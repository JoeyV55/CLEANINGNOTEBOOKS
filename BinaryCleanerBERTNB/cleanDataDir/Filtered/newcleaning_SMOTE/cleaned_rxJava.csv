prNumber,Util,Network,Interpreter,i18n,Logic,Test,IO,App,corpus
138,1,0,0,0,0,0,1,0,implemented sequenceequal operator fixes issue since there is no direct analogue of iequalitycomparer in java func has been used nice and great use of the zip operator thank you again mairbek
138,1,0,1,0,0,0,1,0,implemented sequenceequal operator fixes issue since there is no direct analogue of iequalitycomparer in java func has been used nice and great use of the zip operator thank you again mairbek
138,1,0,1,0,0,1,1,1,implemented sequenceequal operator fixes issue since there is no direct analogue of iequalitycomparer in java func has been used nice and great use of the zip operator thank you again mairbek
146,1,0,0,0,0,0,1,0,merge of pull for issue operator takewhile manually merging from mairbek implementation of done by mairbek ive run the unit tests locally and reviewed the code while doing the manual merge looks good so merging into master branch
146,1,0,1,0,0,1,1,1,merge of pull for issue operator takewhile manually merging from mairbek implementation of done by mairbek ive run the unit tests locally and reviewed the code while doing the manual merge looks good so merging into master branch
146,1,0,1,0,0,0,1,0,merge of pull for issue operator takewhile manually merging from mairbek implementation of done by mairbek ive run the unit tests locally and reviewed the code while doing the manual merge looks good so merging into master branch
146,1,0,0,0,0,0,1,0,merge of pull for issue operator takewhile manually merging from mairbek implementation of done by mairbek ive run the unit tests locally and reviewed the code while doing the manual merge looks good so merging into master branch
146,1,0,1,0,0,1,1,1,merge of pull for issue operator takewhile manually merging from mairbek implementation of done by mairbek ive run the unit tests locally and reviewed the code while doing the manual merge looks good so merging into master branch
146,1,0,0,1,1,1,1,1,merge of pull for issue operator takewhile manually merging from mairbek implementation of done by mairbek ive run the unit tests locally and reviewed the code while doing the manual merge looks good so merging into master branch
156,1,0,0,0,0,0,1,0,implemented toiterable operation for issue this would allow to implement other blocking methods like single lastordefault next this looks good merging
156,1,0,1,0,0,1,1,1,implemented toiterable operation for issue this would allow to implement other blocking methods like single lastordefault next this looks good merging
156,1,0,1,0,0,1,1,1,implemented toiterable operation for issue this would allow to implement other blocking methods like single lastordefault next this looks good merging
165,1,0,0,0,0,0,1,0,bug in ranges issue
165,1,0,1,0,0,0,1,0,bug in ranges issue
165,1,0,0,1,1,1,1,1,bug in ranges issue
205,1,0,0,0,0,0,1,0,reimplementation of concat improved handling of observable the old version required all of the observable s to be generated and bufferedbefore the concat could begin if the outer observable was asynchronous itemscould be dropped test added the new version passes the test and does thebest job i could after examining several possible strategies of achievingclear and consistent semantics in accordance with the principle of leastsurprise my attempt to there is another issue with this implementation the countdown latch will always block the calling thread which is not desirable anything that returns an observable should never be blocking rx is meant to support composition of operations and allows each operation to run concurrently while reviewing this i started playing with the unit tests and added new ones i also made them use inorderverify so they ensure correct ordering ive pasted it below so you can merge into your branch instead of me complicating the merge with another branch the tests pass pass except testconcatunsubscribe which deadlocks it does this because a list wont return the subscription asynchronously so it cant unsubscribe meanwhile a countdownlatch is waiting for the change to trigger and the two latches end up waiting on each otheri havent thought through enough yet to determine if there is a way to solve that or if the unit test is just testing the wrong thing and thus a bad testthe comment above from billy about countdownlatch originated from a discussion between him and i but while reviewing this it is probably the right approachi was playing with other approaches that are purely non blocking while retaining the correct concat sequential behavior but they all seem to require either another wrapping thread stealing work from one of the child observable threads and making it do work that is queued on the others and that seems like a bad idea even though it can be hacked to work but it does so in a way that is very unexpected and thus not something i want to pursue queueing all onnext values which could be a bad memory issue and also means we eagerly subscribe which is not what we wantmy biggest issue right now is that concat o o is a very common usage but that results in list which will be blocking and unsubscribe doesnt workill think through this more but id appreciate your thoughts on how to handle testconcatunsubscribe java public static class unittest { test public void testconcat { suppresswarnings unchecked observer observer mock observerclass final string o { } final string e { } final observable odds observabletoobservable o final observable even observabletoobservable e suppresswarnings unchecked observable concat observablecreate concat odds even concatsubscribe observer verify observer times onnext anystring } test public void testconcatwithlist { suppresswarnings unchecked observer observer mock observerclass final string o { } final string e { } final observable odds observabletoobservable o final observable even observabletoobservable e final list list new arraylist listadd odds listadd even observable concat observablecreate concat list concatsubscribe observer verify observer times onnext anystring } test public void testconcatunsubscribe { final countdownlatch callonce new countdownlatch final countdownlatch oktocontinue new countdownlatch final testobservable w new testobservable one two three final testobservable w new testobservable callonce oktocontinue four five six suppresswarnings unchecked observer aobserver mock observerclass suppresswarnings unchecked observable concat observablecreate concat w w systemoutprintln before subscribe subscription s concatsubscribe aobserver systemoutprintln after subscribe try { block main thread to allow observable w to complete and observable w to call onnext once systemoutprintln before callonceawait callonceawait systemoutprintln after callonceawait s unsubscribe systemoutprintln after s unsubscribe unblock the observable to continue oktocontinuecountdown systemoutprintln after countdown w tjoin w tjoin } catch exception e { eprintstacktrace fail egetmessage } inorder inorder inorder aobserver inorderverify aobserver times onnext one inorderverify aobserver times onnext two inorderverify aobserver times onnext three inorderverify aobserver times onnext four inorderverify aobserver never onnext five inorderverify aobserver never onnext six inorderverify aobserver times oncompleted } test public void testmergeobservableofobservables { suppresswarnings unchecked observer observer mock observerclass final string o { } final string e { } final observable odds observabletoobservable o final observable even observabletoobservable e observable observableofobservables observablecreate new func subscription { override public subscription call observer observer { simulate what would happen in an observable observeronnext odds observeronnext even observeroncompleted return new subscription { override public void unsubscribe { unregister will never be called here since we are executing synchronously } } } } observable concat observablecreate concat observableofobservables concatsubscribe observer verify observer times onnext anystring } simple concat of asynchronous observables ensuring it emits in correct order suppresswarnings unchecked test public void testsimpleasyncconcat { observer observer mock observerclass testobservable o new testobservable one two three testobservable o new testobservable four five six observableconcat o o subscribe observer try { wait for async observables to complete o tjoin o tjoin } catch exception e { throw new runtimeexception failed waiting on threads } inorder inorder inorder observer inorderverify observer times onnext one inorderverify observer times onnext two inorderverify observer times onnext three inorderverify observer times onnext four inorderverify observer times onnext five inorderverify observer times onnext six } test an async observable that emits more async observables suppresswarnings unchecked test public void testnestedasyncconcat throws exception { observer observer mock observerclass final testobservable o new testobservable one two three final testobservable o new testobservable four five six final testobservable o new testobservable seven eight nine final countdownlatch allowthird new countdownlatch final atomicreference parent new atomicreference observable observableofobservables observablecreate new func subscription { override public subscription call final observer observer { final booleansubscription s new booleansubscription parentset new thread new runnable { override public void run { try { emit first if sisunsubscribed { systemoutprintln emit o observeronnext o } emit second if sisunsubscribed { systemoutprintln emit o observeronnext o } wait until sometime later and emit third try { allowthirdawait } catch interruptedexception e { observeronerror e } if sisunsubscribed { systemoutprintln emit o observeronnext o } } catch exception e { observeronerror e } finally { systemoutprintln done parent observable observeroncompleted } } } parentget start return s } } observablecreate concat observableofobservables subscribe observer wait for parent to start while parentget null { threadsleep } try { wait for first async observables to complete while o t null { threadsleep } systemoutprintln thread started waiting for it to complete o tjoin while o t null { threadsleep } systemoutprintln thread started waiting for it to complete o tjoin } catch exception e { throw new runtimeexception failed waiting on threads e } inorder inorder inorder observer inorderverify observer times onnext one inorderverify observer times onnext two inorderverify observer times onnext three inorderverify observer times onnext four inorderverify observer times onnext five inorderverify observer times onnext six we shouldnt have the following yet inorderverify observer never onnext seven inorderverify observer never onnext eight inorderverify observer never onnext nine we should not be completed yet verify observer never oncompleted verify observer never onerror any exceptionclass now allow the third allowthirdcountdown try { while o t null { threadsleep } wait for rd to complete o tjoin } catch exception e { throw new runtimeexception failed waiting on threads e } inorderverify observer times onnext seven inorderverify observer times onnext eight inorderverify observer times onnext nine inorderverify observer times oncompleted verify observer never onerror any exceptionclass } suppresswarnings unchecked test public void testblockedobservableofobservables { observer observer mock observerclass final string o { } final string e { } final observable odds observabletoobservable o final observable even observabletoobservable e final countdownlatch callonce new countdownlatch final countdownlatch oktocontinue new countdownlatch testobservable observableofobservables new testobservable callonce oktocontinue odds even func subscription concatf concat observableofobservables observable concat observablecreate concatf concatsubscribe observer try { block main thread to allow observables to serve up o callonceawait } catch exception ex { exprintstacktrace fail exgetmessage } the concated observable should have served up all of the odds verify observer times onnext verify observer times onnext verify observer times onnext verify observer times onnext try { unblock observables so it can serve up o and complete oktocontinuecountdown observableofobservablestjoin } catch exception ex { exprintstacktrace fail exgetmessage } the concatenated observable should now have served up all the evens verify observer times onnext verify observer times onnext verify observer times onnext } private static class testobservable extends observable { private final subscription s new subscription { override public void unsubscribe { subscribed false } } private final list values private thread t null private int count private boolean subscribed true private final countdownlatch once private final countdownlatch oktocontinue public testobservable t values { this null null values } public testobservable countdownlatch once countdownlatch oktocontinue t values { thisvalues arraysaslist values thisonce once thisoktocontinue oktocontinue } override public subscription subscribe final observer observer { t new thread new runnable { override public void run { try { while count while reviewing this i started playing with the unit tests and added new ones i also made them use inorderverify so they ensure correct ordering ive pasted it below so you can merge into your branch instead of me complicating the merge with another branch the tests pass pass except testconcatunsubscribe which deadlocks it does this because a list wont return the subscription asynchronously so it cant unsubscribe meanwhile a countdownlatch is waiting for the change to trigger and the two latches end up waiting on each other i havent thought through enough yet to determine if there is a way to solve that or if the unit test is just testing the wrong thing and thus a bad test the comment above from billy about countdownlatch originated from a discussion between him and i but while reviewing this it is probably the right approach i was playing with other approaches that are purely non blocking while retaining the correct concat sequential behavior but they all seem to require either another wrapping thread stealing work from one of the child observable threads and making it do work that is queued on the others and that seems like a bad idea even though it can be hacked to work but it does so in a way that is very unexpected and thus not something i want to pursue queueing all onnext values which could be a bad memory issue and also means we eagerly subscribe which is not what we want my biggest issue right now is that concat o o is a very common usage but that results in list which will be blocking and unsubscribe doesnt work ill think through this more but id appreciate your thoughts on how to handle testconcatunsubscribe public static class unittest { test public void testconcat { suppresswarnings unchecked observer observer mock observerclass final string o { } final string e { } final observable odds observabletoobservable o final observable even observabletoobservable e suppresswarnings unchecked observable concat observablecreate concat odds even concatsubscribe observer verify observer times onnext anystring } test public void testconcatwithlist { suppresswarnings unchecked observer observer mock observerclass final string o { } final string e { } final observable odds observabletoobservable o final observable even observabletoobservable e final list list new arraylist listadd odds listadd even observable concat observablecreate concat list concatsubscribe observer verify observer times onnext anystring } test public void testconcatunsubscribe { final countdownlatch callonce new countdownlatch final countdownlatch oktocontinue new countdownlatch final testobservable w new testobservable one two three final testobservable w new testobservable callonce oktocontinue four five six suppresswarnings unchecked observer aobserver mock observerclass suppresswarnings unchecked observable concat observablecreate concat w w systemoutprintln before subscribe subscription s concatsubscribe aobserver systemoutprintln after subscribe try { block main thread to allow observable w to complete and observable w to call onnext once systemoutprintln before callonceawait callonceawait systemoutprintln after callonceawait s unsubscribe systemoutprintln after s unsubscribe unblock the observable to continue oktocontinuecountdown systemoutprintln after countdown w tjoin w tjoin } catch exception e { eprintstacktrace fail egetmessage } inorder inorder inorder aobserver inorderverify aobserver times onnext one inorderverify aobserver times onnext two inorderverify aobserver times onnext three inorderverify aobserver times onnext four inorderverify aobserver never onnext five inorderverify aobserver never onnext six inorderverify aobserver times oncompleted } test public void testmergeobservableofobservables { suppresswarnings unchecked observer observer mock observerclass final string o { } final string e { } final observable odds observabletoobservable o final observable even observabletoobservable e observable observableofobservables observablecreate new func subscription { override public subscription call observer observer { simulate what would happen in an observable observeronnext odds observeronnext even observeroncompleted return new subscription { override public void unsubscribe { unregister will never be called here since we are executing synchronously } } } } observable concat observablecreate concat observableofobservables concatsubscribe observer verify observer times onnext anystring } simple concat of asynchronous observables ensuring it emits in correct order suppresswarnings unchecked test public void testsimpleasyncconcat { observer observer mock observerclass testobservable o new testobservable one two three testobservable o new testobservable four five six observableconcat o o subscribe observer try { wait for async observables to complete o tjoin o tjoin } catch exception e { throw new runtimeexception failed waiting on threads } inorder inorder inorder observer inorderverify observer times onnext one inorderverify observer times onnext two inorderverify observer times onnext three inorderverify observer times onnext four inorderverify observer times onnext five inorderverify observer times onnext six } test an async observable that emits more async observables suppresswarnings unchecked test public void testnestedasyncconcat throws exception { observer observer mock observerclass final testobservable o new testobservable one two three final testobservable o new testobservable four five six final testobservable o new testobservable seven eight nine final countdownlatch allowthird new countdownlatch final atomicreference parent new atomicreference observable observableofobservables observablecreate new func subscription { override public subscription call final observer observer { final booleansubscription s new booleansubscription parentset new thread new runnable { override public void run { try { emit first if sisunsubscribed { systemoutprintln emit o observeronnext o } emit second if sisunsubscribed { systemoutprintln emit o observeronnext o } wait until sometime later and emit third try { allowthirdawait } catch interruptedexception e { observeronerror e } if sisunsubscribed { systemoutprintln emit o observeronnext o } } catch exception e { observeronerror e } finally { systemoutprintln done parent observable observeroncompleted } } } parentget start return s } } observablecreate concat observableofobservables subscribe observer wait for parent to start while parentget null { threadsleep } try { wait for first async observables to complete while o t null { threadsleep } systemoutprintln thread started waiting for it to complete o tjoin while o t null { threadsleep } systemoutprintln thread started waiting for it to complete o tjoin } catch exception e { throw new runtimeexception failed waiting on threads e } inorder inorder inorder observer inorderverify observer times onnext one inorderverify observer times onnext two inorderverify observer times onnext three inorderverify observer times onnext four inorderverify observer times onnext five inorderverify observer times onnext six we shouldnt have the following yet inorderverify observer never onnext seven inorderverify observer never onnext eight inorderverify observer never onnext nine we should not be completed yet verify observer never oncompleted verify observer never onerror any exceptionclass now allow the third allowthirdcountdown try { while o t null { threadsleep } wait for rd to complete o tjoin } catch exception e { throw new runtimeexception failed waiting on threads e } inorderverify observer times onnext seven inorderverify observer times onnext eight inorderverify observer times onnext nine inorderverify observer times oncompleted verify observer never onerror any exceptionclass } suppresswarnings unchecked test public void testblockedobservableofobservables { observer observer mock observerclass final string o { } final string e { } final observable odds observabletoobservable o final observable even observabletoobservable e final countdownlatch callonce new countdownlatch final countdownlatch oktocontinue new countdownlatch testobservable observableofobservables new testobservable callonce oktocontinue odds even func subscription concatf concat observableofobservables observable concat observablecreate concatf concatsubscribe observer try { block main thread to allow observables to serve up o callonceawait } catch exception ex { exprintstacktrace fail exgetmessage } the concated observable should have served up all of the odds verify observer times onnext verify observer times onnext verify observer times onnext verify observer times onnext try { unblock observables so it can serve up o and complete oktocontinuecountdown observableofobservablestjoin } catch exception ex { exprintstacktrace fail exgetmessage } the concatenated observable should now have served up all the evens verify observer times onnext verify observer times onnext verify observer times onnext } private static class testobservable extends observable { private final subscription s new subscription { override public void unsubscribe { subscribed false } } private final list values private thread t null private int count private boolean subscribed true private final countdownlatch once private final countdownlatch oktocontinue public testobservable t values { this null null values } public testobservable countdownlatch once countdownlatch oktocontinue t values { thisvalues arraysaslist values thisonce once thisoktocontinue oktocontinue } override public subscription subscribe final observer observer { t new thread new runnable { override public void run { try { while count observeronnext valuesget count count unblock the main thread to call unsubscribe if null once oncecountdown block until the main thread has called unsubscribe if null once oktocontinueawait } if subscribed observeroncompleted } catch interruptedexception e { eprintstacktrace fail egetmessage } } } tstart return s } } }  reply to this email directly or view it on github thanks for update let me take a look and i will do some moreresearch thought on the testconcatsubscribe test caseon fri mar at am cloudbees pull request builder plugin wrote rxjava pull requests this pull request looks good — reply to this email directly or view it on github rxjava pull requests looks good my original test case was intended to test the unsubscribe inside one ofchild observable the countdownlatch was used so that the code will havea chance to unsubscribe in a predicable manner unsubscribe after four in a normal case there should be no blocking between inner and outerobservable i rewrote the case for better clarity and having the outerobservable is in a separate thread so the test will pass now youbrought up a good point about when you can unsubscribe should it onlyallow unsubscribe to happen during the outer onnext i need to do moreresearch on it here is the test i plan to add test public void testconcatunsubscribeobservableofobservable { final countdownlatch callonce new countdownlatch final countdownlatch oktocontinue new countdownlatch final testobservable w new testobservable one two three final testobservable w newtestobservable callonce oktocontinuefour five six suppresswarnings unchecked observer aobserver mock observerclass suppresswarnings unchecked testobservable observableofobservables newtestobservable w w func subscription concatf concat observableofobservables observable concat observablecreate concatf subscription s concatsubscribe aobserver try { block main thread to allow observable w to complete and observable w to call onnext exactly once callonceawait four has been processed by onnext s unsubscribe five and six will not be processed by onnext unblock the observable to continue oktocontinuecountdown w tjoin w tjoin } catch exception e { eprintstacktrace fail egetmessage } inorder inorder inorder aobserver inorderverify aobserver times onnext one inorderverify aobserver times onnext two inorderverify aobserver times onnext three inorderverify aobserver times onnext four inorderverify aobserver never onnext five inorderverify aobserver never onnext six verify aobserver never oncompleted verify aobserver never onerror any exceptionclass }on tue apr at pm cloudbees pull request builder plugin wrote rxjava pull requests this pull request looks good — reply to this email directly or view it on github the rx net version of concat uses the immediatescheduler to execute theoperation which will execute the operation on the same calling thread soif the observables are running on the same thread it will besynchronous blocked i have pulled in your changes from your fork andadded the additional unit test to test unsubscribe with observablesrunning in different thread i have also updated the javadoc about theblocking with observable on the same thread from my side it looks goodon wed apr at am billy yuen billyy gmailcom wrote my original test case was intended to test the unsubscribe inside one of child observable the countdownlatch was used so that the code will have a chance to unsubscribe in a predicable manner unsubscribe after four in a normal case there should be no blocking between inner and outer observable i rewrote the case for better clarity and having the outer observable is in a separate thread so the test will pass now you brought up a good point about when you can unsubscribe should it only allow unsubscribe to happen during the outer onnext i need to do more research on it here is the test i plan to add test public void testconcatunsubscribeobservableofobservable { final countdownlatch callonce new countdownlatch final countdownlatch oktocontinue new countdownlatch final testobservable w new testobservable one two three final testobservable w newtestobservable callonce oktocontinue four five six suppresswarnings unchecked observer aobserver mock observerclass suppresswarnings unchecked testobservable observableofobservables newtestobservable w w func subscription concatf concat observableofobservables observable concat observablecreate concatf subscription s concatsubscribe aobserver try { block main thread to allow observable w to complete and observable w to call onnext exactly once callonceawait four has been processed by onnext s unsubscribe five and six will not be processed by onnext unblock the observable to continue oktocontinuecountdown w tjoin w tjoin } catch exception e { eprintstacktrace fail egetmessage } inorder inorder inorder aobserver inorderverify aobserver times onnext one inorderverify aobserver times onnext two inorderverify aobserver times onnext three inorderverify aobserver times onnext four inorderverify aobserver never onnext five inorderverify aobserver never onnext six verify aobserver never oncompleted verify aobserver never onerror any exceptionclass } on tue apr at pm cloudbees pull request builder plugin notifications githubcom wrote rxjava pull requests this pull request looks good — reply to this email directly or view it on github i do find it a little strange that observablefrom iterable is a shotgun observable ie the subscribe blocks until all downstream operations have completed on all items which means it is impossible to ever unsubscribe but given that this is correct behavior i think that it makes sense that concat o o also cannot be unsubscribed from i added a cautionary comment to the javadocrx does not or rarely does add concurrency see guideline thus observablefrom is wrapping a synchronous iterable therefore the observable will be synchronousa scheduler could be used to make the subscription to an iterable happen on another thread or a custom observable could be created that handles an iterable asynchronouslyall rx operators must be capable of handling both synchronous and asynchronous sequences and if its synchronous that means unsubscribe will not work which means its up to the implementor of an observable to understand this and decided if its okay to firehose the results for the case of concat my concern is that if all the sequences being combined are async then we need to retain the async behavior and not block and prevent unsubscriptionfor example async or synchronous observablea with items async or synchronous observableb with items async observablec with infinite items hot observable that never completed i should be able to do this concat a b c take this should get the items from a items from b and first items from c and then unsubscribe and continuedoes this work with the current implementation and correctly unsubscribe from observablec good point the best way to tell is to build an unit test for this case i can expand my new test to include this case and see what happenon wed apr at pm ben christensen notifications githubcomwrote i do find it a little strange that observablefrom iterable is a shotgun observable ie the subscribe blocks until all downstream operations have completed on all items which means it is impossible to ever unsubscribe but given that this is correct behavior i think that it makes sense that concat o o also cannot be unsubscribed from i added a cautionary comment to the javadoc rx does not or rarely does add concurrency see guideline thus observablefrom is wrapping a synchronous iterable therefore the observable will be synchronous a scheduler could be used to make the subscription to an iterable happen on another thread or a custom observable could be created that handles an iterable asynchronously all rx operators must be capable of handling both synchronous and asynchronous sequences and if its synchronous that means unsubscribe will not work which means its up to the implementor of an observable to understand this and decided if its okay to firehose the results for the case of concat my concern is that if all the sequences being combined are async then we need to retain the async behavior and not block and prevent unsubscription for example async or synchronous observablea with items async or synchronous observableb with items async observablec with infinite items hot observable that never completed i should be able to do this concat a b c take this should get the items from a items from b and first items from c and then unsubscribe and continue does this work with the current implementation and correctly unsubscribe from observablec — reply to this email directly or view it on github
205,1,0,1,0,0,0,1,0,reimplementation of concat improved handling of observable the old version required all of the observable s to be generated and bufferedbefore the concat could begin if the outer observable was asynchronous itemscould be dropped test added the new version passes the test and does thebest job i could after examining several possible strategies of achievingclear and consistent semantics in accordance with the principle of leastsurprise my attempt to there is another issue with this implementation the countdown latch will always block the calling thread which is not desirable anything that returns an observable should never be blocking rx is meant to support composition of operations and allows each operation to run concurrently while reviewing this i started playing with the unit tests and added new ones i also made them use inorderverify so they ensure correct ordering ive pasted it below so you can merge into your branch instead of me complicating the merge with another branch the tests pass pass except testconcatunsubscribe which deadlocks it does this because a list wont return the subscription asynchronously so it cant unsubscribe meanwhile a countdownlatch is waiting for the change to trigger and the two latches end up waiting on each otheri havent thought through enough yet to determine if there is a way to solve that or if the unit test is just testing the wrong thing and thus a bad testthe comment above from billy about countdownlatch originated from a discussion between him and i but while reviewing this it is probably the right approachi was playing with other approaches that are purely non blocking while retaining the correct concat sequential behavior but they all seem to require either another wrapping thread stealing work from one of the child observable threads and making it do work that is queued on the others and that seems like a bad idea even though it can be hacked to work but it does so in a way that is very unexpected and thus not something i want to pursue queueing all onnext values which could be a bad memory issue and also means we eagerly subscribe which is not what we wantmy biggest issue right now is that concat o o is a very common usage but that results in list which will be blocking and unsubscribe doesnt workill think through this more but id appreciate your thoughts on how to handle testconcatunsubscribe java public static class unittest { test public void testconcat { suppresswarnings unchecked observer observer mock observerclass final string o { } final string e { } final observable odds observabletoobservable o final observable even observabletoobservable e suppresswarnings unchecked observable concat observablecreate concat odds even concatsubscribe observer verify observer times onnext anystring } test public void testconcatwithlist { suppresswarnings unchecked observer observer mock observerclass final string o { } final string e { } final observable odds observabletoobservable o final observable even observabletoobservable e final list list new arraylist listadd odds listadd even observable concat observablecreate concat list concatsubscribe observer verify observer times onnext anystring } test public void testconcatunsubscribe { final countdownlatch callonce new countdownlatch final countdownlatch oktocontinue new countdownlatch final testobservable w new testobservable one two three final testobservable w new testobservable callonce oktocontinue four five six suppresswarnings unchecked observer aobserver mock observerclass suppresswarnings unchecked observable concat observablecreate concat w w systemoutprintln before subscribe subscription s concatsubscribe aobserver systemoutprintln after subscribe try { block main thread to allow observable w to complete and observable w to call onnext once systemoutprintln before callonceawait callonceawait systemoutprintln after callonceawait s unsubscribe systemoutprintln after s unsubscribe unblock the observable to continue oktocontinuecountdown systemoutprintln after countdown w tjoin w tjoin } catch exception e { eprintstacktrace fail egetmessage } inorder inorder inorder aobserver inorderverify aobserver times onnext one inorderverify aobserver times onnext two inorderverify aobserver times onnext three inorderverify aobserver times onnext four inorderverify aobserver never onnext five inorderverify aobserver never onnext six inorderverify aobserver times oncompleted } test public void testmergeobservableofobservables { suppresswarnings unchecked observer observer mock observerclass final string o { } final string e { } final observable odds observabletoobservable o final observable even observabletoobservable e observable observableofobservables observablecreate new func subscription { override public subscription call observer observer { simulate what would happen in an observable observeronnext odds observeronnext even observeroncompleted return new subscription { override public void unsubscribe { unregister will never be called here since we are executing synchronously } } } } observable concat observablecreate concat observableofobservables concatsubscribe observer verify observer times onnext anystring } simple concat of asynchronous observables ensuring it emits in correct order suppresswarnings unchecked test public void testsimpleasyncconcat { observer observer mock observerclass testobservable o new testobservable one two three testobservable o new testobservable four five six observableconcat o o subscribe observer try { wait for async observables to complete o tjoin o tjoin } catch exception e { throw new runtimeexception failed waiting on threads } inorder inorder inorder observer inorderverify observer times onnext one inorderverify observer times onnext two inorderverify observer times onnext three inorderverify observer times onnext four inorderverify observer times onnext five inorderverify observer times onnext six } test an async observable that emits more async observables suppresswarnings unchecked test public void testnestedasyncconcat throws exception { observer observer mock observerclass final testobservable o new testobservable one two three final testobservable o new testobservable four five six final testobservable o new testobservable seven eight nine final countdownlatch allowthird new countdownlatch final atomicreference parent new atomicreference observable observableofobservables observablecreate new func subscription { override public subscription call final observer observer { final booleansubscription s new booleansubscription parentset new thread new runnable { override public void run { try { emit first if sisunsubscribed { systemoutprintln emit o observeronnext o } emit second if sisunsubscribed { systemoutprintln emit o observeronnext o } wait until sometime later and emit third try { allowthirdawait } catch interruptedexception e { observeronerror e } if sisunsubscribed { systemoutprintln emit o observeronnext o } } catch exception e { observeronerror e } finally { systemoutprintln done parent observable observeroncompleted } } } parentget start return s } } observablecreate concat observableofobservables subscribe observer wait for parent to start while parentget null { threadsleep } try { wait for first async observables to complete while o t null { threadsleep } systemoutprintln thread started waiting for it to complete o tjoin while o t null { threadsleep } systemoutprintln thread started waiting for it to complete o tjoin } catch exception e { throw new runtimeexception failed waiting on threads e } inorder inorder inorder observer inorderverify observer times onnext one inorderverify observer times onnext two inorderverify observer times onnext three inorderverify observer times onnext four inorderverify observer times onnext five inorderverify observer times onnext six we shouldnt have the following yet inorderverify observer never onnext seven inorderverify observer never onnext eight inorderverify observer never onnext nine we should not be completed yet verify observer never oncompleted verify observer never onerror any exceptionclass now allow the third allowthirdcountdown try { while o t null { threadsleep } wait for rd to complete o tjoin } catch exception e { throw new runtimeexception failed waiting on threads e } inorderverify observer times onnext seven inorderverify observer times onnext eight inorderverify observer times onnext nine inorderverify observer times oncompleted verify observer never onerror any exceptionclass } suppresswarnings unchecked test public void testblockedobservableofobservables { observer observer mock observerclass final string o { } final string e { } final observable odds observabletoobservable o final observable even observabletoobservable e final countdownlatch callonce new countdownlatch final countdownlatch oktocontinue new countdownlatch testobservable observableofobservables new testobservable callonce oktocontinue odds even func subscription concatf concat observableofobservables observable concat observablecreate concatf concatsubscribe observer try { block main thread to allow observables to serve up o callonceawait } catch exception ex { exprintstacktrace fail exgetmessage } the concated observable should have served up all of the odds verify observer times onnext verify observer times onnext verify observer times onnext verify observer times onnext try { unblock observables so it can serve up o and complete oktocontinuecountdown observableofobservablestjoin } catch exception ex { exprintstacktrace fail exgetmessage } the concatenated observable should now have served up all the evens verify observer times onnext verify observer times onnext verify observer times onnext } private static class testobservable extends observable { private final subscription s new subscription { override public void unsubscribe { subscribed false } } private final list values private thread t null private int count private boolean subscribed true private final countdownlatch once private final countdownlatch oktocontinue public testobservable t values { this null null values } public testobservable countdownlatch once countdownlatch oktocontinue t values { thisvalues arraysaslist values thisonce once thisoktocontinue oktocontinue } override public subscription subscribe final observer observer { t new thread new runnable { override public void run { try { while count while reviewing this i started playing with the unit tests and added new ones i also made them use inorderverify so they ensure correct ordering ive pasted it below so you can merge into your branch instead of me complicating the merge with another branch the tests pass pass except testconcatunsubscribe which deadlocks it does this because a list wont return the subscription asynchronously so it cant unsubscribe meanwhile a countdownlatch is waiting for the change to trigger and the two latches end up waiting on each other i havent thought through enough yet to determine if there is a way to solve that or if the unit test is just testing the wrong thing and thus a bad test the comment above from billy about countdownlatch originated from a discussion between him and i but while reviewing this it is probably the right approach i was playing with other approaches that are purely non blocking while retaining the correct concat sequential behavior but they all seem to require either another wrapping thread stealing work from one of the child observable threads and making it do work that is queued on the others and that seems like a bad idea even though it can be hacked to work but it does so in a way that is very unexpected and thus not something i want to pursue queueing all onnext values which could be a bad memory issue and also means we eagerly subscribe which is not what we want my biggest issue right now is that concat o o is a very common usage but that results in list which will be blocking and unsubscribe doesnt work ill think through this more but id appreciate your thoughts on how to handle testconcatunsubscribe public static class unittest { test public void testconcat { suppresswarnings unchecked observer observer mock observerclass final string o { } final string e { } final observable odds observabletoobservable o final observable even observabletoobservable e suppresswarnings unchecked observable concat observablecreate concat odds even concatsubscribe observer verify observer times onnext anystring } test public void testconcatwithlist { suppresswarnings unchecked observer observer mock observerclass final string o { } final string e { } final observable odds observabletoobservable o final observable even observabletoobservable e final list list new arraylist listadd odds listadd even observable concat observablecreate concat list concatsubscribe observer verify observer times onnext anystring } test public void testconcatunsubscribe { final countdownlatch callonce new countdownlatch final countdownlatch oktocontinue new countdownlatch final testobservable w new testobservable one two three final testobservable w new testobservable callonce oktocontinue four five six suppresswarnings unchecked observer aobserver mock observerclass suppresswarnings unchecked observable concat observablecreate concat w w systemoutprintln before subscribe subscription s concatsubscribe aobserver systemoutprintln after subscribe try { block main thread to allow observable w to complete and observable w to call onnext once systemoutprintln before callonceawait callonceawait systemoutprintln after callonceawait s unsubscribe systemoutprintln after s unsubscribe unblock the observable to continue oktocontinuecountdown systemoutprintln after countdown w tjoin w tjoin } catch exception e { eprintstacktrace fail egetmessage } inorder inorder inorder aobserver inorderverify aobserver times onnext one inorderverify aobserver times onnext two inorderverify aobserver times onnext three inorderverify aobserver times onnext four inorderverify aobserver never onnext five inorderverify aobserver never onnext six inorderverify aobserver times oncompleted } test public void testmergeobservableofobservables { suppresswarnings unchecked observer observer mock observerclass final string o { } final string e { } final observable odds observabletoobservable o final observable even observabletoobservable e observable observableofobservables observablecreate new func subscription { override public subscription call observer observer { simulate what would happen in an observable observeronnext odds observeronnext even observeroncompleted return new subscription { override public void unsubscribe { unregister will never be called here since we are executing synchronously } } } } observable concat observablecreate concat observableofobservables concatsubscribe observer verify observer times onnext anystring } simple concat of asynchronous observables ensuring it emits in correct order suppresswarnings unchecked test public void testsimpleasyncconcat { observer observer mock observerclass testobservable o new testobservable one two three testobservable o new testobservable four five six observableconcat o o subscribe observer try { wait for async observables to complete o tjoin o tjoin } catch exception e { throw new runtimeexception failed waiting on threads } inorder inorder inorder observer inorderverify observer times onnext one inorderverify observer times onnext two inorderverify observer times onnext three inorderverify observer times onnext four inorderverify observer times onnext five inorderverify observer times onnext six } test an async observable that emits more async observables suppresswarnings unchecked test public void testnestedasyncconcat throws exception { observer observer mock observerclass final testobservable o new testobservable one two three final testobservable o new testobservable four five six final testobservable o new testobservable seven eight nine final countdownlatch allowthird new countdownlatch final atomicreference parent new atomicreference observable observableofobservables observablecreate new func subscription { override public subscription call final observer observer { final booleansubscription s new booleansubscription parentset new thread new runnable { override public void run { try { emit first if sisunsubscribed { systemoutprintln emit o observeronnext o } emit second if sisunsubscribed { systemoutprintln emit o observeronnext o } wait until sometime later and emit third try { allowthirdawait } catch interruptedexception e { observeronerror e } if sisunsubscribed { systemoutprintln emit o observeronnext o } } catch exception e { observeronerror e } finally { systemoutprintln done parent observable observeroncompleted } } } parentget start return s } } observablecreate concat observableofobservables subscribe observer wait for parent to start while parentget null { threadsleep } try { wait for first async observables to complete while o t null { threadsleep } systemoutprintln thread started waiting for it to complete o tjoin while o t null { threadsleep } systemoutprintln thread started waiting for it to complete o tjoin } catch exception e { throw new runtimeexception failed waiting on threads e } inorder inorder inorder observer inorderverify observer times onnext one inorderverify observer times onnext two inorderverify observer times onnext three inorderverify observer times onnext four inorderverify observer times onnext five inorderverify observer times onnext six we shouldnt have the following yet inorderverify observer never onnext seven inorderverify observer never onnext eight inorderverify observer never onnext nine we should not be completed yet verify observer never oncompleted verify observer never onerror any exceptionclass now allow the third allowthirdcountdown try { while o t null { threadsleep } wait for rd to complete o tjoin } catch exception e { throw new runtimeexception failed waiting on threads e } inorderverify observer times onnext seven inorderverify observer times onnext eight inorderverify observer times onnext nine inorderverify observer times oncompleted verify observer never onerror any exceptionclass } suppresswarnings unchecked test public void testblockedobservableofobservables { observer observer mock observerclass final string o { } final string e { } final observable odds observabletoobservable o final observable even observabletoobservable e final countdownlatch callonce new countdownlatch final countdownlatch oktocontinue new countdownlatch testobservable observableofobservables new testobservable callonce oktocontinue odds even func subscription concatf concat observableofobservables observable concat observablecreate concatf concatsubscribe observer try { block main thread to allow observables to serve up o callonceawait } catch exception ex { exprintstacktrace fail exgetmessage } the concated observable should have served up all of the odds verify observer times onnext verify observer times onnext verify observer times onnext verify observer times onnext try { unblock observables so it can serve up o and complete oktocontinuecountdown observableofobservablestjoin } catch exception ex { exprintstacktrace fail exgetmessage } the concatenated observable should now have served up all the evens verify observer times onnext verify observer times onnext verify observer times onnext } private static class testobservable extends observable { private final subscription s new subscription { override public void unsubscribe { subscribed false } } private final list values private thread t null private int count private boolean subscribed true private final countdownlatch once private final countdownlatch oktocontinue public testobservable t values { this null null values } public testobservable countdownlatch once countdownlatch oktocontinue t values { thisvalues arraysaslist values thisonce once thisoktocontinue oktocontinue } override public subscription subscribe final observer observer { t new thread new runnable { override public void run { try { while count observeronnext valuesget count count unblock the main thread to call unsubscribe if null once oncecountdown block until the main thread has called unsubscribe if null once oktocontinueawait } if subscribed observeroncompleted } catch interruptedexception e { eprintstacktrace fail egetmessage } } } tstart return s } } }  reply to this email directly or view it on github thanks for update let me take a look and i will do some moreresearch thought on the testconcatsubscribe test caseon fri mar at am cloudbees pull request builder plugin wrote rxjava pull requests this pull request looks good — reply to this email directly or view it on github rxjava pull requests looks good my original test case was intended to test the unsubscribe inside one ofchild observable the countdownlatch was used so that the code will havea chance to unsubscribe in a predicable manner unsubscribe after four in a normal case there should be no blocking between inner and outerobservable i rewrote the case for better clarity and having the outerobservable is in a separate thread so the test will pass now youbrought up a good point about when you can unsubscribe should it onlyallow unsubscribe to happen during the outer onnext i need to do moreresearch on it here is the test i plan to add test public void testconcatunsubscribeobservableofobservable { final countdownlatch callonce new countdownlatch final countdownlatch oktocontinue new countdownlatch final testobservable w new testobservable one two three final testobservable w newtestobservable callonce oktocontinuefour five six suppresswarnings unchecked observer aobserver mock observerclass suppresswarnings unchecked testobservable observableofobservables newtestobservable w w func subscription concatf concat observableofobservables observable concat observablecreate concatf subscription s concatsubscribe aobserver try { block main thread to allow observable w to complete and observable w to call onnext exactly once callonceawait four has been processed by onnext s unsubscribe five and six will not be processed by onnext unblock the observable to continue oktocontinuecountdown w tjoin w tjoin } catch exception e { eprintstacktrace fail egetmessage } inorder inorder inorder aobserver inorderverify aobserver times onnext one inorderverify aobserver times onnext two inorderverify aobserver times onnext three inorderverify aobserver times onnext four inorderverify aobserver never onnext five inorderverify aobserver never onnext six verify aobserver never oncompleted verify aobserver never onerror any exceptionclass }on tue apr at pm cloudbees pull request builder plugin wrote rxjava pull requests this pull request looks good — reply to this email directly or view it on github the rx net version of concat uses the immediatescheduler to execute theoperation which will execute the operation on the same calling thread soif the observables are running on the same thread it will besynchronous blocked i have pulled in your changes from your fork andadded the additional unit test to test unsubscribe with observablesrunning in different thread i have also updated the javadoc about theblocking with observable on the same thread from my side it looks goodon wed apr at am billy yuen billyy gmailcom wrote my original test case was intended to test the unsubscribe inside one of child observable the countdownlatch was used so that the code will have a chance to unsubscribe in a predicable manner unsubscribe after four in a normal case there should be no blocking between inner and outer observable i rewrote the case for better clarity and having the outer observable is in a separate thread so the test will pass now you brought up a good point about when you can unsubscribe should it only allow unsubscribe to happen during the outer onnext i need to do more research on it here is the test i plan to add test public void testconcatunsubscribeobservableofobservable { final countdownlatch callonce new countdownlatch final countdownlatch oktocontinue new countdownlatch final testobservable w new testobservable one two three final testobservable w newtestobservable callonce oktocontinue four five six suppresswarnings unchecked observer aobserver mock observerclass suppresswarnings unchecked testobservable observableofobservables newtestobservable w w func subscription concatf concat observableofobservables observable concat observablecreate concatf subscription s concatsubscribe aobserver try { block main thread to allow observable w to complete and observable w to call onnext exactly once callonceawait four has been processed by onnext s unsubscribe five and six will not be processed by onnext unblock the observable to continue oktocontinuecountdown w tjoin w tjoin } catch exception e { eprintstacktrace fail egetmessage } inorder inorder inorder aobserver inorderverify aobserver times onnext one inorderverify aobserver times onnext two inorderverify aobserver times onnext three inorderverify aobserver times onnext four inorderverify aobserver never onnext five inorderverify aobserver never onnext six verify aobserver never oncompleted verify aobserver never onerror any exceptionclass } on tue apr at pm cloudbees pull request builder plugin notifications githubcom wrote rxjava pull requests this pull request looks good — reply to this email directly or view it on github i do find it a little strange that observablefrom iterable is a shotgun observable ie the subscribe blocks until all downstream operations have completed on all items which means it is impossible to ever unsubscribe but given that this is correct behavior i think that it makes sense that concat o o also cannot be unsubscribed from i added a cautionary comment to the javadocrx does not or rarely does add concurrency see guideline thus observablefrom is wrapping a synchronous iterable therefore the observable will be synchronousa scheduler could be used to make the subscription to an iterable happen on another thread or a custom observable could be created that handles an iterable asynchronouslyall rx operators must be capable of handling both synchronous and asynchronous sequences and if its synchronous that means unsubscribe will not work which means its up to the implementor of an observable to understand this and decided if its okay to firehose the results for the case of concat my concern is that if all the sequences being combined are async then we need to retain the async behavior and not block and prevent unsubscriptionfor example async or synchronous observablea with items async or synchronous observableb with items async observablec with infinite items hot observable that never completed i should be able to do this concat a b c take this should get the items from a items from b and first items from c and then unsubscribe and continuedoes this work with the current implementation and correctly unsubscribe from observablec good point the best way to tell is to build an unit test for this case i can expand my new test to include this case and see what happenon wed apr at pm ben christensen notifications githubcomwrote i do find it a little strange that observablefrom iterable is a shotgun observable ie the subscribe blocks until all downstream operations have completed on all items which means it is impossible to ever unsubscribe but given that this is correct behavior i think that it makes sense that concat o o also cannot be unsubscribed from i added a cautionary comment to the javadoc rx does not or rarely does add concurrency see guideline thus observablefrom is wrapping a synchronous iterable therefore the observable will be synchronous a scheduler could be used to make the subscription to an iterable happen on another thread or a custom observable could be created that handles an iterable asynchronously all rx operators must be capable of handling both synchronous and asynchronous sequences and if its synchronous that means unsubscribe will not work which means its up to the implementor of an observable to understand this and decided if its okay to firehose the results for the case of concat my concern is that if all the sequences being combined are async then we need to retain the async behavior and not block and prevent unsubscription for example async or synchronous observablea with items async or synchronous observableb with items async observablec with infinite items hot observable that never completed i should be able to do this concat a b c take this should get the items from a items from b and first items from c and then unsubscribe and continue does this work with the current implementation and correctly unsubscribe from observablec — reply to this email directly or view it on github
205,1,0,0,0,0,0,1,0,reimplementation of concat improved handling of observable the old version required all of the observable s to be generated and bufferedbefore the concat could begin if the outer observable was asynchronous itemscould be dropped test added the new version passes the test and does thebest job i could after examining several possible strategies of achievingclear and consistent semantics in accordance with the principle of leastsurprise my attempt to there is another issue with this implementation the countdown latch will always block the calling thread which is not desirable anything that returns an observable should never be blocking rx is meant to support composition of operations and allows each operation to run concurrently while reviewing this i started playing with the unit tests and added new ones i also made them use inorderverify so they ensure correct ordering ive pasted it below so you can merge into your branch instead of me complicating the merge with another branch the tests pass pass except testconcatunsubscribe which deadlocks it does this because a list wont return the subscription asynchronously so it cant unsubscribe meanwhile a countdownlatch is waiting for the change to trigger and the two latches end up waiting on each otheri havent thought through enough yet to determine if there is a way to solve that or if the unit test is just testing the wrong thing and thus a bad testthe comment above from billy about countdownlatch originated from a discussion between him and i but while reviewing this it is probably the right approachi was playing with other approaches that are purely non blocking while retaining the correct concat sequential behavior but they all seem to require either another wrapping thread stealing work from one of the child observable threads and making it do work that is queued on the others and that seems like a bad idea even though it can be hacked to work but it does so in a way that is very unexpected and thus not something i want to pursue queueing all onnext values which could be a bad memory issue and also means we eagerly subscribe which is not what we wantmy biggest issue right now is that concat o o is a very common usage but that results in list which will be blocking and unsubscribe doesnt workill think through this more but id appreciate your thoughts on how to handle testconcatunsubscribe java public static class unittest { test public void testconcat { suppresswarnings unchecked observer observer mock observerclass final string o { } final string e { } final observable odds observabletoobservable o final observable even observabletoobservable e suppresswarnings unchecked observable concat observablecreate concat odds even concatsubscribe observer verify observer times onnext anystring } test public void testconcatwithlist { suppresswarnings unchecked observer observer mock observerclass final string o { } final string e { } final observable odds observabletoobservable o final observable even observabletoobservable e final list list new arraylist listadd odds listadd even observable concat observablecreate concat list concatsubscribe observer verify observer times onnext anystring } test public void testconcatunsubscribe { final countdownlatch callonce new countdownlatch final countdownlatch oktocontinue new countdownlatch final testobservable w new testobservable one two three final testobservable w new testobservable callonce oktocontinue four five six suppresswarnings unchecked observer aobserver mock observerclass suppresswarnings unchecked observable concat observablecreate concat w w systemoutprintln before subscribe subscription s concatsubscribe aobserver systemoutprintln after subscribe try { block main thread to allow observable w to complete and observable w to call onnext once systemoutprintln before callonceawait callonceawait systemoutprintln after callonceawait s unsubscribe systemoutprintln after s unsubscribe unblock the observable to continue oktocontinuecountdown systemoutprintln after countdown w tjoin w tjoin } catch exception e { eprintstacktrace fail egetmessage } inorder inorder inorder aobserver inorderverify aobserver times onnext one inorderverify aobserver times onnext two inorderverify aobserver times onnext three inorderverify aobserver times onnext four inorderverify aobserver never onnext five inorderverify aobserver never onnext six inorderverify aobserver times oncompleted } test public void testmergeobservableofobservables { suppresswarnings unchecked observer observer mock observerclass final string o { } final string e { } final observable odds observabletoobservable o final observable even observabletoobservable e observable observableofobservables observablecreate new func subscription { override public subscription call observer observer { simulate what would happen in an observable observeronnext odds observeronnext even observeroncompleted return new subscription { override public void unsubscribe { unregister will never be called here since we are executing synchronously } } } } observable concat observablecreate concat observableofobservables concatsubscribe observer verify observer times onnext anystring } simple concat of asynchronous observables ensuring it emits in correct order suppresswarnings unchecked test public void testsimpleasyncconcat { observer observer mock observerclass testobservable o new testobservable one two three testobservable o new testobservable four five six observableconcat o o subscribe observer try { wait for async observables to complete o tjoin o tjoin } catch exception e { throw new runtimeexception failed waiting on threads } inorder inorder inorder observer inorderverify observer times onnext one inorderverify observer times onnext two inorderverify observer times onnext three inorderverify observer times onnext four inorderverify observer times onnext five inorderverify observer times onnext six } test an async observable that emits more async observables suppresswarnings unchecked test public void testnestedasyncconcat throws exception { observer observer mock observerclass final testobservable o new testobservable one two three final testobservable o new testobservable four five six final testobservable o new testobservable seven eight nine final countdownlatch allowthird new countdownlatch final atomicreference parent new atomicreference observable observableofobservables observablecreate new func subscription { override public subscription call final observer observer { final booleansubscription s new booleansubscription parentset new thread new runnable { override public void run { try { emit first if sisunsubscribed { systemoutprintln emit o observeronnext o } emit second if sisunsubscribed { systemoutprintln emit o observeronnext o } wait until sometime later and emit third try { allowthirdawait } catch interruptedexception e { observeronerror e } if sisunsubscribed { systemoutprintln emit o observeronnext o } } catch exception e { observeronerror e } finally { systemoutprintln done parent observable observeroncompleted } } } parentget start return s } } observablecreate concat observableofobservables subscribe observer wait for parent to start while parentget null { threadsleep } try { wait for first async observables to complete while o t null { threadsleep } systemoutprintln thread started waiting for it to complete o tjoin while o t null { threadsleep } systemoutprintln thread started waiting for it to complete o tjoin } catch exception e { throw new runtimeexception failed waiting on threads e } inorder inorder inorder observer inorderverify observer times onnext one inorderverify observer times onnext two inorderverify observer times onnext three inorderverify observer times onnext four inorderverify observer times onnext five inorderverify observer times onnext six we shouldnt have the following yet inorderverify observer never onnext seven inorderverify observer never onnext eight inorderverify observer never onnext nine we should not be completed yet verify observer never oncompleted verify observer never onerror any exceptionclass now allow the third allowthirdcountdown try { while o t null { threadsleep } wait for rd to complete o tjoin } catch exception e { throw new runtimeexception failed waiting on threads e } inorderverify observer times onnext seven inorderverify observer times onnext eight inorderverify observer times onnext nine inorderverify observer times oncompleted verify observer never onerror any exceptionclass } suppresswarnings unchecked test public void testblockedobservableofobservables { observer observer mock observerclass final string o { } final string e { } final observable odds observabletoobservable o final observable even observabletoobservable e final countdownlatch callonce new countdownlatch final countdownlatch oktocontinue new countdownlatch testobservable observableofobservables new testobservable callonce oktocontinue odds even func subscription concatf concat observableofobservables observable concat observablecreate concatf concatsubscribe observer try { block main thread to allow observables to serve up o callonceawait } catch exception ex { exprintstacktrace fail exgetmessage } the concated observable should have served up all of the odds verify observer times onnext verify observer times onnext verify observer times onnext verify observer times onnext try { unblock observables so it can serve up o and complete oktocontinuecountdown observableofobservablestjoin } catch exception ex { exprintstacktrace fail exgetmessage } the concatenated observable should now have served up all the evens verify observer times onnext verify observer times onnext verify observer times onnext } private static class testobservable extends observable { private final subscription s new subscription { override public void unsubscribe { subscribed false } } private final list values private thread t null private int count private boolean subscribed true private final countdownlatch once private final countdownlatch oktocontinue public testobservable t values { this null null values } public testobservable countdownlatch once countdownlatch oktocontinue t values { thisvalues arraysaslist values thisonce once thisoktocontinue oktocontinue } override public subscription subscribe final observer observer { t new thread new runnable { override public void run { try { while count while reviewing this i started playing with the unit tests and added new ones i also made them use inorderverify so they ensure correct ordering ive pasted it below so you can merge into your branch instead of me complicating the merge with another branch the tests pass pass except testconcatunsubscribe which deadlocks it does this because a list wont return the subscription asynchronously so it cant unsubscribe meanwhile a countdownlatch is waiting for the change to trigger and the two latches end up waiting on each other i havent thought through enough yet to determine if there is a way to solve that or if the unit test is just testing the wrong thing and thus a bad test the comment above from billy about countdownlatch originated from a discussion between him and i but while reviewing this it is probably the right approach i was playing with other approaches that are purely non blocking while retaining the correct concat sequential behavior but they all seem to require either another wrapping thread stealing work from one of the child observable threads and making it do work that is queued on the others and that seems like a bad idea even though it can be hacked to work but it does so in a way that is very unexpected and thus not something i want to pursue queueing all onnext values which could be a bad memory issue and also means we eagerly subscribe which is not what we want my biggest issue right now is that concat o o is a very common usage but that results in list which will be blocking and unsubscribe doesnt work ill think through this more but id appreciate your thoughts on how to handle testconcatunsubscribe public static class unittest { test public void testconcat { suppresswarnings unchecked observer observer mock observerclass final string o { } final string e { } final observable odds observabletoobservable o final observable even observabletoobservable e suppresswarnings unchecked observable concat observablecreate concat odds even concatsubscribe observer verify observer times onnext anystring } test public void testconcatwithlist { suppresswarnings unchecked observer observer mock observerclass final string o { } final string e { } final observable odds observabletoobservable o final observable even observabletoobservable e final list list new arraylist listadd odds listadd even observable concat observablecreate concat list concatsubscribe observer verify observer times onnext anystring } test public void testconcatunsubscribe { final countdownlatch callonce new countdownlatch final countdownlatch oktocontinue new countdownlatch final testobservable w new testobservable one two three final testobservable w new testobservable callonce oktocontinue four five six suppresswarnings unchecked observer aobserver mock observerclass suppresswarnings unchecked observable concat observablecreate concat w w systemoutprintln before subscribe subscription s concatsubscribe aobserver systemoutprintln after subscribe try { block main thread to allow observable w to complete and observable w to call onnext once systemoutprintln before callonceawait callonceawait systemoutprintln after callonceawait s unsubscribe systemoutprintln after s unsubscribe unblock the observable to continue oktocontinuecountdown systemoutprintln after countdown w tjoin w tjoin } catch exception e { eprintstacktrace fail egetmessage } inorder inorder inorder aobserver inorderverify aobserver times onnext one inorderverify aobserver times onnext two inorderverify aobserver times onnext three inorderverify aobserver times onnext four inorderverify aobserver never onnext five inorderverify aobserver never onnext six inorderverify aobserver times oncompleted } test public void testmergeobservableofobservables { suppresswarnings unchecked observer observer mock observerclass final string o { } final string e { } final observable odds observabletoobservable o final observable even observabletoobservable e observable observableofobservables observablecreate new func subscription { override public subscription call observer observer { simulate what would happen in an observable observeronnext odds observeronnext even observeroncompleted return new subscription { override public void unsubscribe { unregister will never be called here since we are executing synchronously } } } } observable concat observablecreate concat observableofobservables concatsubscribe observer verify observer times onnext anystring } simple concat of asynchronous observables ensuring it emits in correct order suppresswarnings unchecked test public void testsimpleasyncconcat { observer observer mock observerclass testobservable o new testobservable one two three testobservable o new testobservable four five six observableconcat o o subscribe observer try { wait for async observables to complete o tjoin o tjoin } catch exception e { throw new runtimeexception failed waiting on threads } inorder inorder inorder observer inorderverify observer times onnext one inorderverify observer times onnext two inorderverify observer times onnext three inorderverify observer times onnext four inorderverify observer times onnext five inorderverify observer times onnext six } test an async observable that emits more async observables suppresswarnings unchecked test public void testnestedasyncconcat throws exception { observer observer mock observerclass final testobservable o new testobservable one two three final testobservable o new testobservable four five six final testobservable o new testobservable seven eight nine final countdownlatch allowthird new countdownlatch final atomicreference parent new atomicreference observable observableofobservables observablecreate new func subscription { override public subscription call final observer observer { final booleansubscription s new booleansubscription parentset new thread new runnable { override public void run { try { emit first if sisunsubscribed { systemoutprintln emit o observeronnext o } emit second if sisunsubscribed { systemoutprintln emit o observeronnext o } wait until sometime later and emit third try { allowthirdawait } catch interruptedexception e { observeronerror e } if sisunsubscribed { systemoutprintln emit o observeronnext o } } catch exception e { observeronerror e } finally { systemoutprintln done parent observable observeroncompleted } } } parentget start return s } } observablecreate concat observableofobservables subscribe observer wait for parent to start while parentget null { threadsleep } try { wait for first async observables to complete while o t null { threadsleep } systemoutprintln thread started waiting for it to complete o tjoin while o t null { threadsleep } systemoutprintln thread started waiting for it to complete o tjoin } catch exception e { throw new runtimeexception failed waiting on threads e } inorder inorder inorder observer inorderverify observer times onnext one inorderverify observer times onnext two inorderverify observer times onnext three inorderverify observer times onnext four inorderverify observer times onnext five inorderverify observer times onnext six we shouldnt have the following yet inorderverify observer never onnext seven inorderverify observer never onnext eight inorderverify observer never onnext nine we should not be completed yet verify observer never oncompleted verify observer never onerror any exceptionclass now allow the third allowthirdcountdown try { while o t null { threadsleep } wait for rd to complete o tjoin } catch exception e { throw new runtimeexception failed waiting on threads e } inorderverify observer times onnext seven inorderverify observer times onnext eight inorderverify observer times onnext nine inorderverify observer times oncompleted verify observer never onerror any exceptionclass } suppresswarnings unchecked test public void testblockedobservableofobservables { observer observer mock observerclass final string o { } final string e { } final observable odds observabletoobservable o final observable even observabletoobservable e final countdownlatch callonce new countdownlatch final countdownlatch oktocontinue new countdownlatch testobservable observableofobservables new testobservable callonce oktocontinue odds even func subscription concatf concat observableofobservables observable concat observablecreate concatf concatsubscribe observer try { block main thread to allow observables to serve up o callonceawait } catch exception ex { exprintstacktrace fail exgetmessage } the concated observable should have served up all of the odds verify observer times onnext verify observer times onnext verify observer times onnext verify observer times onnext try { unblock observables so it can serve up o and complete oktocontinuecountdown observableofobservablestjoin } catch exception ex { exprintstacktrace fail exgetmessage } the concatenated observable should now have served up all the evens verify observer times onnext verify observer times onnext verify observer times onnext } private static class testobservable extends observable { private final subscription s new subscription { override public void unsubscribe { subscribed false } } private final list values private thread t null private int count private boolean subscribed true private final countdownlatch once private final countdownlatch oktocontinue public testobservable t values { this null null values } public testobservable countdownlatch once countdownlatch oktocontinue t values { thisvalues arraysaslist values thisonce once thisoktocontinue oktocontinue } override public subscription subscribe final observer observer { t new thread new runnable { override public void run { try { while count observeronnext valuesget count count unblock the main thread to call unsubscribe if null once oncecountdown block until the main thread has called unsubscribe if null once oktocontinueawait } if subscribed observeroncompleted } catch interruptedexception e { eprintstacktrace fail egetmessage } } } tstart return s } } }  reply to this email directly or view it on github thanks for update let me take a look and i will do some moreresearch thought on the testconcatsubscribe test caseon fri mar at am cloudbees pull request builder plugin wrote rxjava pull requests this pull request looks good — reply to this email directly or view it on github rxjava pull requests looks good my original test case was intended to test the unsubscribe inside one ofchild observable the countdownlatch was used so that the code will havea chance to unsubscribe in a predicable manner unsubscribe after four in a normal case there should be no blocking between inner and outerobservable i rewrote the case for better clarity and having the outerobservable is in a separate thread so the test will pass now youbrought up a good point about when you can unsubscribe should it onlyallow unsubscribe to happen during the outer onnext i need to do moreresearch on it here is the test i plan to add test public void testconcatunsubscribeobservableofobservable { final countdownlatch callonce new countdownlatch final countdownlatch oktocontinue new countdownlatch final testobservable w new testobservable one two three final testobservable w newtestobservable callonce oktocontinuefour five six suppresswarnings unchecked observer aobserver mock observerclass suppresswarnings unchecked testobservable observableofobservables newtestobservable w w func subscription concatf concat observableofobservables observable concat observablecreate concatf subscription s concatsubscribe aobserver try { block main thread to allow observable w to complete and observable w to call onnext exactly once callonceawait four has been processed by onnext s unsubscribe five and six will not be processed by onnext unblock the observable to continue oktocontinuecountdown w tjoin w tjoin } catch exception e { eprintstacktrace fail egetmessage } inorder inorder inorder aobserver inorderverify aobserver times onnext one inorderverify aobserver times onnext two inorderverify aobserver times onnext three inorderverify aobserver times onnext four inorderverify aobserver never onnext five inorderverify aobserver never onnext six verify aobserver never oncompleted verify aobserver never onerror any exceptionclass }on tue apr at pm cloudbees pull request builder plugin wrote rxjava pull requests this pull request looks good — reply to this email directly or view it on github the rx net version of concat uses the immediatescheduler to execute theoperation which will execute the operation on the same calling thread soif the observables are running on the same thread it will besynchronous blocked i have pulled in your changes from your fork andadded the additional unit test to test unsubscribe with observablesrunning in different thread i have also updated the javadoc about theblocking with observable on the same thread from my side it looks goodon wed apr at am billy yuen billyy gmailcom wrote my original test case was intended to test the unsubscribe inside one of child observable the countdownlatch was used so that the code will have a chance to unsubscribe in a predicable manner unsubscribe after four in a normal case there should be no blocking between inner and outer observable i rewrote the case for better clarity and having the outer observable is in a separate thread so the test will pass now you brought up a good point about when you can unsubscribe should it only allow unsubscribe to happen during the outer onnext i need to do more research on it here is the test i plan to add test public void testconcatunsubscribeobservableofobservable { final countdownlatch callonce new countdownlatch final countdownlatch oktocontinue new countdownlatch final testobservable w new testobservable one two three final testobservable w newtestobservable callonce oktocontinue four five six suppresswarnings unchecked observer aobserver mock observerclass suppresswarnings unchecked testobservable observableofobservables newtestobservable w w func subscription concatf concat observableofobservables observable concat observablecreate concatf subscription s concatsubscribe aobserver try { block main thread to allow observable w to complete and observable w to call onnext exactly once callonceawait four has been processed by onnext s unsubscribe five and six will not be processed by onnext unblock the observable to continue oktocontinuecountdown w tjoin w tjoin } catch exception e { eprintstacktrace fail egetmessage } inorder inorder inorder aobserver inorderverify aobserver times onnext one inorderverify aobserver times onnext two inorderverify aobserver times onnext three inorderverify aobserver times onnext four inorderverify aobserver never onnext five inorderverify aobserver never onnext six verify aobserver never oncompleted verify aobserver never onerror any exceptionclass } on tue apr at pm cloudbees pull request builder plugin notifications githubcom wrote rxjava pull requests this pull request looks good — reply to this email directly or view it on github i do find it a little strange that observablefrom iterable is a shotgun observable ie the subscribe blocks until all downstream operations have completed on all items which means it is impossible to ever unsubscribe but given that this is correct behavior i think that it makes sense that concat o o also cannot be unsubscribed from i added a cautionary comment to the javadocrx does not or rarely does add concurrency see guideline thus observablefrom is wrapping a synchronous iterable therefore the observable will be synchronousa scheduler could be used to make the subscription to an iterable happen on another thread or a custom observable could be created that handles an iterable asynchronouslyall rx operators must be capable of handling both synchronous and asynchronous sequences and if its synchronous that means unsubscribe will not work which means its up to the implementor of an observable to understand this and decided if its okay to firehose the results for the case of concat my concern is that if all the sequences being combined are async then we need to retain the async behavior and not block and prevent unsubscriptionfor example async or synchronous observablea with items async or synchronous observableb with items async observablec with infinite items hot observable that never completed i should be able to do this concat a b c take this should get the items from a items from b and first items from c and then unsubscribe and continuedoes this work with the current implementation and correctly unsubscribe from observablec good point the best way to tell is to build an unit test for this case i can expand my new test to include this case and see what happenon wed apr at pm ben christensen notifications githubcomwrote i do find it a little strange that observablefrom iterable is a shotgun observable ie the subscribe blocks until all downstream operations have completed on all items which means it is impossible to ever unsubscribe but given that this is correct behavior i think that it makes sense that concat o o also cannot be unsubscribed from i added a cautionary comment to the javadoc rx does not or rarely does add concurrency see guideline thus observablefrom is wrapping a synchronous iterable therefore the observable will be synchronous a scheduler could be used to make the subscription to an iterable happen on another thread or a custom observable could be created that handles an iterable asynchronously all rx operators must be capable of handling both synchronous and asynchronous sequences and if its synchronous that means unsubscribe will not work which means its up to the implementor of an observable to understand this and decided if its okay to firehose the results for the case of concat my concern is that if all the sequences being combined are async then we need to retain the async behavior and not block and prevent unsubscription for example async or synchronous observablea with items async or synchronous observableb with items async observablec with infinite items hot observable that never completed i should be able to do this concat a b c take this should get the items from a items from b and first items from c and then unsubscribe and continue does this work with the current implementation and correctly unsubscribe from observablec — reply to this email directly or view it on github
225,1,0,0,0,0,0,1,0,schedulers merge of pull manual merge of by mairbek plus the following changes made some classes non public so they dont become part of the published api if we find they have value in the public api we can make them so but once published its hard to remove them so id rather keep them implementation details until then consolidated executorscheduler and scheduledexecutorscheduler made executorscheduler use a system wide scheduledexecutorscheduler for handling delayed events when only an executor is available made the iothreadpool use a non bounded cached thread pool next step from here is to review all operator implementations and add the scheduler overloads the unit test is poorly written non deterministic ill fix in the morning awesome work with this it should be easy to implement operators like sample etc yes it should open the gates to many operators we havent been able to pursue committed a few tweaks and fixesopen questions for me are were not using the schedulernow value anywhere should we be or is that only for the virtual scheduler used for testing not quite sure how the overloads should work on merge etc ive implemented them but the behavior might not yet match c can someone with an rxnet environment setup implement a test similar to this from java and tell me the output java test public void testmixedschedulers throws interruptedexception { final string mainthreadname threadcurrentthread getname observable o observable create new func subscription { override public subscription call observer observer { systemoutprintln origin observable is running on threadcurrentthread getname assertfalse threadcurrentthread getname equals mainthreadname asserttrue actually threadcurrentthread getname threadcurrentthread getname startswith rxiothreadpool observeronnext one observeronnext two observeronnext three observeroncompleted return subscriptionsempty } } subscribeon schedulersthreadpoolforio subscribe to the source on the io thread pool now merge on the cpu threadpool o observable merge o observable from four five subscribeon schedulersthreadpoolforcomputation map new func { override public string call string v { opportunity to see what thread the merge is running on systemoutprintln merge is running on threadcurrentthread getname return v } } final countdownlatch latch new countdownlatch final atomicreference onerror new atomicreference subscribe on a new thread osubscribe new observer { override public void oncompleted { systemoutprintln received oncompleted latchcountdown } override public void onerror exception e { systemoutprintln received onerror egetmessage onerrorset runtimeexception e latchcountdown } override public void onnext string v { systemoutprintln final subscribe is running on threadcurrentthread getname systemoutprintln onnext v } } schedulersnewthread wait for the above to finish or blow up if its blocked latchawait timeunitseconds } im trying to understand how a sequence should work when multiple subscribeon operators are applied at different steps of a sequenceof course rxnet doesnt have the io and cpu thread pools those are just helper methods to executors which would be separate threadpools for different work types so youll need to adjust that is there any reason to use schedulerschedule on an internal operator implementation instead of just leveraging subscribeon other than when we need the delay arguments of course for example on a method overload of merge is this okay java return merge source subscribeon scheduler or is there some reason to inside the operationmerge do this java return schedulerschedule new func { override public subscription call { return new mergeobservable o call observer } } they seem to accomplish the same thing but would like to know if theres a reason to prefer one over the otheri prefer just reusing subscribeon i cant tell from reading c code what it does as i cant find the extensions that implement the override methods im pulling the trigger and merging this into master so people can start playing with it and providing feedbackthe public api changes are fairly limited still so most changes which i fully expect will be implementation details rxjava pull requests looks good
225,1,0,1,0,0,0,1,0,schedulers merge of pull manual merge of by mairbek plus the following changes made some classes non public so they dont become part of the published api if we find they have value in the public api we can make them so but once published its hard to remove them so id rather keep them implementation details until then consolidated executorscheduler and scheduledexecutorscheduler made executorscheduler use a system wide scheduledexecutorscheduler for handling delayed events when only an executor is available made the iothreadpool use a non bounded cached thread pool next step from here is to review all operator implementations and add the scheduler overloads the unit test is poorly written non deterministic ill fix in the morning awesome work with this it should be easy to implement operators like sample etc yes it should open the gates to many operators we havent been able to pursue committed a few tweaks and fixesopen questions for me are were not using the schedulernow value anywhere should we be or is that only for the virtual scheduler used for testing not quite sure how the overloads should work on merge etc ive implemented them but the behavior might not yet match c can someone with an rxnet environment setup implement a test similar to this from java and tell me the output java test public void testmixedschedulers throws interruptedexception { final string mainthreadname threadcurrentthread getname observable o observable create new func subscription { override public subscription call observer observer { systemoutprintln origin observable is running on threadcurrentthread getname assertfalse threadcurrentthread getname equals mainthreadname asserttrue actually threadcurrentthread getname threadcurrentthread getname startswith rxiothreadpool observeronnext one observeronnext two observeronnext three observeroncompleted return subscriptionsempty } } subscribeon schedulersthreadpoolforio subscribe to the source on the io thread pool now merge on the cpu threadpool o observable merge o observable from four five subscribeon schedulersthreadpoolforcomputation map new func { override public string call string v { opportunity to see what thread the merge is running on systemoutprintln merge is running on threadcurrentthread getname return v } } final countdownlatch latch new countdownlatch final atomicreference onerror new atomicreference subscribe on a new thread osubscribe new observer { override public void oncompleted { systemoutprintln received oncompleted latchcountdown } override public void onerror exception e { systemoutprintln received onerror egetmessage onerrorset runtimeexception e latchcountdown } override public void onnext string v { systemoutprintln final subscribe is running on threadcurrentthread getname systemoutprintln onnext v } } schedulersnewthread wait for the above to finish or blow up if its blocked latchawait timeunitseconds } im trying to understand how a sequence should work when multiple subscribeon operators are applied at different steps of a sequenceof course rxnet doesnt have the io and cpu thread pools those are just helper methods to executors which would be separate threadpools for different work types so youll need to adjust that is there any reason to use schedulerschedule on an internal operator implementation instead of just leveraging subscribeon other than when we need the delay arguments of course for example on a method overload of merge is this okay java return merge source subscribeon scheduler or is there some reason to inside the operationmerge do this java return schedulerschedule new func { override public subscription call { return new mergeobservable o call observer } } they seem to accomplish the same thing but would like to know if theres a reason to prefer one over the otheri prefer just reusing subscribeon i cant tell from reading c code what it does as i cant find the extensions that implement the override methods im pulling the trigger and merging this into master so people can start playing with it and providing feedbackthe public api changes are fairly limited still so most changes which i fully expect will be implementation details rxjava pull requests looks good
225,1,0,1,1,1,1,1,1,schedulers merge of pull manual merge of by mairbek plus the following changes made some classes non public so they dont become part of the published api if we find they have value in the public api we can make them so but once published its hard to remove them so id rather keep them implementation details until then consolidated executorscheduler and scheduledexecutorscheduler made executorscheduler use a system wide scheduledexecutorscheduler for handling delayed events when only an executor is available made the iothreadpool use a non bounded cached thread pool next step from here is to review all operator implementations and add the scheduler overloads the unit test is poorly written non deterministic ill fix in the morning awesome work with this it should be easy to implement operators like sample etc yes it should open the gates to many operators we havent been able to pursue committed a few tweaks and fixesopen questions for me are were not using the schedulernow value anywhere should we be or is that only for the virtual scheduler used for testing not quite sure how the overloads should work on merge etc ive implemented them but the behavior might not yet match c can someone with an rxnet environment setup implement a test similar to this from java and tell me the output java test public void testmixedschedulers throws interruptedexception { final string mainthreadname threadcurrentthread getname observable o observable create new func subscription { override public subscription call observer observer { systemoutprintln origin observable is running on threadcurrentthread getname assertfalse threadcurrentthread getname equals mainthreadname asserttrue actually threadcurrentthread getname threadcurrentthread getname startswith rxiothreadpool observeronnext one observeronnext two observeronnext three observeroncompleted return subscriptionsempty } } subscribeon schedulersthreadpoolforio subscribe to the source on the io thread pool now merge on the cpu threadpool o observable merge o observable from four five subscribeon schedulersthreadpoolforcomputation map new func { override public string call string v { opportunity to see what thread the merge is running on systemoutprintln merge is running on threadcurrentthread getname return v } } final countdownlatch latch new countdownlatch final atomicreference onerror new atomicreference subscribe on a new thread osubscribe new observer { override public void oncompleted { systemoutprintln received oncompleted latchcountdown } override public void onerror exception e { systemoutprintln received onerror egetmessage onerrorset runtimeexception e latchcountdown } override public void onnext string v { systemoutprintln final subscribe is running on threadcurrentthread getname systemoutprintln onnext v } } schedulersnewthread wait for the above to finish or blow up if its blocked latchawait timeunitseconds } im trying to understand how a sequence should work when multiple subscribeon operators are applied at different steps of a sequenceof course rxnet doesnt have the io and cpu thread pools those are just helper methods to executors which would be separate threadpools for different work types so youll need to adjust that is there any reason to use schedulerschedule on an internal operator implementation instead of just leveraging subscribeon other than when we need the delay arguments of course for example on a method overload of merge is this okay java return merge source subscribeon scheduler or is there some reason to inside the operationmerge do this java return schedulerschedule new func { override public subscription call { return new mergeobservable o call observer } } they seem to accomplish the same thing but would like to know if theres a reason to prefer one over the otheri prefer just reusing subscribeon i cant tell from reading c code what it does as i cant find the extensions that implement the override methods im pulling the trigger and merging this into master so people can start playing with it and providing feedbackthe public api changes are fairly limited still so most changes which i fully expect will be implementation details rxjava pull requests looks good
228,1,0,0,0,0,0,1,0,interval i have attempted to implement the interval operator here as far as i can see it seems to work this is based on the quite fresh work on schedulersit doesnt work with the currentthread or newthread schedulers i guess due to the simple sleepingaction it does work with a scheduledexecutorservice thoughfor testing this conveniently i also wrote a test scheduler with adjustable timelooking forward to any review comments lets consider adding new method to the scheduler javascheduleperiodically action action long initialdelay long period timeunit unit it would allow to leverage scheduledexecutorservicescheduleatrate for the executorscheduler for other schedulers we could use recursive action scheduling from pull request i agree scheduleperiodically would be helpful here jmhofer do you plan to work on this feature im thinking about implementing buffer operator and this one will be very helpful for me ill have a look at it maybe we should also combine all the longs and units into a timespan class it doesnt feel right to always have them as separate parameters anyone know why net wouldnt have a scheduleperiodically concept if we were to add that it would only really work with scheduledexecutorservice and thus most scheduler implementations would have to rely upon the generic scheduledexecutorservice that ive added in called genericscheduledexecutorservice this suggests to me that it isnt the right solution to add another interface method as it seems very tied to a particular implementation cant this be achieved with recursive schedulers which now work after the changes you did in im curious about this it doesnt work with the currentthread or newthread schedulers i guess due to the simple sleepingaction it does work with a scheduledexecutorservice thoughit seems that this operator needs to be async and must default to using something like schedulersthreadpoolforcomputation documentation at msdn suggests that this defaults to using a thread pool scheduler the following example code uses the interval operator to generate a sequence of long integers staring at zero each integer in the sequence is generated after the two second period has expired each integer is written to the console window along with the current time to show the period parameter in effect the generation of the integer sequence is scheduled to run on a thread from the net thread pool so the main thread is not blocked and can process the enter key being pressed to stop the intervalperhaps newthreadscheduler will work as of because it now uses genericscheduledexecutorservice when a delay is passed in instead of sleepingaction what happens in net if someone tries to use immediatescheduler or currentthreadscheduler anyone have access to net to try that maybe we should also combine all the longs and units into a timespan class it doesnt feel right to always have them as separate parametersif were going to consider doing this then we should do it as part of before i release another version since this would change the schedulers interfacejava itself always keeps the separate though so perhaps the idiomatic thing to do in java is to keep them separate i dont have a strong opinion on this one but the decision made now will last a very long time actually net does have scheduleperiodic see here its useful to avoid recursive scheduling where the schedulers support this directly as well as to do the slightly messy recursive scheduling ourselves for other types of schedulers so that the user doesnt have to ah interesting thanks for educating me on that this doesnt look like its been integrated into observable but im going to merge as it looks useful to get this in the testscheduler especially while interval continues getting work done great thanks this still needs a bit of work if when we do periodic scheduling are you okay with me releasing current code on the master branch and then the rest of interval coming lateris there anything else about master branch as it stands that should be changed before i release id like to do so today thats alright with me benjchristensen now the interval operators in rxjava and rxnet have different behaviors when the scheduler is currentthread in rxnet the following codes c var o observableinterval timespanfrommilliseconds schedulercurrentthread otake subscribe x consolewriteline x otake subscribe x consolewriteline x consolereadline output in rxjava the following codes java observable o observableinterval timeunitmilliseconds schedulerscurrentthread otake subscribe new action { override public void call long t { systemoutprintln t } } otake subscribe new action { override public void call long t { systemoutprintln t } } output and the current thread is blocked at the first subscribe is it ok or the interval operator should not be used with currentthread
228,1,0,1,0,0,0,1,0,interval i have attempted to implement the interval operator here as far as i can see it seems to work this is based on the quite fresh work on schedulersit doesnt work with the currentthread or newthread schedulers i guess due to the simple sleepingaction it does work with a scheduledexecutorservice thoughfor testing this conveniently i also wrote a test scheduler with adjustable timelooking forward to any review comments lets consider adding new method to the scheduler javascheduleperiodically action action long initialdelay long period timeunit unit it would allow to leverage scheduledexecutorservicescheduleatrate for the executorscheduler for other schedulers we could use recursive action scheduling from pull request i agree scheduleperiodically would be helpful here jmhofer do you plan to work on this feature im thinking about implementing buffer operator and this one will be very helpful for me ill have a look at it maybe we should also combine all the longs and units into a timespan class it doesnt feel right to always have them as separate parameters anyone know why net wouldnt have a scheduleperiodically concept if we were to add that it would only really work with scheduledexecutorservice and thus most scheduler implementations would have to rely upon the generic scheduledexecutorservice that ive added in called genericscheduledexecutorservice this suggests to me that it isnt the right solution to add another interface method as it seems very tied to a particular implementation cant this be achieved with recursive schedulers which now work after the changes you did in im curious about this it doesnt work with the currentthread or newthread schedulers i guess due to the simple sleepingaction it does work with a scheduledexecutorservice thoughit seems that this operator needs to be async and must default to using something like schedulersthreadpoolforcomputation documentation at msdn suggests that this defaults to using a thread pool scheduler the following example code uses the interval operator to generate a sequence of long integers staring at zero each integer in the sequence is generated after the two second period has expired each integer is written to the console window along with the current time to show the period parameter in effect the generation of the integer sequence is scheduled to run on a thread from the net thread pool so the main thread is not blocked and can process the enter key being pressed to stop the intervalperhaps newthreadscheduler will work as of because it now uses genericscheduledexecutorservice when a delay is passed in instead of sleepingaction what happens in net if someone tries to use immediatescheduler or currentthreadscheduler anyone have access to net to try that maybe we should also combine all the longs and units into a timespan class it doesnt feel right to always have them as separate parametersif were going to consider doing this then we should do it as part of before i release another version since this would change the schedulers interfacejava itself always keeps the separate though so perhaps the idiomatic thing to do in java is to keep them separate i dont have a strong opinion on this one but the decision made now will last a very long time actually net does have scheduleperiodic see here its useful to avoid recursive scheduling where the schedulers support this directly as well as to do the slightly messy recursive scheduling ourselves for other types of schedulers so that the user doesnt have to ah interesting thanks for educating me on that this doesnt look like its been integrated into observable but im going to merge as it looks useful to get this in the testscheduler especially while interval continues getting work done great thanks this still needs a bit of work if when we do periodic scheduling are you okay with me releasing current code on the master branch and then the rest of interval coming lateris there anything else about master branch as it stands that should be changed before i release id like to do so today thats alright with me benjchristensen now the interval operators in rxjava and rxnet have different behaviors when the scheduler is currentthread in rxnet the following codes c var o observableinterval timespanfrommilliseconds schedulercurrentthread otake subscribe x consolewriteline x otake subscribe x consolewriteline x consolereadline output in rxjava the following codes java observable o observableinterval timeunitmilliseconds schedulerscurrentthread otake subscribe new action { override public void call long t { systemoutprintln t } } otake subscribe new action { override public void call long t { systemoutprintln t } } output and the current thread is blocked at the first subscribe is it ok or the interval operator should not be used with currentthread
228,1,0,0,0,0,0,1,0,interval i have attempted to implement the interval operator here as far as i can see it seems to work this is based on the quite fresh work on schedulersit doesnt work with the currentthread or newthread schedulers i guess due to the simple sleepingaction it does work with a scheduledexecutorservice thoughfor testing this conveniently i also wrote a test scheduler with adjustable timelooking forward to any review comments lets consider adding new method to the scheduler javascheduleperiodically action action long initialdelay long period timeunit unit it would allow to leverage scheduledexecutorservicescheduleatrate for the executorscheduler for other schedulers we could use recursive action scheduling from pull request i agree scheduleperiodically would be helpful here jmhofer do you plan to work on this feature im thinking about implementing buffer operator and this one will be very helpful for me ill have a look at it maybe we should also combine all the longs and units into a timespan class it doesnt feel right to always have them as separate parameters anyone know why net wouldnt have a scheduleperiodically concept if we were to add that it would only really work with scheduledexecutorservice and thus most scheduler implementations would have to rely upon the generic scheduledexecutorservice that ive added in called genericscheduledexecutorservice this suggests to me that it isnt the right solution to add another interface method as it seems very tied to a particular implementation cant this be achieved with recursive schedulers which now work after the changes you did in im curious about this it doesnt work with the currentthread or newthread schedulers i guess due to the simple sleepingaction it does work with a scheduledexecutorservice thoughit seems that this operator needs to be async and must default to using something like schedulersthreadpoolforcomputation documentation at msdn suggests that this defaults to using a thread pool scheduler the following example code uses the interval operator to generate a sequence of long integers staring at zero each integer in the sequence is generated after the two second period has expired each integer is written to the console window along with the current time to show the period parameter in effect the generation of the integer sequence is scheduled to run on a thread from the net thread pool so the main thread is not blocked and can process the enter key being pressed to stop the intervalperhaps newthreadscheduler will work as of because it now uses genericscheduledexecutorservice when a delay is passed in instead of sleepingaction what happens in net if someone tries to use immediatescheduler or currentthreadscheduler anyone have access to net to try that maybe we should also combine all the longs and units into a timespan class it doesnt feel right to always have them as separate parametersif were going to consider doing this then we should do it as part of before i release another version since this would change the schedulers interfacejava itself always keeps the separate though so perhaps the idiomatic thing to do in java is to keep them separate i dont have a strong opinion on this one but the decision made now will last a very long time actually net does have scheduleperiodic see here its useful to avoid recursive scheduling where the schedulers support this directly as well as to do the slightly messy recursive scheduling ourselves for other types of schedulers so that the user doesnt have to ah interesting thanks for educating me on that this doesnt look like its been integrated into observable but im going to merge as it looks useful to get this in the testscheduler especially while interval continues getting work done great thanks this still needs a bit of work if when we do periodic scheduling are you okay with me releasing current code on the master branch and then the rest of interval coming lateris there anything else about master branch as it stands that should be changed before i release id like to do so today thats alright with me benjchristensen now the interval operators in rxjava and rxnet have different behaviors when the scheduler is currentthread in rxnet the following codes c var o observableinterval timespanfrommilliseconds schedulercurrentthread otake subscribe x consolewriteline x otake subscribe x consolewriteline x consolereadline output in rxjava the following codes java observable o observableinterval timeunitmilliseconds schedulerscurrentthread otake subscribe new action { override public void call long t { systemoutprintln t } } otake subscribe new action { override public void call long t { systemoutprintln t } } output and the current thread is blocked at the first subscribe is it ok or the interval operator should not be used with currentthread
229,1,0,0,0,0,0,1,0,trying to extend the scheduler interface according to the comments at ive tried to extend the scheduler interface according to the discussion at issue if i understand this correctly most of it can be done via the abstractscheduler i hope this helps please have a look awesome looks like it doesnt break a scheduler interface i thought about two examples java final scheduler scheduler schedulerscurrentthread observable obs observablecreate new func subscription { override public subscription call final observer observer { return schedulerschedule new func { override public subscription call scheduler scheduler integer i { if i { observeroncompleted return subscriptionsempty } observeronnext i return schedulerschedule i this } } } } obssubscribe new observer { override public void oncompleted { systemoutprintln completed } override public void onerror exception e { systemoutprintln error } override public void onnext integer args { systemoutprintln args } } and java final scheduler scheduler schedulersthreadpoolforcomputation observable obs observablecreate new func subscription { override public subscription call final observer observer { return schedulerschedule new booleansubscription new func { override public subscription call scheduler scheduler booleansubscription cancel { if cancelisunsubscribed { observeroncompleted return subscriptionsempty } observeronnext try { threadsleep } catch interruptedexception e { eprintstacktrace } schedulerschedule cancel this return cancel } } } } subscription subscribe obssubscribe new observer { override public void oncompleted { systemoutprintln completed } override public void onerror exception e { systemoutprintln error } override public void onnext integer args { systemoutprintln args } } threadsleep subscribeunsubscribe systemoutprintln unsubscribe threadsleep and they worked well for me im wondering if the scheduler interface really needs all of these overloadsrx has primary methods the rest are extension methods that look like they do transformations the key ones are java subscription schedule t state func action subscription schedule t state func action long duetime timeunit unit we dont have one with an explicit time to run only relative at this time it appears the overloads all make sense but again net is able to use extension methods to make the design much more elegant where only the main are part of the interface and the rest come along for the rideit means we end up with a scheduler abstractscheduler interface abstract pairing to make this workshould we just make scheduler an abstract im very tempted to do so because of the following problems adding methods to scheduler will be breaking changes requiring major version increments people implementing schedulers will basically always have to also extend abstractscheduler or copy paste all of those method overloadsor should be remove all but the main methods from scheduler and put all the overloads as utility functions on the schedulers class insteadthe precedent for using abstract or concrete classes instead of interfaces which net then augments with extension methods is already done observable is a concrete class instead of interface for this very reasonall plugins as abstracts instead of interfaces for this reason as wellthoughts while reviewing and playing with this i considered some changes id like to propose i have submitted another pull request that builds on top of your work jmhofer and includes the unit tests from mairbek i would appreciate your thoughts on it and whether they are beneficial changes or just pedantic merged manually via
229,1,0,0,0,1,1,1,1,trying to extend the scheduler interface according to the comments at ive tried to extend the scheduler interface according to the discussion at issue if i understand this correctly most of it can be done via the abstractscheduler i hope this helps please have a look awesome looks like it doesnt break a scheduler interface i thought about two examples java final scheduler scheduler schedulerscurrentthread observable obs observablecreate new func subscription { override public subscription call final observer observer { return schedulerschedule new func { override public subscription call scheduler scheduler integer i { if i { observeroncompleted return subscriptionsempty } observeronnext i return schedulerschedule i this } } } } obssubscribe new observer { override public void oncompleted { systemoutprintln completed } override public void onerror exception e { systemoutprintln error } override public void onnext integer args { systemoutprintln args } } and java final scheduler scheduler schedulersthreadpoolforcomputation observable obs observablecreate new func subscription { override public subscription call final observer observer { return schedulerschedule new booleansubscription new func { override public subscription call scheduler scheduler booleansubscription cancel { if cancelisunsubscribed { observeroncompleted return subscriptionsempty } observeronnext try { threadsleep } catch interruptedexception e { eprintstacktrace } schedulerschedule cancel this return cancel } } } } subscription subscribe obssubscribe new observer { override public void oncompleted { systemoutprintln completed } override public void onerror exception e { systemoutprintln error } override public void onnext integer args { systemoutprintln args } } threadsleep subscribeunsubscribe systemoutprintln unsubscribe threadsleep and they worked well for me im wondering if the scheduler interface really needs all of these overloadsrx has primary methods the rest are extension methods that look like they do transformations the key ones are java subscription schedule t state func action subscription schedule t state func action long duetime timeunit unit we dont have one with an explicit time to run only relative at this time it appears the overloads all make sense but again net is able to use extension methods to make the design much more elegant where only the main are part of the interface and the rest come along for the rideit means we end up with a scheduler abstractscheduler interface abstract pairing to make this workshould we just make scheduler an abstract im very tempted to do so because of the following problems adding methods to scheduler will be breaking changes requiring major version increments people implementing schedulers will basically always have to also extend abstractscheduler or copy paste all of those method overloadsor should be remove all but the main methods from scheduler and put all the overloads as utility functions on the schedulers class insteadthe precedent for using abstract or concrete classes instead of interfaces which net then augments with extension methods is already done observable is a concrete class instead of interface for this very reasonall plugins as abstracts instead of interfaces for this reason as wellthoughts while reviewing and playing with this i considered some changes id like to propose i have submitted another pull request that builds on top of your work jmhofer and includes the unit tests from mairbek i would appreciate your thoughts on it and whether they are beneficial changes or just pedantic merged manually via
229,1,0,0,0,1,1,1,1,trying to extend the scheduler interface according to the comments at ive tried to extend the scheduler interface according to the discussion at issue if i understand this correctly most of it can be done via the abstractscheduler i hope this helps please have a look awesome looks like it doesnt break a scheduler interface i thought about two examples java final scheduler scheduler schedulerscurrentthread observable obs observablecreate new func subscription { override public subscription call final observer observer { return schedulerschedule new func { override public subscription call scheduler scheduler integer i { if i { observeroncompleted return subscriptionsempty } observeronnext i return schedulerschedule i this } } } } obssubscribe new observer { override public void oncompleted { systemoutprintln completed } override public void onerror exception e { systemoutprintln error } override public void onnext integer args { systemoutprintln args } } and java final scheduler scheduler schedulersthreadpoolforcomputation observable obs observablecreate new func subscription { override public subscription call final observer observer { return schedulerschedule new booleansubscription new func { override public subscription call scheduler scheduler booleansubscription cancel { if cancelisunsubscribed { observeroncompleted return subscriptionsempty } observeronnext try { threadsleep } catch interruptedexception e { eprintstacktrace } schedulerschedule cancel this return cancel } } } } subscription subscribe obssubscribe new observer { override public void oncompleted { systemoutprintln completed } override public void onerror exception e { systemoutprintln error } override public void onnext integer args { systemoutprintln args } } threadsleep subscribeunsubscribe systemoutprintln unsubscribe threadsleep and they worked well for me im wondering if the scheduler interface really needs all of these overloadsrx has primary methods the rest are extension methods that look like they do transformations the key ones are java subscription schedule t state func action subscription schedule t state func action long duetime timeunit unit we dont have one with an explicit time to run only relative at this time it appears the overloads all make sense but again net is able to use extension methods to make the design much more elegant where only the main are part of the interface and the rest come along for the rideit means we end up with a scheduler abstractscheduler interface abstract pairing to make this workshould we just make scheduler an abstract im very tempted to do so because of the following problems adding methods to scheduler will be breaking changes requiring major version increments people implementing schedulers will basically always have to also extend abstractscheduler or copy paste all of those method overloadsor should be remove all but the main methods from scheduler and put all the overloads as utility functions on the schedulers class insteadthe precedent for using abstract or concrete classes instead of interfaces which net then augments with extension methods is already done observable is a concrete class instead of interface for this very reasonall plugins as abstracts instead of interfaces for this reason as wellthoughts while reviewing and playing with this i considered some changes id like to propose i have submitted another pull request that builds on top of your work jmhofer and includes the unit tests from mairbek i would appreciate your thoughts on it and whether they are beneficial changes or just pedantic merged manually via
248,1,0,0,0,0,0,1,0,implemented sample operation now that operationinterval is in operationsample see was kind of straightforward i also added a unit test against sampling and allowed for specifying a scheduler used by the sample operation we want methods on observable dont we sure i just completely forgot about that ill add them
248,1,0,0,1,1,1,1,1,implemented sample operation now that operationinterval is in operationsample see was kind of straightforward i also added a unit test against sampling and allowed for specifying a scheduler used by the sample operation we want methods on observable dont we sure i just completely forgot about that ill add them
248,1,0,0,1,1,1,1,1,implemented sample operation now that operationinterval is in operationsample see was kind of straightforward i also added a unit test against sampling and allowed for specifying a scheduler used by the sample operation we want methods on observable dont we sure i just completely forgot about that ill add them
249,1,0,0,0,0,0,1,0,timestamp operation straightforward implementation of issue based on operationmap without the scheduler version as map doesnt take a scheduler yet either the failing test has nothing to do with my changes i guess its a sporadic test problem as theres not much difference between and milliseconds this should also be added to observable shouldnt it my eclipse configuration also automatically added a lot of override annotations i hope you dont mind otherwise i can remove them again of course the override annotations are fine they are standard java they may be missing in some places because this project started with java compliance and it had the annotations in less places than java
249,1,0,1,1,0,1,1,1,timestamp operation straightforward implementation of issue based on operationmap without the scheduler version as map doesnt take a scheduler yet either the failing test has nothing to do with my changes i guess its a sporadic test problem as theres not much difference between and milliseconds this should also be added to observable shouldnt it my eclipse configuration also automatically added a lot of override annotations i hope you dont mind otherwise i can remove them again of course the override annotations are fine they are standard java they may be missing in some places because this project started with java compliance and it had the annotations in less places than java
249,1,0,0,0,0,0,1,0,timestamp operation straightforward implementation of issue based on operationmap without the scheduler version as map doesnt take a scheduler yet either the failing test has nothing to do with my changes i guess its a sporadic test problem as theres not much difference between and milliseconds this should also be added to observable shouldnt it my eclipse configuration also automatically added a lot of override annotations i hope you dont mind otherwise i can remove them again of course the override annotations are fine they are standard java they may be missing in some places because this project started with java compliance and it had the annotations in less places than java
250,1,0,0,0,0,0,1,0,initial implementation of asyncsubject ive done some work on asyncsubject including unit tests and im looking for feedback i dont expect to get this pull request immediately accepted but i hope to find out if this is the correct workflow for this repository and if the code is up to your standards before i start pouring in more hours into issue if you guys are ok with the asyncsubject implementation ill start working on the otherslooking forward to some feedback hi michaeldejong thanks for getting involvedbased on my reading of the msdn docs for asyncsubject and your code this looks goodthank for you following the coding style of the project and making sure the copyright unit tests etc are all in placemerging now
250,1,0,0,1,1,1,1,1,initial implementation of asyncsubject ive done some work on asyncsubject including unit tests and im looking for feedback i dont expect to get this pull request immediately accepted but i hope to find out if this is the correct workflow for this repository and if the code is up to your standards before i start pouring in more hours into issue if you guys are ok with the asyncsubject implementation ill start working on the otherslooking forward to some feedback hi michaeldejong thanks for getting involvedbased on my reading of the msdn docs for asyncsubject and your code this looks goodthank for you following the coding style of the project and making sure the copyright unit tests etc are all in placemerging now
250,1,0,0,1,1,1,1,1,initial implementation of asyncsubject ive done some work on asyncsubject including unit tests and im looking for feedback i dont expect to get this pull request immediately accepted but i hope to find out if this is the correct workflow for this repository and if the code is up to your standards before i start pouring in more hours into issue if you guys are ok with the asyncsubject implementation ill start working on the otherslooking forward to some feedback hi michaeldejong thanks for getting involvedbased on my reading of the msdn docs for asyncsubject and your code this looks goodthank for you following the coding style of the project and making sure the copyright unit tests etc are all in placemerging now
257,1,0,0,0,0,0,1,0,improved scan reduce aggregate scan is currently restricted to accumulators of type func where func would be possible for initial values of type r this pull request tries to fix this by generalizing the scan implementation i had to restructure the scan operator a bit for this to stay typesafe imho its more readable now thoughthis indirectly leads to generalized reduce tooalso aggregate is added as an alias for reduce see thank you for working on this observable had not had any changes done to it to expose the new reduce or scan methods so that should probably be added to this pull request what names should we use on the public apirxnet never used reduce it uses aggregate others call it fold accumulate etc more here is using the reduce and collector names what names should we use and what aliases if any should we include in observable about observable hmm seems that the changes got lost somehow ill go dig them out agai d about the names to use imho rxjava should have the java names as well as the orginial rxnet names agreed with your opinion on naming can you add those when you update the observable and make sure the javadocs of the methods are clear in linking to each other when they are aliases of each other ive had a look at the java stream operations to me it looks like theres no explicit scan equivalent in java or am i missing something collect seems to be specifically made for mutable operations i dont see where we would use thatso i would just alias reduce with aggregate and scan stays unaliased if thats okay that works for me we can always add more aliases if java adds a scan equivalent i plan on doing a release tomorrow about hours from now if you want to try and have this ready for that rxjava pull requests looks good as soon as this is in my swing branch becomes finally ready for a merge it offers a few simple observables created from button click keyboard and mouse events looking forward to this
257,1,0,1,1,1,1,1,1,improved scan reduce aggregate scan is currently restricted to accumulators of type func where func would be possible for initial values of type r this pull request tries to fix this by generalizing the scan implementation i had to restructure the scan operator a bit for this to stay typesafe imho its more readable now thoughthis indirectly leads to generalized reduce tooalso aggregate is added as an alias for reduce see thank you for working on this observable had not had any changes done to it to expose the new reduce or scan methods so that should probably be added to this pull request what names should we use on the public apirxnet never used reduce it uses aggregate others call it fold accumulate etc more here is using the reduce and collector names what names should we use and what aliases if any should we include in observable about observable hmm seems that the changes got lost somehow ill go dig them out agai d about the names to use imho rxjava should have the java names as well as the orginial rxnet names agreed with your opinion on naming can you add those when you update the observable and make sure the javadocs of the methods are clear in linking to each other when they are aliases of each other ive had a look at the java stream operations to me it looks like theres no explicit scan equivalent in java or am i missing something collect seems to be specifically made for mutable operations i dont see where we would use thatso i would just alias reduce with aggregate and scan stays unaliased if thats okay that works for me we can always add more aliases if java adds a scan equivalent i plan on doing a release tomorrow about hours from now if you want to try and have this ready for that rxjava pull requests looks good as soon as this is in my swing branch becomes finally ready for a merge it offers a few simple observables created from button click keyboard and mouse events looking forward to this
257,1,0,1,0,0,1,1,1,improved scan reduce aggregate scan is currently restricted to accumulators of type func where func would be possible for initial values of type r this pull request tries to fix this by generalizing the scan implementation i had to restructure the scan operator a bit for this to stay typesafe imho its more readable now thoughthis indirectly leads to generalized reduce tooalso aggregate is added as an alias for reduce see thank you for working on this observable had not had any changes done to it to expose the new reduce or scan methods so that should probably be added to this pull request what names should we use on the public apirxnet never used reduce it uses aggregate others call it fold accumulate etc more here is using the reduce and collector names what names should we use and what aliases if any should we include in observable about observable hmm seems that the changes got lost somehow ill go dig them out agai d about the names to use imho rxjava should have the java names as well as the orginial rxnet names agreed with your opinion on naming can you add those when you update the observable and make sure the javadocs of the methods are clear in linking to each other when they are aliases of each other ive had a look at the java stream operations to me it looks like theres no explicit scan equivalent in java or am i missing something collect seems to be specifically made for mutable operations i dont see where we would use thatso i would just alias reduce with aggregate and scan stays unaliased if thats okay that works for me we can always add more aliases if java adds a scan equivalent i plan on doing a release tomorrow about hours from now if you want to try and have this ready for that rxjava pull requests looks good as soon as this is in my swing branch becomes finally ready for a merge it offers a few simple observables created from button click keyboard and mouse events looking forward to this
331,1,0,0,1,0,0,1,0,adding super extends so that observable is covariant ok so this pull request changes a _lot_ of lines its mostly generalizing all the funcx s to be used like funcx t t tx r contravariant parameters covariant return type and all the observer s to be used in a contravariant way a few of the observable uses are covariant now too mostly zip this is the pull request for this doesnt look very good in the code thanks java also it doesnt seem to make scala interop easier at all at least not yet please take a look im not exactly happy with the result maybe im doing something wrong here ive still got hope that theres an easier waythe pull request compiles and tests ok for me except for the clojure module but thats another story and not due to my changes ill have to spend some time later playing with this anyone else able to try this out and comment on the changes jmhofer can you provide examples or use cases of using the updated code that demonstrates covariant contravariant usage that couldnt be achieved before ok heres an example of what you can do now with the improved zip javaimport rxobservableimport rxutilfunctionsfunc class media {}class movie extends media {}class horrormovie extends movie {}class rating {}class coolrating extends rating {}class result {}class extendedresult extends result {}public class covariance { public static void main string args { observable horrors observablefrom new horrormovie observable ratings observablefrom new coolrating func combine new func { override public extendedresult call media m rating r { return null } } observablezip horrors ratings combine the method zip observable observable func in the type observable is not applicable for the arguments observable observable func but works in super extends branch }} lots more observable usages to go however the observer s are probably mostly done let me know when youre ready for this to be merged and released i plan on releasing this as as it does have some breaking changes that cloudbees build failure is legit i also cant build rxjava scala on my machine with this branch the core library is fine what went wrong execution failed for task language adaptors rxjava scala compilescala compilation failed because of an internal compiler error see the error output for details in this line javaobservable observable observablecreate new func subscription is it the case that java programmers creating an observable this way would always have to include the super bit or is this just for completeness is this what you mean by im not exactly happy with the result i havent thought through it but this doesnt seem like it should be necessary if its done right benjchristensen i just noticed that too and adapted the rximplicits daveray looks like it yes i couldnt make the compiler happy without it but maybe im missing something if you find something that avoids this then please let me know still to do future is covariant and timestamped and notification are probably tooalso lots of operators can be used standalone and therefore should be generalized too rxjava pull requests rxjava pull requests huh very interesting compiles for me rxjava pull requests looks good rxjava pull requests successthis pull request looks good rxjava pull requests successthis pull request looks good rxjava pull requests successthis pull request looks good i would call this ready to merge now i looked through all the code and adapted everything i found i cant guarantee that i havent overlooked something but i guess a few places here and there can still be adapted later on without too much harmthe one caveat is daverays comment maybe the observers are overgeneralized somewhere and we can really avoid people having to write super x when creating their own observers i havent found a solution for this but im probably blind to it by nowof course one could still add a lot of tests or use cases in covariancetest to show that everything compiles as it should in that respect im rather optimistic thoughmaybe we can also get rid of more rawtype unchecked annotations now ill check this later onnow i need some time to recover from all that toiling through java boilerplatery i need to spend some more time on this in my playing around i wasnt thrilled by how it forces this type of user code that has super in it java public static observable o observablecreate new func subscription { override public subscription call observer t { return null } } i have the same concern guava seems to takes the same approach but i dont recall ever having to use type constraints like that when using it briefly looking through the guava code nothing stood out to me though that would make it behave differently though re reading effective java josh bloch says this on page properly used wildcard types are nearly invisible to users of a class they cause methods to accept the parameters they should accept and reject those they should reject if the user of a class has to think about wildcard types there is probably something wrong with the class’s apihowever all of his examples are about methods they arent about instantiating classes like func where ends up as extends subscription perhaps if this is what covariant generics truly requires we create a new function type specifically for this extremely common case of creating an observable and have it be something like this javapublic interface observablefunction extends func subscription { public subscription call observer t } it can then be used like this java public static observable o observablecreate new observablefunction { override public subscription call observer t { return null } } public static class myobserver implements observer { override public void oncompleted { todo auto generated method stub } override public void onerror throwable e { todo auto generated method stub } override public void onnext media args { todo auto generated method stub } } public static void testthis { o subscribe new myobserver } this still requires public subscription call observer t but that is auto generated by an ide and lets face it anyone writing java is using an ide whereas the function definition is far easier new observablefunction probably need a better name than observablefunction but thus far it feels better to use unfortunately it cant be an overload of the existing create method as type erasure and dynamic languages see it as the same thing javapublic static observable create func extends subscription func using the observablefunction works against that but then people would have to discover that new type in some other way to be truly user friendly the method signature would need to change to javapublic static observable create observablefunction func this way people would get prompted by their ides and javadoc to use the easiest approachthis whole thing with or without a new type is a wide impact breaking change all places someone does observablecreate i tried again to do without observer in several relevant places but i failed yet again it seems to be just necessary it stands to reason though if you think about it because observer is a contravariant type and java cant deal with that in any other way and in the case of observers api users are not just using them theyre creating themi like bens observablefunction idea above i think it would probably even be possible to get around the overloading problem by not inheriting from func delegating to it instead however its still a wide impact breaking change due to the super that has to be added within every call method signature concerning observersstill if the create method is the biggest problem maybe its not so big after all or is create really so widely used id think that mostly api users will be using already created observables combining them and subscribing to them here is a trivial example using java demonstrating how super needs to exist even here if retaining type safety java observable omovie observablecreate observer o { oonnext new movie oonnext new movie return subscriptionsempty } map movie { return movie transformed movie } observable omedia observablecreate observer o { oonnext new media oonnext new horrormovie return subscriptionsempty } map movie { return media transformed movie } observablezip omovie omedia a b { return a b } subscribe movie { systemoutprintln media movie movie } or type safety can be thrown away java observable omovie observablecreate observer o { oonnext new movie oonnext new movie return subscriptionsempty } map movie { return movie transformed movie } but now that allows this to compile java observable omovie observablecreate observer o { oonnext new movie oonnext hello this is not a movie object return subscriptionsempty } map movie { return movie transformed movie } jmhofer the create method is how observable s are created so this affects all producers this should not affect consumers other than making the prompts docs verbose screen shot at pm and mustafasezgin do you have any input on this discussion since you are using rxjava from plain java groovy is similar but the generics dont actually do much for it as they are more or less ignored at compile time as best i can tell groovy observable omovie observablecreate { observer o oonnext new movie oonnext new movie return subscriptionsempty } map { movie return movie transformed movie } observable omedia observablecreate { observer o oonnext new media oonnext new horrormovie return subscriptionsempty } map { movie return media transformed movie } observablezip omovie omedia { a b return a b } subscribe { movie systemoutprintln media movie movie } this groovy code works against current master as well as the new code with super groovy observable omovie observablecreate { observer o oonnext new movie oonnext new movie ooncompleted return subscriptionsempty } observable omedia observablecreate { observer o oonnext new media oonnext new horrormovie ooncompleted return subscriptionsempty } observablezip omovie omedia { movie a media b return stringvalueof a stringvalueof b } subscribe { media systemoutprintln media movie media } and here it is again in plain java java observable omovie observablecreate new func subscription { override public subscription call observer o { oonnext new movie oonnext new movie ooncompleted return subscriptionsempty } } observable omedia observablecreate new func subscription { override public subscription call observer o { oonnext new media oonnext new horrormovie ooncompleted return subscriptionsempty } } observablezip omovie omedia new func { override public string call movie a media b { return stringvalueof a stringvalueof b } } subscribe new action { override public void call string media { systemoutprintln media movie media } } it seems that super is fine on the outer generics and doesnt need to be typed everywhere its just when its a generic inside a generic the type of the observer that it becomes annoying it seems the only option while supporting covariance for reducing code verbosity is to create a new type that hides the func extends subscription complexityso my question now is should we change the api to make all uses of create use the new type or should it remain as func and the other type is just a nice utility that can be used to fulfill the signaturein other words do we leave it as this javapublic static observable create func extends subscription func or change it to javapublic static observable create observablefunction func and what do we call the new type if we go that route options ive considered are observablefunction observablefunc onsubscribefunction onsubscribefunc funconsubscribe and should that live in rxutilfunctions or rx alongside rxobservable it feels that this is not generic and should therefore live inside rx unfortunately we can not overload this method and support both as type erasure makes them the same and it will confuse dynamic languages implicits etc if we had two methods with similar single function signaturesnormally id rather leave the lower level func method signature and just have a helper class but code completion and javadocs will be far less obvious and not very discoverable thus for discoverability i think it makes more sense to use create observablefunction func i cant yet think of any forward compatibility reason why this would be a bad thing this pull request is breaking either direction we pursue one last spam to everyone please weigh in if you have an opinion as i intend on making a decision and releasing this weekthis will be a breaking change and affect usage for everyone here is what the observablefunction interface looks like java function interface for work to be performed when an { link observable} is subscribed to via { link observablesubscribe observer } param public interface observablefunction extends func subscription { public subscription call observer t } and the updated create method javapublic static observable create observablefunction func and sample code using this java observable omovie observablecreate new observablefunction { override public subscription call observer o { oonnext new movie oonnext new movie ooncompleted return subscriptionsempty } } here is a fork including these changes so we can review and discuss still not thrilled by any of the directions we can take here i cant argue against making rxjava support covariant types josh bloch certainly supports it in effective java when he says if you write a library that will be widely used the proper use of wildcard types should be considered mandatoryon the flip side it forces the use of super extends everywhere even when covariant requirements are rarei think the only decision at this point to make is whether we should use something like observablefunction to minimize the verbosity or just leave func extends subscription and if we do use observablefunction do we provide similar solutions elsewhere that feels wrong to have special function interfaces for so many things even though it likely will improve readability and usabilityother operators that are awkward include defer func observablefactory aggregate func accumulator buffer func bufferclosingselector flatmap func func flatmap is very common and ends up like this java omediaflatmap new func { override public observable call media s { } } compare this with current java omediaflatmap new func { override public observable call media s { } } however lambdas do make a big different on instance methods not as much on statics as they can infer the types for example in java the above can become this java omediaflatmap value { return null } so without observablefunction in java we have java observablecreate observer o { oonnext new media oonnext new horrormovie return subscriptionsempty } flatmap movie { return observablefrom media transformed moviegetname } with observablefunction in java we get this java observablecreate observer o { oonnext new media oonnext new horrormovie return subscriptionsempty } flatmap movie { return observablefrom media transformed moviegetname } it seems that type inference will handle the instance methods for example aggregate reduce becomes this java observablecreate observer o { oonnext oonnext return subscriptionsempty } aggregate previous current { return previous current } so its only the static methods of concern create being the most significantjava and android are going to be ugly no matter what but we already knew that and they already are this makes it worse experiencing some of the pain with generic method signatures and nestingfirst hand i prefer the type alias in form of an interface i would arguethat the subscription function is so widely used that the interfacecloaking it will be understood quickly enough by developers so the loss indirect clarity should be negligible rxjava pull requests failurelooks like theres a problem with this pull request observablefunction interface but call it something else maybe with subscription subscribe in the name benjchristensen we could overload create etc for this wed have to make observablefunction delegate to func then instead of inheriting from it im not sure if thats a good idea though it would probably be even more confusingim not sure about the naming although it is kind of _the_ internal observable function i think id prefer subscriptionfunction or subscriberfunction or something like that rxjava pull requests successthis pull request looks good how about these names onsubscribefunction onsubscribefunc funconsubscribe based on my highly scientific poll of people around me at my office and the few who have commented above im going with onsubscribefunc benjchristensen works for me will it extend func or be an independent type as jmhofer suggests above i think id prefer the latter i havent played with it not extending func it will need to at least extend function so it fits with all other functions in the codebase in what way will it improve things if it doesnt extend since this function is only intended for us by the observablecreate does anyone have issues with it being namespaced as rxobservableonsubscribefunc as a static inner class of observable rather than a first class citizen rxonsubscribefunc this works great in java are there any issues from clojure or scala doing it this waycreate looks like this javapublic static observable create onsubscribefunc func use of it looks like this java import rxobservable import rxobservableonsubscribefunc observable observable observablecreate new onsubscribefunc { override public subscription call observer observer { observeronnext one observeronnext two observeronnext three observeroncompleted return subscriptionsempty } } the function definition looks like java function interface for work to be performed when an { link observable} is subscribed to via { link observablesubscribe observer } param public static interface onsubscribefunc extends function { public subscription call observer t } good idea and shouldnt be a problem for scala great ill proceed with this change then thanks for the feedback final interface looks like this java function interface for work to be performed when an { link observable} is subscribed to via { link observablesubscribe observer } param public static interface onsubscribefunc extends function { public subscription onsubscribe observer t } this is being merged in
331,1,0,1,1,1,1,1,1,adding super extends so that observable is covariant ok so this pull request changes a _lot_ of lines its mostly generalizing all the funcx s to be used like funcx t t tx r contravariant parameters covariant return type and all the observer s to be used in a contravariant way a few of the observable uses are covariant now too mostly zip this is the pull request for this doesnt look very good in the code thanks java also it doesnt seem to make scala interop easier at all at least not yet please take a look im not exactly happy with the result maybe im doing something wrong here ive still got hope that theres an easier waythe pull request compiles and tests ok for me except for the clojure module but thats another story and not due to my changes ill have to spend some time later playing with this anyone else able to try this out and comment on the changes jmhofer can you provide examples or use cases of using the updated code that demonstrates covariant contravariant usage that couldnt be achieved before ok heres an example of what you can do now with the improved zip javaimport rxobservableimport rxutilfunctionsfunc class media {}class movie extends media {}class horrormovie extends movie {}class rating {}class coolrating extends rating {}class result {}class extendedresult extends result {}public class covariance { public static void main string args { observable horrors observablefrom new horrormovie observable ratings observablefrom new coolrating func combine new func { override public extendedresult call media m rating r { return null } } observablezip horrors ratings combine the method zip observable observable func in the type observable is not applicable for the arguments observable observable func but works in super extends branch }} lots more observable usages to go however the observer s are probably mostly done let me know when youre ready for this to be merged and released i plan on releasing this as as it does have some breaking changes that cloudbees build failure is legit i also cant build rxjava scala on my machine with this branch the core library is fine what went wrong execution failed for task language adaptors rxjava scala compilescala compilation failed because of an internal compiler error see the error output for details in this line javaobservable observable observablecreate new func subscription is it the case that java programmers creating an observable this way would always have to include the super bit or is this just for completeness is this what you mean by im not exactly happy with the result i havent thought through it but this doesnt seem like it should be necessary if its done right benjchristensen i just noticed that too and adapted the rximplicits daveray looks like it yes i couldnt make the compiler happy without it but maybe im missing something if you find something that avoids this then please let me know still to do future is covariant and timestamped and notification are probably tooalso lots of operators can be used standalone and therefore should be generalized too rxjava pull requests rxjava pull requests huh very interesting compiles for me rxjava pull requests looks good rxjava pull requests successthis pull request looks good rxjava pull requests successthis pull request looks good rxjava pull requests successthis pull request looks good i would call this ready to merge now i looked through all the code and adapted everything i found i cant guarantee that i havent overlooked something but i guess a few places here and there can still be adapted later on without too much harmthe one caveat is daverays comment maybe the observers are overgeneralized somewhere and we can really avoid people having to write super x when creating their own observers i havent found a solution for this but im probably blind to it by nowof course one could still add a lot of tests or use cases in covariancetest to show that everything compiles as it should in that respect im rather optimistic thoughmaybe we can also get rid of more rawtype unchecked annotations now ill check this later onnow i need some time to recover from all that toiling through java boilerplatery i need to spend some more time on this in my playing around i wasnt thrilled by how it forces this type of user code that has super in it java public static observable o observablecreate new func subscription { override public subscription call observer t { return null } } i have the same concern guava seems to takes the same approach but i dont recall ever having to use type constraints like that when using it briefly looking through the guava code nothing stood out to me though that would make it behave differently though re reading effective java josh bloch says this on page properly used wildcard types are nearly invisible to users of a class they cause methods to accept the parameters they should accept and reject those they should reject if the user of a class has to think about wildcard types there is probably something wrong with the class’s apihowever all of his examples are about methods they arent about instantiating classes like func where ends up as extends subscription perhaps if this is what covariant generics truly requires we create a new function type specifically for this extremely common case of creating an observable and have it be something like this javapublic interface observablefunction extends func subscription { public subscription call observer t } it can then be used like this java public static observable o observablecreate new observablefunction { override public subscription call observer t { return null } } public static class myobserver implements observer { override public void oncompleted { todo auto generated method stub } override public void onerror throwable e { todo auto generated method stub } override public void onnext media args { todo auto generated method stub } } public static void testthis { o subscribe new myobserver } this still requires public subscription call observer t but that is auto generated by an ide and lets face it anyone writing java is using an ide whereas the function definition is far easier new observablefunction probably need a better name than observablefunction but thus far it feels better to use unfortunately it cant be an overload of the existing create method as type erasure and dynamic languages see it as the same thing javapublic static observable create func extends subscription func using the observablefunction works against that but then people would have to discover that new type in some other way to be truly user friendly the method signature would need to change to javapublic static observable create observablefunction func this way people would get prompted by their ides and javadoc to use the easiest approachthis whole thing with or without a new type is a wide impact breaking change all places someone does observablecreate i tried again to do without observer in several relevant places but i failed yet again it seems to be just necessary it stands to reason though if you think about it because observer is a contravariant type and java cant deal with that in any other way and in the case of observers api users are not just using them theyre creating themi like bens observablefunction idea above i think it would probably even be possible to get around the overloading problem by not inheriting from func delegating to it instead however its still a wide impact breaking change due to the super that has to be added within every call method signature concerning observersstill if the create method is the biggest problem maybe its not so big after all or is create really so widely used id think that mostly api users will be using already created observables combining them and subscribing to them here is a trivial example using java demonstrating how super needs to exist even here if retaining type safety java observable omovie observablecreate observer o { oonnext new movie oonnext new movie return subscriptionsempty } map movie { return movie transformed movie } observable omedia observablecreate observer o { oonnext new media oonnext new horrormovie return subscriptionsempty } map movie { return media transformed movie } observablezip omovie omedia a b { return a b } subscribe movie { systemoutprintln media movie movie } or type safety can be thrown away java observable omovie observablecreate observer o { oonnext new movie oonnext new movie return subscriptionsempty } map movie { return movie transformed movie } but now that allows this to compile java observable omovie observablecreate observer o { oonnext new movie oonnext hello this is not a movie object return subscriptionsempty } map movie { return movie transformed movie } jmhofer the create method is how observable s are created so this affects all producers this should not affect consumers other than making the prompts docs verbose screen shot at pm and mustafasezgin do you have any input on this discussion since you are using rxjava from plain java groovy is similar but the generics dont actually do much for it as they are more or less ignored at compile time as best i can tell groovy observable omovie observablecreate { observer o oonnext new movie oonnext new movie return subscriptionsempty } map { movie return movie transformed movie } observable omedia observablecreate { observer o oonnext new media oonnext new horrormovie return subscriptionsempty } map { movie return media transformed movie } observablezip omovie omedia { a b return a b } subscribe { movie systemoutprintln media movie movie } this groovy code works against current master as well as the new code with super groovy observable omovie observablecreate { observer o oonnext new movie oonnext new movie ooncompleted return subscriptionsempty } observable omedia observablecreate { observer o oonnext new media oonnext new horrormovie ooncompleted return subscriptionsempty } observablezip omovie omedia { movie a media b return stringvalueof a stringvalueof b } subscribe { media systemoutprintln media movie media } and here it is again in plain java java observable omovie observablecreate new func subscription { override public subscription call observer o { oonnext new movie oonnext new movie ooncompleted return subscriptionsempty } } observable omedia observablecreate new func subscription { override public subscription call observer o { oonnext new media oonnext new horrormovie ooncompleted return subscriptionsempty } } observablezip omovie omedia new func { override public string call movie a media b { return stringvalueof a stringvalueof b } } subscribe new action { override public void call string media { systemoutprintln media movie media } } it seems that super is fine on the outer generics and doesnt need to be typed everywhere its just when its a generic inside a generic the type of the observer that it becomes annoying it seems the only option while supporting covariance for reducing code verbosity is to create a new type that hides the func extends subscription complexityso my question now is should we change the api to make all uses of create use the new type or should it remain as func and the other type is just a nice utility that can be used to fulfill the signaturein other words do we leave it as this javapublic static observable create func extends subscription func or change it to javapublic static observable create observablefunction func and what do we call the new type if we go that route options ive considered are observablefunction observablefunc onsubscribefunction onsubscribefunc funconsubscribe and should that live in rxutilfunctions or rx alongside rxobservable it feels that this is not generic and should therefore live inside rx unfortunately we can not overload this method and support both as type erasure makes them the same and it will confuse dynamic languages implicits etc if we had two methods with similar single function signaturesnormally id rather leave the lower level func method signature and just have a helper class but code completion and javadocs will be far less obvious and not very discoverable thus for discoverability i think it makes more sense to use create observablefunction func i cant yet think of any forward compatibility reason why this would be a bad thing this pull request is breaking either direction we pursue one last spam to everyone please weigh in if you have an opinion as i intend on making a decision and releasing this weekthis will be a breaking change and affect usage for everyone here is what the observablefunction interface looks like java function interface for work to be performed when an { link observable} is subscribed to via { link observablesubscribe observer } param public interface observablefunction extends func subscription { public subscription call observer t } and the updated create method javapublic static observable create observablefunction func and sample code using this java observable omovie observablecreate new observablefunction { override public subscription call observer o { oonnext new movie oonnext new movie ooncompleted return subscriptionsempty } } here is a fork including these changes so we can review and discuss still not thrilled by any of the directions we can take here i cant argue against making rxjava support covariant types josh bloch certainly supports it in effective java when he says if you write a library that will be widely used the proper use of wildcard types should be considered mandatoryon the flip side it forces the use of super extends everywhere even when covariant requirements are rarei think the only decision at this point to make is whether we should use something like observablefunction to minimize the verbosity or just leave func extends subscription and if we do use observablefunction do we provide similar solutions elsewhere that feels wrong to have special function interfaces for so many things even though it likely will improve readability and usabilityother operators that are awkward include defer func observablefactory aggregate func accumulator buffer func bufferclosingselector flatmap func func flatmap is very common and ends up like this java omediaflatmap new func { override public observable call media s { } } compare this with current java omediaflatmap new func { override public observable call media s { } } however lambdas do make a big different on instance methods not as much on statics as they can infer the types for example in java the above can become this java omediaflatmap value { return null } so without observablefunction in java we have java observablecreate observer o { oonnext new media oonnext new horrormovie return subscriptionsempty } flatmap movie { return observablefrom media transformed moviegetname } with observablefunction in java we get this java observablecreate observer o { oonnext new media oonnext new horrormovie return subscriptionsempty } flatmap movie { return observablefrom media transformed moviegetname } it seems that type inference will handle the instance methods for example aggregate reduce becomes this java observablecreate observer o { oonnext oonnext return subscriptionsempty } aggregate previous current { return previous current } so its only the static methods of concern create being the most significantjava and android are going to be ugly no matter what but we already knew that and they already are this makes it worse experiencing some of the pain with generic method signatures and nestingfirst hand i prefer the type alias in form of an interface i would arguethat the subscription function is so widely used that the interfacecloaking it will be understood quickly enough by developers so the loss indirect clarity should be negligible rxjava pull requests failurelooks like theres a problem with this pull request observablefunction interface but call it something else maybe with subscription subscribe in the name benjchristensen we could overload create etc for this wed have to make observablefunction delegate to func then instead of inheriting from it im not sure if thats a good idea though it would probably be even more confusingim not sure about the naming although it is kind of _the_ internal observable function i think id prefer subscriptionfunction or subscriberfunction or something like that rxjava pull requests successthis pull request looks good how about these names onsubscribefunction onsubscribefunc funconsubscribe based on my highly scientific poll of people around me at my office and the few who have commented above im going with onsubscribefunc benjchristensen works for me will it extend func or be an independent type as jmhofer suggests above i think id prefer the latter i havent played with it not extending func it will need to at least extend function so it fits with all other functions in the codebase in what way will it improve things if it doesnt extend since this function is only intended for us by the observablecreate does anyone have issues with it being namespaced as rxobservableonsubscribefunc as a static inner class of observable rather than a first class citizen rxonsubscribefunc this works great in java are there any issues from clojure or scala doing it this waycreate looks like this javapublic static observable create onsubscribefunc func use of it looks like this java import rxobservable import rxobservableonsubscribefunc observable observable observablecreate new onsubscribefunc { override public subscription call observer observer { observeronnext one observeronnext two observeronnext three observeroncompleted return subscriptionsempty } } the function definition looks like java function interface for work to be performed when an { link observable} is subscribed to via { link observablesubscribe observer } param public static interface onsubscribefunc extends function { public subscription call observer t } good idea and shouldnt be a problem for scala great ill proceed with this change then thanks for the feedback final interface looks like this java function interface for work to be performed when an { link observable} is subscribed to via { link observablesubscribe observer } param public static interface onsubscribefunc extends function { public subscription onsubscribe observer t } this is being merged in
331,1,0,0,1,1,1,1,1,adding super extends so that observable is covariant ok so this pull request changes a _lot_ of lines its mostly generalizing all the funcx s to be used like funcx t t tx r contravariant parameters covariant return type and all the observer s to be used in a contravariant way a few of the observable uses are covariant now too mostly zip this is the pull request for this doesnt look very good in the code thanks java also it doesnt seem to make scala interop easier at all at least not yet please take a look im not exactly happy with the result maybe im doing something wrong here ive still got hope that theres an easier waythe pull request compiles and tests ok for me except for the clojure module but thats another story and not due to my changes ill have to spend some time later playing with this anyone else able to try this out and comment on the changes jmhofer can you provide examples or use cases of using the updated code that demonstrates covariant contravariant usage that couldnt be achieved before ok heres an example of what you can do now with the improved zip javaimport rxobservableimport rxutilfunctionsfunc class media {}class movie extends media {}class horrormovie extends movie {}class rating {}class coolrating extends rating {}class result {}class extendedresult extends result {}public class covariance { public static void main string args { observable horrors observablefrom new horrormovie observable ratings observablefrom new coolrating func combine new func { override public extendedresult call media m rating r { return null } } observablezip horrors ratings combine the method zip observable observable func in the type observable is not applicable for the arguments observable observable func but works in super extends branch }} lots more observable usages to go however the observer s are probably mostly done let me know when youre ready for this to be merged and released i plan on releasing this as as it does have some breaking changes that cloudbees build failure is legit i also cant build rxjava scala on my machine with this branch the core library is fine what went wrong execution failed for task language adaptors rxjava scala compilescala compilation failed because of an internal compiler error see the error output for details in this line javaobservable observable observablecreate new func subscription is it the case that java programmers creating an observable this way would always have to include the super bit or is this just for completeness is this what you mean by im not exactly happy with the result i havent thought through it but this doesnt seem like it should be necessary if its done right benjchristensen i just noticed that too and adapted the rximplicits daveray looks like it yes i couldnt make the compiler happy without it but maybe im missing something if you find something that avoids this then please let me know still to do future is covariant and timestamped and notification are probably tooalso lots of operators can be used standalone and therefore should be generalized too rxjava pull requests rxjava pull requests huh very interesting compiles for me rxjava pull requests looks good rxjava pull requests successthis pull request looks good rxjava pull requests successthis pull request looks good rxjava pull requests successthis pull request looks good i would call this ready to merge now i looked through all the code and adapted everything i found i cant guarantee that i havent overlooked something but i guess a few places here and there can still be adapted later on without too much harmthe one caveat is daverays comment maybe the observers are overgeneralized somewhere and we can really avoid people having to write super x when creating their own observers i havent found a solution for this but im probably blind to it by nowof course one could still add a lot of tests or use cases in covariancetest to show that everything compiles as it should in that respect im rather optimistic thoughmaybe we can also get rid of more rawtype unchecked annotations now ill check this later onnow i need some time to recover from all that toiling through java boilerplatery i need to spend some more time on this in my playing around i wasnt thrilled by how it forces this type of user code that has super in it java public static observable o observablecreate new func subscription { override public subscription call observer t { return null } } i have the same concern guava seems to takes the same approach but i dont recall ever having to use type constraints like that when using it briefly looking through the guava code nothing stood out to me though that would make it behave differently though re reading effective java josh bloch says this on page properly used wildcard types are nearly invisible to users of a class they cause methods to accept the parameters they should accept and reject those they should reject if the user of a class has to think about wildcard types there is probably something wrong with the class’s apihowever all of his examples are about methods they arent about instantiating classes like func where ends up as extends subscription perhaps if this is what covariant generics truly requires we create a new function type specifically for this extremely common case of creating an observable and have it be something like this javapublic interface observablefunction extends func subscription { public subscription call observer t } it can then be used like this java public static observable o observablecreate new observablefunction { override public subscription call observer t { return null } } public static class myobserver implements observer { override public void oncompleted { todo auto generated method stub } override public void onerror throwable e { todo auto generated method stub } override public void onnext media args { todo auto generated method stub } } public static void testthis { o subscribe new myobserver } this still requires public subscription call observer t but that is auto generated by an ide and lets face it anyone writing java is using an ide whereas the function definition is far easier new observablefunction probably need a better name than observablefunction but thus far it feels better to use unfortunately it cant be an overload of the existing create method as type erasure and dynamic languages see it as the same thing javapublic static observable create func extends subscription func using the observablefunction works against that but then people would have to discover that new type in some other way to be truly user friendly the method signature would need to change to javapublic static observable create observablefunction func this way people would get prompted by their ides and javadoc to use the easiest approachthis whole thing with or without a new type is a wide impact breaking change all places someone does observablecreate i tried again to do without observer in several relevant places but i failed yet again it seems to be just necessary it stands to reason though if you think about it because observer is a contravariant type and java cant deal with that in any other way and in the case of observers api users are not just using them theyre creating themi like bens observablefunction idea above i think it would probably even be possible to get around the overloading problem by not inheriting from func delegating to it instead however its still a wide impact breaking change due to the super that has to be added within every call method signature concerning observersstill if the create method is the biggest problem maybe its not so big after all or is create really so widely used id think that mostly api users will be using already created observables combining them and subscribing to them here is a trivial example using java demonstrating how super needs to exist even here if retaining type safety java observable omovie observablecreate observer o { oonnext new movie oonnext new movie return subscriptionsempty } map movie { return movie transformed movie } observable omedia observablecreate observer o { oonnext new media oonnext new horrormovie return subscriptionsempty } map movie { return media transformed movie } observablezip omovie omedia a b { return a b } subscribe movie { systemoutprintln media movie movie } or type safety can be thrown away java observable omovie observablecreate observer o { oonnext new movie oonnext new movie return subscriptionsempty } map movie { return movie transformed movie } but now that allows this to compile java observable omovie observablecreate observer o { oonnext new movie oonnext hello this is not a movie object return subscriptionsempty } map movie { return movie transformed movie } jmhofer the create method is how observable s are created so this affects all producers this should not affect consumers other than making the prompts docs verbose screen shot at pm and mustafasezgin do you have any input on this discussion since you are using rxjava from plain java groovy is similar but the generics dont actually do much for it as they are more or less ignored at compile time as best i can tell groovy observable omovie observablecreate { observer o oonnext new movie oonnext new movie return subscriptionsempty } map { movie return movie transformed movie } observable omedia observablecreate { observer o oonnext new media oonnext new horrormovie return subscriptionsempty } map { movie return media transformed movie } observablezip omovie omedia { a b return a b } subscribe { movie systemoutprintln media movie movie } this groovy code works against current master as well as the new code with super groovy observable omovie observablecreate { observer o oonnext new movie oonnext new movie ooncompleted return subscriptionsempty } observable omedia observablecreate { observer o oonnext new media oonnext new horrormovie ooncompleted return subscriptionsempty } observablezip omovie omedia { movie a media b return stringvalueof a stringvalueof b } subscribe { media systemoutprintln media movie media } and here it is again in plain java java observable omovie observablecreate new func subscription { override public subscription call observer o { oonnext new movie oonnext new movie ooncompleted return subscriptionsempty } } observable omedia observablecreate new func subscription { override public subscription call observer o { oonnext new media oonnext new horrormovie ooncompleted return subscriptionsempty } } observablezip omovie omedia new func { override public string call movie a media b { return stringvalueof a stringvalueof b } } subscribe new action { override public void call string media { systemoutprintln media movie media } } it seems that super is fine on the outer generics and doesnt need to be typed everywhere its just when its a generic inside a generic the type of the observer that it becomes annoying it seems the only option while supporting covariance for reducing code verbosity is to create a new type that hides the func extends subscription complexityso my question now is should we change the api to make all uses of create use the new type or should it remain as func and the other type is just a nice utility that can be used to fulfill the signaturein other words do we leave it as this javapublic static observable create func extends subscription func or change it to javapublic static observable create observablefunction func and what do we call the new type if we go that route options ive considered are observablefunction observablefunc onsubscribefunction onsubscribefunc funconsubscribe and should that live in rxutilfunctions or rx alongside rxobservable it feels that this is not generic and should therefore live inside rx unfortunately we can not overload this method and support both as type erasure makes them the same and it will confuse dynamic languages implicits etc if we had two methods with similar single function signaturesnormally id rather leave the lower level func method signature and just have a helper class but code completion and javadocs will be far less obvious and not very discoverable thus for discoverability i think it makes more sense to use create observablefunction func i cant yet think of any forward compatibility reason why this would be a bad thing this pull request is breaking either direction we pursue one last spam to everyone please weigh in if you have an opinion as i intend on making a decision and releasing this weekthis will be a breaking change and affect usage for everyone here is what the observablefunction interface looks like java function interface for work to be performed when an { link observable} is subscribed to via { link observablesubscribe observer } param public interface observablefunction extends func subscription { public subscription call observer t } and the updated create method javapublic static observable create observablefunction func and sample code using this java observable omovie observablecreate new observablefunction { override public subscription call observer o { oonnext new movie oonnext new movie ooncompleted return subscriptionsempty } } here is a fork including these changes so we can review and discuss still not thrilled by any of the directions we can take here i cant argue against making rxjava support covariant types josh bloch certainly supports it in effective java when he says if you write a library that will be widely used the proper use of wildcard types should be considered mandatoryon the flip side it forces the use of super extends everywhere even when covariant requirements are rarei think the only decision at this point to make is whether we should use something like observablefunction to minimize the verbosity or just leave func extends subscription and if we do use observablefunction do we provide similar solutions elsewhere that feels wrong to have special function interfaces for so many things even though it likely will improve readability and usabilityother operators that are awkward include defer func observablefactory aggregate func accumulator buffer func bufferclosingselector flatmap func func flatmap is very common and ends up like this java omediaflatmap new func { override public observable call media s { } } compare this with current java omediaflatmap new func { override public observable call media s { } } however lambdas do make a big different on instance methods not as much on statics as they can infer the types for example in java the above can become this java omediaflatmap value { return null } so without observablefunction in java we have java observablecreate observer o { oonnext new media oonnext new horrormovie return subscriptionsempty } flatmap movie { return observablefrom media transformed moviegetname } with observablefunction in java we get this java observablecreate observer o { oonnext new media oonnext new horrormovie return subscriptionsempty } flatmap movie { return observablefrom media transformed moviegetname } it seems that type inference will handle the instance methods for example aggregate reduce becomes this java observablecreate observer o { oonnext oonnext return subscriptionsempty } aggregate previous current { return previous current } so its only the static methods of concern create being the most significantjava and android are going to be ugly no matter what but we already knew that and they already are this makes it worse experiencing some of the pain with generic method signatures and nestingfirst hand i prefer the type alias in form of an interface i would arguethat the subscription function is so widely used that the interfacecloaking it will be understood quickly enough by developers so the loss indirect clarity should be negligible rxjava pull requests failurelooks like theres a problem with this pull request observablefunction interface but call it something else maybe with subscription subscribe in the name benjchristensen we could overload create etc for this wed have to make observablefunction delegate to func then instead of inheriting from it im not sure if thats a good idea though it would probably be even more confusingim not sure about the naming although it is kind of _the_ internal observable function i think id prefer subscriptionfunction or subscriberfunction or something like that rxjava pull requests successthis pull request looks good how about these names onsubscribefunction onsubscribefunc funconsubscribe based on my highly scientific poll of people around me at my office and the few who have commented above im going with onsubscribefunc benjchristensen works for me will it extend func or be an independent type as jmhofer suggests above i think id prefer the latter i havent played with it not extending func it will need to at least extend function so it fits with all other functions in the codebase in what way will it improve things if it doesnt extend since this function is only intended for us by the observablecreate does anyone have issues with it being namespaced as rxobservableonsubscribefunc as a static inner class of observable rather than a first class citizen rxonsubscribefunc this works great in java are there any issues from clojure or scala doing it this waycreate looks like this javapublic static observable create onsubscribefunc func use of it looks like this java import rxobservable import rxobservableonsubscribefunc observable observable observablecreate new onsubscribefunc { override public subscription call observer observer { observeronnext one observeronnext two observeronnext three observeroncompleted return subscriptionsempty } } the function definition looks like java function interface for work to be performed when an { link observable} is subscribed to via { link observablesubscribe observer } param public static interface onsubscribefunc extends function { public subscription call observer t } good idea and shouldnt be a problem for scala great ill proceed with this change then thanks for the feedback final interface looks like this java function interface for work to be performed when an { link observable} is subscribed to via { link observablesubscribe observer } param public static interface onsubscribefunc extends function { public subscription onsubscribe observer t } this is being merged in
375,1,0,0,0,0,0,1,0,implemented distinct operator this pr implements distinct as speficied by again i havent implemented the net methods taking an iequalitycomparator see
375,1,0,1,1,1,1,1,1,implemented distinct operator this pr implements distinct as speficied by again i havent implemented the net methods taking an iequalitycomparator see
375,1,0,0,1,1,1,1,1,implemented distinct operator this pr implements distinct as speficied by again i havent implemented the net methods taking an iequalitycomparator see
381,1,0,0,0,0,0,1,0,implemented mapwithindex as requested by samuelgruetter in test failure again due to sporadic timing problems i just submitted an issue for this
381,1,1,0,1,1,1,1,1,implemented mapwithindex as requested by samuelgruetter in test failure again due to sporadic timing problems i just submitted an issue for this
381,1,0,0,0,0,0,1,0,implemented mapwithindex as requested by samuelgruetter in test failure again due to sporadic timing problems i just submitted an issue for this
385,1,0,0,0,0,0,1,0,implemented the any operator this implements the operator any from in all two variantshowever i encountered two problemsupdated the online document is wrong see my later discussio other question is if i add the any method to rxobservable some unit tests will fail as the method any in rxobservable overrides the method orgmockitomatchersany javalangclass in some unit tests eg rxsubjectsreplaysubject do i need to use another method name or just modify the unit tests now the any methods in rxobservable are commented outthanks i havent looked at the first question yet but on the second one well likely need to stop importing orgmockitomatchers and call it directly orgmockitomatchersany sorry that i missed the keyword empty in my description the first question is im not sure how to handle an empty observable sequence i tested the c any today the environment is vs net i found the description in my vs is determines whether any element of an observable sequence satisfies a condition this is totally different from the online document always did some tests for any here is the code using systemusing systemcollectionsgenericusing systemlinqusing systemtextusing systemreactivelinqnamespace consoleapplication { class program { static void main string args { var any observableempty any anysubscribe x consolewriteline subscriber got x subscriber got false any observablerange any anysubscribe x consolewriteline subscriber got x subscriber got true any observableempty any x true anysubscribe x consolewriteline subscriber got x subscriber got false any observablerange any x x anysubscribe x consolewriteline subscriber got x subscriber got true any observablerange any x x anysubscribe x consolewriteline subscriber got x subscriber got false consolereadline } }} here is the output subscriber got falsesubscriber got truesubscriber got falsesubscriber got truesubscriber got false in summary if an observable sequence is empty any emits false if one element of an observable sequence satisfies the condition any emits true if all elements of an observable sequence do not satisfy the condition any emits false i have implemented the correct any operator please take a look in scala we will probably use isempty instead of any negated and exists somepredicate instead of any somepredicate you could use these names also in java to avoid confusion and name conflicts zsxwing i dont have time tonight but will definitely get to this in the near future thank you for getting involved
385,1,1,0,1,1,1,1,1,implemented the any operator this implements the operator any from in all two variantshowever i encountered two problemsupdated the online document is wrong see my later discussio other question is if i add the any method to rxobservable some unit tests will fail as the method any in rxobservable overrides the method orgmockitomatchersany javalangclass in some unit tests eg rxsubjectsreplaysubject do i need to use another method name or just modify the unit tests now the any methods in rxobservable are commented outthanks i havent looked at the first question yet but on the second one well likely need to stop importing orgmockitomatchers and call it directly orgmockitomatchersany sorry that i missed the keyword empty in my description the first question is im not sure how to handle an empty observable sequence i tested the c any today the environment is vs net i found the description in my vs is determines whether any element of an observable sequence satisfies a condition this is totally different from the online document always did some tests for any here is the code using systemusing systemcollectionsgenericusing systemlinqusing systemtextusing systemreactivelinqnamespace consoleapplication { class program { static void main string args { var any observableempty any anysubscribe x consolewriteline subscriber got x subscriber got false any observablerange any anysubscribe x consolewriteline subscriber got x subscriber got true any observableempty any x true anysubscribe x consolewriteline subscriber got x subscriber got false any observablerange any x x anysubscribe x consolewriteline subscriber got x subscriber got true any observablerange any x x anysubscribe x consolewriteline subscriber got x subscriber got false consolereadline } }} here is the output subscriber got falsesubscriber got truesubscriber got falsesubscriber got truesubscriber got false in summary if an observable sequence is empty any emits false if one element of an observable sequence satisfies the condition any emits true if all elements of an observable sequence do not satisfy the condition any emits false i have implemented the correct any operator please take a look in scala we will probably use isempty instead of any negated and exists somepredicate instead of any somepredicate you could use these names also in java to avoid confusion and name conflicts zsxwing i dont have time tonight but will definitely get to this in the near future thank you for getting involved
385,1,0,0,0,0,0,1,0,implemented the any operator this implements the operator any from in all two variantshowever i encountered two problemsupdated the online document is wrong see my later discussio other question is if i add the any method to rxobservable some unit tests will fail as the method any in rxobservable overrides the method orgmockitomatchersany javalangclass in some unit tests eg rxsubjectsreplaysubject do i need to use another method name or just modify the unit tests now the any methods in rxobservable are commented outthanks i havent looked at the first question yet but on the second one well likely need to stop importing orgmockitomatchers and call it directly orgmockitomatchersany sorry that i missed the keyword empty in my description the first question is im not sure how to handle an empty observable sequence i tested the c any today the environment is vs net i found the description in my vs is determines whether any element of an observable sequence satisfies a condition this is totally different from the online document always did some tests for any here is the code using systemusing systemcollectionsgenericusing systemlinqusing systemtextusing systemreactivelinqnamespace consoleapplication { class program { static void main string args { var any observableempty any anysubscribe x consolewriteline subscriber got x subscriber got false any observablerange any anysubscribe x consolewriteline subscriber got x subscriber got true any observableempty any x true anysubscribe x consolewriteline subscriber got x subscriber got false any observablerange any x x anysubscribe x consolewriteline subscriber got x subscriber got true any observablerange any x x anysubscribe x consolewriteline subscriber got x subscriber got false consolereadline } }} here is the output subscriber got falsesubscriber got truesubscriber got falsesubscriber got truesubscriber got false in summary if an observable sequence is empty any emits false if one element of an observable sequence satisfies the condition any emits true if all elements of an observable sequence do not satisfy the condition any emits false i have implemented the correct any operator please take a look in scala we will probably use isempty instead of any negated and exists somepredicate instead of any somepredicate you could use these names also in java to avoid confusion and name conflicts zsxwing i dont have time tonight but will definitely get to this in the near future thank you for getting involved
390,1,0,0,0,0,0,1,0,implemented the elementat and elementatordefault operators see hithis implements the elementat and elementatordefault operators from for elementat if the index is less than or greater than or equal to the number of elements in the source sequence an indexoutofboundsexception will be threwfor elementatordefault if the index is less than an indexoutofboundsexception will be threw whats more i added a defaultvalue parameter i can not get the element type in the source observable due to type erasure so i can not determine the default value automatically thats why elementatordefault needs a defaultvalue parameter thank you zsxwing
390,1,0,0,0,1,1,1,1,implemented the elementat and elementatordefault operators see hithis implements the elementat and elementatordefault operators from for elementat if the index is less than or greater than or equal to the number of elements in the source sequence an indexoutofboundsexception will be threwfor elementatordefault if the index is less than an indexoutofboundsexception will be threw whats more i added a defaultvalue parameter i can not get the element type in the source observable due to type erasure so i can not determine the default value automatically thats why elementatordefault needs a defaultvalue parameter thank you zsxwing
390,1,0,0,1,1,1,1,1,implemented the elementat and elementatordefault operators see hithis implements the elementat and elementatordefault operators from for elementat if the index is less than or greater than or equal to the number of elements in the source sequence an indexoutofboundsexception will be threwfor elementatordefault if the index is less than an indexoutofboundsexception will be threw whats more i added a defaultvalue parameter i can not get the element type in the source observable due to type erasure so i can not determine the default value automatically thats why elementatordefault needs a defaultvalue parameter thank you zsxwing
409,1,0,0,0,0,0,1,0,implemented synchronize with lock hii implemented to support that sending a lock to the synchronize operatori also found that there was a issue that testmultithreadedwithnpe and testmultithreadedwithnpeinmiddle might fail in some special situation when onerror is invoked before any onnext the last statement assertequals busyobservermaxconcurrentthreadsget in these methods will fail i also this issue in the pull request looks good thank you
409,1,0,1,1,0,1,1,1,implemented synchronize with lock hii implemented to support that sending a lock to the synchronize operatori also found that there was a issue that testmultithreadedwithnpe and testmultithreadedwithnpeinmiddle might fail in some special situation when onerror is invoked before any onnext the last statement assertequals busyobservermaxconcurrentthreadsget in these methods will fail i also this issue in the pull request looks good thank you
409,1,0,0,1,1,1,1,1,implemented synchronize with lock hii implemented to support that sending a lock to the synchronize operatori also found that there was a issue that testmultithreadedwithnpe and testmultithreadedwithnpeinmiddle might fail in some special situation when onerror is invoked before any onnext the last statement assertequals busyobservermaxconcurrentthreadsget in these methods will fail i also this issue in the pull request looks good thank you
415,1,0,0,0,0,0,1,0,implemented the empty operator with scheduler hii implemented the empty operator with scheduler please take a look thanks
415,1,0,1,0,1,1,1,1,implemented the empty operator with scheduler hii implemented the empty operator with scheduler please take a look thanks
415,1,0,1,0,0,0,1,0,implemented the empty operator with scheduler hii implemented the empty operator with scheduler please take a look thanks
416,1,0,0,0,0,0,1,0,implemented the throw operator with scheduler hii implemented the throw operator with scheduler i found that rxjava had an error method so i just implemented the scheduler overload benjchristensen i agree with you i updated the codes and rebased it to master
416,1,1,1,1,1,1,1,1,implemented the throw operator with scheduler hii implemented the throw operator with scheduler i found that rxjava had an error method so i just implemented the scheduler overload benjchristensen i agree with you i updated the codes and rebased it to master
416,1,0,1,0,0,1,1,1,implemented the throw operator with scheduler hii implemented the throw operator with scheduler i found that rxjava had an error method so i just implemented the scheduler overload benjchristensen i agree with you i updated the codes and rebased it to master
424,1,0,0,0,0,0,1,0,implemented the ignoreelements operator hii implemented the ignoreelements operator please take a look thanks can you rebase this with the changes to master so it can be cleanly merged again with all the other changes this no longer cleanly mergesthank you zsxwing for this and all the other pull requests i really appreciate your involvement in the project i rebased the pull request now it should be able to merge to master directly looks good
424,1,1,0,1,1,1,1,1,implemented the ignoreelements operator hii implemented the ignoreelements operator please take a look thanks can you rebase this with the changes to master so it can be cleanly merged again with all the other changes this no longer cleanly mergesthank you zsxwing for this and all the other pull requests i really appreciate your involvement in the project i rebased the pull request now it should be able to merge to master directly looks good
424,1,0,1,1,1,1,1,1,implemented the ignoreelements operator hii implemented the ignoreelements operator please take a look thanks can you rebase this with the changes to master so it can be cleanly merged again with all the other changes this no longer cleanly mergesthank you zsxwing for this and all the other pull requests i really appreciate your involvement in the project i rebased the pull request now it should be able to merge to master directly looks good
450,1,0,0,0,0,0,1,0,implemented the timeinterval operator hi this pr implemented the timeinterval operator please take a look thanks looks good thanks zsxwing
450,1,0,1,0,0,0,1,0,implemented the timeinterval operator hi this pr implemented the timeinterval operator please take a look thanks looks good thanks zsxwing
450,1,0,0,1,0,1,1,1,implemented the timeinterval operator hi this pr implemented the timeinterval operator please take a look thanks looks good thanks zsxwing
460,1,0,0,0,0,0,1,0,implemented the amb operator hi this pr implemented the amb operator i used varargs to support the array version and first second version in one method so in my pr there are only two variants you shouldnt define a vararg method taking a generic type because you cannot use it without getting warnings weve already had this with other operators instead define an overload for args args args yup its a pain but this is what we ended up doing for zip merge etc instead of using varargs thank you
460,1,0,0,0,1,1,1,1,implemented the amb operator hi this pr implemented the amb operator i used varargs to support the array version and first second version in one method so in my pr there are only two variants you shouldnt define a vararg method taking a generic type because you cannot use it without getting warnings weve already had this with other operators instead define an overload for args args args yup its a pain but this is what we ended up doing for zip merge etc instead of using varargs thank you
460,1,0,0,1,1,1,1,1,implemented the amb operator hi this pr implemented the amb operator i used varargs to support the array version and first second version in one method so in my pr there are only two variants you shouldnt define a vararg method taking a generic type because you cannot use it without getting warnings weve already had this with other operators instead define an overload for args args args yup its a pain but this is what we ended up doing for zip merge etc instead of using varargs thank you
463,1,0,0,0,0,1,1,1,added the rest overloads of timeout operator hi this pr implemented the rest overloads of timeout operator please take a look thanks due to pull request which touched virtually every file in the project can you please rebase this so it can merge cleanly again i have rebased it thank you zsxwing
463,1,0,0,0,1,1,1,1,added the rest overloads of timeout operator hi this pr implemented the rest overloads of timeout operator please take a look thanks due to pull request which touched virtually every file in the project can you please rebase this so it can merge cleanly again i have rebased it thank you zsxwing
463,1,0,0,0,1,1,1,1,added the rest overloads of timeout operator hi this pr implemented the rest overloads of timeout operator please take a look thanks due to pull request which touched virtually every file in the project can you please rebase this so it can merge cleanly again i have rebased it thank you zsxwing
478,1,0,0,0,0,0,1,0,implemented the operator min and minby and operator max and maxby hi this pr implemented the operator min and minby and operator max and maxby every operator has variants one for comparable another for comparator please take a look thanks operationmin and operationmax are exactly the same except that are swapped cant you implement one in terms of the other or create a general one which takes or to know whether we want is the following solution ok java public static observable min observable source { return minmax source } public static observable max observable source { return minmax source } public static observable minmax observable source final long flag { return sourcereduce new func { override public t call t acc t value { if flag acccompareto value { return acc } return value } } } flag must be long as integermin_value integermin_value but we will have one multiplication for every compareto another solution is java public static observable min observable source { return minmax source true } public static observable max observable source { return minmax source false } public static observable minmax observable source final boolean ismin { return sourcereduce new func { override public t call t acc t value { if ismin { if acccompareto value { return acc } } return value } } } samuelgruetter do you have other better solution i like both of these two solutions with a slight preference for the first one nice catch with integermin_value a third solution would be to implement max using min and wrapping the given comparator such that it inverts the ordering but i think the first solution is the bestanother issue what if there are several minimal elements does min return the first of them the last of them or is it unspecified this should be documented samuelgruetter thanks for your review i used the way to implement it and also updated the document looks good zsxwing and thanks samuelgruetter for the reviewsome nice use of generics in those signatures
478,1,0,0,0,1,1,1,1,implemented the operator min and minby and operator max and maxby hi this pr implemented the operator min and minby and operator max and maxby every operator has variants one for comparable another for comparator please take a look thanks operationmin and operationmax are exactly the same except that are swapped cant you implement one in terms of the other or create a general one which takes or to know whether we want is the following solution ok java public static observable min observable source { return minmax source } public static observable max observable source { return minmax source } public static observable minmax observable source final long flag { return sourcereduce new func { override public t call t acc t value { if flag acccompareto value { return acc } return value } } } flag must be long as integermin_value integermin_value but we will have one multiplication for every compareto another solution is java public static observable min observable source { return minmax source true } public static observable max observable source { return minmax source false } public static observable minmax observable source final boolean ismin { return sourcereduce new func { override public t call t acc t value { if ismin { if acccompareto value { return acc } } return value } } } samuelgruetter do you have other better solution i like both of these two solutions with a slight preference for the first one nice catch with integermin_value a third solution would be to implement max using min and wrapping the given comparator such that it inverts the ordering but i think the first solution is the bestanother issue what if there are several minimal elements does min return the first of them the last of them or is it unspecified this should be documented samuelgruetter thanks for your review i used the way to implement it and also updated the document looks good zsxwing and thanks samuelgruetter for the reviewsome nice use of generics in those signatures
478,1,0,0,1,1,1,1,1,implemented the operator min and minby and operator max and maxby hi this pr implemented the operator min and minby and operator max and maxby every operator has variants one for comparable another for comparator please take a look thanks operationmin and operationmax are exactly the same except that are swapped cant you implement one in terms of the other or create a general one which takes or to know whether we want is the following solution ok java public static observable min observable source { return minmax source } public static observable max observable source { return minmax source } public static observable minmax observable source final long flag { return sourcereduce new func { override public t call t acc t value { if flag acccompareto value { return acc } return value } } } flag must be long as integermin_value integermin_value but we will have one multiplication for every compareto another solution is java public static observable min observable source { return minmax source true } public static observable max observable source { return minmax source false } public static observable minmax observable source final boolean ismin { return sourcereduce new func { override public t call t acc t value { if ismin { if acccompareto value { return acc } } return value } } } samuelgruetter do you have other better solution i like both of these two solutions with a slight preference for the first one nice catch with integermin_value a third solution would be to implement max using min and wrapping the given comparator such that it inverts the ordering but i think the first solution is the bestanother issue what if there are several minimal elements does min return the first of them the last of them or is it unspecified this should be documented samuelgruetter thanks for your review i used the way to implement it and also updated the document looks good zsxwing and thanks samuelgruetter for the reviewsome nice use of generics in those signatures
478,1,0,0,0,0,0,1,0,implemented the operator min and minby and operator max and maxby hi this pr implemented the operator min and minby and operator max and maxby every operator has variants one for comparable another for comparator please take a look thanks operationmin and operationmax are exactly the same except that are swapped cant you implement one in terms of the other or create a general one which takes or to know whether we want is the following solution ok java public static observable min observable source { return minmax source } public static observable max observable source { return minmax source } public static observable minmax observable source final long flag { return sourcereduce new func { override public t call t acc t value { if flag acccompareto value { return acc } return value } } } flag must be long as integermin_value integermin_value but we will have one multiplication for every compareto another solution is java public static observable min observable source { return minmax source true } public static observable max observable source { return minmax source false } public static observable minmax observable source final boolean ismin { return sourcereduce new func { override public t call t acc t value { if ismin { if acccompareto value { return acc } } return value } } } samuelgruetter do you have other better solution i like both of these two solutions with a slight preference for the first one nice catch with integermin_value a third solution would be to implement max using min and wrapping the given comparator such that it inverts the ordering but i think the first solution is the bestanother issue what if there are several minimal elements does min return the first of them the last of them or is it unspecified this should be documented samuelgruetter thanks for your review i used the way to implement it and also updated the document looks good zsxwing and thanks samuelgruetter for the reviewsome nice use of generics in those signatures
478,1,0,1,0,0,1,1,0,implemented the operator min and minby and operator max and maxby hi this pr implemented the operator min and minby and operator max and maxby every operator has variants one for comparable another for comparator please take a look thanks operationmin and operationmax are exactly the same except that are swapped cant you implement one in terms of the other or create a general one which takes or to know whether we want is the following solution ok java public static observable min observable source { return minmax source } public static observable max observable source { return minmax source } public static observable minmax observable source final long flag { return sourcereduce new func { override public t call t acc t value { if flag acccompareto value { return acc } return value } } } flag must be long as integermin_value integermin_value but we will have one multiplication for every compareto another solution is java public static observable min observable source { return minmax source true } public static observable max observable source { return minmax source false } public static observable minmax observable source final boolean ismin { return sourcereduce new func { override public t call t acc t value { if ismin { if acccompareto value { return acc } } return value } } } samuelgruetter do you have other better solution i like both of these two solutions with a slight preference for the first one nice catch with integermin_value a third solution would be to implement max using min and wrapping the given comparator such that it inverts the ordering but i think the first solution is the bestanother issue what if there are several minimal elements does min return the first of them the last of them or is it unspecified this should be documented samuelgruetter thanks for your review i used the way to implement it and also updated the document looks good zsxwing and thanks samuelgruetter for the reviewsome nice use of generics in those signatures
478,1,0,0,0,0,0,1,0,implemented the operator min and minby and operator max and maxby hi this pr implemented the operator min and minby and operator max and maxby every operator has variants one for comparable another for comparator please take a look thanks operationmin and operationmax are exactly the same except that are swapped cant you implement one in terms of the other or create a general one which takes or to know whether we want is the following solution ok java public static observable min observable source { return minmax source } public static observable max observable source { return minmax source } public static observable minmax observable source final long flag { return sourcereduce new func { override public t call t acc t value { if flag acccompareto value { return acc } return value } } } flag must be long as integermin_value integermin_value but we will have one multiplication for every compareto another solution is java public static observable min observable source { return minmax source true } public static observable max observable source { return minmax source false } public static observable minmax observable source final boolean ismin { return sourcereduce new func { override public t call t acc t value { if ismin { if acccompareto value { return acc } } return value } } } samuelgruetter do you have other better solution i like both of these two solutions with a slight preference for the first one nice catch with integermin_value a third solution would be to implement max using min and wrapping the given comparator such that it inverts the ordering but i think the first solution is the bestanother issue what if there are several minimal elements does min return the first of them the last of them or is it unspecified this should be documented samuelgruetter thanks for your review i used the way to implement it and also updated the document looks good zsxwing and thanks samuelgruetter for the reviewsome nice use of generics in those signatures
480,1,0,0,0,0,0,1,0,bugfix emit an illegalargumentexception instead of arithmeticexception if the observable is empty this pr the average issue in if an observable is empty average will emit an illegalargumentexception instead of arithmeticexception thanks
480,1,0,0,1,1,1,1,1,bugfix emit an illegalargumentexception instead of arithmeticexception if the observable is empty this pr the average issue in if an observable is empty average will emit an illegalargumentexception instead of arithmeticexception thanks
480,1,0,1,0,1,1,1,1,bugfix emit an illegalargumentexception instead of arithmeticexception if the observable is empty this pr the average issue in if an observable is empty average will emit an illegalargumentexception instead of arithmeticexception thanks
481,1,0,0,0,0,0,1,0,implement the using operator hi this pr implemented the using operator please take a look thanks interesting operator hadnt really ever looked at this onethank you zsxwing for the implementation
481,1,0,0,1,1,1,1,1,implement the using operator hi this pr implemented the using operator please take a look thanks interesting operator hadnt really ever looked at this onethank you zsxwing for the implementation
481,1,0,0,0,1,1,1,1,implement the using operator hi this pr implemented the using operator please take a look thanks interesting operator hadnt really ever looked at this onethank you zsxwing for the implementation
492,1,0,0,0,0,0,1,0,implement the scheduler overloads for range from startwith hi this pr implemented the scheduler overloads for range from startwith please take a look thanks this conflicts and cant merge can you rebase and update the pr please i have updated the pr
492,1,0,0,1,1,1,1,1,implement the scheduler overloads for range from startwith hi this pr implemented the scheduler overloads for range from startwith please take a look thanks this conflicts and cant merge can you rebase and update the pr please i have updated the pr
492,1,0,1,0,0,0,1,0,implement the scheduler overloads for range from startwith hi this pr implemented the scheduler overloads for range from startwith please take a look thanks this conflicts and cant merge can you rebase and update the pr please i have updated the pr
492,1,0,0,0,0,0,1,0,implement the scheduler overloads for range from startwith hi this pr implemented the scheduler overloads for range from startwith please take a look thanks this conflicts and cant merge can you rebase and update the pr please i have updated the pr
492,1,0,0,1,1,1,1,1,implement the scheduler overloads for range from startwith hi this pr implemented the scheduler overloads for range from startwith please take a look thanks this conflicts and cant merge can you rebase and update the pr please i have updated the pr
492,1,1,0,0,0,0,1,0,implement the scheduler overloads for range from startwith hi this pr implemented the scheduler overloads for range from startwith please take a look thanks this conflicts and cant merge can you rebase and update the pr please i have updated the pr
492,1,0,0,0,0,0,1,0,implement the scheduler overloads for range from startwith hi this pr implemented the scheduler overloads for range from startwith please take a look thanks this conflicts and cant merge can you rebase and update the pr please i have updated the pr
492,1,0,0,1,1,1,1,1,implement the scheduler overloads for range from startwith hi this pr implemented the scheduler overloads for range from startwith please take a look thanks this conflicts and cant merge can you rebase and update the pr please i have updated the pr
492,1,0,0,0,0,1,1,1,implement the scheduler overloads for range from startwith hi this pr implemented the scheduler overloads for range from startwith please take a look thanks this conflicts and cant merge can you rebase and update the pr please i have updated the pr
496,1,0,0,0,0,0,1,0,add contravariant for min and max hi this pr added contravariant for min and max mentioned in
496,1,0,1,0,0,0,1,0,add contravariant for min and max hi this pr added contravariant for min and max mentioned in
496,1,0,0,1,1,1,1,1,add contravariant for min and max hi this pr added contravariant for min and max mentioned in
506,1,0,0,0,0,0,1,0,operators and then when issue issue issue can be extended to plan plan and pattern pattern if action action is available not sure about the actionn version i dont understand i used the master havent touched groupby or the schedulers the build succeeds on my machine although with jdk now whatedit i found the logical error in operationgroupbytest assuming the thread will finish if it emits items is unreliable should that assertion be tested at all just another case of the operationgroupbytest test issue has not be yet that is an impressive contribution akarnokd i dont see any problems in my review the unit tests were essential to understanding and trusting this so thank you for being thoroughim going to merge this and leverage the fact that were still pre so that if there are any issues found we can still fix them even if we need to break a signature
506,1,1,0,1,1,1,1,1,operators and then when issue issue issue can be extended to plan plan and pattern pattern if action action is available not sure about the actionn version i dont understand i used the master havent touched groupby or the schedulers the build succeeds on my machine although with jdk now whatedit i found the logical error in operationgroupbytest assuming the thread will finish if it emits items is unreliable should that assertion be tested at all just another case of the operationgroupbytest test issue has not be yet that is an impressive contribution akarnokd i dont see any problems in my review the unit tests were essential to understanding and trusting this so thank you for being thoroughim going to merge this and leverage the fact that were still pre so that if there are any issues found we can still fix them even if we need to break a signature
506,1,0,0,1,1,1,1,1,operators and then when issue issue issue can be extended to plan plan and pattern pattern if action action is available not sure about the actionn version i dont understand i used the master havent touched groupby or the schedulers the build succeeds on my machine although with jdk now whatedit i found the logical error in operationgroupbytest assuming the thread will finish if it emits items is unreliable should that assertion be tested at all just another case of the operationgroupbytest test issue has not be yet that is an impressive contribution akarnokd i dont see any problems in my review the unit tests were essential to understanding and trusting this so thank you for being thoroughim going to merge this and leverage the fact that were still pre so that if there are any issues found we can still fix them even if we need to break a signature
506,1,0,0,0,0,0,1,0,operators and then when issue issue issue can be extended to plan plan and pattern pattern if action action is available not sure about the actionn version i dont understand i used the master havent touched groupby or the schedulers the build succeeds on my machine although with jdk now whatedit i found the logical error in operationgroupbytest assuming the thread will finish if it emits items is unreliable should that assertion be tested at all just another case of the operationgroupbytest test issue has not be yet that is an impressive contribution akarnokd i dont see any problems in my review the unit tests were essential to understanding and trusting this so thank you for being thoroughim going to merge this and leverage the fact that were still pre so that if there are any issues found we can still fix them even if we need to break a signature
506,1,0,0,1,1,1,1,1,operators and then when issue issue issue can be extended to plan plan and pattern pattern if action action is available not sure about the actionn version i dont understand i used the master havent touched groupby or the schedulers the build succeeds on my machine although with jdk now whatedit i found the logical error in operationgroupbytest assuming the thread will finish if it emits items is unreliable should that assertion be tested at all just another case of the operationgroupbytest test issue has not be yet that is an impressive contribution akarnokd i dont see any problems in my review the unit tests were essential to understanding and trusting this so thank you for being thoroughim going to merge this and leverage the fact that were still pre so that if there are any issues found we can still fix them even if we need to break a signature
506,1,0,0,1,1,1,1,1,operators and then when issue issue issue can be extended to plan plan and pattern pattern if action action is available not sure about the actionn version i dont understand i used the master havent touched groupby or the schedulers the build succeeds on my machine although with jdk now whatedit i found the logical error in operationgroupbytest assuming the thread will finish if it emits items is unreliable should that assertion be tested at all just another case of the operationgroupbytest test issue has not be yet that is an impressive contribution akarnokd i dont see any problems in my review the unit tests were essential to understanding and trusting this so thank you for being thoroughim going to merge this and leverage the fact that were still pre so that if there are any issues found we can still fix them even if we need to break a signature
506,1,0,0,0,0,0,1,0,operators and then when issue issue issue can be extended to plan plan and pattern pattern if action action is available not sure about the actionn version i dont understand i used the master havent touched groupby or the schedulers the build succeeds on my machine although with jdk now whatedit i found the logical error in operationgroupbytest assuming the thread will finish if it emits items is unreliable should that assertion be tested at all just another case of the operationgroupbytest test issue has not be yet that is an impressive contribution akarnokd i dont see any problems in my review the unit tests were essential to understanding and trusting this so thank you for being thoroughim going to merge this and leverage the fact that were still pre so that if there are any issues found we can still fix them even if we need to break a signature
506,1,0,0,1,1,1,1,1,operators and then when issue issue issue can be extended to plan plan and pattern pattern if action action is available not sure about the actionn version i dont understand i used the master havent touched groupby or the schedulers the build succeeds on my machine although with jdk now whatedit i found the logical error in operationgroupbytest assuming the thread will finish if it emits items is unreliable should that assertion be tested at all just another case of the operationgroupbytest test issue has not be yet that is an impressive contribution akarnokd i dont see any problems in my review the unit tests were essential to understanding and trusting this so thank you for being thoroughim going to merge this and leverage the fact that were still pre so that if there are any issues found we can still fix them even if we need to break a signature
506,1,0,0,1,1,1,1,1,operators and then when issue issue issue can be extended to plan plan and pattern pattern if action action is available not sure about the actionn version i dont understand i used the master havent touched groupby or the schedulers the build succeeds on my machine although with jdk now whatedit i found the logical error in operationgroupbytest assuming the thread will finish if it emits items is unreliable should that assertion be tested at all just another case of the operationgroupbytest test issue has not be yet that is an impressive contribution akarnokd i dont see any problems in my review the unit tests were essential to understanding and trusting this so thank you for being thoroughim going to merge this and leverage the fact that were still pre so that if there are any issues found we can still fix them even if we need to break a signature
513,1,0,0,0,0,0,1,0,operators tomap and tomultimap again issue and issue tomap overloadstomultimap overloadsadded groovy test to verify overloading ah this cant merge anymore because of other commits probably the join operator on your other pr can you rebase
513,1,0,0,1,1,1,1,1,operators tomap and tomultimap again issue and issue tomap overloadstomultimap overloadsadded groovy test to verify overloading ah this cant merge anymore because of other commits probably the join operator on your other pr can you rebase
513,1,0,1,0,0,1,1,1,operators tomap and tomultimap again issue and issue tomap overloadstomultimap overloadsadded groovy test to verify overloading ah this cant merge anymore because of other commits probably the join operator on your other pr can you rebase
513,1,0,0,0,0,0,1,0,operators tomap and tomultimap again issue and issue tomap overloadstomultimap overloadsadded groovy test to verify overloading ah this cant merge anymore because of other commits probably the join operator on your other pr can you rebase
513,1,1,0,1,1,1,1,1,operators tomap and tomultimap again issue and issue tomap overloadstomultimap overloadsadded groovy test to verify overloading ah this cant merge anymore because of other commits probably the join operator on your other pr can you rebase
513,1,0,0,1,1,1,1,1,operators tomap and tomultimap again issue and issue tomap overloadstomultimap overloadsadded groovy test to verify overloading ah this cant merge anymore because of other commits probably the join operator on your other pr can you rebase
560,1,0,0,0,0,0,1,0,add type variances for dooneach actions this fixes the use of contravariant actions issue
560,1,0,1,1,0,1,1,0,add type variances for dooneach actions this fixes the use of contravariant actions issue
560,1,0,1,0,0,0,1,0,add type variances for dooneach actions this fixes the use of contravariant actions issue
563,1,0,0,0,0,0,1,0,operation groupbyuntil issue rebased
563,1,1,0,1,1,1,1,1,operation groupbyuntil issue rebased
563,1,0,1,0,0,0,1,0,operation groupbyuntil issue rebased
565,1,0,0,0,0,0,1,0,operator groupjoin v issue rebasedstill headinthebox while writing the test for the operator ive noticed that when both duration selectors are never rxnet never calls oncompleted on the group subjects even though the left and right sources oncomplete i havent seen rxnet test for this scenario this comes into play when i want to emulate join with groupjoin the outer merge never oncompletes if i understand the behavior corretly when both left and right sources get depleted there is no way a new group or new group value would arrive and all the open groups and the main observer can be oncompleted this is somewhat similar to join and groupbyuntil behavior
565,1,1,0,1,1,1,1,1,operator groupjoin v issue rebasedstill headinthebox while writing the test for the operator ive noticed that when both duration selectors are never rxnet never calls oncompleted on the group subjects even though the left and right sources oncomplete i havent seen rxnet test for this scenario this comes into play when i want to emulate join with groupjoin the outer merge never oncompletes if i understand the behavior corretly when both left and right sources get depleted there is no way a new group or new group value would arrive and all the open groups and the main observer can be oncompleted this is somewhat similar to join and groupbyuntil behavior
565,1,0,1,0,0,1,1,0,operator groupjoin v issue rebasedstill headinthebox while writing the test for the operator ive noticed that when both duration selectors are never rxnet never calls oncompleted on the group subjects even though the left and right sources oncomplete i havent seen rxnet test for this scenario this comes into play when i want to emulate join with groupjoin the outer merge never oncompletes if i understand the behavior corretly when both left and right sources get depleted there is no way a new group or new group value would arrive and all the open groups and the main observer can be oncompleted this is somewhat similar to join and groupbyuntil behavior
571,1,0,0,0,0,0,1,0,operation sample with observable v issue sample will terminate if either the source or the sampler terminates or throws an error the sampler now emits values only in its onnext method therefore if the sampler completes and there is a sampled value available valuetaken false it wont emit the value before terminating
571,1,1,1,0,0,0,1,0,operation sample with observable v issue sample will terminate if either the source or the sampler terminates or throws an error the sampler now emits values only in its onnext method therefore if the sampler completes and there is a sampled value available valuetaken false it wont emit the value before terminating
571,1,0,0,1,1,1,1,1,operation sample with observable v issue sample will terminate if either the source or the sampler terminates or throws an error the sampler now emits values only in its onnext method therefore if the sampler completes and there is a sampled value available valuetaken false it wont emit the value before terminating
575,1,0,0,0,0,0,1,0,reimplement the sequenceequal operator hi this pr reimplemented the sequenceequal operator and should fix the issue the wiki page still needs to be updated davidmgross could you help update the marble diagram of sequenceequal thanks okay i think ive got it corrected it only covers one condition so mightbenefit from having some more examples but itll do for nowon fri dec at am cloudbees pull request builder plugin wrote rxjava pull requests this pull request looks good — reply to this email directly or view it on github david m grossplp consulting davidmgross looks cool good job just a few things you are using gate to ensure concurrency and you access the firstdone and seconddone while synchronizing over gate i believe these two can be simple boolean fields instead of atomicbooleans you are setting the firstvalues and secondvalues in the init method into a volatile fields i believe these can be moved into the constructor and set to a regular private final list type and accessor optional you might want to call clear on both firstvalues and secondvalues if there was a termination condition so they dont hold onto queued values until the client observer disappears i really think that sequenceequal should be implemented in terms of other operators dont reinvent the wheel with every operator you add in scala id do it like this scaladef sequenceequal t o observable t o observable t observable boolean { val obs observable option t o map some _ observable none is concat val obs observable option t o map some _ observable none if different length comparing the none of the shorter with some element of the longer will return false obs zip obs forall pair pair_ pair_ } samuelgruetter great idea really thanks i overrode the previous commit as their is no option in java i use notification instead looks good i also have a question about notificationhasvalue java retrieves a value indicating whether this notification has a value return a value indicating whether this notification has a value public boolean hasvalue { return isonnext && value null } here it checks if value is not null but i think value can be nulli also checked the rxnet codes here c returns true public override bool hasvalue { get { return true } } it returns true directly in onnextnotification if notificationhasvalue has the same meaning in rxjava and rxnet i think && value null needs to be removed rxjava pull requests successthis pull request looks good much nicer now regarding hasvalue i dont know what is it good for if its the same as isonnext and why would one need the current version imho it could just be removedsomething else regarding null values and sequenceequal with default equality i think you shouldnt call onerror nullpointerexception but just onnext true or onnext false samuelgruetter thanks for reminding me the null issue rxjava pull requests successthis pull request looks good
575,1,0,0,1,1,1,1,1,reimplement the sequenceequal operator hi this pr reimplemented the sequenceequal operator and should fix the issue the wiki page still needs to be updated davidmgross could you help update the marble diagram of sequenceequal thanks okay i think ive got it corrected it only covers one condition so mightbenefit from having some more examples but itll do for nowon fri dec at am cloudbees pull request builder plugin wrote rxjava pull requests this pull request looks good — reply to this email directly or view it on github david m grossplp consulting davidmgross looks cool good job just a few things you are using gate to ensure concurrency and you access the firstdone and seconddone while synchronizing over gate i believe these two can be simple boolean fields instead of atomicbooleans you are setting the firstvalues and secondvalues in the init method into a volatile fields i believe these can be moved into the constructor and set to a regular private final list type and accessor optional you might want to call clear on both firstvalues and secondvalues if there was a termination condition so they dont hold onto queued values until the client observer disappears i really think that sequenceequal should be implemented in terms of other operators dont reinvent the wheel with every operator you add in scala id do it like this scaladef sequenceequal t o observable t o observable t observable boolean { val obs observable option t o map some _ observable none is concat val obs observable option t o map some _ observable none if different length comparing the none of the shorter with some element of the longer will return false obs zip obs forall pair pair_ pair_ } samuelgruetter great idea really thanks i overrode the previous commit as their is no option in java i use notification instead looks good i also have a question about notificationhasvalue java retrieves a value indicating whether this notification has a value return a value indicating whether this notification has a value public boolean hasvalue { return isonnext && value null } here it checks if value is not null but i think value can be nulli also checked the rxnet codes here c returns true public override bool hasvalue { get { return true } } it returns true directly in onnextnotification if notificationhasvalue has the same meaning in rxjava and rxnet i think && value null needs to be removed rxjava pull requests successthis pull request looks good much nicer now regarding hasvalue i dont know what is it good for if its the same as isonnext and why would one need the current version imho it could just be removedsomething else regarding null values and sequenceequal with default equality i think you shouldnt call onerror nullpointerexception but just onnext true or onnext false samuelgruetter thanks for reminding me the null issue rxjava pull requests successthis pull request looks good
575,1,0,1,0,1,1,1,1,reimplement the sequenceequal operator hi this pr reimplemented the sequenceequal operator and should fix the issue the wiki page still needs to be updated davidmgross could you help update the marble diagram of sequenceequal thanks okay i think ive got it corrected it only covers one condition so mightbenefit from having some more examples but itll do for nowon fri dec at am cloudbees pull request builder plugin wrote rxjava pull requests this pull request looks good — reply to this email directly or view it on github david m grossplp consulting davidmgross looks cool good job just a few things you are using gate to ensure concurrency and you access the firstdone and seconddone while synchronizing over gate i believe these two can be simple boolean fields instead of atomicbooleans you are setting the firstvalues and secondvalues in the init method into a volatile fields i believe these can be moved into the constructor and set to a regular private final list type and accessor optional you might want to call clear on both firstvalues and secondvalues if there was a termination condition so they dont hold onto queued values until the client observer disappears i really think that sequenceequal should be implemented in terms of other operators dont reinvent the wheel with every operator you add in scala id do it like this scaladef sequenceequal t o observable t o observable t observable boolean { val obs observable option t o map some _ observable none is concat val obs observable option t o map some _ observable none if different length comparing the none of the shorter with some element of the longer will return false obs zip obs forall pair pair_ pair_ } samuelgruetter great idea really thanks i overrode the previous commit as their is no option in java i use notification instead looks good i also have a question about notificationhasvalue java retrieves a value indicating whether this notification has a value return a value indicating whether this notification has a value public boolean hasvalue { return isonnext && value null } here it checks if value is not null but i think value can be nulli also checked the rxnet codes here c returns true public override bool hasvalue { get { return true } } it returns true directly in onnextnotification if notificationhasvalue has the same meaning in rxjava and rxnet i think && value null needs to be removed rxjava pull requests successthis pull request looks good much nicer now regarding hasvalue i dont know what is it good for if its the same as isonnext and why would one need the current version imho it could just be removedsomething else regarding null values and sequenceequal with default equality i think you shouldnt call onerror nullpointerexception but just onnext true or onnext false samuelgruetter thanks for reminding me the null issue rxjava pull requests successthis pull request looks good
575,1,0,0,0,0,0,1,0,reimplement the sequenceequal operator hi this pr reimplemented the sequenceequal operator and should fix the issue the wiki page still needs to be updated davidmgross could you help update the marble diagram of sequenceequal thanks okay i think ive got it corrected it only covers one condition so mightbenefit from having some more examples but itll do for nowon fri dec at am cloudbees pull request builder plugin wrote rxjava pull requests this pull request looks good — reply to this email directly or view it on github david m grossplp consulting davidmgross looks cool good job just a few things you are using gate to ensure concurrency and you access the firstdone and seconddone while synchronizing over gate i believe these two can be simple boolean fields instead of atomicbooleans you are setting the firstvalues and secondvalues in the init method into a volatile fields i believe these can be moved into the constructor and set to a regular private final list type and accessor optional you might want to call clear on both firstvalues and secondvalues if there was a termination condition so they dont hold onto queued values until the client observer disappears i really think that sequenceequal should be implemented in terms of other operators dont reinvent the wheel with every operator you add in scala id do it like this scaladef sequenceequal t o observable t o observable t observable boolean { val obs observable option t o map some _ observable none is concat val obs observable option t o map some _ observable none if different length comparing the none of the shorter with some element of the longer will return false obs zip obs forall pair pair_ pair_ } samuelgruetter great idea really thanks i overrode the previous commit as their is no option in java i use notification instead looks good i also have a question about notificationhasvalue java retrieves a value indicating whether this notification has a value return a value indicating whether this notification has a value public boolean hasvalue { return isonnext && value null } here it checks if value is not null but i think value can be nulli also checked the rxnet codes here c returns true public override bool hasvalue { get { return true } } it returns true directly in onnextnotification if notificationhasvalue has the same meaning in rxjava and rxnet i think && value null needs to be removed rxjava pull requests successthis pull request looks good much nicer now regarding hasvalue i dont know what is it good for if its the same as isonnext and why would one need the current version imho it could just be removedsomething else regarding null values and sequenceequal with default equality i think you shouldnt call onerror nullpointerexception but just onnext true or onnext false samuelgruetter thanks for reminding me the null issue rxjava pull requests successthis pull request looks good
575,1,1,0,1,1,1,1,1,reimplement the sequenceequal operator hi this pr reimplemented the sequenceequal operator and should fix the issue the wiki page still needs to be updated davidmgross could you help update the marble diagram of sequenceequal thanks okay i think ive got it corrected it only covers one condition so mightbenefit from having some more examples but itll do for nowon fri dec at am cloudbees pull request builder plugin wrote rxjava pull requests this pull request looks good — reply to this email directly or view it on github david m grossplp consulting davidmgross looks cool good job just a few things you are using gate to ensure concurrency and you access the firstdone and seconddone while synchronizing over gate i believe these two can be simple boolean fields instead of atomicbooleans you are setting the firstvalues and secondvalues in the init method into a volatile fields i believe these can be moved into the constructor and set to a regular private final list type and accessor optional you might want to call clear on both firstvalues and secondvalues if there was a termination condition so they dont hold onto queued values until the client observer disappears i really think that sequenceequal should be implemented in terms of other operators dont reinvent the wheel with every operator you add in scala id do it like this scaladef sequenceequal t o observable t o observable t observable boolean { val obs observable option t o map some _ observable none is concat val obs observable option t o map some _ observable none if different length comparing the none of the shorter with some element of the longer will return false obs zip obs forall pair pair_ pair_ } samuelgruetter great idea really thanks i overrode the previous commit as their is no option in java i use notification instead looks good i also have a question about notificationhasvalue java retrieves a value indicating whether this notification has a value return a value indicating whether this notification has a value public boolean hasvalue { return isonnext && value null } here it checks if value is not null but i think value can be nulli also checked the rxnet codes here c returns true public override bool hasvalue { get { return true } } it returns true directly in onnextnotification if notificationhasvalue has the same meaning in rxjava and rxnet i think && value null needs to be removed rxjava pull requests successthis pull request looks good much nicer now regarding hasvalue i dont know what is it good for if its the same as isonnext and why would one need the current version imho it could just be removedsomething else regarding null values and sequenceequal with default equality i think you shouldnt call onerror nullpointerexception but just onnext true or onnext false samuelgruetter thanks for reminding me the null issue rxjava pull requests successthis pull request looks good
575,1,0,0,0,0,0,1,0,reimplement the sequenceequal operator hi this pr reimplemented the sequenceequal operator and should fix the issue the wiki page still needs to be updated davidmgross could you help update the marble diagram of sequenceequal thanks okay i think ive got it corrected it only covers one condition so mightbenefit from having some more examples but itll do for nowon fri dec at am cloudbees pull request builder plugin wrote rxjava pull requests this pull request looks good — reply to this email directly or view it on github david m grossplp consulting davidmgross looks cool good job just a few things you are using gate to ensure concurrency and you access the firstdone and seconddone while synchronizing over gate i believe these two can be simple boolean fields instead of atomicbooleans you are setting the firstvalues and secondvalues in the init method into a volatile fields i believe these can be moved into the constructor and set to a regular private final list type and accessor optional you might want to call clear on both firstvalues and secondvalues if there was a termination condition so they dont hold onto queued values until the client observer disappears i really think that sequenceequal should be implemented in terms of other operators dont reinvent the wheel with every operator you add in scala id do it like this scaladef sequenceequal t o observable t o observable t observable boolean { val obs observable option t o map some _ observable none is concat val obs observable option t o map some _ observable none if different length comparing the none of the shorter with some element of the longer will return false obs zip obs forall pair pair_ pair_ } samuelgruetter great idea really thanks i overrode the previous commit as their is no option in java i use notification instead looks good i also have a question about notificationhasvalue java retrieves a value indicating whether this notification has a value return a value indicating whether this notification has a value public boolean hasvalue { return isonnext && value null } here it checks if value is not null but i think value can be nulli also checked the rxnet codes here c returns true public override bool hasvalue { get { return true } } it returns true directly in onnextnotification if notificationhasvalue has the same meaning in rxjava and rxnet i think && value null needs to be removed rxjava pull requests successthis pull request looks good much nicer now regarding hasvalue i dont know what is it good for if its the same as isonnext and why would one need the current version imho it could just be removedsomething else regarding null values and sequenceequal with default equality i think you shouldnt call onerror nullpointerexception but just onnext true or onnext false samuelgruetter thanks for reminding me the null issue rxjava pull requests successthis pull request looks good
587,1,0,0,0,0,0,1,0,operation longcount issue straightforward version of the regular count however i would have implemented it differently so the constant boxing unboxing could be avoided
587,1,0,0,0,1,1,1,1,operation longcount issue straightforward version of the regular count however i would have implemented it differently so the constant boxing unboxing could be avoided
593,1,0,0,0,0,0,1,0,lock free subscriptions uniform naming of inner components issue lock free approach to avoid deadlocks issue serialsubscriptionisunsubscribe added issue remarks imo an unsubscribed single serial multiple subscription return subscriptionsempty instead of null so unless the user put a null in there he she shouldnt worry about null there was a concurrency bug in jloisel s reimplementation of compositesubscription it allowed multiple threads to enter the mutation part if the current state was already mutate ive added the necessary checks to allow only normal mutate transitions it cannot return subscriptionsempty since the rx contract is to return null also returning empty when unsubscribed is ambiguous has it been unsubscribed or has empty been set by the client code good that you the race condition in multipleassignementsubscription as well as the contract it was unsubscribing the previous subscription although it shouldnt ive checked the rxnet sources singleassignmentdisposable returns defaultdisposableinstance serialdisposabe returns null refcountdisposable returns disposableempty scheduleddisposable returns defaultdisposableinstanceso my question is why only serialdisposable returns null checking the return of the getsubscription to determine if unsubscription happened is wrong since serialsubscription can be started with null this is why isunsubscribed is to be used to check the state it cannot return subscriptionsempty since the rx contract is to return nulli dont think that is actually this strict that is what the implementation does i think it is better to return empty than null the real state is is isunsubscribed and the properties might as well be write only i think the disposable subscription contract lakes precision and uniformity it doesnt matter to return null or empty what matters is a constant behavior following the least astonishment principle
593,1,1,0,0,0,0,1,0,lock free subscriptions uniform naming of inner components issue lock free approach to avoid deadlocks issue serialsubscriptionisunsubscribe added issue remarks imo an unsubscribed single serial multiple subscription return subscriptionsempty instead of null so unless the user put a null in there he she shouldnt worry about null there was a concurrency bug in jloisel s reimplementation of compositesubscription it allowed multiple threads to enter the mutation part if the current state was already mutate ive added the necessary checks to allow only normal mutate transitions it cannot return subscriptionsempty since the rx contract is to return null also returning empty when unsubscribed is ambiguous has it been unsubscribed or has empty been set by the client code good that you the race condition in multipleassignementsubscription as well as the contract it was unsubscribing the previous subscription although it shouldnt ive checked the rxnet sources singleassignmentdisposable returns defaultdisposableinstance serialdisposabe returns null refcountdisposable returns disposableempty scheduleddisposable returns defaultdisposableinstanceso my question is why only serialdisposable returns null checking the return of the getsubscription to determine if unsubscription happened is wrong since serialsubscription can be started with null this is why isunsubscribed is to be used to check the state it cannot return subscriptionsempty since the rx contract is to return nulli dont think that is actually this strict that is what the implementation does i think it is better to return empty than null the real state is is isunsubscribed and the properties might as well be write only i think the disposable subscription contract lakes precision and uniformity it doesnt matter to return null or empty what matters is a constant behavior following the least astonishment principle
593,1,0,0,0,0,0,1,0,lock free subscriptions uniform naming of inner components issue lock free approach to avoid deadlocks issue serialsubscriptionisunsubscribe added issue remarks imo an unsubscribed single serial multiple subscription return subscriptionsempty instead of null so unless the user put a null in there he she shouldnt worry about null there was a concurrency bug in jloisel s reimplementation of compositesubscription it allowed multiple threads to enter the mutation part if the current state was already mutate ive added the necessary checks to allow only normal mutate transitions it cannot return subscriptionsempty since the rx contract is to return null also returning empty when unsubscribed is ambiguous has it been unsubscribed or has empty been set by the client code good that you the race condition in multipleassignementsubscription as well as the contract it was unsubscribing the previous subscription although it shouldnt ive checked the rxnet sources singleassignmentdisposable returns defaultdisposableinstance serialdisposabe returns null refcountdisposable returns disposableempty scheduleddisposable returns defaultdisposableinstanceso my question is why only serialdisposable returns null checking the return of the getsubscription to determine if unsubscription happened is wrong since serialsubscription can be started with null this is why isunsubscribed is to be used to check the state it cannot return subscriptionsempty since the rx contract is to return nulli dont think that is actually this strict that is what the implementation does i think it is better to return empty than null the real state is is isunsubscribed and the properties might as well be write only i think the disposable subscription contract lakes precision and uniformity it doesnt matter to return null or empty what matters is a constant behavior following the least astonishment principle
593,1,0,1,0,0,1,1,1,lock free subscriptions uniform naming of inner components issue lock free approach to avoid deadlocks issue serialsubscriptionisunsubscribe added issue remarks imo an unsubscribed single serial multiple subscription return subscriptionsempty instead of null so unless the user put a null in there he she shouldnt worry about null there was a concurrency bug in jloisel s reimplementation of compositesubscription it allowed multiple threads to enter the mutation part if the current state was already mutate ive added the necessary checks to allow only normal mutate transitions it cannot return subscriptionsempty since the rx contract is to return null also returning empty when unsubscribed is ambiguous has it been unsubscribed or has empty been set by the client code good that you the race condition in multipleassignementsubscription as well as the contract it was unsubscribing the previous subscription although it shouldnt ive checked the rxnet sources singleassignmentdisposable returns defaultdisposableinstance serialdisposabe returns null refcountdisposable returns disposableempty scheduleddisposable returns defaultdisposableinstanceso my question is why only serialdisposable returns null checking the return of the getsubscription to determine if unsubscription happened is wrong since serialsubscription can be started with null this is why isunsubscribed is to be used to check the state it cannot return subscriptionsempty since the rx contract is to return nulli dont think that is actually this strict that is what the implementation does i think it is better to return empty than null the real state is is isunsubscribed and the properties might as well be write only i think the disposable subscription contract lakes precision and uniformity it doesnt matter to return null or empty what matters is a constant behavior following the least astonishment principle
593,1,0,0,0,0,0,1,0,lock free subscriptions uniform naming of inner components issue lock free approach to avoid deadlocks issue serialsubscriptionisunsubscribe added issue remarks imo an unsubscribed single serial multiple subscription return subscriptionsempty instead of null so unless the user put a null in there he she shouldnt worry about null there was a concurrency bug in jloisel s reimplementation of compositesubscription it allowed multiple threads to enter the mutation part if the current state was already mutate ive added the necessary checks to allow only normal mutate transitions it cannot return subscriptionsempty since the rx contract is to return null also returning empty when unsubscribed is ambiguous has it been unsubscribed or has empty been set by the client code good that you the race condition in multipleassignementsubscription as well as the contract it was unsubscribing the previous subscription although it shouldnt ive checked the rxnet sources singleassignmentdisposable returns defaultdisposableinstance serialdisposabe returns null refcountdisposable returns disposableempty scheduleddisposable returns defaultdisposableinstanceso my question is why only serialdisposable returns null checking the return of the getsubscription to determine if unsubscription happened is wrong since serialsubscription can be started with null this is why isunsubscribed is to be used to check the state it cannot return subscriptionsempty since the rx contract is to return nulli dont think that is actually this strict that is what the implementation does i think it is better to return empty than null the real state is is isunsubscribed and the properties might as well be write only i think the disposable subscription contract lakes precision and uniformity it doesnt matter to return null or empty what matters is a constant behavior following the least astonishment principle
593,1,0,0,1,1,1,1,1,lock free subscriptions uniform naming of inner components issue lock free approach to avoid deadlocks issue serialsubscriptionisunsubscribe added issue remarks imo an unsubscribed single serial multiple subscription return subscriptionsempty instead of null so unless the user put a null in there he she shouldnt worry about null there was a concurrency bug in jloisel s reimplementation of compositesubscription it allowed multiple threads to enter the mutation part if the current state was already mutate ive added the necessary checks to allow only normal mutate transitions it cannot return subscriptionsempty since the rx contract is to return null also returning empty when unsubscribed is ambiguous has it been unsubscribed or has empty been set by the client code good that you the race condition in multipleassignementsubscription as well as the contract it was unsubscribing the previous subscription although it shouldnt ive checked the rxnet sources singleassignmentdisposable returns defaultdisposableinstance serialdisposabe returns null refcountdisposable returns disposableempty scheduleddisposable returns defaultdisposableinstanceso my question is why only serialdisposable returns null checking the return of the getsubscription to determine if unsubscription happened is wrong since serialsubscription can be started with null this is why isunsubscribed is to be used to check the state it cannot return subscriptionsempty since the rx contract is to return nulli dont think that is actually this strict that is what the implementation does i think it is better to return empty than null the real state is is isunsubscribed and the properties might as well be write only i think the disposable subscription contract lakes precision and uniformity it doesnt matter to return null or empty what matters is a constant behavior following the least astonishment principle
594,1,0,0,0,0,0,1,0,implement the start operator hi this pr implemented the start operator please take a look nice so observablestart func might become the new way of creating futures maybe add some tests which illustrate what happens if i subscribe to observablestart before while after its calculation has terminated and what happens if there are several subscribers i think its correctly implemented but just to make everything more stable and better documented thanks samuelgruetter i added more tests is it necessary to construct a special test that subscribe and func run at the same time i think before and after are enough looks good
594,1,0,1,0,0,0,1,0,implement the start operator hi this pr implemented the start operator please take a look nice so observablestart func might become the new way of creating futures maybe add some tests which illustrate what happens if i subscribe to observablestart before while after its calculation has terminated and what happens if there are several subscribers i think its correctly implemented but just to make everything more stable and better documented thanks samuelgruetter i added more tests is it necessary to construct a special test that subscribe and func run at the same time i think before and after are enough looks good
612,1,0,0,0,0,0,1,0,replay additional overloads issue added several overloads of the replay operator limited buffer limited time window buffer time scheduler overloads versions which perform a projection before the replay added missing multicast overload could you give me an explanation of what the selector does and why itsuseful and also what the version of replay that uses a subject factory isall about the javadocs are opaque to me and the msdn docs intro to rxarent helpful eitheron thu dec at pm cloudbees pull request builder plugin wrote rxjava pull requests this pull request looks good — reply to this email directly or view it on github david m grossplp consulting im not sure myself i think it allows transforming the subjects output without the danger of resubscribing to the uplink source i couldnt find any tests for them in the rxnet sources
612,1,0,1,0,0,0,1,0,replay additional overloads issue added several overloads of the replay operator limited buffer limited time window buffer time scheduler overloads versions which perform a projection before the replay added missing multicast overload could you give me an explanation of what the selector does and why itsuseful and also what the version of replay that uses a subject factory isall about the javadocs are opaque to me and the msdn docs intro to rxarent helpful eitheron thu dec at pm cloudbees pull request builder plugin wrote rxjava pull requests this pull request looks good — reply to this email directly or view it on github david m grossplp consulting im not sure myself i think it allows transforming the subjects output without the danger of resubscribing to the uplink source i couldnt find any tests for them in the rxnet sources
635,1,0,0,0,0,0,1,0,operators switchcase case ifthen if dowhile dowhile whiledo w hile issue no msdn references available
635,1,0,0,0,0,1,1,1,operators switchcase case ifthen if dowhile dowhile whiledo w hile issue no msdn references available
657,1,0,0,0,0,0,1,0,operations aggregate average and sum with selector issue remarks i know we can combine ops to get one of the new aggregate variant but i think it might be worth having a direct version which avoids nesting several layers of observables observers and subscriptions the averageinteger and suminteger and the other types are handy if we want to use chained operation invocations with less overhead javaobservablefrom a bb ccc suminteger s slength toblockingobservable single instead of javaobservablesumintegers observablefrom a bb ccc map s slength toblockingobservable single this establishes or strengthens a precedent of adding a large number of helper methods for very specific cases to the already massive observable so id like to explore one of two routes move mathematical operators to a separate observable in rxobservablenumericalobservable or something like that move them into a contrib module like id go for numericalobservable on this one as it is primarily useful out of box whereas futures may go into contrib
657,1,0,1,0,0,1,1,1,operations aggregate average and sum with selector issue remarks i know we can combine ops to get one of the new aggregate variant but i think it might be worth having a direct version which avoids nesting several layers of observables observers and subscriptions the averageinteger and suminteger and the other types are handy if we want to use chained operation invocations with less overhead javaobservablefrom a bb ccc suminteger s slength toblockingobservable single instead of javaobservablesumintegers observablefrom a bb ccc map s slength toblockingobservable single this establishes or strengthens a precedent of adding a large number of helper methods for very specific cases to the already massive observable so id like to explore one of two routes move mathematical operators to a separate observable in rxobservablenumericalobservable or something like that move them into a contrib module like id go for numericalobservable on this one as it is primarily useful out of box whereas futures may go into contrib
667,1,0,0,0,0,0,1,0,operators skip skiplast take with time rebased version without the drain scheduler variant fixes issue mentioned in as well
667,1,0,1,0,1,1,1,1,operators skip skiplast take with time rebased version without the drain scheduler variant fixes issue mentioned in as well
733,1,0,0,0,0,0,1,0,buffer with observable boundary mentined in issue overload where the user can specify the capacity of the internal buffer
733,1,0,1,0,0,1,1,0,buffer with observable boundary mentined in issue overload where the user can specify the capacity of the internal buffer
734,1,0,0,0,0,0,1,0,delay with subscription and item delaying observables listed in note onerror and oncompleted events of the source are immediately propagated and will prevent emitting any pending values
734,1,0,0,1,1,1,1,1,delay with subscription and item delaying observables listed in note onerror and oncompleted events of the source are immediately propagated and will prevent emitting any pending values
735,1,0,0,0,0,0,1,0,window with observable boundary listed in issue
735,1,0,0,1,0,1,1,1,window with observable boundary listed in issue
736,1,0,0,0,0,0,1,0,mergemap with iterable and resultselector overloads listed in forgot an overload looks these operators can be implemented by composing the existing operators i agree there is likely some simplification we can do on this but im going to merge as the public apis look correct and unit tests are good we can iterate on the implementation internally
736,1,0,0,1,0,1,1,1,mergemap with iterable and resultselector overloads listed in forgot an overload looks these operators can be implemented by composing the existing operators i agree there is likely some simplification we can do on this but im going to merge as the public apis look correct and unit tests are good we can iterate on the implementation internally
738,1,0,0,0,0,0,1,0,publish and publishlast overloads listed in these operators use the existing multicast and subject infrastructure so i omitted any direct tests
738,1,0,1,0,1,1,1,1,publish and publishlast overloads listed in these operators use the existing multicast and subject infrastructure so i omitted any direct tests
740,1,0,0,0,0,0,1,0,timeout with selector overloads listed in
740,1,0,0,1,0,1,1,1,timeout with selector overloads listed in
741,1,0,0,0,0,0,1,0,zip with iterable removed old aggregator version and updated tests listed in these are instance methods none of our zip operators are at the instance level i would have thought wed add the zip overloads with iterable to match the existing static ones i went according to where there was zip overloads without strike through agreed on the overloads but they should be static correct no the intention was to chain them to an existing observable javaobservablefrom zip arraysaslist a b a b makes sense wasnt sure as it was different than all the other zip methods thanks for confirming
741,1,0,0,1,1,1,1,1,zip with iterable removed old aggregator version and updated tests listed in these are instance methods none of our zip operators are at the instance level i would have thought wed add the zip overloads with iterable to match the existing static ones i went according to where there was zip overloads without strike through agreed on the overloads but they should be static correct no the intention was to chain them to an existing observable javaobservablefrom zip arraysaslist a b a b makes sense wasnt sure as it was different than all the other zip methods thanks for confirming
825,1,0,0,0,0,0,1,0,issue commenting out the call to attachcallingthreadstack when co nstructing a compositeexception should i merge this manually into
825,1,0,1,0,0,0,1,0,issue commenting out the call to attachcallingthreadstack when co nstructing a compositeexception should i merge this manually into
860,1,0,0,0,0,0,1,0,fixing the generics for merge and lift ive tracked down to two problems the first is that lift wasnt quite right i changed the lift argument from operator to operator unfortunately java wont let us hide that away in the operator class so we have to redeclare that everywhere in the debug hooks but its still better than the alternative of having to use the full func super subscriber everywherethe second problem was in the return type of merge observable because of operators like merge observable t observable t the only thing that can be said for the return type is that it is also observable but at the moment it is returning observable this pull request changes all of them and leads to some silly return values like observable a bobservable x merge a b we should avoid return types such as a akarnokd you were right the return type change wasnt necessary ive reverted and rebased the branch to clean out all the mistakes rxjava pull requests i almost did a pr on this when i saw you now did the same thing as i but was it necessary to change the debugs as well yes there is a plugin hook inside lift that the debug plugin implements and spreads from there
860,1,0,0,0,0,0,1,0,fixing the generics for merge and lift ive tracked down to two problems the first is that lift wasnt quite right i changed the lift argument from operator to operator unfortunately java wont let us hide that away in the operator class so we have to redeclare that everywhere in the debug hooks but its still better than the alternative of having to use the full func super subscriber everywherethe second problem was in the return type of merge observable because of operators like merge observable t observable t the only thing that can be said for the return type is that it is also observable but at the moment it is returning observable this pull request changes all of them and leads to some silly return values like observable a bobservable x merge a b we should avoid return types such as a akarnokd you were right the return type change wasnt necessary ive reverted and rebased the branch to clean out all the mistakes rxjava pull requests i almost did a pr on this when i saw you now did the same thing as i but was it necessary to change the debugs as well yes there is a plugin hook inside lift that the debug plugin implements and spreads from there
955,1,0,0,1,0,1,1,1,replaysubject leak fix for issue i can confirm this for me thanks akarnokd this might in fact be the final nail in the coffin for any workarounds we used on android to prevent activities from leaking this is great benjchristensen do you think we could get this in for that would be fantastic it would simplify reasoning about requirements for android operators a lot since the use of cache and replay is quite common on android and some design decisions for operatorobservefromandroidcomponent were made purely due to the existence of this bug no one actually thought to question the correctness of the underlying operator back then hah
955,1,0,0,1,1,1,1,1,replaysubject leak fix for issue i can confirm this for me thanks akarnokd this might in fact be the final nail in the coffin for any workarounds we used on android to prevent activities from leaking this is great benjchristensen do you think we could get this in for that would be fantastic it would simplify reasoning about requirements for android operators a lot since the use of cache and replay is quite common on android and some design decisions for operatorobservefromandroidcomponent were made purely due to the existence of this bug no one actually thought to question the correctness of the underlying operator back then hah
964,1,0,0,1,0,1,1,1,subjectsubscriptionmanager fix fix for if an already unsubscribed subscriber is added the subscription function ends up in an infinite loop as the inner unsubscription logic changes the state to another object before the outer state machine continues the outer state machine loop now exits if unsubscription happened and doesnt attempt to modify the state the removeobserver method is changed so that if the subscription to be removed is not in the array it returns this instead of an unnecessary copy in addition copyof calls have been replaced by arraycopy to avoid reflective array creation interesting bug thanks for the fixas for the test failure looks like testnumberofthreadsonscheduledmerge has become non deterministic as a result of recent changes not your commit
964,1,0,1,0,0,1,1,0,subjectsubscriptionmanager fix fix for if an already unsubscribed subscriber is added the subscription function ends up in an infinite loop as the inner unsubscription logic changes the state to another object before the outer state machine continues the outer state machine loop now exits if unsubscription happened and doesnt attempt to modify the state the removeobserver method is changed so that if the subscription to be removed is not in the array it returns this instead of an unnecessary copy in addition copyof calls have been replaced by arraycopy to avoid reflective array creation interesting bug thanks for the fixas for the test failure looks like testnumberofthreadsonscheduledmerge has become non deterministic as a result of recent changes not your commit
965,0,0,0,0,0,0,1,0,bugfix chain subscription in timeoutsubscriber and serializedsubscriber this pr chains subscription in timeoutsubscriber and serializedsubscriber found by rbramw thanks for your unit tests rbramw i have no idea why rxoperatorsoperationparallelmergetesttestnumberofthreadsonscheduledmerge failed in my local machine it fails sometimes is it nondeterministic rebased thank you
965,1,1,0,0,0,0,1,0,bugfix chain subscription in timeoutsubscriber and serializedsubscriber this pr chains subscription in timeoutsubscriber and serializedsubscriber found by rbramw thanks for your unit tests rbramw i have no idea why rxoperatorsoperationparallelmergetesttestnumberofthreadsonscheduledmerge failed in my local machine it fails sometimes is it nondeterministic rebased thank you
972,1,0,0,1,0,0,1,0,deadlock in subjects operatorcache fix for issue i had to rewrite operatorcache to allow testing for deadlocks in all subject types the terminationlatch was unnecessarily waiting for existing subscribers to deliver their termination events which caused deadlock with repeat treating subjects as internal implementations was not necessary to fix the problem i dont understand these changes yet but on first review they are very awkward as the subjectsubscriptionmanager methods now both invoke a function and return a collection true the rewritten subjects dont require an action they are fine with action the changes had to be made since the countdonwlatch logic acted as a synchronization block and emitting events while holding locks is prone to deadlocks as the associated issue demonstrates ah holding the lock is the issue we should find a way of doing that without the latches at all as it is blocking the latch has its use because once the state has been swapped to terminal state we still need to perform some tasks on any related state within the particular subject before client notifications can resume usually it is to set the last event which then will be available to newcomers i havent merged this yet as i need to spend time better understanding this and the impact on design since this has conflicts and i did some cleanup based on our discussion above ive opened for merging this
972,1,0,1,0,0,0,1,0,deadlock in subjects operatorcache fix for issue i had to rewrite operatorcache to allow testing for deadlocks in all subject types the terminationlatch was unnecessarily waiting for existing subscribers to deliver their termination events which caused deadlock with repeat treating subjects as internal implementations was not necessary to fix the problem i dont understand these changes yet but on first review they are very awkward as the subjectsubscriptionmanager methods now both invoke a function and return a collection true the rewritten subjects dont require an action they are fine with action the changes had to be made since the countdonwlatch logic acted as a synchronization block and emitting events while holding locks is prone to deadlocks as the associated issue demonstrates ah holding the lock is the issue we should find a way of doing that without the latches at all as it is blocking the latch has its use because once the state has been swapped to terminal state we still need to perform some tasks on any related state within the particular subject before client notifications can resume usually it is to set the last event which then will be available to newcomers i havent merged this yet as i need to spend time better understanding this and the impact on design since this has conflicts and i did some cleanup based on our discussion above ive opened for merging this
1073,1,0,0,0,0,0,1,0,operatorbuffer operator buffer split into variantsissue there are some important behavioral changes compared to the original versions when an onerror event appears from anywhere the currently accumulated chunk s are _not_ emitted before the error is propagated this conforms with rx design guideline the observable returned by the func inside the buffer func now is used as long as possible and whenever it fires an event a new buffer chunk is started the func is called only once per subscriber the original called it and subscribed to it all the time causing all increasing resubscriptions
1073,1,0,0,0,1,1,1,1,operatorbuffer operator buffer split into variantsissue there are some important behavioral changes compared to the original versions when an onerror event appears from anywhere the currently accumulated chunk s are _not_ emitted before the error is propagated this conforms with rx design guideline the observable returned by the func inside the buffer func now is used as long as possible and whenever it fires an event a new buffer chunk is started the func is called only once per subscriber the original called it and subscribed to it all the time causing all increasing resubscriptions
1079,1,0,0,0,0,0,1,0,operatorcombinelatest operator combinelatestissue remarks added an overload to observable which accepts any number of sources not sure why it wasnt exposed before perhaps removed relying on just the sos onnext is not enough as leaving the synchronized block allows reordering of onnext calls therefore the combinator uses the trick from serializedobserver to make sure the combination order is consistent with whe winning of the synchronization race
1079,1,1,0,0,0,0,1,0,operatorcombinelatest operator combinelatestissue remarks added an overload to observable which accepts any number of sources not sure why it wasnt exposed before perhaps removed relying on just the sos onnext is not enough as leaving the synchronized block allows reordering of onnext calls therefore the combinator uses the trick from serializedobserver to make sure the combination order is consistent with whe winning of the synchronization race
1083,1,0,0,0,0,0,1,0,operatordematerialize operator dematerializeissue two notes since the dematerialize is an instance method there is no correct type parametrization for the operator therefore i just used a raw version in the call the original dematerialize could send out two oncompleted or an onerror followed by an oncompleted because the materialize always adds an oncompleted after the raw events this affected operators due to unsafesubscribe this new version ensures this doesnt happen
1083,1,0,1,0,0,0,1,0,operatordematerialize operator dematerializeissue two notes since the dematerialize is an instance method there is no correct type parametrization for the operator therefore i just used a raw version in the call the original dematerialize could send out two oncompleted or an onerror followed by an oncompleted because the materialize always adds an oncompleted after the raw events this affected operators due to unsafesubscribe this new version ensures this doesnt happen
1084,1,0,0,0,0,0,1,0,operatordistinct operator distinctissue i didnt port the variant with the custom key comparator because it has been decided to rely on objectequals and there were not exposed anyway
1084,1,0,0,0,0,0,1,0,operatordistinct operator distinctissue i didnt port the variant with the custom key comparator because it has been decided to rely on objectequals and there were not exposed anyway
1085,1,0,0,0,0,0,1,0,operatordistinctuntilchanged operator distinctuntilchangedissue again i havent ported the custom comparator version
1085,1,0,0,0,1,1,1,1,operatordistinctuntilchanged operator distinctuntilchangedissue again i havent ported the custom comparator version
1095,1,0,0,0,0,0,1,0,operatorgroupbyuntil operator groupbyuntilfor issue while rewriting ive noticed a common pitfall with the observation of the duration many other operators react to onnext or oncompleted but one should only expire once ill review my recent operators and post a separate pr if any
1095,1,0,0,1,0,1,1,1,operatorgroupbyuntil operator groupbyuntilfor issue while rewriting ive noticed a common pitfall with the observation of the duration many other operators react to onnext or oncompleted but one should only expire once ill review my recent operators and post a separate pr if any
1096,1,0,0,0,0,0,1,0,operatorgroupjoin operator groupjoinfor issue maybe this could be moved to the new joins is this better associated with rxjava joins
1096,1,1,0,0,0,0,1,0,operatorgroupjoin operator groupjoinfor issue maybe this could be moved to the new joins is this better associated with rxjava joins
1103,1,0,0,0,0,0,1,0,operatorjoin operator joinissue remark now that the clientonnext is called outside the synchronization block joint results may appear in arbitrary order in case both left and right observables emit values concurrently i suppose the strict ordering is not really expected here but someone who uses this operator can tell duncani perhaps rxoperatorsoperatorpivottesttestconcurrencyandserialization needs some fixing rxoperatorsoperatorpivottesttestconcurrencyandserialization needs some fixing yes it does
1103,1,0,1,0,0,0,1,0,operatorjoin operator joinissue remark now that the clientonnext is called outside the synchronization block joint results may appear in arbitrary order in case both left and right observables emit values concurrently i suppose the strict ordering is not really expected here but someone who uses this operator can tell duncani perhaps rxoperatorsoperatorpivottesttestconcurrencyandserialization needs some fixing rxoperatorsoperatorpivottesttestconcurrencyandserialization needs some fixing yes it does
1120,1,0,0,0,0,0,1,0,operatorsequenceequal operator sequenceequal lightened the operator but note that notificationlite escaping an operator may cause undesired effects in other operators relying on notificationlite as well
1120,1,0,0,1,1,1,1,1,operatorsequenceequal operator sequenceequal lightened the operator but note that notificationlite escaping an operator may cause undesired effects in other operators relying on notificationlite as well
1121,1,0,0,0,0,0,1,0,operatorskiptimed operator skiptimed there was an unexpected dependency in operationtaketimedtest and is surely to cause conflict when taketimed is rewritten once all operators have been merged i suggest we create a primary testexception and rewrite tests to use it instead of all those custom exception classes everywhere
1121,1,0,0,0,1,1,1,1,operatorskiptimed operator skiptimed there was an unexpected dependency in operationtaketimedtest and is surely to cause conflict when taketimed is rewritten once all operators have been merged i suggest we create a primary testexception and rewrite tests to use it instead of all those custom exception classes everywhere
1132,1,0,0,0,0,0,1,0,manual merge of several prs merging many prs that were conflictingheroic work by akarnokd and zsxwing on all unit tests are passing on my machine going to let this bake a while before a release other prs on still on their way
1132,1,0,0,1,1,1,1,1,manual merge of several prs merging many prs that were conflictingheroic work by akarnokd and zsxwing on all unit tests are passing on my machine going to let this bake a while before a release other prs on still on their way
1160,1,0,0,0,0,0,1,0,add replay and multicast variants to rxscala this pr has some breaking changes change def multicast r t subject rxlangscalasubject r subscription observable r to def multicast r t subject rxlangscalasubject r connectableobservable r change def replay subscription observable t to def replay connectableobservable t remove observableapply int so its better to merge it at the next major release cc headinthebox samuelgruetter id like someone with better scala skills that me to review this please ill code review it later today but in principle these are simple fixes to bring the other variants of publish in sync with returning connectable observable looks good is this reviewed and ready to go it is conflicting against master so can you please rebase this is also conflicting against i would like to rebase it after is merged to master waiting until is already merged rxjava pull requests successthis pull request looks good should this wait until were ready to do i think this one can be merged since has already broken the api headinthebox samuelgruetter do you mind it go for it
1160,1,0,1,0,0,1,1,1,add replay and multicast variants to rxscala this pr has some breaking changes change def multicast r t subject rxlangscalasubject r subscription observable r to def multicast r t subject rxlangscalasubject r connectableobservable r change def replay subscription observable t to def replay connectableobservable t remove observableapply int so its better to merge it at the next major release cc headinthebox samuelgruetter id like someone with better scala skills that me to review this please ill code review it later today but in principle these are simple fixes to bring the other variants of publish in sync with returning connectable observable looks good is this reviewed and ready to go it is conflicting against master so can you please rebase this is also conflicting against i would like to rebase it after is merged to master waiting until is already merged rxjava pull requests successthis pull request looks good should this wait until were ready to do i think this one can be merged since has already broken the api headinthebox samuelgruetter do you mind it go for it
1160,1,0,0,0,0,0,1,0,add replay and multicast variants to rxscala this pr has some breaking changes change def multicast r t subject rxlangscalasubject r subscription observable r to def multicast r t subject rxlangscalasubject r connectableobservable r change def replay subscription observable t to def replay connectableobservable t remove observableapply int so its better to merge it at the next major release cc headinthebox samuelgruetter id like someone with better scala skills that me to review this please ill code review it later today but in principle these are simple fixes to bring the other variants of publish in sync with returning connectable observable looks good is this reviewed and ready to go it is conflicting against master so can you please rebase this is also conflicting against i would like to rebase it after is merged to master waiting until is already merged rxjava pull requests successthis pull request looks good should this wait until were ready to do i think this one can be merged since has already broken the api headinthebox samuelgruetter do you mind it go for it
1160,1,0,0,1,0,1,1,1,add replay and multicast variants to rxscala this pr has some breaking changes change def multicast r t subject rxlangscalasubject r subscription observable r to def multicast r t subject rxlangscalasubject r connectableobservable r change def replay subscription observable t to def replay connectableobservable t remove observableapply int so its better to merge it at the next major release cc headinthebox samuelgruetter id like someone with better scala skills that me to review this please ill code review it later today but in principle these are simple fixes to bring the other variants of publish in sync with returning connectable observable looks good is this reviewed and ready to go it is conflicting against master so can you please rebase this is also conflicting against i would like to rebase it after is merged to master waiting until is already merged rxjava pull requests successthis pull request looks good should this wait until were ready to do i think this one can be merged since has already broken the api headinthebox samuelgruetter do you mind it go for it
1185,1,0,0,1,0,0,1,0,behavior subject time gap fix based on discussions in ive unified the behavior among the subjectsbehaviorsubject doesnt seem to exhibit issue and a second pair of eyes would be great to confirm the correctness and check if the removal of the countdownlatch was the correct approach wow this is quite the change i need fresher eyes on this one so will come back to it thank you very much for tackling this this is non trivial code so i may have missed something but this looks like excellent forward progress on what we had to add the functionality needed for behaviorsubject and sharing the logic across all of the subject implsvery nice work
1185,1,0,1,1,1,1,1,1,behavior subject time gap fix based on discussions in ive unified the behavior among the subjectsbehaviorsubject doesnt seem to exhibit issue and a second pair of eyes would be great to confirm the correctness and check if the removal of the countdownlatch was the correct approach wow this is quite the change i need fresher eyes on this one so will come back to it thank you very much for tackling this this is non trivial code so i may have missed something but this looks like excellent forward progress on what we had to add the functionality needed for behaviorsubject and sharing the logic across all of the subject implsvery nice work
1185,1,0,0,1,0,0,1,0,behavior subject time gap fix based on discussions in ive unified the behavior among the subjectsbehaviorsubject doesnt seem to exhibit issue and a second pair of eyes would be great to confirm the correctness and check if the removal of the countdownlatch was the correct approach wow this is quite the change i need fresher eyes on this one so will come back to it thank you very much for tackling this this is non trivial code so i may have missed something but this looks like excellent forward progress on what we had to add the functionality needed for behaviorsubject and sharing the logic across all of the subject implsvery nice work
1185,1,0,1,0,0,0,1,0,behavior subject time gap fix based on discussions in ive unified the behavior among the subjectsbehaviorsubject doesnt seem to exhibit issue and a second pair of eyes would be great to confirm the correctness and check if the removal of the countdownlatch was the correct approach wow this is quite the change i need fresher eyes on this one so will come back to it thank you very much for tackling this this is non trivial code so i may have missed something but this looks like excellent forward progress on what we had to add the functionality needed for behaviorsubject and sharing the logic across all of the subject implsvery nice work
1185,1,0,0,1,0,0,1,0,behavior subject time gap fix based on discussions in ive unified the behavior among the subjectsbehaviorsubject doesnt seem to exhibit issue and a second pair of eyes would be great to confirm the correctness and check if the removal of the countdownlatch was the correct approach wow this is quite the change i need fresher eyes on this one so will come back to it thank you very much for tackling this this is non trivial code so i may have missed something but this looks like excellent forward progress on what we had to add the functionality needed for behaviorsubject and sharing the logic across all of the subject implsvery nice work
1185,1,1,0,0,0,0,1,0,behavior subject time gap fix based on discussions in ive unified the behavior among the subjectsbehaviorsubject doesnt seem to exhibit issue and a second pair of eyes would be great to confirm the correctness and check if the removal of the countdownlatch was the correct approach wow this is quite the change i need fresher eyes on this one so will come back to it thank you very much for tackling this this is non trivial code so i may have missed something but this looks like excellent forward progress on what we had to add the functionality needed for behaviorsubject and sharing the logic across all of the subject implsvery nice work
1195,1,0,0,0,0,0,1,0,swingscheduler allow negative schedule fix for issue the new scheduleperiodic may calculate negative delay times if the next task was already due this change will allow negative timing on the swing scheduler indicating an immediate schedule i suggest adding some comments in the schedulerschedule and schedulescheduleperiodically about negative timing eg negative delay time should be regarded as it would be helpful for anyone who wants to implement special scheduler ive added extra comments
1195,1,0,1,0,1,1,1,1,swingscheduler allow negative schedule fix for issue the new scheduleperiodic may calculate negative delay times if the next task was already due this change will allow negative timing on the swing scheduler indicating an immediate schedule i suggest adding some comments in the schedulerschedule and schedulescheduleperiodically about negative timing eg negative delay time should be regarded as it would be helpful for anyone who wants to implement special scheduler ive added extra comments
1236,1,0,0,0,0,0,1,0,compositesubscription with atomic field updater this pr is aimed at to reduce unnecessary memory overhead in frequently used classes this change in compositesubscription saves about bytes per instancein addition the field updaters may be faster by about for small adds and removals ive changed the implementation of unsubscribe to use getandset which leverages platform intrinsics and is usually compiled to a single instruction this makes unsubscribing a tiny bit faster and thus reducing latency in benchmarks that only pass on single element around
1236,1,0,0,0,1,1,1,1,compositesubscription with atomic field updater this pr is aimed at to reduce unnecessary memory overhead in frequently used classes this change in compositesubscription saves about bytes per instancein addition the field updaters may be faster by about for small adds and removals ive changed the implementation of unsubscribe to use getandset which leverages platform intrinsics and is usually compiled to a single instruction this makes unsubscribing a tiny bit faster and thus reducing latency in benchmarks that only pass on single element around
1237,0,0,0,0,0,0,1,0,safesubscriber memory reduction for this saves bytes per instance thanks i think we probably should do this all over i havent merged my change to compositesubscription yet so that needs to be done as well oh you already have a pr for compositesubscription as well akarnokd benjchristensen why was there a change from boolean to int there is no atomicbooleanfieldupdater and the nearest thing is an atomicintegerfieldupdater since classes are padded to byte boundaries anyway moving from byte boolean to byte integer is no extra overhead oh i just checked you are right that explains a lot but i have no clue why they didnt add that
1237,1,0,0,0,0,0,1,0,safesubscriber memory reduction for this saves bytes per instance thanks i think we probably should do this all over i havent merged my change to compositesubscription yet so that needs to be done as well oh you already have a pr for compositesubscription as well akarnokd benjchristensen why was there a change from boolean to int there is no atomicbooleanfieldupdater and the nearest thing is an atomicintegerfieldupdater since classes are padded to byte boundaries anyway moving from byte boolean to byte integer is no extra overhead oh i just checked you are right that explains a lot but i have no clue why they didnt add that
1269,1,0,0,0,0,0,1,0,fix the bug that int overflow can bypass the range check fix the bug mentioned in
1269,1,0,0,0,0,0,1,0,fix the bug that int overflow can bypass the range check fix the bug mentioned in
1271,1,0,0,0,0,0,1,0,operator retry with predicate operator retry with predicate overload for issue the func version is simply named retry the func version is named retryif due to lack of ideas and because to avoid overload resolution issues i also had to open up the operatorretrytest classes a bit thanks for implementing this should we just keep one of those two instead of both so we dont have to deal with the naming overload issue i dont know which one to keep probably the one that includes attempts this is the advanced use case for retry so it should probably provide both attempts and error it just feels awkward to need to come up with a new name just so we can have one with attempts and one without headinthebox do you have an opinion on this agree with benjchristensen if you are using this one you should know what you are doing thanks akarnokd and headinthebox for the review
1271,1,1,0,0,0,0,1,0,operator retry with predicate operator retry with predicate overload for issue the func version is simply named retry the func version is named retryif due to lack of ideas and because to avoid overload resolution issues i also had to open up the operatorretrytest classes a bit thanks for implementing this should we just keep one of those two instead of both so we dont have to deal with the naming overload issue i dont know which one to keep probably the one that includes attempts this is the advanced use case for retry so it should probably provide both attempts and error it just feels awkward to need to come up with a new name just so we can have one with attempts and one without headinthebox do you have an opinion on this agree with benjchristensen if you are using this one you should know what you are doing thanks akarnokd and headinthebox for the review
1272,1,0,0,1,0,1,1,0,executorscheduler to wrap an executor for issue and this implementation should conform with the scheduler contract except it is not possible to avoid thread hopping dont worry the tasks execute serially but maybe not on the same physical thread few open improvement possibilities usage of mpsclinkedqueue once available a better performing subscription container for this kind of queue drain task tracking instead of compositesubscription ability to remove a subscription from a compositesubscription without it calling unsubscribe on the removed subscription á la multipleassignmentsubscriptionset thanks akarnokd for this looks good for a first cut the trade offs thread hopping are expected and why we wont use this as a default for anything and agreed on possible improvements but those can come later
1272,1,0,0,1,1,1,1,1,executorscheduler to wrap an executor for issue and this implementation should conform with the scheduler contract except it is not possible to avoid thread hopping dont worry the tasks execute serially but maybe not on the same physical thread few open improvement possibilities usage of mpsclinkedqueue once available a better performing subscription container for this kind of queue drain task tracking instead of compositesubscription ability to remove a subscription from a compositesubscription without it calling unsubscribe on the removed subscription á la multipleassignmentsubscriptionset thanks akarnokd for this looks good for a first cut the trade offs thread hopping are expected and why we wont use this as a default for anything and agreed on possible improvements but those can come later
1272,1,0,0,1,0,1,1,0,executorscheduler to wrap an executor for issue and this implementation should conform with the scheduler contract except it is not possible to avoid thread hopping dont worry the tasks execute serially but maybe not on the same physical thread few open improvement possibilities usage of mpsclinkedqueue once available a better performing subscription container for this kind of queue drain task tracking instead of compositesubscription ability to remove a subscription from a compositesubscription without it calling unsubscribe on the removed subscription á la multipleassignmentsubscriptionset thanks akarnokd for this looks good for a first cut the trade offs thread hopping are expected and why we wont use this as a default for anything and agreed on possible improvements but those can come later
1272,1,0,1,0,0,0,1,0,executorscheduler to wrap an executor for issue and this implementation should conform with the scheduler contract except it is not possible to avoid thread hopping dont worry the tasks execute serially but maybe not on the same physical thread few open improvement possibilities usage of mpsclinkedqueue once available a better performing subscription container for this kind of queue drain task tracking instead of compositesubscription ability to remove a subscription from a compositesubscription without it calling unsubscribe on the removed subscription á la multipleassignmentsubscriptionset thanks akarnokd for this looks good for a first cut the trade offs thread hopping are expected and why we wont use this as a default for anything and agreed on possible improvements but those can come later
1286,1,0,0,0,0,0,1,0,rename some operator classes to onsubscribe as per see discussion in issue numerous classes in the rxoperator package are not implementations of operator but are actually implementations of onsubscribe the classes have been renamed in this pull requestexcuse me not squashing commits looked complicated after doing a pull from upstream in the middle
1286,1,0,0,0,0,1,1,1,rename some operator classes to onsubscribe as per see discussion in issue numerous classes in the rxoperator package are not implementations of operator but are actually implementations of onsubscribe the classes have been renamed in this pull requestexcuse me not squashing commits looked complicated after doing a pull from upstream in the middle
1287,1,0,0,0,0,0,1,0,replaysubject remove replaystate chm and related subjectobserver changes for issue this change should help avoid chm garbage although boxed integers will still fly around in addition i moved the notificationlite around to make room for the index ive also removed the callback onadd in publishsubject because it was unnecessary awesome ill try this against the tests i was doing this looks like it does improve performance and object allocation when using my hystrix tests i get this new run ops sec run ops sec run ops sec run ops sec run ops sec old run ops sec run ops sec run ops sec run ops sec run ops sec new run ops sec run ops sec run ops sec run ops sec run ops sec old run ops sec run ops sec run ops sec run ops sec run ops sec old old i need to go give hystrix some love too as there are some obvious things to go solve therethanks akarnokd for getting to this so quickly
1287,1,1,0,0,0,0,1,0,replaysubject remove replaystate chm and related subjectobserver changes for issue this change should help avoid chm garbage although boxed integers will still fly around in addition i moved the notificationlite around to make room for the index ive also removed the callback onadd in publishsubject because it was unnecessary awesome ill try this against the tests i was doing this looks like it does improve performance and object allocation when using my hystrix tests i get this new run ops sec run ops sec run ops sec run ops sec run ops sec old run ops sec run ops sec run ops sec run ops sec run ops sec new run ops sec run ops sec run ops sec run ops sec run ops sec old run ops sec run ops sec run ops sec run ops sec run ops sec old old i need to go give hystrix some love too as there are some obvious things to go solve therethanks akarnokd for getting to this so quickly
1347,1,0,0,0,0,1,1,1,allow use of the returned subscription to cancel periodic scheduling the documentation for scheduleperiodically indicates that the returnedsubscription can be used to unsubscribe from the periodic action or tounschedule it if it has not been scheduled yet that was the case onlybefore the first action took place and it was then impossible tounsubscribe using the given subscription although unsubscribing theworker did workthis this new version contains a fix by akarnokd thank you
1347,1,0,1,1,1,1,1,1,allow use of the returned subscription to cancel periodic scheduling the documentation for scheduleperiodically indicates that the returnedsubscription can be used to unsubscribe from the periodic action or tounschedule it if it has not been scheduled yet that was the case onlybefore the first action took place and it was then impossible tounsubscribe using the given subscription although unsubscribing theworker did workthis this new version contains a fix by akarnokd thank you
1367,0,0,0,0,0,0,1,0,fix the bug that flatmap swallows onerrornotimplementedexception not sure if any other place will swallow onerrornotimplementedexception or the fatal errors hi allim new here so i may be missing something but im afraid that this issue should not be closed just yetindeed it looks like there is still a problem if there is more than one flatmap in the chainhere is a unit test to reproduce the bug i used the previous unit test that was added as part of this bugfix and simply added an additional flatmap stage test expected onerrornotimplementedexceptionclass public void testsubscribewithoutonerror { observablejust a b flatmap s observablejust s s flatmap s observableerror new exception test foreach systemout println } the output i get is nothing and no error eithershould i submit a new issue or can you reopen this one think the issue still exists there needs to be clear functionality by which exception can be cleanly trapped and rethrown if needed user preference to upper layers
1367,1,0,1,0,0,0,1,0,fix the bug that flatmap swallows onerrornotimplementedexception not sure if any other place will swallow onerrornotimplementedexception or the fatal errors hi allim new here so i may be missing something but im afraid that this issue should not be closed just yetindeed it looks like there is still a problem if there is more than one flatmap in the chainhere is a unit test to reproduce the bug i used the previous unit test that was added as part of this bugfix and simply added an additional flatmap stage test expected onerrornotimplementedexceptionclass public void testsubscribewithoutonerror { observablejust a b flatmap s observablejust s s flatmap s observableerror new exception test foreach systemout println } the output i get is nothing and no error eithershould i submit a new issue or can you reopen this one think the issue still exists there needs to be clear functionality by which exception can be cleanly trapped and rethrown if needed user preference to upper layers
1393,1,0,0,0,0,0,1,0,add cache int capacity to observable proposed patch for
1393,1,0,1,0,1,1,1,1,add cache int capacity to observable proposed patch for
1422,1,0,1,0,0,0,1,0,concurrency fixes for rxringbuffer & merge possible fix for i was unable to exactly reproduce the issue but was able to create a possibly related one this fixes itit also simplifies the logic and code somewhat at a possible small performance cost for these rooperatormergeperfmerge syncstreamofn thrpt ops srooperatormergeperfmerge syncstreamofn thrpt ops srooperatormergeperfmergensyncstreamsofn thrpt ops s
1422,1,0,1,0,0,0,1,0,concurrency fixes for rxringbuffer & merge possible fix for i was unable to exactly reproduce the issue but was able to create a possibly related one this fixes itit also simplifies the logic and code somewhat at a possible small performance cost for these rooperatormergeperfmerge syncstreamofn thrpt ops srooperatormergeperfmerge syncstreamofn thrpt ops srooperatormergeperfmergensyncstreamsofn thrpt ops s
1431,1,0,0,0,0,1,1,0,compositeexception fix for android revert changes from f ae aa remove duplicated causes in stack trace chain this will take a while to review as those changes were done for good reason maybe i should provide some explanation about what was wrong with the previous implementationheres how most of java programmers will rethrow an exception if not handled observablecreate subscriber subscriber subscriberonerror new runtimeexception ex observeon androidschedulersmainthread subscribeon schedulersio subscribe object { } error { handle some exceptions rethrow unhandled throw new runtimeexception ex error } now we have compositeexception with two nested exceptions ex ex which cause is ex the previous implementation will create a loop in this situation onerrorfailedexception compositeexception ex ex ex ex ive provided test for this scenario and additional method to remove throwables which are causes of another throwable it means ex will not be attached as a cause of the compositeexception because it is a cause of ex so it will be automatically attached with ex and printed in the stack trace output onerrorfailedexception compositeexception ex ex cc mattrjacobs matt can you get involved here now that youre back since you have the most recent history and context in this code discussion at given the new constraint that android does something unexpected to me anyway with the set of printstacktrace methods its probably preferable to modify the structure of compositeexception so that any arbitrary output of a compositeexception is correct relying on the implementation details of precisely how android does the printstacktrace doesnt protect us from any other edge cases so i generally think the sort of change proposed by tomrozb is good im validating what the output looks like in our prod env now thanks tomrozb for the pr im merging this now thanks for the clear explanation and fix with a test tomrozb thanks mattrjacobs and tomrozb
1431,1,0,1,0,0,1,1,0,compositeexception fix for android revert changes from f ae aa remove duplicated causes in stack trace chain this will take a while to review as those changes were done for good reason maybe i should provide some explanation about what was wrong with the previous implementationheres how most of java programmers will rethrow an exception if not handled observablecreate subscriber subscriber subscriberonerror new runtimeexception ex observeon androidschedulersmainthread subscribeon schedulersio subscribe object { } error { handle some exceptions rethrow unhandled throw new runtimeexception ex error } now we have compositeexception with two nested exceptions ex ex which cause is ex the previous implementation will create a loop in this situation onerrorfailedexception compositeexception ex ex ex ex ive provided test for this scenario and additional method to remove throwables which are causes of another throwable it means ex will not be attached as a cause of the compositeexception because it is a cause of ex so it will be automatically attached with ex and printed in the stack trace output onerrorfailedexception compositeexception ex ex cc mattrjacobs matt can you get involved here now that youre back since you have the most recent history and context in this code discussion at given the new constraint that android does something unexpected to me anyway with the set of printstacktrace methods its probably preferable to modify the structure of compositeexception so that any arbitrary output of a compositeexception is correct relying on the implementation details of precisely how android does the printstacktrace doesnt protect us from any other edge cases so i generally think the sort of change proposed by tomrozb is good im validating what the output looks like in our prod env now thanks tomrozb for the pr im merging this now thanks for the clear explanation and fix with a test tomrozb thanks mattrjacobs and tomrozb
1559,1,0,0,1,0,0,1,0,more consistent hooks for scheduler plugins this is a rework of deprecated rxjavadefaultschedulers and rxjavadefaultschedulersdefault i think these names are confusing added rxjavaschedulershook ability to override entire schedulers from scratch ability to decorate action before submission to schedulerthe main change from is the decoration of action instead of runnable action is an improvement as all schedulers must handle these whereas not all schedulers handle runnables reviewed with benjchristensen and merging
1559,1,1,0,0,0,0,1,0,more consistent hooks for scheduler plugins this is a rework of deprecated rxjavadefaultschedulers and rxjavadefaultschedulersdefault i think these names are confusing added rxjavaschedulershook ability to override entire schedulers from scratch ability to decorate action before submission to schedulerthe main change from is the decoration of action instead of runnable action is an improvement as all schedulers must handle these whereas not all schedulers handle runnables reviewed with benjchristensen and merging
1602,1,0,0,0,0,0,1,0,make retrywhen the same with the scheduler as the retrywhen without the scheduler came up in
1602,1,0,0,1,1,1,1,1,make retrywhen the same with the scheduler as the retrywhen without the scheduler came up in
1705,0,0,0,0,0,1,1,0,issue fix null emitting combinelatest benjchristensen thanks for fixing this stupid bug on my partit should have been javabuffergetvalue o orbufferaccept o child your fix does the same thing benjchristensen just saw that this didnt make it into do i need to do something to make sure it gets into cant tell how you guys are managing the various release branches this was merged into x and is in the releases it was in rc you want it also in the x releases go ahead and submit another pr against that branch x is where most of the focus is as we work towards the final release scheduled for november th ah i tried switching us over to rc but one of our dependencies uses the comnetflix packaging and android wont let us include both in our apk dex complains about duplicate classes one of our dependencies uses the comnetflix packagingyes its going to be a painful one time migration to get onto once we hit final ill encourage everyone to do so
1705,1,0,0,0,0,1,1,1,issue fix null emitting combinelatest benjchristensen thanks for fixing this stupid bug on my partit should have been javabuffergetvalue o orbufferaccept o child your fix does the same thing benjchristensen just saw that this didnt make it into do i need to do something to make sure it gets into cant tell how you guys are managing the various release branches this was merged into x and is in the releases it was in rc you want it also in the x releases go ahead and submit another pr against that branch x is where most of the focus is as we work towards the final release scheduled for november th ah i tried switching us over to rc but one of our dependencies uses the comnetflix packaging and android wont let us include both in our apk dex complains about duplicate classes one of our dependencies uses the comnetflix packagingyes its going to be a painful one time migration to get onto once we hit final ill encourage everyone to do so
1742,1,0,0,0,0,1,1,1,emptyobserver and testobserver remove emptyobserver as it was confusing compared to observersempty make testobserver not throw onerrornotimplemented if a delegate is not provided fixes
1742,1,0,0,1,1,1,1,1,emptyobserver and testobserver remove emptyobserver as it was confusing compared to observersempty make testobserver not throw onerrornotimplemented if a delegate is not provided fixes
1742,1,0,0,0,0,1,1,1,emptyobserver and testobserver remove emptyobserver as it was confusing compared to observersempty make testobserver not throw onerrornotimplemented if a delegate is not provided fixes
1761,0,0,0,0,0,1,1,0,issue fix null emitting combinelatest same as but for the \ folks
1767,1,0,0,1,0,1,1,0,executorscheduler delivers uncaught exceptions instead of swallowing unhandled errors executorscheduler delivers themto the executing threads uncaughtexceptionhandlerthis addresses the same issue as reactivex rxjava but forexecutorscheduler which does not used scheduledaction
1777,1,0,0,1,0,1,1,0,excluding things from the javadoc for one of the sub issues in exclude rxinternalexclude rxjavaerrorhandlerdefault by deleting it
1784,1,0,0,0,0,0,1,0,publish with backpressure implementation of publish with backpressure moves away from using the multicast operator and publishsubject as per discussion in and
1802,1,0,0,1,0,1,1,1,add hasobservers method to subjects as per now keeps track of the actual subjectbufferuntilsubscriber synchronizes on the state guard looks good thanks simonbasle
1866,1,0,0,1,0,0,1,0,fix memory leak in bounded replaysubject due to retaining the node index indefinitely once the subscriber caught upfor issue this test failed both times rxinternaloperatorsoperatormergedelayerrortest testerrorinparentobservabledelayed failed orgmockitoexceptionsverificationtoolittleactualinvocations stringobserveronnext hello wanted times at rxinternaloperatorsoperatormergedelayerrortesttesterrorinparentobservabledelayed operatormergedelayerrortestjava but was time at rxobserverstestobserveronnext testobserverjava at rxinternaloperatorsoperatormergedelayerrortesttesterrorinparentobservabledelayed operatormergedelayerrortestjava no idea why or if its related but id like to understand before merging this i dont think mergedelayerror uses replaysubject i dont fully understand the operatormerge but it contains a lot of mutable variables and synchronized blocks and im not sure but i found some anomalies in synchronizes on the mergeproducers this but reads the mergesubscribers wip field which generally is accessed through the mergesubscribers this same seems to be true for the scalarvaluequeue ive tested things locally and its working for me i opened an issue to track the issue you brought up regarding merge
1884,1,0,0,0,0,0,1,0,fix scan reduce collect factory ambiguity this puts the seed factory on collect and removes it from scan and reduce due to ambiguitysee and collect api was already very close so this fixes it to use a seed factory so the signature is now javapublic final observable collect func statefactory final action collector { i remove the factory overloads for scan and reduce due to the issue in related to generics type erasure and lambdas causing ambiguity and compilation failureswe may want to add at least a scan impl in the future with a seed factory but it will need a different name if we do such as scanto i dont want to do that now for so well need to revisit that for with more time to think about it this code is now possible java observablerange collect new arraylist list i { listadd i } foreach systemout println this will no longer compile java observablerange scan new arraylist list i { listadd i return list } foreach systemout println
1922,1,0,0,0,0,0,1,0,set removeoncancelpolicy on the threadpool if supported this should solve the task retention problem of unused timeout tasks mentioned in i know java scheduledthreadpoolexecutor has the setremoveoncancelpolicy and i remember seeing it in android although i cant tell from which api versionin java this cant be solved without rewriting the entire scheduler or using a backported executor akarnokd cool thanks for whipping this up so quickly since rxjava supports java we need to fix that too right i looked at the packages of jsr _ but couldnt find one that ports this flag back to java benjchristensen are there plans to fix this for java too since we technically support it or do we mark it as a limitation and people that are hit by this need to go to java im asking because we have lots of users on java and some of the requests have s timeouts im open to a fix that works for java if someone can suggest what to do and or submit a pr i personally dont have the time to tackle this anytime soon but would accept the change if it solves the problem without breaking anything else including performance for java benjchristensen okay thanks for the info ill tackle it if customers start to complain for now i also think its not as high priority since technically jdk is eol anyway yes the strongest reason actually that rxjava supports java rather than as the minimum is for android support if it becomes an issue for your customers and you want to tackle this ill happily review discuss and merge youd need to backport the java scheduledthreadpoolexecutor and a bunch of helper classes i looked for a backport on doug leas site but no luck how about calling scheduledthreadpoolexecutorremove runnable task in unsubscribe for java although its a o n action while its o log n in java its better than oom that doesnt work on submit tasks because they are wrapped maybe a better option is to have purge be called periodically that doesnt work on submit tasks because they are wrappedthe returned scheduledfuture is exactly the object in the workqueue
1973,1,0,0,0,0,1,1,0,test issuing non serialized messages to the subject should resolve the test failure of when the main part of the test succeded an oncompleted was sent out from the main thread which was not serialized in respect to the onnext issued from the worker thread therefore two replay was attempted sometimes at first the caughtup was seen false the replay was entered but the next instruction cleared the index causing the illegalstateexception failed in testreplaysubjectemissionsubscriptionrace failed javalangnullpointerexception at rxsubjectsreplaysubject$boundedstatereplayobserverfromindex replaysubjectjava at rxsubjectsreplaysubject$boundedstatereplayobserver replaysubjectjava at rxsubjectsreplaysubjectcaughtup replaysubjectjava at rxsubjectsreplaysubjectoncompleted replaysubjectjava at rxsubjectsreplaysubjectboundedconcurrencytesttestreplaysubjectemissionsubscriptionrace replaysubjectboundedconcurrencytestjava thanks forgot about the other test class
2465,1,0,0,0,0,1,1,0,scheduledexecutorservice call purge periodically on jdk to avoid cancelled task retentionfirst debated in see also we may want to discuss the naming of system parameters i chose these so rxjava specific properties may be trivially separated ioreactivexrxjavaschedulerjdk purge frequency millis specifies the purge frequency in milliseconds default is ioreactivexrxjavaschedulerjdk purge force forces the use of the purge if set to true even if the setremoveoncancelpolicy is supported the benefit is that removing cancelled tasks now runs on a different thread so the main pool thread doesnt waste time on them the drawback is the retention window can be still to largedo we have a wiki page where such parameters are listed i did run the unit test by forcing a jdk runtime and seems to work merging to allow progress on schedulers
2470,1,0,0,1,0,0,1,0,subject state information methods & bounded replaysubject termination fixthis pr aims to support the requests in and by adding methods to the final subject classes that let developers access in flight state in a snapshot fashion this may be considered safe api change because all subject classes were final already so adding extra methods wont break anyones code and we will be careful with our observable in the future notificationlite is now extended with two missing value checks isnull and isnext each subject has hascompleted hasthrowable and getthrowable methods however i cant add them to subject because that would be an incompatible api change where applicable getvalue and getthrowable return null instead of throwing exceptions so users are encouraged to call hasxxx methods beforehand there was a chaining bug in the bounded replaysubject because the terminal value was added after a potential pruning the node links could get broken and concurrent replays might not have seen the terminal value since replaysubject can have multiple values ive added size hasanyvalue isempty is taken and getvalues methods to make a snapshot of the current buffer contents whether or not the replaysubject has terminated the usual tolist would wait until the subject has terminated the unrelated operatormergetesttestconcurrency hangs for me for some reason without activity either a buffer bug or a merge bug is in play there ive added a timeout so it doesnt stop the other tests im merging this changes are either internal or annotated with experimental on final classes
2470,1,0,0,1,0,0,1,0,subject state information methods & bounded replaysubject termination fixthis pr aims to support the requests in and by adding methods to the final subject classes that let developers access in flight state in a snapshot fashion this may be considered safe api change because all subject classes were final already so adding extra methods wont break anyones code and we will be careful with our observable in the future notificationlite is now extended with two missing value checks isnull and isnext each subject has hascompleted hasthrowable and getthrowable methods however i cant add them to subject because that would be an incompatible api change where applicable getvalue and getthrowable return null instead of throwing exceptions so users are encouraged to call hasxxx methods beforehand there was a chaining bug in the bounded replaysubject because the terminal value was added after a potential pruning the node links could get broken and concurrent replays might not have seen the terminal value since replaysubject can have multiple values ive added size hasanyvalue isempty is taken and getvalues methods to make a snapshot of the current buffer contents whether or not the replaysubject has terminated the usual tolist would wait until the subject has terminated the unrelated operatormergetesttestconcurrency hangs for me for some reason without activity either a buffer bug or a merge bug is in play there ive added a timeout so it doesnt stop the other tests im merging this changes are either internal or annotated with experimental on final classes
2471,1,0,0,0,0,0,1,0,fixes npes reported in reactivex by synchronizing queue also adds a unit test for regressionit appears there is a potential race condition if something adds to removes from the pq while its _inside_ the poll operation which is where the exceptions in seem to have actually come from therefore the initial null check didnt really address the original problem the test here seems to reliably recreate those conditionsi considered using a priorityblockingqueue instead of synchronized but since the isempty and poll calls should not allow something to interleave between them and access the queue a synchronized block seemed wiser here almost good two things since we only use offer poll you can use the unbounded priorityblockingqueue now could you move counter and counter_updater into the innercurrentthreadscheduler class both non static fields we are using atomicfieldupdaters to save on the instance cost of atomicinteger s could you change the counter to use atomiclongfieldupdater done on a related but side note do you know if these field updaters are proguard safe for obfuscation they reflect on field name for sure it might be worth looking into the fix would probably be implementing the abstract setters and getters which would obviously be a bit more boilerplate and kinda less fun but might be worth it if it reduces custom proguard rules required to use rx thanks for the changes looks good to me i dont know about proguard looks like per the proguard manual it does indeed recognize fieldupdater declarations so this should be fine wow i did not expect that how uncharacteristically useful of them good to know for the future the reflection section no anchor link that lists the basic reflection methods it automatically detects
2493,1,0,0,0,0,0,1,0,operator takeuntil with predicate take values and check the condition after the value is emittedfor enhancement request thanks for adding this not convinced on the name though the do prefix is used to represent side effects everywhere else i think the prefix should still be take something the question then remains should it stop if predicate turns into false or should it stop if predicate turns into true because classically do { } while true and repeat until false pascal i like it how its currently implemented do until trueit fits the takeuntil term take until a value predicate java systemoutprintln observablejust dooneach systemout println takeuntil i i foreach systemout println systemoutprintln observablejust dooneach systemout println takewhile i i foreach systemout println that code shows the difference with takewhile and it works well we emit and then stop rxnotification cd onnext rxnotification cd a onnext rxnotification cd b onnext rxnotification cd onnext rxnotification cd a onnext rxnotification cd b onnext rxnotification cd c onnext
2548,1,0,1,0,0,1,1,1,subscriberrequest should throw exception if negative request made as per discussion in and making a call to subscriberrequest n with negative n should throw an illegalargumentexception includes unit test i think the iae should be mentioned in requests javadoc javadoc added great
2548,1,0,1,0,0,1,1,1,subscriberrequest should throw exception if negative request made as per discussion in and making a call to subscriberrequest n with negative n should throw an illegalargumentexception includes unit test i think the iae should be mentioned in requests javadoc javadoc added great
2550,1,0,1,0,0,1,1,1,subscriberonstart requests should be additive and check for overflow as per discussion in looks good that looks helpful thanks davidmoten
2553,1,0,0,0,0,0,1,0,rxringbuffer with synchronization changed rxringbuffer to use synchronized blocks for correctness we are relying here upon biased locking and lock elision it gets pretty close to the baselinebenchmark benchmark size x pr this syncstreamofn syncstreamofn syncstreamofn nasyncstreamsofn nasyncstreamsofn nsyncstreamsof nsyncstreamsof nsyncstreamsof nsyncstreamsofn nsyncstreamsofn twoasyncstreamsofn twoasyncstreamsofn reamofnthatmergesin reamofnthatmergesin reamofnthatmergesin changes in respect of x using spscarrayqueue removed look ahead and null check using peek to check for emptyness in certain positions using short as possible synchronization blocks here is my perf comparison building on what i did at x branch as of jan ndpr pr after rebasing onto x jan nd pr pr after rebasing onto x jan nd pr pr on x as of jan benchmark size mode samples x pr pr pr rooperatormergeperfmerge syncstreamofn thrpt rooperatormergeperfmerge syncstreamofn thrpt rooperatormergeperfmerge syncstreamofn thrpt rooperatormergeperfmergenasyncstreamsofn thrpt rooperatormergeperfmergenasyncstreamsofn thrpt rooperatormergeperfmergensyncstreamsof thrpt rooperatormergeperfmergensyncstreamsof thrpt rooperatormergeperfmergensyncstreamsof thrpt rooperatormergeperfmergensyncstreamsofn thrpt rooperatormergeperfmergensyncstreamsofn thrpt rooperatormergeperfmergetwoasyncstreamsofn thrpt rooperatormergeperfmergetwoasyncstreamsofn thrpt rooperatormergeperfonestreamofnthatmergesin thrpt rooperatormergeperfonestreamofnthatmergesin thrpt rooperatormergeperfonestreamofnthatmergesin thrpt the degradations of this are incremental and i think worth the correctnesscrazy to me that we cant find a non blocking approach that performs better than the jvm doing lock elisioni suggest we move forward with this after cleaning up the comments in the code that are no longer valid i suggest we move forward with this after cleaning up the comments in the code that are no longer validokay if you feel ready you can merge it at your will ill take care of
2585,1,0,0,0,0,0,1,0,operator switchifempty changes to thanks akarnokd for fixing up and merging
2622,1,0,0,0,0,0,1,0,changed observableempty into a stateless constant observable empty was always stateless so creating a new instance all the time especially through a from iterable is wasteful besides oncompleted events dont have to be backpressuredshould enable identity based optimizations discussed in
2627,1,0,0,0,0,0,1,0,flatmap overloads with maximum concurrency parameter for issue there is no point in adding maxconcurrent to flatmapiterable because each iterable is subscribed to sequentially and run to completion there is no point in adding maxconcurrent to flatmapiterable because each iterable is subscribed to sequentially and run to completioni was wrong with this statement depending on the request pattern reordering may still happen and the downstream may be still slower unboundedness of flatmapiterable may still cause excessive source iterable generation that fills in the tracking arrays inside flatmap having the maxconcurrency parameter is valuable and prevents buffer bloat
2630,1,0,0,0,0,0,1,0,cast back observer to subscriber if passed to subscribe observer rebased
2648,1,0,1,0,0,0,1,0,takewhile dont unsubscribe downstream issue with takewhile
2759,1,0,0,0,0,0,1,0,observableusing should use unsafesubscribe and enable eager disposal see where it was discovered that observableusing used subscribe instead of unsafesubscribe which provoked a race condition leading to an illegalargumentexception from the merge operatorthis pr uses unsafesubscribe and adds an overload for using to optionally dispose of resources eagerly just before completion or error the use case for this is a _synchronous_ observable where a downstream operation wants to reuse a resource but because the observable is synchronous the resource cannot get disposed till the downstream completes unit tests included thanks akarnokd ive made the change and squashed commits replaced tabs with spaces added experimental annotation to new overload and typo in javadoc squashed commits this seems reasonable to me i dont use using so trust the conversation youve had to address the necessary functionality reading through the other pr this does seem necessary and i agree that unsafesubscribe is appropriate for this
2762,1,0,0,0,0,0,1,0,optimized isunsubscribed check extracted isunsubscribed optimization from benchmark size mode samples x rscomputationschedulerperfobserveon thrpt rscomputationschedulerperfobserveon thrpt rscomputationschedulerperfobserveon thrpt rscomputationschedulerperfobserveon thrpt rscomputationschedulerperfobserveon thrpt rscomputationschedulerperfobserveon thrpt rscomputationschedulerperfobserveon thrpt rscomputationschedulerperfsubscribeon thrpt rscomputationschedulerperfsubscribeon thrpt rscomputationschedulerperfsubscribeon thrpt rscomputationschedulerperfsubscribeon thrpt rscomputationschedulerperfsubscribeon thrpt rscomputationschedulerperfsubscribeon thrpt rscomputationschedulerperfsubscribeon thrpt nice improvement
2767,1,0,0,0,0,0,1,0,optimized scalar observeon subscribeon redone run on i ghz windows x jdk u benchmark size this score error x score errorobserveon observeon observeon observeon observeon observeon observeon observeon observeon observeon subscribeon subscribeon subscribeon subscribeon subscribeon subscribeon subscribeon subscribeon subscribeon subscribeon note that since the tests create a lot of garbage some perf numbers have quite some error margin some appear to be faster with this pr while others appear to be slower even if they are not affected by the changes am i reading it correctly that this should really only benefit this case benchmark size this score error x score errorobserveon yes it optimizes for the scalar observing of a value i assume this is a common enough case to warrant an optimized code path this is exactly the case i need code looks good all internal changes thanks akarnokd
2804,1,0,0,0,0,0,1,0,observeon throughput enhancements squashed commits of further optimizations to observeon using spscarrayqueue directly in observeon instead of ringbuffer to avoid the synchronization block split tracking structure to serial subscriptionlist and timed compositesubscription in eventloopsscheduler which improves the sequential scheduling performance because a completing tasks subscription will be most likely the first item in the underlying linkedlistbenchmark i window x java u x s warmup x s iteration benchmark size x x error this pr this errorobserveon observeon observeon observeon observeon observeon observeon observeon observeon observeon subscribeon subscribeon subscribeon subscribeon subscribeon subscribeon subscribeon subscribeon subscribeon subscribeon notes at size the throughput varies in a range on each run and since the changes dont touch the scalar optimization there is no real improvement there at size my system reached either the cache capacity or the os schedulers time resolution so there no improvement there on at size and size the throughput doubles if i introduce some extra delay ie via sleep or some extra work the benchmark generates a lot of garbage due to boxing switching to a constant emitter increases the throughput subscribeon from to since it conflicts with anyway this is pr is to let others verify the optimizations actually work on other oses because on my windows i sometimes get significant variance in the throughput during iterations increased iteration time may be required as well
2804,1,0,0,0,0,0,1,0,observeon throughput enhancements squashed commits of further optimizations to observeon using spscarrayqueue directly in observeon instead of ringbuffer to avoid the synchronization block split tracking structure to serial subscriptionlist and timed compositesubscription in eventloopsscheduler which improves the sequential scheduling performance because a completing tasks subscription will be most likely the first item in the underlying linkedlistbenchmark i window x java u x s warmup x s iteration benchmark size x x error this pr this errorobserveon observeon observeon observeon observeon observeon observeon observeon observeon observeon subscribeon subscribeon subscribeon subscribeon subscribeon subscribeon subscribeon subscribeon subscribeon subscribeon notes at size the throughput varies in a range on each run and since the changes dont touch the scalar optimization there is no real improvement there at size my system reached either the cache capacity or the os schedulers time resolution so there no improvement there on at size and size the throughput doubles if i introduce some extra delay ie via sleep or some extra work the benchmark generates a lot of garbage due to boxing switching to a constant emitter increases the throughput subscribeon from to since it conflicts with anyway this is pr is to let others verify the optimizations actually work on other oses because on my windows i sometimes get significant variance in the throughput during iterations increased iteration time may be required as well
2883,1,0,0,1,0,1,1,0,proposal standardized subject state peeking methods this pr modifies the subject class to host the union of the state peeking methods of the various subject implementations and fixes the inconsistent behavior of replaysubjectgetvalues t the changes enable the serializedsubject to relay such state peeking method calls into the wrapped subject and allows future subject wrappers to do the same seems to make sense the additions to subject all should be non breaking due to the experimental marking of these im being a little less stringent in discussing the addition to public apis but it seems to me that the precedent set on the behaviorsubject shows the value of these methods additionally subjects are the stateful side effecting types and these methods seem to make sense for them
2969,1,0,0,0,0,0,1,0,operator cache now supports backpressure ive removed the controversial features and made the backing cachedobservable internalrelated issue does it really need to be returning a new type of observable it seems the methods isconnected hasobservers and cachedeventcount are only used by the unit tests yes otherwise one would need ugly reflection magic to get inside the state of this observable i checked out the branch and took a shot at making it an onsubscribe function again cache had originally more functionality ie the ability to terminate it manually like a disconnect but was downwoted i forgot about the tocached methods which are just relics and ill update this protherwise i dont really see why i shouldnt extend observable especially if one day there will be a real need to support disconnection of cache ive rebased it and im going to merge this if there has concern about it being implemented as a observable a pr can always be submitted with the suggested changes
2970,1,0,0,0,0,0,1,0,deprecated onbackpressureblock see for reasons to deprecate
2972,1,0,0,0,0,0,1,0,window time to work properly with unsubscription added backpressure support to window size skip see
2983,1,0,0,0,0,0,1,0,multiple calls to onstart started investigating multiple calls to onstart based on and found a bunch but since onstart can be overridden i might have missed cases in addition ive found a single place where a producer is set twice on a subscriber but again many other places may exist i know that is easy to complain this decorator strategy is not very memory friendly you have this annoying gwt compatibility perspective atomicxxxfieldupdater in a lot of places to reduce memory usage and you end up adding this decorators to only disable one method callwhat do you think thanks to solve the problem anyway yikes theres a lot of stuffed up backpressure here im hoping we can release soon
3048,1,0,0,0,0,1,1,0,compositeexception extra npe protection compositeexception wont crash if it received null by some means a null collection or null collection item is replaced by a nullpointerexception instancesee also
3049,1,0,0,0,0,0,1,0,single add tosingle method to observable closes reactivex rxjava this method allows an observable which is guaranteed to return exactly one item to be converted to a single note the semantics of this function are very similar to that of single ie errors are passed through more than one item results in an illegalargumentexception completion without emission results in a nosuchelementexception and exactly one item is passed through the onsuccess method of singlesubscriber would appreciate feedback since this is my first contribution to rxjava yes looks good can you add the license headers to the files please the block of code to add is shown here have done so would you mind rebasing to a single commit also done thank you tilal for the contribution and responsiveness on changes glad to contributeim planning to look into more tricky issues soon so hopefully this is not the last youll see of me
3081,1,0,0,0,0,0,1,0,revert of cache replay i did revert commit of the pr that added back pressure support to the cache operator and ran a canary our production systems seem stable now even with the new merge thats good news not sure what time akarnokd has for reviewing cache backpressure work if we cant fix this short term would be nice too see a fix for go in if backpressure doesnt make it quick summary is in cache emits nothing until source has completed can you create an unit test based on the usage pattern it would be also interesting to verify replay autoconnect since it ought to be functionally equivalent to cache i have no clue at the moment what the actual code path is causing the lockup itll take awhile for me to instrument code to narrow which usage pattern is causing the problem i believe the issue were seeing comes from use of cache in hystrix use hystrix at very high volume and cache will be used by a large percentage of those calls this explains why this impacted our canary so significantly ive reverted both the cache and revert related commits the tests and the canary seem to do fine so far
3118,1,0,1,0,0,0,1,0,implementing the synconsubscribe this is useful for creating an observable that reads from a data source in a synchronous manner this is a rewrite of the abstractonsubscribe experimental class based on the ideas in you cant delete abstractonsubscribe because it is part of the public api and even though marked as experimental such components can be deleted only at a major release such as experimental apis can be removed or change at any time as per the readme experimental apis marked with the experimental annotation at the class or method level will almost certainly change they can be modified in any way or even removed at any time you should not use or rely on them in any production code they are purely to allow broad testing and feedback i would have expected to make such apis deprecated for a few releases before completely removing it besides this pr just gives an alternative to another experimental class and could live side by side then users could decide vote which to keep at the next major release akarnokd you have a good point that the efficacy of both implementations should be compared however i do not think that we should expose multiple alternatives in the public api this ambiguous api leads to confusion and questions about the unexplained differences between one or the other implementation the pull request should not be the place for debate either since this should be about issues with this implementation this comparison and debate was what i was hoping to get out of opening issue would you like to open a separate issue for comparing the implementations the latest commit adds work stealing to manage unsubscribe to avoid concurrent modification of state while running onunsubscribe concurrently with next and a test to exercise fixes issues with tabs spaces and adds javadocs the latest commit makes a few changes added the abstractonsubscribe back into the code base the experimental annotation states clearly that either of these implementations can be removed at any time so its not necessary for anything to be removed now it is up to the consumer when they chose to use a potentially unstable api added jmh tests to compare performance against onsubscribefromiterable the performance is impacted in astounding ways by the additional complexity of a cleanup function this requires object initialization which the onsubscribefromiterable does not require general optimizations removing a volatile and reorganizing the request loop stealthcode can you give us more detail on the jmh comparison sure sorry for leaving that out heres the jmh report output $ gradlew clean benchmarks pjmh f tu s bm thrpt wi i r synconsubscribeperf benchmark size mode samples score score error unitsrosynconsubscribeperfbenchabstractonsubscribe thrpt ops srosynconsubscribeperfbenchabstractonsubscribe thrpt ops srosynconsubscribeperfbenchabstractonsubscribe thrpt ops srosynconsubscribeperfbenchabstractonsubscribe thrpt ops srosynconsubscribeperfbenchfromiterable thrpt ops srosynconsubscribeperfbenchfromiterable thrpt ops srosynconsubscribeperfbenchfromiterable thrpt ops srosynconsubscribeperfbenchfromiterable thrpt ops srosynconsubscribeperfbenchsynconsubscribe thrpt ops srosynconsubscribeperfbenchsynconsubscribe thrpt ops srosynconsubscribeperfbenchsynconsubscribe thrpt ops srosynconsubscribeperfbenchsynconsubscribe thrpt ops s under flight recorder analysis both the aos and sos suffer from the cost of creating a subscriptionlist and allocating memory where as a the onsubscribefromiterable does not require adding an unsubscribe action so doesnt need to allocate i plan on testing some changes to get around this bottle neck will submit a pull request soon hopefully this upcoming change will be a private change and not have to wait until x here are the updated benchmarks this paints a very different picture than last time the performance of the synconsubscribe is now observables in ways that obviate the need to merge at all are there use cases that i am missingthat said i would rather not corrupt the api with a one off concept of stop without good reason its important that we get the api correct even in experimental javadoc is now updated reviewed the code
3121,1,0,0,0,0,0,1,0,improve performance of newthreadworker disable search for setremoveoncancelpolicy on android api this pr adds methods for detecting android api version and disables newthreadworkertryenablecancelpolicy on android api which has significant performance cost on androidpr also improves performance of newthreadworkertryenablecancelpolicy via caching reflection checked on jvm java android api android api all comments removed test with reflection added more javadoc and comments tests are now compilable on jdk didnt check but they should work fine akarnokd jakewharton ptal great
3129,1,0,0,0,0,0,1,0,fix retry with predicate ignoring backpressure apparently we forgot about this operator the backpressure handling is a trivial case with producerarbiter ive also some apparent code indentation errororiginally reported in with a test case which i didnt include due to its lengthy nature however i did run the test manually and both passed after the fix
3147,1,0,0,0,0,0,1,0,remove unnecessary static modifier ps benjchristensen akarnokd sorry for large amount of simple pull requests im doing full code review of rxjava sources and ill create prs and issues during this reviewill try to group changes by themes so it will be easy to review them looks like this adventure is going to be part of if it were only me id accept cosmetic changes such as this but history tells me not to akarnokd why sad that javac is not strict enough and allows such things we can add checkstyle with only java lang rules and remove all these things from the code but last time i suggested to add checkstyle benjchristensen was not very happy…i understand that rxjava is not my project and i cant just come and force you to use my codestyle which is actually just standard java codestyle so if you dont want to accept such changes — its okay ill stop doing such prs and will report only major issues i like this pr too much im going to merge it i like this pr too much im going to merge it
3149,1,0,0,0,0,1,1,0,scheduler shutdown capability repost of we still need to decide on the reset vs shutdown distinction is your perspective do you have a strong opinion one way or another with start shutdown there is a clear intention to stop everybody with reset any running code could respawn the threads and the new threads will resume leaking i prefer start shutdown agree it will be great to have ability to stop schedulers and prevent new workers from scheduling for apps that run in servlets and other similar containers which can be stopped externally im happy with the start shutdown pair which seems to support my primary use cases resource release on webapp shutdown in container resource release on completion of programs run by a framework that looked for unreleased threads maven on ad hoc basis ensuring schedulers are not running in the background on entry into a unit test when running a suite thanks akarnokd the start shutdown semantic looks good to me more explicit best enforcement of shutdown and good compatibility with items mentioned by davidmoten which are pretty much our use cases as well ill following this thread to be notified when its merged thanks akarnokd benjchristensen do you consider we have consensus on naming after that itd be showtime because so many customers from us run into this daschl i would like a bit more context on what the goal is for the scheduler shutdown capability davidmoten and any others please respond thanks resource release on webapp shutdown in containerwhat resources exactly need to be freed shutting down the schedulers would prevent new workers from being scheduled and would free up threads from the executor is this the desired behavior or is there some side effect that you are looking for resource release on completion of programs run by a framework that looked for unreleased threads maven could anyone name a framework thats impacted is the concern that open threads keep the framework from properly terminating on ad hoc basis ensuring schedulers are not running in the background on entry into a unit test when running a suite would the testscheduler solve this problem for you this doesnt rely on singleton values and can be used to precisely test scheduling behavior stealthcode i can answer the question i hope it help you could anyone name a framework thats impacted is the concern that open threads keep the framework from properly terminating couchbase java sdkcb sdk are not able to finish some of they own threads because it is referring rxcomputationthreadpool threads who cant be finishedyou can see more details about how this issue are affecting this framework here stealthcode i can give you the answer to your questions tooid like to use rxjava in the container eg id like to use jersey rx client on tomcat unfortunately it is impossible to shutdown _rxcomputationthreadpool _ threads and container has memory leaks that causes that rxjava is inapplicable for my purposes and in my case regarding question yes shutting down all schedulers permanently is a desired behaviour and testscheduler is not a solution so im really looking forward to seeing this pr accepted and released mjakubowski similar case here mjakubowski understood regarding the testscheduler this is meant for use in tests and highly recommended when it comes to a container you would definitely want to use a real scheduler so what i hear is that there is no desire to resume the scheduler once it is shut down my concern is that by offering a schedulerlifecyclestart method we are inviting non deterministic behavior in the case that someone wants to use this to teardown and then resume in integration tests for example would it be acceptable to remove the start method from the public interface and rename shutdown to teardown to more accurately describe the intent i dont have strong opinion between shutdown teardown teardown makes the intent clearer but shutdown is more idiomatic in the context of java executor otherwise the code lgtm another thing if we want to be more java idiomatic maybe hiding the start is the right thing to doit will also have the benefit of avoiding bug by misusage of the library calling start after a shutdown i can make schedulersstart package private so the tests can use it but i the scheduler implementations have to keep their start public please do i believe that would be better done akarnokd stevegury folks do you think its possible to get this into akarnokd thanks i think this is fine do you guys have a plan date to merge it akarnokd i think its appropriate that you merge this pr since you are most familiar with this code if you think you are happy with it then feel free oh sorry didnt recount the number of likes merging where can i get the latest build with this fix maven central is still at chiangh you can clone the project and build it from master good luck rxjava uses bintray for binaries and also publishes snapshots in jfrogs oss artifactory so you can add the following repository to your pomxml xml snapshots libs snapshot that you should be able to depend on rxjava snapshot
3150,1,0,0,0,0,1,1,0,window operators now support backpressure in the inner observable repost of do we need to maintain both bufferuntilsubscriber v and v at the same time bufferuntilsubscriber does some black backpressure magic inside groupby which i wasnt able to figure out and the v doesnt pass unit tests with it it seems like bufferuntilsubscriber is being used as a special case buffer for operatorgroupby while bufferuntilsubscriberv is custom for the windowing operators if they cannot be reconciled to work for both cases then could you please move them into the operators as static nested classesalso since groupbys back pressure is being patched maybe itd be a good idea to revisit this pull request with those changes to try to combine the two bufferuntilsubscriber s these are internal classes and can live in their own files the groupby in no longer uses it and once merged this bufferuntilsubscriberv can be renamed or better yet promoted to a standard api unicastsubject i dont think we should be so eager to combine things such combinations end up in monstrous classes which are then sources of misunderstanding and complexity bufferuntilsubscriber was a proposed as a solution to the time gap problem in group by so because bufferuntilsubscriberv doesnt work to solve this problem for group by leads me to question its naming is it built to handle the same problem or a different problem are you proposing to rename v to unicastsubject i dont think we should be so eager to combine things such combinations end up in monstrous classes which are then sources of misunderstanding and complexityim proposing to hide away internal functionality from the public api neither of these are public api since they reside in the internal package hiding them further away seems to be unnecessary in addition bufferuntilsubscriberv is effectively turned into the official unicastsubject in xhistorically bufferuntilsubscriber started out to solve the time gap problem for the non backpressured groupby and window when the backpressure was introduced groupby had to support backpressure but bufferuntilsubscriber wasnt enhanced instead bufferuntilsubscriber is used as a middle man and the subscription process is hijacked to inject a producer that attempts to coordinate requests apparently this didnt cover all request pattern hence the original bug due to this very specific hijacking adding backpressure to bufferuntilsubscriber directly didnt work out as it conflicted with the request coordination in a way i couldnt resolve therefore i decided to have a separate class that does backpressure but doesnt have to be involved in request coordination for window which i believe cant be established with a reasonable strategy all im asking for is a rename from v in x maybe i missed it but whats the name youd like ive renamed the class to unicastsubject and combined the state with the onsubscribebus class im going to sleep now its midnight here so if you only have concerns about naming location and visibility i suggest merging this pr then posting a separate pr with your changes and merge it if you can get somebody else to like it in the meantime akarnokd would you mind rebasing this done
3155,1,0,0,0,0,1,1,1,safesubscriber report oncompleted unsubscribe error to rxjavaplugin discussed in when an observable emits oncompleted but unsubscribe in safesubscriber throws then the error should be reported to the rxjavaplugin error handler and if that fails a stack trace is written to systemerr there are a lot of repeated try catch blocks calling the rxjavaplugins error handler so ive made a rxjavapluginutils class it will also be called from the using fix which i will submit once this pr has been accepted one of the tests fails im going to ponder the issue of throwing after reporting to the error handler a bit ive been looking for a bit of guidance about what to do when unsubscribe throws in safesubscriber _rx design guidelines_ doesnt really cover it _reactive streams jvm_ does touch upon it saying calling subscriptioncancel must return normally the only legal way to signal failure to a subscriber is via the onerror methodi think given that the contract has been breached it is fair to throw an exception and i think a new wrapper unsubscribefailureexception would be appropriateid also like to address the case when oncompleted throws _reactive streams jvm_ has this to say calling onsubscribe onnext onerror or oncomplete must return normally except when any provided parameter is null in which case it must throw a javalangnullpointerexception to the caller for all other situations the only legal way for a subscriber to signal failure is by cancelling its subscription in the case that this rule is violated any associated subscription to the subscriber must be considered as cancelled and the caller must raise this error condition in a fashion that is adequate for the runtime environmentso in the existing code if in safesubscriber an onerror call to the downstream subscriber throws then the rxjavaplugin error handler is called _and_ an onerrorfailedexception is thrown comments in the method say this is ok because the contract has been broken and this is probably consistent with the advice in and the caller must raise this error condition in a fashion that is adequate for the runtime environmentin the existing code if in safesubscriber an oncompleted call to the downstream subscriber throws then the consequent call to _onerror tries to signal onerror to the downstream subscriber im worried that calling onerror after calling oncompleted is a strong enough breach of the contract that the possible side effects could be worse than just a throw shouldnt we throw only and notify the plugin error handler of course ive submitted code that matches my thinking above it still fails because i havent amended the existing unit tests associated with throwing ill do that after another round of review if accepted the failing test is a coverage test for a behavior no longer present i suggest removing it and rerunning the jacoco to see if all current code path is covered akarnokd yep thats right are you happy that a throwing oncompleted call should not induce an onerror call if so ill clean up and update the pr ive the unit tests and added more so that safesubscriber gets coverage looks good to mesince this adds public api classes it requires further approval otherwise it shouldnt affect programs other than those that badly fail therefore the merge policy would allow me to merge it lgtm it would be better if you can fix the indent for unsubscribefailureexception its a pity that we cannot change onerrorfailedexception s that should have been unsubscribefailureexception now since its a break change thanks for review akarnokd and zsxwing ive fixed indent in test and squashed commits great
3169,1,0,1,0,0,0,1,0,merge can now operate in horizontally unbounded mode note that since the default merge operation is unbounded this change could lead to an excessive memory usage when flatmapping fast sources note that the pre version did this albeit on a slighty slower paththe change also affects the scalar optimization as well pre implicitly limited the concurrency level to rxringbuffersize when scalars were received this version now fills the queue up to the concurrency levelfor i suggest having a bounded behavior by default and require the developer to specify integermax_value to go for the unbounded behavior so he she knows about the consequences ill have to allocate some time to review this later as it is somewhat detailed thank you for tackling this pre implicitly limited the concurrency level to rxringbuffersize when scalars were receivedthat was done by design since scalars behave as onnext and we can limit the number of observable s being merged if we have scalars queued up for deliverythe reason we cant limit the number of async observable s is because we dont know if they will emit or not and thus risk deadlock ill rebase this rebased lets get this finally in
3286,1,0,0,0,0,1,1,1,implements blockingsingle adds blockingsingle issue the blocking version of rxsingleblockingsingle has the following methods from single factory method for creating a blockingsingle from a single value returns the value emitted from the single tofuture returns a javautilconcurrentfuture couldnt actually think of any other useful operations to perform on blockingsingle in comparison to blockingobservable theres not much to this class at the moment hmmmgot a test failure that i cant reproduce locally by rxobservablessynconsubscribetest testsubscribeon failed javalangassertionerror expected but was at orgjunitassertfail assertjava at orgjunitassertfailnotequals assertjava at orgjunitassertassertequals assertjava at orgjunitassertassertequals assertjava at orgjunitassertassertequals assertjava at rxobservablessynconsubscribetesttestsubscribeon synconsubscribetestjava this test failure should be resolved now hyleung is this ready to be reviewed merged abersnaze not quite yet there are a couple of things from artem zinnatullins pr that i want to pull in splitting out a separate blockingutils class to hold awaitcomplete for example also im going to rebase it against head of x since its been about a month abersnaze the pr is ready for review btw ill keep the commits separate as i incorporate the feedback and squash it down at the end maybe move blockingsingle from rxobservables to rxsingles artem zinnatullin re rxsingles that would be a new package then dont have a particular option either way tbh anybody else ah i see what youre getting atmoved to rxsingles which other operators are you thinking of adding to single btw lgtm just a few nits left im ready to merge this as long as we can add the necessary experimental annotations and rebase onto x stealthcode done thanks for contributing
3352,1,0,1,0,0,0,1,0,perf checks for flatmap and merge ported the two perf tests to evaluate x throughput primary suspect for the extra overhead are the atomics of queue drain the x uses a synchronized based emitter loop which is elided by the jit compiler but atomics cant be elided as i mentioned before synchronized works better for light to none asynchronous use whereas atomics work better for asynchronous usealso quote from exceptions that do not require a would be javadoc changes unit test additions or refactoring perf test additions fixes or refactoring grammatical and presentation fixes to readme contributing and other such metadata files
3357,1,0,0,0,0,0,1,0,eager concatmap related discussion in thanks a lot for contributing this one akarnokd ive had one look through and no problems jump out at me but i will review further this will be useful thanks for the review davidmoten usually i use one letter variables because i find it easier to parse the code and instead of long variable names i use newlines to separate logical blocks this way i dont have to type that many letters and i dont have to wait while eclipse returns with the content assist which is blocking by the way and may take hundreds of milliseconds even on my i ssd i took the time and renamed variables as you asked for and added some more unit tests that check the code paths that being said i dont plan to do such renames in my contributions very often in the future and encourage anybody to post their prs with their proposed cleanups renames thanks for the feedback ive updated the method names to concatmapeager and concateager added the experimental tags some javadoc and a missing test for a parameter concateager overload updated with a capacity fix for the spsclinkedarrayqueue i reviewed in details in the code and i believe it is correctbut i wonder if subscribing to the sources in a unbounded mode is the right thing to doat the expense of complexifying the code i believe it could be possible to split the request n between the sources maybe requesting to all the m sources expect the first one which we request n m and so onthe devil is in the details and i believe this would significantly complexify the code but i would like to know what you are thinking about this stevegury this operator consumes source observables in order and doesnt make sense to split any request from downstream if the downstream requests n and the first is requested n count that would hang the sequence because only the first is allowed to emit and it wont emit enough to trigger a new requestit is possible to use a bounded buffer per source so while they are not consumed they dont grow indefinitely however it means that each of them can produce only rxringbuffersize elements before stopping and thus the operator wouldnt be eager anymore akarnokd sorry i wasnt very clear but what i proposed was roughly what you described replacing rxringbuffersize my main concern here is the use of unbounded buffer which i think could be avoided davidmoten what do you think about the bounded buffering and the fact that such sources would act more like a delayed source id be happy to see bounded buffering rxringbuffersize sounds a better default size than to me and would be consistent with the request eagerness of other operators like merge for instance could we add an overload to allow the specification of buffer size as wellif this is significant rework im content to see this unbounded version documented with its buffering characteristics merged and we can defer the bounding work to another pr done great thanks akarnokd lightning quick as always lgtm the three of you seem happy with it so im merging it
3382,1,0,0,0,0,0,1,0,fix spsclinkedarrayqueue leaves slot null just before growing discovered while debugging confirmed with jctools in https githubcom jctools jctools pull
3417,1,0,0,0,0,1,1,1,add singledoonsuccess closes artem zinnatullin rebase please abersnaze rebased
3444,1,0,0,0,0,1,1,1,completable class to support valueless event composition tests this is a backport of looks good should we annotate experimental on all the public methods and operators now the class annotation should indicate all methods are experimental if individual methods get promoted we can add direct annotations then sounds good on sat dec david karnok notifications githubcom wrote now the class annotation should indicate all methods are experimental if individual methods get promoted we can add direct annotations then — reply to this email directly or view it on github since this adds to the api surface id like to get another like before merging awesome
3447,1,0,0,0,0,0,1,0,delaysubscription with a plain other observable requested in this is an efficient implementation as it avoids allocating the lifter object doesnt require a function wrapper and doesnt use producer arbitration bonus points to those who can recognize the similarities with any thoughts about this
3447,1,0,0,0,0,0,1,0,delaysubscription with a plain other observable requested in this is an efficient implementation as it avoids allocating the lifter object doesnt require a function wrapper and doesnt use producer arbitration bonus points to those who can recognize the similarities with any thoughts about this
3467,1,0,0,0,0,1,1,0,compensation for significant clock drifts in scheduleperiodically there is a problem reported in and in which if the system clock drifts the periodic calculation inside schedulerworker gets off and either taking a longer time for the next invocation of the task or doing catching up with all the lost invocationsthe solution checks the wall clock difference between the last run and the current run and if it went back or forward significantly it rebases the timer period and schedules the next execution relative to nowif the clock goes back the original code scheduled the next invocation way into the future this pr will schedule it after the periodif the clock goes forward the original code scheduled executions for all the missed time between the last run and the new time immediately yielding a bunch of delays this pr will simply schedule the next invocation after the periodthe algorithm for both cases is the same make sure the next invocation is scheduled relative to now and recalculate the start timestamp as if the whole sequence run under the new drifted clock all along the subsequent invocations will be scheduled at a rate againive added the system parameter rxschedulerdrift tolerance unit minutes default minutes which is used to determine if the clock drifted too far between invocations of the periodic task time drift is pretty nasty we spent a lot of time on this in rxnet ive updated the code with the suggestion of stealthcode do you need additional changes if not feel free to merge this pr yay this was important issueso i did test similar to javaobservable interval seconds subscribe along loggerd interval d along and then changed system clock to hours at runtime of the app before fix as expected computation scheduler gone crazy and fired about events during one second img width altscreen shot at src width altscreen shot at src fix everything was just fine no incorrect events no cpu consuming img width altscreen shot at src width altscreen shot at src i think and can be closed nowthanks akarnokd
3467,1,0,0,0,0,1,1,0,compensation for significant clock drifts in scheduleperiodically there is a problem reported in and in which if the system clock drifts the periodic calculation inside schedulerworker gets off and either taking a longer time for the next invocation of the task or doing catching up with all the lost invocationsthe solution checks the wall clock difference between the last run and the current run and if it went back or forward significantly it rebases the timer period and schedules the next execution relative to nowif the clock goes back the original code scheduled the next invocation way into the future this pr will schedule it after the periodif the clock goes forward the original code scheduled executions for all the missed time between the last run and the new time immediately yielding a bunch of delays this pr will simply schedule the next invocation after the periodthe algorithm for both cases is the same make sure the next invocation is scheduled relative to now and recalculate the start timestamp as if the whole sequence run under the new drifted clock all along the subsequent invocations will be scheduled at a rate againive added the system parameter rxschedulerdrift tolerance unit minutes default minutes which is used to determine if the clock drifted too far between invocations of the periodic task time drift is pretty nasty we spent a lot of time on this in rxnet ive updated the code with the suggestion of stealthcode do you need additional changes if not feel free to merge this pr yay this was important issueso i did test similar to javaobservable interval seconds subscribe along loggerd interval d along and then changed system clock to hours at runtime of the app before fix as expected computation scheduler gone crazy and fired about events during one second img width altscreen shot at src width altscreen shot at src fix everything was just fine no incorrect events no cpu consuming img width altscreen shot at src width altscreen shot at src i think and can be closed nowthanks akarnokd
3470,0,0,0,0,0,1,1,0,replay request coordination reduce overhead reported in this change will make sure whenever a new subscriber arrives therequest coordination doesnt scan every other subscriber unnecessary they will trigger a managerequests individually anyway unfortunately i cant make the subscription registration constant via a hashset because that would slow down the dispatching loop which is quite expensive to for each over compared to a plain array note also that this will likely conflict with i get the following numbers with the program in subscribingsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secunsubscribingunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per sec ive updated the code to have o subscription unsubscription cost as well the program from now produces stunning results subscribingsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secsubscribed so far took ms to subscribe last at rate per secunsubscribingunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per secunsubscribed so far took ms to unsubscribe last at rate per sec the numbers could be actually higher but windows timer resolution is about ms at best ive updated the code to avoid the synchronized block on each replay attempt in case the cached version of the innerproducers is still the same as the sets version i havent reviewed the changes in detail yet but i do notice that openhashset doesnt have any dedicated unit tests ive added a unit test for openhashset strangely the test doesnt crash with java must be some difference between what type for each extracts akarnokd needs rebase on latest x thanks working on it rebased i like this a lot and the results are really impressive code looks good to me cleaner than the previous implementation too i finally find some time to review this one sorry for the delay
3512,0,0,0,0,0,0,1,0,fix safesubscriber documentation regarding unsubscribe the documentation was wrong in two points unsubscription doesnt call oncompleted and unsubscription doesnt directly prevent delivery of onxxx events since the implementation doesnt even check isunsubscribed it is the responsibility of the upstream to do that related issue
3513,1,0,0,1,0,1,1,0,add shorter rxjavaplugin class lookup approach this adds a new pattern and lookup method that lets the developer specify the custom plugins with shorter system property keys android is quite restrictive and allows only charactersthe new pattern splits the target simple class name and its implementation into two separate system properties rxjavaplugin classsimpleclassnamerxjavaplugin implpathtoimplclass the index tag can be any string of your chosing rxjavapluginmykeyclasssimpleclassnamerxjavapluginmykeyimplpathtoimplclass but make sure they are paired otherwise nothing will happenif there are multiple class entries with the same simpleclassname one of them will be chosen depending on the walk order in javautilproperties related issue updated made strings local constants and using length ˙instead of magic numbers plus if the default keying matches the properties is not traversed for an alternate specification an alternative pattern could be this rxjavaplugin simpleclassnameorgpackagenamingactualclass i agree that if the plugin cannot be found we should crash the app updated the code to crash if the plugin implementation is missing
3524,1,0,0,0,0,0,1,0,fix subscribe javadoc fix for javadoc issue
3584,1,0,0,0,0,0,1,0,clarify behaviour of groupby in javadoc as discussed in some clarification of the behaviour of groupby looks necessary re its behaviour when the groupedobservable terminates early for example has first applied to it see also i also took the liberty of recommending ignoreelements instead of take for the section in the javadoc that recommends how to ignore emissions because the take approach would have more overhead every emission from source would prompt the emission of a new groupedobservable than the ignoreelements approachonce this is accepted ill look to submit a pr with groupbyonce mentioned in corrected the documentation that said resubscription occurs when it is rather a new groupedobservable is emittted for a group incorporated akarnokd suggestion i also took the liberty of recommending ignoreelements instead of take for the section in the javadoc that recommends how to ignore emissions because the take approach would have more overhead every emission from source would prompt the emission of a new groupedobservable than the ignoreelements approachby the way ignoreelements has a drawback it keeps all group observable s in memory even some of them wont emit items
3584,1,0,0,0,0,0,1,0,clarify behaviour of groupby in javadoc as discussed in some clarification of the behaviour of groupby looks necessary re its behaviour when the groupedobservable terminates early for example has first applied to it see also i also took the liberty of recommending ignoreelements instead of take for the section in the javadoc that recommends how to ignore emissions because the take approach would have more overhead every emission from source would prompt the emission of a new groupedobservable than the ignoreelements approachonce this is accepted ill look to submit a pr with groupbyonce mentioned in corrected the documentation that said resubscription occurs when it is rather a new groupedobservable is emittted for a group incorporated akarnokd suggestion i also took the liberty of recommending ignoreelements instead of take for the section in the javadoc that recommends how to ignore emissions because the take approach would have more overhead every emission from source would prompt the emission of a new groupedobservable than the ignoreelements approachby the way ignoreelements has a drawback it keeps all group observable s in memory even some of them wont emit items
3614,1,0,0,0,0,0,1,0,just now supports backpressure related fixes changes updated just to fully support backpressurethis is a repost of due to merge and rebase problems we were waiting to hear from benjchristensen on this one i think any news for correctness despite my hesitance due to perf impact
3655,1,0,0,0,0,1,1,1,add singleonerrorresumenext single part of will submit a pr for onerrorresumenext func later akarnokd changed to implements singleonsubscribe ptal zsxwing ptal
3661,1,0,0,0,0,0,1,0,combinelatest now supports any number of sources this pr is a backport of the x combinelatest with null support and lets the programmer combine more than sources at once note that x supports manual sizing of the prefetch buffer and allows delaying the exceptions to the last moment i kept these in case such features are required by x some daythe original had this limit due to using a single and non parametric rxringbuffer to store values from sources in addition the original algorithm divided downstream requests among the sources with some strange logic in order to keep them running and not overflow the bufferthis pr uses an unbounded linked spsc queue which can now hold as many elements as there are sources times the default ring buffer size this is not preallocated and grows shrinks as necessary the algorithm stores the current latest array and the source subscriber in the queue in pairs so when that particular row is emitted to downstream that source subscriber gets the request replenishment call that generated the rowin addition ive added an iterator overload from as well
3682,1,0,0,0,0,0,1,0,fix observeon resource handling add delayerror capability this pr fixes the messing around reported in and adds an overload to observeon that allows delaying errors without the need for wrapping see and maybe there are other reports in addition this pr adds a proper override of the isempty method to simply compare the two indexes for emptiness directly instead of size to avoid looping multi reading and castingbenchmark comparison i windows x java u that the benchmark is generally quite noisy yielding hectic results ie firing up a thread with newthread may take quite some random microseconds for example observeonimmediate shouldnt be affected by any of the changes yet the run to run variance is im fine with the results of the benchmark
3682,1,0,0,0,0,0,1,0,fix observeon resource handling add delayerror capability this pr fixes the messing around reported in and adds an overload to observeon that allows delaying errors without the need for wrapping see and maybe there are other reports in addition this pr adds a proper override of the isempty method to simply compare the two indexes for emptiness directly instead of size to avoid looping multi reading and castingbenchmark comparison i windows x java u that the benchmark is generally quite noisy yielding hectic results ie firing up a thread with newthread may take quite some random microseconds for example observeonimmediate shouldnt be affected by any of the changes yet the run to run variance is im fine with the results of the benchmark
3689,1,0,0,0,0,0,1,0,unified onerrorx and onexceptionresumenext and backpressure the operators didnt honor backpressure when they switched over to the other observablethis pr also includes the there was a test failure in backpressureteststestmergeasync run before any of the changes of this pr and shouldnt have any effect overloaded servers
3696,1,0,0,1,0,1,1,1,added single execution hooks would you also apply these plugin methods in single onsubscribestart onsubscribereturn onsubscribeerror onlift below hooks are already called i replaced previous calls of rxjavaobservableexecutionhook rxjavasingleexecutionhook calls onsubscribereturn onsubscribeerror onlifthowever there is problem with onsubscribestart this hook should be called in onsubscribe and unsafesubscribe unfortunately in single onsubscribe and unsafesubscribe methods get subscriber type as parameter instead of singlesubscriber i will make a commit to cover it soon there is something wrong a bunch of single test failed as far i see that failing test is not related with my changes is rxschedulerscachedthreadschedulertest testunsubscribeforscheduler some kind of flaky test more tests would be appreciated but otherwise could you squash the commits and rebase this pr after you rebase squash the commits
3701,1,0,0,0,0,1,1,1,add completabledooncompleted and deprecate completabledooncomplete closes wait what i thought you wanted to add completabledooncompleted i see no reason to change the established naming of observabledooncompleted in fact for consistency id rather prefer adding completabledooncompleted that makes sense the only reason i did it this way is because on the x branch both observable and completable use dooncomplete yes those follow the reactive streams convention and completable started out as a x addition in the meantime ill fix that test failure changed completable instead updated tests to match zach klippenstein thanks just updated the title
3712,1,0,0,0,0,1,1,1,add takeuntil support in single as discussed in this adds takeuntil observable and takeuntil single support in single it was mostly just adapting the logic from the existing operatortakeuntil and adjusting it for accepting a single and sending a cancelattionexception in the event of a submission from other prior to a terminal event in the source single any feedback is appreciated it this is my first time contributing an implementation to this project particularly wondering if its worth keeping both overloads or if the user should just coerce their other to one type or ther other also particularly looking for feedback on what information to include in the cancellationexception just noticed my ide swapped the wildcard imports for explicit ones let me know if i should revert that yes please just style issues otherwise lgtm cc akarnokd artem zinnatullin for the tests most of them are adapted from operatortakeuntiltest it looks like these tests have two different styles one with testobservable and the other with subject i reused both of them here but would we maybe want to stick with one or the other especially with single i think some now overlapalso if we stick with one style here should we update the style in operatortakeuntiltest as well to match im not too keen on how the tests are named or what test framework objects you useplease squash your commits squashed zsxwing stevegury any input need another collaborator reviewmain points im wondering about should we only support one overload if we support more than one should it support all three including completable should takeuntil test styles formalized looks like there are two styles right now judging operatortakeuntiltest subject based and testobservable based yes i think it makes sense to had an override for completable regarding test styles i dont think its a big deal the best thing to do slowly convert all the tests to the new convention ideally in separated commits that dont change the behavior sending a cancelattionexception in the event of a submission from other prior to a terminal event in the source singlethis behavior is really confusing why not be same as observable am i missing anything akarnokd and i discussed it in single currently emits a nosuchelementexception if the stream is terminated prior to any event emission by signaling a cancellationexception we can at least signal to the subscriber if the error was due to takeuntil unsubscribing it or normal missing emissions hzsweers thanks for clarifying however i would expect singletakeuntil returns something that contains or item how about returning observable instead then the semantics of singletakeuntil is onnext{ } oncompleted onerror which is consistent with observabletakeuntil onnext{ n} oncompleted onerror the operators should stay in the same type as long as they can and there are operators that simply cant behave the same as their counterpart in other reactive types if one wishes the observabletakeuntil behavior one can use toobservable takeuntil and get that behavior the operators should stay in the same type as long as they can and there are operators that simply cant behave the same as their counterpart in other reactive types if one wishes the observabletakeuntil behavior one can use toobservable takeuntil and get that behaviorif so i vote for nosuchelementexception as cancellationexception seems counterintuitive to me cancellationexception looks some codes cancel single eg i call unsubscribe in some place but here the error is that singletakeuntil returns something that is not single hence i would expect nosuchelementexception thats fair but is there something we could do to at least indicate whether the source was just unsubscribed or actually misbehaved i was of the impression that onerror was primarily for serious unexpected errors whereas this seems like not unexpected or seriousconsider the followingwith nosuchelementexception javapublishsubject source publishsubjectcreate publishsubject until publishsubjectcreate sourcetake tosingle takeuntil untiltake tosingle subscribe new action { override public void call integer integer { systemoutprintln success } } new action { override public void call throwable throwable { systemoutprintln i dont know if it was due to unsubscribing or the source is misbehaving } } untilonnext vs with cancellationexception javapublishsubject source publishsubjectcreate publishsubject until publishsubjectcreate sourcetake tosingle takeuntil untiltake tosingle subscribe new action { override public void call integer integer { systemoutprintln success } } new action { override public void call throwable throwable { if throwable instanceof cancellationexception { systemoutprintln it was canceled } else { systemoutprintln source didnt emit } } } untilonnext the example i gave in the issue is probably the best example for me we use something similar to this for lifecycle binding in android when the lifecycle ends it might unsubscribe this in the middle for a normal error we might show a generic an error occurred message in the event that its just the lifecycle ending we dont want to react that way and rather likely just want to do nothing at all or clean up resources im fine with not using cancellationexception but i think it would be useful to add a means of being able to differentiate between unsubscription reasons i thought about just specifying a message but felt that akarnokds cancellationexception suggestion made it more clear ill add an overload for completable as well and remove the old test style in the new tests here for now stevegury just to be clear the new style would be the subject based approach right hzsweers i actually typed its a big deal but i was willing to say its not a big deal i corrected my previous comment i prefer the subject based approach but i am not strongly opinionated about thati still on the current implementation thats fair but is there something we could do to at least indicate whether the source was just unsubscribed or actually misbehavedmy point here is if singletakeuntil returns a single that emits nothing it should be misbehaved rather than unsubscribed i think cancellationexception is the clearer reaction here remember the problems around the observablesingle and how it is a source of problem to find out exactly who didnt signal here you know that if takeuntil is tripped and not some upstream machinery ends up being empty i think cancellationexception is the clearer reaction here remember the problems around the observablesingle and how it is a source of problem to find out exactly who didnt signal here you know that if takeuntil is tripped and not some upstream machinery ends up being emptywhat if we want to add other operator that may return something doesnt signal if it also emits cancellationexception then we still cannot find out exactly who didnt signal so why not use nosuchelementexception to indicate all cases that didnt signal what about a subclass of nosuchelementexception a cancelednosuchelementexception so to speak wouldnt break the downstream apis but still allows for the subscriber to differentiate what about a subclass of nosuchelementexception a cancelednosuchelementexception so to speak wouldnt break the downstream apis but still allows for the subscriber to differentiatemaybe a more general question should we add special exceptions for different operators or we just use a general exception to indicate the same error i think people should be aware of the implications of operators they use would compositeexception possibly be precedent for this i think people should be aware of the implications of operators they use would compositeexception possibly be precedent for thiscompositeexception is fine and clear it indicates there are multiple errors thrown all classes in rxexceptions are well defined and its very easy to connect them with the bad cases i can just read the exception name and tell what my codes violate but for cancellationexception its hard to connect it with takeuntil especially people use some library that calls takeuntil internally in addition imo if i see cancellationexception my first thought is futurecancel is called somewhereif we can define clearly that when should throw cancellationexception cancelednosuchelementexception or whatever you propose when should throw nosuchelementexception i wont be against that for now the confusing thing for me is that if a single doesnt signal i may receive cancellationexception or nosuchelementexception im fine with either i think we could be clear in the documentation and subclassing would still allow downstream subscribers to treat it as a nosuchelementexception akarnokd stevegury thoughts added takeuntil completable support and standardized tests updated with a separate commit for easier reviewing let me know if you want me to squash againping akarnokd stevegury
3714,1,0,0,0,0,0,1,0,add maxconcurrent parameter to concatmapeager relevant issue will you update this pr yes on it i submitted a commit with your proposed changes sorry for the delay feel free to give me more comments changes also i can squash if needed dont squash this time github has now a new feature for the merge button where it offers squashing id like to test if it really squashes everything and the main just gets commit nothing critical akarnokd squashing on github works and it works especially great when author of the pr just commits on top of previous commits because github now remembers what code youve checked and what not and you can continue reviewing from previous point doesnt work for me when pr is always squashed i have updated the pr do pr commits trigger github notifications should i comment after i do an update unfortunately no notification
3722,1,0,0,0,0,0,1,0,add maxconcurrent parameter to flatmapiterable refs should these new overloaded functions be annotated with beta the failing test testnomorerequestsafterunsubscribe seems unrelated all tests pass locally if you could add one unit test for each method that verifies maxconcurrent is honored that would be great while writing the test i figured you might have been right when commenting on issue if i am not mistaken all the observables created with operatormappairconvertselector use the same scheduler there is no way to subscribe them to different schedulers and thus are run sequentially and until completion would adding a scheduler parameter make sense there is no scheduler involved here so no as it is now
3733,1,0,0,0,1,1,1,1,avoid swallowing errors in completable instead deliver them up to the threads uncaught exception handlerfixes reactivex rxjava what happened to completabletest akarnokd sorry ij formatted it will clean up and push again just a nit about timeout in tests otherwise removed timeouts
3741,1,0,0,0,0,1,1,1,add doonsubscribe for single ref i didnt write much unit tests for doonsubscribe because it internally uses operatordoonsubscribe which is well covered thanks aaronhe
3752,1,0,0,0,0,1,1,1,singleusing this pr adds the factory method using overload to single as requested in for convenience ive also added singlesubscribe observer lgtm
3756,1,0,0,0,0,0,1,0,clarify join groupjoin no ordering guarantees original issue
3766,1,0,0,0,0,1,1,1,add singleonerrorresumenext func closes closes closes whoa issues at a time akarnokd your comments btw should i add experimental to these operators yes and copy over the experimental and since tags into the javadoc there is this new like option but do you get a notification for them noon mon mar pm david karnok notifications githubcom wrote image there is this new like option but do you get a notification for them — you are receiving this because you are subscribed to this thread reply to this email directly or view it on github
3766,1,0,0,0,0,1,1,1,add singleonerrorresumenext func closes closes closes whoa issues at a time akarnokd your comments btw should i add experimental to these operators yes and copy over the experimental and since tags into the javadoc there is this new like option but do you get a notification for them noon mon mar pm david karnok notifications githubcom wrote image there is this new like option but do you get a notification for them — you are receiving this because you are subscribed to this thread reply to this email directly or view it on github
3766,1,0,0,0,0,1,1,1,add singleonerrorresumenext func closes closes closes whoa issues at a time akarnokd your comments btw should i add experimental to these operators yes and copy over the experimental and since tags into the javadoc there is this new like option but do you get a notification for them noon mon mar pm david karnok notifications githubcom wrote image there is this new like option but do you get a notification for them — you are receiving this because you are subscribed to this thread reply to this email directly or view it on github
3777,1,0,0,0,0,0,1,0,observeon allow configurable buffer size the observeon operator is backed by a small queue of slots that mayoverflow quickly on slow producers this could only be avoided byadding a backpressure operator before the observeon not onlyinconvenient but also taking a perf hit as it forces hops between twoqueues this patch allows modifying the default queue size on the observeonoperatorfixes signed off by galo navarro anglorvaroa gmailcom though id leave old test for default buffer size and just add a new one rebased the javadoc link and a spelling mistake artem zinnatullin i reused this one to avoid redundancy as the code path is virtually the same and there are tests the ones referenced in the link which use the default size let me know if you still prefer the cases and ill fix that yeah i understand just afraid that one may change linked tests and we wont cover overload one day well setup code coverage i hope agh thanks akarnokd i didnt notice i changed computers so i was back on the st patch and lost the overload resubmitted based on the one with all overloads and added the extra test instead of rewriting it hopefully fine now ive seen some failures on the test locally and there is also a bug in the test the loop should start at not i cant look into it right now but will take a look asap im merging this the changes are algorithmically solid so im not sure what failures you see locally thanks akarnokd the failure was no error notifications emitted at random sizes but i did notice travis didnt complain ping me if it surfaces
3787,0,0,0,0,0,1,1,0,fix groupby delaying group completion till all groups were emitted in groupby was to properly honor backpressure on the outer observable the change included a drain loop that emitted oncompleted to the groups only when all groupedobservable s were drained from the main queue this delayed the groups completion unnecessarily causing the concat operator to hang in some source consumer cases such as this pr fixes the behavior by signalling oncompleted to the groups the moment the main completes note however that concatenating groups is eventually prone to hangs due to the groups not completing until the source completes thus concat cant switch to the next source one should use flatmap or concatmapeager instead
3789,1,0,0,0,0,1,1,1,prevent singlezip of zero singles closes
3790,1,0,0,0,0,0,1,0,expose singlelift closes
3822,1,0,0,1,0,0,1,0,make defensive copy of the properties in rxjavaplugins possible solution to
3856,1,0,0,0,0,0,1,0,provide factories for creating the default scheduler instances unlike other hooks the rxjavaschedulershook has no access to the real scheduler instances in order to do wrapping delegation with these factory methods a hook can access what would otherwise be the instance used since there is often no other means of creating these specialized schedulersfor android this wrapping delegation use case is important for ui testing we have a means to tell the testing framework when the app is idle and to do that we need to hook into the schedulers to know when theyre empty this is easy to do currently but you cannot wrap the real instance and instead have to supply alternate implementations which might subtly alter the behavior under testthese three methods are referenced in and i think providing the defaults is useful as well as eventually adding overloads which take threadfactory instances for each please correct me if im wrong but looks like as soon as you access one of the new methods static final schedulersinstance will be instantiated which will make impossible to use rxjavaschedulershook as you described have you checked described use case maybe add such tests as example if possible we have a means to tell the testing framework when the app is idle and to do that we need to hook into the schedulers to know when theyre emptyjust wanted to say for those who may find this pr later empty non empty state of schedulers is not source of truth for ui tests you may have some background or time related periodic etc code that does not affect the ui directly and may even freeze tests you are accessing the methods from the hook which was called from the static initializer of this class on first reference to schedulersio or the like ill add a test yup but there is still potential problem if somebody will try to create schedulers using these methods outside of the hook for example in beforeclass etc or probably even just for non test needs may result in hours of trying to understand why hook is not overriding schedulers…maybe move these methods to rxjavaschedulershook that prevents package scoped methods from being used in the factory that prevents package scoped methods from being used in the factorywe can move schedulers to internalschedulers to defend from that otherwise somebody can always use reflection to break package scope and make constructors publicideal solution would be to return schedulers in rxjavaschedulershook by default instead of returning null like it does now so calling supergetsomescheduler will give original instance that you can wrap etc as you wish though well have to handle null as default too sorry im very tired and want to sleep so i may come to wrong conclusions the factories were moved to the hook now but let me ask again what about this ideal solution would be to return schedulers in rxjavaschedulershook by default instead of returning null like it does now so calling supergetsomescheduler will give original instance that you can wrap etc as you wish though well have to handle null as default toono need for new methods no need to fight with instantiation order and package scope visibility yes user wont be able to instantiate new scheduler of required type outside of the hook but its not possible at the moment so nobody loses nothing
3866,1,0,0,0,0,1,1,1,add singletocompletable closes seems github doesnt add the pr description to the commit message automatically when squashing a pr i added it manually
3879,1,0,0,0,0,1,1,0,expose scheduler factories which accept thread factories this allows hooks to create schedulers whose threads have different prioritiescloses thankson fri apr at pm david karnok notifications githubcomwrote merged — you are receiving this because you authored the thread reply to this email directly or view it on github
3883,1,0,0,0,0,1,1,0,fix multiple chained singledoafterterminate not calling actions the bug is caused by the impedance mismatch between observable s subscriber and single s singlesubscriber the original code called onnext which immediately signalled an onsuccess but also caused an unsubscription preventing a delivery of oncompleted in the inner singlethe fix keeps onsuccess onerror rails intact throughout the chain
3886,1,0,0,0,0,1,1,0,throwiffatal now throws oncompletedfailedexception otherwise if theres an error in oncompleted the exception isswallowed and unreported
3907,1,0,0,0,0,0,1,0,doonunsubscribe javadoc clarifications see
3941,1,0,0,0,0,1,1,1,fix singleflatmap not composing subscription through see
3942,1,0,0,1,0,0,1,0,add completablesafesubscribe option rxjavaplugins hook support add option to safely subscribe a completablesubscriber regular subscriber and handle onxxx failuressee also naming and whether or not the safe wrapping should be the default is open to discussion in my opinion safe wrapping should be the default as its the default in observable and single at least the should behave the same way when using them one should expect them to have a difference in their essential semantics and not in these kind of things should the tests about error handling plugin in be here or we leave it in that pr bryant your pr has a test failure rxpluginsrxjavapluginstest testonerrorwhenusingcompletable failed javalangassertionerror expected but was at orgjunitassertfail assertjava at orgjunitassertfailnotequals assertjava at orgjunitassertassertequals assertjava at orgjunitassertassertequals assertjava at rxpluginsrxjavapluginstesttestonerrorwhenusingcompletable rxjavapluginstestjava typo renamed methods akarnokd they fail on purpose because i made the test but didnt fix the problem completable is not calling the error handling plugin the methods should be the other way around following single and observable there should be a single unsafesubscribe method which accepts a parameter of type completablesubscriber and subscribe should be present in the following ways subscribe subscribe action subscribe action action subscribe subscriber and subscribe completablesubscriber the subscribe methods wrap with safecomletablesubscriber similar to how observablesubscribe wraps with safesubscriber subscribe subscriber is there to allow conversion and cross type apis to bypass the safety overhead updated with plugin support can you cherry pick the commit that adds tests for the error handling plugn in completable and single from sure done the comment todo plugin wrapping onsubscribe in completablecreate can be deleted as the constructor is already calling the hook now removed comment changed to reuse methods added onstart call please add the missing experimental otherwise added missing annotations
3948,1,0,0,0,0,1,1,1,add completableandthen completable deprecate endwith see please update unit tests that use these deprecated methods done 👍 but id either duplicate tests or make universal test functions and test both endwith and andthen to make sure that we dont break old behavior of public api the question is also since completable is still experimental we could if this is wanted go the hard way and remove the deprecated methods and make everyone force to use the standard new methods since there are already quite a few deprecated duplicated methods 👍 but id either duplicate tests or make universal test functions and test both endwith and andthen to make sure that we dont break old behavior of public api artem zinnatullin im not against it but this is really minor as andthen just calls endwith im going to merge this feel free to add tests in a separate pr if you wish
3966,1,0,0,0,0,0,1,0,add multi other withlatestfrom operators add withlatestfrom operator version that can take to n other sources and combine them with the main sourcerelated
3971,1,0,0,0,0,0,1,0,request rebatch operator this is a follow up on but with a separate operator on observable abersnaze stealthcode you had some use cases for this any objections the reuse of the observeon is interesting but couldnt it be done without the allocation of a queue if the downstream request is unbounded and the downstream has caught up then the queue can be skipped in this case observeon cant be reused anymore and a custom drain logic has to be implementedotherwise the upstream emissions have to be stored temporarily for an underrequesting downstream i know that abersnaze still had reservations about this i think that this should not be using observeon my concern is this if abersnaze implemented the batching functionality then why wouldnt we use that the queue in observeon scheduling creates a layer of indirection that seems unnecessary remember this started out as a change to observeon to not ignore the immediate scheduler but people wanted this behavior exposed behind a proper name thanks for reminding me of the context of this work it seems like we have implementations for the same functionality i think abersnaze and i agree that the features of request batching and request valve type functionality could be composed however i think that using observeon for this functionality is not necessarily the best way to accomplish this i personally would be okay with either implementation i think observeon is a nice choice because of the request management but would prefer it more if there wasnt a queue but realistically i think the choice is fine also its interesting to note that users are gravitating more and more to taking direct control over the requester producer interactions for example this pr does something similar but exactly n could be modified to have optional and without a queue
3974,1,0,0,0,0,0,1,0,add terminal clarification to switchmap operators see
3977,1,0,0,0,0,1,1,0,use the correct throwable to set the cause for compositeexception the cause of is we use a wrong throwable its cause has been set to set the cause and initcause will throw an exception hence the cause chain is not created correctly in this pr it searches the root cause which doesnt have a cause and use it to call initcause
3981,1,0,0,0,0,0,1,0,document zip eagerness see and
3981,1,0,0,0,0,0,1,0,document zip eagerness see and
3986,1,0,0,0,0,0,1,0,add schedulersreset for better testing this adds a reset method to schedulers with the main benefit being improved testing support this does slightly tweak the internal api of schedulers to use a getinstance approach to allow lazy init this way we dont have to replace the singleton instance during reset and allow it to lazily re evaluate upon next usage otherwise if you change your scheduler hook youd always have to make sure you set it before you call schedulersreset will run perf tests overnight in case im not sure how much of a tradeoff moving to an internal getinstance approach costs if anythingcc zsxwing i think the failing test might be flaky it doesnt fail for me locally thanks i dont suppose this could be squeezed into the requires review of could it that test doesnt fail for me locally im not really sure what do do about it any ideas ive extended the timeout in some tests in pr once it appears it was enough ill merge that and this pr should work cool ill rebase after thats merged then non need to rebase but to rerun the travis job did it for you ah i pushed the rebase as you commented oh well ¯\_ ツ _ ¯ cool looks like the timeout tweaks worked code is ok so 👍 but resetting the schedulers is dangerous during application runtime and also bad code could invoke it in the middle of an application life cycle and really break applications if not used cautiouslywhy were adding more and more apis to break things and allow people use bad practices its two and theyre largely targeted at testing i dont think having a reset is bad practice and like most code only breaks things if you make poor decisions with it i could just as easily add a bad scheduling hook or buggy global error handlerhaving to otherwise use di to inject schedulers everywhere gets tedious fast and inadvertantly discourages people from actually using the conventional static apis with this it can be wrapped up in a nice test rule and enforces a clean state before and after tests using the plugins api also allows you to control the schedulers used across modules and rd party libraries as wellfor me its a missing and much needed api i dont think requiring di everywhere you use a scheduler just to test is a scalable approach considering how ubiquitous they are could you imagine injecting say timber everywhere you wanted to use itthats my speel for why i think this is useful i wonder why people with such testing needs dont roll their own global myschedulers class which lets them easily switch scheduler types and use that like observeon myschedulersforcomputation of course this means you have to remember to use the scheduler overloaded operators everywhere i also just copied that doc from the other reset i dont know that its as dangerous though it just forces a re init if its dangerous its because resetting rx plugins is dangerous since theyre not explicitly bound i wouldnt mind making the doc warning a little less severe p rd party libraries dont use your apps global class plus that case still requires you to hook in a delegate scheduler in tests early enough were adding a global scheduler of sorts for background work and still planning to have a reset on the schedulers libraries should expose the option to customize the scheduler they run on do you know a library that doesnt allow such customization most actually they just use the built in schedulerswhatever or androidschedulersmainthread i dont see how a wrapper with static methods solves this either you still need some mechanism of resetting the underlying scheduleris there any harm in allowing reset here to facilitate just having developers go through the standard api but heres a quick example off the top of my head otherwise i think the whole plugin system in rxjava x is getting cumbersome in x i did a much simpler and direct approach for overriding stufffor example this is how the schedulers get initialized is where they are returned what scheduler is returned from schedulers is easy via adding a function that can wrap or completely replace the scheduleri dont know if netflix wants at all but if so id be glad to rewrite the plugin system but heres a quick example off the top of my head where does it use rxjava schedulers forcefully found one reversegeocodeobservablejava should have provided a way to customize that scheduler anyway this one may sound crazy but what about marking reset as deprecated with explanation of better ways i think experimental with a doc explaining that the api will be revamped in the future would make more sense i dont have strong feelings for or against deprecated though and can switch to that if others want anything to help move this pr along deprecated will produce compile warning and will be visible in ide pretty sure most of the people who will use schedulersreset will copy paste from so or some blog post which will arrive as soon as we merge release this and wont even know that its experimental im not blocking pr if that matters fair point akarnokd any thoughts it seems like this has the requisite 👍s to move forward can add deprecated if you think its worthwhile do we really expect people to accidentally use this and be surpriseddeprecating the method sounds like it punishes those who want to use itid deprecate create and others long before this methodon mon jun pm zac sweers notifications githubcom wrote fair point akarnokd any thoughts it seems like this has the requisite 👍s to move forward can add deprecated if you think its worthwhile — you are receiving this because you are subscribed to this thread reply to this email directly view it on github or mute the thread when you put it that way i think i agree dont deprecate it do we really expect people to accidentally use this and be surprisedhave seen helped people asking how to solve problems after applying scheduler hooks for testing they didnt realize mostly how it can break things create is local evil it doesnt break global state alternative solution would be to move apis like create reset and so on to rxunsafe like java rust and so on its there but use it at your own risk
3996,1,0,0,0,0,0,1,0,fix reset shutting down everything other than the schedulers the reset shut down all the main schedulers and the helper pools causing the failure in hzsweers you were right with the need for the instance shutdown method minor nit rest of the code looks good 👍 nice catch sorry for the inadvertent bug and glad it was a relatively simple fix
4024,1,0,0,0,0,0,1,0,update dooneach observer javadoc fixes the documentation problem reported in nice improvement
4026,1,0,0,0,0,0,1,0,expand and explain cache in more detail this pr rephrases the cache documentation a bit and adds workaround for stopping and forgetting the cached valuesrelated 👍 this obviously isnt related to that but testreplaysubjectconcurrentsubscriptions failed in ci thanks will look into it before merging this could be a bug due a pattern they share nothing obvious so far the test passes for me locally when run times will investigate it further through
4034,1,0,0,0,0,0,1,0,distinctuntilchanged with direct value comparator alternative alternative implementation to lgtm thanks jake for the review
4036,1,0,0,0,0,0,1,0,added zip function with observable array as discussed in with akarnokd thanks almost forgot please also add a unit test that verifies this overload works with or a couple of sources you can add a unit test that for example loops from to generates an array with that many simple sources and checks if all source values actually zipped into the final value akarnokd sorry for the delay i just added tests for and multiple array sizes let me know if thats ok
4051,1,0,0,1,0,1,1,0,fix replaysubject anomaly around caughtup by removing that optimization adding the backpressure support to replaysubject exposed a race condition around the caughtup optimizationthe problem occurs when the source thread has caught up after drain returned true but at the same time a concurrent drain starts running due to a subscribe process finishing or requesting on top of the previous longmax_value this concurrent drain may think the replay hasnt started yet by finding rpnode null or seeing that the buffer has more elements that may get double emitted the current solution is to remove this optimization until we come up with a correct optimizationrelated
4053,1,0,0,1,0,0,1,0,convert schedulersupport annotation to accept a string value closes i meant to include in the pr description that i removed the single value it was unused and the javadoc didnt make it clear as to what the exact usage would be anyway no problem can be added later if necessary although singlescheduler is not planned to be a default for any operators right now
4063,1,0,0,0,0,0,1,0,scan & reduce give javadoc about unsharing the initialvalue replacement for this to not get in conflict with other prs targeting observable
4069,1,0,0,1,0,1,1,1,remove second type parameter from subject and flowprocessor closes
4070,1,0,0,0,0,1,1,1,merge serialdisposable and multipleassignmentdisposable closes although doesnt address the name of the class excellent although doesnt address the name of the classno problem
4102,1,0,0,1,0,1,1,1,expose isdisposed method on disposable this is a fairly dumb addition theres lots of room for follow up improvement in the utilization of base helper classes and even removing some now duplicated state managementcloses there are a bunch of compilation errors probably missing imports i have to edit those by hand in each file so thediffs dont go wildon fri jun at am david karnok notifications githubcomwrote there are a bunch of compilation errors — you are receiving this because you authored the thread reply to this email directly view it on github or mute the thread thanks
4139,1,0,0,1,0,1,1,1,fix flaky tests this pr should fix some test timing out otherwise sensitive to thread hiccups
4139,1,0,0,1,0,1,1,1,fix flaky tests this pr should fix some test timing out otherwise sensitive to thread hiccups
4139,1,0,0,1,0,1,1,1,fix flaky tests this pr should fix some test timing out otherwise sensitive to thread hiccups
4140,1,0,0,0,0,1,1,1,change completablesubscribe onerror oncomplete to oncomplete onerror closes closes actually i can deprecate old one and add new one as overload it will have less impact on user code because only calls like subscribe actionsempty actionsempty will be ambiguous to the compilerthoughts dynamic languages have trouble with the two methods lets only have method
4140,1,0,0,0,0,1,1,1,change completablesubscribe onerror oncomplete to oncomplete onerror closes closes actually i can deprecate old one and add new one as overload it will have less impact on user code because only calls like subscribe actionsempty actionsempty will be ambiguous to the compilerthoughts dynamic languages have trouble with the two methods lets only have method
4154,1,0,0,0,0,1,1,0,ability to create custom schedulers with behavior based on composing operators based on allows the use of operators for controlling the timing around when actions scheduled on workers are actually done this makes it possible to layer additional behavior on an existing scheduler the main parameter is a function that flattens an observable into just one completable there must be a chain of operators connecting the returned value to the source observable otherwise any work scheduled on the scheduler will not be executedwhen schedulercreateworker is invoked a completable is onnextd to the combinator to be flattened if the completable is not immediately subscribed to an calls to workerschedule are buffered once the completable is subscribed to actions are then scheduled on the actual scheduler when the worker is unsubscribed the completable emits an oncomplete and triggers any behavior in the flattening operator the observable and all completable s give to the flattening function never onerrorslowing down the rate to no more than than a second java scheduler slowsched new schedulewhen workers { use concatenate to make each worker happen one at a time return completableconcat workersmap worker { delay the starting of the next worker by second return workerdelay timeunitseconds } } schedulerscomputation limit the amount concurrency two at a time without creating a new fix size thread pool java scheduler limitsched new schedulewhen workers { use merge max concurrent to two at a time return completablemerge workers } schedulerscomputation this test changes its timing pattern when run on one of the merging customization of this scheduler java testpublic void fasttasks { final scheduler sched new schedulewhen new func completable { override public completable call observable workers { return completablemerge workers } } schedulerscomputation observablerange flatmap new func { override public observable call final integer v { return observableinterval timeunitmilliseconds sched take map new func { override public string call long u { return v refresh u } } } } timeinterval toblocking subscribe new action { override public void call timeinterval v { systemoutprintln v } } } what i get is that for the first seconds i get refresh x and refresh x in ms intervals but after thet all the refresh x and refresh x gets printed instantly timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh timeinterval intervalinmilliseconds value refresh if i understand the purpose of this scheduler especially with the merge workers case you want to limit the number of concurrently running tasks however the implementation blocks out further workers from executing anything until a previous worker is released for example given a service that accepts connections per client if i have to periodically execute or more tasks against this service via the interval above only the first two would execute periodically in addition the other would slowly pile up tasks in the internal queue and if the associated sequence uses timeout this will make it timeouti think the solution is to use a thread pool instead it limits the number of concurrent tasks while allowing all workers to make progressmy second reservation is that since the schedulewhen is a self contained class unlike operators that need a method in observable this can live in any external library just like androidschedulers this isnt intended for long running observables your example is a pathological case rather than scheduling on the outer timer if flatmap and schedule on the inner observables it would not block and all three would be able to runthere are many was to misuse this but if used in a controlled setting of a service library it can be use to protect service from bursts of traffic the main point is to be able to reuse an existing scheduler with some additional behavior rather than having to create new thread pools to enforce rate limits to address your concern ive changed the api from ob comp to ob comp this is a more direct mapping of scheduler of workers of actions that give the user complete control how and when the actions in the example above the actions from all workers can be merged into one stream of actions and then the merge max n concurrent could be applied to the actions to better simulate running on a n threads akarnokd i think ive addressed all the concerns regrading this pr what can i do help get this experiment merged oh sorry was busy with something elseokay lets continue with the experiment cc zsxwing artem zinnatullin does 👍 mean the pr is merged now should we wait for a review from zsxwing and or artem zinnatullin lets wait for at least one of them 👍 for this experiment api just one comment about synchronized actionqueue very interesting api abersnaze few comments and im 👍 with it i dont know how i would draw the marble diagram for this one abersnaze if all feedback is resolved feel free to merge this pr and if you want post any short description of this addition beyond the ref to this pr thanks for the feed back as far as im concerned the feedback cycle hadnt really finished on this im hoping that api changes etc are not out of scope if i raise an issue my comment about the use of subscribe in the constructor was not addressed should be unsafesubscribe i think davidmoten if you have further concerns dont hesitate to open an issue or post a pr the file needs some javadoc tidying up anyway
4225,1,0,0,0,0,0,1,0,publishsubject fail fast when backpressured this pr modifies the publishsubject to fail fast if the child subscriber cant keep up therefore instead of some other operator failing somewhere downstream the missingbackpressureexception now points to the publishsubject instead in addition there were complaints in that cross unsubscription doesnt stop another subscriber from receiving events if it comes after the unsubscribe call in the dispatch loop since publishsubject now tracks request which is the main extra overhead it is trivial to add the necessary eager check for the unsubscribed statebenchmark comparison i windows x java u expected this adds some overhead although most noticeably for the mid range only short lived publishing is now slightly faster eveninterestingly many benchmarks behave oddly in these s range we could be hitting some jit threshold while in other benchmarks the warmup iteration numbers keep increasing as jit does its work but here it starts out quite nicely then drops and stays that way im on windows so jmh perfasm doesnt workif this direction is accepted ill update behaviorsubject timer and interval do do the same tracking
4226,1,0,0,0,0,1,1,1,singleflatmapcompletable addresses happy to receive feedback on the implementation also should i take the documentation from flatmapobservable and adjust it also should i take the documentation from flatmapobservable and adjust ityes updated the documentation i hope the wording is okay now also im pointing to which does not exist yet but davidmgross already tracked it at i hope thats okaythanks for the completableflatmapsingletocompletable i knew something was missing i also created two more tests that cover some of the previously missing behaviour would it be possible to get this one into if zsxwing or anyone from netflix approves it in time
4251,1,0,0,0,0,0,1,0,tomap prevent multiple terminal events support backpressure as per discussion in if an operator maps an onnext emission to an onerror emission downstream then it needs be defensive about an oncompleted being sent from upstream even if upstream has been unsubscribedincludes three unit tests that failed on the original code the fix also has the side effect of enabling gc of map when the factory fails onerror was called on the child not this so map was not set to null i thought it supported backpressure could you rewrite it by using deferredscalarsubscription unrelated test failure rxschedulerscomputationschedulertests testhandlederrorisnotdeliveredtothreadhandler failed javalangassertionerror handler should not have received anything expected but was at orgjunitassertfail assertjava at orgjunitassertfailnotequals assertjava at orgjunitassertassertequals assertjava at rxschedulersschedulerteststesthandlederrorisnotdeliveredtothreadhandler schedulertestsjava at rxschedulerscomputationschedulerteststesthandlederrorisnotdeliveredtothreadhandler computationschedulertestsjava i thought it supported backpressure could you rewrite it by using deferredscalarsubscriptionsure what i might do is fix multiple terminal emissions in onsubscribecollect first and make necessary done changes to deferredscalarsubscriber in that pr ill follow that with the backpressure fix for operatortomap akarnokd in terms of releasing a value so can be gcd i thought to modify deferredscalarsubscriber in this method so that the field thisvalue is set to null just before the call to aonnext javaprotected final void complete r value { subscriber a actual for { int s stateget if s no_request_has_value s has_request_has_value aisunsubscribed { return } if s has_request_no_value { r v value value null aonnext v if aisunsubscribed { aoncompleted } statelazyset has_request_has_value return } thisvalue value if statecompareandset no_request_no_value no_request_has_value { return } } } is that ok dont review latest change just committed so could work on it from another location im not sure if its worth it many operators dont really do that because it is also likely the whole chain gets forgotten and gc claims all of them on its own if you want to make sure there is no leak use onterminatedetach could you rebase the whole thing somehow you picked up changes to master and they show up in the diff rebased rewrote to use deferredscalarsubscribersafe use singleton of defaultmapfactory moved to onsubscribe to save allocations added backpressure test good idea ive updated the pr
4261,1,0,0,0,0,0,1,0,concatdelayerror multiple arguments this pr adds multiple arguments to concatdelayerror operatorrelated to cc artem zinnatullin stevegury zsxwing
4262,1,0,0,0,0,0,1,0,dooneach reduce allocations report to rxjavahooks as discussed in call rxjavahooksonerror for secondary errors reduced allocations actionsubscriber actionobserver operator onsubscribe added unit tests actionsubscriber usage and removed empty test ta
4288,1,0,0,1,1,1,1,1,move exceptions to public area exceptionhelper related the exceptionspropagate and exceptionsthrowiffatal are too useful to be hidden in an internal package so this pr moves them into the public ioreactivexexceptions package the terminal atomics related to throwable containers lives in the exceptionhelper enum lgtm
4297,1,0,1,1,0,1,1,1,rename single base interface types for consistency addresses lgtm jakewharton if you want me to and you havent started yet id continue on that list and rename the other classes interfaces as well sure go for iton sun aug at pm niklas baudy notifications githubcomwrote jakewharton if you want me too and you havent started yet id continue on that list and rename the other classes interfaces as well — you are receiving this because you were mentioned reply to this email directly view it on github or mute the thread
4299,1,0,0,1,0,1,1,1,rename flowable base interface types for consistency addresses lgtm
4300,1,0,0,1,1,1,1,1,rename observable base interface types for consistency addresses there are a large amount of compilation errors rebased against x and re did the last changes looks good this time
4302,1,0,0,1,0,1,1,1,rename completable base interface types for consistency addresses
4309,1,0,0,0,0,1,1,0,remove unused exceptions in public api as wanted in cc jakewharton if the test changes are acceptable for your setup
4317,1,0,1,1,1,1,1,1,rename create to unsafecreate add safe create methods this is a proposal to solve but for x and closes built around one goal make the create methods actually usable by developerscurrently the advice given to most developers using x is avoid create unless you are absolutely sure you understand backpressure and cancellation and even then avoid it if possible this method is a trap that most new developers fall into _the method is named create after all so it must be how i create these things_ i want to make that statement not only correct but advisable at least when the still convenient from methods are not suitable such as when wrapping callback based apis because observable single and completable are backpressure free this amounts to just suppressing downstream notifications when disposed this doesnt seem too controversialthe most controversial part is that i have renamed flowablefromasync to flowablecreate thus making it the canonical way for users to create flowable s directly im much less opinionated on this change but it felt wrong to have an flowableunsafecreate with no associated create and fromasync is the safest version we have i think its also important to point out i replaced consumer with flowablesource for parity with other safe create method parameter types the unsafe variant still takes a raw publisher however
4317,1,0,1,1,1,1,1,1,rename create to unsafecreate add safe create methods this is a proposal to solve but for x and closes built around one goal make the create methods actually usable by developerscurrently the advice given to most developers using x is avoid create unless you are absolutely sure you understand backpressure and cancellation and even then avoid it if possible this method is a trap that most new developers fall into _the method is named create after all so it must be how i create these things_ i want to make that statement not only correct but advisable at least when the still convenient from methods are not suitable such as when wrapping callback based apis because observable single and completable are backpressure free this amounts to just suppressing downstream notifications when disposed this doesnt seem too controversialthe most controversial part is that i have renamed flowablefromasync to flowablecreate thus making it the canonical way for users to create flowable s directly im much less opinionated on this change but it felt wrong to have an flowableunsafecreate with no associated create and fromasync is the safest version we have i think its also important to point out i replaced consumer with flowablesource for parity with other safe create method parameter types the unsafe variant still takes a raw publisher however
4330,1,0,0,0,0,1,1,0,added observableconcat iterable see i also adjusted the test as it was testing the wrong thing before
4337,1,0,0,0,0,0,1,0,move disposableobserver to public area add some javadocs move disposableobserver to ioreactivexobservers some documentationrelated having these in the public api make it seem like asyncobserver becomes obsolete in the case where its not managing any additional resources should we rename it to resourceobserver or something and have it always manage resources sure will you do it yep
4370,1,0,0,1,0,1,1,1,remove try optional introduce notification this pr removes the try and optional classes and re introduces notification there are several ways to implement it this pr uses the abstract class private subclasses approach that saves on instance sizerelated discussion this pr uses the abstract class private subclasses approach that saves on instance sizethis seems like it would prevent a lot of inlining of the simple isers and geters because the callsites become polymorphic instead of monomorphicwhen i check the object layout having two fields in a root object doesnt increase the size because of object padding $ cat notificationjavafinal class notification { private static final object completed new object private final t value private final throwable error notification t value throwable error { thisvalue value thiserror error }}$ javac notificationjava$ java cp users jw downloads jol cli fulljar orgopenjdkjolmain internals notificationobjc class javalaunchhelper is implemented in both library java javavirtualmachines jdk _ jdk contents home bin java and library java javavirtualmachines jdk _ jdk contents home jre lib libinstrumentdylib one of the two will be used which one is undefined warning unable to attach serviceability agent you can try again with escalated privileges two options a use djoltrywithsudotrue to try with sudo b echo sudo tee proc sys kernel yama ptrace_scope running bit hotspot vm using compressed oop with bit shift using compressed klass with bit shift warning compressed references base shifts are guessed by the experiment warning therefore computed addresses are just guesses and are not reliable warning make sure to attach serviceability agent to get the reliable addresses objects are bytes aligned field sizes by type bytes array element sizes bytes vm fails to invoke the default constructor falling back to class only introspectionnotification object internals offset size type description value object header n a object notificationvalue n a throwable notificationerror n a loss due to the next object alignment instance size bytesspace losses bytes internal bytes external bytes total oops i wrote my comparison wrong and left it out of the comment youre right the individual classes are only bytes header field that said vs isnt that big of a deal to gain guaranteed monomorphism there are other ways of doing it ie single object field private wrapper for throwables bytes per onnext and bytes per onerror true ill leave it up to you though or getting at least bimorphic by having value null represent oncomplete updated now we have the smaller size but an instanceof check for every isonnext and getvalue calls looks good
4371,1,0,1,1,1,1,1,1,move blocking operators into the base classes this pr removes the blockingflowable and blockingobservable classes and moves the blocking operators into the respective reactive classes and names pre with blocking in addition many of the mentions of flowable has been replaced with observable in observable related lgtm
4421,1,0,0,0,0,0,1,0,fixes cleanups renames changes fix spelling mistakes more consistent parameter naming scheme based on but incomplete rc fix bugs due to wrong variable naming compact logic expressions fix completabledoafterterminate not called the right time onerrorreturnvalue renamed to onerrorreturnitem davidmgross once this pr has been merged it would be great you submitted one that has todo markers on those lines that need attention the naming scheme you suggested doesnt come intuitively to me so i may skip many of them without the markers
4422,1,0,0,0,0,1,1,0,add subscribewith to get back the subscriber observer fluently this pr adds the subscribewith methods to the base reactive types to mainly help with the x to x changeover as x subscribe subscriber return void instead of the resource cancellation unsubscription type disposable see the javadocs and the unit test for example userelated
4425,1,0,0,0,0,1,1,1,remove completable prefix from nested interfaces move its subscription to top level this is only the completable part of it does not make completablesubscriber an abstract class nor create singleoperator compiler error looks okay what about the deprecated markers oh sure ill add them in real quick i wasnt sure on your stance on them but i think itll make migration easier yes having deprecated markers is more forgiveable than lacking the entire type i dont know how extensively completable is in use by other libraries right now beyond rxjavareactivestreams reactors converter retrofit updated compilation issue resolved i know still waiting for a second approval okay lets have this one can complain anytime later
4436,1,0,0,0,0,0,1,0,maybe for lazy optional in i hit on the problem of needing a lazy object that could either be zero or one value in that issue the idea of switching the return value of reduce r func from observable to single because that operator can only ever produce an observable that emits exactly one value the problem was that reduce func could not be changed to single because the source observable could be empty and therefore not produce one and only one valueto solve this problem i mentioned we could create a lazy type that represents either or no value could fill the gap between completable and single this pr is for the introduction of the maybe type you referenced java types in your code my problem with adding another base type is the increased mainte ce cost currently we have types in the major versions and it is likely adding a new operator overload or making a fix has to be done for all of them im one man armying rxjava for a considerable time now but i have my limits therefore my suggestion is that you have this maybe as a separate library that depends on rxjava but rxjava doesnt depend on it since rxjava offers fluent conversion method s it should be only a small inconvenience to convert to maybe javaflowable source flowablerange maybe mb sourceto maybereduceflowable a b a b mbfilter v false subscribe systemout println throwable printstacktrace systemoutprintln done mbtoflowable subscribe systemout println throwable printstacktrace systemoutprintln done as i mentioned my plans were to greatly increase the coupling between observable & flowable to single & maybe by having the various operators that return exactly or sometimes value to these two types type exactly for this purpose i suggest you try that first im not strictly opposed because my plans were to greatly increase the coupling between observable & flowable to single & maybe by having the various operators that return exactly or sometimes value to these two typesappeals to me but i dont have a really strong feeling without using it more okay then lets merge this and see how it works out please dont post prs targeting maybe im working on cleaning it up a bit plus a few other classes if i find something wrong the code copied from an older commit of the other types
4442,1,0,0,1,0,1,1,1,cleanup javadoc completablefromemitter add javadoc to asyncemitterbackpressuremode deprecate observablefromasync add observablefromemitter instead add completablefromemitter add missing placeholder since tags fix some generics error rxjavahooks add race helper to testutil fix javadoc warnings
4442,1,0,0,1,0,1,1,1,cleanup javadoc completablefromemitter add javadoc to asyncemitterbackpressuremode deprecate observablefromasync add observablefromemitter instead add completablefromemitter add missing placeholder since tags fix some generics error rxjavahooks add race helper to testutil fix javadoc warnings
4442,1,0,0,1,0,1,1,1,cleanup javadoc completablefromemitter add javadoc to asyncemitterbackpressuremode deprecate observablefromasync add observablefromemitter instead add completablefromemitter add missing placeholder since tags fix some generics error rxjavahooks add race helper to testutil fix javadoc warnings
4458,1,0,0,0,0,0,1,0,rename observable and single dooncancel to doondispose completable already used doondispose however i renamed the arguments to match observable and single the diff for observable doesnt show but the offline comparison only lists lines changes did you run some whitespace cleanup akarnokd whoops youre right sorry auto formatter seems to have changed some whitespaces ill revert that this update is missing in release notes on github please remember to mention such changes in the future
4460,1,0,0,0,0,1,1,1,completable add dooneach first part of is it okay that i reused notification like thatalso are there any java generics missing it would be nice if this project was set up to target java sdk as my default seems to be java and i dont get any errors shown in the ide okay but you have generics problem alright its now
4461,1,0,0,0,0,0,1,0,single add dooneach really not that happy with onnotificationcall notification createonnext t do you guys have any other way of doing this theres no way of creating a notification that has the oncompleted plus a value a new one could be introduced there though also the dooneachsuccess test feels clunkyalso why does single when using the do methods does the job by using an observable and later converting it back to a single again is it due to the way single was implemented in x with completable there is no converting of back and forth neededjavadoc will follow once we sorted out the few nits here fails although im not quite sure what the purpose of that test is also it seems a bit off to me can you give some insights there looks like removing the toobservabletosingle no longer wraps the subscriber into a safesubscriber and the test just crashes with a different exception no exception is being thrown at all can you single step the test in the orginal dooneach it has throwiffatal an throworreport you missed btw
4466,1,0,0,0,0,0,1,0,deprecate notificationcreateoncompleted it might just as well shine some light into which method should be used and explain why there are
4488,1,0,0,0,0,0,1,0,add new methods to maybe observable and single from this pr adds just the new methods from to allow a much cleaner change of return types later on updated with corrections
4503,1,0,0,0,0,0,1,0,add system properties to adjust thread priorities of schedulers this pr adds the ability to specify the default thread priorities of computation io newthread and single schedulers via system properties ive added the property names to the schedulers javadocrelated thanks
4504,1,0,0,0,0,0,1,0,add disposable observer for maybe completable & single also any reason the dispoable is called s is it still from the subscription time seems unrelated ioreactivexinternaloperatorsobservableobservablerefcounttest testrepeat failed javalangassertionerror error s present javalangillegalstateexception onsubscribe not called in proper order latch values errors completions at ioreactivexobserverstestobserverfail testobserverjava at ioreactivexobserverstestobserverassertnoerrors testobserverjava at ioreactivexinternaloperatorsobservableobservablerefcounttesttestrepeat observablerefcounttestjava caused by ioreactivexexceptionscompositeexception at ioreactivexobserverstestobserverfail testobserverjava more caused by ioreactivexexceptionscompositeexception$compositeexceptioncausalchain chain of causes for compositeexception in order received caused by javalangillegalstateexception onsubscribe not called in proper order yep ill fix that next started to become annoying to me too
4513,1,0,0,0,0,1,1,1,fix switchmap bad cancellation both switchmap implementations didnt properly cancel the current inner consumer but instead cancelled the outer connection only reported in
4516,1,0,0,0,0,1,1,1,fix singleusing add unit tests and coverage ive forgotten to create a branch so the first part of todays coverage work landed in x direct removed unused methods from various classes compacted spscarrayqueue added null checks to spsclinkedarrayqueueoffer and mpsclinkedqueueoffer resourceobserver not calling onstart added direct notificationlite emission methods to appendonlylinkedarraylist updated serializedobserver and serializedsubscriber to use it directly instead of the former indirection testobserverisdisposed now reports true if terminal events were received resourcesubscriber to use subscriptionhelper s deferred subscription requesting management added unit tests to cover disposablexobserver s serializedobserver and serializedsubscriber now have proper unit tests eachthis current pr fixes singleusing not properly managing the resource and adds unit tests to verify the behavior along with a few extra coverage improvements
4518,1,0,0,0,0,1,1,0,add missing resource observer for maybe completable & single and adjust some javadoc it might be worth considering removing the protected cancel methods as they are duplicates of dispose for resourcesubscriber i dont know because it works with subscriptioncancel but also is a disposable so dispose is there as well so should i remove the cancel method on all resource observer jakewharton your opinion on the removal im supportive of removing cancel i much prefer when theres only one way to do something
4522,1,0,0,0,0,1,1,1,observable flowable completable singledelay should always call onerror on the provided scheduler great job applying the changes to all of the base types
4525,1,0,0,0,0,0,1,0,fix generics t in zip & combinelatest test for combinelatest fill follow
4580,1,0,0,0,0,0,1,0,rename asyncemitter to emitter as per discussion in renaming asyncemitter to emitter via deprecationthere is a catch though completableemitter is correctly named now and depends on asyncemitter via the method java void setcancellation asyncemittercancellable c when can we break the api of that class thanks for review akarnokd i take it we have to wait for to break the api of experimental completableemitter deleting experimental apis has to wait one patch version so will have both and can remove the asyncemitter ok ill patch again once is outon thu sep david karnok notifications githubcom wrote deleting experimental apis has to wait one patch version so will have both and can remove the asyncemitter — you are receiving this because you authored the thread reply to this email directly view it on github or mute the thread cc jakewharton artem zinnatullin make the cancelable interfaces extend each other as wellon thu sep pm dave moten notifications githubcom wrote _ davidmoten_ commented on this pull request in src main java rx asyncemitterjava experimental deprecated public interface asyncemitter extends observer { cannot extend emitter because of two versions of cancellable would break existing asyncemitter use — you are receiving this because you were mentioned reply to this email directly view it on github or mute the thread make the cancelable interfaces extend each other as wellgood idea um i dont think its worth it juggling with inheritance of these interfaces straight after next release im just going to delete the deprecated stuff ive added a deprecated annotation to completableemitter let me know if you guys still want the interface inheritance business forgot to move cancellable to rxfunctions thats done now thanks for working this out
4585,1,0,0,1,0,1,1,0,evaluate schedule initialization via callable this implements the solution proposed in to initialize the schedulers via a callable rather than directly via a value akarnokd correct me if im wrong but in order to avoid the evaluation of the default scheduler instance when it is being overridden i still need to change the oninit singleionewcomputation handler signatures to be function scheduler as per static volatile function scheduler oninitsinglehandler otherwise the invocation of initsinglescheduler will cause the evaluation of the default value to pass it as a parameter to the overriding transforming function oninitsinglehandler yes you still need callable as the indirection but the inner class will be evaluated only if call is actually invoked ive added the remaining lazy initializationive also fairly aggressively enforced non null in the associated functions for example javapublic static scheduler initioscheduler callable defaultscheduler { objecthelperrequirenonnull defaultscheduler scheduler callable cant be null callable scheduler f oninitiohandler if f null { return callrequirenonnull defaultscheduler } return applyrequirenonnull f defaultscheduler } however to me this seems slightly out of place over the top is that enforcement necessary or should the resultant null scheduler be left unasserted and left to the eventual nullpointerexception when the scheduler is used either way im happy to keep or remove that based upon review feedback aggressive input validation is never over the top if you defer checkingthen the stacktrace tells you nothing about what actually caused the brokenstateon sun sep am peter tackage notifications githubcomwrote ive added the remaining lazy initialization ive also fairly aggressively enforced non null in the associated functions for example public static scheduler initioscheduler callable defaultscheduler { objecthelperrequirenonnull defaultscheduler scheduler callable cant be null callable scheduler f oninitiohandler if f null { return callrequirenonnull defaultscheduler } return applyrequirenonnull f defaultscheduler } however to me this seems slightly out of place over the top is that enforcement necessary or should the resultant null scheduler be left unasserted and left to the eventual nullpointerexception when the scheduler is used either way im happy to keep or remove that based upon review feedback — you are receiving this because you commented reply to this email directly view it on github or mute the thread akarnokd all done as far as i am concerned do i need to anything else for this to be merged i was waiting for you to settle with the implementation thanks for the contribution
4586,1,0,0,0,0,1,1,1,add error assertion with predicate to testsubscriber and testobserver added support for error assertions with to testsubscriber requested in to support custom error evaluation removes the need to implement equals and hashcode in exceptions could you do it for testobserver as well sure i will update the pr
4629,1,0,0,0,0,1,1,1,add completablefromrunnable addresses theres maybefromrunnable but completable is missing this method thanks
4636,1,1,0,1,1,1,1,1,update mockito to rc equivalent of but now for the x branch the test ioreactivexmaybemaybetest onterminatedetach seems to be failing claiming there is a memory leak i sadly have no experience with this test to fix it that test is a bit flaky maybe the new mockito increased the base memory usage ill fix that test and rerun this one thanks a lot and enjoy fyi mockito has been released which is equivalent to rc once again thanks a lot for using mockito
4641,0,0,0,0,0,0,1,0,safesubscriber not to call rxjavahooks before delivering the original error before the introduction of rxjavahooks the safesubscriber_onerror called the original error handler with the exception it received which was by default an empty handler the default rxjavahooksonerror behavior however is to signal errors to the uncaught exception handler of the caller thread which leads to unnecessary logging or app crashes even though the error itself is to be handled properlythis pr restores the safesubscriber_onerror to skip the rxjavahooks and call the original handler directy so old tracking code should still get all safe error while newer hooking doesnt get calledrelated cc dlew lgtm thanks for doing this
4645,1,0,0,1,0,1,1,0,signal npe observableamb flowableamb this pr addresses
4647,1,0,0,1,0,1,1,1,merge ambarray and ambiterable into amb for single maybe and completable types this pr addresses merge singleambarray and singleambiterable operators into singleamb merge maybeambarray and maybeambiterable operators into maybeamb merge completableambarray and completableambiterable operators into completableamb
4651,1,0,0,1,0,1,1,0,switch maybe and single to use their transformers in compose whoops forgot to update the tests will update in a sec intellij user i presume indeed does i presume 😉 eclipse do something to protect against this eclipse has an error view which doesnt obscure the project structure plus when one shows the breadcrumbs they get error icons indicating theres still something wrong also the project tree gets error icons so it is much harder to miss these kinds of errors interesting ill have to check that out
4654,1,0,0,0,0,0,1,0,upcast concurrenthashmap to map to avoid compatibility issue resovles see http stackoverflowcom a
4681,1,0,0,0,0,1,1,0,fix flowable single elementat and elementatorerror operators on empty sources this will elementatorerror on an empty source just leaves the new single hanging without signalling onerror elementat on an empty source just leaves the maybe hanging without signalling oncomplete i also noticed that elementat with a default value on an empty source did not work either you may have to check the build and restart it a few times if it fails with jacocotestreport
4686,1,0,0,0,0,1,1,0,fix flatmapx over cancellation in case of an inner error a non delayed error set the cancellation flag and thus any subsequent drain would just quit instead of delivering the error and while im at it ill try to figure out a way to not get killed by oomkiller reported in
4687,1,0,0,0,0,1,1,1,add observablerangelong & flowablerangelong will adds observablerangelong adds flowablerangelong both implementations are copied same for the unit testswhat should we do about the range overflow check we could use bigdecimal to check that
4690,1,0,0,0,0,1,1,1,basetestconsumer add assertvalueat index predicate adds assertvalueat index predicate to basetestconsumer
4710,1,0,0,1,0,1,1,0,remove checked exceptions from transformer interfaces these functions are for transforming the stream shape not doing work any operation that would throw a checked exception should happen inside the stream not when shaping itcloses
4716,1,0,0,0,0,1,1,1,fix subscribe action action to report isunsubscribed the lambda version didnt report isunsubscribed as before because of the removal of the safesubscriber wrapping this pr makes sure it reports consistently againrepored in note that there is no unsafesubscribe singlesubscriber so a regular subscribe singlesubscriber by default wont report isunsubscribed true unless the implementation of onsuccess and onerror controlled by the user doesnt call unsubscribe on itself
4729,1,0,0,0,0,1,1,0,merge flowableemitterbackpressuremode into backpressurestrategy this is the implementation of i have implemented the changes from the code commentsill keep in mind to rely on code coverage in the futureshould i reply to the review comments directly no need in this case
4747,1,0,0,1,0,1,1,1,distinctuntilchanged to store the selected key instead of the value fix distinctuntilchanged to store the selected key instead of the input valuereported in
4751,1,1,0,1,1,1,1,1,fix flowableconcatmapeager hang due to bad request management flowableconcatmapeager s drain loop when encountering a finished inner jumped back to the beginning of the loop but disregarded the potentially changed request amount and just stopped emitting the fix is to use the typical request management approach of reading the current request at the beginning of the loop and then committing the emission amount before trying to leave the looprelated in addition testhelperasserterror has been changed to attach the whole unexpected exception to the assertionerror
4757,1,0,0,0,0,0,1,0,add cache to single uses the same test as the observable one sorry im late to the party here this seems to be rxjava x only is this going to reach x its in uupps right thanks
4767,1,0,0,0,0,1,1,0,rename backpressurestrategynone to missing as discussed in
4783,1,0,0,0,0,1,1,1,fix observablerepeatwhen & retrywhen not disposing the inner the observer that is subscribing to the observable returned by the handler function was not properly linked to the disposing of the end observer this pr fixes it by making that observer do async disposable management and make sure the end observer receives a disposable list with both the main and the handler disposable sthe flowable versions worked properly but added unit tests to them regardlessreported in
4810,1,0,0,0,0,0,1,0,subtle change in completables documentation for retrywhen small change as discussed in
4828,1,0,0,0,0,0,1,0,changing inner classes to package private to in
4830,1,0,0,0,0,1,1,1,completabledoafterterminate to run after onerror as well doafterterminate was intended to call the callback after either oncompleted or onerror but somehow missed that behavior in xrelated
4858,1,0,0,0,0,1,1,0,add maybeflatmapsingleelement returning maybe this pr adds the maybeflatmapsingleelement operator that returns a maybe and completes if the source completes unlike flatmapsingle where the returned single signals nosuchelementexception related
4873,1,0,0,0,0,1,1,1,testobserver shouldnt clear the upstream disposable on terminated testobserver replaced the upstreams disposable with the disposed sentinel when it got a terminal event unlike testsubscriber and there seems to be a need for triggering dispose in some upstream even after that this pr changes this behavior and also updates unit tests that expect isdisposed true without actually calling dispose related
4881,0,0,0,1,0,1,1,0,add checkreturnvalue annotation first draft on thisso far i have only annotated subscribewith and test methodsi checked this against error prone and their check is able of picking up the rxjava annotationhow do you feel if i extend basetypeannotations to test for checkreturnvalue toorelated would you manually ignore methods like disposable subscribe vanniktech see artem zinnatullin weird somehow findbugs didnt pick it up though could be a configuration error on my sideid argue that not annotating diposable subscribe is fine however i feel like disposable subscribe consumer and the others should be annotated i personally almost never use subscribewith and prefer the variations with lambdaswere on the same point that static factory methods and operators such as flatmap first last etc should be annotated right if so id apply those and then we can see which might need an annotation too akarnokd added the checkreturnvalue annotation to all public api methods of flowable maybe single observable and completable except for private methods void methods and the disposable subscribe method is that okay now yes cc jakewharton
4884,1,0,0,0,0,1,1,1,enable testscheduler with osecond periodic scheduling the default periodic scheduling code accessed the current worker time as milliseconds which prevents running microsecond and osecond scale unit tests with testscheduler as its internal osecond resolution time is always converted losing precisionthis pr introduces the internal scheduleperiodichelper class moves the default scheduling code into a static method and defines a now osupplier interface that is now implemented by testschedulerworker to return the current o time the default workerscheduleperiodically delegates to this static method and given a null no osupplier the workernow is converted to oseconds as usualrelated
4911,1,0,0,0,0,1,1,1,fix & update observablerepeatwhen and retrywhen again this pr fixes the observablerepeatwhen not completing properly if the handler completes in addition the observableredo has been split to observableretrywhen and observablerepeatwhen just like their flowable counterpart and are now they use a less convoluted algorithmrelated i dont know why the travis ci push still shows up
4921,1,0,0,0,0,0,1,0,fix testsubscriber observer message texts fix the wrong messages in testsubscriber and testobserver related
4924,1,0,0,0,0,0,1,0,change completable to completablesource changing completable to completablesource also found one other wrong spot that i within this pr
4927,1,0,0,0,0,1,1,1,fix timer ise due to bad resource mgmt both observabletimer and flowabletimer could report illegalstateexception because if the delayed task completed before the tasks disposable was set the setonce found a non null non terminal reference already setrelated
4932,1,0,0,0,0,1,1,0,add safeguards to generate flowablegenerate and observablegenerate lacked the safeguards that were present in x this adds those and adds extra state cleanuprelated
4943,1,0,0,0,0,1,1,0,fix publish function not replenishing its queue i was working on converting the monte carlo pi benchmark to rxjava and it turned out i forgot to replenish the internal queue of publish function in case the upstream was not sync fuseablethis pr fixes the replenishment problem for non fused and async fused sources by requesting after consumptionin addition if an inner subscriber cancelled while it was at request the other inner subscribers might not have resumed drainingive also two unit tests with wrong timeout unit of measure that randomly failed the tests on a slow machine or travis
4945,1,0,0,0,1,1,1,1,fix timeout with fallback not cancelling the main source this pr fixes the lack of dispose cancel call towards the upstream in the timed fallback timeout operator versionin addition the selector version received similar unit tests to ensure they work properly they did related
4955,1,0,0,0,0,1,1,1,add sample overload that can emit the very last buffered item the sample operator in x has been changed to always emit the very last buffered item before completion for discussion pr change has been forgotten in x because x sample was implemented several months earlier but unlike x i dont want to break existing use cases hence the introduction of overloads for each base type that lets one define the tail behaviornote that the associated marble diagrams are inconsistent with the operators implemented we need a new diagram where the timed sample also emits the last value one new diagram where the sampler sample doesnt emit the last value image default sampler sample should use this and the emitlast true version can use the current diagram i dont have a mac thus cant run omnigraffle related
4957,1,0,0,0,0,1,1,0,fix lambdaobserver calling dispose when terminating this pr changes the lambdaobserver to not dispose the upstream when it receives a terminal event the lambdasubscriber has been previoulsy updated but apparently not syncedreported in this pr fixes unit test methods of flowableignoreelements as they were not actually testing the operator discovered when the observableignoreelements initially failed after the patch to lambdaobserver
4962,1,0,0,0,0,1,1,0,fix singletakeuntil other triggering twice this pr fixes the double termination of singletakeuntil publisher when the other fires an item and then completes while ignoring the cancellation in between trying to signal a cancellationexception again which is routed to the rxjavapluginsonerror and crashing on androidin addition the maybetakeuntil received a unit test verifying this doesnt also happen to itrelated
4972,1,0,0,0,0,1,1,0,improve compose generics i tested and built with the added tests on java and not sure if you want to keep them in before merging since theyre not really functional in nature just there to make sure they compile side note gets even better on java which removes the need for a type argument at all in those examples img width altscreen shot at am src
4982,1,0,0,1,0,1,1,0,fix observableconcatmapeager bad logic for immediate scalars the operator observableconcatmapeager had a bad optimization targeting scalar and callable sources and emitted their values immediately even if it wasnt that particular sources turn for itthe flowable is not affected added unit tests for bothreported in
4987,1,0,0,1,0,1,1,1,make obscombinelatest consistent with flowable doc cornercase this pr fixes observablecombinelatest to be consistent with flowablecombinelatest by not subscribing to additional input sources if the operator reached a terminal state due to a valueless source that completes or errors in addition such early termination didnt properly cancel the other sources when delayerrors true ive also extended the documentation on the overloads to warn about empty sources that will terminate the operator even with combinelatestdelayerror and thus subscription side effects may not happenthere is a related issue where the operator should fully consume each input source no matter what and terminate when all terminate im still considering what would be the best way to introduce thisreported in
4987,1,0,0,1,0,1,1,1,make obscombinelatest consistent with flowable doc cornercase this pr fixes observablecombinelatest to be consistent with flowablecombinelatest by not subscribing to additional input sources if the operator reached a terminal state due to a valueless source that completes or errors in addition such early termination didnt properly cancel the other sources when delayerrors true ive also extended the documentation on the overloads to warn about empty sources that will terminate the operator even with combinelatestdelayerror and thus subscription side effects may not happenthere is a related issue where the operator should fully consume each input source no matter what and terminate when all terminate im still considering what would be the best way to introduce thisreported in
5002,1,0,1,1,0,1,1,1,add scheduler creation factories this is a pretty vanilla copy from rxjava s implementation note that i had to tune newthread scheduler to not be a singleton to support thiswe had talked about borrowing from project reactors apis for different overloads let me know if you think we should add more fine grained controls through these one other thing im worried about is schedulers the best place for this rxjava had them in its rxjavahooks class my concern is that having these alongside the normal io computation etc factories will make them look overly inviting for use and accidental abuse one other thing im worried about is schedulers the best place for this rxjava had them in its rxjavahooks class my concern is that having these alongside the normal io computation etc factories will make them look overly inviting for use and accidental abuseanother problem is that people will try to override the scheduler init with these method calls for rxjavaplugins but referencing schedulers will init the default schedulers regardlessindeed rxjavaplugins sounds like a better place for the methods but keep only the threadfactory variants heading to bed right now but will update the pr in the morning with requested changes also let me know if theres anywhere i should put tests as i wasnt sure what the right place would be indeed rxjavaplugins sounds like a better place for the methods but keep only the threadfactory variantssounds good to me will do that in my updates tomorrow yes tests that verify the custom thread factory actually worked by checking a custom thread name for each case indeed rxjavaplugins sounds like a better place for the methods b d but keep only the threadfactory variants also tweaked the naming a bit newnewthread was a little weird went with create and added scheduler suffix since were not in the schedulers class anymore yes tests that verify the custom thread factory actually worked by checking a custom thread name for each casei tried setting this up matching some of the cdl based approaches in the plugin tests but want able to get it working just hangs pushed what i had in a b any insight heading on vacation for a couple weeks but let me know what you think of getting the tests to work i should have some time here and there to update the pr ive already told you use the runnable in the factory method on the thread constructor use the runnable in the factory method on the thread constructorarent i just testing the test threadfactory implementations then and not that the schedulers are hooked up properly to power the scheduler whats the problem with the tests they seem to be verifying that the supplied factory was used oh you didnt pass the supplied runnable when calling new thread inside the factory oh you didnt pass the supplied runnable when calling new thread inside the factoryah this is what i was missing thanks for pointing that out ive updated tests which should now all be passing and also made them a bit more robust full integration with schedulers to simulate a more real world use case failing test looks like a flake wait no its not reprod locally will fix i think i added manual shutdowns of schedulers after theyre done only io had this lifecycle issue over tests but i did the shutdown in all to be safe ok this time it seems actually flaky as the same commit passed in a different travis job against my fork
5005,1,0,0,1,0,1,1,1,executorschedulerscheduledirect to report isdisposed on complete this pr makes the disposable returned by the executorschedulerscheduledirect report isdisposed true if the task has actually finished which should now be consistent with the worker behavior of other schedulersreported in
5007,1,0,0,0,0,0,1,0,update sample time diagram to indicate emission of last this pr updates the x sample time diagram to indicate the last value is emitted when the sequence completes it is the same style as for x default scheduler scheduler image
5027,1,0,0,1,0,1,1,0,dedicated singlezip implementation no dispose on all success this adds a dedicated implementation for zipping single s adapted from maybezipx routing the original zip through flowable added the usually unwanted behavior of cancelling the sources if one of them reports a completion after a row has been consumed from all when converted to flowable singleobserveronsuccess becomes subscriberonnext oncomplete since there is only onsuccess and onerror in single there is no need to dispose the sources once all signalled their only onsuccess related
5047,1,0,0,1,0,1,1,1,document and test amb subscription ordering refs once wording and tests are approved ill port to x as well hmm i seem to be fighting the cool documentation checker which is being a bit too clever in this instance im using the word subscription at the beginning of a sentence which it thinks means subscription the type ill figure out a wording tweak to make it end up as a lowercase subscription also with regard to signal types i figure the other tests cover those already so in these cases were just guarding against ordering changes yes lowercase it as subscription is interpreted as the reference to the type merging
5049,1,0,0,1,0,1,1,0,use bounded wildcards for errorhandler adding bound wildcards for error handler merging
5051,0,0,0,1,0,0,0,0,feature nonnull annotations issue starting to add nonnull and nullable annotationsi decided to add a compileonly dependency to findbugs jsr artifactwe could also use ioreactivexannotationsnonnull which already exists but there is no ioreactivexannotationsnullable annotation which is at least as important in my experiencesince these are only annotations it is no problem when the class files are missing at compile time jls retention i have started to add annotations in the scheduler and rxjavapluginsthe test rxjavaplugins contains some invalid checks using null lines and following this pull request is work in progress and should be discussedquestions so far use jsr compileonly or existing annotation in ioreactivex if not using jsr use own nullable annotation or try to get one added to ioreactivex or skip these completely which misses the point of the static code analysis why has there been tests calling the rxjavapluginson scheduler with null arguments can these be removed securely maybe it wasnt well articulated but based on i thought we try with just the functional interfaces and come back later if it was not enough i decided to add a compileonly dependency to findbugs jsr artifactwe rather use our own annotations as most tools allow customizing what annotations to considerexpect futher comments inline thanks for the feedback i will improve the pull request further
5054,1,0,0,0,0,1,1,1,add nullable annotation to simple queue as explained in simplequeue might return nullto document this behavior a nullable annotation has been added merging
5055,1,0,0,0,0,1,1,0,feature more null checks i have added some more null checks to help the static code analysisi think i have also one possible npe in newthreadworker merging
5058,1,0,0,1,0,1,1,0,feature more generics in rxjavaplugins i widened the bounds for the functions looks good for merelated to looks like this needs rebasing im sorrry im trying to merge your prs in proper order but multiple recent prs change the same file s yeah no problem rebasing isnt too difficult import and rebased looks like there is a compilation error with the changes uups fixed it at least i hope merging
5064,1,0,0,1,0,1,1,1,fix replay cancel dispose npe this pr fixes both flowablereplay and observablereplay throwing a nullpointerexception if the connection is disconnect before the upstream calls onsubscribe on the connection being established in practice this requires an async cancellation to happen through refcount unsubscribeon for example the validation tests simulate this by not calling onsubscribe until the synchronous connect disconnect happensreported in
5086,1,0,1,0,1,1,1,1,deprecate create add alternatives looks like create wont go away unless we get the ide mark it someway such as being deprecatedthis pr deprecates create and adds unsafecreate for internal use and deprecate renames fromemitter to create action backpressuremode there was an earlier attempt at deprecating create but it was not followed up this pr executes what i suggested in one of the comments https githubcom reactivex rxjava pull issuecomment merging
5087,1,0,0,1,0,0,1,0,correct marble diagram dimensions this fixes part of as requested in these changes were generated using the following script sh usr bin env bashfind name java print \ xargs grep ^\s \ \ grep op \ sort u \ while read r i do echo updating ${i} gather image details data$ identify tags referencing the image find name java print \ xargs perl i p e s img widthheight ^ src\q${i}\e img width height${new_height} src${i}g done note that i assumed that its okay to just fix the width of all images at px that seemed to be the prevailing style great scripting job thanks since the change only touches javadoc i assume the travis ci job failure is spurious unrelated otherwise ill need a pointer on how to correct the situation the failure is due to time sensitive tests failing on an overloaded ci ill try to resolve it separately dont worry about it merging
5090,1,0,0,0,0,1,1,1,fix scan seed f to emit accumulated values asap for performance reasons the scan delayed the emission of accumulated items by one which worked well with sources that pushed new items frequently unfortunately if the source stopped emitting without completion the very last accumulated item was stuck and no way to get it out of scan i considered this type of use being rare but apparently i was wrongthe pr changes scan to emit accumulated items including the initial seed as soon as there is request for it the operator now uses a stable prefetch queue drain found throughout other operators such as observeon remark sadly request trickery such as capturing the first request call emitting the seed and then requesting n doesnt work because if the request call itself happens from another thread and the source is empty the onnext and oncomplete could run concurrentlyreported in
5091,1,0,0,0,0,0,1,0,create subscribeon avoid same pool deadlock this pr allows to fix the same pool deadlock that may happen with create formerly fromemitter and subscribeon as subscribeon by default schedules the requests behind a running emitter and thus the internal request amount may not get updated leading to unnecessary datalosssee in the update if subscribeon detects its upstream is onsubscribecreate it no longer reschedules requests for it for other non immediate cases a new overload allows specifying the requeston parameter that should be false if there is a create action backpressurestrategy in the sequence upstream
5092,1,0,0,0,0,1,1,1,add singlemerge obs obsflatmapsingle & flatmapcompletable this pr adds specialized operators for merging single and completable sources singlemerge observable maxconcurrency overload singlemergedelayerror observable maxconcurrency overload observableflatmapsingle func delayerrors delayerrors maxconcurrency overloads observableflatmapcompletable func delayerrors delayerrors maxconcurrency overloadsall of these return observable this replaces sidenote for some time now contributor s from certain party tend to contribute low quality or inadequate code and disappear pretty quickly i cant be sure this is just lazyness or a deliberate and elaborate scheme to extract free work out of me for their own partys benefit but it is annoying as hell merging
5101,1,0,0,1,0,1,1,1,fix maybeconcat subscribe after cancel verify others this pr fixes maybeconcatx subscribing to the next source when the downstream cancelled the flowable sequence from its onnext this resulted in executing the subscription side effects of the source to be immediately cancelled when it called onsubscribe on concats maybeobserver in addition tests were added to verify the other types dont have this kind of a problemrelated
5106,1,0,0,0,0,1,1,0,fix window time size not completing windows on timeout this pr fixes the operators flowablewindow time size and observablewindow time size to complete the current window if the time elapses before the size limit is reachedreported in merging
5112,1,1,1,1,1,1,1,1,flowable as a publisher to be fully rs compliant this pr performs the changes suggested in introduce flowablesubscriber with extra textual specification on its relaxed nature flowablesubscribe subscriber checks for flowablesubscriber and if not found it wraps the incoming rs subscriber into a strictsubscriber that follows the rs spec to the letter at any cost introduce flowablesubscribe flowablesubscribe that most internal operators will use change abstractflowablewithupstream to accept flowable as a source update operators some operators were useful with raw publisher input these were duplicated on their outer containing type but use the same internal flowablesubscriber removed cheat from the tck tests adjusted timeout on delay replaced most implements subscriber with implements flowablesubscriber replaced most new subscriber with new flowablesubscriber in tests the rest is required for testing the strictness itself strict is now an identity operator with suggested scheduled removalperformance impact estimation most primary use of a flowable should go through subscribe flowablesubscribe and thus no overhead change where the api mandated publisher as input providing a flowable will have an instanceof check at subscription time and routed to subscribe flowablesubscriber if the consumer is part of rxjava itself okay lets go from here in the unlikely case the spec becomes more forgiving the undo is just to remove cast wrapping from flowablesubscribe and everything works the same as flowablesubscriber is an interface
5114,1,0,0,1,0,1,1,1,fix observablecombinelatest to dispose eagerly this pr fixes observablecombinelatest to dispose the sources outside the serialization loop just like flowablecombinelatest does this allows cancellation even if the serialization loop is busy blocking inside an onnext emissionin addition a unit test was added to flowablecombinelatest as wellreported in merging
5117,1,0,0,1,0,1,1,1,add parallelflowablesequentialdelayerror this pr adds the sequentialdelayerror operator to parallelflowable that allows awaiting all rails in a parallel flow to terminate normally or with the composite exception of the failed rail s to enable this the flowableparallel operators behavior regarding rail cancellation had to be changed in v if any of the rails cancelled maybe due to a failure maybe due to an end consumer cancelling the entire parallel flow the input flowable was cancelled this pr alters this by requiring all rails to cancel before cancelling the input flowable the change permits one or multiple rails to fail and let others progress in case the new sequentialdelayerror is applied as a terminal operator the original sequential operator still cancels all rails if one of them fails triggering the cancellation of the input flowable note that this change may still drop and never process elements in the internal queues of the operators in the parallel flow because the parallel processing is not implemented with work stealing that could pick up elements from a dead queue in order to get as many elements processed as possible it is recommended to reduce the default prefetch on the runon operator to a reasonable tradeoff value between throughput and fault tolerance edit updated the pr to make sure parallel ignores cancelled rails when it dispatches itemsrelated merging
5121,1,0,0,0,0,1,1,1,fix observablezip to dispose eagerly this pr fixes observablezip to dispose the sources outside the serialization loop just like flowablezip does this allows cancellation even if the serialization loop is busy blocking inside an onnext emissionin addition a unit test was added to observablezip as wellreported in merging
5127,1,0,0,0,0,0,1,0,update javadoc of flatmap overloads this pr rewords the javadoc of flowableflatmap overloads to correctly express their behavior regarding backpressure towards their upstream in x only merge operators are unbounded in by default flatmap s are by default bounded buffersize or the maxconcurrency parameterin addition one of the flatmap overload still had resultselector instead of the common combiner parameter name as far as i know there are no language specific libraries targeting x yet where in the language the actual parameter names are also part of the signature and changing them counts as an incompatible changerelated merging
5133,1,0,0,0,0,1,1,1,fix flatmap not cancelling the upstream eagerly this pr fixes the lack of eager cancellation when flatmapping sources and not stopping the upstream if the inner source failsunit tests were added to verify single in case it receives a dedicated implementation one day as currently it delegates to flowable flowable and observable reported in merging
5136,1,0,0,0,0,0,1,0,fix repeatwhen and retrywhen signatures adjust the repeatwhen and retrywhen signatures to accept publisher on single and completable matching flowable s signaturereported in no coverage uploaded for pull request base x a b e click here to learn what that means n a x coverage complexity files hits misses partials impacted files coverage δ complexity δ src main java io reactivex flowablejava src main java io reactivex singlejava src main java io reactivex completablejava continue to review full report at codecov legend click here to learn more δ absolute impact not affected missing data last update a b ed bd read the comment docs
5140,1,0,0,1,0,1,1,1,fix timed replay like components replaying outdated items the timed versions of flowablereplay replayprocessor observablereplay and replaysubject all replay outdated items to new subscribers and through the getvalues and size state peeking methods similar to issue resolved via the fix includes a node walk for new subscribers that skips old entries some unit tests werent logically considering the emission pattern ie items timed out shouldnt appear and have been as wellreported in merging
5140,1,0,0,1,0,1,1,1,fix timed replay like components replaying outdated items the timed versions of flowablereplay replayprocessor observablereplay and replaysubject all replay outdated items to new subscribers and through the getvalues and size state peeking methods similar to issue resolved via the fix includes a node walk for new subscribers that skips old entries some unit tests werent logically considering the emission pattern ie items timed out shouldnt appear and have been as wellreported in merging
5141,1,0,0,1,0,1,1,1,fix timed replay not terminating when all items timeout the timed replay operator didnt terminate a late subscriber if all the items timed out in the meantimerelated
5146,1,0,0,0,0,1,1,1,add unsubscribeon to single type add unsubscribeon to single type merging
5156,0,0,0,0,0,0,1,0,add nonnull to the methods of emitter this pr is a part of this pr adds nonnull annotation to some methods of emitter so that the users of rxjava migrating from x to x can easily know passing null to the methods will cause npe sorry ive just noticed there is related to this pr merging
5161,1,0,0,0,0,1,1,1,add observableswitchmapsingle and switchmapsingledelayerror this is a new operator discussed in the issue refers to a goodly number of new operators which ill do bit by bit as my time allows and to ensure review is not too daunting updated with suggested changes unrelated ci failure ioreactivexparallelparallelflowabletest parallelismandprefetchasync failed javalangassertionerror value counts differ expected actual latch values errors completions timeout disposed at ioreactivexobserversbasetestconsumerfail basetestconsumerjava at ioreactivexobserversbasetestconsumerassertvaluecount basetestconsumerjava at ioreactivexparallelparallelflowabletestparallelismandprefetchasync parallelflowabletestjava unrelated ci failuretracking via could be due to low timeout settings and travis overload just rerun the build next time i did it just now merging
5163,1,0,0,0,0,1,1,0,singlesubscribe to report isdisposed true on success error the consumersingleobserver didnt report isdisposed consistently with its statereported in merging
5174,1,0,0,0,0,0,1,0,wip removes anonymous inner classes this is a wip since the changes are big an incremental review and pr was recommended by akarnokd removes them from flowable observable operators issue https githubcom reactivex rxjava issues merging
5177,1,0,0,0,0,0,1,0,removes all anonymous inner classes this is a what left to complete this one removes all aics issue https githubcom reactivex rxjava issues sleimanjneidi whats the motivation behind making this change naturalwarren to improve stack traces and to reduce the footprint naturalwarren to improve stack traces and to reduce the footprintmakes sense thanks for filling me in merging
5182,1,0,0,1,0,1,1,1,fix replay refcount leaking items between connections this pr updates observablereplay and flowablereplay for x to not leak items between reconnections when run with refcount the replay operator is designed to hold onto the buffer even after its completion so late subscribers can still receive the cached data only a new connect clears this data which may or may not happen since refcount ensures that there wont be any latecommers to an already completed connection because it also drops its current subscribers on termination or when reaching zero the replay can be reset to an empty staterelated merging
5189,1,0,0,1,0,1,1,0,fix concatmapeager should accept for prefetch fixes a bug that flowableconcatmapeager mapper maxconcurrency prefetch and observableconcatmapeager mapper maxconcurrency prefetch operators will not accept and negative numbersreported in i believe a breaks the internals of the operator and has the completely opposite effect taking more memory i am sorry with the wrong fixis it only necessary to modify the document is it only necessary to modify the documentyes please modify only the javadoc thank you also i think that the test case name is wrong so i modifed it merging
5195,1,0,0,0,0,0,1,0,unicastsubject fail fast and delay error behavior this pr adds support for delay error behavior to unicastsubject with methods unicastsubject create boolean delayerror unicastsubject create int capacityhint action onterminated boolean delayerror behavior of existing factory methods was not changed and is fail fastrelates to merging
5199,1,0,0,0,0,1,1,1,increase timeout on parallel & completable tests this pr increases the timeout on completabletest test methods and on parallelflowabletestparallelismandprefetchasync related merging
5199,1,0,0,0,0,1,1,1,increase timeout on parallel & completable tests this pr increases the timeout on completabletest test methods and on parallelflowabletestparallelismandprefetchasync related merging
5202,1,1,0,1,1,1,1,1,add resilient versions of parallel map filter & doonnext this pr adds new overloads to parallelflowable operators map filter and doonnext to enable per item error handling in case the main function fails with some exception javaflowablerange parallel map v v parallelfailurehandlingskip sequential test assertresult the new parallelfailurehandling has some default enumeration values to handle the common cases in addition the bifunction overload allows bounded retries and or conditional handling of failuresrelated merging
5207,1,0,0,1,0,1,1,1,prevent tasks to self interrupt on the standard schedulers task wrappers of the various schedulers and modes direct & worker were able to get cancelled via interruption from the same thread they were runningrelated merging
5208,1,0,0,0,0,0,1,0,fix images of firstelement flattenasx flatmapiterable this pr links in the new images from for previously misleading marble diagrams of the operators merging
5210,1,0,0,0,0,0,1,0,better documentation on the abstract consumer classes this pr improves the documentation of the abstract consumer classes such as disposablesubscriber resourcesubscriber and their counterparts for the other base reactive typesit contains a lot of copy paste so please read through all of the text in case the text was not properly adapted to the abstract class at handrelated merging
5213,1,0,0,0,0,1,1,0,fix window with time size emission problems the window operator overload with time and size bound didnt work correctly when some windows were terminated by the timeout and others by the size this pr fixes the case when the operator restarts the time windows when the size bound is reached leaking of the worker the item counter not reset to zero when the time bound is reached periodic window bound stopped working after the first windowrelated again merging
5217,1,0,0,0,0,0,1,0,unicastsubject fail fast support this pr adds support for fail fast behavior to unicastsubject with methods unicastsubject create boolean delayerror unicastsubject create int capacityhint runnable onterminated boolean delayerror relates to merging
5223,1,0,0,1,0,0,1,0,improve the documentation of schedulers utility class this pr improves the javadoc of the ioreactivexschedulersschedulers utility class plus adds a missing schedulersupport constant for the single schedulerlet me know if something needs further explanation or some new case needs explanation related merging
5225,1,0,0,0,0,1,1,0,fix completableonerrorresumenext unsubscribe not propagated the completableonerrorresumenext did not properly propagate the downstream unsubscribe call to upstreamreported in merging
5226,1,0,0,0,0,0,1,0,unicastprocessor fail fast support this pr adds support for fail fast behavior to unicastprocessor with methods unicastprocessor create boolean delayerror unicastprocessor create int capacityhint runnable onterminated boolean delayerror relates to merging
5247,1,0,0,0,0,1,1,1,fix flowabletolist onnext cancel race this pr fixes the nullpointerexception that can happen because cancel nulls out the value and onnext simply dereferences that value in flowabletolist reported in merging
5258,1,0,0,0,0,1,1,1,use intellij ide friendly assertion failure message the assertitem failure message pattern in testsubscriber does not match any of the regex patterns defined by intellij to show link before changing the _expected to be_ to _expected _ the pattern is recognised by intellij and the helpful link is presented after original idea from was to use the _expected but was _ pattern used in junit but it is not picked up on its own by intellij the assertionerror must extend from junits comparisonfailure to get it recognised this however requires dependency on junit junit in the end the fix is just a very simple change in the message merging
5277,1,0,0,0,0,1,1,0,singlesubscribe biconsumer consistent isdisposed fixes the singlesubscribe biconsumer to report isdisposed when terminatingreported in merging
5296,1,0,0,0,0,0,1,0,improve doondispose javadoc sorry for the earlier pr this addresses the javadoc issues discussed in removes the note in observabledoondispose which claims its action would be called on terminal events slightly adjusts the javadocs of the maybe single completable variants adds throws note to some observable single maybe doondispose as it was present in the completable variant merging
5296,1,0,0,0,0,0,1,0,improve doondispose javadoc sorry for the earlier pr this addresses the javadoc issues discussed in removes the note in observabledoondispose which claims its action would be called on terminal events slightly adjusts the javadocs of the maybe single completable variants adds throws note to some observable single maybe doondispose as it was present in the completable variant merging
5302,1,0,0,0,0,0,1,0,add singleunsubscribeon this pr adds the singleunsubscribeon operatorrelated merging
5307,1,0,0,1,0,0,1,0,apply promotions for v this pr applies the promotions listed in suggested review strategy check if the experimental annotation has been removed or turned into beta check if the history x matches the original value of the updated since x merging
5318,1,0,0,0,0,0,1,0,apply api promotions for this pr applies the api promotions of note that singleunsubscribeon remainded experimental and observablefromemitter was removedwhere the experimental version was available it was moved up as history xy experimental similar to how x versioning promotions happensuggested review strategy verify experimental and beta annotations are removed from the method and from javadoc verify since is present merging
5409,1,0,0,0,0,0,1,0,corrected singledelay documentation corrected singledelay documentation that says that success or error signals will be delayed by the specified amount but in fact errors are not delayed only successes
5419,1,0,0,0,0,1,1,0,fix periodic scheduling with negative period causing iae this pr adds unit tests to verify the schedulerscheduleperiodicallydirect and schedulerworkerscheduleperiodically works with non positive period as required by the javadoc the computation and single schedulers were not working properly and the underlying scheduledexecutorservice crashed with illegalargumentexception thus these are now with custom handler for the period l casesrelated
5427,1,0,0,0,0,1,1,1,fix buffer time maxsize duplicating buffers on time size race the pr fixes both the time maxsize bound buffer operators of flowable and observable the logic didnt properly mutually exclude the timer action and the onnext action resulting in probabilistic emission of the same buffer twicereported in merging
5440,1,0,0,0,0,1,1,1,concat to report isdisposed consistently with termination this pr makes sure the disposable of a concat operator reports true when the sequence terminatesreported in merging
5447,1,0,1,0,0,0,1,0,remove nonnull annotation in consumer method parameter this this should be safe to merge see the discussion in merging
5449,1,0,0,0,0,0,1,0,remove the nonnull annotation from function as per per the discussion in merging
5466,1,0,0,0,0,0,1,0,flowabletimeouttimed replace atomicreference with mutable field as per discussion in the timer fields in the subscriber classes in flowabletimeouttimed are atomicreference s but this is not required as the fields are accessed synchronouslythe timer field in timeouttimedothersubscriber did require an atomicreference because of the dispose call here but this call is not required if we just call workerdispose no unit test additionsps unit tests in rxjava x an outrageous amount of work thanks akarnokd and other contributors merging
5486,1,0,0,0,0,1,1,0,small note on maybedefaultifempty regarding tosingle ths pr replaces regarding the issue of because our javadoc validation did not allow that type of wording ie mentioning single when the method signature is not related to it merging
5486,1,0,0,0,0,1,1,0,small note on maybedefaultifempty regarding tosingle ths pr replaces regarding the issue of because our javadoc validation did not allow that type of wording ie mentioning single when the method signature is not related to it merging
5507,1,0,0,1,0,1,1,1,fix spsclaq nepotism flowablerefcounttesttestrefcountasync flaky this pr fixes the so called gc nepotism see in spsclinkedarrayqueue by not nulling out the previous buffers next pointer upon switching buffers in the peek poll methodsin addition the flowablerefcounttesttestrefcountasync has been reworked to be more forgiving towards unexpected delays due to system load reported in merging
5507,1,0,0,1,0,1,1,1,fix spsclaq nepotism flowablerefcounttesttestrefcountasync flaky this pr fixes the so called gc nepotism see in spsclinkedarrayqueue by not nulling out the previous buffers next pointer upon switching buffers in the peek poll methodsin addition the flowablerefcounttesttestrefcountasync has been reworked to be more forgiving towards unexpected delays due to system load reported in merging
5524,1,0,0,0,0,0,1,0,add update observable marbles this pr updates the marbles of the following observable operators just image by leonardortlima rangelong image by leonardortlima startwith image by leonardortlima startwitharray image by leonardortlima sorted image by leonardortlima see merging
5560,1,0,0,0,0,0,1,0,fix obscombinelatestdelayerror sync initial error not emitting this pr fixes the case reported in where a synchronous first non empty source triggered an error completion immediately instead of giving a chance to the other sources to form combinationsthe fix also includes initialization of the combineobserver s now happen in the constructor the atomicreference of the inner observers are now inlined into combineobserver cleaned up drain logic unit tests verifying flowablecombinelatest no changes required there merging
5568,1,0,0,0,0,1,1,1,add assertvaluesonly to basetestconsumer adds assertvaluesonly that asserts that the testobserver testsubscriber received only the specified values in the specified order without terminating merging
5582,1,0,0,0,0,0,1,0,implement maybeswitchifempty single adds maybeswitchifempty single merging
5590,1,0,0,0,0,1,1,0,implement lambdaconsumerintrospection and allows you to introspect if the resulting observer has missing error consumption and subsequently supplies a default throwing one wasnt sure how youd want to do the naming can work on adding some tests if this looks good wanted to get something up for api review early the naming is fine with me merging
5600,1,0,0,0,0,0,1,0,updating javadoc with correct return types a small pr with updated javadoc mentioned in the issue thanks to roblewis for reporting it updated documentation about return types where observable was incorrectly mentioned instead of single the flowable variants are okay merging
5609,1,0,0,1,0,1,1,0,fix observableconcatmapeager queueing of source items this pr fixes the wrong queue type in observableconcatmapeager to be the spsclinkedarrayqueue instead of the spscarrayqueue the latter basically ignored items from the main source when it got full a rem t from its bounded flowable cousin unit tests added that ensure both flowable and observable variants work properlyreported in merging
5616,1,0,0,1,0,1,1,0,add singledelay overload that delays errors much like i discovered when trying to fake a slow flaky backend that singledelay doesnt delay errorsthis pr adds an overload that does bringing singledelay in line with observabledelay it also corrects the javadoc for existing overloads only updated merging
5637,1,0,0,1,0,0,1,0,fixing javadoc warnings minor fixes for warnings reported javadoc tool mentioned in nice could you also fix this javadoc home travis build reactivex rxjava src main java io reactivex observers resourcemaybeobserverjava error bad use of subscribewith new resourcemaybeobserver&ltinteger { sure amended merging
5647,1,0,0,0,0,0,1,0,fix subscribewith documentation examples this pr improves a documentation of subscribewith functions in single maybe completable by making sure examples are compilable by using classes which implement disposable this should in that issue akarnokd approved my idea to use disposablemaybeobserver in the example but as i looked in other classes i noticed that observablesubscribewith documentation uses a resourceobserver which implements disposable so i thought that this is the way to go in all other top classesif you think that this is not the case and instead all of them should be switched to use disposable observer in their examples let me know i will do it in this way theni think that all those example should use similar classes resourcexobserver is generally not necessary so disposablexobserver should be in the docs merging
5649,1,0,0,0,0,0,1,0,add concatmapcompletable to observable add concatmapcompletable to observable as discussed in i didnt think it made sense in other reactive typescode is mostly a copy of observableconcatmap let me know if there is a better style of code to base this off instead it also does not have the option to delay errors as concatmap does not sure if that is needed merging
5660,1,0,0,0,0,0,1,0,fix timeout timed selector unsubscribe bug this pr fixes an unsubscribe bug somewhere in the timed timeout operator reported in by implementing it in a algorithmically fresh manner merging
5669,1,0,0,0,0,1,1,1,fix publishprocessor cancel emission overflow bug this pr should fix the bug that caused the test failure in the bug manifested itself when a cancellation was happening the same time a request was being fulfilled since the same request accounting was used for cancellation indicator if the cancel happened between the onnext s get check and decrementandget this decrementandget decremented longmin_value unconditionally which lead to a state that would appear the subscriber still can receive events a concurrent offer which saves the current array of registered subscriber s then would emit an item and overflow the subscriber the fix is to use the cancellation aware backpressurehelperproducedcancel utilityunit test were added to verify the correct behavior on both publishprocessor and behaviorprocessor the latter uses different cancellation mechanism via a dedicated field merging
5677,1,0,0,0,0,1,1,0,make parallel a fusion async boundary the parallel supports front fusion but since the operator is almost always followed by the separate runon operator the parallel version of the observeon operator such front fusion should be considered a boundary type fusion just like with observeon a requestfusion with boundary tells the upstream operator s that when fused their actions would be executed behind an async boundary and possibly on an unwanted thread operators such as map and doonnext who are generally expected to be thread confined can then refuse to fuse restoring the traditional queue hopping behavior source queue op queue op queue consumer reported in cc smaldini & simonbasle merging
5696,1,0,0,0,0,1,1,0,fix completableconcat to use replace dont dispose old fixes the same bug as with the x completableandthen and completableconcat see & merging
5705,1,0,0,0,1,1,1,1,moved tests to fromcallabletest from fromcompletabletest there was a test class named observablefromcompletabletest which actually was targeting observablefromcallabletest this was most likely just a naming issue copied all tests from observablefromcompletabletest to observablefromcallabletest and deleted the former class merging
5718,1,0,0,0,0,0,1,0,add a sentence to documentation of take operator merging
5719,1,0,0,0,0,0,1,0,add a sentence to documentation of take operator merging
5729,1,0,0,0,0,1,1,1,implement as this implement as support as discussed in i took the opportunity to try to standardize the docs and tests for it which vary a little bit across implementations of to related let me know if you want to add more tests some usages of to were mixed in other tests and wasnt sure if they were specifically targeting testing it im not sure i understand the remaining ci errors as the parameters have the nonnull annotation some style checks failed add as to parallelflowable please add a unit test that has a converter class which combines all interfaces and is applied to the types of sources could you explain what the style checks fix is i didnt quite understand the message in the log parallelflowable adb started on more converter tests in convertertest in c f ee composite converter test is in there only thing im stuck on is the genericssignaturetest tests borrowed from transformerstest currently they dont compile but im not sure what the goal is or if it even makes sense to match the checks transformerstest does let me know what you think you have to extend the paramvalidationcheckertest with instances of your new converter types put something like the following into l javadefaultvaluesput observableconverterclass new observableconverter { override public object apply observable o { return o }} as for these you are using the wrong generic types observableconverter b is applied to observable in the test where integer is unrelated to a i overlooked the test using a ill check code locally the wildcard definition in those compile errors and the wrong parameter confuses the compiler i suggest going raw types with these converters and using suppresswarnings {unchecked rawtypes} on the problematic tests posted a patch for your pr merging
5740,1,0,0,0,0,0,1,0,marbles for observable all frompublisher ziparray this pr adds a marble diagram to frompublisher and updates the marbles of all and ziparray inside observable the images can be seen in this comment of merging
5743,1,0,0,0,1,1,1,1,check isdisposed before emitting in singlefromcallable previously singlefromcallable did not check if the subscriber wasunsubscribed before emitting onsuccess or onerror this fixes thatbehavior and adds tests to singlefromcallable completablefromcallableand maybefromcallable merging
5745,1,0,0,0,0,0,1,0,add update observable marbles this pr adds or updates mable diagrams of observable blockingfirst blockingfirst with default tofuture blockingsubscribe no arguments blockingsubscribe with argument blockingsubscribe with arguments blockingsubscribe with arguments collectinto dooncomplete doonerror doonlifecycle doonnext doondispose comment https githubcom reactivex rxjava issues issuecomment merging
5755,1,0,0,0,0,0,1,0,add marbles for observable this pr adds some missing marbles to observable concatmapcompletable concatmapdelayerror concatmapeager concatmapeagerdelayerror concatmapiterable doafternext dofinally in images in comment https githubcom reactivex rxjava issues issuecomment merging
5766,0,0,0,0,0,0,1,0,rename interface parameters signed off by shaishavgandhi merging
5773,1,0,0,0,0,0,1,0,improve javadoc of retrywhen operators this pr improves the javadoc of the retrywhen operators in the base classes adds example to handling an asynchronous source with delay where an early oncomplete may cause unexpected terminations otherwiserelated merging
5781,1,0,0,0,0,0,1,0,describe merge error handling this pr adds some clarifications about how merge handles multiple errors in a new error handling section in its javadoc entrythere exist several dozen variants of merge in the various base classes that could also include such javadoc addition once the wording has been reviewed the other places will receive a separate prrelated merging
5781,1,0,0,0,0,0,1,0,describe merge error handling this pr adds some clarifications about how merge handles multiple errors in a new error handling section in its javadoc entrythere exist several dozen variants of merge in the various base classes that could also include such javadoc addition once the wording has been reviewed the other places will receive a separate prrelated merging
5783,1,0,0,0,0,0,1,0,fix javadoc wording of onterminatedetach a missing nulls word from flowableonterminatedetach and observableonterminatedetach javadoc the other types have this word alreadyrelated merging
5792,1,0,0,0,0,1,1,0,fix flatmap inner fused poll crash not cancelling the upstream this pr fixes the lack of upstream cancel call when an inner fused sources queuepoll crashes in a non delayed error modeunit tests were added to verify observableflatmap flowableflatmapiterable and observableflatmapiterable as well merging
5805,1,0,0,0,0,0,1,0,final planned observable marble additions fixes this is the final part of the observable marble fixes and additions as planned in tolist callable toflowable buffer toflowable drop toflowable latest toflowable error toflowable missing unsubscribeon position and spacing of the marbles in the zipwith overloads no image change images in https githubcom reactivex rxjava issues issuecomment merging
5811,1,0,0,0,0,1,1,1,fix buffer open close not disposing indicators properly the pr fixes the resource management in the buffer operator that uses other reactive sources to indicate when a buffer starts and ends both flowable and observable implementations had to be fixes akarnokd let me know if i understand the spirit of this pr on flowablebufferboundary avoids keeping reference to tracking buffers in subscribers other than the main cancel source on open subscriber completion if it completes and the last buffers close publisher has completed subscribers will have size and we can safely cancel upstream as no new buffer will open at this point in main distinguish a open subscriber error from a close subscriber error due to the later needs associated buffer cleanup is that correct exhaustive avoids keeping reference to tracking buffers in subscribers other than the mainyes cancel source on open subscriber completion if it completes and the last buffers close publisher has completed subscribers will have size and we can safely cancel upstream as no new buffer will open at this pointyes in main distinguish a open subscriber error from a close subscriber error due to the later needs associated buffer cleanupno if the openerror or closeerror is fired both should cancel the main source cancel the subscribers other than themselves clean the buffer and then report the error they could be converted into a common method of boundserror disposable d throwable ex merging
5820,1,0,0,1,0,1,1,0,plugin lookup workaround for systemproperties access restrictions the pr adds a try catch around the system property lookup inside the rxjavaplugins in case a security manager prevents reading arbitrary property entriesthis mainly affects the rxjavaplugin index class lookup which were introduced due to the character key limit on androidhowever when running in a container such as tomcat a security manager may prevent reading these type of pre entries where index cant be known upfront crashing the initialization update the systemgetproperties can also fail therefore retrieving the properties has been factored out into a separate method that returns an empty properties merging
5828,1,0,0,1,0,0,1,0,document replay n emission retention caveat adds javadocs indicating a caveat regarding size bounded replay operators subjects and processors see for details merging
5833,1,0,0,0,0,1,1,1,fix observableswitchmap main onerror not disposing the current inner source the observableswitchmap had bad logic in its main onerror handler which didnt dispose the current inner observable the flowable version didnt have this logic error both variants received an unit test to verify the correct behavior merging
5845,1,0,0,0,0,0,1,0,add efficient concatwith singlemaybecompletable overloads this pr adds specialized overloads to the concatwith operator in flowable and observable if accepted the marbles will be updated in a separate prrelated merging
5847,1,0,0,1,0,1,1,0,add efficient mergewith singlemaybecompletable overloads this pr adds specialized overloads to the mergewith operator in flowable and observable if accepted the marbles will be updated in a separate prrelated merging
5860,1,0,0,0,0,1,1,1,flowablegroupby add overload with evicting map factory as per discussion in this pr adds an overload for flowablegroupby that specifies an evictingmapfactory an example of usage taken from the new javadoc javafunction map evictingmapfactory notify cachebuilder newbuilder maximumsize removallistener entry { try { emit the value not the key notifyaccept entrygetvalue } catch exception e { throw new runtimeexception e } } build asmap emit items but ensure that the internal map never has more than items in it flowable range note that number of keys is groupby x x x x true evictingmapfactory flatmap g g foreach systemout println note that i based this operator on the x version which i think may have a bug that goes as far as the signature of that method the eviction consumer should not be given a key but rather the value from the map ill pursue the x issue after dealing with this merging
5863,1,0,0,0,0,0,1,0,expand the documentation of the flowablelift operator this pr expands the documentation of the flowablelift operator used for inserting custom operators into flows in a functional and fluent fashionthe other reactive base classes feature similar lift operators for which the text can be adapted and contributed in a separate pr once the content of this pr is stabilized by review feedbackrelated merging
5870,1,0,0,0,0,1,1,0,add flowableswitchmapcompletable{delayerror} operator this pr adds the flowableswitchmapcompletable and flowableswitchmapcompletabledelayerror operators as requested by the associated new marbles are switchmapcompletable https rawgithubcom wiki reactivex rxjava images rx operators switchmapcompletablefpng switchmapcompletabledelayerror https rawgithubcom wiki reactivex rxjava images rx operators switchmapcompletabledelayerrorfpng merging
5871,1,0,0,0,0,1,1,0,add flowableconcatmapcompletable{delayerror} operator this pr adds the flowableconcatmapcompletable and flowableconcatmapcompletabledelayerror operators as requested by the marbles will be updated in a separate pr merging
5872,1,0,0,0,0,0,1,0,add flowableconcatmap{maybesingle}{delayerror} operators this pr adds operators that allow concatenating a mapped sequence of maybe s or single s with or without delaying their errors concatmapmaybe overload with prefetch concatmapmaybedelayerror overloads with error mode and prefetch concatmapsingle overload with prefetch concatmapsingledelayerror overloads with error mode and prefetch they are in the same pr as the single variants implementation is practically the maybe implementation minus the oncomplete casetheir marbles will be updated in a separate proriginally requested in merging
5873,1,0,0,0,0,1,1,0,add flowableswitchmap{maybesingle}{delayerror} operators this pr adds flowable operators that allow switching between a mapped sequence of maybe s or single s with or without delaying their errors switchmapmaybe switchmapmaybedelayerror switchmapsingle switchmapsingledelayerror they are in the same pr as the single variants implementation is practically the maybe implementation minus the oncomplete casetheir marbles will be updated in a separate proriginally requested in merging
5875,1,0,0,0,0,1,1,0,add observable switchmapx and concatmapx operators this pr ports the various switchmapx and concatmapx operators from and to observable concatmapcompletable replaced by the common implementation concatmapcompletabledelayerror concatmapmaybe concatmapmaybedelayerror concatmapsingle concatmapsingledelayerror switchmapcompletable switchmapcompletabledelayerror switchmapmaybe switchmapmaybedelayerror switchmapsingle dedicated implementation switchmapsingledelayerror dedicated implementation this pr concludes the requested set of operators in marbles will be updated adjusted in a separate pr merging
5886,1,0,0,0,1,1,1,1,upgrade the algorithm of observabletimeout timeselector operators this pr improves the algorithms of the observabletimeout time and observabletimeout selector operators to match their flowable counterparts implemented in in addition coverage of the flowable counterparts have been improved by synchronizing the unit testsnote that they were the last users of observerfullarbiter and fullarbiterobserver which are now removedcloses merging
5887,1,0,0,0,0,1,1,1,fix window observablecallable upstream handling this pr fixes the upstream handling in observablewindow observablesource and observablewindow callable operators to make sure if both the main output and the inner windows have been disposed the upstream is also disposed remark there are a couple of w null checks showing up as partially covered in theory with the right interleaving w can become null but unfortunately the usual testhelperrace testing is unlikely to trigger that case there would be a higher chance with threads one disposing one completing the main and one completing the inner window but the current ci is effectively cores threads that tend to not produce a thorough interleaving merging
5888,1,0,0,0,0,1,1,1,fix flowablewindow publishercallable upstream handling this pr fixes the upstream handling in flowablewindow publisher and flowablewindow callable operators to make sure if both the main output and the inner windows have been cancelled the upstream is also cancelledrelated in addition the jacoco code coverage has been updated to mainly due to the automatic filtering of difficult to impossible code paths https githubcom jacoco jacoco releases tag v merging
5895,1,0,0,0,0,0,1,0,fix buffer documentation to correctly describe onerror behaviour i just copied the sentence from the docs in x and updated to use observablesource publisher naming merging
5904,1,0,0,0,0,1,1,1,fix flowablesingleorerror toflowable not signalling nosuchelementexception when a singleorerror is followed toflowable the assembly process switches the flowable single operator into a flowable flowable operator implementing the singleorerror behavior saving the back and forth type conversion the backing implementation was shared with singleelement and as such did not properly handle the orerror case for an empty source the pr fixes the lack of nosuchelementexception in this case the observable variant doesnt have such optimization but the test has been converted to make sure observable is verified for this aspect in case the optimization is implemented with it in the future merging
5906,1,0,0,0,0,0,1,0,add public constructor for testscheduler that takes the time adds a time constructor to testscheduler should i make it experimental or will it just be stable merging
5923,1,0,0,0,0,0,1,0,fix javadoc warnings of buffer publishercallable text is not allowed between and its child tags merging
5924,1,0,0,0,0,0,1,0,update singleflatmappublisher marble renamed the operator in the box for flatmappublisher https rawgithubcom wiki reactivex rxjava images rx operators singleflatmappublisherpng
5928,1,0,0,0,0,1,1,0,fix concatmapsingle & concatmapmaybe dispose cleanup crash this pr fixes the accidental logical mistake in the cancel dispose logic of the new concatmapsingle and concatmapmaybe operators of both flowable and observable where the internal queue cleanup should happen in a serialized fashion only which is the state when the work in progress counter changes from to ensured by a check this is severe enough to release as a hotfix version asap although the mistakes are in the newly introduced operators ive done a quick search for this pattern and doesnt happen in older code luckily also this is on the dispose path and doesnt really the performance in the normal operation mode ie when data is allowed to flow through till the end without cancellation merging
5947,1,0,0,0,0,1,1,1,fix groupby cancellation with evicting map factory when the outer stream is cancelled there may be evicted groups present in the queue to be completedive added code to complete the evicted groups in the cancel method as suggested by akarnokd to protect against a race condition where the evictionaction is called just after the evicted groups are completed in cancel ive added a cancelled check to evictionaction however i am concerned about a race that ill place in the comments on the code below merging
5948,1,0,0,0,0,0,1,0,fix observable javadoc replace dooncancel doondispose in observable javadocthank you for contributing to rxjava before pressing the create pull request button please consider the following points please give a description about what and why you are contributing even if its trivialreplace dooncancel doondispose in observable javadoc please include the issue list number s or other pr numbers in the description if you are contributing in response to those please include a reasonable set of unit tests if you contribute new code or change an existing one if you contribute an operator if applicable please make sure you have tests for working with an empty just range of values as well as an error source with and or without backpressure and see if unsubscription cancellation propagates correctlyjavadoc only merging
5972,1,0,0,0,0,1,1,0,fix observableconcatmapsingle dropping upstream items the internal queue of observableconcatmapsingle was incorrectly the bounded one from its flowable counterpart causing it to drop upstream items if the current single was delayed the right queue for observable s is the spsclinkedarrayqueue added unit tests to both concatmapsingle and concatmapmaybe to verify the correct behaviorfixes merging
5979,1,0,0,1,0,1,1,1,add throttlelatest operator this pr adds the throttlelatest operator to observable and flowable also known as conflate it is a combination of throttlefirst and sample whereby frequent items are sampled but the first item outside the sampling window will be emitted immediately throttlelatest replaces merging
6014,1,0,0,0,0,1,1,0,fix & prevent null checks on primitives this pr removes the accidental null checks on primitives in two observable methods and adds a trap method to objecthelper to both highlight and fail the tests in case the null checks are still attempted the method is marked as deprecated so it will also show up in eclipses problems windowreplaces merging
6014,1,0,0,0,0,1,1,0,fix & prevent null checks on primitives this pr removes the accidental null checks on primitives in two observable methods and adds a trap method to objecthelper to both highlight and fail the tests in case the null checks are still attempted the method is marked as deprecated so it will also show up in eclipses problems windowreplaces merging
6019,1,0,0,0,0,1,1,1,fix singletakeuntil maybetakeuntil dispose behavior fix the dispose behavior of the singletakeuntil and maybetakeuntil operatorstests were also added to the other takeuntil variants for completable it is delegated to amb fixes merging
6021,1,0,0,0,0,1,1,0,singleflatmappublisher full implementation see discussion in resolves merging
6021,1,0,0,0,0,1,1,0,singleflatmappublisher full implementation see discussion in resolves merging
6026,1,0,1,0,0,1,1,0,fix flowableblockingsubscribe is unbounded and can lead to oome create and bound new blockingsubscribe overloads to buffersize create new overloads with buffersize create a boundedconsumer create a boundedsubsciber close merging
6036,1,0,0,0,0,1,1,0,fix disposed lambdaobserver onerror to route to global error handler fix the behaviour of lambdaobserver when disposed to route to the global error handler merging
6049,1,0,0,0,0,0,1,0,make it explicit that throttlewithtimout is an alias of debounce the documentation implies that these two methods are somewhat different fixing that confusion as discussed in made the descriptions of these methods the same mentioned that it is an alias in the first paragraphs of throttlewithtimeout javadoc comments removed the links to third party websites build warnings please avoid dangling tags merging
6052,1,0,0,0,0,0,1,0,made subscribeactual protected proposalchanged subscribeactual from public to protected as described in how i testedran tests locally please let me know if i missed part of the contributing guidelines 👼 fixes cc vanniktech artem zinnatullin davidmoten strictly speaking this is technically a breaking change on something that shouldnt be in use at all by external developers im fine with this change for merging
6053,1,0,0,0,0,0,1,0,add maybe marble diagrams a resolved the following diagrams of amb missing diagram ambarray missing diagram image concat iterable missing diagram image concat publisher missing diagram image concat publisher int missing diagram image concatarray missing diagram image concatarraydelayerror indicate error delayed marble per source image concatarrayeager missing diagram image concatdelayerror iterable missing diagram image concatdelayerror publisher missing diagram image concateager iterable missing diagram image concateager publisher missing diagram image https rawgithubcom wiki reactivex rxjava images rx operators maybeconcateagerppng merging
6060,1,0,0,0,0,1,1,0,fix concatmap{singlemaybe} null emission on dispose race this pr fixes a bug in all specialized concatmap implementation that allows null to be emitted when the success signal of the inner source races with the dispose signal of the sequencelikely fixes a very similar thing happened in just after a release but this bug was there between and merging
6074,1,0,0,0,0,0,1,0,add marble diagram to the singlenever method first of all im extremely grateful to open my first pr for rxjava i hope that ill be able to tick more of the marbles from but for now this should tick off the never operatorplease let me know if i need to change anything on the diagram itself if not please send me url when you upload image within the project so i can change url for the marble in the pr merging
6075,1,0,0,0,0,0,1,0,add marble diagram to the singlefilter method hopefully this should tick off the filter operator in please let me know if i need to change anything on the diagram itself if not please send me url when you upload image within the project so i can change url for the marble in the pralthough i had a doubt and wanted to double check operator filter returns maybe which essentially will call onsuccess or oncomplete by running junit tests i could observe that this is a behavior but if i use testobserver then both assertvalue and assertcomplete are invoked when there are elements that satisfy filter condition merging
6076,1,0,0,0,0,0,1,0,add marble diagrams to the singledelay method here are marbles for delay operator in please let me know if i need to change anything on the diagram itself if not please send me url when you upload image within the project so i can change url for the marble in the pr merging
6077,1,0,0,0,0,0,1,0,add marble diagram for singlehide operator this should complete hide operator in please let me know if i need to change anything on the diagram itself if not please send me url when you upload image within the project so i can change url for the marble in the pralthough i wasnt sure if i should represent somehow that disposable is hidden as well if so can you please tell me how to represent that on marble merging
6079,1,0,0,0,0,1,1,0,add completabletakeuntil completable operator this pr adds the missing dedicated takeuntil operator to completable the same effect could be achieved via the ambwith but there are two benefits of a dedicated operator easier to discover based on the takeuntil operator in other types more direct implementation unlike ambwith which is built upon an n ary amb operator with additional overheadthere was a feature request in some time ago but apparently the issue got closed off after singletakeuntil was implemented merging
6081,1,0,0,0,0,0,1,0,add marble diagrams for singlerepeat operators here are marbles for repeat repeat times and repeatwhen operator in please let me know if i need to change anything on the diagram itself if not please send me url when you upload image within the project so i can change url for the marble in the pri intentionally added two diagrams for repeatwhen as i would say its interesting case that people should be aware of edit here are marbles repeat operator repeat operator repeat with count operator repeatwhen https rawentcom umfsimke rxjava images images repeatwhenpng merging
6083,1,0,0,0,0,0,1,0,add completable marble diagrams a this pr adds the following marble diagrams to completable operators amb ambarray complete image concatarray concat image defer image error image https rawgithubcom wiki reactivex rxjava images rx operators completableerrorpng image https rawgithubcom wiki reactivex rxjava images rx operators completableerrorfpng merging
6084,1,0,0,0,0,0,1,0,add marble diagram for singlerepeatuntil operator here is marble for repeatuntil operator in repeatuntil let me know if i need to change anything on the diagram itself if not please send me url when you upload image within the project so i can change url for the marble in the pr merging
6085,1,0,0,0,0,1,1,0,more completable marbles add completablefrommaybe this pr adds marble diagrams to the following operators as well as adds the missing completablefrommaybe operator fromx of other types were already there uses existing maybeignoreelement s underlying implementation fromaction fromcallable image fromfuture image frommaybe image fromobservable image frompublisher image fromsingle image mergearray & mergearraydelayerror image merge both iterable and publisher variants image mergedelayerror both iterable and publisher variants image never image timer image https rawgithubcom wiki reactivex rxjava images rx operators completabletimerpng image https rawgithubcom wiki reactivex rxjava images rx operators completabletimerspng merging
6086,1,0,0,0,0,0,1,0,single error operators marbles here are marbles for for error callable errorcallable error throwable only added error event to be red errorthrowable onerrorreturn onerrorreturn onerrorreturnitem onerrorreturnitem onerrorresumenext singlesource onerrorresumenext onerrorresumenext function onerrorresumenextfn https rawentcom umfsimke rxjava images images onerrorresumenextwithfnpng for the onerrorx please indicate the normal case via different marble ie the usual split diagram btw you can save yourself a commit if you follow the following naming in the javadocs xxxx is the name of the operator such as error and may contain argument indicator letters s is for scheduler s or single t is for timed n is for some numerical value f is for function or flowable c is for callable or completable p is for publisher m is for maybe or some other numerical valuethus the image naming of this pr will look like this merging
6087,1,0,0,0,0,0,1,0,add marbles for singlefrom operators here are marbles for fromcallable frompublisher and fromobservable operators from marble for fromcallable fromcallable for frompublisher frompublisher for fromobservable fromobservable https rawentcom umfsimke rxjava images images fromobservablepng merging
6091,1,0,0,0,0,0,1,0,add marbles for singleamb operators here are operators for amb and ambarray from marble for amb amb for ambarray ambarray https rawentcom umfsimke rxjava images images ambarraypng merging
6095,1,0,0,0,0,0,1,0,add marbles for singletimer singledefer and singletoxxx operators here are marbles for defer timer delay unit timer delay unit scheduler toflowable tomaybe tofuture operators in marble for defer defer for timer delay unit timer for timer delay unit scheduler timerscheduler for tofuture although for this one i believe we should add case when there is no event sent from single as there will be timeout exception thrown tofuture for tomaybe tomaybe for toflowable although here i didnt figured out what will happen if we request more than event from flowable toflowable https rawentcom umfsimke rxjava images images toflowablepng defer i would have drawn it with a curly brace listing the options below each other please add the subscribe indicators as welltofuture i indicate future with a sided shape and indicate get call and a return see completablefromfuture for an exampletoflowable simply indicate request n any positive n has the same effect with this operator however an error is always pushed through even without a request just remove the request from that side of the diagram merging
6097,1,0,0,0,0,0,1,0,add missing completable marbles a this pr add even more missing marbles to completable tracked by delay doonx image dofinally image onerrorcomplete image onerrorresumenext image onterminatedetach image mergewith image concatwith image observeon image hide image https rawgithubcom wiki reactivex rxjava images rx operators completablehidepng merging
6098,1,0,0,0,0,0,1,0,several more completable marbles b this pr adds a couple of more marble diagrams to completable subscribeon unsubscribeon image tosingle tosingledefault image toflowable image tomaybe image https rawgithubcom wiki reactivex rxjava images rx operators completabletomaybepng merging
6101,1,0,0,0,0,0,1,0,final set of missing completable marbles this pr contains the final set of missing completable marbles repeat repeatuntil image repeatwhen image retry image retrywhen image startwith image timeout image create image unsafecreate image lift image subscribe image subscribewith image test image https rawgithubcom wiki reactivex rxjava images rx operators completabletestpng image https rawgithubcom wiki reactivex rxjava images rx operators completabletestbpng merging
6137,1,0,0,0,0,0,1,0,add marbles for singleconcat operator here are marbles for concat iterable concat publisher concat publisher prefetch concat observable concat source source concat source source source concat source source source source and concatarray operators that should close them at marble for concat iterable concatiterable for concat publisher concatpublisher for concat publisher prefetch concatpublishern for concat observable concatobservable for concat source source concat for concat source source source concat for concat source source source source concat for concatarray concatarray pay attention to file names in javadoc as i was not sure how to name concat iterable so ive added at the end i for concat observable ive added o for concat source source source and concat source source source source ive used n and m as they are numerical valuesalso is there an error in concat publisher and concat publisher prefetch with request commands i did used as a reference completableconcat publisher marble but i do not understand why do we have request after first event as we already requested prefetching of multiple ones is it because others are still not producedthanks merging
6141,1,0,0,0,0,0,1,0,add marble diagrams for various single operators here are marble diagrams for various single operators that will close some of the marble for concateager publisher concateeagerp for concateager iterable concateeageri for create create for ambwith ambwith for equals equals for merge source source merge for merge source source source mergethree for merge source source source source mergefour for merge singlesource mergesinglesource for mergewith mergewith for doafterterminate doafterterminate for to to for as as for compose compose for doaftersuccess doaftersuccess for merge publisher mergepublisher for merge iterable mergeiterable https rawentcom umfsimke rxjava images images mergeiterablepng merging
6143,1,0,0,0,0,0,1,0,add concatarrayeagerdelayerror operator expose feature this pr exposes the existing delayerror capability of the concatmapeager operator as concatarrayeagerdelayerror for both flowable and observable in addition the concatarrayeager and these new methods receive marble diagrams observable flowable image sidenote one of the validators had to be adjusted due to false positive it produced merging
6145,1,0,0,0,0,1,1,0,fix boundary fusion of concatmap and publish operator this pr fixes the lack of boundary fusion marker in the concatmap and publish operators that can break the thread confinement expectation when using observeon upstream and a thread sensitive operator javasourceobserveon scheduler map some thread sensitive operation publish or concatmap by default these operators may call poll from any of the participating threads which would otherwise dequeue observeon and execute map on that threadthe fix adds the necessary flag to both operators onsubscribe logic for a temporary workaround one should use hide before such operators to make sure fusion doesnt happenfixes merging
6152,1,0,0,0,0,0,1,0,clarify testobserverassertvalueset in docs and via tests clarify that {testobservertestsubscriber}assertvalueset checks for all received items to be in the provided set but that set can contain additional elements that could have been received unit tests have been added to demonstrate the expected behaviorresolves merging
6155,1,0,0,0,0,0,1,0,fix marble of maybeflatmap events to maybesource fix the marble diagram of the event mapping maybeflatmap operator in merging
6167,1,0,0,0,0,1,1,0,make observeon not let workerdispose called prematurely some operators may call dispose cancel from onerror oncomplete which could trigger a permature call to workerdispose that was about to happen anyway this pr prevents this by moving the operator into its disposed cancelled state before signaling the terminal event thus a downstream cancel dispose call wont trigger this premature cleanupsuch premature cleanups may cause unwanted schedulersio reuse in some scenariosrelated there are x tests that were relying on a race that the previous behavior always allowed ive updated those tests to avoid the inherent termination cancel race in them merging
6175,1,0,0,0,0,1,1,0,explain null observer subscriber error reports in detail from rxjavaplugins this pr is related to issue these changes all reactive types will emit detailed error message when onsubscribe hook installed using rxjavaplugins returns null observer subscriber observable the rxjavapluginsonsubscribe hook returned a null observer please check the handler provided to rxjavapluginssetonobservablesubscribe for invalid null returns further reading the rxjavapluginsonsubscribe hook returned a null flowablesubscriber please check the handler provided to rxjavapluginssetonflowablesubscribe for invalid null returns further reading the rxjavapluginsonsubscribe hook returned a null singleobserver please check the handler provided to rxjavapluginssetonsinglesubscribe for invalid null returns further reading the rxjavapluginsonsubscribe hook returned a null maybeobserver please check the handler provided to rxjavapluginssetonmaybesubscribe for invalid null returns further reading the rxjavapluginsonsubscribe hook returned a null completableobserver please check the handler provided to rxjavapluginssetoncompletablesubscribe for invalid null returns further reading there was no null check on observer returned from rxjavapluginsonsubscribe this observer method call in completable s subscribe method so ive added it in this pr is that fine merging
6187,1,0,0,0,0,0,1,0,fix refcount termination reconnect race this pr modifies the refcount operator in both flowable and observable types to avoid certain termination reconnection racesthe original race could happen when the refcounted source terminated at the same time as new observers arrived leaving those new observers hanging as they practically joined a dying connection and got possibly undercut by the dispose callthe change involve a new internal interface resettableconnection that will allow resetting the connection object inside the connectable source if it is equal to the connection object known by the initiator of the original connect call merging
6193,1,0,0,0,0,0,1,0,add error handling java docs section to from callable & co added javadocs describing the regular and canceled disposed behavior for observablefromcallable singlefromcallable maybefromaction completablefromcallable completablefromaction flowablefromcallable did not alter maybefromcallable because the existing javadoc appears to be adequate merging
6197,1,0,0,0,0,0,1,0,fix flowablereduce bifunction javadoc empty source does not signal nosuchelementexception merging
6199,1,0,0,0,0,0,1,0,fix terminology of cancel dispose in the javadocs changing terminology from cancel dispose wherever appropriate in the following classes observablejava singlejava maybejava completablejava areas where i did _not_ change from cancel disposal include where the cancellation was in reference to a flowable publisher or a future test methods where the testobserver returned actually has a cancel method merging
6200,1,0,0,0,0,0,1,0,fix tofuture marbles and descriptions this pr fixes the marble diagrams of flowabletofuture and observabletofuture to indicate multi valued sources signal indexoutofboundsexception source has to be finite for the future to terminate also fixes the diagram for merging
6232,1,0,0,0,0,1,1,1,cleanup observableflatmap drain logic cleanup the drain logic of observableflatmap by removing unnecessary loops and fixing the index management in case of a fused failure in one of the sources triggering another round over the same source unnecessarilyresolves merging
6254,1,0,0,0,0,1,1,1,fix flaky sample backpressure test improve coverage use processors to trigger the missingbackpressureexception case instead of the timer which could fire prematurely and stop the sequence before the first item was sent by the behaviorprocessor also small improvements to the code coverage of flowablesample merging
6258,1,0,0,1,0,1,1,1,fix cancel dispose upon upstream switch for some operators this pr extends the subscriptionarbiter to optionally allow or disallow cancelling the current subscription if it is replaced by a new one some operators do not need to cancel the current subscription concat concatmap repeat repeatwhen retry and retrywhen in addition repeatwhen and retrywhen were cancelling when the handler sequence itself terminated the code has been updated to disconnect the upstream upon the completion failure but before signaling the handlerthe reactive streams specification also disallows synchronous cancellation after the terminal event anywayothers may actually need to cancel such as timeout observable s dont have a specific arbiter they use the disposablehelper methods and the relevant ones were changed to replace instead of the disposing set callsome tests actually checking if the dispose cancel happens and had to be updatedthe flowabledelaysubscription publisher also used subscriptionarbiter but it was unnecessary the code has been replaced with a more apt deferred requesting scheme as the downstream requests need to be delayed until the main subscription happens the other publisher is always consumed unboundedresolves merging
6269,1,0,0,1,0,1,1,1,call the doon{disposecancel} handler at most once this pr makes sure the doondispose dooncancel and doonlifecycle execute their cancellation handler onceresolves merging
6275,1,0,0,0,0,1,1,1,improve the observable flowable cache operators this pr rewrites the observablecache and flowablecache operators to allocate less and be more up to date algorithmicallyive also added comments to help understand its inner workings in case someone is interestedresolves merging
6278,1,0,0,0,0,1,1,0,add materialize and dematerialize this pr adds the materialize operator to maybe single and completable to turn their signals into the corresponding notification object this operator has been available for observable s and flowable s from the beginning of the rx api the methods return single to complement the dematerialize operator is only defined for single and results in a maybe if accepted ill draw the correct marble diagrams for them in a separate prresolves merging
6287,1,0,0,0,0,0,1,0,expose the keep alive value of the io scheduler as system property configuring keep alive through system propertyresolves merging
6287,1,0,0,0,0,0,1,0,expose the keep alive value of the io scheduler as system property configuring keep alive through system propertyresolves merging
6297,1,0,0,1,0,1,1,1,fix refcount eager disconnect not resetting the connection this pr fixes the case when an observer subscriber disposes cancels immediately upon subscribing to a refcount operator before it establishes the connection and ends up with a disposed but non reset connection preventing further interactions with the connectable sourcethe fix is to detect this case and reset the connection when the connect method signals the dispose handlerboth connectableflowablerefcount and connectableflowablerefcount is affectedfixes merging
6303,1,0,0,0,0,0,1,0,javadoc fix incorrect image placement add before image elements in javadocresolves merging
6305,1,0,0,0,0,0,1,0,javadoc explain explicitly about using emitter interface methods synchronously add note in javadoc explicitly explaining about using emitter interface methods synchronously add notes for generate methods in observable and flowable plus add the similar note to emitter interfaceresolves merging
6308,1,0,0,0,0,0,1,0,javadoc updates for rxjava issue updates to ioreactivexflowable javadocs as per updated docs for all flowablegroupby methods merging
6311,1,0,0,0,0,1,1,1,javadoc explain that distinctuntilchanged requires non mutating data to work as expected add note in javadoc for all distinctuntilchanged methods in flowable and observable class explaining about unexpected results to expect when using mutable data sources like mutable charsequence or lists resolves merging
6313,1,0,0,0,0,0,1,0,adding nonnull annotations to observable & single adding nonnull annotations in factory methods for improved code compilationresolves akarnokd can you pls take a look at this and review thanks for contributing a few points you dont have to keep the welcome text of the pr thats for telling contributors what to do see the updated text for future reference didnt you mean to add nonnull to the arguments rather than to the return value merging
6321,1,0,0,0,0,0,1,0,fix flowabletoobservable backpressure support merging
6359,1,0,0,0,0,1,1,1,fix the error race in observablerepeatwhen due to flooding repeat signal this pr fixes a race condition in the observablerepeatwhen operator for the case when the repeat signal is not for and a new subscription may race with the clearing of the previous disposable because active is set to false too early the fix is to swap the two operations observableretrywhen and the flowable versions do not have this bug unit tests were added to all operators to verify the correct behavior regardlessfixes merging
6364,1,0,0,0,0,1,1,0,fix publish not requesting upon client change due to a bug in the flowablepublish operator it is not requesting more if there was a change in the subscriber array during an emission run in the non fused operation modefixes merging
6370,1,0,0,0,0,1,1,0,add interruptible mode to schedulersfrom by default the schedulersfrom uses a trampoline to ensure worker tasks are executed fifo and non overlappingly on any potentially multi threaded executor this old setup didnt allow task interruption due to this disconnect between the trampoline task and the operator task in contrast the standard schedulers use single threaded executors and their future is linked and interruptible when the operator task is cancelled this pr add an interruptible mode to the schedulersfrom via a paramerer in a new overload and some internal dispatching based on this mode selector existing schedulersfrom executor users should still behave the sameresolves merging
6375,1,0,0,0,0,1,1,0,dont dispose the winner of {singlemaybecompletable}amb this pr fixes the singleamb maybeamb and completableamb operators to not dispose the winner source causing potential interruptions as a side effect on the current threadthe fix is to delete the winner from the composite before disposing the rest to avoid the interruption raceunit tests were added to verify this behavior on all amb implementations flowable and observable were already working correctlyfixes merging
6377,1,0,0,0,0,0,1,0,expand observabledebounce and flowabledebounce javadoc mention that if the processing of a task takes too longand a newer item arrives then the previous task willget disposed interrupting a long running workfixes merging
6386,1,0,0,0,0,1,1,0,add doonterminate to single maybe for consistency this pr adds doonterminate operator to single and mayberesolves merging
6405,1,0,0,1,0,1,1,0,fix concateager to dispose sources & clean up properly this pr fixes the concatmapeager operator which drives the static variants as well to properly dispose and clean up the state of the operator upon cancelling disposing the sequence flowableconcatmapeager did not cancel the current active inner consumer only the ones coming after observableconcatmapeager did not dispose the main source of the inner observablesboth variants have received the same two unit tests to verify their behaviorfixes merging
6408,1,0,0,0,0,0,1,0,improving javadoc of flattenasflowable and flattenasobservable method improving the javadoc of the flattenasflowable and flattenasobservable methods of single and maybe classesresolves merging
6432,1,0,0,0,0,0,1,0,composite disposable docs on compositedisposable add and addall methods if the param is null currently the npe error message produced by objecthelper is d is null which is not very helpfulthis is a small refactor for making the message a bit more helpful merging
6452,1,0,0,0,0,0,1,0,remove dependency of schedulers from observablerefcount in the constructor of observablerefcount that takes connectableobservable source as the argument we set timeout to l in that specific use case of observablerefcount scheduler is never needed its only referenced in cancel method but if timeout is it wont be triggered at all because there is early return this commit removes the need to depend on schedulerstrampoline and instead passes null to be scheduler when the ref count is not time based similarly applies the same change to flowablerefcount the reasons for this change are the following in projects that dont depend on schedulers class if there is no reference to schedulers the whole schedulers can be stripped out of the library after optimizations eg proguard with constructor that references schedulers the optimizer cant properly strip it out in our quick test of our android app we were able to reduce the rxjava library size dependency from kb to kb after optimization but before compression by simply avoiding access to schedulers in observablerefcount in terms of modularity observablerefcount is just an operator so it by itself should probably not have dependency on what available pool of schedulers schedulers there are it should just know that there is some scheduler that could be passed to observablerefcount when observablerefcount needs it merging
6458,1,0,0,1,0,1,1,1,update the javadoc of the retry operator specify that the times function parameter describes the number of timesto resubscribe if the current observable failssolves bellow is the marble with the number of retries decreased from to if the marble is correct can you upload it to the repository retry o n sure could you also make sure all the other counted retry operators in the other base classes have the correct wording merging
6461,1,0,0,0,0,0,1,0,change error message in observablefromarray changed the error message when an element at position i is null to what was suggested in could you please update these locations as well merging
6469,1,0,0,1,0,1,1,1,remove redundant methods from sample observable resolves merging
6483,1,0,0,0,0,0,1,0,correction for maybecount doc typo merging
6488,1,0,0,1,0,1,1,1,fix zip not stopping the subscription upon eager error the observablezip did not stop subscribing to the next sources if the previous one failed with an onerror flowablezip works as intended merging
6519,1,0,0,1,0,1,1,1,connectableflowable connetableobservabe redesign this pr changes the connectable api to have a specific reset method to reset a terminated connectable source as part of the official apiin x when publish terminated it reset itself to a fresh state which could lead to late consumers not receiving events as there might be no one to call connect again see however replay did not reset itself thus late consumers got the cached events however a reconnect started the sequence and new consumers may have missed itemsin x this two corner cases have been by the introduction of reset both publish and replay now remain in their terminated state until reset is called if the connection is disposed it will automatically reset their state just like before the state transitions are as follows fresh connect running oncomplete onerror terminated reset fresh fresh connect running dispose fresh fresh connect running oncomplete onerror terminated dispose fresh fresh connect running oncomplete onerror terminated connect running this does resolve the race condition with publish refcount described in in addition there are some changes to flowablepublish s behavior it no longer keeps consuming the upstream if there are no subscribers this implies if the source terminates while there are unconsumed items in the internal buffer those will be available for observation i have no strong preference on this property and in comparison observablepublish drops items because there is no backpressure buffer in its implementation upstream errors are not reported to the rxjavapluginsonerror handler when if there are no subscribers but have to be observed via a subscriber because terminal events are available until reset now we cant know really if there is going to be a subscriber or not however it might be possible to detect the no consumer case upon an error and still report it when reset or dispose is called resolves merging
6519,1,0,0,1,0,1,1,1,connectableflowable connetableobservabe redesign this pr changes the connectable api to have a specific reset method to reset a terminated connectable source as part of the official apiin x when publish terminated it reset itself to a fresh state which could lead to late consumers not receiving events as there might be no one to call connect again see however replay did not reset itself thus late consumers got the cached events however a reconnect started the sequence and new consumers may have missed itemsin x this two corner cases have been by the introduction of reset both publish and replay now remain in their terminated state until reset is called if the connection is disposed it will automatically reset their state just like before the state transitions are as follows fresh connect running oncomplete onerror terminated reset fresh fresh connect running dispose fresh fresh connect running oncomplete onerror terminated dispose fresh fresh connect running oncomplete onerror terminated connect running this does resolve the race condition with publish refcount described in in addition there are some changes to flowablepublish s behavior it no longer keeps consuming the upstream if there are no subscribers this implies if the source terminates while there are unconsumed items in the internal buffer those will be available for observation i have no strong preference on this property and in comparison observablepublish drops items because there is no backpressure buffer in its implementation upstream errors are not reported to the rxjavapluginsonerror handler when if there are no subscribers but have to be observed via a subscriber because terminal events are available until reset now we cant know really if there is going to be a subscriber or not however it might be possible to detect the no consumer case upon an error and still report it when reset or dispose is called resolves merging
6519,1,0,0,1,0,1,1,1,connectableflowable connetableobservabe redesign this pr changes the connectable api to have a specific reset method to reset a terminated connectable source as part of the official apiin x when publish terminated it reset itself to a fresh state which could lead to late consumers not receiving events as there might be no one to call connect again see however replay did not reset itself thus late consumers got the cached events however a reconnect started the sequence and new consumers may have missed itemsin x this two corner cases have been by the introduction of reset both publish and replay now remain in their terminated state until reset is called if the connection is disposed it will automatically reset their state just like before the state transitions are as follows fresh connect running oncomplete onerror terminated reset fresh fresh connect running dispose fresh fresh connect running oncomplete onerror terminated dispose fresh fresh connect running oncomplete onerror terminated connect running this does resolve the race condition with publish refcount described in in addition there are some changes to flowablepublish s behavior it no longer keeps consuming the upstream if there are no subscribers this implies if the source terminates while there are unconsumed items in the internal buffer those will be available for observation i have no strong preference on this property and in comparison observablepublish drops items because there is no backpressure buffer in its implementation upstream errors are not reported to the rxjavapluginsonerror handler when if there are no subscribers but have to be observed via a subscriber because terminal events are available until reset now we cant know really if there is going to be a subscriber or not however it might be possible to detect the no consumer case upon an error and still report it when reset or dispose is called resolves merging
6522,1,0,0,0,0,1,1,0,fix concatmapdelayerror not continuing on fused inner source crash the callable fused path didnt consider the error delay settings and cut the sequence shortfixes merging
6523,1,0,0,0,0,1,1,0,fix concatmapdelayerror not continuing on fused inner source crash the supplier fused path didnt consider the error delay settings and cut the sequence shortfixes
6525,1,0,0,0,0,1,1,0,remove test from testxxx method names create a validator create validator automatically rename methods testxxx to xxx analog to fixlicenseheaders check rename methods merging
6528,1,0,0,0,0,1,1,0,rename test methods and enable the check no coverage uploaded for pull request base x edb f click here to learn what that means n a x coverage complexity files hits misses partials continue to review full report at codecov legend click here to learn more δ absolute impact not affected missing data last update edb f e a read the comment docs
6532,1,0,0,1,0,1,1,1,add eager truncation to bounded replay to avoid item retention this pr adds the eagertruncate option to the replay operator so that the head node will lose the item reference it holds upon truncationthe bounded buffers in replay implement a linked list that when truncated moves the head reference forward along the links atomically this allows late consumers to pick up the head and follow the links between them to get items replayed however the truncation may happen concurrently with a consumer working on some prior nodes so if the truncation would null out the value the consumer reaching the same node would see null as well and fail avoid this type of retention the head node has to be refreshed with a new node still pointing to the next node in the chain but without any value image reason this is not the default is that it requires an additional allocation for each new incoming value when the buffer is full which would reduce performance in cases where the excess retention is not a problemoverloads to both the direct and function variants of both flowablereplay and observablereplay have been added to avoid too many overloads only one extra overload has been added extending the signature of the longest parameterized method per each bounds mode size time time size their unit test files have been cloned so that both the non eager original behavior and the eager behavior is tested separately merging
6534,1,0,0,0,0,1,1,1,make using resource disposal order consistent with eager mode make the resource disposal order in all using implementations are consistent with the eagerness of the operator eager dispose resource then dispose the upstream non eager dispose the upstream then dispose the resourcefixes merging
6538,1,0,0,1,0,1,1,1,add concatmap with scheduler guaranteeing where the mapper runs this pr adds an overload to concatmap and concatmapdelayerror in both flowable and observable which makes sure the mapper function is always executed on a dedicated schedulerby default concatmap may execute the mapper function on various threads the subscribing thread the upstream thread generating the items to be mapped or the thread where the generated inner source terminates these overloads remove this kind of uncertaintythe implementation is a copy of the original concatmap instead of an extension so that optimizations for the non scheduled variants still work without extra overheadoverloads to the concatmap{singlemaybecompletable} and concatmap{singlemaybecompletable}delayerror may be added in a separate pr later merging
6544,1,0,0,0,0,0,1,0,fixing version tag on schedulersfrom executor boolean updating the version tag on schedulersfrom executor boolean since it was promoted merging
6556,1,0,0,1,0,1,1,1,rename on error resume next methods to disambiguate when calling from kotlin renamed onerrorresumenext source to onerrorresumewith source for observable maybe single and flowable renamed some unit tests and their classes to reflect the method name change changed parameter type of singleonerrorresumewith from single to singlesource updated javadocs for all renamed methods removed redundant casts for unit tests deleted duplicate unit test that arose from no longer needing to cast arguments
6559,1,0,0,0,0,1,1,1,fix npe when debouncing empty source background related issue debounce with selector on the empty observable leads to npeit happens because of debounceobserverdebouncer field is set up only when onnext is called when onnext isnt called at all like when debouncing observableempty we get a null reference from debouncer and call emit on null which actually leads to npe change wrap emit call with null check both in observabledebounce and flowabledebounce test plan to check observable gradlew test tests ioreactivexinternaloperatorsobservableobservabledebouncetestdebounceonempty to check flowable gradlew test tests ioreactivexinternaloperatorsflowableflowabledebouncetestdebounceonempty merging
6560,1,0,0,0,0,1,1,1,fix npe when debouncing empty source background related issue cherry pick of for x versiondebounce with selector on the empty observable leads to npeit happens because of debounceobserverdebouncer field is set up only when onnext is called when onnext isnt called at all like when debouncing observableempty we get a null reference from debouncer and call emit on null which actually leads to npe change wrap emit call with null check both in observabledebounce and flowabledebounce test plan to check observable gradlew test tests ioreactivexinternaloperatorsobservableobservabledebouncetestdebounceonempty to check flowable gradlew test tests ioreactivexinternaloperatorsflowableflowabledebouncetestdebounceonempty merging
6564,1,0,0,1,0,1,1,1,remove buffer window with supplier & onexceptionresumenext this pr removes kinds of operators that had no noticeable use bases or use cases on their own in the past years buffer supplier supplier window supplier int onexceptionresumenext resolves merging
6564,1,0,0,1,0,1,1,1,remove buffer window with supplier & onexceptionresumenext this pr removes kinds of operators that had no noticeable use bases or use cases on their own in the past years buffer supplier supplier window supplier int onexceptionresumenext resolves merging
6577,1,0,0,0,0,0,1,0,observableblockingsubscribe compares blockingobserverterminated with wrong object compare with v instead of o merging
6589,1,0,0,0,0,1,1,1,create a base test class and have all unit tests extend it this commit creates the rxjavatest class defining a defaulttimeout to minutes an ignored test announce itself for eachrunning class extending it preventing travis ci from killing thebuildhave completable tests extend from rxjavatest have disposable tests extend from rxjavatest have exception tests extend from rxjavatest related merging
6594,1,0,0,1,1,1,1,1,have unit tests extends rxjavatest this commit updates the unit tests of the following operators flowable maybe observable disposable observer parallel processors schedulersand rxjava pluginrelated merging
6595,1,0,0,1,1,1,1,1,have unit tests extends rxjavatest this commit updates the unit tests of the following operators single subjects subscribersand for internal operators internaldisposable internalfuctions internalobservers internalqueue interanlschedulers internalsubscribers internalsubscriptions internaloperatorcompletablerelated merging
6600,1,0,0,1,1,1,1,1,have internaloperatorflowable unit tests extends rxjavatest this commit updates the unit tests for internaloperatorflowable related merging
6601,1,0,0,0,0,0,1,0,observableblockingsubscribe compares with wrong object it should compare the terminated instance with the value received from the blocking queuefixes related
6602,1,0,0,1,0,1,1,1,fix truncation bugs in replay and replaysubject processor this pr fixes several truncation bugs with the time and size bound replay operators and their hot class versions unexpected removal of the last item just added due to becoming out of date at the lowest time resolution creating a hole in the linked chain and hanging the consumer related failure incorrect size accounting upon removing old entries leading to more items dropped than expectedrelated
6604,1,0,0,1,1,1,1,1,have unit tests extends rxjavatest this commit updates the unit tests of the following operators internaloperatorsmaybe internaloperatormixed internaloperatorsinglerelated
6607,1,0,0,1,1,1,1,1,have internaloperatorobservable unit tests extends rxjavatest this commit updates the unit tests for internaloperatorobservable related merging
6609,1,0,0,1,0,1,1,1,fix refcount not resetting when termination triggers cross cancel this pr fixes both refcount implementation to properly reset the source when the source terminates multiple consumersin the original when the source terminated multiple sources the first termination handler cleared the connection but since the subscribercount wasnt zero the source was not reset if this termination triggered a cancel on the second consumer that path would not get the source reset either due to losing the connection object unfortunately one cant just take the first termination handler and reset there immediately either because that could disrupt the termination of the rest of the consumers it has to wait for the source to terminate all consumers or have the consumers cancel allthis affects x and will be backported in a separate pr merging
6612,1,0,0,0,0,1,1,0,fix many operators swallowing undeliverable exceptions fix many operators to emit the collected exception in case of a cancel dispose call to the plugin error handler ie becoming undeliverable excptions in addition the terminal event error delivery has been unified in many other operators so that the terminal indicator exception is never leakedthere will be a separate pr about cleaning up the addthrowable usage cases fixes merging
6612,1,0,0,0,0,1,1,0,fix many operators swallowing undeliverable exceptions fix many operators to emit the collected exception in case of a cancel dispose call to the plugin error handler ie becoming undeliverable excptions in addition the terminal event error delivery has been unified in many other operators so that the terminal indicator exception is never leakedthere will be a separate pr about cleaning up the addthrowable usage cases fixes merging
6620,1,0,0,0,0,0,1,0,elementat first constrain upstream requests as discussed in this pr constrains upstream requests for the elementat and first overloads other operators will be covered in other prs merging
6626,1,0,0,0,0,0,1,0,fix blockingiterable not unblocking when force disposed when the iterator was cast to disposable and disposed the subsequent hasnext would block indefinitely that interface is not intended to be part of the public api and iterator in general does not support any form of official cancellation unlike stream this pr makes sure that if that dispose is called it unblocks the iteratora separate pr will be posted for xrelated
6627,1,0,0,0,0,1,1,1,fix blockingiterable hang when force disposed when the iterator was cast to disposable and disposed the subsequent hasnext would block indefinitely that interface is not intended to be part of the public api and iterator in general does not support any form of official cancellation unlike stream this pr makes sure that if that dispose is called it unblocks the iterator
6629,1,0,0,1,0,1,1,1,fix refcount not resetting when cross canceled this pr fixes the issue with refcount not resetting the connection when the termination triggers cross cancellation over it the fix is more involved than because how x uses two publish implementation internally due to bug the old classic implementation does not fail but the newer implementation fails if the fix is applied unconditionally the old classic implementation fails an older unit test verifying an error allows reconnection therefore the pr checks and applies the new code path only if refcount isnt talking to the classic publish implementationas a reminder for x has a redesigned connectable with a much more clearer reset semantics and thus the restructuring of the termination handling had no trouble passing the aforementioned error allows reconnect unit test merging
6635,1,0,0,1,0,1,1,1,remove vararg overloads for combinelatest in observable flowable started removing the vararg function from hmm after looking at the tests the varag variant for combinelatestdelayerror might be useful since there are no x overloads available what do you think let me guess intellij refactor the varargs is a convenience over the array variant so combinelatestdelayerror s can go merging
6637,1,0,0,0,0,1,1,0,avoid using systemgetproperties due to security restrictions change the code in the schedulerpoolfactory to use systemgetproperty directly also fix property names to rx as now both v and v could run together merging
6650,1,0,0,1,0,1,1,1,constrain upstream requests from take remove limit operator as per discussion in this pr constrains upstream requests from the take operator and removes the limit operatorive also added a couple of unit tests for coverage of elementat that i didnt include in merging
6652,1,0,0,0,0,1,1,0,fix size time bound window not creating windows properly there was a logic error in the size time bound window operator for when to close a window if timers are not restarted when the size bound is hitdue to this bug two tests were not receiving and thus accounting for empty windows that are happening when the size bound is hit followed by the periodic time bound hit x will be in a separate pr no coverage uploaded for pull request base x a click here to learn what that means
6657,1,0,0,0,0,1,1,0,fix size time bound window not creating windows properly there was a logic error in the size time bound window operator for when to close a window if timers are not restarted when the size bound is hitdue to this bug two tests were not receiving and thus accounting for empty windows that are happening when the size bound is hit followed by the periodic time bound hit merging
6664,1,0,0,0,0,1,1,1,fix groupby group emission in some cases this pr fixes two issues when the observablegroupby operator would abandon a newly created group before the groups only item was emitted causing dataloss when the groupby s value selector failed for a new group thus the new group would never be emitted and report the failureit should fix the first test failure of but may not be the cause for the second merging
6668,1,0,0,0,0,0,1,0,add missing marble diagams to single add hopefully all remaining missing marble diagrams to single https rawgithubcom wiki reactivex rxjava images rx operators singleconcatarrayeagerpng image https rawgithubcom wiki reactivex rxjava images rx operators singlemergedelayerroripng image https rawgithubcom wiki reactivex rxjava images rx operators singlemergedelayerrorppng image https rawgithubcom wiki reactivex rxjava images rx operators singlemergedelayerror png image https rawgithubcom wiki reactivex rxjava images rx operators singlemergedelayerror png image https rawgithubcom wiki reactivex rxjava images rx operators singlemergedelayerror png image https rawgithubcom wiki reactivex rxjava images rx operators singleunsafecreatepng image https rawgithubcom wiki reactivex rxjava images rx operators singleusingpng image https rawgithubcom wiki reactivex rxjava images rx operators singleusingbpng image https rawgithubcom wiki reactivex rxjava images rx operators singlewrappng image https rawgithubcom wiki reactivex rxjava images rx operators singlecachepng image https rawgithubcom wiki reactivex rxjava images rx operators singlecastpng image https rawgithubcom wiki reactivex rxjava images rx operators singledelaysubscriptiontpng image https rawgithubcom wiki reactivex rxjava images rx operators singledelaysubscriptiontspng image https rawgithubcom wiki reactivex rxjava images rx operators singledooneventpng image https rawgithubcom wiki reactivex rxjava images rx operators singleblockinggetpng image https rawgithubcom wiki reactivex rxjava images rx operators singleliftpng image https rawgithubcom wiki reactivex rxjava images rx operators singlecontainsfpng image https rawgithubcom wiki reactivex rxjava images rx operators singlecontainspng image https rawgithubcom wiki reactivex rxjava images rx operators singleonerrorresumewithpng image https rawgithubcom wiki reactivex rxjava images rx operators singleonterminatedetachpng image https rawgithubcom wiki reactivex rxjava images rx operators singleretrypng image https rawgithubcom wiki reactivex rxjava images rx operators singleretryf png image https rawgithubcom wiki reactivex rxjava images rx operators singleretrynpng image https rawgithubcom wiki reactivex rxjava images rx operators singleretryfpng image https rawgithubcom wiki reactivex rxjava images rx operators singleretrynfpng image https rawgithubcom wiki reactivex rxjava images rx operators singleretrywhenpng image https rawgithubcom wiki reactivex rxjava images rx operators singlesubscribepng image https rawgithubcom wiki reactivex rxjava images rx operators singlesubscribecpng image https rawgithubcom wiki reactivex rxjava images rx operators singlesubscribeccpng image https rawgithubcom wiki reactivex rxjava images rx operators singlesubscribec png image https rawgithubcom wiki reactivex rxjava images rx operators singlesubscribewithpng image https rawgithubcom wiki reactivex rxjava images rx operators singletakeuntilcpng image https rawgithubcom wiki reactivex rxjava images rx operators singletakeuntilspng image https rawgithubcom wiki reactivex rxjava images rx operators singletakeuntilppng image https rawgithubcom wiki reactivex rxjava images rx operators singletimeoutpng image https rawgithubcom wiki reactivex rxjava images rx operators singletimeoutspng image https rawgithubcom wiki reactivex rxjava images rx operators singletimeoutbpng image https rawgithubcom wiki reactivex rxjava images rx operators singletimeoutsbpng image https rawgithubcom wiki reactivex rxjava images rx operators singleunsubscribeonpng image https rawgithubcom wiki reactivex rxjava images rx operators singletestpng image https rawgithubcom wiki reactivex rxjava images rx operators singletestbpng image https rawgithubcom wiki reactivex rxjava images rx operators singledelaysubscriptionppng image https rawgithubcom wiki reactivex rxjava images rx operators singledelaysubscriptionopng image https rawgithubcom wiki reactivex rxjava images rx operators singledelaysubscriptionspng image https rawgithubcom wiki reactivex rxjava images rx operators singledelaysubscriptioncpng image https rawgithubcom wiki reactivex rxjava images rx operators singledematerializepng merging
6700,1,0,0,0,0,0,1,0,update javadoc for observeon to mention its eagerness update javadoc to reflect the eagerness property of observeon in flowable and observable classes merging
6714,1,0,0,0,0,1,1,0,fix multicastprocessor not requesting more after limit is reached after reaching the prefetch limit the updated consumed counter was not written back so the processor stopped requesting more consumed limit affects x to a separate pr will be posted for it merging
6715,1,0,0,0,0,1,1,0,fix multicastprocessor not requesting more after limit is reached after reaching the prefetch limit the updated consumed counter was not written back so the processor stopped requesting more consumed limit merging
6720,1,0,0,0,0,1,1,1,fix parallel on grouped flowable not replenishing properly backport of fix a case when the groupedflowable is consumed by a parallel in fusion mode causing the source to stop replenishing items from the upstream hanging the whole sequenceparallel was slightly different from the usual queue consumers because it checks for isempty before trying to pull for an item this was necessary because the rails may not be ready for more and an eager pull to check for emptyness would lose that item the replenishing was done in groupedflowablepull but a call to groupedflowableisempty would not replenishthe fix is to have isempty replenish similar to when poll detects emptyness and replenishesreported in reactor reactor core merging
6729,1,0,0,0,0,0,1,0,fix self see references some comments some see should point to the other party plain delayerror add a few see to the nearby operators comments no longer apply in blockingxmostrecent source code add a comment from to actiondisposable replaces
6729,1,0,0,0,0,0,1,0,fix self see references some comments some see should point to the other party plain delayerror add a few see to the nearby operators comments no longer apply in blockingxmostrecent source code add a comment from to actiondisposable replaces
6730,1,0,0,0,0,0,1,0,add maybe marble diagrams cases related https rawgithubcom wiki reactivex rxjava images rx operators maybezipipng image https rawgithubcom wiki reactivex rxjava images rx operators maybezipnpng image https rawgithubcom wiki reactivex rxjava images rx operators maybeziparraypng image https rawgithubcom wiki reactivex rxjava images rx operators maybezipwithpng image https rawgithubcom wiki reactivex rxjava images rx operators maybecontainsopng image https rawgithubcom wiki reactivex rxjava images rx operators maybeunsubscribeonpng image https rawgithubcom wiki reactivex rxjava images rx operators maybeonterminatedetachpng image https rawgithubcom wiki reactivex rxjava images rx operators maybecastpng image https rawgithubcom wiki reactivex rxjava images rx operators maybeliftpng image https rawgithubcom wiki reactivex rxjava images rx operators maybedooneventpng image https rawgithubcom wiki reactivex rxjava images rx operators maybedelaysubscriptiontpng image https rawgithubcom wiki reactivex rxjava images rx operators maybedelaysubscriptiontspng image https rawgithubcom wiki reactivex rxjava images rx operators maybedelaysubscriptionppng merging
6732,1,0,0,0,0,0,1,0,update singlezip marble diagrams cases related https rawgithubcom wiki reactivex rxjava images rx operators singlezipipng image https rawgithubcom wiki reactivex rxjava images rx operators singlezipnpng image https rawgithubcom wiki reactivex rxjava images rx operators singleziparraypng image https rawgithubcom wiki reactivex rxjava images rx operators singlezipwithpng
6744,1,0,0,1,0,1,1,0,add fair mode overload to schedulersfrom executor the default schedulersfrom implementation uses an eager approach to execute tasks on the underlying executor which can lead to excessive thread occupation on its own even if operators use buffering prefetch of this pr introduces a new overload with a fairness option so that tasks are submitted to the executor in a non overlapping and fifo manner one by onein addition the scheduler retention tests have been cleaned up and reworked to not wait unnecessarily long for the gc to finishrelated merging
6745,1,0,0,0,0,0,1,0,make disposablecontainer public api make the internal interface disposablecontainer public as it can be one safely ive seen some rd party usage in custom containers this will make them now legit on x edit also should resolve the osgi private reference warning merging
6748,1,0,0,0,0,1,1,0,change how the cause of compositeexception is generated this pr changes how compositeexceptiongetcause creates a cause exception on demand in x and x the code tried to link up the various inner exceptions via their initcause which was in on itself fishy as well as could lead to excessive memory usageinstead the new code will present the inner exceptions as part of a formatted message which in theory should be still picked up by ide exception listings and allow navigation multiple exceptions ioreactivexrxjava exceptionstestexception ex at ioreactivexrxjava exceptionscompositeexceptiontestnestedmultilinemessage compositeexceptiontestjava ioreactivexrxjava exceptionstestexception ex at ioreactivexrxjava exceptionscompositeexceptiontestnestedmultilinemessage compositeexceptiontestjava ioreactivexrxjava exceptionscompositeexception exceptions occurred at ioreactivexrxjava exceptionscompositeexceptiontestnestedmultilinemessage compositeexceptiontestjava ioreactivexrxjava exceptionscompositeexceptionexceptionoverview multiple exceptions ioreactivexrxjava exceptionstestexception ex at ioreactivexrxjava exceptionscompositeexceptiontestnestedmultilinemessage compositeexceptiontestjava ioreactivexrxjava exceptionstestexception ex at ioreactivexrxjava exceptionscompositeexceptiontestnestedmultilinemessage compositeexceptiontestjava are a few formatting conveniences if there is only one inner exception the compositeexception s cause will be simply that exception this can happen when the very same exception is aggregated into the composite and get deduplicated if an inner exceptions message is multi lined the message and cause traces should be indented properly reoccurring causes are not expanded over and over multiple exceptions ioreactivexrxjava exceptionstestexception ex at ioreactivexrxjava exceptionscompositeexceptiontestreoccurringexception compositeexceptiontestjava ioreactivexrxjava exceptionstestexception ex at ioreactivexrxjava exceptionscompositeexceptiontestreoccurringexception compositeexceptiontestjava ioreactivexrxjava exceptionstestexception ex at ioreactivexrxjava exceptionscompositeexceptiontestreoccurringexception compositeexceptiontestjava ioreactivexrxjava exceptionstestexception ex at ioreactivexrxjava exceptionscompositeexceptiontestreoccurringexception compositeexceptiontestjava cause not expanded again ioreactivexrxjava exceptionstestexception ex currently only the first line of the stacktraces are shown because it can get quite long and thus memory consuming to list them all maybe a system parameter can be introduced to control the verbosity merging
6754,1,0,0,0,0,1,1,1,zip combinelatest and amb operators throw when supplied with observablesource implementation that doesnt subclass observable please add unit tests so this doesnt happen again in case of any future change merging
6756,1,0,0,1,0,1,1,1,fix observable amb combinelatest & zip arraystoreexception when using iterable of sources the initial array is the wrong type and causes arraystoreexception unit tests were added to verify the other implementations merging
6762,1,0,0,0,0,1,1,1,fix window boundary start end cancel and abandonment this pr fixes the window operator with boundary and start end sources so that cancelling the inner windows allows cancelling the upstream once neither the main output nor other windows are being consumed further ignoring a window still allows cancelling the upstreamfollow up to and merging
6765,1,0,0,0,0,0,1,0,java upgrade to java add flowablefromx operators this pr upgrades rxjava to use and compile with java build target set to animalsniffer set to javadocs link to the official jdk set to implemented operators flowablefromoptional flowablefromcompletionstage flowablefromstream applied safevarargs to many methods created marblesrelated https rawgithubcom wiki reactivex rxjava images rx operators fromoptionalfpng image https rawgithubcom wiki reactivex rxjava images rx operators fromcompletionstagefpng image https rawgithubcom wiki reactivex rxjava images rx operators fromstreamfpng merging
6773,1,0,1,0,0,0,1,0,add functionalinterface annotations merging
6779,1,1,0,1,1,1,1,1,java add blockingstream & flatmapstream to flowable add java interoperation methods to flowable blockingstream essentially blockingiterable with close support concatmapstream map and concatenate streams flatmapstream map and concatenate streams inherently same as concatmapstream related marbles https rawgithubcom wiki reactivex rxjava images rx operators blockingstreamfpng image https rawgithubcom wiki reactivex rxjava images rx operators blockingstreamfipng image https rawgithubcom wiki reactivex rxjava images rx operators concatmapstreamfpng image https rawgithubcom wiki reactivex rxjava images rx operators concatmapstreamfipng image https rawgithubcom wiki reactivex rxjava images rx operators flatmapstreamfpng image https rawgithubcom wiki reactivex rxjava images rx operators flatmapstreamfipng merging
6780,1,0,0,0,0,0,1,0,java add autocloseable disposable conversions nicen docs add disposablesfromautocloseable and disposablestoautocloseable methods improve javadocs styling resolves you could also do javainterface disposable extends autocloseable { boolean isdisposed void dispose default void close { dispose }} merging
6780,1,0,0,0,0,0,1,0,java add autocloseable disposable conversions nicen docs add disposablesfromautocloseable and disposablestoautocloseable methods improve javadocs styling resolves you could also do javainterface disposable extends autocloseable { boolean isdisposed void dispose default void close { dispose }} merging
6783,1,0,0,1,0,1,1,1,java add fromopt stage mapoptional tocompletionstage to m s c add the following java operators to various reactive base classes operator maybe single completable fromoptional fromcompletionstage image image image mapoptional image image tocompletionstage image image tocompletionstage t image image should it be implemented as optionalempty singleerror new nosuchelementexception no reason to implement always completablecomplete no value to map no value to emit thus it is better to ask the user for a completion value never empty no reason to implementrelated marbles image https rawgithubcom wiki reactivex rxjava images rx operators fromoptionalmpng image https rawgithubcom wiki reactivex rxjava images rx operators fromcompletionstagespng image https rawgithubcom wiki reactivex rxjava images rx operators fromcompletionstagecpng image https rawgithubcom wiki reactivex rxjava images rx operators mapoptionalmpng image https rawgithubcom wiki reactivex rxjava images rx operators mapoptionalspng image https rawgithubcom wiki reactivex rxjava images rx operators tocompletionstagempng image https rawgithubcom wiki reactivex rxjava images rx operators tocompletionstagemvpng image https rawgithubcom wiki reactivex rxjava images rx operators tocompletionstagespng image https rawgithubcom wiki reactivex rxjava images rx operators tocompletionstagecpng merging
6786,1,0,0,1,1,1,1,1,diamond operators in unit tests observable package hello in this pull request ive changed all ide marked explicit types with diamond operator affected package is internal operators observable there is one test fail in completabletestrepeatnormal but diamond is not the cause there is last stack entry javalangassertionerror expected but was at orgjunitassertfail assertjava this pr is part of issue resolving merging
6787,1,0,0,1,1,1,1,1,diamond operators in unit tests flowable package hello in this pull request ive changed all ide marked explicit types with diamond operator affected package is internal operators flowable there is one test fail in completabletestrepeatnormal but diamond is not the cause there is last stack entry javalangassertionerror expected but was at orgjunitassertfail assertjava this pr is part of issue resolving
6788,1,0,0,1,1,1,1,1,diamond operators in tests hello in this pull request ive changed all ide marked explicit types with diamond operator affected packages is internal internal operators there is one test fail in completabletestrepeatnormal but diamond is not the cause there is last stack entry javalangassertionerror expected but was at orgjunitassertfail assertjava this pr is part of issue resolving merging
6789,1,1,0,1,1,1,1,1,diamond operators in tests small packages hello in this pull request ive changed all ide marked explicit types with diamond operator affected packages is in tests rootthere is one test fail in completabletestrepeatnormal but diamond is not the cause there is last stack entry javalangassertionerror expected but was at orgjunitassertfail assertjava this pr is part of issue resolving merging
6791,1,0,0,1,0,1,1,1,add nonnull & safevarargs annotations validator this pr cleans up the main classes add missing nonnull annotations add missing safevarargs annotations add validator code that scans the sources to verify the annotations are present remove unnecessary suppresswarnings annotations fix a few type argumentsrelated merging
6797,1,0,0,1,0,1,1,1,java add observable operators cleanup add the following java operators to observable fromoptional fromcompletionstage fromstream firststage firstorerrorstage singestage singleorerrorstage laststage lastorerrorstage blockingstream mapoptional collect concatmapstream flatmapstream in addition some validators received reporting improvements such as using at so the ide can jump to the exact line of the issue consequently all local variable misnaming of unicastsubject up and unicastprocessor us have been as wellrelated marbles merging
6799,1,0,0,0,0,1,1,1,xprocessoroffer to throw npe immediately make offer throw a nullpointerexception immediately instead of turning it into an error signal in addition have multicastprocessoroffer throw an illegalstateexception if called when the processor is in fusion mode merging
6800,1,0,0,0,0,0,1,0,add blockingforeach consumer int overload the underlying blockingiterable already supported the custom prefetch overload and this pr exposes it as a new blockingforeach overloadin addition the javadocs incorrectly stated blockingforeach operated in an unbounded in fashion it uses the usual stable prefetch with re request amount merging
6801,1,0,0,0,0,1,1,1,add missing throwiffatal calls add missing exceptionsthrowiffatal calls in catch throwable blocks add validator that checks for the existence of these throwiffatal wraporthrow or fail calls fix autocloseabledisposable to use wraporthrow like the other disposable wrapper implementations merging
6805,1,0,0,0,0,1,1,0,java add flattenstreamasx to maybe single add maybeflattenstreamasflowable maybeflattenstreamasobservable singleflattenstreamasflowable singleflattenstreamasobservable related in addition adjust the validators to appreciate the new patterns marbles https rawgithubcom wiki reactivex rxjava images rx operators flattenstreamasflowablempng image https rawgithubcom wiki reactivex rxjava images rx operators flattenstreamasobservablempng image https rawgithubcom wiki reactivex rxjava images rx operators flattenstreamasflowablespng image https rawgithubcom wiki reactivex rxjava images rx operators flattenstreamasobservablespng merging
6814,1,0,0,1,0,1,1,1,remove fromfuture scheduler overloads those overloads were only applying subscribeon with no other benefitsresolves merging
6817,1,0,0,0,0,0,1,0,deleted functionsnaturalorder removes a duplication of the natural order comparator merging
6826,1,0,0,0,0,1,1,1,fix flowableflatmap not canceling the inner sources on outer error the outer onerror did not cancel the inner sources the observable variant works correctly but both received an unit test to verify the behavior x will be in a separate prrelated merging
6827,1,0,0,0,0,1,1,1,fix flowableflatmap not canceling the inner sources on outer error the outer onerror did not cancel the inner sources the observable variant works correctly but both received an unit test to verify the behaviorfixes merging
6837,1,0,0,0,0,1,1,1,remove a pointless observableconcatmapiterable overload remove the concatmapiterable function int overload as there is no buffering involved with the operator
6838,1,0,0,1,0,1,1,1,rename to combinelatestarraydelayerror the operator missed a rename with x to match the combinelatestarray variant merging
6839,0,0,0,0,0,1,0,0,enable javac parameter saving in class files related merging
6840,1,0,1,1,0,1,1,0,add nullability annotations to type arguments annotate type argument use with nonnull merging
6843,1,0,0,0,0,1,1,0,improve wording of operators reword sentences with modifies and instructs reword the source x to the current x reword a couple of other operator sentencesrelated merging
6843,1,0,0,0,0,1,1,0,improve wording of operators reword sentences with modifies and instructs reword the source x to the current x reword a couple of other operator sentencesrelated merging
6844,1,0,0,0,0,1,1,0,remove maybeonexceptionresumenext it was always very peculiar to let only checked exceptions resumed merging
6847,1,0,0,0,0,1,1,0,simplify return sentences in flowable javadocs simplify the wording of return in javadocs merging
6853,1,0,0,0,0,1,1,0,fix method argument naming across types make method argument naming consistent between the base reactive classes adjust some of the naming for allin addition the null check was missing from blockingmostrecent the utility program has to be run manually to list the inconsistencies the remaining inconsistency is due to merge because its argument is sources for flowable observable but source for single maybe nested merging
6856,1,0,0,0,0,0,1,0,rename singleequals to singlesequenceequal renamed singleequals to singlesequenceequal and renamed argument names for consistent naming merging
6857,1,0,0,1,0,0,1,0,wiki improve operator matrix with links and notes update the operatormatrixgenerator to add anchors and links to notes about why operators are not present in one or another class operators are missing and will be added as part of merging
6857,1,0,0,1,0,0,1,0,wiki improve operator matrix with links and notes update the operatormatrixgenerator to add anchors and links to notes about why operators are not present in one or another class operators are missing and will be added as part of merging
6860,1,0,0,0,0,1,1,0,add last missing throws tag to javadocs added the last missing throws tag to methods and one missing nonnull annotationi included a small program that will list javadocs without throws for future use merging
6862,1,0,0,0,0,0,1,0,add maybe single completable blockingsubscribe add the missing blockingsubscribe methods to maybe single and completable for symmetry with flowable and observable usually wed like to avoid blocking but now that project loom preview transparently turns latch based awaiting into suspension inside virtual threads they will act as free interop operators for exiting the reactive world into the continuation worldrelated marbles maybe single image completable image https rawgithubcom wiki reactivex rxjava images rx operators completableblockingsubscribepng image https rawgithubcom wiki reactivex rxjava images rx operators completableblockingsubscribeapng image https rawgithubcom wiki reactivex rxjava images rx operators completableblockingsubscribeacpng image https rawgithubcom wiki reactivex rxjava images rx operators completableblockingsubscribeopng merging
6864,1,0,0,1,0,1,1,0,adding delayerror to maybedelay merging
6867,1,0,0,0,0,0,1,0,add onerrorcomplete to flowable observable and single add the onerrorcomplete and onerrorcomplete predicate operators to the remaining base classesalso created the missing marble for maybeonerrorcomplete related https rawgithubcom wiki reactivex rxjava images rx operators flowableonerrorcompletepng image https rawgithubcom wiki reactivex rxjava images rx operators flowableonerrorcompletefpng image https rawgithubcom wiki reactivex rxjava images rx operators observableonerrorcompletepng image https rawgithubcom wiki reactivex rxjava images rx operators observableonerrorcompletefpng image https rawgithubcom wiki reactivex rxjava images rx operators singleonerrorcompletepng image https rawgithubcom wiki reactivex rxjava images rx operators singleonerrorcompletefpng image https rawgithubcom wiki reactivex rxjava images rx operators maybeonerrorcompletepng image https rawgithubcom wiki reactivex rxjava images rx operators maybeonerrorcompletefpng merging
6867,1,0,0,0,0,0,1,0,add onerrorcomplete to flowable observable and single add the onerrorcomplete and onerrorcomplete predicate operators to the remaining base classesalso created the missing marble for maybeonerrorcomplete related https rawgithubcom wiki reactivex rxjava images rx operators flowableonerrorcompletepng image https rawgithubcom wiki reactivex rxjava images rx operators flowableonerrorcompletefpng image https rawgithubcom wiki reactivex rxjava images rx operators observableonerrorcompletepng image https rawgithubcom wiki reactivex rxjava images rx operators observableonerrorcompletefpng image https rawgithubcom wiki reactivex rxjava images rx operators singleonerrorcompletepng image https rawgithubcom wiki reactivex rxjava images rx operators singleonerrorcompletefpng image https rawgithubcom wiki reactivex rxjava images rx operators maybeonerrorcompletepng image https rawgithubcom wiki reactivex rxjava images rx operators maybeonerrorcompletefpng merging
6868,1,0,0,0,0,1,1,1,add completableonerrorresumewith this pr adds the missing completableonerrorresumewith present in the rest of the base classesalso marbles for maybeonerrorresumenext and maybeonerrorresumewith have been updatedrelated https rawgithubcom wiki reactivex rxjava images rx operators completableonerrorresumewithpng image https rawgithubcom wiki reactivex rxjava images rx operators maybeonerrorresumenextpng image https rawgithubcom wiki reactivex rxjava images rx operators maybeonerrorresumewithpng merging
6868,1,0,0,0,0,1,1,1,add completableonerrorresumewith this pr adds the missing completableonerrorresumewith present in the rest of the base classesalso marbles for maybeonerrorresumenext and maybeonerrorresumewith have been updatedrelated https rawgithubcom wiki reactivex rxjava images rx operators completableonerrorresumewithpng image https rawgithubcom wiki reactivex rxjava images rx operators maybeonerrorresumenextpng image https rawgithubcom wiki reactivex rxjava images rx operators maybeonerrorresumewithpng merging
6869,1,0,0,0,0,1,1,0,add single completable retryuntil marbles retryuntil was missing from single and completable added marble for maybe as wellrelated https rawgithubcom wiki reactivex rxjava images rx operators completableretryuntilpng image https rawgithubcom wiki reactivex rxjava images rx operators singleretryuntilpng image https rawgithubcom wiki reactivex rxjava images rx operators mayberetryuntilpng merging
6869,1,0,0,0,0,1,1,0,add single completable retryuntil marbles retryuntil was missing from single and completable added marble for maybe as wellrelated https rawgithubcom wiki reactivex rxjava images rx operators completableretryuntilpng image https rawgithubcom wiki reactivex rxjava images rx operators singleretryuntilpng image https rawgithubcom wiki reactivex rxjava images rx operators mayberetryuntilpng merging
6870,1,0,0,0,0,0,1,0,add maybe single completable switchonnext & switchonnextdelayerror add the missing switchonnext and switchonnextdelayerror operators which are essentially delegated to the respective flowable switchmapx operators with identity mappingrelated https rawgithubcom wiki reactivex rxjava images rx operators completableswitchonnextpng image https rawgithubcom wiki reactivex rxjava images rx operators completableswitchonnextdelayerrorpng image https rawgithubcom wiki reactivex rxjava images rx operators singleswitchonnextpng image https rawgithubcom wiki reactivex rxjava images rx operators singleswitchonnextdelayerrorpng image https rawgithubcom wiki reactivex rxjava images rx operators maybeswitchonnextpng image https rawgithubcom wiki reactivex rxjava images rx operators maybeswitchonnextdelayerrorpng
6871,1,0,0,0,0,1,1,1,add maybedematerialize add the dematerialize operator to maybe to be in sync with the other classesrelated https rawgithubcom wiki reactivex rxjava images rx operators maybedematerializepng merging
6873,1,0,0,1,0,1,1,1,add many fromx operators marbles add a cross section of from operators present fromaction fromsingle operator f o m s c fromaction present notes present namefromcompletable fromcompletable present notes absent notes frommaybe present notes present namefromobservable fromobservable present notes present namefrompublisher frompublisher present namefromrunnable fromrunnable present notes present namefromsingle fromsingle present notes present https rawgithubcom wiki reactivex rxjava images rx operators flowablefromactionpng image https rawgithubcom wiki reactivex rxjava images rx operators flowablefromcompletablepng image https rawgithubcom wiki reactivex rxjava images rx operators flowablefrommaybepng image https rawgithubcom wiki reactivex rxjava images rx operators flowablefromobservablebufferpng image https rawgithubcom wiki reactivex rxjava images rx operators flowablefromobservablelatestpng image https rawgithubcom wiki reactivex rxjava images rx operators flowablefromobservabledroppng image https rawgithubcom wiki reactivex rxjava images rx operators flowablefromobservableerrorpng image https rawgithubcom wiki reactivex rxjava images rx operators flowablefromobservablemissingpng image https rawgithubcom wiki reactivex rxjava images rx operators flowablefromrunnablepng image https rawgithubcom wiki reactivex rxjava images rx operators flowablefromsinglepng image https rawgithubcom wiki reactivex rxjava images rx operators observablefromactionpng image https rawgithubcom wiki reactivex rxjava images rx operators observablefromcompletablepng image https rawgithubcom wiki reactivex rxjava images rx operators observablefrommaybepng image https rawgithubcom wiki reactivex rxjava images rx operators observablefromrunnablepng image https rawgithubcom wiki reactivex rxjava images rx operators observablefromsinglepng image https rawgithubcom wiki reactivex rxjava images rx operators maybefrompublisherpng image https rawgithubcom wiki reactivex rxjava images rx operators maybefromobservablepng image https rawgithubcom wiki reactivex rxjava images rx operators singlefrommaybepng image https rawgithubcom wiki reactivex rxjava images rx operators singlefrommaybevpng merging
6874,1,0,0,0,0,0,1,0,add timeinterval & timestamp to m s add timeinterval and timestamp operators overloads each to maybe and single related https rawgithubcom wiki reactivex rxjava images rx operators maybetimeintervalpng image https rawgithubcom wiki reactivex rxjava images rx operators maybetimeintervalspng image https rawgithubcom wiki reactivex rxjava images rx operators maybetimestamppng image https rawgithubcom wiki reactivex rxjava images rx operators maybetimestampspng image https rawgithubcom wiki reactivex rxjava images rx operators singletimeintervalpng image https rawgithubcom wiki reactivex rxjava images rx operators singletimeintervalspng image https rawgithubcom wiki reactivex rxjava images rx operators singletimestamppng image https rawgithubcom wiki reactivex rxjava images rx operators singletimestampspng merging
6875,1,0,0,0,0,0,1,0,add maybe completable tofuture add tofuture to maybe and completable related https githubcom reactivex rxjava wiki images rx operators maybetofuturepng image https githubcom reactivex rxjava wiki images rx operators completabletofuturepng merging
6876,1,1,0,1,1,1,1,1,add singleoftype add oftype to single already available to the other non empty base typesrelated addition diagrams for maybefilter and maybeoftype have been updated image merging
6876,1,1,0,1,1,1,1,1,add singleoftype add oftype to single already available to the other non empty base typesrelated addition diagrams for maybefilter and maybeoftype have been updated image merging
6877,1,0,0,0,0,1,1,1,add doonlifecycle to maybe single & completable add the doonlifecycle operator to the remaining classesrelated https rawgithubcom wiki reactivex rxjava images rx operators maybedoonlifecyclepng image https rawgithubcom wiki reactivex rxjava images rx operators singledoonlifecyclepng image https rawgithubcom wiki reactivex rxjava images rx operators completabledoonlifecyclepng merging
6879,1,0,0,1,0,1,1,0,add concatmapx operators aliases add the following operator aliases maybeconcatmapcompletable maybeconcatmapsingle singleconcatmapcompletable singleconcatmap singleconcatmapmaybe related addition some missing or wrong maybe marbles have been image https rawgithubcom wiki reactivex rxjava images rx operators maybeconcatmappng image https rawgithubcom wiki reactivex rxjava images rx operators maybeflatmapcompletable png image https rawgithubcom wiki reactivex rxjava images rx operators maybeflatmapsingle png image https rawgithubcom wiki reactivex rxjava images rx operators maybeflatmapsingleelementpng merging
6881,1,0,0,1,0,1,1,1,add various concatxdelayerror operators add the following concat kind of operators maybeconcatarrayeagerdelayerror maybeconcatdelayerror publisher int singleconcatarraydelayerror singleconcatarrayeagerdelayerror singleconcatdelayerror completableconcatarraydelayerror completableconcatdelayerror related addition the maybeconcatdelayerror publisher marble has been image https rawgithubcom wiki reactivex rxjava images rx operators maybeconcatdelayerror ipng merging
6882,1,0,0,0,0,0,1,0,add singlemergearray & mergearraydelayerror single was missing the mergearray and mergearraydelayerror operators already present in the other classesrelated https rawgithubcom wiki reactivex rxjava images rx operators singlemergearraypng image https rawgithubcom wiki reactivex rxjava images rx operators singlemergearraydelayerrorpng merging
6884,1,0,0,0,0,1,1,0,add completablesequenceequal the operator was available in all other classesrelated https rawgithubcom wiki reactivex rxjava images rx operators completablesequenceequalpng merging
6885,1,0,0,0,0,0,1,0,add missing startwith overloads add missing add startwith overloads source \ other f o m s c flowable present absent add add add absent present add add add add add add add add add add add add add present present add add present https rawgithubcom wiki reactivex rxjava images rx operators flowablestartwithmpng image https rawgithubcom wiki reactivex rxjava images rx operators flowablestartwithspng image https rawgithubcom wiki reactivex rxjava images rx operators flowablestartwithcpng image https rawgithubcom wiki reactivex rxjava images rx operators observablestartwithmpng image https rawgithubcom wiki reactivex rxjava images rx operators observablestartwithspng image https rawgithubcom wiki reactivex rxjava images rx operators observablestartwithcpng image https rawgithubcom wiki reactivex rxjava images rx operators maybestartwithppng image https rawgithubcom wiki reactivex rxjava images rx operators maybestartwithopng image https rawgithubcom wiki reactivex rxjava images rx operators maybestartwithmpng image https rawgithubcom wiki reactivex rxjava images rx operators maybestartwithspng image https rawgithubcom wiki reactivex rxjava images rx operators maybestartwithcpng image https rawgithubcom wiki reactivex rxjava images rx operators singlestartwithppng image https rawgithubcom wiki reactivex rxjava images rx operators singlestartwithopng image https rawgithubcom wiki reactivex rxjava images rx operators singlestartwithmpng image https rawgithubcom wiki reactivex rxjava images rx operators singlestartwithspng image https rawgithubcom wiki reactivex rxjava images rx operators singlestartwithcpng image https rawgithubcom wiki reactivex rxjava images rx operators completablestartwithmpng image https rawgithubcom wiki reactivex rxjava images rx operators completablestartwithspng merging
6886,1,0,0,0,0,1,1,0,add completableonerrorreturn item the operators were already available elsewhererelated addition the maybe variants have received updated marbles as well image merging
6886,1,0,0,0,0,1,1,0,add completableonerrorreturn item the operators were already available elsewhererelated addition the maybe variants have received updated marbles as well image merging
6887,1,0,0,1,0,1,1,1,add safesubscribe to maybe single & completable add the final missing method safesubscribe to maybe single & completable merging
6888,1,0,0,0,0,1,1,0,use more appropriate operators when delegating to flowable ops many single and maybe operators delegate to flowable operators this pr makes sure they use the most appropriate ones since there are single and maybe specific operators on flowable for some time nowsome concatenating non delayed single operators now use the flowableconcatmapsingledelayerror functionsidentity false because an array or iterable of single s cant just throw anytime like a publisher s publisher could hence a delay error until boundary mode works the same but without the extra coordination of the more general publisher variant completable didnt have any delegation required changing merging
6890,1,1,1,0,0,0,1,0,fix marble dimensions add program that checks them also added diagrams missing diagram wrongly exported image https rawgithubcom wiki reactivex rxjava images rx operators completableconcatarraydelayerrorpng merging
6891,1,0,0,0,0,1,1,0,swap maybeflatmapsingle and maybeflatmapsingleelement dropped the old maybeflatmapsingle and replaced it with maybeflatmapsingleelement hmm for xflatmaptestmaybesingle if i replace flatmapsingle tosingle with tosingle flatmap then the test will pass the test checks if disposing while in the function the returned single never gets subscribed to and thus no error is signaled to the downstream or the global error handler put an ignore on it for now and ill look into the operator tomorrow merging
6893,1,0,0,0,0,1,1,0,reenable xflatmaptestmaybesingle add missing single operators reenable the xflatmaptestmaybesingle and make sure all flatmap variants behave the same when the flow is cancelled disposed while the mapper function is executing thus the returned inner source doesnt get subscribed to at all while adding the extra tests i noticed two flatmap variant is missing from single a combiner of the original and inner success item flatmap function bifunction a notification type mapper flatmap function function the same combiner variant for maybe received a marble diagram too image merging
6893,1,0,0,0,0,1,1,0,reenable xflatmaptestmaybesingle add missing single operators reenable the xflatmaptestmaybesingle and make sure all flatmap variants behave the same when the flow is cancelled disposed while the mapper function is executing thus the returned inner source doesnt get subscribed to at all while adding the extra tests i noticed two flatmap variant is missing from single a combiner of the original and inner success item flatmap function bifunction a notification type mapper flatmap function function the same combiner variant for maybe received a marble diagram too image merging
6897,1,0,0,0,0,0,1,0,add remaining maybe marbles https rawgithubcom wiki reactivex rxjava images rx operators maybeambwithpng image https rawgithubcom wiki reactivex rxjava images rx operators maybeblockinggetpng image https rawgithubcom wiki reactivex rxjava images rx operators maybeblockinggetvpng image https rawgithubcom wiki reactivex rxjava images rx operators maybecachepng image https rawgithubcom wiki reactivex rxjava images rx operators maybecomposepng image https rawgithubcom wiki reactivex rxjava images rx operators maybeconcatwithpng image https rawgithubcom wiki reactivex rxjava images rx operators maybecountpng image https rawgithubcom wiki reactivex rxjava images rx operators maybedefaultifemptypng image https rawgithubcom wiki reactivex rxjava images rx operators maybedelayppng image https rawgithubcom wiki reactivex rxjava images rx operators maybedelaytpng image https rawgithubcom wiki reactivex rxjava images rx operators maybedelaytbpng image https rawgithubcom wiki reactivex rxjava images rx operators maybedelaytspng image https rawgithubcom wiki reactivex rxjava images rx operators maybedelaytsbpng image https rawgithubcom wiki reactivex rxjava images rx operators maybedoaftersuccesspng image https rawgithubcom wiki reactivex rxjava images rx operators maybedoafterterminatepng image https rawgithubcom wiki reactivex rxjava images rx operators maybedofinallypng image https rawgithubcom wiki reactivex rxjava images rx operators maybedoondisposepng image https rawgithubcom wiki reactivex rxjava images rx operators maybedoonsubscribepng image https rawgithubcom wiki reactivex rxjava images rx operators maybedoonterminatepng image https rawgithubcom wiki reactivex rxjava images rx operators maybeflatmapobservablepng image https rawgithubcom wiki reactivex rxjava images rx operators maybeflatmappublisherpng image https rawgithubcom wiki reactivex rxjava images rx operators maybeisemptypng image https rawgithubcom wiki reactivex rxjava images rx operators maybemergewithpng image https rawgithubcom wiki reactivex rxjava images rx operators mayberepeatnpng image https rawgithubcom wiki reactivex rxjava images rx operators mayberepeatpng image https rawgithubcom wiki reactivex rxjava images rx operators mayberepeatuntilpng image https rawgithubcom wiki reactivex rxjava images rx operators mayberepeatwhenpng image https rawgithubcom wiki reactivex rxjava images rx operators mayberetryfpng image https rawgithubcom wiki reactivex rxjava images rx operators mayberetrygpng image https rawgithubcom wiki reactivex rxjava images rx operators mayberetrynpng image https rawgithubcom wiki reactivex rxjava images rx operators mayberetrynfpng image https rawgithubcom wiki reactivex rxjava images rx operators mayberetrypng image https rawgithubcom wiki reactivex rxjava images rx operators mayberetrywhenpng image https rawgithubcom wiki reactivex rxjava images rx operators maybeswitchifemptympng image https rawgithubcom wiki reactivex rxjava images rx operators maybeswitchifemptyspng image https rawgithubcom wiki reactivex rxjava images rx operators maybetakeuntilmpng image https rawgithubcom wiki reactivex rxjava images rx operators maybetakeuntilppng image https rawgithubcom wiki reactivex rxjava images rx operators maybetimeoutmpng image https rawgithubcom wiki reactivex rxjava images rx operators maybetimeoutmmpng image https rawgithubcom wiki reactivex rxjava images rx operators maybetimeoutppng image https rawgithubcom wiki reactivex rxjava images rx operators maybetimeoutpmpng image https rawgithubcom wiki reactivex rxjava images rx operators maybetimeouttpng image https rawgithubcom wiki reactivex rxjava images rx operators maybetimeouttmpng image https rawgithubcom wiki reactivex rxjava images rx operators maybetimeouttspng image https rawgithubcom wiki reactivex rxjava images rx operators maybetimeouttsmpng image https rawgithubcom wiki reactivex rxjava images rx operators maybetopng image https rawgithubcom wiki reactivex rxjava images rx operators maybetoflowablepng image https rawgithubcom wiki reactivex rxjava images rx operators maybetoobservablepng image https rawgithubcom wiki reactivex rxjava images rx operators maybetosinglepng merging
6899,1,0,0,0,0,0,1,0,add concateagerdelayerror across flowable observable maybe and single now have a concateagerdelayerror delegating to the appropriate concatmapeagerdelayerror operatorin addition maybe and single received an overload concateager iterable int to expose the maxconcurrency option already present in the rest of the typesnote that completableconcateagerdelayerror is essentially the same as mergedelayerror because there are no items to keep emitting in order the flowable and observable variant of concateager also received fresh marble diagrams related flowable observable image maybe image single image https rawgithubcom wiki reactivex rxjava images rx operators singleconcateagerinpng image https rawgithubcom wiki reactivex rxjava images rx operators singleconcateagerpnpng image https rawgithubcom wiki reactivex rxjava images rx operators singleconcateagerdelayerroripng image https rawgithubcom wiki reactivex rxjava images rx operators singleconcateagerdelayerrorinpng image https rawgithubcom wiki reactivex rxjava images rx operators singleconcateagerdelayerrorppng image https rawgithubcom wiki reactivex rxjava images rx operators singleconcateagerdelayerrorpnpng merging
6921,1,0,0,1,0,1,1,1,fix replay not resetting when the connection is disposed disposing a replay based connectable should reset the operator to its fresh state this was supposed to happen but the relevant code changes were not enabled the pr fixes this for both flowable and observable based implementationsthe publish based connectables work as intended merging
6960,1,0,0,0,0,1,1,1,fix observableflatmap with maxconcurrency hangs just a backport to x of the fix for the scalar queue max concurrency issue already for x in the code for the fix has been added and also the test for itin addition as was also done for the corresponding test for flowableflatmap has been added merging
6969,1,0,0,1,0,1,1,1,allow setting the drift tolerance timeunit via system property adds the new system property rx schedulerdrift tolerance unit to allow specifying a more fine grained tolerance amount merging
6996,1,0,0,1,1,1,1,1,suppress undeliverableexception handling in tests i used a junit testrule to suppress handling of undeliverableexception for test methods annotated with suppressundeliverable this approach is coarser than the suggested approach it suppresses the handling of all undeliverableexceptions for the entire annotated test method i thought this approach was clean but i can switch to the suggested approach if preferredi added suppressundeliverable to most tests that were logging undeliverableexceptions with the test method in the stack trace this may be more suppression than was required so just let me know merging
7028,1,0,0,0,0,1,1,1,allow mbe in flowablegroupbytestissue runpart noevict issue above test can probabilistically throw an exception thus above assertion would be invalid i have removed the invalid assertion merging
7033,1,0,0,0,0,0,1,0,{flowableobservable}collect collector contravariant on t added super twice would compilation errors task compilejava home travis build reactivex rxjava src main java io reactivex rxjava core flowablejava error cannot infer type arguments for flowablecollectwithcollectorsingle return rxjavapluginsonassembly new flowablecollectwithcollectorsingle this collector ^ reason inferred type does not conform to equality constraint s inferred cap equality constraints s cap t where t is a type variable t extends object declared in class flowable where cap is a fresh type variable cap extends object super t from capture of super t home travis build reactivex rxjava src main java io reactivex rxjava core observablejava error cannot infer type arguments for observablecollectwithcollectorsingle return rxjavapluginsonassembly new observablecollectwithcollectorsingle this collector ^ reason inferred type does not conform to equality constraint s inferred cap equality constraints s cap t where t is a type variable t extends object declared in class observable where cap is a fresh type variable cap extends object super t from capture of super t errors hehe i thought i would get away with not even compiling the sources merging
7040,1,0,0,0,0,1,1,1,fix map conditional chain causing npe fix the case when an async fused filter map filter chain does not handle the null indicator in its conditional path inside map ❤️ wow so happy with the turnaround on this merging
7049,1,0,0,0,0,1,1,1,fix observablewindow size skip overlap dispose behavior disposing the main output of the observablewindow operator did not properly propagate the dispose call under certain circumstances such as no current active window or the window s were abandoned immediately merging
7080,1,0,0,0,0,0,1,0,change a method name to make consistent with pr thank you for contributing to rxjava before pressing the create pull request button please consider the following points please give a description about what and why you are contributing even if its trivialin a method name flowablezipiterableerror is changed to fail but its similar class observablezipiterable was not changedi changed it for consistency please include the issue list number s or other pr numbers in the description if you are contributing in response to thosethis pr is related to please include a reasonable set of unit tests if you contribute new code or change an existing one if you contribute an operator if applicable please make sure you have tests for working with an empty just range of values as well as an error source with and or without backpressure and see if unsubscription cancellation propagates correctlythis change will not affect external behavior merging
7126,1,0,0,0,0,1,1,1,improve error messages in the test consumers this pr improves the error messages reported in the testobserver and testsubscriber assertvalue predicate now shows the value that didnt pass the predicate assertvalueat index t if the index is out of range the message includes the valid range the message now includes the index argument where the failure happened assertvalueat index predicate if the index is out of range the message includes the valid range shows the value at index that didnt pass the predicate the message now includes the index argument where the failure happened asserterror predicate is now worded to indicate the exception did not pass the predicatein addition the verification tests for the error messages were not actually testing the error message with assertthrows and have been updated merging
7144,1,0,0,0,0,0,1,0,update marbles of amb ambarray and ambwith update the marble diagrams in flowable and observable indicating cancellation of the non winners https rawgithubcom wiki reactivex rxjava images rx operators flowableambpng image https rawgithubcom wiki reactivex rxjava images rx operators flowableambarraypng image https rawgithubcom wiki reactivex rxjava images rx operators flowableambwithpng image https rawgithubcom wiki reactivex rxjava images rx operators observableambpng image https rawgithubcom wiki reactivex rxjava images rx operators observableambarraypng image https rawgithubcom wiki reactivex rxjava images rx operators observableambwithpng merging
7163,1,0,0,0,0,1,1,1,testscheduler option to use onschedule hook the testscheduler is a bit inconsistent regarding the use of rxjavapluginsonschedule it extends scheduler so the scheduledirect methods do invoke the hook whereas the workers schedule methods dontthis pr adds a constructor flag to enable the use of the hook in the workers schedule methods as well this addition should avoid issues with existing tests not expecting the hook to be invoked all of a sudden merging
7164,1,0,0,0,0,0,1,0,updating documentation for scheduleactual method remove unnecessary sentence from newthreadworkerscheduleactual merging
7165,1,1,0,1,1,1,1,1,add fusion support to concatmap{maybesinglecompletable} this pr adds front fusion support to flowableconcatmapcompletable flowableconcatmapmaybe flowableconcatmapsingle observableconcatmapcompletable observableconcatmapmaybe observableconcatmapsingle the operators have been tidied up by factoring out common code pathsin addition the deferredscalarsubscription s fusion emission had to be in async fusion mode onnext null is generally expected from the upstream but deferredscalarsubscription sent the value itself now it correctly sends null deferredscalardisposable already did this correctly merging
7170,1,0,0,1,0,1,1,1,introduce property rx scheduleruse otime akarnokd i had to create a new schedulertest class because on the x branch the package did not match the package of scheduler therefore i could not access the field package private merging
7191,1,0,0,1,0,1,1,0,add onsubscribe hook to parallelflowable operators parallel operators were missing an rxjavapluginsonsubscribe hook merging
7196,1,0,0,0,0,0,1,0,allow singlezip and maybezip result to be garbage collected akarnokd sorry hit re review accidentally merging
7203,1,0,0,0,0,1,1,1,fix schedulersfrom to honor interruptibleworker across methods the direct scheduling methods of the executorscheduler created via schedulersfrom executor boolean did not fully honor the interruptibleworker settings merging
7212,1,0,0,0,0,0,1,0,compositeexceptionprintstacktrace to write directly into printstream printwriter i dont remember why the stacktrace it wasnt printed directly via the printstream printwriter no reason to aggregate the entire string outputfixes merging
