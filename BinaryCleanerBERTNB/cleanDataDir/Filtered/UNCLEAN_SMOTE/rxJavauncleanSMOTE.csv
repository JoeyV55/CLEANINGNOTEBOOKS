prNumber,Util,Network,Interpreter,i18n,Logic,Test,IO,App,corpus
138,1,0,0,0,0,0,1,0,implemented sequenceequal operator fixes issue #76since there is no direct analogue of `iequalitycomparer` in java `func2<t t boolean>` has been used nice and great use of the zip operator! || thank you again @mairbek  ||
138,1,0,1,0,0,0,1,0,implemented sequenceequal operator fixes issue #76since there is no direct analogue of `iequalitycomparer` in java `func2<t t boolean>` has been used nice and great use of the zip operator! || thank you again @mairbek  ||
138,1,0,1,0,0,1,1,1,implemented sequenceequal operator fixes issue #76since there is no direct analogue of `iequalitycomparer` in java `func2<t t boolean>` has been used nice and great use of the zip operator! || thank you again @mairbek  ||
146,1,0,0,0,0,0,1,0,merge of pull #125 for issue #87 operator takewhile manually merging  from @mairbek implementation of  done by @mairbek ive run the unit tests locally and reviewed the code while doing the manual merge looks good so merging into master branch ||
146,1,0,1,0,0,1,1,1,merge of pull #125 for issue #87 operator takewhile manually merging  from @mairbek implementation of  done by @mairbek ive run the unit tests locally and reviewed the code while doing the manual merge looks good so merging into master branch ||
146,1,0,1,0,0,0,1,0,merge of pull #125 for issue #87 operator takewhile manually merging  from @mairbek implementation of  done by @mairbek ive run the unit tests locally and reviewed the code while doing the manual merge looks good so merging into master branch ||
146,1,0,0,0,0,0,1,0,merge of pull #125 for issue #87 operator takewhile manually merging  from @mairbek implementation of  done by @mairbek ive run the unit tests locally and reviewed the code while doing the manual merge looks good so merging into master branch ||
146,1,0,1,0,0,1,1,1,merge of pull #125 for issue #87 operator takewhile manually merging  from @mairbek implementation of  done by @mairbek ive run the unit tests locally and reviewed the code while doing the manual merge looks good so merging into master branch ||
146,1,0,0,1,1,1,1,1,merge of pull #125 for issue #87 operator takewhile manually merging  from @mairbek implementation of  done by @mairbek ive run the unit tests locally and reviewed the code while doing the manual merge looks good so merging into master branch ||
156,1,0,0,0,0,0,1,0,implemented toiterable operation for issue #18this would allow to implement other blocking methods like `single` `lastordefault` next this looks good merging ||
156,1,0,1,0,0,1,1,1,implemented toiterable operation for issue #18this would allow to implement other blocking methods like `single` `lastordefault` next this looks good merging ||
156,1,0,1,0,0,1,1,1,implemented toiterable operation for issue #18this would allow to implement other blocking methods like `single` `lastordefault` next this looks good merging ||
165,1,0,0,0,0,0,1,0, bug in ranges  issue #164 #3 
165,1,0,1,0,0,0,1,0, bug in ranges  issue #164 #3 
165,1,0,0,1,1,1,1,1, bug in ranges  issue #164 #3 
205,1,0,0,0,0,0,1,0,reimplementation of concat improved handling of observable<observable<t >>the old version required all of the observable<t>s to be generated and bufferedbefore the concat could begin  if the outer observable was asynchronous itemscould be dropped (test added)  the new version passes the test and does thebest job i could (after examining several possible strategies) of achievingclear and consistent semantics in accordance with the principle of leastsurprise(my attempt to  #202) #45] there is another issue with this implementation  the countdown latch will always block the calling thread which is not desirable  anything that returns an observable should never be blocking  rx is meant to support composition of operations and allows each operation to run concurrently || while reviewing this i started playing with the unit tests and added 2 new ones i also made them use inorderverify so they ensure correct ordering ive pasted it below so you can merge into your branch instead of me complicating the merge with another branch the tests pass pass except `testconcatunsubscribe` which deadlocks it does this because a list<observable> wont return the subscription asynchronously so it cant unsubscribe meanwhile a countdownlatch is waiting for the change to trigger and the two latches end up waiting on each otheri havent thought through enough yet to determine if there is a way to solve that or if the unit test is just testing the wrong thing and thus a bad testthe comment above from @billy about countdownlatch originated from a discussion between him and i - but while reviewing this it is probably the right approachi was playing with other approaches that are purely non-blocking while retaining the correct concat sequential behavior but they all seem to require either:- another wrapping thread- stealing work from one of the child observable threads and making it do work that is queued on the others  and that seems like a bad idea even though it can be hacked to "work" but it does so in a way that is very unexpected and thus not something i want to pursue- queueing all onnext values which could be a bad memory issue  and also means we eagerly subscribe which is not what we wantmy biggest issue right now is that concat(o1 o2) is a very common usage but that results in list<observable> which will be blocking and unsubscribe doesnt workill think through this more but id appreciate your thoughts on how to handle `testconcatunsubscribe` ``` java    public static class unittest {        @test        public void testconcat() {            @suppresswarnings("unchecked")            observer<string> observer  mock(observerclass)            final string o  { "1" "3" "5" "7" }            final string e  { "2" "4" "6" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            @suppresswarnings("unchecked")            observable<string> concat  observablecreate(concat(odds even))            concatsubscribe(observer)            verify(observer times(7))onnext(anystring())        }        @test        public void testconcatwithlist() {            @suppresswarnings("unchecked")            observer<string> observer  mock(observerclass)            final string o  { "1" "3" "5" "7" }            final string e  { "2" "4" "6" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            final list<observable<string>> list  new arraylist<observable<string>>()            listadd(odds)            listadd(even)            observable<string> concat  observablecreate(concat(list))            concatsubscribe(observer)            verify(observer times(7))onnext(anystring())        }        @test        public void testconcatunsubscribe() {            final countdownlatch callonce  new countdownlatch(1)            final countdownlatch oktocontinue  new countdownlatch(1)            final testobservable<string> w1  new testobservable<string>("one" "two" "three")            final testobservable<string> w2  new testobservable<string>(callonce oktocontinue "four" "five" "six")            @suppresswarnings("unchecked")            observer<string> aobserver  mock(observerclass)            @suppresswarnings("unchecked")            observable<string> concat  observablecreate(concat(w1 w2))            systemoutprintln("before subscribe")            subscription s1  concatsubscribe(aobserver)            systemoutprintln("after subscribe")            try {                //block main thread to allow observable "w1" to complete and observable "w2" to call onnext once                systemoutprintln("before callonceawait")                callonceawait()                systemoutprintln("after callonceawait")                s1unsubscribe()                systemoutprintln("after s1unsubscribe")                //unblock the observable to continue                oktocontinuecountdown()                systemoutprintln("after countdown")                w1tjoin()                w2tjoin()            } catch (exception e) {                eprintstacktrace()                fail(egetmessage())            }            inorder inorder  inorder(aobserver)            inorderverify(aobserver times(1))onnext("one")            inorderverify(aobserver times(1))onnext("two")            inorderverify(aobserver times(1))onnext("three")            inorderverify(aobserver times(1))onnext("four")            inorderverify(aobserver never())onnext("five")            inorderverify(aobserver never())onnext("six")            inorderverify(aobserver times(1))oncompleted()        }        @test        public void testmergeobservableofobservables() {            @suppresswarnings("unchecked")            observer<string> observer  mock(observerclass)            final string o  { "1" "3" "5" "7" }            final string e  { "2" "4" "6" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {                @override                public subscription call(observer<observable<string>> observer) {                    // simulate what would happen in an observable                    observeronnext(odds)                    observeronnext(even)                    observeroncompleted()                    return new subscription() {                        @override                        public void unsubscribe() {                            // unregister  will never be called here since we are executing synchronously                        }                    }                }            })            observable<string> concat  observablecreate(concat(observableofobservables))            concatsubscribe(observer)            verify(observer times(7))onnext(anystring())        }        /**         * simple concat of 2 asynchronous observables ensuring it emits in correct order         */        @suppresswarnings("unchecked")        @test        public void testsimpleasyncconcat() {            observer<string> observer  mock(observerclass)            testobservable<string> o1  new testobservable<string>("one" "two" "three")            testobservable<string> o2  new testobservable<string>("four" "five" "six")            observableconcat(o1 o2)subscribe(observer)            try {                // wait for async observables to complete                o1tjoin()                o2tjoin()            } catch (exception e) {                throw new runtimeexception("failed waiting on threads")            }            inorder inorder  inorder(observer)            inorderverify(observer times(1))onnext("one")            inorderverify(observer times(1))onnext("two")            inorderverify(observer times(1))onnext("three")            inorderverify(observer times(1))onnext("four")            inorderverify(observer times(1))onnext("five")            inorderverify(observer times(1))onnext("six")        }        /**         * test an async observable that emits more async observables         */        @suppresswarnings("unchecked")        @test        public void testnestedasyncconcat() throws exception {            observer<string> observer  mock(observerclass)            final testobservable<string> o1  new testobservable<string>("one" "two" "three")            final testobservable<string> o2  new testobservable<string>("four" "five" "six")            final testobservable<string> o3  new testobservable<string>("seven" "eight" "nine")            final countdownlatch allowthird  new countdownlatch(1)            final atomicreference<thread> parent  new atomicreference<thread>()            observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {                @override                public subscription call(final observer<observable<string>> observer) {                    final booleansubscription s  new booleansubscription()                    parentset(new thread(new runnable() {                        @override                        public void run() {                            try {                                // emit first                                if (!sisunsubscribed()) {                                    systemoutprintln("emit o1")                                    observeronnext(o1)                                }                                // emit second                                if (!sisunsubscribed()) {                                    systemoutprintln("emit o2")                                    observeronnext(o2)                                }                                // wait until sometime later and emit third                                try {                                    allowthirdawait()                                } catch (interruptedexception e) {                                    observeronerror(e)                                }                                if (!sisunsubscribed()) {                                    systemoutprintln("emit o3")                                    observeronnext(o3)                                }                            } catch (exception e) {                                observeronerror(e)                            } finally {                                systemoutprintln("done parent observable")                                observeroncompleted()                            }                        }                    }))                    parentget()start()                    return s                }            })            observablecreate(concat(observableofobservables))subscribe(observer)            // wait for parent to start            while (parentget()  null) {                threadsleep(1)            }            try {                // wait for first 2 async observables to complete                while (o1t  null) {                    threadsleep(1)                }                systemoutprintln("thread1 started  waiting for it to complete ")                o1tjoin()                while (o2t  null) {                    threadsleep(1)                }                systemoutprintln("thread2 started  waiting for it to complete ")                o2tjoin()            } catch (exception e) {                throw new runtimeexception("failed waiting on threads" e)            }            inorder inorder  inorder(observer)            inorderverify(observer times(1))onnext("one")            inorderverify(observer times(1))onnext("two")            inorderverify(observer times(1))onnext("three")            inorderverify(observer times(1))onnext("four")            inorderverify(observer times(1))onnext("five")            inorderverify(observer times(1))onnext("six")            // we shouldnt have the following 3 yet            inorderverify(observer never())onnext("seven")            inorderverify(observer never())onnext("eight")            inorderverify(observer never())onnext("nine")            // we should not be completed yet            verify(observer never())oncompleted()            verify(observer never())onerror(any(exceptionclass))            // now allow the third            allowthirdcountdown()            try {                while (o3t  null) {                    threadsleep(1)                }                // wait for 3rd to complete                o3tjoin()            } catch (exception e) {                throw new runtimeexception("failed waiting on threads" e)            }            inorderverify(observer times(1))onnext("seven")            inorderverify(observer times(1))onnext("eight")            inorderverify(observer times(1))onnext("nine")            inorderverify(observer times(1))oncompleted()            verify(observer never())onerror(any(exceptionclass))        }        @suppresswarnings("unchecked")        @test        public void testblockedobservableofobservables() {            observer<string> observer  mock(observerclass)            final string o  { "1" "3" "5" "7" }            final string e  { "2" "4" "6" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            final countdownlatch callonce  new countdownlatch(1)            final countdownlatch oktocontinue  new countdownlatch(1)            testobservable<observable<string>> observableofobservables  new testobservable<observable<string>>(callonce oktocontinue odds even)            func1<observer<string> subscription> concatf  concat(observableofobservables)            observable<string> concat  observablecreate(concatf)            concatsubscribe(observer)            try {                //block main thread to allow observables to serve up o1                callonceawait()            } catch (exception ex) {                exprintstacktrace()                fail(exgetmessage())            }            // the concated observable should have served up all of the odds            verify(observer times(1))onnext("1")            verify(observer times(1))onnext("3")            verify(observer times(1))onnext("5")            verify(observer times(1))onnext("7")            try {                // unblock observables so it can serve up o2 and complete                oktocontinuecountdown()                observableofobservablestjoin()            } catch (exception ex) {                exprintstacktrace()                fail(exgetmessage())            }            // the concatenated observable should now have served up all the evens            verify(observer times(1))onnext("2")            verify(observer times(1))onnext("4")            verify(observer times(1))onnext("6")        }        private static class testobservable<t> extends observable<t> {            private final subscription s  new subscription() {                @override                public void unsubscribe() {                    subscribed  false                }            }            private final list<t> values            private thread t  null            private int count  0            private boolean subscribed  true            private final countdownlatch once            private final countdownlatch oktocontinue            public testobservable(t values) {                this(null null values)            }            public testobservable(countdownlatch once countdownlatch oktocontinue t values) {                thisvalues  arraysaslist(values)                thisonce  once                thisoktocontinue  oktocontinue            }            @override            public subscription subscribe(final observer<t> observer) {                t  new thread(new runnable() {                    @override                    public void run() {                        try {                            while (count < valuessize() && subscribed) {                                observeronnext(valuesget(count))                                count++                                //unblock the main thread to call unsubscribe                                if (null ! once)                                    oncecountdown()                                //block until the main thread has called unsubscribe                                if (null ! once)                                    oktocontinueawait()                            }                            if (subscribed)                                observeroncompleted()                        } catch (interruptedexception e) {                            eprintstacktrace()                            fail(egetmessage())                        }                    }                })                tstart()                return s            }        }    }``` || thanks for the comments and the extra tests i have merged them anduploaded a new versionregarding testconcatunsubscribe: im still not entirely sure of my footingbut i believe the test is in error it is demonstrating exactly the issuewhich i mentioned in the new javadoc for operationconcat specifically itsets up a situation wherein the inner observables thread is blocked on theouter observables thread: the inner thread cannot proceed until the testcalls oktocontinuecountdown() which happens-afterconcatsubscribe(aobserver) which blocks until the list has delivered bothw1 and w2am i right that in general an observer should block onnext() until it hasfinished processing the item? this pushes the flow-control upstream ratherthan excessive buffering or throttling (which can be done explicitly in theoperation-chain if desired) if thats right then i think concat mustblock the outer onnext until it has finished servicing the inner sequencei do find it a little strange that observablefrom(iterable) is a "shotgunobservable" ie the subscribe() blocks until all downstream operationshave completed on all items which means it is impossible to everunsubscribe() but given that this is correct behavior i think that itmakes sense that concat(o1 o2) also cannot be unsubscribed-from i added acautionary comment to the javadoci have updated the test case to call concatsubscribe(aobserver) in abackground thread which fixes the deadlock and to expect all items to bedelivered despite an unsubscribe which makes the test pass(i had also tried those three non-blocking approaches before uploading thisversion thanks for checking my work :)on mar 27 2013 6:56 am "ben christensen" notifications@githubcom wrote:> while reviewing this i started playing with the unit tests and added 2 new> ones i also made them use inorderverify so they ensure correct ordering> ive pasted it below so you can merge into your branch instead of me> complicating the merge with another branch> > the tests pass pass except testconcatunsubscribe which deadlocks it does> this because a list wont return the subscription asynchronously so it> cant unsubscribe meanwhile a countdownlatch is waiting for the change to> trigger and the two latches end up waiting on each other> > i havent thought through enough yet to determine if there is a way to> solve that or if the unit test is just testing the wrong thing and thus a> bad test> > the comment above from @billy  about> countdownlatch originated from a discussion between him and i - but while> reviewing this it is probably the right approach> > i was playing with other approaches that are purely non-blocking while> retaining the correct concat sequential behavior but they all seem to> require either:> - another wrapping thread> - stealing work from one of the child observable threads and making it>   do work that is queued on the others  and that seems like a bad idea>   even though it can be hacked to "work" but it does so in a way that is very>   unexpected and thus not something i want to pursue> - queueing all onnext values which could be a bad memory issue  and>   also means we eagerly subscribe which is not what we want> > my biggest issue right now is that concat(o1 o2) is a very common usage> but that results in list which will be blocking and unsubscribe doesnt> work> > ill think through this more but id appreciate your thoughts on how to> handle testconcatunsubscribe> > ```> public static class unittest {> >     @test>     public void testconcat() {>         @suppresswarnings("unchecked")>         observer<string> observer  mock(observerclass)> >         final string o  { "1" "3" "5" "7" }>         final string e  { "2" "4" "6" }> >         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)> >         @suppresswarnings("unchecked")>         observable<string> concat  observablecreate(concat(odds even))>         concatsubscribe(observer)> >         verify(observer times(7))onnext(anystring())>     }> >     @test>     public void testconcatwithlist() {>         @suppresswarnings("unchecked")>         observer<string> observer  mock(observerclass)> >         final string[] o  { "1" "3" "5" "7" }>         final string[] e  { "2" "4" "6" }> >         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)>         final list<observable<string>> list  new arraylist<observable<string>>()>         listadd(odds)>         listadd(even)>         observable<string> concat  observablecreate(concat(list))>         concatsubscribe(observer)> >         verify(observer times(7))onnext(anystring())>     }> >     @test>     public void testconcatunsubscribe() {>         final countdownlatch callonce  new countdownlatch(1)>         final countdownlatch oktocontinue  new countdownlatch(1)>         final testobservable<string> w1  new testobservable<string>("one" "two" "three")>         final testobservable<string> w2  new testobservable<string>(callonce oktocontinue "four" "five" "six")> >         @suppresswarnings("unchecked")>         observer<string> aobserver  mock(observerclass)>         @suppresswarnings("unchecked")>         observable<string> concat  observablecreate(concat(w1 w2))>         systemoutprintln("before subscribe")>         subscription s1  concatsubscribe(aobserver)>         systemoutprintln("after subscribe")>         try {>             //block main thread to allow observable "w1" to complete and observable "w2" to call onnext once>             systemoutprintln("before callonceawait")>             callonceawait()>             systemoutprintln("after callonceawait")>             s1unsubscribe()>             systemoutprintln("after s1unsubscribe")>             //unblock the observable to continue>             oktocontinuecountdown()>             systemoutprintln("after countdown")>             w1tjoin()>             w2tjoin()>         } catch (exception e) {>             eprintstacktrace()>             fail(egetmessage())>         }> >         inorder inorder  inorder(aobserver)>         inorderverify(aobserver times(1))onnext("one")>         inorderverify(aobserver times(1))onnext("two")>         inorderverify(aobserver times(1))onnext("three")>         inorderverify(aobserver times(1))onnext("four")>         inorderverify(aobserver never())onnext("five")>         inorderverify(aobserver never())onnext("six")>         inorderverify(aobserver times(1))oncompleted()>     }> >     @test>     public void testmergeobservableofobservables() {>         @suppresswarnings("unchecked")>         observer<string> observer  mock(observerclass)> >         final string[] o  { "1" "3" "5" "7" }>         final string[] e  { "2" "4" "6" }> >         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)> >         observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {> >             @override>             public subscription call(observer<observable<string>> observer) {>                 // simulate what would happen in an observable>                 observeronnext(odds)>                 observeronnext(even)>                 observeroncompleted()> >                 return new subscription() {> >                     @override>                     public void unsubscribe() {>                         // unregister  will never be called here since we are executing synchronously>                     }> >                 }>             }> >         })>         observable<string> concat  observablecreate(concat(observableofobservables))>         concatsubscribe(observer)>         verify(observer times(7))onnext(anystring())>     }> >     /**         * simple concat of 2 asynchronous observables ensuring it emits in correct order         */>     @suppresswarnings("unchecked")>     @test>     public void testsimpleasyncconcat() {>         observer<string> observer  mock(observerclass)> >         testobservable<string> o1  new testobservable<string>("one" "two" "three")>         testobservable<string> o2  new testobservable<string>("four" "five" "six")> >         observableconcat(o1 o2)subscribe(observer)> >         try {>             // wait for async observables to complete>             o1tjoin()>             o2tjoin()>         } catch (exception e) {>             throw new runtimeexception("failed waiting on threads")>         }> >         inorder inorder  inorder(observer)>         inorderverify(observer times(1))onnext("one")>         inorderverify(observer times(1))onnext("two")>         inorderverify(observer times(1))onnext("three")>         inorderverify(observer times(1))onnext("four")>         inorderverify(observer times(1))onnext("five")>         inorderverify(observer times(1))onnext("six")>     }> >     /**         * test an async observable that emits more async observables         */>     @suppresswarnings("unchecked")>     @test>     public void testnestedasyncconcat() throws exception {>         observer<string> observer  mock(observerclass)> >         final testobservable<string> o1  new testobservable<string>("one" "two" "three")>         final testobservable<string> o2  new testobservable<string>("four" "five" "six")>         final testobservable<string> o3  new testobservable<string>("seven" "eight" "nine")>         final countdownlatch allowthird  new countdownlatch(1)> >         final atomicreference<thread> parent  new atomicreference<thread>()>         observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {> >             @override>             public subscription call(final observer<observable<string>> observer) {>                 final booleansubscription s  new booleansubscription()>                 parentset(new thread(new runnable() {> >                     @override>                     public void run() {>                         try {>                             // emit first>                             if (!sisunsubscribed()) {>                                 systemoutprintln("emit o1")>                                 observeronnext(o1)>                             }>                             // emit second>                             if (!sisunsubscribed()) {>                                 systemoutprintln("emit o2")>                                 observeronnext(o2)>                             }> >                             // wait until sometime later and emit third>                             try {>                                 allowthirdawait()>                             } catch (interruptedexception e) {>                                 observeronerror(e)>                             }>                             if (!sisunsubscribed()) {>                                 systemoutprintln("emit o3")>                                 observeronnext(o3)>                             }> >                         } catch (exception e) {>                             observeronerror(e)>                         } finally {>                             systemoutprintln("done parent observable")>                             observeroncompleted()>                         }>                     }>                 }))>                 parentget()start()>                 return s>             }>         })> >         observablecreate(concat(observableofobservables))subscribe(observer)> >         // wait for parent to start>         while (parentget()  null) {>             threadsleep(1)>         }> >         try {>             // wait for first 2 async observables to complete>             while (o1t  null) {>                 threadsleep(1)>             }>             systemoutprintln("thread1 started  waiting for it to complete ")>             o1tjoin()>             while (o2t  null) {>                 threadsleep(1)>             }>             systemoutprintln("thread2 started  waiting for it to complete ")>             o2tjoin()>         } catch (exception e) {>             throw new runtimeexception("failed waiting on threads" e)>         }> >         inorder inorder  inorder(observer)>         inorderverify(observer times(1))onnext("one")>         inorderverify(observer times(1))onnext("two")>         inorderverify(observer times(1))onnext("three")>         inorderverify(observer times(1))onnext("four")>         inorderverify(observer times(1))onnext("five")>         inorderverify(observer times(1))onnext("six")>         // we shouldnt have the following 3 yet>         inorderverify(observer never())onnext("seven")>         inorderverify(observer never())onnext("eight")>         inorderverify(observer never())onnext("nine")>         // we should not be completed yet>         verify(observer never())oncompleted()>         verify(observer never())onerror(any(exceptionclass))> >         // now allow the third>         allowthirdcountdown()> >         try {>             while (o3t  null) {>                 threadsleep(1)>             }>             // wait for 3rd to complete>             o3tjoin()>         } catch (exception e) {>             throw new runtimeexception("failed waiting on threads" e)>         }> >         inorderverify(observer times(1))onnext("seven")>         inorderverify(observer times(1))onnext("eight")>         inorderverify(observer times(1))onnext("nine")> >         inorderverify(observer times(1))oncompleted()>         verify(observer never())onerror(any(exceptionclass))>     }> >     @suppresswarnings("unchecked")>     @test>     public void testblockedobservableofobservables() {>         observer<string> observer  mock(observerclass)> >         final string[] o  { "1" "3" "5" "7" }>         final string[] e  { "2" "4" "6" }>         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)>         final countdownlatch callonce  new countdownlatch(1)>         final countdownlatch oktocontinue  new countdownlatch(1)>         testobservable<observable<string>> observableofobservables  new testobservable<observable<string>>(callonce oktocontinue odds even)>         func1<observer<string> subscription> concatf  concat(observableofobservables)>         observable<string> concat  observablecreate(concatf)>         concatsubscribe(observer)>         try {>             //block main thread to allow observables to serve up o1>             callonceawait()>         } catch (exception ex) {>             exprintstacktrace()>             fail(exgetmessage())>         }>         // the concated observable should have served up all of the odds>         verify(observer times(1))onnext("1")>         verify(observer times(1))onnext("3")>         verify(observer times(1))onnext("5")>         verify(observer times(1))onnext("7")> >         try {>             // unblock observables so it can serve up o2 and complete>             oktocontinuecountdown()>             observableofobservablestjoin()>         } catch (exception ex) {>             exprintstacktrace()>             fail(exgetmessage())>         }>         // the concatenated observable should now have served up all the evens>         verify(observer times(1))onnext("2")>         verify(observer times(1))onnext("4")>         verify(observer times(1))onnext("6")>     }> >     private static class testobservable<t> extends observable<t> {> >         private final subscription s  new subscription() {> >             @override>             public void unsubscribe() {>                 subscribed  false>             }> >         }>         private final list<t> values>         private thread t  null>         private int count  0>         private boolean subscribed  true>         private final countdownlatch once>         private final countdownlatch oktocontinue> >         public testobservable(t values) {>             this(null null values)>         }> >         public testobservable(countdownlatch once countdownlatch oktocontinue t values) {>             thisvalues  arraysaslist(values)>             thisonce  once>             thisoktocontinue  oktocontinue>         }> >         @override>         public subscription subscribe(final observer<t> observer) {>             t  new thread(new runnable() {> >                 @override>                 public void run() {>                     try {>                         while (count < valuessize() && subscribed) {>                             observeronnext(valuesget(count))>                             count++>                             //unblock the main thread to call unsubscribe>                             if (null ! once)>                                 oncecountdown()>                             //block until the main thread has called unsubscribe>                             if (null ! once)>                                 oktocontinueawait()>                         }>                         if (subscribed)>                             observeroncompleted()>                     } catch (interruptedexception e) {>                         eprintstacktrace()>                         fail(egetmessage())>                     }>                 }> >             })>             tstart()>             return s>         }> >     }> > }> ```> > > reply to this email directly or view it on github  || #59  #60 thanks for update  let me take a look and i will do some moreresearch/thought on the testconcatsubscribe test caseon fri mar 29 2013 at 2:22 am cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #60 > this pull request looks good> > —> reply to this email directly or view it on github  || [rxjava-pull-requests #72 looks good || my original test case was intended to test the unsubscribe inside one ofchild observable   the countdownlatch was used so that the code will havea chance to unsubscribe in a predicable manner (unsubscribe after "four") in a normal case there should be no blocking between inner and outerobservable  i rewrote the case for better clarity and having the outerobservable is in a separate thread (so the test will pass now)  youbrought up a good point about "when" you can unsubscribe  should it onlyallow unsubscribe to happen during the outer onnext()?  i need to do moreresearch on it  here is the test i plan to add```    @test``` public void testconcatunsubscribeobservableofobservable() {```        final countdownlatch callonce  new countdownlatch(1)        final countdownlatch oktocontinue  new countdownlatch(1)        final testobservable<string> w1  new testobservable<string>(```"one" "two" "three")```        final testobservable<string> w2 ```newtestobservable<string>(callonce oktocontinue"four" "five" "six")```        @suppresswarnings("unchecked")        observer<string> aobserver  mock(observerclass)        @suppresswarnings("unchecked")```   testobservable<observable<string>> observableofobservables newtestobservable<observable<string>>(w1 w2)```        func1<observer<string> subscription> concatf ```concat(observableofobservables)```        observable<string> concat  observablecreate(concatf)        subscription s1  concatsubscribe(aobserver)        try {            //block main thread to allow observable "w1" to complete```and observable "w2" to call onnext exactly once```        callonceawait()        //"four" has been processed by onnext()            s1unsubscribe()            //"five" and "six" will not be processed by onnext()            //unblock the observable to continue            oktocontinuecountdown()            w1tjoin()            w2tjoin()        } catch (exception e) {            eprintstacktrace()            fail(egetmessage())        }        inorder inorder  inorder(aobserver)        inorderverify(aobserver times(1))onnext("one")        inorderverify(aobserver times(1))onnext("two")        inorderverify(aobserver times(1))onnext("three")        inorderverify(aobserver times(1))onnext("four")        inorderverify(aobserver never())onnext("five")        inorderverify(aobserver never())onnext("six")        verify(aobserver never())oncompleted()        verify(aobserver never())onerror(any(exceptionclass))```  }on tue apr 2 2013 at 8:55 pm cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #72 > this pull request looks good> > —> reply to this email directly or view it on github  || the rx net version of concat uses the immediatescheduler to execute theoperation which will execute the operation on the same calling thread  soif the observables are running on the same thread it will besynchronous/blocked   i have pulled in your changes from your fork andadded the additional unit test to test unsubscribe() with observablesrunning in different thread  i have also updated the javadoc about theblocking with observable on the same thread  from my side it looks goodon wed apr 3 2013 at 10:20 am billy yuen billyy@gmailcom wrote:> my original test case was intended to test the unsubscribe inside one of> child observable   the countdownlatch was used so that the code will have> a chance to unsubscribe in a predicable manner (unsubscribe after "four")>  in a normal case there should be no blocking between inner and outer> observable  i rewrote the case for better clarity and having the outer> observable is in a separate thread (so the test will pass now)  you> brought up a good point about "when" you can unsubscribe  should it only> allow unsubscribe to happen during the outer onnext()?  i need to do more> research on it  here is the test i plan to add> > ```>     @test> ```> >  public void testconcatunsubscribeobservableofobservable() {> > ```>         final countdownlatch callonce  new countdownlatch(1)> >         final countdownlatch oktocontinue  new countdownlatch(1)> >         final testobservable<string> w1  new testobservable<string>(> ```> > "one" "two" "three")> > ```>         final testobservable<string> w2  newtestobservable<string>(callonce oktocontinue> ```> > "four" "five" "six")> > ```>         @suppresswarnings("unchecked")> >         observer<string> aobserver  mock(observerclass)> >         @suppresswarnings("unchecked")> ```> >    testobservable<observable<string>> observableofobservables  newtestobservable<observable<string>>(w1 w2)> > ```>         func1<observer<string> subscription> concatf > ```> > concat(observableofobservables)> > ```>         observable<string> concat  observablecreate(concatf)> > > >         subscription s1  concatsubscribe(aobserver)> > > >         try {> >             //block main thread to allow observable "w1" to complete> ```> > and observable "w2" to call onnext exactly once> > ```>         callonceawait()> >         //"four" has been processed by onnext()> >             s1unsubscribe()> >             //"five" and "six" will not be processed by onnext()> >             //unblock the observable to continue> >             oktocontinuecountdown()> >             w1tjoin()> >             w2tjoin()> >         } catch (exception e) {> >             eprintstacktrace()> >             fail(egetmessage())> >         }> > >         inorder inorder  inorder(aobserver)> >         inorderverify(aobserver times(1))onnext("one")> >         inorderverify(aobserver times(1))onnext("two")> >         inorderverify(aobserver times(1))onnext("three")> >         inorderverify(aobserver times(1))onnext("four")> >         inorderverify(aobserver never())onnext("five")> >         inorderverify(aobserver never())onnext("six")> >         verify(aobserver never())oncompleted()> >         verify(aobserver never())onerror(any(exceptionclass))> ```> >   }> > on tue apr 2 2013 at 8:55 pm cloudbees pull request builder plugin <> notifications@githubcom> wrote:> > > rxjava-pull-requests #72 > > > this pull request looks good> > > > —> > reply to this email directly or view it on github >  || > i do find it a little strange that observablefrom(iterable) is a "shotgun> observable" ie the subscribe() blocks until all downstream operations> have completed on all items which means it is impossible to ever> unsubscribe() but given that this is correct behavior i think that it> makes sense that concat(o1 o2) also cannot be unsubscribed-from i added a> cautionary comment to the javadocrx does not (or rarely does) add concurrency (see guideline 612) thus `observablefrom` is wrapping a synchronous iterable therefore the observable will be synchronousa `scheduler` could be used to make the subscription to an iterable happen on another thread or a custom `observable` could be created that handles an iterable asynchronouslyall rx operators must be capable of handling both synchronous and asynchronous sequences and if its synchronous that means unsubscribe will not work (which means its up to the implementor of an observable to understand this and decided if its okay to firehose the results)for the case of concat my concern is that if all the sequences being combined are async then we need to retain the async behavior and not block and prevent unsubscriptionfor example:- async or synchronous observablea with 10 items- async or synchronous observableb with 20 items- async observablec with infinite items (hot observable that never completed)i should be able to do this: `concat(a b c)take(50)` this should get the 10 items from a 20 items from b and first 20 items from c and then unsubscribe and continuedoes this work with the current implementation and correctly unsubscribe from observablec? || good point  the best way to tell is to build an unit test for this case i can expand my new test to include this case and see what happenon wed apr 3 2013 at 2:29 pm ben christensen notifications@githubcomwrote:> i do find it a little strange that observablefrom(iterable) is a "shotgun> observable" ie the subscribe() blocks until all downstream operations> have completed on all items which means it is impossible to ever> unsubscribe() but given that this is correct behavior i think that it> makes sense that concat(o1 o2) also cannot be unsubscribed-from i added a> cautionary comment to the javadoc> > rx does not (or rarely does) add concurrency (see guideline 612) thus> observablefrom is wrapping a synchronous iterable therefore the> observable will be synchronous> > a scheduler could be used to make the subscription to an iterable happen> on another thread or a custom observable could be created that handles> an iterable asynchronously> > all rx operators must be capable of handling both synchronous and> asynchronous sequences and if its synchronous that means unsubscribe will> not work (which means its up to the implementor of an observable to> understand this and decided if its okay to firehose the results)> > for the case of concat my concern is that if all the sequences being> combined are async then we need to retain the async behavior and not block> and prevent unsubscription> > for example:> - async or synchronous observablea with 10 items> - async or synchronous observableb with 20 items> - async observablec with infinite items (hot observable that never>   completed)> > i should be able to do this:> > concat(a b c)take(50)> > this should get the 10 items from a 20 items from b and first 20 items> from c and then unsubscribe and continue> > does this work with the current implementation and correctly unsubscribe> from observablec?> > —> reply to this email directly or view it on github  || 
205,1,0,1,0,0,0,1,0,reimplementation of concat improved handling of observable<observable<t >>the old version required all of the observable<t>s to be generated and bufferedbefore the concat could begin  if the outer observable was asynchronous itemscould be dropped (test added)  the new version passes the test and does thebest job i could (after examining several possible strategies) of achievingclear and consistent semantics in accordance with the principle of leastsurprise(my attempt to  #202) #45] there is another issue with this implementation  the countdown latch will always block the calling thread which is not desirable  anything that returns an observable should never be blocking  rx is meant to support composition of operations and allows each operation to run concurrently || while reviewing this i started playing with the unit tests and added 2 new ones i also made them use inorderverify so they ensure correct ordering ive pasted it below so you can merge into your branch instead of me complicating the merge with another branch the tests pass pass except `testconcatunsubscribe` which deadlocks it does this because a list<observable> wont return the subscription asynchronously so it cant unsubscribe meanwhile a countdownlatch is waiting for the change to trigger and the two latches end up waiting on each otheri havent thought through enough yet to determine if there is a way to solve that or if the unit test is just testing the wrong thing and thus a bad testthe comment above from @billy about countdownlatch originated from a discussion between him and i - but while reviewing this it is probably the right approachi was playing with other approaches that are purely non-blocking while retaining the correct concat sequential behavior but they all seem to require either:- another wrapping thread- stealing work from one of the child observable threads and making it do work that is queued on the others  and that seems like a bad idea even though it can be hacked to "work" but it does so in a way that is very unexpected and thus not something i want to pursue- queueing all onnext values which could be a bad memory issue  and also means we eagerly subscribe which is not what we wantmy biggest issue right now is that concat(o1 o2) is a very common usage but that results in list<observable> which will be blocking and unsubscribe doesnt workill think through this more but id appreciate your thoughts on how to handle `testconcatunsubscribe` ``` java    public static class unittest {        @test        public void testconcat() {            @suppresswarnings("unchecked")            observer<string> observer  mock(observerclass)            final string o  { "1" "3" "5" "7" }            final string e  { "2" "4" "6" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            @suppresswarnings("unchecked")            observable<string> concat  observablecreate(concat(odds even))            concatsubscribe(observer)            verify(observer times(7))onnext(anystring())        }        @test        public void testconcatwithlist() {            @suppresswarnings("unchecked")            observer<string> observer  mock(observerclass)            final string o  { "1" "3" "5" "7" }            final string e  { "2" "4" "6" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            final list<observable<string>> list  new arraylist<observable<string>>()            listadd(odds)            listadd(even)            observable<string> concat  observablecreate(concat(list))            concatsubscribe(observer)            verify(observer times(7))onnext(anystring())        }        @test        public void testconcatunsubscribe() {            final countdownlatch callonce  new countdownlatch(1)            final countdownlatch oktocontinue  new countdownlatch(1)            final testobservable<string> w1  new testobservable<string>("one" "two" "three")            final testobservable<string> w2  new testobservable<string>(callonce oktocontinue "four" "five" "six")            @suppresswarnings("unchecked")            observer<string> aobserver  mock(observerclass)            @suppresswarnings("unchecked")            observable<string> concat  observablecreate(concat(w1 w2))            systemoutprintln("before subscribe")            subscription s1  concatsubscribe(aobserver)            systemoutprintln("after subscribe")            try {                //block main thread to allow observable "w1" to complete and observable "w2" to call onnext once                systemoutprintln("before callonceawait")                callonceawait()                systemoutprintln("after callonceawait")                s1unsubscribe()                systemoutprintln("after s1unsubscribe")                //unblock the observable to continue                oktocontinuecountdown()                systemoutprintln("after countdown")                w1tjoin()                w2tjoin()            } catch (exception e) {                eprintstacktrace()                fail(egetmessage())            }            inorder inorder  inorder(aobserver)            inorderverify(aobserver times(1))onnext("one")            inorderverify(aobserver times(1))onnext("two")            inorderverify(aobserver times(1))onnext("three")            inorderverify(aobserver times(1))onnext("four")            inorderverify(aobserver never())onnext("five")            inorderverify(aobserver never())onnext("six")            inorderverify(aobserver times(1))oncompleted()        }        @test        public void testmergeobservableofobservables() {            @suppresswarnings("unchecked")            observer<string> observer  mock(observerclass)            final string o  { "1" "3" "5" "7" }            final string e  { "2" "4" "6" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {                @override                public subscription call(observer<observable<string>> observer) {                    // simulate what would happen in an observable                    observeronnext(odds)                    observeronnext(even)                    observeroncompleted()                    return new subscription() {                        @override                        public void unsubscribe() {                            // unregister  will never be called here since we are executing synchronously                        }                    }                }            })            observable<string> concat  observablecreate(concat(observableofobservables))            concatsubscribe(observer)            verify(observer times(7))onnext(anystring())        }        /**         * simple concat of 2 asynchronous observables ensuring it emits in correct order         */        @suppresswarnings("unchecked")        @test        public void testsimpleasyncconcat() {            observer<string> observer  mock(observerclass)            testobservable<string> o1  new testobservable<string>("one" "two" "three")            testobservable<string> o2  new testobservable<string>("four" "five" "six")            observableconcat(o1 o2)subscribe(observer)            try {                // wait for async observables to complete                o1tjoin()                o2tjoin()            } catch (exception e) {                throw new runtimeexception("failed waiting on threads")            }            inorder inorder  inorder(observer)            inorderverify(observer times(1))onnext("one")            inorderverify(observer times(1))onnext("two")            inorderverify(observer times(1))onnext("three")            inorderverify(observer times(1))onnext("four")            inorderverify(observer times(1))onnext("five")            inorderverify(observer times(1))onnext("six")        }        /**         * test an async observable that emits more async observables         */        @suppresswarnings("unchecked")        @test        public void testnestedasyncconcat() throws exception {            observer<string> observer  mock(observerclass)            final testobservable<string> o1  new testobservable<string>("one" "two" "three")            final testobservable<string> o2  new testobservable<string>("four" "five" "six")            final testobservable<string> o3  new testobservable<string>("seven" "eight" "nine")            final countdownlatch allowthird  new countdownlatch(1)            final atomicreference<thread> parent  new atomicreference<thread>()            observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {                @override                public subscription call(final observer<observable<string>> observer) {                    final booleansubscription s  new booleansubscription()                    parentset(new thread(new runnable() {                        @override                        public void run() {                            try {                                // emit first                                if (!sisunsubscribed()) {                                    systemoutprintln("emit o1")                                    observeronnext(o1)                                }                                // emit second                                if (!sisunsubscribed()) {                                    systemoutprintln("emit o2")                                    observeronnext(o2)                                }                                // wait until sometime later and emit third                                try {                                    allowthirdawait()                                } catch (interruptedexception e) {                                    observeronerror(e)                                }                                if (!sisunsubscribed()) {                                    systemoutprintln("emit o3")                                    observeronnext(o3)                                }                            } catch (exception e) {                                observeronerror(e)                            } finally {                                systemoutprintln("done parent observable")                                observeroncompleted()                            }                        }                    }))                    parentget()start()                    return s                }            })            observablecreate(concat(observableofobservables))subscribe(observer)            // wait for parent to start            while (parentget()  null) {                threadsleep(1)            }            try {                // wait for first 2 async observables to complete                while (o1t  null) {                    threadsleep(1)                }                systemoutprintln("thread1 started  waiting for it to complete ")                o1tjoin()                while (o2t  null) {                    threadsleep(1)                }                systemoutprintln("thread2 started  waiting for it to complete ")                o2tjoin()            } catch (exception e) {                throw new runtimeexception("failed waiting on threads" e)            }            inorder inorder  inorder(observer)            inorderverify(observer times(1))onnext("one")            inorderverify(observer times(1))onnext("two")            inorderverify(observer times(1))onnext("three")            inorderverify(observer times(1))onnext("four")            inorderverify(observer times(1))onnext("five")            inorderverify(observer times(1))onnext("six")            // we shouldnt have the following 3 yet            inorderverify(observer never())onnext("seven")            inorderverify(observer never())onnext("eight")            inorderverify(observer never())onnext("nine")            // we should not be completed yet            verify(observer never())oncompleted()            verify(observer never())onerror(any(exceptionclass))            // now allow the third            allowthirdcountdown()            try {                while (o3t  null) {                    threadsleep(1)                }                // wait for 3rd to complete                o3tjoin()            } catch (exception e) {                throw new runtimeexception("failed waiting on threads" e)            }            inorderverify(observer times(1))onnext("seven")            inorderverify(observer times(1))onnext("eight")            inorderverify(observer times(1))onnext("nine")            inorderverify(observer times(1))oncompleted()            verify(observer never())onerror(any(exceptionclass))        }        @suppresswarnings("unchecked")        @test        public void testblockedobservableofobservables() {            observer<string> observer  mock(observerclass)            final string o  { "1" "3" "5" "7" }            final string e  { "2" "4" "6" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            final countdownlatch callonce  new countdownlatch(1)            final countdownlatch oktocontinue  new countdownlatch(1)            testobservable<observable<string>> observableofobservables  new testobservable<observable<string>>(callonce oktocontinue odds even)            func1<observer<string> subscription> concatf  concat(observableofobservables)            observable<string> concat  observablecreate(concatf)            concatsubscribe(observer)            try {                //block main thread to allow observables to serve up o1                callonceawait()            } catch (exception ex) {                exprintstacktrace()                fail(exgetmessage())            }            // the concated observable should have served up all of the odds            verify(observer times(1))onnext("1")            verify(observer times(1))onnext("3")            verify(observer times(1))onnext("5")            verify(observer times(1))onnext("7")            try {                // unblock observables so it can serve up o2 and complete                oktocontinuecountdown()                observableofobservablestjoin()            } catch (exception ex) {                exprintstacktrace()                fail(exgetmessage())            }            // the concatenated observable should now have served up all the evens            verify(observer times(1))onnext("2")            verify(observer times(1))onnext("4")            verify(observer times(1))onnext("6")        }        private static class testobservable<t> extends observable<t> {            private final subscription s  new subscription() {                @override                public void unsubscribe() {                    subscribed  false                }            }            private final list<t> values            private thread t  null            private int count  0            private boolean subscribed  true            private final countdownlatch once            private final countdownlatch oktocontinue            public testobservable(t values) {                this(null null values)            }            public testobservable(countdownlatch once countdownlatch oktocontinue t values) {                thisvalues  arraysaslist(values)                thisonce  once                thisoktocontinue  oktocontinue            }            @override            public subscription subscribe(final observer<t> observer) {                t  new thread(new runnable() {                    @override                    public void run() {                        try {                            while (count < valuessize() && subscribed) {                                observeronnext(valuesget(count))                                count++                                //unblock the main thread to call unsubscribe                                if (null ! once)                                    oncecountdown()                                //block until the main thread has called unsubscribe                                if (null ! once)                                    oktocontinueawait()                            }                            if (subscribed)                                observeroncompleted()                        } catch (interruptedexception e) {                            eprintstacktrace()                            fail(egetmessage())                        }                    }                })                tstart()                return s            }        }    }``` || thanks for the comments and the extra tests i have merged them anduploaded a new versionregarding testconcatunsubscribe: im still not entirely sure of my footingbut i believe the test is in error it is demonstrating exactly the issuewhich i mentioned in the new javadoc for operationconcat specifically itsets up a situation wherein the inner observables thread is blocked on theouter observables thread: the inner thread cannot proceed until the testcalls oktocontinuecountdown() which happens-afterconcatsubscribe(aobserver) which blocks until the list has delivered bothw1 and w2am i right that in general an observer should block onnext() until it hasfinished processing the item? this pushes the flow-control upstream ratherthan excessive buffering or throttling (which can be done explicitly in theoperation-chain if desired) if thats right then i think concat mustblock the outer onnext until it has finished servicing the inner sequencei do find it a little strange that observablefrom(iterable) is a "shotgunobservable" ie the subscribe() blocks until all downstream operationshave completed on all items which means it is impossible to everunsubscribe() but given that this is correct behavior i think that itmakes sense that concat(o1 o2) also cannot be unsubscribed-from i added acautionary comment to the javadoci have updated the test case to call concatsubscribe(aobserver) in abackground thread which fixes the deadlock and to expect all items to bedelivered despite an unsubscribe which makes the test pass(i had also tried those three non-blocking approaches before uploading thisversion thanks for checking my work :)on mar 27 2013 6:56 am "ben christensen" notifications@githubcom wrote:> while reviewing this i started playing with the unit tests and added 2 new> ones i also made them use inorderverify so they ensure correct ordering> ive pasted it below so you can merge into your branch instead of me> complicating the merge with another branch> > the tests pass pass except testconcatunsubscribe which deadlocks it does> this because a list wont return the subscription asynchronously so it> cant unsubscribe meanwhile a countdownlatch is waiting for the change to> trigger and the two latches end up waiting on each other> > i havent thought through enough yet to determine if there is a way to> solve that or if the unit test is just testing the wrong thing and thus a> bad test> > the comment above from @billy  about> countdownlatch originated from a discussion between him and i - but while> reviewing this it is probably the right approach> > i was playing with other approaches that are purely non-blocking while> retaining the correct concat sequential behavior but they all seem to> require either:> - another wrapping thread> - stealing work from one of the child observable threads and making it>   do work that is queued on the others  and that seems like a bad idea>   even though it can be hacked to "work" but it does so in a way that is very>   unexpected and thus not something i want to pursue> - queueing all onnext values which could be a bad memory issue  and>   also means we eagerly subscribe which is not what we want> > my biggest issue right now is that concat(o1 o2) is a very common usage> but that results in list which will be blocking and unsubscribe doesnt> work> > ill think through this more but id appreciate your thoughts on how to> handle testconcatunsubscribe> > ```> public static class unittest {> >     @test>     public void testconcat() {>         @suppresswarnings("unchecked")>         observer<string> observer  mock(observerclass)> >         final string o  { "1" "3" "5" "7" }>         final string e  { "2" "4" "6" }> >         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)> >         @suppresswarnings("unchecked")>         observable<string> concat  observablecreate(concat(odds even))>         concatsubscribe(observer)> >         verify(observer times(7))onnext(anystring())>     }> >     @test>     public void testconcatwithlist() {>         @suppresswarnings("unchecked")>         observer<string> observer  mock(observerclass)> >         final string[] o  { "1" "3" "5" "7" }>         final string[] e  { "2" "4" "6" }> >         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)>         final list<observable<string>> list  new arraylist<observable<string>>()>         listadd(odds)>         listadd(even)>         observable<string> concat  observablecreate(concat(list))>         concatsubscribe(observer)> >         verify(observer times(7))onnext(anystring())>     }> >     @test>     public void testconcatunsubscribe() {>         final countdownlatch callonce  new countdownlatch(1)>         final countdownlatch oktocontinue  new countdownlatch(1)>         final testobservable<string> w1  new testobservable<string>("one" "two" "three")>         final testobservable<string> w2  new testobservable<string>(callonce oktocontinue "four" "five" "six")> >         @suppresswarnings("unchecked")>         observer<string> aobserver  mock(observerclass)>         @suppresswarnings("unchecked")>         observable<string> concat  observablecreate(concat(w1 w2))>         systemoutprintln("before subscribe")>         subscription s1  concatsubscribe(aobserver)>         systemoutprintln("after subscribe")>         try {>             //block main thread to allow observable "w1" to complete and observable "w2" to call onnext once>             systemoutprintln("before callonceawait")>             callonceawait()>             systemoutprintln("after callonceawait")>             s1unsubscribe()>             systemoutprintln("after s1unsubscribe")>             //unblock the observable to continue>             oktocontinuecountdown()>             systemoutprintln("after countdown")>             w1tjoin()>             w2tjoin()>         } catch (exception e) {>             eprintstacktrace()>             fail(egetmessage())>         }> >         inorder inorder  inorder(aobserver)>         inorderverify(aobserver times(1))onnext("one")>         inorderverify(aobserver times(1))onnext("two")>         inorderverify(aobserver times(1))onnext("three")>         inorderverify(aobserver times(1))onnext("four")>         inorderverify(aobserver never())onnext("five")>         inorderverify(aobserver never())onnext("six")>         inorderverify(aobserver times(1))oncompleted()>     }> >     @test>     public void testmergeobservableofobservables() {>         @suppresswarnings("unchecked")>         observer<string> observer  mock(observerclass)> >         final string[] o  { "1" "3" "5" "7" }>         final string[] e  { "2" "4" "6" }> >         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)> >         observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {> >             @override>             public subscription call(observer<observable<string>> observer) {>                 // simulate what would happen in an observable>                 observeronnext(odds)>                 observeronnext(even)>                 observeroncompleted()> >                 return new subscription() {> >                     @override>                     public void unsubscribe() {>                         // unregister  will never be called here since we are executing synchronously>                     }> >                 }>             }> >         })>         observable<string> concat  observablecreate(concat(observableofobservables))>         concatsubscribe(observer)>         verify(observer times(7))onnext(anystring())>     }> >     /**         * simple concat of 2 asynchronous observables ensuring it emits in correct order         */>     @suppresswarnings("unchecked")>     @test>     public void testsimpleasyncconcat() {>         observer<string> observer  mock(observerclass)> >         testobservable<string> o1  new testobservable<string>("one" "two" "three")>         testobservable<string> o2  new testobservable<string>("four" "five" "six")> >         observableconcat(o1 o2)subscribe(observer)> >         try {>             // wait for async observables to complete>             o1tjoin()>             o2tjoin()>         } catch (exception e) {>             throw new runtimeexception("failed waiting on threads")>         }> >         inorder inorder  inorder(observer)>         inorderverify(observer times(1))onnext("one")>         inorderverify(observer times(1))onnext("two")>         inorderverify(observer times(1))onnext("three")>         inorderverify(observer times(1))onnext("four")>         inorderverify(observer times(1))onnext("five")>         inorderverify(observer times(1))onnext("six")>     }> >     /**         * test an async observable that emits more async observables         */>     @suppresswarnings("unchecked")>     @test>     public void testnestedasyncconcat() throws exception {>         observer<string> observer  mock(observerclass)> >         final testobservable<string> o1  new testobservable<string>("one" "two" "three")>         final testobservable<string> o2  new testobservable<string>("four" "five" "six")>         final testobservable<string> o3  new testobservable<string>("seven" "eight" "nine")>         final countdownlatch allowthird  new countdownlatch(1)> >         final atomicreference<thread> parent  new atomicreference<thread>()>         observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {> >             @override>             public subscription call(final observer<observable<string>> observer) {>                 final booleansubscription s  new booleansubscription()>                 parentset(new thread(new runnable() {> >                     @override>                     public void run() {>                         try {>                             // emit first>                             if (!sisunsubscribed()) {>                                 systemoutprintln("emit o1")>                                 observeronnext(o1)>                             }>                             // emit second>                             if (!sisunsubscribed()) {>                                 systemoutprintln("emit o2")>                                 observeronnext(o2)>                             }> >                             // wait until sometime later and emit third>                             try {>                                 allowthirdawait()>                             } catch (interruptedexception e) {>                                 observeronerror(e)>                             }>                             if (!sisunsubscribed()) {>                                 systemoutprintln("emit o3")>                                 observeronnext(o3)>                             }> >                         } catch (exception e) {>                             observeronerror(e)>                         } finally {>                             systemoutprintln("done parent observable")>                             observeroncompleted()>                         }>                     }>                 }))>                 parentget()start()>                 return s>             }>         })> >         observablecreate(concat(observableofobservables))subscribe(observer)> >         // wait for parent to start>         while (parentget()  null) {>             threadsleep(1)>         }> >         try {>             // wait for first 2 async observables to complete>             while (o1t  null) {>                 threadsleep(1)>             }>             systemoutprintln("thread1 started  waiting for it to complete ")>             o1tjoin()>             while (o2t  null) {>                 threadsleep(1)>             }>             systemoutprintln("thread2 started  waiting for it to complete ")>             o2tjoin()>         } catch (exception e) {>             throw new runtimeexception("failed waiting on threads" e)>         }> >         inorder inorder  inorder(observer)>         inorderverify(observer times(1))onnext("one")>         inorderverify(observer times(1))onnext("two")>         inorderverify(observer times(1))onnext("three")>         inorderverify(observer times(1))onnext("four")>         inorderverify(observer times(1))onnext("five")>         inorderverify(observer times(1))onnext("six")>         // we shouldnt have the following 3 yet>         inorderverify(observer never())onnext("seven")>         inorderverify(observer never())onnext("eight")>         inorderverify(observer never())onnext("nine")>         // we should not be completed yet>         verify(observer never())oncompleted()>         verify(observer never())onerror(any(exceptionclass))> >         // now allow the third>         allowthirdcountdown()> >         try {>             while (o3t  null) {>                 threadsleep(1)>             }>             // wait for 3rd to complete>             o3tjoin()>         } catch (exception e) {>             throw new runtimeexception("failed waiting on threads" e)>         }> >         inorderverify(observer times(1))onnext("seven")>         inorderverify(observer times(1))onnext("eight")>         inorderverify(observer times(1))onnext("nine")> >         inorderverify(observer times(1))oncompleted()>         verify(observer never())onerror(any(exceptionclass))>     }> >     @suppresswarnings("unchecked")>     @test>     public void testblockedobservableofobservables() {>         observer<string> observer  mock(observerclass)> >         final string[] o  { "1" "3" "5" "7" }>         final string[] e  { "2" "4" "6" }>         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)>         final countdownlatch callonce  new countdownlatch(1)>         final countdownlatch oktocontinue  new countdownlatch(1)>         testobservable<observable<string>> observableofobservables  new testobservable<observable<string>>(callonce oktocontinue odds even)>         func1<observer<string> subscription> concatf  concat(observableofobservables)>         observable<string> concat  observablecreate(concatf)>         concatsubscribe(observer)>         try {>             //block main thread to allow observables to serve up o1>             callonceawait()>         } catch (exception ex) {>             exprintstacktrace()>             fail(exgetmessage())>         }>         // the concated observable should have served up all of the odds>         verify(observer times(1))onnext("1")>         verify(observer times(1))onnext("3")>         verify(observer times(1))onnext("5")>         verify(observer times(1))onnext("7")> >         try {>             // unblock observables so it can serve up o2 and complete>             oktocontinuecountdown()>             observableofobservablestjoin()>         } catch (exception ex) {>             exprintstacktrace()>             fail(exgetmessage())>         }>         // the concatenated observable should now have served up all the evens>         verify(observer times(1))onnext("2")>         verify(observer times(1))onnext("4")>         verify(observer times(1))onnext("6")>     }> >     private static class testobservable<t> extends observable<t> {> >         private final subscription s  new subscription() {> >             @override>             public void unsubscribe() {>                 subscribed  false>             }> >         }>         private final list<t> values>         private thread t  null>         private int count  0>         private boolean subscribed  true>         private final countdownlatch once>         private final countdownlatch oktocontinue> >         public testobservable(t values) {>             this(null null values)>         }> >         public testobservable(countdownlatch once countdownlatch oktocontinue t values) {>             thisvalues  arraysaslist(values)>             thisonce  once>             thisoktocontinue  oktocontinue>         }> >         @override>         public subscription subscribe(final observer<t> observer) {>             t  new thread(new runnable() {> >                 @override>                 public void run() {>                     try {>                         while (count < valuessize() && subscribed) {>                             observeronnext(valuesget(count))>                             count++>                             //unblock the main thread to call unsubscribe>                             if (null ! once)>                                 oncecountdown()>                             //block until the main thread has called unsubscribe>                             if (null ! once)>                                 oktocontinueawait()>                         }>                         if (subscribed)>                             observeroncompleted()>                     } catch (interruptedexception e) {>                         eprintstacktrace()>                         fail(egetmessage())>                     }>                 }> >             })>             tstart()>             return s>         }> >     }> > }> ```> > > reply to this email directly or view it on github  || #59  #60 thanks for update  let me take a look and i will do some moreresearch/thought on the testconcatsubscribe test caseon fri mar 29 2013 at 2:22 am cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #60 > this pull request looks good> > —> reply to this email directly or view it on github  || [rxjava-pull-requests #72 looks good || my original test case was intended to test the unsubscribe inside one ofchild observable   the countdownlatch was used so that the code will havea chance to unsubscribe in a predicable manner (unsubscribe after "four") in a normal case there should be no blocking between inner and outerobservable  i rewrote the case for better clarity and having the outerobservable is in a separate thread (so the test will pass now)  youbrought up a good point about "when" you can unsubscribe  should it onlyallow unsubscribe to happen during the outer onnext()?  i need to do moreresearch on it  here is the test i plan to add```    @test``` public void testconcatunsubscribeobservableofobservable() {```        final countdownlatch callonce  new countdownlatch(1)        final countdownlatch oktocontinue  new countdownlatch(1)        final testobservable<string> w1  new testobservable<string>(```"one" "two" "three")```        final testobservable<string> w2 ```newtestobservable<string>(callonce oktocontinue"four" "five" "six")```        @suppresswarnings("unchecked")        observer<string> aobserver  mock(observerclass)        @suppresswarnings("unchecked")```   testobservable<observable<string>> observableofobservables newtestobservable<observable<string>>(w1 w2)```        func1<observer<string> subscription> concatf ```concat(observableofobservables)```        observable<string> concat  observablecreate(concatf)        subscription s1  concatsubscribe(aobserver)        try {            //block main thread to allow observable "w1" to complete```and observable "w2" to call onnext exactly once```        callonceawait()        //"four" has been processed by onnext()            s1unsubscribe()            //"five" and "six" will not be processed by onnext()            //unblock the observable to continue            oktocontinuecountdown()            w1tjoin()            w2tjoin()        } catch (exception e) {            eprintstacktrace()            fail(egetmessage())        }        inorder inorder  inorder(aobserver)        inorderverify(aobserver times(1))onnext("one")        inorderverify(aobserver times(1))onnext("two")        inorderverify(aobserver times(1))onnext("three")        inorderverify(aobserver times(1))onnext("four")        inorderverify(aobserver never())onnext("five")        inorderverify(aobserver never())onnext("six")        verify(aobserver never())oncompleted()        verify(aobserver never())onerror(any(exceptionclass))```  }on tue apr 2 2013 at 8:55 pm cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #72 > this pull request looks good> > —> reply to this email directly or view it on github  || the rx net version of concat uses the immediatescheduler to execute theoperation which will execute the operation on the same calling thread  soif the observables are running on the same thread it will besynchronous/blocked   i have pulled in your changes from your fork andadded the additional unit test to test unsubscribe() with observablesrunning in different thread  i have also updated the javadoc about theblocking with observable on the same thread  from my side it looks goodon wed apr 3 2013 at 10:20 am billy yuen billyy@gmailcom wrote:> my original test case was intended to test the unsubscribe inside one of> child observable   the countdownlatch was used so that the code will have> a chance to unsubscribe in a predicable manner (unsubscribe after "four")>  in a normal case there should be no blocking between inner and outer> observable  i rewrote the case for better clarity and having the outer> observable is in a separate thread (so the test will pass now)  you> brought up a good point about "when" you can unsubscribe  should it only> allow unsubscribe to happen during the outer onnext()?  i need to do more> research on it  here is the test i plan to add> > ```>     @test> ```> >  public void testconcatunsubscribeobservableofobservable() {> > ```>         final countdownlatch callonce  new countdownlatch(1)> >         final countdownlatch oktocontinue  new countdownlatch(1)> >         final testobservable<string> w1  new testobservable<string>(> ```> > "one" "two" "three")> > ```>         final testobservable<string> w2  newtestobservable<string>(callonce oktocontinue> ```> > "four" "five" "six")> > ```>         @suppresswarnings("unchecked")> >         observer<string> aobserver  mock(observerclass)> >         @suppresswarnings("unchecked")> ```> >    testobservable<observable<string>> observableofobservables  newtestobservable<observable<string>>(w1 w2)> > ```>         func1<observer<string> subscription> concatf > ```> > concat(observableofobservables)> > ```>         observable<string> concat  observablecreate(concatf)> > > >         subscription s1  concatsubscribe(aobserver)> > > >         try {> >             //block main thread to allow observable "w1" to complete> ```> > and observable "w2" to call onnext exactly once> > ```>         callonceawait()> >         //"four" has been processed by onnext()> >             s1unsubscribe()> >             //"five" and "six" will not be processed by onnext()> >             //unblock the observable to continue> >             oktocontinuecountdown()> >             w1tjoin()> >             w2tjoin()> >         } catch (exception e) {> >             eprintstacktrace()> >             fail(egetmessage())> >         }> > >         inorder inorder  inorder(aobserver)> >         inorderverify(aobserver times(1))onnext("one")> >         inorderverify(aobserver times(1))onnext("two")> >         inorderverify(aobserver times(1))onnext("three")> >         inorderverify(aobserver times(1))onnext("four")> >         inorderverify(aobserver never())onnext("five")> >         inorderverify(aobserver never())onnext("six")> >         verify(aobserver never())oncompleted()> >         verify(aobserver never())onerror(any(exceptionclass))> ```> >   }> > on tue apr 2 2013 at 8:55 pm cloudbees pull request builder plugin <> notifications@githubcom> wrote:> > > rxjava-pull-requests #72 > > > this pull request looks good> > > > —> > reply to this email directly or view it on github >  || > i do find it a little strange that observablefrom(iterable) is a "shotgun> observable" ie the subscribe() blocks until all downstream operations> have completed on all items which means it is impossible to ever> unsubscribe() but given that this is correct behavior i think that it> makes sense that concat(o1 o2) also cannot be unsubscribed-from i added a> cautionary comment to the javadocrx does not (or rarely does) add concurrency (see guideline 612) thus `observablefrom` is wrapping a synchronous iterable therefore the observable will be synchronousa `scheduler` could be used to make the subscription to an iterable happen on another thread or a custom `observable` could be created that handles an iterable asynchronouslyall rx operators must be capable of handling both synchronous and asynchronous sequences and if its synchronous that means unsubscribe will not work (which means its up to the implementor of an observable to understand this and decided if its okay to firehose the results)for the case of concat my concern is that if all the sequences being combined are async then we need to retain the async behavior and not block and prevent unsubscriptionfor example:- async or synchronous observablea with 10 items- async or synchronous observableb with 20 items- async observablec with infinite items (hot observable that never completed)i should be able to do this: `concat(a b c)take(50)` this should get the 10 items from a 20 items from b and first 20 items from c and then unsubscribe and continuedoes this work with the current implementation and correctly unsubscribe from observablec? || good point  the best way to tell is to build an unit test for this case i can expand my new test to include this case and see what happenon wed apr 3 2013 at 2:29 pm ben christensen notifications@githubcomwrote:> i do find it a little strange that observablefrom(iterable) is a "shotgun> observable" ie the subscribe() blocks until all downstream operations> have completed on all items which means it is impossible to ever> unsubscribe() but given that this is correct behavior i think that it> makes sense that concat(o1 o2) also cannot be unsubscribed-from i added a> cautionary comment to the javadoc> > rx does not (or rarely does) add concurrency (see guideline 612) thus> observablefrom is wrapping a synchronous iterable therefore the> observable will be synchronous> > a scheduler could be used to make the subscription to an iterable happen> on another thread or a custom observable could be created that handles> an iterable asynchronously> > all rx operators must be capable of handling both synchronous and> asynchronous sequences and if its synchronous that means unsubscribe will> not work (which means its up to the implementor of an observable to> understand this and decided if its okay to firehose the results)> > for the case of concat my concern is that if all the sequences being> combined are async then we need to retain the async behavior and not block> and prevent unsubscription> > for example:> - async or synchronous observablea with 10 items> - async or synchronous observableb with 20 items> - async observablec with infinite items (hot observable that never>   completed)> > i should be able to do this:> > concat(a b c)take(50)> > this should get the 10 items from a 20 items from b and first 20 items> from c and then unsubscribe and continue> > does this work with the current implementation and correctly unsubscribe> from observablec?> > —> reply to this email directly or view it on github  || 
205,1,0,0,0,0,0,1,0,reimplementation of concat improved handling of observable<observable<t >>the old version required all of the observable<t>s to be generated and bufferedbefore the concat could begin  if the outer observable was asynchronous itemscould be dropped (test added)  the new version passes the test and does thebest job i could (after examining several possible strategies) of achievingclear and consistent semantics in accordance with the principle of leastsurprise(my attempt to  #202) #45] there is another issue with this implementation  the countdown latch will always block the calling thread which is not desirable  anything that returns an observable should never be blocking  rx is meant to support composition of operations and allows each operation to run concurrently || while reviewing this i started playing with the unit tests and added 2 new ones i also made them use inorderverify so they ensure correct ordering ive pasted it below so you can merge into your branch instead of me complicating the merge with another branch the tests pass pass except `testconcatunsubscribe` which deadlocks it does this because a list<observable> wont return the subscription asynchronously so it cant unsubscribe meanwhile a countdownlatch is waiting for the change to trigger and the two latches end up waiting on each otheri havent thought through enough yet to determine if there is a way to solve that or if the unit test is just testing the wrong thing and thus a bad testthe comment above from @billy about countdownlatch originated from a discussion between him and i - but while reviewing this it is probably the right approachi was playing with other approaches that are purely non-blocking while retaining the correct concat sequential behavior but they all seem to require either:- another wrapping thread- stealing work from one of the child observable threads and making it do work that is queued on the others  and that seems like a bad idea even though it can be hacked to "work" but it does so in a way that is very unexpected and thus not something i want to pursue- queueing all onnext values which could be a bad memory issue  and also means we eagerly subscribe which is not what we wantmy biggest issue right now is that concat(o1 o2) is a very common usage but that results in list<observable> which will be blocking and unsubscribe doesnt workill think through this more but id appreciate your thoughts on how to handle `testconcatunsubscribe` ``` java    public static class unittest {        @test        public void testconcat() {            @suppresswarnings("unchecked")            observer<string> observer  mock(observerclass)            final string o  { "1" "3" "5" "7" }            final string e  { "2" "4" "6" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            @suppresswarnings("unchecked")            observable<string> concat  observablecreate(concat(odds even))            concatsubscribe(observer)            verify(observer times(7))onnext(anystring())        }        @test        public void testconcatwithlist() {            @suppresswarnings("unchecked")            observer<string> observer  mock(observerclass)            final string o  { "1" "3" "5" "7" }            final string e  { "2" "4" "6" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            final list<observable<string>> list  new arraylist<observable<string>>()            listadd(odds)            listadd(even)            observable<string> concat  observablecreate(concat(list))            concatsubscribe(observer)            verify(observer times(7))onnext(anystring())        }        @test        public void testconcatunsubscribe() {            final countdownlatch callonce  new countdownlatch(1)            final countdownlatch oktocontinue  new countdownlatch(1)            final testobservable<string> w1  new testobservable<string>("one" "two" "three")            final testobservable<string> w2  new testobservable<string>(callonce oktocontinue "four" "five" "six")            @suppresswarnings("unchecked")            observer<string> aobserver  mock(observerclass)            @suppresswarnings("unchecked")            observable<string> concat  observablecreate(concat(w1 w2))            systemoutprintln("before subscribe")            subscription s1  concatsubscribe(aobserver)            systemoutprintln("after subscribe")            try {                //block main thread to allow observable "w1" to complete and observable "w2" to call onnext once                systemoutprintln("before callonceawait")                callonceawait()                systemoutprintln("after callonceawait")                s1unsubscribe()                systemoutprintln("after s1unsubscribe")                //unblock the observable to continue                oktocontinuecountdown()                systemoutprintln("after countdown")                w1tjoin()                w2tjoin()            } catch (exception e) {                eprintstacktrace()                fail(egetmessage())            }            inorder inorder  inorder(aobserver)            inorderverify(aobserver times(1))onnext("one")            inorderverify(aobserver times(1))onnext("two")            inorderverify(aobserver times(1))onnext("three")            inorderverify(aobserver times(1))onnext("four")            inorderverify(aobserver never())onnext("five")            inorderverify(aobserver never())onnext("six")            inorderverify(aobserver times(1))oncompleted()        }        @test        public void testmergeobservableofobservables() {            @suppresswarnings("unchecked")            observer<string> observer  mock(observerclass)            final string o  { "1" "3" "5" "7" }            final string e  { "2" "4" "6" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {                @override                public subscription call(observer<observable<string>> observer) {                    // simulate what would happen in an observable                    observeronnext(odds)                    observeronnext(even)                    observeroncompleted()                    return new subscription() {                        @override                        public void unsubscribe() {                            // unregister  will never be called here since we are executing synchronously                        }                    }                }            })            observable<string> concat  observablecreate(concat(observableofobservables))            concatsubscribe(observer)            verify(observer times(7))onnext(anystring())        }        /**         * simple concat of 2 asynchronous observables ensuring it emits in correct order         */        @suppresswarnings("unchecked")        @test        public void testsimpleasyncconcat() {            observer<string> observer  mock(observerclass)            testobservable<string> o1  new testobservable<string>("one" "two" "three")            testobservable<string> o2  new testobservable<string>("four" "five" "six")            observableconcat(o1 o2)subscribe(observer)            try {                // wait for async observables to complete                o1tjoin()                o2tjoin()            } catch (exception e) {                throw new runtimeexception("failed waiting on threads")            }            inorder inorder  inorder(observer)            inorderverify(observer times(1))onnext("one")            inorderverify(observer times(1))onnext("two")            inorderverify(observer times(1))onnext("three")            inorderverify(observer times(1))onnext("four")            inorderverify(observer times(1))onnext("five")            inorderverify(observer times(1))onnext("six")        }        /**         * test an async observable that emits more async observables         */        @suppresswarnings("unchecked")        @test        public void testnestedasyncconcat() throws exception {            observer<string> observer  mock(observerclass)            final testobservable<string> o1  new testobservable<string>("one" "two" "three")            final testobservable<string> o2  new testobservable<string>("four" "five" "six")            final testobservable<string> o3  new testobservable<string>("seven" "eight" "nine")            final countdownlatch allowthird  new countdownlatch(1)            final atomicreference<thread> parent  new atomicreference<thread>()            observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {                @override                public subscription call(final observer<observable<string>> observer) {                    final booleansubscription s  new booleansubscription()                    parentset(new thread(new runnable() {                        @override                        public void run() {                            try {                                // emit first                                if (!sisunsubscribed()) {                                    systemoutprintln("emit o1")                                    observeronnext(o1)                                }                                // emit second                                if (!sisunsubscribed()) {                                    systemoutprintln("emit o2")                                    observeronnext(o2)                                }                                // wait until sometime later and emit third                                try {                                    allowthirdawait()                                } catch (interruptedexception e) {                                    observeronerror(e)                                }                                if (!sisunsubscribed()) {                                    systemoutprintln("emit o3")                                    observeronnext(o3)                                }                            } catch (exception e) {                                observeronerror(e)                            } finally {                                systemoutprintln("done parent observable")                                observeroncompleted()                            }                        }                    }))                    parentget()start()                    return s                }            })            observablecreate(concat(observableofobservables))subscribe(observer)            // wait for parent to start            while (parentget()  null) {                threadsleep(1)            }            try {                // wait for first 2 async observables to complete                while (o1t  null) {                    threadsleep(1)                }                systemoutprintln("thread1 started  waiting for it to complete ")                o1tjoin()                while (o2t  null) {                    threadsleep(1)                }                systemoutprintln("thread2 started  waiting for it to complete ")                o2tjoin()            } catch (exception e) {                throw new runtimeexception("failed waiting on threads" e)            }            inorder inorder  inorder(observer)            inorderverify(observer times(1))onnext("one")            inorderverify(observer times(1))onnext("two")            inorderverify(observer times(1))onnext("three")            inorderverify(observer times(1))onnext("four")            inorderverify(observer times(1))onnext("five")            inorderverify(observer times(1))onnext("six")            // we shouldnt have the following 3 yet            inorderverify(observer never())onnext("seven")            inorderverify(observer never())onnext("eight")            inorderverify(observer never())onnext("nine")            // we should not be completed yet            verify(observer never())oncompleted()            verify(observer never())onerror(any(exceptionclass))            // now allow the third            allowthirdcountdown()            try {                while (o3t  null) {                    threadsleep(1)                }                // wait for 3rd to complete                o3tjoin()            } catch (exception e) {                throw new runtimeexception("failed waiting on threads" e)            }            inorderverify(observer times(1))onnext("seven")            inorderverify(observer times(1))onnext("eight")            inorderverify(observer times(1))onnext("nine")            inorderverify(observer times(1))oncompleted()            verify(observer never())onerror(any(exceptionclass))        }        @suppresswarnings("unchecked")        @test        public void testblockedobservableofobservables() {            observer<string> observer  mock(observerclass)            final string o  { "1" "3" "5" "7" }            final string e  { "2" "4" "6" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            final countdownlatch callonce  new countdownlatch(1)            final countdownlatch oktocontinue  new countdownlatch(1)            testobservable<observable<string>> observableofobservables  new testobservable<observable<string>>(callonce oktocontinue odds even)            func1<observer<string> subscription> concatf  concat(observableofobservables)            observable<string> concat  observablecreate(concatf)            concatsubscribe(observer)            try {                //block main thread to allow observables to serve up o1                callonceawait()            } catch (exception ex) {                exprintstacktrace()                fail(exgetmessage())            }            // the concated observable should have served up all of the odds            verify(observer times(1))onnext("1")            verify(observer times(1))onnext("3")            verify(observer times(1))onnext("5")            verify(observer times(1))onnext("7")            try {                // unblock observables so it can serve up o2 and complete                oktocontinuecountdown()                observableofobservablestjoin()            } catch (exception ex) {                exprintstacktrace()                fail(exgetmessage())            }            // the concatenated observable should now have served up all the evens            verify(observer times(1))onnext("2")            verify(observer times(1))onnext("4")            verify(observer times(1))onnext("6")        }        private static class testobservable<t> extends observable<t> {            private final subscription s  new subscription() {                @override                public void unsubscribe() {                    subscribed  false                }            }            private final list<t> values            private thread t  null            private int count  0            private boolean subscribed  true            private final countdownlatch once            private final countdownlatch oktocontinue            public testobservable(t values) {                this(null null values)            }            public testobservable(countdownlatch once countdownlatch oktocontinue t values) {                thisvalues  arraysaslist(values)                thisonce  once                thisoktocontinue  oktocontinue            }            @override            public subscription subscribe(final observer<t> observer) {                t  new thread(new runnable() {                    @override                    public void run() {                        try {                            while (count < valuessize() && subscribed) {                                observeronnext(valuesget(count))                                count++                                //unblock the main thread to call unsubscribe                                if (null ! once)                                    oncecountdown()                                //block until the main thread has called unsubscribe                                if (null ! once)                                    oktocontinueawait()                            }                            if (subscribed)                                observeroncompleted()                        } catch (interruptedexception e) {                            eprintstacktrace()                            fail(egetmessage())                        }                    }                })                tstart()                return s            }        }    }``` || thanks for the comments and the extra tests i have merged them anduploaded a new versionregarding testconcatunsubscribe: im still not entirely sure of my footingbut i believe the test is in error it is demonstrating exactly the issuewhich i mentioned in the new javadoc for operationconcat specifically itsets up a situation wherein the inner observables thread is blocked on theouter observables thread: the inner thread cannot proceed until the testcalls oktocontinuecountdown() which happens-afterconcatsubscribe(aobserver) which blocks until the list has delivered bothw1 and w2am i right that in general an observer should block onnext() until it hasfinished processing the item? this pushes the flow-control upstream ratherthan excessive buffering or throttling (which can be done explicitly in theoperation-chain if desired) if thats right then i think concat mustblock the outer onnext until it has finished servicing the inner sequencei do find it a little strange that observablefrom(iterable) is a "shotgunobservable" ie the subscribe() blocks until all downstream operationshave completed on all items which means it is impossible to everunsubscribe() but given that this is correct behavior i think that itmakes sense that concat(o1 o2) also cannot be unsubscribed-from i added acautionary comment to the javadoci have updated the test case to call concatsubscribe(aobserver) in abackground thread which fixes the deadlock and to expect all items to bedelivered despite an unsubscribe which makes the test pass(i had also tried those three non-blocking approaches before uploading thisversion thanks for checking my work :)on mar 27 2013 6:56 am "ben christensen" notifications@githubcom wrote:> while reviewing this i started playing with the unit tests and added 2 new> ones i also made them use inorderverify so they ensure correct ordering> ive pasted it below so you can merge into your branch instead of me> complicating the merge with another branch> > the tests pass pass except testconcatunsubscribe which deadlocks it does> this because a list wont return the subscription asynchronously so it> cant unsubscribe meanwhile a countdownlatch is waiting for the change to> trigger and the two latches end up waiting on each other> > i havent thought through enough yet to determine if there is a way to> solve that or if the unit test is just testing the wrong thing and thus a> bad test> > the comment above from @billy  about> countdownlatch originated from a discussion between him and i - but while> reviewing this it is probably the right approach> > i was playing with other approaches that are purely non-blocking while> retaining the correct concat sequential behavior but they all seem to> require either:> - another wrapping thread> - stealing work from one of the child observable threads and making it>   do work that is queued on the others  and that seems like a bad idea>   even though it can be hacked to "work" but it does so in a way that is very>   unexpected and thus not something i want to pursue> - queueing all onnext values which could be a bad memory issue  and>   also means we eagerly subscribe which is not what we want> > my biggest issue right now is that concat(o1 o2) is a very common usage> but that results in list which will be blocking and unsubscribe doesnt> work> > ill think through this more but id appreciate your thoughts on how to> handle testconcatunsubscribe> > ```> public static class unittest {> >     @test>     public void testconcat() {>         @suppresswarnings("unchecked")>         observer<string> observer  mock(observerclass)> >         final string o  { "1" "3" "5" "7" }>         final string e  { "2" "4" "6" }> >         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)> >         @suppresswarnings("unchecked")>         observable<string> concat  observablecreate(concat(odds even))>         concatsubscribe(observer)> >         verify(observer times(7))onnext(anystring())>     }> >     @test>     public void testconcatwithlist() {>         @suppresswarnings("unchecked")>         observer<string> observer  mock(observerclass)> >         final string[] o  { "1" "3" "5" "7" }>         final string[] e  { "2" "4" "6" }> >         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)>         final list<observable<string>> list  new arraylist<observable<string>>()>         listadd(odds)>         listadd(even)>         observable<string> concat  observablecreate(concat(list))>         concatsubscribe(observer)> >         verify(observer times(7))onnext(anystring())>     }> >     @test>     public void testconcatunsubscribe() {>         final countdownlatch callonce  new countdownlatch(1)>         final countdownlatch oktocontinue  new countdownlatch(1)>         final testobservable<string> w1  new testobservable<string>("one" "two" "three")>         final testobservable<string> w2  new testobservable<string>(callonce oktocontinue "four" "five" "six")> >         @suppresswarnings("unchecked")>         observer<string> aobserver  mock(observerclass)>         @suppresswarnings("unchecked")>         observable<string> concat  observablecreate(concat(w1 w2))>         systemoutprintln("before subscribe")>         subscription s1  concatsubscribe(aobserver)>         systemoutprintln("after subscribe")>         try {>             //block main thread to allow observable "w1" to complete and observable "w2" to call onnext once>             systemoutprintln("before callonceawait")>             callonceawait()>             systemoutprintln("after callonceawait")>             s1unsubscribe()>             systemoutprintln("after s1unsubscribe")>             //unblock the observable to continue>             oktocontinuecountdown()>             systemoutprintln("after countdown")>             w1tjoin()>             w2tjoin()>         } catch (exception e) {>             eprintstacktrace()>             fail(egetmessage())>         }> >         inorder inorder  inorder(aobserver)>         inorderverify(aobserver times(1))onnext("one")>         inorderverify(aobserver times(1))onnext("two")>         inorderverify(aobserver times(1))onnext("three")>         inorderverify(aobserver times(1))onnext("four")>         inorderverify(aobserver never())onnext("five")>         inorderverify(aobserver never())onnext("six")>         inorderverify(aobserver times(1))oncompleted()>     }> >     @test>     public void testmergeobservableofobservables() {>         @suppresswarnings("unchecked")>         observer<string> observer  mock(observerclass)> >         final string[] o  { "1" "3" "5" "7" }>         final string[] e  { "2" "4" "6" }> >         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)> >         observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {> >             @override>             public subscription call(observer<observable<string>> observer) {>                 // simulate what would happen in an observable>                 observeronnext(odds)>                 observeronnext(even)>                 observeroncompleted()> >                 return new subscription() {> >                     @override>                     public void unsubscribe() {>                         // unregister  will never be called here since we are executing synchronously>                     }> >                 }>             }> >         })>         observable<string> concat  observablecreate(concat(observableofobservables))>         concatsubscribe(observer)>         verify(observer times(7))onnext(anystring())>     }> >     /**         * simple concat of 2 asynchronous observables ensuring it emits in correct order         */>     @suppresswarnings("unchecked")>     @test>     public void testsimpleasyncconcat() {>         observer<string> observer  mock(observerclass)> >         testobservable<string> o1  new testobservable<string>("one" "two" "three")>         testobservable<string> o2  new testobservable<string>("four" "five" "six")> >         observableconcat(o1 o2)subscribe(observer)> >         try {>             // wait for async observables to complete>             o1tjoin()>             o2tjoin()>         } catch (exception e) {>             throw new runtimeexception("failed waiting on threads")>         }> >         inorder inorder  inorder(observer)>         inorderverify(observer times(1))onnext("one")>         inorderverify(observer times(1))onnext("two")>         inorderverify(observer times(1))onnext("three")>         inorderverify(observer times(1))onnext("four")>         inorderverify(observer times(1))onnext("five")>         inorderverify(observer times(1))onnext("six")>     }> >     /**         * test an async observable that emits more async observables         */>     @suppresswarnings("unchecked")>     @test>     public void testnestedasyncconcat() throws exception {>         observer<string> observer  mock(observerclass)> >         final testobservable<string> o1  new testobservable<string>("one" "two" "three")>         final testobservable<string> o2  new testobservable<string>("four" "five" "six")>         final testobservable<string> o3  new testobservable<string>("seven" "eight" "nine")>         final countdownlatch allowthird  new countdownlatch(1)> >         final atomicreference<thread> parent  new atomicreference<thread>()>         observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {> >             @override>             public subscription call(final observer<observable<string>> observer) {>                 final booleansubscription s  new booleansubscription()>                 parentset(new thread(new runnable() {> >                     @override>                     public void run() {>                         try {>                             // emit first>                             if (!sisunsubscribed()) {>                                 systemoutprintln("emit o1")>                                 observeronnext(o1)>                             }>                             // emit second>                             if (!sisunsubscribed()) {>                                 systemoutprintln("emit o2")>                                 observeronnext(o2)>                             }> >                             // wait until sometime later and emit third>                             try {>                                 allowthirdawait()>                             } catch (interruptedexception e) {>                                 observeronerror(e)>                             }>                             if (!sisunsubscribed()) {>                                 systemoutprintln("emit o3")>                                 observeronnext(o3)>                             }> >                         } catch (exception e) {>                             observeronerror(e)>                         } finally {>                             systemoutprintln("done parent observable")>                             observeroncompleted()>                         }>                     }>                 }))>                 parentget()start()>                 return s>             }>         })> >         observablecreate(concat(observableofobservables))subscribe(observer)> >         // wait for parent to start>         while (parentget()  null) {>             threadsleep(1)>         }> >         try {>             // wait for first 2 async observables to complete>             while (o1t  null) {>                 threadsleep(1)>             }>             systemoutprintln("thread1 started  waiting for it to complete ")>             o1tjoin()>             while (o2t  null) {>                 threadsleep(1)>             }>             systemoutprintln("thread2 started  waiting for it to complete ")>             o2tjoin()>         } catch (exception e) {>             throw new runtimeexception("failed waiting on threads" e)>         }> >         inorder inorder  inorder(observer)>         inorderverify(observer times(1))onnext("one")>         inorderverify(observer times(1))onnext("two")>         inorderverify(observer times(1))onnext("three")>         inorderverify(observer times(1))onnext("four")>         inorderverify(observer times(1))onnext("five")>         inorderverify(observer times(1))onnext("six")>         // we shouldnt have the following 3 yet>         inorderverify(observer never())onnext("seven")>         inorderverify(observer never())onnext("eight")>         inorderverify(observer never())onnext("nine")>         // we should not be completed yet>         verify(observer never())oncompleted()>         verify(observer never())onerror(any(exceptionclass))> >         // now allow the third>         allowthirdcountdown()> >         try {>             while (o3t  null) {>                 threadsleep(1)>             }>             // wait for 3rd to complete>             o3tjoin()>         } catch (exception e) {>             throw new runtimeexception("failed waiting on threads" e)>         }> >         inorderverify(observer times(1))onnext("seven")>         inorderverify(observer times(1))onnext("eight")>         inorderverify(observer times(1))onnext("nine")> >         inorderverify(observer times(1))oncompleted()>         verify(observer never())onerror(any(exceptionclass))>     }> >     @suppresswarnings("unchecked")>     @test>     public void testblockedobservableofobservables() {>         observer<string> observer  mock(observerclass)> >         final string[] o  { "1" "3" "5" "7" }>         final string[] e  { "2" "4" "6" }>         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)>         final countdownlatch callonce  new countdownlatch(1)>         final countdownlatch oktocontinue  new countdownlatch(1)>         testobservable<observable<string>> observableofobservables  new testobservable<observable<string>>(callonce oktocontinue odds even)>         func1<observer<string> subscription> concatf  concat(observableofobservables)>         observable<string> concat  observablecreate(concatf)>         concatsubscribe(observer)>         try {>             //block main thread to allow observables to serve up o1>             callonceawait()>         } catch (exception ex) {>             exprintstacktrace()>             fail(exgetmessage())>         }>         // the concated observable should have served up all of the odds>         verify(observer times(1))onnext("1")>         verify(observer times(1))onnext("3")>         verify(observer times(1))onnext("5")>         verify(observer times(1))onnext("7")> >         try {>             // unblock observables so it can serve up o2 and complete>             oktocontinuecountdown()>             observableofobservablestjoin()>         } catch (exception ex) {>             exprintstacktrace()>             fail(exgetmessage())>         }>         // the concatenated observable should now have served up all the evens>         verify(observer times(1))onnext("2")>         verify(observer times(1))onnext("4")>         verify(observer times(1))onnext("6")>     }> >     private static class testobservable<t> extends observable<t> {> >         private final subscription s  new subscription() {> >             @override>             public void unsubscribe() {>                 subscribed  false>             }> >         }>         private final list<t> values>         private thread t  null>         private int count  0>         private boolean subscribed  true>         private final countdownlatch once>         private final countdownlatch oktocontinue> >         public testobservable(t values) {>             this(null null values)>         }> >         public testobservable(countdownlatch once countdownlatch oktocontinue t values) {>             thisvalues  arraysaslist(values)>             thisonce  once>             thisoktocontinue  oktocontinue>         }> >         @override>         public subscription subscribe(final observer<t> observer) {>             t  new thread(new runnable() {> >                 @override>                 public void run() {>                     try {>                         while (count < valuessize() && subscribed) {>                             observeronnext(valuesget(count))>                             count++>                             //unblock the main thread to call unsubscribe>                             if (null ! once)>                                 oncecountdown()>                             //block until the main thread has called unsubscribe>                             if (null ! once)>                                 oktocontinueawait()>                         }>                         if (subscribed)>                             observeroncompleted()>                     } catch (interruptedexception e) {>                         eprintstacktrace()>                         fail(egetmessage())>                     }>                 }> >             })>             tstart()>             return s>         }> >     }> > }> ```> > > reply to this email directly or view it on github  || #59  #60 thanks for update  let me take a look and i will do some moreresearch/thought on the testconcatsubscribe test caseon fri mar 29 2013 at 2:22 am cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #60 > this pull request looks good> > —> reply to this email directly or view it on github  || [rxjava-pull-requests #72 looks good || my original test case was intended to test the unsubscribe inside one ofchild observable   the countdownlatch was used so that the code will havea chance to unsubscribe in a predicable manner (unsubscribe after "four") in a normal case there should be no blocking between inner and outerobservable  i rewrote the case for better clarity and having the outerobservable is in a separate thread (so the test will pass now)  youbrought up a good point about "when" you can unsubscribe  should it onlyallow unsubscribe to happen during the outer onnext()?  i need to do moreresearch on it  here is the test i plan to add```    @test``` public void testconcatunsubscribeobservableofobservable() {```        final countdownlatch callonce  new countdownlatch(1)        final countdownlatch oktocontinue  new countdownlatch(1)        final testobservable<string> w1  new testobservable<string>(```"one" "two" "three")```        final testobservable<string> w2 ```newtestobservable<string>(callonce oktocontinue"four" "five" "six")```        @suppresswarnings("unchecked")        observer<string> aobserver  mock(observerclass)        @suppresswarnings("unchecked")```   testobservable<observable<string>> observableofobservables newtestobservable<observable<string>>(w1 w2)```        func1<observer<string> subscription> concatf ```concat(observableofobservables)```        observable<string> concat  observablecreate(concatf)        subscription s1  concatsubscribe(aobserver)        try {            //block main thread to allow observable "w1" to complete```and observable "w2" to call onnext exactly once```        callonceawait()        //"four" has been processed by onnext()            s1unsubscribe()            //"five" and "six" will not be processed by onnext()            //unblock the observable to continue            oktocontinuecountdown()            w1tjoin()            w2tjoin()        } catch (exception e) {            eprintstacktrace()            fail(egetmessage())        }        inorder inorder  inorder(aobserver)        inorderverify(aobserver times(1))onnext("one")        inorderverify(aobserver times(1))onnext("two")        inorderverify(aobserver times(1))onnext("three")        inorderverify(aobserver times(1))onnext("four")        inorderverify(aobserver never())onnext("five")        inorderverify(aobserver never())onnext("six")        verify(aobserver never())oncompleted()        verify(aobserver never())onerror(any(exceptionclass))```  }on tue apr 2 2013 at 8:55 pm cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #72 > this pull request looks good> > —> reply to this email directly or view it on github  || the rx net version of concat uses the immediatescheduler to execute theoperation which will execute the operation on the same calling thread  soif the observables are running on the same thread it will besynchronous/blocked   i have pulled in your changes from your fork andadded the additional unit test to test unsubscribe() with observablesrunning in different thread  i have also updated the javadoc about theblocking with observable on the same thread  from my side it looks goodon wed apr 3 2013 at 10:20 am billy yuen billyy@gmailcom wrote:> my original test case was intended to test the unsubscribe inside one of> child observable   the countdownlatch was used so that the code will have> a chance to unsubscribe in a predicable manner (unsubscribe after "four")>  in a normal case there should be no blocking between inner and outer> observable  i rewrote the case for better clarity and having the outer> observable is in a separate thread (so the test will pass now)  you> brought up a good point about "when" you can unsubscribe  should it only> allow unsubscribe to happen during the outer onnext()?  i need to do more> research on it  here is the test i plan to add> > ```>     @test> ```> >  public void testconcatunsubscribeobservableofobservable() {> > ```>         final countdownlatch callonce  new countdownlatch(1)> >         final countdownlatch oktocontinue  new countdownlatch(1)> >         final testobservable<string> w1  new testobservable<string>(> ```> > "one" "two" "three")> > ```>         final testobservable<string> w2  newtestobservable<string>(callonce oktocontinue> ```> > "four" "five" "six")> > ```>         @suppresswarnings("unchecked")> >         observer<string> aobserver  mock(observerclass)> >         @suppresswarnings("unchecked")> ```> >    testobservable<observable<string>> observableofobservables  newtestobservable<observable<string>>(w1 w2)> > ```>         func1<observer<string> subscription> concatf > ```> > concat(observableofobservables)> > ```>         observable<string> concat  observablecreate(concatf)> > > >         subscription s1  concatsubscribe(aobserver)> > > >         try {> >             //block main thread to allow observable "w1" to complete> ```> > and observable "w2" to call onnext exactly once> > ```>         callonceawait()> >         //"four" has been processed by onnext()> >             s1unsubscribe()> >             //"five" and "six" will not be processed by onnext()> >             //unblock the observable to continue> >             oktocontinuecountdown()> >             w1tjoin()> >             w2tjoin()> >         } catch (exception e) {> >             eprintstacktrace()> >             fail(egetmessage())> >         }> > >         inorder inorder  inorder(aobserver)> >         inorderverify(aobserver times(1))onnext("one")> >         inorderverify(aobserver times(1))onnext("two")> >         inorderverify(aobserver times(1))onnext("three")> >         inorderverify(aobserver times(1))onnext("four")> >         inorderverify(aobserver never())onnext("five")> >         inorderverify(aobserver never())onnext("six")> >         verify(aobserver never())oncompleted()> >         verify(aobserver never())onerror(any(exceptionclass))> ```> >   }> > on tue apr 2 2013 at 8:55 pm cloudbees pull request builder plugin <> notifications@githubcom> wrote:> > > rxjava-pull-requests #72 > > > this pull request looks good> > > > —> > reply to this email directly or view it on github >  || > i do find it a little strange that observablefrom(iterable) is a "shotgun> observable" ie the subscribe() blocks until all downstream operations> have completed on all items which means it is impossible to ever> unsubscribe() but given that this is correct behavior i think that it> makes sense that concat(o1 o2) also cannot be unsubscribed-from i added a> cautionary comment to the javadocrx does not (or rarely does) add concurrency (see guideline 612) thus `observablefrom` is wrapping a synchronous iterable therefore the observable will be synchronousa `scheduler` could be used to make the subscription to an iterable happen on another thread or a custom `observable` could be created that handles an iterable asynchronouslyall rx operators must be capable of handling both synchronous and asynchronous sequences and if its synchronous that means unsubscribe will not work (which means its up to the implementor of an observable to understand this and decided if its okay to firehose the results)for the case of concat my concern is that if all the sequences being combined are async then we need to retain the async behavior and not block and prevent unsubscriptionfor example:- async or synchronous observablea with 10 items- async or synchronous observableb with 20 items- async observablec with infinite items (hot observable that never completed)i should be able to do this: `concat(a b c)take(50)` this should get the 10 items from a 20 items from b and first 20 items from c and then unsubscribe and continuedoes this work with the current implementation and correctly unsubscribe from observablec? || good point  the best way to tell is to build an unit test for this case i can expand my new test to include this case and see what happenon wed apr 3 2013 at 2:29 pm ben christensen notifications@githubcomwrote:> i do find it a little strange that observablefrom(iterable) is a "shotgun> observable" ie the subscribe() blocks until all downstream operations> have completed on all items which means it is impossible to ever> unsubscribe() but given that this is correct behavior i think that it> makes sense that concat(o1 o2) also cannot be unsubscribed-from i added a> cautionary comment to the javadoc> > rx does not (or rarely does) add concurrency (see guideline 612) thus> observablefrom is wrapping a synchronous iterable therefore the> observable will be synchronous> > a scheduler could be used to make the subscription to an iterable happen> on another thread or a custom observable could be created that handles> an iterable asynchronously> > all rx operators must be capable of handling both synchronous and> asynchronous sequences and if its synchronous that means unsubscribe will> not work (which means its up to the implementor of an observable to> understand this and decided if its okay to firehose the results)> > for the case of concat my concern is that if all the sequences being> combined are async then we need to retain the async behavior and not block> and prevent unsubscription> > for example:> - async or synchronous observablea with 10 items> - async or synchronous observableb with 20 items> - async observablec with infinite items (hot observable that never>   completed)> > i should be able to do this:> > concat(a b c)take(50)> > this should get the 10 items from a 20 items from b and first 20 items> from c and then unsubscribe and continue> > does this work with the current implementation and correctly unsubscribe> from observablec?> > —> reply to this email directly or view it on github  || 
225,1,0,0,0,0,0,1,0,schedulers (merge of pull #199) manual merge of  by @mairbek plus the following changes:- made some classes non-public so they dont become part of the published api (if we find they have value in the public api we can make them so but once published its hard to remove them so id rather keep them implementation details until then)- consolidated executorscheduler and scheduledexecutorscheduler- made executorscheduler use a system-wide scheduledexecutorscheduler for handling delayed events when only an executor is available- made the iothreadpool use a non-bounded cached thread-pool next step from here is to review all operator implementations and add the scheduler overloads #77  #78 the unit test is poorly written (non-deterministic) ill fix in the morning  || awesome work! - with this it should be easy to implement operators like "sample" etc || yes it should open the gates to many operators we havent been able to pursue || committed a few tweaks and fixesopen questions for me are:- were not using the schedulernow value anywhere should we be? or is that only for the virtual scheduler used for testing?- not quite sure how the overloads should work on `merge` etc  ive implemented them but the behavior might not yet match c# || can someone with an rxnet environment setup implement a test similar to this from java and tell me the output?``` java@test    public void testmixedschedulers() throws interruptedexception {        final string mainthreadname  threadcurrentthread()getname()        observable<string> o  observable<string> create(new func1<observer<string> subscription>() {            @override            public subscription call(observer<string> observer) {                systemoutprintln("origin observable is running on: " + threadcurrentthread()getname())                assertfalse(threadcurrentthread()getname()equals(mainthreadname))                asserttrue("actually: " + threadcurrentthread()getname() threadcurrentthread()getname()startswith("rxiothreadpool"))                observeronnext("one")                observeronnext("two")                observeronnext("three")                observeroncompleted()                return subscriptionsempty()            }        })subscribeon(schedulersthreadpoolforio()) // subscribe to the source on the io thread pool        // now merge on the cpu threadpool        o  observable<string> merge(o observable<string> from("four" "five"))                subscribeon(schedulersthreadpoolforcomputation())                map(new func1<string string>() {                    @override                    public string call(string v) {                        // opportunity to see what thread the merge is running on                        systemoutprintln("merge is running on: " + threadcurrentthread()getname())                        return v                    }                })        final countdownlatch latch  new countdownlatch(1)        final atomicreference<runtimeexception> onerror  new atomicreference<runtimeexception>()        // subscribe on a new thread        osubscribe(new observer<string>() {            @override            public void oncompleted() {                systemoutprintln("> received oncompleted")                latchcountdown()            }            @override            public void onerror(exception e) {                systemoutprintln("> received onerror: " + egetmessage())                onerrorset((runtimeexception) e)                latchcountdown()            }            @override            public void onnext(string v) {                systemoutprintln("> final subscribe is running on: " + threadcurrentthread()getname())                systemoutprintln("> onnext: " + v)            }        } schedulersnewthread())        // wait for the above to finish or blow up if its blocked        latchawait(5 timeunitseconds)    }```im trying to understand how a sequence should work when multiple `subscribeon` operators are applied at different steps of a sequenceof course rxnet doesnt have the io and cpu thread pools  those are just helper methods to executors which would be 2 separate threadpools for different work types so youll need to adjust that || #79 is there any reason to use `schedulerschedule` on an internal operator implementation instead of just leveraging `subscribeon` (other than when we need the delay arguments of course)?for example on a method overload of `merge` is this okay?``` java        return merge(source)subscribeon(scheduler)```or is there some reason to inside the `operationmerge` do this:``` java                return schedulerschedule(new func0<subscription>() {                    @override                    public subscription call() {                        return new mergeobservable<t>(o)call(observer)                    }                })```they seem to accomplish the same thing but would like to know if theres a reason to prefer one over the otheri prefer just reusing `subscribeon` i cant tell from reading c# code what it does as i cant find the extensions that implement the override methods! || im pulling the trigger and merging this into master so people can start playing with it and providing feedbackthe public api changes are fairly limited still so most changes (which i fully expect) will be implementation details || [rxjava-pull-requests #80 looks good || 
225,1,0,1,0,0,0,1,0,schedulers (merge of pull #199) manual merge of  by @mairbek plus the following changes:- made some classes non-public so they dont become part of the published api (if we find they have value in the public api we can make them so but once published its hard to remove them so id rather keep them implementation details until then)- consolidated executorscheduler and scheduledexecutorscheduler- made executorscheduler use a system-wide scheduledexecutorscheduler for handling delayed events when only an executor is available- made the iothreadpool use a non-bounded cached thread-pool next step from here is to review all operator implementations and add the scheduler overloads #77  #78 the unit test is poorly written (non-deterministic) ill fix in the morning  || awesome work! - with this it should be easy to implement operators like "sample" etc || yes it should open the gates to many operators we havent been able to pursue || committed a few tweaks and fixesopen questions for me are:- were not using the schedulernow value anywhere should we be? or is that only for the virtual scheduler used for testing?- not quite sure how the overloads should work on `merge` etc  ive implemented them but the behavior might not yet match c# || can someone with an rxnet environment setup implement a test similar to this from java and tell me the output?``` java@test    public void testmixedschedulers() throws interruptedexception {        final string mainthreadname  threadcurrentthread()getname()        observable<string> o  observable<string> create(new func1<observer<string> subscription>() {            @override            public subscription call(observer<string> observer) {                systemoutprintln("origin observable is running on: " + threadcurrentthread()getname())                assertfalse(threadcurrentthread()getname()equals(mainthreadname))                asserttrue("actually: " + threadcurrentthread()getname() threadcurrentthread()getname()startswith("rxiothreadpool"))                observeronnext("one")                observeronnext("two")                observeronnext("three")                observeroncompleted()                return subscriptionsempty()            }        })subscribeon(schedulersthreadpoolforio()) // subscribe to the source on the io thread pool        // now merge on the cpu threadpool        o  observable<string> merge(o observable<string> from("four" "five"))                subscribeon(schedulersthreadpoolforcomputation())                map(new func1<string string>() {                    @override                    public string call(string v) {                        // opportunity to see what thread the merge is running on                        systemoutprintln("merge is running on: " + threadcurrentthread()getname())                        return v                    }                })        final countdownlatch latch  new countdownlatch(1)        final atomicreference<runtimeexception> onerror  new atomicreference<runtimeexception>()        // subscribe on a new thread        osubscribe(new observer<string>() {            @override            public void oncompleted() {                systemoutprintln("> received oncompleted")                latchcountdown()            }            @override            public void onerror(exception e) {                systemoutprintln("> received onerror: " + egetmessage())                onerrorset((runtimeexception) e)                latchcountdown()            }            @override            public void onnext(string v) {                systemoutprintln("> final subscribe is running on: " + threadcurrentthread()getname())                systemoutprintln("> onnext: " + v)            }        } schedulersnewthread())        // wait for the above to finish or blow up if its blocked        latchawait(5 timeunitseconds)    }```im trying to understand how a sequence should work when multiple `subscribeon` operators are applied at different steps of a sequenceof course rxnet doesnt have the io and cpu thread pools  those are just helper methods to executors which would be 2 separate threadpools for different work types so youll need to adjust that || #79 is there any reason to use `schedulerschedule` on an internal operator implementation instead of just leveraging `subscribeon` (other than when we need the delay arguments of course)?for example on a method overload of `merge` is this okay?``` java        return merge(source)subscribeon(scheduler)```or is there some reason to inside the `operationmerge` do this:``` java                return schedulerschedule(new func0<subscription>() {                    @override                    public subscription call() {                        return new mergeobservable<t>(o)call(observer)                    }                })```they seem to accomplish the same thing but would like to know if theres a reason to prefer one over the otheri prefer just reusing `subscribeon` i cant tell from reading c# code what it does as i cant find the extensions that implement the override methods! || im pulling the trigger and merging this into master so people can start playing with it and providing feedbackthe public api changes are fairly limited still so most changes (which i fully expect) will be implementation details || [rxjava-pull-requests #80 looks good || 
225,1,0,1,1,1,1,1,1,schedulers (merge of pull #199) manual merge of  by @mairbek plus the following changes:- made some classes non-public so they dont become part of the published api (if we find they have value in the public api we can make them so but once published its hard to remove them so id rather keep them implementation details until then)- consolidated executorscheduler and scheduledexecutorscheduler- made executorscheduler use a system-wide scheduledexecutorscheduler for handling delayed events when only an executor is available- made the iothreadpool use a non-bounded cached thread-pool next step from here is to review all operator implementations and add the scheduler overloads #77  #78 the unit test is poorly written (non-deterministic) ill fix in the morning  || awesome work! - with this it should be easy to implement operators like "sample" etc || yes it should open the gates to many operators we havent been able to pursue || committed a few tweaks and fixesopen questions for me are:- were not using the schedulernow value anywhere should we be? or is that only for the virtual scheduler used for testing?- not quite sure how the overloads should work on `merge` etc  ive implemented them but the behavior might not yet match c# || can someone with an rxnet environment setup implement a test similar to this from java and tell me the output?``` java@test    public void testmixedschedulers() throws interruptedexception {        final string mainthreadname  threadcurrentthread()getname()        observable<string> o  observable<string> create(new func1<observer<string> subscription>() {            @override            public subscription call(observer<string> observer) {                systemoutprintln("origin observable is running on: " + threadcurrentthread()getname())                assertfalse(threadcurrentthread()getname()equals(mainthreadname))                asserttrue("actually: " + threadcurrentthread()getname() threadcurrentthread()getname()startswith("rxiothreadpool"))                observeronnext("one")                observeronnext("two")                observeronnext("three")                observeroncompleted()                return subscriptionsempty()            }        })subscribeon(schedulersthreadpoolforio()) // subscribe to the source on the io thread pool        // now merge on the cpu threadpool        o  observable<string> merge(o observable<string> from("four" "five"))                subscribeon(schedulersthreadpoolforcomputation())                map(new func1<string string>() {                    @override                    public string call(string v) {                        // opportunity to see what thread the merge is running on                        systemoutprintln("merge is running on: " + threadcurrentthread()getname())                        return v                    }                })        final countdownlatch latch  new countdownlatch(1)        final atomicreference<runtimeexception> onerror  new atomicreference<runtimeexception>()        // subscribe on a new thread        osubscribe(new observer<string>() {            @override            public void oncompleted() {                systemoutprintln("> received oncompleted")                latchcountdown()            }            @override            public void onerror(exception e) {                systemoutprintln("> received onerror: " + egetmessage())                onerrorset((runtimeexception) e)                latchcountdown()            }            @override            public void onnext(string v) {                systemoutprintln("> final subscribe is running on: " + threadcurrentthread()getname())                systemoutprintln("> onnext: " + v)            }        } schedulersnewthread())        // wait for the above to finish or blow up if its blocked        latchawait(5 timeunitseconds)    }```im trying to understand how a sequence should work when multiple `subscribeon` operators are applied at different steps of a sequenceof course rxnet doesnt have the io and cpu thread pools  those are just helper methods to executors which would be 2 separate threadpools for different work types so youll need to adjust that || #79 is there any reason to use `schedulerschedule` on an internal operator implementation instead of just leveraging `subscribeon` (other than when we need the delay arguments of course)?for example on a method overload of `merge` is this okay?``` java        return merge(source)subscribeon(scheduler)```or is there some reason to inside the `operationmerge` do this:``` java                return schedulerschedule(new func0<subscription>() {                    @override                    public subscription call() {                        return new mergeobservable<t>(o)call(observer)                    }                })```they seem to accomplish the same thing but would like to know if theres a reason to prefer one over the otheri prefer just reusing `subscribeon` i cant tell from reading c# code what it does as i cant find the extensions that implement the override methods! || im pulling the trigger and merging this into master so people can start playing with it and providing feedbackthe public api changes are fairly limited still so most changes (which i fully expect) will be implementation details || [rxjava-pull-requests #80 looks good || 
228,1,0,0,0,0,0,1,0,interval i have attempted to implement the "interval" operator (#55) here as far as i can see it seems to work this is based on the quite fresh work on schedulersit doesnt work with the `currentthread` or `newthread` schedulers i guess due to the simple `sleepingaction` it does work with a `scheduledexecutorservice` thoughfor testing this conveniently i also wrote a test scheduler with adjustable timelooking forward to any review comments #83 #84  lets consider adding new method to the `scheduler```` javascheduleperiodically(action0 action long initialdelay long period timeunit unit) ```it would allow to leverage `scheduledexecutorservice#scheduleatrate` for the `executorscheduler` for other schedulers we could use recursive action scheduling from pull request #229  || i agree `scheduleperiodically` would be helpful here || @jmhofer do you plan to work on this feature? im thinking about implementing buffer operator #16 and this one will be very helpful for me || ill have a look at it || maybe we should also combine all the longs and units into a timespan class? - it doesnt feel right to always have them as separate parameters || anyone know why net wouldnt have a `scheduleperiodically` concept? if we were to add that it would only really work with `scheduledexecutorservice` and thus most `scheduler` implementations would have to rely upon the generic `scheduledexecutorservice` that ive added in  called `genericscheduledexecutorservice`this suggests to me that it isnt the right solution to add another interface method as it seems very tied to a particular implementation cant this be achieved with recursive schedulers which now work after the changes you did in  || im curious about this:> it doesnt work with the currentthread or newthread schedulers i guess due to the simple sleepingaction it does work with a scheduledexecutorservice thoughit seems that this operator needs to be async and must default to using something like `schedulersthreadpoolforcomputation()`documentation at msdn ( suggests that this defaults to using a thread-pool scheduler:> the following example code uses the interval operator to generate a sequence of long integers staring at zero each integer in the sequence is generated after the two second period has expired each integer is written to the console window along with the current time to show the period parameter in effect the generation of the integer sequence is scheduled to run on a thread from the net thread pool so the main thread is not blocked and can process the enter key being pressed to stop the intervalperhaps `newthreadscheduler` will work as of  because it now uses `genericscheduledexecutorservice` when a delay is passed in instead of `sleepingaction`what happens in net if someone tries to use `immediatescheduler` or `currentthreadscheduler`? anyone have access to net to try that? || > maybe we should also combine all the longs and units into a timespan class? - it doesnt feel right to always have them as separate parametersif were going to consider doing this then we should do it as part of  before i release another version since this would change the `schedulers` interfacejava itself always keeps the 2 separate though so perhaps the idiomatic thing to do in java is to keep them separate? i dont have a strong opinion on this one but the decision made now will last a very long time || actually net does have `scheduleperiodic` see here:  its useful to avoid recursive scheduling where the schedulers support this directly as well as to do the slightly messy recursive scheduling ourselves for other types of schedulers so that the user doesnt have to || ah interesting thanks for educating me on that || this doesnt look like its been integrated into observable but im going to merge as it looks useful to get this in  the testscheduler especially while interval continues getting work done || great thanks (this still needs a bit of work if/when we do periodic scheduling) || are you okay with me releasing current code on the master branch and then the rest of `interval` coming later?is there anything else about master branch as it stands that should be changed before i release? id like to do so today || thats alright with me || @benjchristensen now the `interval` operators in rxjava and rxnet have different behaviors when the scheduler is `currentthread`in rxnet the following codes``` c#            var o  observableinterval(timespanfrommilliseconds(100) schedulercurrentthread)            otake(5)subscribe(                x > consolewriteline(x)            )            otake(4)subscribe(                x > consolewriteline(x)            )            consolereadline()```output```012340123```in rxjava the following codes``` java            observable<long> o   observableinterval(100 timeunitmilliseconds                    schedulerscurrentthread())            otake(5)subscribe(new action1<long>() {                @override                public void call(long t1) {                    systemoutprintln(t1)                }            })            otake(4)subscribe(new action1<long>() {                @override                public void call(long t1) {                    systemoutprintln(t1)                }            })```output```01234```and the current thread is blocked at the first `subscribe`is it ok or the `interval` operator should not be used with `currentthread`? ||
228,1,0,1,0,0,0,1,0,interval i have attempted to implement the "interval" operator (#55) here as far as i can see it seems to work this is based on the quite fresh work on schedulersit doesnt work with the `currentthread` or `newthread` schedulers i guess due to the simple `sleepingaction` it does work with a `scheduledexecutorservice` thoughfor testing this conveniently i also wrote a test scheduler with adjustable timelooking forward to any review comments #83 #84  lets consider adding new method to the `scheduler```` javascheduleperiodically(action0 action long initialdelay long period timeunit unit) ```it would allow to leverage `scheduledexecutorservice#scheduleatrate` for the `executorscheduler` for other schedulers we could use recursive action scheduling from pull request #229  || i agree `scheduleperiodically` would be helpful here || @jmhofer do you plan to work on this feature? im thinking about implementing buffer operator #16 and this one will be very helpful for me || ill have a look at it || maybe we should also combine all the longs and units into a timespan class? - it doesnt feel right to always have them as separate parameters || anyone know why net wouldnt have a `scheduleperiodically` concept? if we were to add that it would only really work with `scheduledexecutorservice` and thus most `scheduler` implementations would have to rely upon the generic `scheduledexecutorservice` that ive added in  called `genericscheduledexecutorservice`this suggests to me that it isnt the right solution to add another interface method as it seems very tied to a particular implementation cant this be achieved with recursive schedulers which now work after the changes you did in  || im curious about this:> it doesnt work with the currentthread or newthread schedulers i guess due to the simple sleepingaction it does work with a scheduledexecutorservice thoughit seems that this operator needs to be async and must default to using something like `schedulersthreadpoolforcomputation()`documentation at msdn ( suggests that this defaults to using a thread-pool scheduler:> the following example code uses the interval operator to generate a sequence of long integers staring at zero each integer in the sequence is generated after the two second period has expired each integer is written to the console window along with the current time to show the period parameter in effect the generation of the integer sequence is scheduled to run on a thread from the net thread pool so the main thread is not blocked and can process the enter key being pressed to stop the intervalperhaps `newthreadscheduler` will work as of  because it now uses `genericscheduledexecutorservice` when a delay is passed in instead of `sleepingaction`what happens in net if someone tries to use `immediatescheduler` or `currentthreadscheduler`? anyone have access to net to try that? || > maybe we should also combine all the longs and units into a timespan class? - it doesnt feel right to always have them as separate parametersif were going to consider doing this then we should do it as part of  before i release another version since this would change the `schedulers` interfacejava itself always keeps the 2 separate though so perhaps the idiomatic thing to do in java is to keep them separate? i dont have a strong opinion on this one but the decision made now will last a very long time || actually net does have `scheduleperiodic` see here:  its useful to avoid recursive scheduling where the schedulers support this directly as well as to do the slightly messy recursive scheduling ourselves for other types of schedulers so that the user doesnt have to || ah interesting thanks for educating me on that || this doesnt look like its been integrated into observable but im going to merge as it looks useful to get this in  the testscheduler especially while interval continues getting work done || great thanks (this still needs a bit of work if/when we do periodic scheduling) || are you okay with me releasing current code on the master branch and then the rest of `interval` coming later?is there anything else about master branch as it stands that should be changed before i release? id like to do so today || thats alright with me || @benjchristensen now the `interval` operators in rxjava and rxnet have different behaviors when the scheduler is `currentthread`in rxnet the following codes``` c#            var o  observableinterval(timespanfrommilliseconds(100) schedulercurrentthread)            otake(5)subscribe(                x > consolewriteline(x)            )            otake(4)subscribe(                x > consolewriteline(x)            )            consolereadline()```output```012340123```in rxjava the following codes``` java            observable<long> o   observableinterval(100 timeunitmilliseconds                    schedulerscurrentthread())            otake(5)subscribe(new action1<long>() {                @override                public void call(long t1) {                    systemoutprintln(t1)                }            })            otake(4)subscribe(new action1<long>() {                @override                public void call(long t1) {                    systemoutprintln(t1)                }            })```output```01234```and the current thread is blocked at the first `subscribe`is it ok or the `interval` operator should not be used with `currentthread`? ||
228,1,0,0,0,0,0,1,0,interval i have attempted to implement the "interval" operator (#55) here as far as i can see it seems to work this is based on the quite fresh work on schedulersit doesnt work with the `currentthread` or `newthread` schedulers i guess due to the simple `sleepingaction` it does work with a `scheduledexecutorservice` thoughfor testing this conveniently i also wrote a test scheduler with adjustable timelooking forward to any review comments #83 #84  lets consider adding new method to the `scheduler```` javascheduleperiodically(action0 action long initialdelay long period timeunit unit) ```it would allow to leverage `scheduledexecutorservice#scheduleatrate` for the `executorscheduler` for other schedulers we could use recursive action scheduling from pull request #229  || i agree `scheduleperiodically` would be helpful here || @jmhofer do you plan to work on this feature? im thinking about implementing buffer operator #16 and this one will be very helpful for me || ill have a look at it || maybe we should also combine all the longs and units into a timespan class? - it doesnt feel right to always have them as separate parameters || anyone know why net wouldnt have a `scheduleperiodically` concept? if we were to add that it would only really work with `scheduledexecutorservice` and thus most `scheduler` implementations would have to rely upon the generic `scheduledexecutorservice` that ive added in  called `genericscheduledexecutorservice`this suggests to me that it isnt the right solution to add another interface method as it seems very tied to a particular implementation cant this be achieved with recursive schedulers which now work after the changes you did in  || im curious about this:> it doesnt work with the currentthread or newthread schedulers i guess due to the simple sleepingaction it does work with a scheduledexecutorservice thoughit seems that this operator needs to be async and must default to using something like `schedulersthreadpoolforcomputation()`documentation at msdn ( suggests that this defaults to using a thread-pool scheduler:> the following example code uses the interval operator to generate a sequence of long integers staring at zero each integer in the sequence is generated after the two second period has expired each integer is written to the console window along with the current time to show the period parameter in effect the generation of the integer sequence is scheduled to run on a thread from the net thread pool so the main thread is not blocked and can process the enter key being pressed to stop the intervalperhaps `newthreadscheduler` will work as of  because it now uses `genericscheduledexecutorservice` when a delay is passed in instead of `sleepingaction`what happens in net if someone tries to use `immediatescheduler` or `currentthreadscheduler`? anyone have access to net to try that? || > maybe we should also combine all the longs and units into a timespan class? - it doesnt feel right to always have them as separate parametersif were going to consider doing this then we should do it as part of  before i release another version since this would change the `schedulers` interfacejava itself always keeps the 2 separate though so perhaps the idiomatic thing to do in java is to keep them separate? i dont have a strong opinion on this one but the decision made now will last a very long time || actually net does have `scheduleperiodic` see here:  its useful to avoid recursive scheduling where the schedulers support this directly as well as to do the slightly messy recursive scheduling ourselves for other types of schedulers so that the user doesnt have to || ah interesting thanks for educating me on that || this doesnt look like its been integrated into observable but im going to merge as it looks useful to get this in  the testscheduler especially while interval continues getting work done || great thanks (this still needs a bit of work if/when we do periodic scheduling) || are you okay with me releasing current code on the master branch and then the rest of `interval` coming later?is there anything else about master branch as it stands that should be changed before i release? id like to do so today || thats alright with me || @benjchristensen now the `interval` operators in rxjava and rxnet have different behaviors when the scheduler is `currentthread`in rxnet the following codes``` c#            var o  observableinterval(timespanfrommilliseconds(100) schedulercurrentthread)            otake(5)subscribe(                x > consolewriteline(x)            )            otake(4)subscribe(                x > consolewriteline(x)            )            consolereadline()```output```012340123```in rxjava the following codes``` java            observable<long> o   observableinterval(100 timeunitmilliseconds                    schedulerscurrentthread())            otake(5)subscribe(new action1<long>() {                @override                public void call(long t1) {                    systemoutprintln(t1)                }            })            otake(4)subscribe(new action1<long>() {                @override                public void call(long t1) {                    systemoutprintln(t1)                }            })```output```01234```and the current thread is blocked at the first `subscribe`is it ok or the `interval` operator should not be used with `currentthread`? ||
229,1,0,0,0,0,0,1,0,trying to extend the scheduler interface according to the comments at ive tried to extend the `scheduler` interface according to the discussion at issue #19 if i understand this correctly most of it can be done via the `abstractscheduler`i hope this helps please have a look #85  awesome looks like it doesnt break a `scheduler` interface i thought about two examples``` java        final scheduler scheduler  schedulerscurrentthread()        observable<integer> obs  observablecreate(new func1<observer<integer> subscription>() {            @override            public subscription call(final observer<integer> observer) {                return schedulerschedule(0 new func2<scheduler integer subscription>() {                    @override                    public subscription call(scheduler scheduler integer i) {                        if (i > 42) {                            observeroncompleted()                            return subscriptionsempty()                        }                        observeronnext(i)                        return schedulerschedule(i + 1 this)                    }                })            }        })        obssubscribe(new observer<integer>() {            @override            public void oncompleted() {                systemoutprintln("completed")            }            @override            public void onerror(exception e) {                systemoutprintln("error")            }            @override            public void onnext(integer args) {                systemoutprintln(args)            }        })```and``` java        final scheduler scheduler  schedulersthreadpoolforcomputation()        observable<integer> obs  observablecreate(new func1<observer<integer> subscription>() {            @override            public subscription call(final observer<integer> observer) {                return schedulerschedule(new booleansubscription() new func2<scheduler booleansubscription subscription>() {                    @override                    public subscription call(scheduler scheduler booleansubscription cancel) {                        if (cancelisunsubscribed()) {                            observeroncompleted()                            return subscriptionsempty()                        }                        observeronnext(42)                        try {                            threadsleep(1000)                        } catch (interruptedexception e) {                            eprintstacktrace()                        }                        schedulerschedule(cancel this)                        return cancel                    }                })            }        })        subscription subscribe  obssubscribe(new observer<integer>() {            @override            public void oncompleted() {                systemoutprintln("completed")            }            @override            public void onerror(exception e) {                systemoutprintln("error")            }            @override            public void onnext(integer args) {                systemoutprintln(args)            }        })        threadsleep(10000)        subscribeunsubscribe()        systemoutprintln("unsubscribe")        threadsleep(10000)```and they worked well for me || im wondering if the `scheduler` interface really needs all of these overloads?rx has 3 primary methods (the rest are extension methods that look like they do transformations) the 2 key ones are:``` java<t> subscription schedule(t state func2<scheduler t subscription> action)<t> subscription schedule(t state func2<scheduler t subscription> action long duetime timeunit unit)```we dont have one with an explicit time to run only relative at this time || it appears the overloads all make sense  but again net is able to use extension methods to make the design much more elegant where only the main 3 are part of the interface and the rest come along for the rideit means we end up with a scheduler/abstractscheduler interface/abstract pairing to make this workshould we just make scheduler an abstract? im very tempted to do so because of the following problems:- adding methods to scheduler will be breaking changes requiring major version increments- people implementing schedulers will basically always have to also extend abstractscheduler or copy/paste all of those method overloadsor should be remove all but the main 3 methods from scheduler and put all the overloads as utility functions on the schedulers class instead?the precedent for using abstract (or concrete) classes instead of interfaces (which net then augments with extension methods) is already done - observable is a concrete class instead of interface for this very reasonall plugins  as abstracts instead of interfaces for this reason as wellthoughts? || while reviewing and playing with this i considered some changes id like to propose i have submitted another pull request ( that builds on top of your work @jmhofer and includes the unit tests from @mairbek i would appreciate your thoughts on it and whether they are beneficial changes or just pedantic || merged manually via  || 
229,1,0,0,0,1,1,1,1,trying to extend the scheduler interface according to the comments at ive tried to extend the `scheduler` interface according to the discussion at issue #19 if i understand this correctly most of it can be done via the `abstractscheduler`i hope this helps please have a look #85  awesome looks like it doesnt break a `scheduler` interface i thought about two examples``` java        final scheduler scheduler  schedulerscurrentthread()        observable<integer> obs  observablecreate(new func1<observer<integer> subscription>() {            @override            public subscription call(final observer<integer> observer) {                return schedulerschedule(0 new func2<scheduler integer subscription>() {                    @override                    public subscription call(scheduler scheduler integer i) {                        if (i > 42) {                            observeroncompleted()                            return subscriptionsempty()                        }                        observeronnext(i)                        return schedulerschedule(i + 1 this)                    }                })            }        })        obssubscribe(new observer<integer>() {            @override            public void oncompleted() {                systemoutprintln("completed")            }            @override            public void onerror(exception e) {                systemoutprintln("error")            }            @override            public void onnext(integer args) {                systemoutprintln(args)            }        })```and``` java        final scheduler scheduler  schedulersthreadpoolforcomputation()        observable<integer> obs  observablecreate(new func1<observer<integer> subscription>() {            @override            public subscription call(final observer<integer> observer) {                return schedulerschedule(new booleansubscription() new func2<scheduler booleansubscription subscription>() {                    @override                    public subscription call(scheduler scheduler booleansubscription cancel) {                        if (cancelisunsubscribed()) {                            observeroncompleted()                            return subscriptionsempty()                        }                        observeronnext(42)                        try {                            threadsleep(1000)                        } catch (interruptedexception e) {                            eprintstacktrace()                        }                        schedulerschedule(cancel this)                        return cancel                    }                })            }        })        subscription subscribe  obssubscribe(new observer<integer>() {            @override            public void oncompleted() {                systemoutprintln("completed")            }            @override            public void onerror(exception e) {                systemoutprintln("error")            }            @override            public void onnext(integer args) {                systemoutprintln(args)            }        })        threadsleep(10000)        subscribeunsubscribe()        systemoutprintln("unsubscribe")        threadsleep(10000)```and they worked well for me || im wondering if the `scheduler` interface really needs all of these overloads?rx has 3 primary methods (the rest are extension methods that look like they do transformations) the 2 key ones are:``` java<t> subscription schedule(t state func2<scheduler t subscription> action)<t> subscription schedule(t state func2<scheduler t subscription> action long duetime timeunit unit)```we dont have one with an explicit time to run only relative at this time || it appears the overloads all make sense  but again net is able to use extension methods to make the design much more elegant where only the main 3 are part of the interface and the rest come along for the rideit means we end up with a scheduler/abstractscheduler interface/abstract pairing to make this workshould we just make scheduler an abstract? im very tempted to do so because of the following problems:- adding methods to scheduler will be breaking changes requiring major version increments- people implementing schedulers will basically always have to also extend abstractscheduler or copy/paste all of those method overloadsor should be remove all but the main 3 methods from scheduler and put all the overloads as utility functions on the schedulers class instead?the precedent for using abstract (or concrete) classes instead of interfaces (which net then augments with extension methods) is already done - observable is a concrete class instead of interface for this very reasonall plugins  as abstracts instead of interfaces for this reason as wellthoughts? || while reviewing and playing with this i considered some changes id like to propose i have submitted another pull request ( that builds on top of your work @jmhofer and includes the unit tests from @mairbek i would appreciate your thoughts on it and whether they are beneficial changes or just pedantic || merged manually via  || 
229,1,0,0,0,1,1,1,1,trying to extend the scheduler interface according to the comments at ive tried to extend the `scheduler` interface according to the discussion at issue #19 if i understand this correctly most of it can be done via the `abstractscheduler`i hope this helps please have a look #85  awesome looks like it doesnt break a `scheduler` interface i thought about two examples``` java        final scheduler scheduler  schedulerscurrentthread()        observable<integer> obs  observablecreate(new func1<observer<integer> subscription>() {            @override            public subscription call(final observer<integer> observer) {                return schedulerschedule(0 new func2<scheduler integer subscription>() {                    @override                    public subscription call(scheduler scheduler integer i) {                        if (i > 42) {                            observeroncompleted()                            return subscriptionsempty()                        }                        observeronnext(i)                        return schedulerschedule(i + 1 this)                    }                })            }        })        obssubscribe(new observer<integer>() {            @override            public void oncompleted() {                systemoutprintln("completed")            }            @override            public void onerror(exception e) {                systemoutprintln("error")            }            @override            public void onnext(integer args) {                systemoutprintln(args)            }        })```and``` java        final scheduler scheduler  schedulersthreadpoolforcomputation()        observable<integer> obs  observablecreate(new func1<observer<integer> subscription>() {            @override            public subscription call(final observer<integer> observer) {                return schedulerschedule(new booleansubscription() new func2<scheduler booleansubscription subscription>() {                    @override                    public subscription call(scheduler scheduler booleansubscription cancel) {                        if (cancelisunsubscribed()) {                            observeroncompleted()                            return subscriptionsempty()                        }                        observeronnext(42)                        try {                            threadsleep(1000)                        } catch (interruptedexception e) {                            eprintstacktrace()                        }                        schedulerschedule(cancel this)                        return cancel                    }                })            }        })        subscription subscribe  obssubscribe(new observer<integer>() {            @override            public void oncompleted() {                systemoutprintln("completed")            }            @override            public void onerror(exception e) {                systemoutprintln("error")            }            @override            public void onnext(integer args) {                systemoutprintln(args)            }        })        threadsleep(10000)        subscribeunsubscribe()        systemoutprintln("unsubscribe")        threadsleep(10000)```and they worked well for me || im wondering if the `scheduler` interface really needs all of these overloads?rx has 3 primary methods (the rest are extension methods that look like they do transformations) the 2 key ones are:``` java<t> subscription schedule(t state func2<scheduler t subscription> action)<t> subscription schedule(t state func2<scheduler t subscription> action long duetime timeunit unit)```we dont have one with an explicit time to run only relative at this time || it appears the overloads all make sense  but again net is able to use extension methods to make the design much more elegant where only the main 3 are part of the interface and the rest come along for the rideit means we end up with a scheduler/abstractscheduler interface/abstract pairing to make this workshould we just make scheduler an abstract? im very tempted to do so because of the following problems:- adding methods to scheduler will be breaking changes requiring major version increments- people implementing schedulers will basically always have to also extend abstractscheduler or copy/paste all of those method overloadsor should be remove all but the main 3 methods from scheduler and put all the overloads as utility functions on the schedulers class instead?the precedent for using abstract (or concrete) classes instead of interfaces (which net then augments with extension methods) is already done - observable is a concrete class instead of interface for this very reasonall plugins  as abstracts instead of interfaces for this reason as wellthoughts? || while reviewing and playing with this i considered some changes id like to propose i have submitted another pull request ( that builds on top of your work @jmhofer and includes the unit tests from @mairbek i would appreciate your thoughts on it and whether they are beneficial changes or just pedantic || merged manually via  || 
248,1,0,0,0,0,0,1,0,implemented sample operation now that `operationinterval` is in `operationsample` (see  #74) was kind of straightforward i also added a unit test against sampling and allowed for specifying a scheduler used by the sample operation #108  we want methods on `observable` dont we? || sure i just completely forgot about that ill add them || #113
248,1,0,0,1,1,1,1,1,implemented sample operation now that `operationinterval` is in `operationsample` (see  #74) was kind of straightforward i also added a unit test against sampling and allowed for specifying a scheduler used by the sample operation #108  we want methods on `observable` dont we? || sure i just completely forgot about that ill add them || #113
248,1,0,0,1,1,1,1,1,implemented sample operation now that `operationinterval` is in `operationsample` (see  #74) was kind of straightforward i also added a unit test against sampling and allowed for specifying a scheduler used by the sample operation #108  we want methods on `observable` dont we? || sure i just completely forgot about that ill add them || #113
249,1,0,0,0,0,0,1,0,timestamp operation straightforward implementation of issue #93 based on `operationmap` (without the scheduler version as `map` doesnt take a scheduler yet either) #109 the failing test has nothing to do with my changes - i guess its a sporadic test problem as theres not much difference between 10 and 30 milliseconds || this should also be added to `observable` shouldnt it? || #112 my eclipse configuration also automatically added a lot of `@override` annotations i hope you dont mind otherwise i can remove them again of course || the @override annotations are fine - they are standard java they may be missing in some places because this project started with java 5 compliance and it had the annotations in less places than java 6  ||
249,1,0,1,1,0,1,1,1,timestamp operation straightforward implementation of issue #93 based on `operationmap` (without the scheduler version as `map` doesnt take a scheduler yet either) #109 the failing test has nothing to do with my changes - i guess its a sporadic test problem as theres not much difference between 10 and 30 milliseconds || this should also be added to `observable` shouldnt it? || #112 my eclipse configuration also automatically added a lot of `@override` annotations i hope you dont mind otherwise i can remove them again of course || the @override annotations are fine - they are standard java they may be missing in some places because this project started with java 5 compliance and it had the annotations in less places than java 6  ||
249,1,0,0,0,0,0,1,0,timestamp operation straightforward implementation of issue #93 based on `operationmap` (without the scheduler version as `map` doesnt take a scheduler yet either) #109 the failing test has nothing to do with my changes - i guess its a sporadic test problem as theres not much difference between 10 and 30 milliseconds || this should also be added to `observable` shouldnt it? || #112 my eclipse configuration also automatically added a lot of `@override` annotations i hope you dont mind otherwise i can remove them again of course || the @override annotations are fine - they are standard java they may be missing in some places because this project started with java 5 compliance and it had the annotations in less places than java 6  ||
250,1,0,0,0,0,0,1,0,initial implementation of asyncsubject ive done some work on asyncsubject<t> including unit tests and im looking for feedback i dont expect to get this pull request immediately accepted but i hope to find out if this is the correct workflow for this repository and if the code is up to your standards before i start pouring in more hours into issue #17 if you guys are ok with the asyncsubject<t> implementation ill start working on the otherslooking forward to some feedback! #110  hi @michaeldejong thanks for getting involved!based on my reading of the msdn docs for `asyncsubject` and your code this looks goodthank for you following the coding style of the project and making sure the copyright unit tests etc are all in placemerging now  ||
250,1,0,0,1,1,1,1,1,initial implementation of asyncsubject ive done some work on asyncsubject<t> including unit tests and im looking for feedback i dont expect to get this pull request immediately accepted but i hope to find out if this is the correct workflow for this repository and if the code is up to your standards before i start pouring in more hours into issue #17 if you guys are ok with the asyncsubject<t> implementation ill start working on the otherslooking forward to some feedback! #110  hi @michaeldejong thanks for getting involved!based on my reading of the msdn docs for `asyncsubject` and your code this looks goodthank for you following the coding style of the project and making sure the copyright unit tests etc are all in placemerging now  ||
250,1,0,0,1,1,1,1,1,initial implementation of asyncsubject ive done some work on asyncsubject<t> including unit tests and im looking for feedback i dont expect to get this pull request immediately accepted but i hope to find out if this is the correct workflow for this repository and if the code is up to your standards before i start pouring in more hours into issue #17 if you guys are ok with the asyncsubject<t> implementation ill start working on the otherslooking forward to some feedback! #110  hi @michaeldejong thanks for getting involved!based on my reading of the msdn docs for `asyncsubject` and your code this looks goodthank for you following the coding style of the project and making sure the copyright unit tests etc are all in placemerging now  ||
257,1,0,0,0,0,0,1,0,improved scan reduce aggregate `scan` is currently restricted to accumulators of type `func2<t t t>` where `func2<r t r>` would be possible for initial values of type `r` this pull request tries to fix this by generalizing the `scan` implementation i had to restructure the scan operator a bit for this to stay typesafe imho its more readable now thoughthis indirectly leads to generalized `reduce` tooalso `aggregate` is added as an alias for `reduce` (see #20) #120  #121 #122 thank you for working on this  - `observable` had not had any changes done to it to expose the new `reduce` or `scan` methods so that should probably be added to this pull request- what names should we use on the public api?rxnet never used `reduce` it uses `aggregate` others call it fold accumulate etc (more here  8 is using the `reduce` and `collector` names ( what names should we use and what aliases if any should we include in `observable`? || about `observable` - hmm seems that the changes got lost somehow ill go dig them out agai d about the names to use: imho rxjava should have the java 8 names as well as the orginial rxnet names || agreed with your opinion on naming can you add those when you update the observable and make sure the javadocs of the methods are clear in linking to each other when they are aliases of each other? || ive had a look at the java 8 stream operations to me it looks like theres no explicit `scan` equivalent in java 8 or am i missing something?`collect` seems to be specifically made for mutable operations i dont see where we would use thatso i would just alias `reduce` with `aggregate` and `scan` stays unaliased if thats okay  || that works for me we can always add more aliases if java 8 adds a `scan` equivalent || i plan on doing a release tomorrow (about 12 hours from now) if you want to try and have this ready for that || [rxjava-pull-requests #131 looks good || as soon as this is in my `swing` branch becomes finally ready for a merge it offers a few simple observables created from button click keyboard and mouse events looking forward to this :) ||
257,1,0,1,1,1,1,1,1,improved scan reduce aggregate `scan` is currently restricted to accumulators of type `func2<t t t>` where `func2<r t r>` would be possible for initial values of type `r` this pull request tries to fix this by generalizing the `scan` implementation i had to restructure the scan operator a bit for this to stay typesafe imho its more readable now thoughthis indirectly leads to generalized `reduce` tooalso `aggregate` is added as an alias for `reduce` (see #20) #120  #121 #122 thank you for working on this  - `observable` had not had any changes done to it to expose the new `reduce` or `scan` methods so that should probably be added to this pull request- what names should we use on the public api?rxnet never used `reduce` it uses `aggregate` others call it fold accumulate etc (more here  8 is using the `reduce` and `collector` names ( what names should we use and what aliases if any should we include in `observable`? || about `observable` - hmm seems that the changes got lost somehow ill go dig them out agai d about the names to use: imho rxjava should have the java 8 names as well as the orginial rxnet names || agreed with your opinion on naming can you add those when you update the observable and make sure the javadocs of the methods are clear in linking to each other when they are aliases of each other? || ive had a look at the java 8 stream operations to me it looks like theres no explicit `scan` equivalent in java 8 or am i missing something?`collect` seems to be specifically made for mutable operations i dont see where we would use thatso i would just alias `reduce` with `aggregate` and `scan` stays unaliased if thats okay  || that works for me we can always add more aliases if java 8 adds a `scan` equivalent || i plan on doing a release tomorrow (about 12 hours from now) if you want to try and have this ready for that || [rxjava-pull-requests #131 looks good || as soon as this is in my `swing` branch becomes finally ready for a merge it offers a few simple observables created from button click keyboard and mouse events looking forward to this :) ||
257,1,0,1,0,0,1,1,1,improved scan reduce aggregate `scan` is currently restricted to accumulators of type `func2<t t t>` where `func2<r t r>` would be possible for initial values of type `r` this pull request tries to fix this by generalizing the `scan` implementation i had to restructure the scan operator a bit for this to stay typesafe imho its more readable now thoughthis indirectly leads to generalized `reduce` tooalso `aggregate` is added as an alias for `reduce` (see #20) #120  #121 #122 thank you for working on this  - `observable` had not had any changes done to it to expose the new `reduce` or `scan` methods so that should probably be added to this pull request- what names should we use on the public api?rxnet never used `reduce` it uses `aggregate` others call it fold accumulate etc (more here  8 is using the `reduce` and `collector` names ( what names should we use and what aliases if any should we include in `observable`? || about `observable` - hmm seems that the changes got lost somehow ill go dig them out agai d about the names to use: imho rxjava should have the java 8 names as well as the orginial rxnet names || agreed with your opinion on naming can you add those when you update the observable and make sure the javadocs of the methods are clear in linking to each other when they are aliases of each other? || ive had a look at the java 8 stream operations to me it looks like theres no explicit `scan` equivalent in java 8 or am i missing something?`collect` seems to be specifically made for mutable operations i dont see where we would use thatso i would just alias `reduce` with `aggregate` and `scan` stays unaliased if thats okay  || that works for me we can always add more aliases if java 8 adds a `scan` equivalent || i plan on doing a release tomorrow (about 12 hours from now) if you want to try and have this ready for that || [rxjava-pull-requests #131 looks good || as soon as this is in my `swing` branch becomes finally ready for a merge it offers a few simple observables created from button click keyboard and mouse events looking forward to this :) ||
331,1,0,0,1,0,0,1,0,adding super/extends so that observable is covariant ok so this pull request changes a _lot_ of lines its mostly generalizing all the `funcx`s to be used like `funcx[-t1 -t2  -tx +r]` (contravariant parameters covariant return type) and all the `observer`s to be used "in a contravariant way" a few of the `observable` uses are covariant now too (mostly `zip`)this is the pull request for #326this doesnt look very good in the code (thanks java) also it doesnt seem to make scala interop easier at all (at least not yet)please take a look im not exactly happy with the result - maybe im doing something wrong here? - ive still got hope that theres an easier waythe pull request compiles and tests ok for me (except for the clojure module but thats another story and not due to my changes) #213 ill have to spend some time later playing with this anyone else able to try this out and comment on the changes?@jmhofer  can you provide examples or use cases of using the updated code that demonstrates covariant/contravariant usage that couldnt be achieved before? || ok heres an example of what you can do now with the improved `zip`:``` javaimport rxobservableimport rxutilfunctionsfunc2class media {}class movie extends media {}class horrormovie extends movie {}class rating {}class coolrating extends rating {}class result {}class extendedresult extends result {}public class covariance {  public static void main(string args) {    observable<horrormovie> horrors  observablefrom(new horrormovie())    observable<coolrating> ratings  observablefrom(new coolrating())    func2<media rating extendedresult> combine  new func2<media rating extendedresult>() {      @override public extendedresult call(media m rating r) {        return null      }    }    observablezip(horrors ratings combine)    // 011: the method zip(observable<t0> observable<t1> func2<t0t1r>)     // in the type observable is not applicable for the arguments     // (observable<horrormovie> observable<coolrating> func2<mediaratingextendedresult>)    //    // but works in super-extends branch  }}``` || lots more `observable` usages to go however the `observer`s are probably mostly done || #216 let me know when youre ready for this to be merged and released i plan on releasing this as 0120 as it does have some breaking changes || that cloudbees build failure is legit i also cant build `rxjava-scala` on my machine with this branch the core library is fine```* what went wrong:execution failed for task :language-adaptors:rxjava-scala:compilescala> compilation failed because of an internal compiler error see the error output for details``` || in this line:``` javaobservable<string> observable  observablecreate(new func1<observer<? super string> subscription>()```is it the case that java programmers creating an `observable` this way would always have to include the `? super` bit? or is this just for completeness? is this what you mean by "im not exactly happy with the result"? i havent thought through it but this doesnt seem like it should be necessary if its done right || @benjchristensen i just noticed that too and adapted the `rximplicits`@daveray looks like it yes i couldnt make the compiler happy without it but maybe im missing something if you find something that avoids this then please let me know || #217  still to do: future is covariant and timestamped and notification are probably tooalso: lots of operators can be used standalone and therefore should be generalized too || [rxjava-pull-requests #218 [rxjava-pull-requests #219 huh? - very interesting (compiles for me) || [rxjava-pull-requests #220 looks good || [rxjava-pull-requests #221]( successthis pull request looks good || [rxjava-pull-requests #222]( successthis pull request looks good || [rxjava-pull-requests #223]( successthis pull request looks good || i would call this ready to merge now i looked through all the code and adapted everything i found i cant guarantee that i havent overlooked something but i guess a few places here and there can still be adapted later on without too much harmthe one caveat is @daverays comment maybe the observers are overgeneralized somewhere and we can really avoid people having to write `? super x` when creating their own observers i havent found a solution for this but im probably blind to it by nowof course one could still add a lot of "tests" or "use cases" in `covariancetest` to show that everything compiles as it should - in that respect im rather optimistic thoughmaybe we can also get rid of more rawtype/unchecked annotations now ill check this later onnow i need some time to recover from all that toiling through java boilerplatery :) || i need to spend some more time on this in my playing around i wasnt thrilled by how it forces this type of user code that has `? super` in it:``` java    public static observable<string> o  observablecreate(new func1<observer<? super string> subscription>() {        @override        public subscription call(observer<? super string> t1) {            return null        }    })``` || i have the same concern guava seems to takes the same approach but i dont recall ever having to use type constraints like that when using it briefly looking through the guava code nothing stood out to me though that would make it behave differently though || re-reading effective java josh bloch says this on page 137:> properly used wildcard types are nearly invisible to users of a class they cause methods to accept the parameters they should accept and reject those they should reject if the user of a class has to think about wildcard types there is probably something wrong with the class’s apihowever all of his examples are about methods they arent about instantiating classes like `func1<t r>` where `<t r>` ends up as `<? super observer<? super t> ? extends subscription>` || perhaps if this is what covariant generics truly requires we create a new function type specifically for this extremely common case of creating an `observable` and have it be something like this:``` javapublic interface observablefunction<t> extends func1<observer<? super t> subscription> {    public subscription call(observer<? super t> t1)}```it can then be used like this:``` java    public static observable<movie> o2  observablecreate(new observablefunction<movie>() {        @override        public subscription call(observer<? super movie> t1) {            return null        }    })    public static class myobserver implements observer<media> {        @override        public void oncompleted() {            // todo auto-generated method stub        }        @override        public void onerror(throwable e) {            // todo auto-generated method stub        }        @override        public void onnext(media args) {            // todo auto-generated method stub        }    }    public static void testthis() {        o2subscribe(new myobserver())    }```this still requires `public subscription call(observer<? super movie> t1)` but that is auto-generated by an ide (and lets face it  anyone writing java is using an ide) whereas the function definition is far easier: `new observablefunction<movie>`probably need a better name than `observablefunction` but thus far it feels better to use || unfortunately it cant be an overload of the existing create method as type erasure (and dynamic languages) see it as the same thing``` javapublic static <t> observable<t> create(func1<? super observer<? super t> ? extends subscription> func)```using the `observablefunction` works against that but then people would have to discover that new type in some other way to be truly user-friendly the method signature would need to change to:``` javapublic static <t> observable<t> create(observablefunction<t> func)```this way people would get prompted by their ides and javadoc to use the easiest approachthis whole thing (with or without a new type) is a wide-impact breaking change  all places someone does `observablecreate` || i tried again to do without observer<? super t> in several relevant places but i failed yet again it seems to be just necessary it stands to reason though if you think about it because observer is a contravariant type and java cant deal with that in any other way and in the case of observers api users are not just using them theyre creating themi like bens `observablefunction` idea above i think it would probably even be possible to get around the overloading problem by not inheriting from `func1` delegating to it instead however its still a wide-impact breaking change due to the `? super` that has to be added within every `call` method signature concerning observersstill if the `create` method is the biggest problem maybe its not so big after all or is `create` really so widely used? - id think that mostly api users will be using already created observables combining them and subscribing to them || here is a trivial example using java 8 demonstrating how `? super` needs to exist even here if retaining type safety:``` java        observable<string> omovie  observablecreate((observer<? super movie> o) -> {            oonnext(new movie())            oonnext(new movie())            return subscriptionsempty()        })map((movie) -> {            return "movie transformed: " + movie        })        observable<string> omedia  observablecreate((observer<? super media> o) -> {            oonnext(new media())            oonnext(new horrormovie())            return subscriptionsempty()        })map((movie) -> {            return "media transformed: " + movie        })        observablezip(omovie omedia (a b) -> {           return a + " ----- " + b        })subscribe((movie) -> {            systemoutprintln("media/movie: " + movie)        })```or type safety can be thrown away:``` java        observable<string> omovie  observablecreate((observer o) -> {            oonnext(new movie())            oonnext(new movie())            return subscriptionsempty()        })map((movie) -> {            return "movie transformed: " + movie        })```but now that allows this to compile:``` java        observable<string> omovie  observablecreate((observer o) -> {            oonnext(new movie())            oonnext("hello") // this is not a movie object            return subscriptionsempty()        })map((movie) -> {            return "movie transformed: " + movie        })``` || @jmhofer the `create` method is how `observable`s are created so this affects all producers this should not affect consumers other than making the prompts/docs verbose:![screen shot 2013-09-03 at 4 41 21 pm]( and @mustafasezgin do you have any input on this discussion since you are using rxjava from plain java? || groovy is similar  but the generics dont actually do much for it as they are more-or-less ignored at compile time as best i can tell:``` groovy        observable<string> omovie  observablecreate({ observer o ->            oonnext(new movie())            oonnext(new movie())            return subscriptionsempty()        })map({ movie ->            return "movie transformed: " + movie        })        observable<string> omedia  observablecreate({ observer<? super media> o ->            oonnext(new media())            oonnext(new horrormovie())            return subscriptionsempty()        })map({ movie ->            return "media transformed: " + movie        })        observablezip(omovie omedia { a b ->            return a + " ----- " + b        })subscribe({ movie ->            systemoutprintln("media/movie: " + movie)        })``` || this groovy code works against current master as well as the new code with `? super`:``` groovy        observable<movie> omovie  observablecreate({ observer<? super movie> o ->            oonnext(new movie())            oonnext(new movie())            ooncompleted()            return subscriptionsempty()        })        observable<media> omedia  observablecreate({ observer<? super media> o ->            oonnext(new media())            oonnext(new horrormovie())            ooncompleted()            return subscriptionsempty()        })        observablezip(omovie omedia { movie a media b ->            return stringvalueof(a) + " ----- " + stringvalueof(b)        })subscribe({ media ->            systemoutprintln("media/movie: " + media)        })```and here it is again in plain java:``` java        observable<movie> omovie  observablecreate(new func1<observer<? super movie> subscription>() {            @override            public subscription call(observer<? super movie> o) {                oonnext(new movie())                oonnext(new movie())                ooncompleted()                return subscriptionsempty()            }        })        observable<media> omedia  observablecreate(new func1<observer<? super media> subscription>() {            @override            public subscription call(observer<? super media> o) {                oonnext(new media())                oonnext(new horrormovie())                ooncompleted()                return subscriptionsempty()            }        })        observablezip(omovie omedia new func2<movie media string>() {            @override            public string call(movie a media b) {                return stringvalueof(a) + " ----- " + stringvalueof(b)            }        })subscribe(new action1<string>() {            @override            public void call(string media) {                systemoutprintln("media/movie: " + media)            }        })```it seems that `? super` is fine on the outer generics and doesnt need to be typed everywhere its just when its a generic inside a generic the type of the `observer` that it becomes annoying || it seems the only option (while supporting covariance) for reducing code verbosity is to create a new type that hides the `func1<? super observer<? super t> ? extends subscription>` complexityso my question now is: should we change the api to make all uses of `create` use the new type or should it remain as `func1` and the other type is just a nice utility that can be used to fulfill the signature?in other words do we leave it as this:``` javapublic static <t> observable<t> create(func1<? super observer<? super t> ? extends subscription> func)```or change it to ``` javapublic static <t> observable<t> create(observablefunction<t> func)```and what do we call the new type if we go that route? options ive considered are:- `observablefunction`- `observablefunc`- `onsubscribefunction`- `onsubscribefunc`- `funconsubscribe`and should that live in `rxutilfunctions` or `rx` alongside `rxobservable`? it feels that this is not generic and should therefore live inside `rx`unfortunately we can not overload this method and support both as type erasure makes them the same (and it will confuse dynamic languages implicits etc) if we had two methods with similar single function signaturesnormally id rather leave the lower level `func1` method signature and just have a helper class but code completion and javadocs will be far less obvious and not very discoverable thus for discoverability i think it makes more sense to use `create(observablefunction<t> func)` i cant yet think of any forward-compatibility reason why this would be a bad thing this pull request is breaking either direction we pursue || one last spam to everyone  please weigh in if you have an opinion as i intend on making a decision and releasing this weekthis will be a breaking change and affect usage for everyone || here is what the `observablefunction` interface looks like:``` java/** * function interface for work to be performed when an {@link observable} is subscribed to via {@link observable#subscribe(observer)} *  * @param <t> */public interface observablefunction<t> extends func1<observer<? super t> subscription> {    public subscription call(observer<? super t> t1)}```and the updated `create` method:``` javapublic static <t> observable<t> create(observablefunction<t> func) ```and sample code using this:``` java        observable<movie> omovie  observablecreate(new observablefunction<movie>() {            @override            public subscription call(observer<? super movie> o) {                oonnext(new movie())                oonnext(new movie())                ooncompleted()                return subscriptionsempty()            }        })``` || here is a fork including these changes so we can review and discuss:  still not thrilled by any of the directions we can take here i cant argue against making rxjava support covariant types josh bloch certainly supports it in effective java when he says "if you write a library that will be widely used the proper use of wildcard types should be considered mandatory"on the flip-side it forces the use of ? super/? extends everywhere even when covariant requirements are rarei think the only decision at this point to make is whether we should use something like `observablefunction<t>` to minimize the verbosity or just leave `func1<? super observer<? super t> ? extends subscription>` and if we do use `observablefunction` do we provide similar solutions elsewhere? that feels wrong to have special function interfaces for so many things even though it likely will improve readability and usabilityother operators that are awkward include:- `defer(func0<? extends observable<? extends t>> observablefactory)`- `aggregate(func2<? super t ? super t ? extends t> accumulator)`- `buffer(func0<? extends observable<? extends bufferclosing>> bufferclosingselector)`- `flatmap(func1<? super t ? extends observable<? extends r>> func)`flatmap is very common and ends up like this:``` java        omediaflatmap(new func1<media observable<? extends string>>() {            @override            public observable<? extends string> call(media s) {                            }        })```compare this with current:``` java        omediaflatmap(new func1<media observable<string>>() {            @override            public observable<string> call(media s) {                            }        })```however lambdas do make a big different on instance methods (not as much on statics) as they can infer the types for example in java 8 the above can become this:``` java        omediaflatmap(value -> {            return null        })```so without `observablefunction<t>` in java 8 we have:``` java        observablecreate((observer<? super media> o) -> {            oonnext(new media())            oonnext(new horrormovie())            return subscriptionsempty()        })flatmap(movie -> {            return observablefrom("media transformed: " + moviegetname())        })```with `observablefunction<t>` in java 8 we get this:``` java        observablecreate((observer<media> o) -> {            oonnext(new media())            oonnext(new horrormovie())            return subscriptionsempty()        })flatmap(movie -> {            return observablefrom("media transformed: " + moviegetname())        })```it seems that type inference will handle the instance methods for example `aggregate`/`reduce` becomes this:``` java        observablecreate((observer<integer> o) -> {            oonnext(1)            oonnext(2)            return subscriptionsempty()        })aggregate((previous current) -> {            return previous + current        })```so its only the static methods of concern `create` being the most significantjava 6/7 (and android) are going to be ugly no matter what - but we already knew that and they already are this makes it worse || experiencing some of the pain with generic method signatures and nestingfirst hand i prefer the type alias in form of an interface i would arguethat the subscription function is so widely used that the interfacecloaking it will be understood quickly enough by developers so the loss indirect clarity should be negligible || [rxjava-pull-requests #229]( failurelooks like theres a problem with this pull request || +1 observablefunction interface but call it something else maybe with subscription/subscribe in the name || @benjchristensen we could overload `create` etc - for this wed have to make `observablefunction` delegate to `func1` then instead of inheriting from it im not sure if thats a good idea though it would probably be even more confusingim not sure about the naming although it is kind of _the_ internal `observable` function i think id prefer `subscriptionfunction` or `subscriberfunction` or something like that || [rxjava-pull-requests #230]( successthis pull request looks good || how about these names?- `onsubscribefunction`- `onsubscribefunc`- `funconsubscribe` || based on my highly scientific poll of people around me at my office  and the few who have commented above im going with `onsubscribefunc`  || @benjchristensen works for me will it extend `func1` or be an independent type as @jmhofer suggests above i think id prefer the latter || i havent played with it not extending func1 it will need to at least extend `function` so it fits with all other functions in the codebase in what way will it improve things if it doesnt extend? || since this function is only intended for us by the `observablecreate` does anyone have issues with it being namespaced as `rxobservableonsubscribefunc` as a static inner class of `observable` rather than a first-class citizen `rxonsubscribefunc`?this works great in java are there any issues from clojure or scala doing it this way?create looks like this:``` javapublic static <t> observable<t> create(onsubscribefunc<t> func)```use of it looks like this:``` java        import rxobservable        import rxobservableonsubscribefunc        observable<string> observable  observablecreate(new onsubscribefunc<string>() {            @override            public subscription call(observer<? super string> observer) {                observeronnext("one")                observeronnext("two")                observeronnext("three")                observeroncompleted()                return subscriptionsempty()            }        })```the function definition looks like:``` java    /**     * function interface for work to be performed when an {@link observable} is subscribed to via {@link observable#subscribe(observer)}     *      * @param <t>     */    public static interface onsubscribefunc<t> extends function<t> {        public subscription call(observer<? super t> t1)    }``` || good idea and shouldnt be a problem for scala || great ill proceed with this change then thanks for the feedback || final interface looks like this:``` java    /**     * function interface for work to be performed when an {@link observable} is subscribed to via {@link observable#subscribe(observer)}     *      * @param <t>     */    public static interface onsubscribefunc<t> extends function {        public subscription onsubscribe(observer<? super t> t1)    }```this is being merged in  || 
331,1,0,1,1,1,1,1,1,adding super/extends so that observable is covariant ok so this pull request changes a _lot_ of lines its mostly generalizing all the `funcx`s to be used like `funcx[-t1 -t2  -tx +r]` (contravariant parameters covariant return type) and all the `observer`s to be used "in a contravariant way" a few of the `observable` uses are covariant now too (mostly `zip`)this is the pull request for #326this doesnt look very good in the code (thanks java) also it doesnt seem to make scala interop easier at all (at least not yet)please take a look im not exactly happy with the result - maybe im doing something wrong here? - ive still got hope that theres an easier waythe pull request compiles and tests ok for me (except for the clojure module but thats another story and not due to my changes) #213 ill have to spend some time later playing with this anyone else able to try this out and comment on the changes?@jmhofer  can you provide examples or use cases of using the updated code that demonstrates covariant/contravariant usage that couldnt be achieved before? || ok heres an example of what you can do now with the improved `zip`:``` javaimport rxobservableimport rxutilfunctionsfunc2class media {}class movie extends media {}class horrormovie extends movie {}class rating {}class coolrating extends rating {}class result {}class extendedresult extends result {}public class covariance {  public static void main(string args) {    observable<horrormovie> horrors  observablefrom(new horrormovie())    observable<coolrating> ratings  observablefrom(new coolrating())    func2<media rating extendedresult> combine  new func2<media rating extendedresult>() {      @override public extendedresult call(media m rating r) {        return null      }    }    observablezip(horrors ratings combine)    // 011: the method zip(observable<t0> observable<t1> func2<t0t1r>)     // in the type observable is not applicable for the arguments     // (observable<horrormovie> observable<coolrating> func2<mediaratingextendedresult>)    //    // but works in super-extends branch  }}``` || lots more `observable` usages to go however the `observer`s are probably mostly done || #216 let me know when youre ready for this to be merged and released i plan on releasing this as 0120 as it does have some breaking changes || that cloudbees build failure is legit i also cant build `rxjava-scala` on my machine with this branch the core library is fine```* what went wrong:execution failed for task :language-adaptors:rxjava-scala:compilescala> compilation failed because of an internal compiler error see the error output for details``` || in this line:``` javaobservable<string> observable  observablecreate(new func1<observer<? super string> subscription>()```is it the case that java programmers creating an `observable` this way would always have to include the `? super` bit? or is this just for completeness? is this what you mean by "im not exactly happy with the result"? i havent thought through it but this doesnt seem like it should be necessary if its done right || @benjchristensen i just noticed that too and adapted the `rximplicits`@daveray looks like it yes i couldnt make the compiler happy without it but maybe im missing something if you find something that avoids this then please let me know || #217  still to do: future is covariant and timestamped and notification are probably tooalso: lots of operators can be used standalone and therefore should be generalized too || [rxjava-pull-requests #218 [rxjava-pull-requests #219 huh? - very interesting (compiles for me) || [rxjava-pull-requests #220 looks good || [rxjava-pull-requests #221]( successthis pull request looks good || [rxjava-pull-requests #222]( successthis pull request looks good || [rxjava-pull-requests #223]( successthis pull request looks good || i would call this ready to merge now i looked through all the code and adapted everything i found i cant guarantee that i havent overlooked something but i guess a few places here and there can still be adapted later on without too much harmthe one caveat is @daverays comment maybe the observers are overgeneralized somewhere and we can really avoid people having to write `? super x` when creating their own observers i havent found a solution for this but im probably blind to it by nowof course one could still add a lot of "tests" or "use cases" in `covariancetest` to show that everything compiles as it should - in that respect im rather optimistic thoughmaybe we can also get rid of more rawtype/unchecked annotations now ill check this later onnow i need some time to recover from all that toiling through java boilerplatery :) || i need to spend some more time on this in my playing around i wasnt thrilled by how it forces this type of user code that has `? super` in it:``` java    public static observable<string> o  observablecreate(new func1<observer<? super string> subscription>() {        @override        public subscription call(observer<? super string> t1) {            return null        }    })``` || i have the same concern guava seems to takes the same approach but i dont recall ever having to use type constraints like that when using it briefly looking through the guava code nothing stood out to me though that would make it behave differently though || re-reading effective java josh bloch says this on page 137:> properly used wildcard types are nearly invisible to users of a class they cause methods to accept the parameters they should accept and reject those they should reject if the user of a class has to think about wildcard types there is probably something wrong with the class’s apihowever all of his examples are about methods they arent about instantiating classes like `func1<t r>` where `<t r>` ends up as `<? super observer<? super t> ? extends subscription>` || perhaps if this is what covariant generics truly requires we create a new function type specifically for this extremely common case of creating an `observable` and have it be something like this:``` javapublic interface observablefunction<t> extends func1<observer<? super t> subscription> {    public subscription call(observer<? super t> t1)}```it can then be used like this:``` java    public static observable<movie> o2  observablecreate(new observablefunction<movie>() {        @override        public subscription call(observer<? super movie> t1) {            return null        }    })    public static class myobserver implements observer<media> {        @override        public void oncompleted() {            // todo auto-generated method stub        }        @override        public void onerror(throwable e) {            // todo auto-generated method stub        }        @override        public void onnext(media args) {            // todo auto-generated method stub        }    }    public static void testthis() {        o2subscribe(new myobserver())    }```this still requires `public subscription call(observer<? super movie> t1)` but that is auto-generated by an ide (and lets face it  anyone writing java is using an ide) whereas the function definition is far easier: `new observablefunction<movie>`probably need a better name than `observablefunction` but thus far it feels better to use || unfortunately it cant be an overload of the existing create method as type erasure (and dynamic languages) see it as the same thing``` javapublic static <t> observable<t> create(func1<? super observer<? super t> ? extends subscription> func)```using the `observablefunction` works against that but then people would have to discover that new type in some other way to be truly user-friendly the method signature would need to change to:``` javapublic static <t> observable<t> create(observablefunction<t> func)```this way people would get prompted by their ides and javadoc to use the easiest approachthis whole thing (with or without a new type) is a wide-impact breaking change  all places someone does `observablecreate` || i tried again to do without observer<? super t> in several relevant places but i failed yet again it seems to be just necessary it stands to reason though if you think about it because observer is a contravariant type and java cant deal with that in any other way and in the case of observers api users are not just using them theyre creating themi like bens `observablefunction` idea above i think it would probably even be possible to get around the overloading problem by not inheriting from `func1` delegating to it instead however its still a wide-impact breaking change due to the `? super` that has to be added within every `call` method signature concerning observersstill if the `create` method is the biggest problem maybe its not so big after all or is `create` really so widely used? - id think that mostly api users will be using already created observables combining them and subscribing to them || here is a trivial example using java 8 demonstrating how `? super` needs to exist even here if retaining type safety:``` java        observable<string> omovie  observablecreate((observer<? super movie> o) -> {            oonnext(new movie())            oonnext(new movie())            return subscriptionsempty()        })map((movie) -> {            return "movie transformed: " + movie        })        observable<string> omedia  observablecreate((observer<? super media> o) -> {            oonnext(new media())            oonnext(new horrormovie())            return subscriptionsempty()        })map((movie) -> {            return "media transformed: " + movie        })        observablezip(omovie omedia (a b) -> {           return a + " ----- " + b        })subscribe((movie) -> {            systemoutprintln("media/movie: " + movie)        })```or type safety can be thrown away:``` java        observable<string> omovie  observablecreate((observer o) -> {            oonnext(new movie())            oonnext(new movie())            return subscriptionsempty()        })map((movie) -> {            return "movie transformed: " + movie        })```but now that allows this to compile:``` java        observable<string> omovie  observablecreate((observer o) -> {            oonnext(new movie())            oonnext("hello") // this is not a movie object            return subscriptionsempty()        })map((movie) -> {            return "movie transformed: " + movie        })``` || @jmhofer the `create` method is how `observable`s are created so this affects all producers this should not affect consumers other than making the prompts/docs verbose:![screen shot 2013-09-03 at 4 41 21 pm]( and @mustafasezgin do you have any input on this discussion since you are using rxjava from plain java? || groovy is similar  but the generics dont actually do much for it as they are more-or-less ignored at compile time as best i can tell:``` groovy        observable<string> omovie  observablecreate({ observer o ->            oonnext(new movie())            oonnext(new movie())            return subscriptionsempty()        })map({ movie ->            return "movie transformed: " + movie        })        observable<string> omedia  observablecreate({ observer<? super media> o ->            oonnext(new media())            oonnext(new horrormovie())            return subscriptionsempty()        })map({ movie ->            return "media transformed: " + movie        })        observablezip(omovie omedia { a b ->            return a + " ----- " + b        })subscribe({ movie ->            systemoutprintln("media/movie: " + movie)        })``` || this groovy code works against current master as well as the new code with `? super`:``` groovy        observable<movie> omovie  observablecreate({ observer<? super movie> o ->            oonnext(new movie())            oonnext(new movie())            ooncompleted()            return subscriptionsempty()        })        observable<media> omedia  observablecreate({ observer<? super media> o ->            oonnext(new media())            oonnext(new horrormovie())            ooncompleted()            return subscriptionsempty()        })        observablezip(omovie omedia { movie a media b ->            return stringvalueof(a) + " ----- " + stringvalueof(b)        })subscribe({ media ->            systemoutprintln("media/movie: " + media)        })```and here it is again in plain java:``` java        observable<movie> omovie  observablecreate(new func1<observer<? super movie> subscription>() {            @override            public subscription call(observer<? super movie> o) {                oonnext(new movie())                oonnext(new movie())                ooncompleted()                return subscriptionsempty()            }        })        observable<media> omedia  observablecreate(new func1<observer<? super media> subscription>() {            @override            public subscription call(observer<? super media> o) {                oonnext(new media())                oonnext(new horrormovie())                ooncompleted()                return subscriptionsempty()            }        })        observablezip(omovie omedia new func2<movie media string>() {            @override            public string call(movie a media b) {                return stringvalueof(a) + " ----- " + stringvalueof(b)            }        })subscribe(new action1<string>() {            @override            public void call(string media) {                systemoutprintln("media/movie: " + media)            }        })```it seems that `? super` is fine on the outer generics and doesnt need to be typed everywhere its just when its a generic inside a generic the type of the `observer` that it becomes annoying || it seems the only option (while supporting covariance) for reducing code verbosity is to create a new type that hides the `func1<? super observer<? super t> ? extends subscription>` complexityso my question now is: should we change the api to make all uses of `create` use the new type or should it remain as `func1` and the other type is just a nice utility that can be used to fulfill the signature?in other words do we leave it as this:``` javapublic static <t> observable<t> create(func1<? super observer<? super t> ? extends subscription> func)```or change it to ``` javapublic static <t> observable<t> create(observablefunction<t> func)```and what do we call the new type if we go that route? options ive considered are:- `observablefunction`- `observablefunc`- `onsubscribefunction`- `onsubscribefunc`- `funconsubscribe`and should that live in `rxutilfunctions` or `rx` alongside `rxobservable`? it feels that this is not generic and should therefore live inside `rx`unfortunately we can not overload this method and support both as type erasure makes them the same (and it will confuse dynamic languages implicits etc) if we had two methods with similar single function signaturesnormally id rather leave the lower level `func1` method signature and just have a helper class but code completion and javadocs will be far less obvious and not very discoverable thus for discoverability i think it makes more sense to use `create(observablefunction<t> func)` i cant yet think of any forward-compatibility reason why this would be a bad thing this pull request is breaking either direction we pursue || one last spam to everyone  please weigh in if you have an opinion as i intend on making a decision and releasing this weekthis will be a breaking change and affect usage for everyone || here is what the `observablefunction` interface looks like:``` java/** * function interface for work to be performed when an {@link observable} is subscribed to via {@link observable#subscribe(observer)} *  * @param <t> */public interface observablefunction<t> extends func1<observer<? super t> subscription> {    public subscription call(observer<? super t> t1)}```and the updated `create` method:``` javapublic static <t> observable<t> create(observablefunction<t> func) ```and sample code using this:``` java        observable<movie> omovie  observablecreate(new observablefunction<movie>() {            @override            public subscription call(observer<? super movie> o) {                oonnext(new movie())                oonnext(new movie())                ooncompleted()                return subscriptionsempty()            }        })``` || here is a fork including these changes so we can review and discuss:  still not thrilled by any of the directions we can take here i cant argue against making rxjava support covariant types josh bloch certainly supports it in effective java when he says "if you write a library that will be widely used the proper use of wildcard types should be considered mandatory"on the flip-side it forces the use of ? super/? extends everywhere even when covariant requirements are rarei think the only decision at this point to make is whether we should use something like `observablefunction<t>` to minimize the verbosity or just leave `func1<? super observer<? super t> ? extends subscription>` and if we do use `observablefunction` do we provide similar solutions elsewhere? that feels wrong to have special function interfaces for so many things even though it likely will improve readability and usabilityother operators that are awkward include:- `defer(func0<? extends observable<? extends t>> observablefactory)`- `aggregate(func2<? super t ? super t ? extends t> accumulator)`- `buffer(func0<? extends observable<? extends bufferclosing>> bufferclosingselector)`- `flatmap(func1<? super t ? extends observable<? extends r>> func)`flatmap is very common and ends up like this:``` java        omediaflatmap(new func1<media observable<? extends string>>() {            @override            public observable<? extends string> call(media s) {                            }        })```compare this with current:``` java        omediaflatmap(new func1<media observable<string>>() {            @override            public observable<string> call(media s) {                            }        })```however lambdas do make a big different on instance methods (not as much on statics) as they can infer the types for example in java 8 the above can become this:``` java        omediaflatmap(value -> {            return null        })```so without `observablefunction<t>` in java 8 we have:``` java        observablecreate((observer<? super media> o) -> {            oonnext(new media())            oonnext(new horrormovie())            return subscriptionsempty()        })flatmap(movie -> {            return observablefrom("media transformed: " + moviegetname())        })```with `observablefunction<t>` in java 8 we get this:``` java        observablecreate((observer<media> o) -> {            oonnext(new media())            oonnext(new horrormovie())            return subscriptionsempty()        })flatmap(movie -> {            return observablefrom("media transformed: " + moviegetname())        })```it seems that type inference will handle the instance methods for example `aggregate`/`reduce` becomes this:``` java        observablecreate((observer<integer> o) -> {            oonnext(1)            oonnext(2)            return subscriptionsempty()        })aggregate((previous current) -> {            return previous + current        })```so its only the static methods of concern `create` being the most significantjava 6/7 (and android) are going to be ugly no matter what - but we already knew that and they already are this makes it worse || experiencing some of the pain with generic method signatures and nestingfirst hand i prefer the type alias in form of an interface i would arguethat the subscription function is so widely used that the interfacecloaking it will be understood quickly enough by developers so the loss indirect clarity should be negligible || [rxjava-pull-requests #229]( failurelooks like theres a problem with this pull request || +1 observablefunction interface but call it something else maybe with subscription/subscribe in the name || @benjchristensen we could overload `create` etc - for this wed have to make `observablefunction` delegate to `func1` then instead of inheriting from it im not sure if thats a good idea though it would probably be even more confusingim not sure about the naming although it is kind of _the_ internal `observable` function i think id prefer `subscriptionfunction` or `subscriberfunction` or something like that || [rxjava-pull-requests #230]( successthis pull request looks good || how about these names?- `onsubscribefunction`- `onsubscribefunc`- `funconsubscribe` || based on my highly scientific poll of people around me at my office  and the few who have commented above im going with `onsubscribefunc`  || @benjchristensen works for me will it extend `func1` or be an independent type as @jmhofer suggests above i think id prefer the latter || i havent played with it not extending func1 it will need to at least extend `function` so it fits with all other functions in the codebase in what way will it improve things if it doesnt extend? || since this function is only intended for us by the `observablecreate` does anyone have issues with it being namespaced as `rxobservableonsubscribefunc` as a static inner class of `observable` rather than a first-class citizen `rxonsubscribefunc`?this works great in java are there any issues from clojure or scala doing it this way?create looks like this:``` javapublic static <t> observable<t> create(onsubscribefunc<t> func)```use of it looks like this:``` java        import rxobservable        import rxobservableonsubscribefunc        observable<string> observable  observablecreate(new onsubscribefunc<string>() {            @override            public subscription call(observer<? super string> observer) {                observeronnext("one")                observeronnext("two")                observeronnext("three")                observeroncompleted()                return subscriptionsempty()            }        })```the function definition looks like:``` java    /**     * function interface for work to be performed when an {@link observable} is subscribed to via {@link observable#subscribe(observer)}     *      * @param <t>     */    public static interface onsubscribefunc<t> extends function<t> {        public subscription call(observer<? super t> t1)    }``` || good idea and shouldnt be a problem for scala || great ill proceed with this change then thanks for the feedback || final interface looks like this:``` java    /**     * function interface for work to be performed when an {@link observable} is subscribed to via {@link observable#subscribe(observer)}     *      * @param <t>     */    public static interface onsubscribefunc<t> extends function {        public subscription onsubscribe(observer<? super t> t1)    }```this is being merged in  || 
331,1,0,0,1,1,1,1,1,adding super/extends so that observable is covariant ok so this pull request changes a _lot_ of lines its mostly generalizing all the `funcx`s to be used like `funcx[-t1 -t2  -tx +r]` (contravariant parameters covariant return type) and all the `observer`s to be used "in a contravariant way" a few of the `observable` uses are covariant now too (mostly `zip`)this is the pull request for #326this doesnt look very good in the code (thanks java) also it doesnt seem to make scala interop easier at all (at least not yet)please take a look im not exactly happy with the result - maybe im doing something wrong here? - ive still got hope that theres an easier waythe pull request compiles and tests ok for me (except for the clojure module but thats another story and not due to my changes) #213 ill have to spend some time later playing with this anyone else able to try this out and comment on the changes?@jmhofer  can you provide examples or use cases of using the updated code that demonstrates covariant/contravariant usage that couldnt be achieved before? || ok heres an example of what you can do now with the improved `zip`:``` javaimport rxobservableimport rxutilfunctionsfunc2class media {}class movie extends media {}class horrormovie extends movie {}class rating {}class coolrating extends rating {}class result {}class extendedresult extends result {}public class covariance {  public static void main(string args) {    observable<horrormovie> horrors  observablefrom(new horrormovie())    observable<coolrating> ratings  observablefrom(new coolrating())    func2<media rating extendedresult> combine  new func2<media rating extendedresult>() {      @override public extendedresult call(media m rating r) {        return null      }    }    observablezip(horrors ratings combine)    // 011: the method zip(observable<t0> observable<t1> func2<t0t1r>)     // in the type observable is not applicable for the arguments     // (observable<horrormovie> observable<coolrating> func2<mediaratingextendedresult>)    //    // but works in super-extends branch  }}``` || lots more `observable` usages to go however the `observer`s are probably mostly done || #216 let me know when youre ready for this to be merged and released i plan on releasing this as 0120 as it does have some breaking changes || that cloudbees build failure is legit i also cant build `rxjava-scala` on my machine with this branch the core library is fine```* what went wrong:execution failed for task :language-adaptors:rxjava-scala:compilescala> compilation failed because of an internal compiler error see the error output for details``` || in this line:``` javaobservable<string> observable  observablecreate(new func1<observer<? super string> subscription>()```is it the case that java programmers creating an `observable` this way would always have to include the `? super` bit? or is this just for completeness? is this what you mean by "im not exactly happy with the result"? i havent thought through it but this doesnt seem like it should be necessary if its done right || @benjchristensen i just noticed that too and adapted the `rximplicits`@daveray looks like it yes i couldnt make the compiler happy without it but maybe im missing something if you find something that avoids this then please let me know || #217  still to do: future is covariant and timestamped and notification are probably tooalso: lots of operators can be used standalone and therefore should be generalized too || [rxjava-pull-requests #218 [rxjava-pull-requests #219 huh? - very interesting (compiles for me) || [rxjava-pull-requests #220 looks good || [rxjava-pull-requests #221]( successthis pull request looks good || [rxjava-pull-requests #222]( successthis pull request looks good || [rxjava-pull-requests #223]( successthis pull request looks good || i would call this ready to merge now i looked through all the code and adapted everything i found i cant guarantee that i havent overlooked something but i guess a few places here and there can still be adapted later on without too much harmthe one caveat is @daverays comment maybe the observers are overgeneralized somewhere and we can really avoid people having to write `? super x` when creating their own observers i havent found a solution for this but im probably blind to it by nowof course one could still add a lot of "tests" or "use cases" in `covariancetest` to show that everything compiles as it should - in that respect im rather optimistic thoughmaybe we can also get rid of more rawtype/unchecked annotations now ill check this later onnow i need some time to recover from all that toiling through java boilerplatery :) || i need to spend some more time on this in my playing around i wasnt thrilled by how it forces this type of user code that has `? super` in it:``` java    public static observable<string> o  observablecreate(new func1<observer<? super string> subscription>() {        @override        public subscription call(observer<? super string> t1) {            return null        }    })``` || i have the same concern guava seems to takes the same approach but i dont recall ever having to use type constraints like that when using it briefly looking through the guava code nothing stood out to me though that would make it behave differently though || re-reading effective java josh bloch says this on page 137:> properly used wildcard types are nearly invisible to users of a class they cause methods to accept the parameters they should accept and reject those they should reject if the user of a class has to think about wildcard types there is probably something wrong with the class’s apihowever all of his examples are about methods they arent about instantiating classes like `func1<t r>` where `<t r>` ends up as `<? super observer<? super t> ? extends subscription>` || perhaps if this is what covariant generics truly requires we create a new function type specifically for this extremely common case of creating an `observable` and have it be something like this:``` javapublic interface observablefunction<t> extends func1<observer<? super t> subscription> {    public subscription call(observer<? super t> t1)}```it can then be used like this:``` java    public static observable<movie> o2  observablecreate(new observablefunction<movie>() {        @override        public subscription call(observer<? super movie> t1) {            return null        }    })    public static class myobserver implements observer<media> {        @override        public void oncompleted() {            // todo auto-generated method stub        }        @override        public void onerror(throwable e) {            // todo auto-generated method stub        }        @override        public void onnext(media args) {            // todo auto-generated method stub        }    }    public static void testthis() {        o2subscribe(new myobserver())    }```this still requires `public subscription call(observer<? super movie> t1)` but that is auto-generated by an ide (and lets face it  anyone writing java is using an ide) whereas the function definition is far easier: `new observablefunction<movie>`probably need a better name than `observablefunction` but thus far it feels better to use || unfortunately it cant be an overload of the existing create method as type erasure (and dynamic languages) see it as the same thing``` javapublic static <t> observable<t> create(func1<? super observer<? super t> ? extends subscription> func)```using the `observablefunction` works against that but then people would have to discover that new type in some other way to be truly user-friendly the method signature would need to change to:``` javapublic static <t> observable<t> create(observablefunction<t> func)```this way people would get prompted by their ides and javadoc to use the easiest approachthis whole thing (with or without a new type) is a wide-impact breaking change  all places someone does `observablecreate` || i tried again to do without observer<? super t> in several relevant places but i failed yet again it seems to be just necessary it stands to reason though if you think about it because observer is a contravariant type and java cant deal with that in any other way and in the case of observers api users are not just using them theyre creating themi like bens `observablefunction` idea above i think it would probably even be possible to get around the overloading problem by not inheriting from `func1` delegating to it instead however its still a wide-impact breaking change due to the `? super` that has to be added within every `call` method signature concerning observersstill if the `create` method is the biggest problem maybe its not so big after all or is `create` really so widely used? - id think that mostly api users will be using already created observables combining them and subscribing to them || here is a trivial example using java 8 demonstrating how `? super` needs to exist even here if retaining type safety:``` java        observable<string> omovie  observablecreate((observer<? super movie> o) -> {            oonnext(new movie())            oonnext(new movie())            return subscriptionsempty()        })map((movie) -> {            return "movie transformed: " + movie        })        observable<string> omedia  observablecreate((observer<? super media> o) -> {            oonnext(new media())            oonnext(new horrormovie())            return subscriptionsempty()        })map((movie) -> {            return "media transformed: " + movie        })        observablezip(omovie omedia (a b) -> {           return a + " ----- " + b        })subscribe((movie) -> {            systemoutprintln("media/movie: " + movie)        })```or type safety can be thrown away:``` java        observable<string> omovie  observablecreate((observer o) -> {            oonnext(new movie())            oonnext(new movie())            return subscriptionsempty()        })map((movie) -> {            return "movie transformed: " + movie        })```but now that allows this to compile:``` java        observable<string> omovie  observablecreate((observer o) -> {            oonnext(new movie())            oonnext("hello") // this is not a movie object            return subscriptionsempty()        })map((movie) -> {            return "movie transformed: " + movie        })``` || @jmhofer the `create` method is how `observable`s are created so this affects all producers this should not affect consumers other than making the prompts/docs verbose:![screen shot 2013-09-03 at 4 41 21 pm]( and @mustafasezgin do you have any input on this discussion since you are using rxjava from plain java? || groovy is similar  but the generics dont actually do much for it as they are more-or-less ignored at compile time as best i can tell:``` groovy        observable<string> omovie  observablecreate({ observer o ->            oonnext(new movie())            oonnext(new movie())            return subscriptionsempty()        })map({ movie ->            return "movie transformed: " + movie        })        observable<string> omedia  observablecreate({ observer<? super media> o ->            oonnext(new media())            oonnext(new horrormovie())            return subscriptionsempty()        })map({ movie ->            return "media transformed: " + movie        })        observablezip(omovie omedia { a b ->            return a + " ----- " + b        })subscribe({ movie ->            systemoutprintln("media/movie: " + movie)        })``` || this groovy code works against current master as well as the new code with `? super`:``` groovy        observable<movie> omovie  observablecreate({ observer<? super movie> o ->            oonnext(new movie())            oonnext(new movie())            ooncompleted()            return subscriptionsempty()        })        observable<media> omedia  observablecreate({ observer<? super media> o ->            oonnext(new media())            oonnext(new horrormovie())            ooncompleted()            return subscriptionsempty()        })        observablezip(omovie omedia { movie a media b ->            return stringvalueof(a) + " ----- " + stringvalueof(b)        })subscribe({ media ->            systemoutprintln("media/movie: " + media)        })```and here it is again in plain java:``` java        observable<movie> omovie  observablecreate(new func1<observer<? super movie> subscription>() {            @override            public subscription call(observer<? super movie> o) {                oonnext(new movie())                oonnext(new movie())                ooncompleted()                return subscriptionsempty()            }        })        observable<media> omedia  observablecreate(new func1<observer<? super media> subscription>() {            @override            public subscription call(observer<? super media> o) {                oonnext(new media())                oonnext(new horrormovie())                ooncompleted()                return subscriptionsempty()            }        })        observablezip(omovie omedia new func2<movie media string>() {            @override            public string call(movie a media b) {                return stringvalueof(a) + " ----- " + stringvalueof(b)            }        })subscribe(new action1<string>() {            @override            public void call(string media) {                systemoutprintln("media/movie: " + media)            }        })```it seems that `? super` is fine on the outer generics and doesnt need to be typed everywhere its just when its a generic inside a generic the type of the `observer` that it becomes annoying || it seems the only option (while supporting covariance) for reducing code verbosity is to create a new type that hides the `func1<? super observer<? super t> ? extends subscription>` complexityso my question now is: should we change the api to make all uses of `create` use the new type or should it remain as `func1` and the other type is just a nice utility that can be used to fulfill the signature?in other words do we leave it as this:``` javapublic static <t> observable<t> create(func1<? super observer<? super t> ? extends subscription> func)```or change it to ``` javapublic static <t> observable<t> create(observablefunction<t> func)```and what do we call the new type if we go that route? options ive considered are:- `observablefunction`- `observablefunc`- `onsubscribefunction`- `onsubscribefunc`- `funconsubscribe`and should that live in `rxutilfunctions` or `rx` alongside `rxobservable`? it feels that this is not generic and should therefore live inside `rx`unfortunately we can not overload this method and support both as type erasure makes them the same (and it will confuse dynamic languages implicits etc) if we had two methods with similar single function signaturesnormally id rather leave the lower level `func1` method signature and just have a helper class but code completion and javadocs will be far less obvious and not very discoverable thus for discoverability i think it makes more sense to use `create(observablefunction<t> func)` i cant yet think of any forward-compatibility reason why this would be a bad thing this pull request is breaking either direction we pursue || one last spam to everyone  please weigh in if you have an opinion as i intend on making a decision and releasing this weekthis will be a breaking change and affect usage for everyone || here is what the `observablefunction` interface looks like:``` java/** * function interface for work to be performed when an {@link observable} is subscribed to via {@link observable#subscribe(observer)} *  * @param <t> */public interface observablefunction<t> extends func1<observer<? super t> subscription> {    public subscription call(observer<? super t> t1)}```and the updated `create` method:``` javapublic static <t> observable<t> create(observablefunction<t> func) ```and sample code using this:``` java        observable<movie> omovie  observablecreate(new observablefunction<movie>() {            @override            public subscription call(observer<? super movie> o) {                oonnext(new movie())                oonnext(new movie())                ooncompleted()                return subscriptionsempty()            }        })``` || here is a fork including these changes so we can review and discuss:  still not thrilled by any of the directions we can take here i cant argue against making rxjava support covariant types josh bloch certainly supports it in effective java when he says "if you write a library that will be widely used the proper use of wildcard types should be considered mandatory"on the flip-side it forces the use of ? super/? extends everywhere even when covariant requirements are rarei think the only decision at this point to make is whether we should use something like `observablefunction<t>` to minimize the verbosity or just leave `func1<? super observer<? super t> ? extends subscription>` and if we do use `observablefunction` do we provide similar solutions elsewhere? that feels wrong to have special function interfaces for so many things even though it likely will improve readability and usabilityother operators that are awkward include:- `defer(func0<? extends observable<? extends t>> observablefactory)`- `aggregate(func2<? super t ? super t ? extends t> accumulator)`- `buffer(func0<? extends observable<? extends bufferclosing>> bufferclosingselector)`- `flatmap(func1<? super t ? extends observable<? extends r>> func)`flatmap is very common and ends up like this:``` java        omediaflatmap(new func1<media observable<? extends string>>() {            @override            public observable<? extends string> call(media s) {                            }        })```compare this with current:``` java        omediaflatmap(new func1<media observable<string>>() {            @override            public observable<string> call(media s) {                            }        })```however lambdas do make a big different on instance methods (not as much on statics) as they can infer the types for example in java 8 the above can become this:``` java        omediaflatmap(value -> {            return null        })```so without `observablefunction<t>` in java 8 we have:``` java        observablecreate((observer<? super media> o) -> {            oonnext(new media())            oonnext(new horrormovie())            return subscriptionsempty()        })flatmap(movie -> {            return observablefrom("media transformed: " + moviegetname())        })```with `observablefunction<t>` in java 8 we get this:``` java        observablecreate((observer<media> o) -> {            oonnext(new media())            oonnext(new horrormovie())            return subscriptionsempty()        })flatmap(movie -> {            return observablefrom("media transformed: " + moviegetname())        })```it seems that type inference will handle the instance methods for example `aggregate`/`reduce` becomes this:``` java        observablecreate((observer<integer> o) -> {            oonnext(1)            oonnext(2)            return subscriptionsempty()        })aggregate((previous current) -> {            return previous + current        })```so its only the static methods of concern `create` being the most significantjava 6/7 (and android) are going to be ugly no matter what - but we already knew that and they already are this makes it worse || experiencing some of the pain with generic method signatures and nestingfirst hand i prefer the type alias in form of an interface i would arguethat the subscription function is so widely used that the interfacecloaking it will be understood quickly enough by developers so the loss indirect clarity should be negligible || [rxjava-pull-requests #229]( failurelooks like theres a problem with this pull request || +1 observablefunction interface but call it something else maybe with subscription/subscribe in the name || @benjchristensen we could overload `create` etc - for this wed have to make `observablefunction` delegate to `func1` then instead of inheriting from it im not sure if thats a good idea though it would probably be even more confusingim not sure about the naming although it is kind of _the_ internal `observable` function i think id prefer `subscriptionfunction` or `subscriberfunction` or something like that || [rxjava-pull-requests #230]( successthis pull request looks good || how about these names?- `onsubscribefunction`- `onsubscribefunc`- `funconsubscribe` || based on my highly scientific poll of people around me at my office  and the few who have commented above im going with `onsubscribefunc`  || @benjchristensen works for me will it extend `func1` or be an independent type as @jmhofer suggests above i think id prefer the latter || i havent played with it not extending func1 it will need to at least extend `function` so it fits with all other functions in the codebase in what way will it improve things if it doesnt extend? || since this function is only intended for us by the `observablecreate` does anyone have issues with it being namespaced as `rxobservableonsubscribefunc` as a static inner class of `observable` rather than a first-class citizen `rxonsubscribefunc`?this works great in java are there any issues from clojure or scala doing it this way?create looks like this:``` javapublic static <t> observable<t> create(onsubscribefunc<t> func)```use of it looks like this:``` java        import rxobservable        import rxobservableonsubscribefunc        observable<string> observable  observablecreate(new onsubscribefunc<string>() {            @override            public subscription call(observer<? super string> observer) {                observeronnext("one")                observeronnext("two")                observeronnext("three")                observeroncompleted()                return subscriptionsempty()            }        })```the function definition looks like:``` java    /**     * function interface for work to be performed when an {@link observable} is subscribed to via {@link observable#subscribe(observer)}     *      * @param <t>     */    public static interface onsubscribefunc<t> extends function<t> {        public subscription call(observer<? super t> t1)    }``` || good idea and shouldnt be a problem for scala || great ill proceed with this change then thanks for the feedback || final interface looks like this:``` java    /**     * function interface for work to be performed when an {@link observable} is subscribed to via {@link observable#subscribe(observer)}     *      * @param <t>     */    public static interface onsubscribefunc<t> extends function {        public subscription onsubscribe(observer<? super t> t1)    }```this is being merged in  || 
375,1,0,0,0,0,0,1,0,implemented `distinct` operator this pr implements `distinct` as speficied by #38 again i havent implemented the net methods taking an `iequalitycomparator` (see #374) #272 
375,1,0,1,1,1,1,1,1,implemented `distinct` operator this pr implements `distinct` as speficied by #38 again i havent implemented the net methods taking an `iequalitycomparator` (see #374) #272 
375,1,0,0,1,1,1,1,1,implemented `distinct` operator this pr implements `distinct` as speficied by #38 again i havent implemented the net methods taking an `iequalitycomparator` (see #374) #272 
381,1,0,0,0,0,0,1,0,implemented `mapwithindex` as requested by @samuelgruetter in #372 #278 (test failure again due to sporadic timing problems) || i just submitted an [issue]( for this || 
381,1,1,0,1,1,1,1,1,implemented `mapwithindex` as requested by @samuelgruetter in #372 #278 (test failure again due to sporadic timing problems) || i just submitted an [issue]( for this || 
381,1,0,0,0,0,0,1,0,implemented `mapwithindex` as requested by @samuelgruetter in #372 #278 (test failure again due to sporadic timing problems) || i just submitted an [issue]( for this || 
385,1,0,0,0,0,0,1,0,implemented the any operator this implements the operator `any` from #24 in all two variantshowever i encountered two problemsupdated: the online document  is wrong see my later discussio other question is if i add the `any` method to `rxobservable<t>` some unit tests will fail as the method `any` in  `rxobservable<t>` overrides the method `orgmockitomatchersany(javalangclass<t>)` in some unit tests (eg `rxsubjectsreplaysubject<t>`) do i need to use another method name or just modify the unit tests? now the `any` methods in `rxobservable<t>` are commented outthanks #284  i havent looked at the first question yet but on the second one well likely need to stop importing `orgmockitomatchers*` and call it directly `orgmockitomatchersany` || sorry that i missed the keyword `empty` in my description the first question is im not sure how to handle an `empty` observable sequence || #285] i tested the c# `any` today the environment is vs2010 net 40i found the description in my vs is `determines whether any element of an observable sequence satisfies a condition` this is totally different from the online document  always did some tests for `any` here is the code:<pre>using systemusing systemcollectionsgenericusing systemlinqusing systemtextusing systemreactivelinqnamespace consoleapplication1{    class program    {        static void main(string args)        {            var any  observableempty<int>()any()            anysubscribe(                x > consolewriteline("subscriber got " + x) // subscriber got false            )            any  observablerange(1 5)any()            anysubscribe(                x > consolewriteline("subscriber got " + x) // subscriber got true            )                        any  observableempty<int>()any(                x > true            )            anysubscribe(                x > consolewriteline("subscriber got " + x) // subscriber got false            )            any  observablerange(1 5)any(                x > x > 3            )            anysubscribe(                x > consolewriteline("subscriber got " + x) // subscriber got true            )            any  observablerange(1 5)any(                x > x > 5            )            anysubscribe(                x > consolewriteline("subscriber got " + x) // subscriber got false            )            consolereadline()        }    }}</pre>here is the output:<pre>subscriber got falsesubscriber got truesubscriber got falsesubscriber got truesubscriber got false</pre>in summary  - if an observable sequence is empty `any` emits `false`- if one element of an observable sequence satisfies the condition `any` emits `true`- if all elements of an observable sequence do not satisfy the condition `any` emits `false` || i have implemented the correct any operator please take a look  #286] in scala we will probably use `isempty` instead of `any()` (negated) and `exists(somepredicate)` instead of `any(somepredicate)` you could use these names also in java to avoid confusion and name conflicts || @zsxwing i dont have time tonight but will definitely get to this in the near future thank you for getting involved! || 
385,1,1,0,1,1,1,1,1,implemented the any operator this implements the operator `any` from #24 in all two variantshowever i encountered two problemsupdated: the online document  is wrong see my later discussio other question is if i add the `any` method to `rxobservable<t>` some unit tests will fail as the method `any` in  `rxobservable<t>` overrides the method `orgmockitomatchersany(javalangclass<t>)` in some unit tests (eg `rxsubjectsreplaysubject<t>`) do i need to use another method name or just modify the unit tests? now the `any` methods in `rxobservable<t>` are commented outthanks #284  i havent looked at the first question yet but on the second one well likely need to stop importing `orgmockitomatchers*` and call it directly `orgmockitomatchersany` || sorry that i missed the keyword `empty` in my description the first question is im not sure how to handle an `empty` observable sequence || #285] i tested the c# `any` today the environment is vs2010 net 40i found the description in my vs is `determines whether any element of an observable sequence satisfies a condition` this is totally different from the online document  always did some tests for `any` here is the code:<pre>using systemusing systemcollectionsgenericusing systemlinqusing systemtextusing systemreactivelinqnamespace consoleapplication1{    class program    {        static void main(string args)        {            var any  observableempty<int>()any()            anysubscribe(                x > consolewriteline("subscriber got " + x) // subscriber got false            )            any  observablerange(1 5)any()            anysubscribe(                x > consolewriteline("subscriber got " + x) // subscriber got true            )                        any  observableempty<int>()any(                x > true            )            anysubscribe(                x > consolewriteline("subscriber got " + x) // subscriber got false            )            any  observablerange(1 5)any(                x > x > 3            )            anysubscribe(                x > consolewriteline("subscriber got " + x) // subscriber got true            )            any  observablerange(1 5)any(                x > x > 5            )            anysubscribe(                x > consolewriteline("subscriber got " + x) // subscriber got false            )            consolereadline()        }    }}</pre>here is the output:<pre>subscriber got falsesubscriber got truesubscriber got falsesubscriber got truesubscriber got false</pre>in summary  - if an observable sequence is empty `any` emits `false`- if one element of an observable sequence satisfies the condition `any` emits `true`- if all elements of an observable sequence do not satisfy the condition `any` emits `false` || i have implemented the correct any operator please take a look  #286] in scala we will probably use `isempty` instead of `any()` (negated) and `exists(somepredicate)` instead of `any(somepredicate)` you could use these names also in java to avoid confusion and name conflicts || @zsxwing i dont have time tonight but will definitely get to this in the near future thank you for getting involved! || 
385,1,0,0,0,0,0,1,0,implemented the any operator this implements the operator `any` from #24 in all two variantshowever i encountered two problemsupdated: the online document  is wrong see my later discussio other question is if i add the `any` method to `rxobservable<t>` some unit tests will fail as the method `any` in  `rxobservable<t>` overrides the method `orgmockitomatchersany(javalangclass<t>)` in some unit tests (eg `rxsubjectsreplaysubject<t>`) do i need to use another method name or just modify the unit tests? now the `any` methods in `rxobservable<t>` are commented outthanks #284  i havent looked at the first question yet but on the second one well likely need to stop importing `orgmockitomatchers*` and call it directly `orgmockitomatchersany` || sorry that i missed the keyword `empty` in my description the first question is im not sure how to handle an `empty` observable sequence || #285] i tested the c# `any` today the environment is vs2010 net 40i found the description in my vs is `determines whether any element of an observable sequence satisfies a condition` this is totally different from the online document  always did some tests for `any` here is the code:<pre>using systemusing systemcollectionsgenericusing systemlinqusing systemtextusing systemreactivelinqnamespace consoleapplication1{    class program    {        static void main(string args)        {            var any  observableempty<int>()any()            anysubscribe(                x > consolewriteline("subscriber got " + x) // subscriber got false            )            any  observablerange(1 5)any()            anysubscribe(                x > consolewriteline("subscriber got " + x) // subscriber got true            )                        any  observableempty<int>()any(                x > true            )            anysubscribe(                x > consolewriteline("subscriber got " + x) // subscriber got false            )            any  observablerange(1 5)any(                x > x > 3            )            anysubscribe(                x > consolewriteline("subscriber got " + x) // subscriber got true            )            any  observablerange(1 5)any(                x > x > 5            )            anysubscribe(                x > consolewriteline("subscriber got " + x) // subscriber got false            )            consolereadline()        }    }}</pre>here is the output:<pre>subscriber got falsesubscriber got truesubscriber got falsesubscriber got truesubscriber got false</pre>in summary  - if an observable sequence is empty `any` emits `false`- if one element of an observable sequence satisfies the condition `any` emits `true`- if all elements of an observable sequence do not satisfy the condition `any` emits `false` || i have implemented the correct any operator please take a look  #286] in scala we will probably use `isempty` instead of `any()` (negated) and `exists(somepredicate)` instead of `any(somepredicate)` you could use these names also in java to avoid confusion and name conflicts || @zsxwing i dont have time tonight but will definitely get to this in the near future thank you for getting involved! || 
390,1,0,0,0,0,0,1,0,implemented the elementat and elementatordefault operators see #41 hithis implements the `elementat` and `elementatordefault` operators from #41for `elementat` if the index is less than 0 or greater than or equal to the number of elements in the source sequence an indexoutofboundsexception will be threwfor `elementatordefault`  if the index is less than 0 an indexoutofboundsexception will be threw whats more i added a `defaultvalue` parameter i can not get the element type in the source observable due to type erasure so i can not determine the default value automatically thats why `elementatordefault` needs  a `defaultvalue` parameter #288  thank you @zsxwing  ||
390,1,0,0,0,1,1,1,1,implemented the elementat and elementatordefault operators see #41 hithis implements the `elementat` and `elementatordefault` operators from #41for `elementat` if the index is less than 0 or greater than or equal to the number of elements in the source sequence an indexoutofboundsexception will be threwfor `elementatordefault`  if the index is less than 0 an indexoutofboundsexception will be threw whats more i added a `defaultvalue` parameter i can not get the element type in the source observable due to type erasure so i can not determine the default value automatically thats why `elementatordefault` needs  a `defaultvalue` parameter #288  thank you @zsxwing  ||
390,1,0,0,1,1,1,1,1,implemented the elementat and elementatordefault operators see #41 hithis implements the `elementat` and `elementatordefault` operators from #41for `elementat` if the index is less than 0 or greater than or equal to the number of elements in the source sequence an indexoutofboundsexception will be threwfor `elementatordefault`  if the index is less than 0 an indexoutofboundsexception will be threw whats more i added a `defaultvalue` parameter i can not get the element type in the source observable due to type erasure so i can not determine the default value automatically thats why `elementatordefault` needs  a `defaultvalue` parameter #288  thank you @zsxwing  ||
409,1,0,0,0,0,0,1,0,implemented synchronize with lock hii implemented #84 to support that sending a lock to the `synchronize` operatori also found that there was a issue that `testmultithreadedwithnpe` and `testmultithreadedwithnpeinmiddle` might fail in some special situation when `onerror` is invoked before any `onnext` the last statement `assertequals(1 busyobservermaxconcurrentthreadsget())` in these methods will fail i also  this issue in the pull request #313] looks good thank you! ||
409,1,0,1,1,0,1,1,1,implemented synchronize with lock hii implemented #84 to support that sending a lock to the `synchronize` operatori also found that there was a issue that `testmultithreadedwithnpe` and `testmultithreadedwithnpeinmiddle` might fail in some special situation when `onerror` is invoked before any `onnext` the last statement `assertequals(1 busyobservermaxconcurrentthreadsget())` in these methods will fail i also  this issue in the pull request #313] looks good thank you! ||
409,1,0,0,1,1,1,1,1,implemented synchronize with lock hii implemented #84 to support that sending a lock to the `synchronize` operatori also found that there was a issue that `testmultithreadedwithnpe` and `testmultithreadedwithnpeinmiddle` might fail in some special situation when `onerror` is invoked before any `onnext` the last statement `assertequals(1 busyobservermaxconcurrentthreadsget())` in these methods will fail i also  this issue in the pull request #313] looks good thank you! ||
415,1,0,0,0,0,0,1,0,implemented the empty operator with scheduler hii implemented the empty operator with scheduler #42 please take a look thanks #323  #325
415,1,0,1,0,1,1,1,1,implemented the empty operator with scheduler hii implemented the empty operator with scheduler #42 please take a look thanks #323  #325
415,1,0,1,0,0,0,1,0,implemented the empty operator with scheduler hii implemented the empty operator with scheduler #42 please take a look thanks #323  #325
416,1,0,0,0,0,0,1,0,implemented the throw operator with scheduler hii implemented the `throw` operator #89 with scheduler i found that rxjava had an `error` method so i just implemented the scheduler overload #324  @benjchristensen i agree with you i updated the codes and rebased it to master || #338
416,1,1,1,1,1,1,1,1,implemented the throw operator with scheduler hii implemented the `throw` operator #89 with scheduler i found that rxjava had an `error` method so i just implemented the scheduler overload #324  @benjchristensen i agree with you i updated the codes and rebased it to master || #338
416,1,0,1,0,0,1,1,1,implemented the throw operator with scheduler hii implemented the `throw` operator #89 with scheduler i found that rxjava had an `error` method so i just implemented the scheduler overload #324  @benjchristensen i agree with you i updated the codes and rebased it to master || #338
424,1,0,0,0,0,0,1,0,implemented the ignoreelements operator hii implemented the `ignoreelements` operator #54 please take a look thanks #333  can you rebase this with the changes to master so it can be cleanly merged again? with all the other changes this no longer cleanly mergesthank you @zsxwing for this and all the other pull requests i really appreciate your involvement in the project || i rebased the pull request now it should be able to merge to master directly || #336 #337 looks good ||
424,1,1,0,1,1,1,1,1,implemented the ignoreelements operator hii implemented the `ignoreelements` operator #54 please take a look thanks #333  can you rebase this with the changes to master so it can be cleanly merged again? with all the other changes this no longer cleanly mergesthank you @zsxwing for this and all the other pull requests i really appreciate your involvement in the project || i rebased the pull request now it should be able to merge to master directly || #336 #337 looks good ||
424,1,0,1,1,1,1,1,1,implemented the ignoreelements operator hii implemented the `ignoreelements` operator #54 please take a look thanks #333  can you rebase this with the changes to master so it can be cleanly merged again? with all the other changes this no longer cleanly mergesthank you @zsxwing for this and all the other pull requests i really appreciate your involvement in the project || i rebased the pull request now it should be able to merge to master directly || #336 #337 looks good ||
450,1,0,0,0,0,0,1,0,implemented the timeinterval operator hi this pr implemented the `timeinterval` operator #90 please take a look thanks #370 looks good thanks @zsxwing  ||
450,1,0,1,0,0,0,1,0,implemented the timeinterval operator hi this pr implemented the `timeinterval` operator #90 please take a look thanks #370 looks good thanks @zsxwing  ||
450,1,0,0,1,0,1,1,1,implemented the timeinterval operator hi this pr implemented the `timeinterval` operator #90 please take a look thanks #370 looks good thanks @zsxwing  ||
460,1,0,0,0,0,0,1,0,implemented the amb operator hi this pr implemented the `amb` operator #22 i used varargs to support the array version and first-second version in one method so in my pr there are only two variants #379 you shouldnt define a vararg method taking a generic type because you cannot use it without getting warnings (weve already had this with other operators) instead define an overload for 2 args 3 args 4 args  || yup its a pain but this is what we ended up doing for zip merge etc instead of using varargs || #382 thank you ||
460,1,0,0,0,1,1,1,1,implemented the amb operator hi this pr implemented the `amb` operator #22 i used varargs to support the array version and first-second version in one method so in my pr there are only two variants #379 you shouldnt define a vararg method taking a generic type because you cannot use it without getting warnings (weve already had this with other operators) instead define an overload for 2 args 3 args 4 args  || yup its a pain but this is what we ended up doing for zip merge etc instead of using varargs || #382 thank you ||
460,1,0,0,1,1,1,1,1,implemented the amb operator hi this pr implemented the `amb` operator #22 i used varargs to support the array version and first-second version in one method so in my pr there are only two variants #379 you shouldnt define a vararg method taking a generic type because you cannot use it without getting warnings (weve already had this with other operators) instead define an overload for 2 args 3 args 4 args  || yup its a pain but this is what we ended up doing for zip merge etc instead of using varargs || #382 thank you ||
463,1,0,0,0,0,1,1,1,added the rest overloads of timeout operator hi this pr implemented the rest overloads of `timeout` operator #91 please take a look thanks #383 due to pull request  which touched virtually every file in the project can you please rebase this so it can merge cleanly again? || #388 i have rebased it || thank you @zsxwing  ||
463,1,0,0,0,1,1,1,1,added the rest overloads of timeout operator hi this pr implemented the rest overloads of `timeout` operator #91 please take a look thanks #383 due to pull request  which touched virtually every file in the project can you please rebase this so it can merge cleanly again? || #388 i have rebased it || thank you @zsxwing  ||
463,1,0,0,0,1,1,1,1,added the rest overloads of timeout operator hi this pr implemented the rest overloads of `timeout` operator #91 please take a look thanks #383 due to pull request  which touched virtually every file in the project can you please rebase this so it can merge cleanly again? || #388 i have rebased it || thank you @zsxwing  ||
478,1,0,0,0,0,0,1,0,implemented the "operator: min and minby" and "operator: max and maxby" hi this pr implemented the `operator: min and minby` #63 and `operator: max and maxby` #61 every operator has 2 variants one for `comparable` another for `comparator` please take a look thanks! #404  `operationmin` and `operationmax` are exactly the same except that `<` and `>` are swapped cant you implement one in terms of the other? or create a general one which takes +1 or -1 to know whether we want `<` or `>`? || is the following solution ok?``` java    public static <t extends comparable<t>> observable<t> min(            observable<t> source) {        return minmax(source -1)    }    public static <t extends comparable<t>> observable<t> max(            observable<t> source) {        return minmax(source 1)    }    public static <t extends comparable<t>> observable<t> minmax(            observable<t> source final long flag) {        return sourcereduce(new func2<t t t>() {            @override            public t call(t acc t value) {                if (flag * acccompareto(value) > 0) {                    return acc                }                return value            }        })    }````flag` must be `long` as `integermin_value  -1 * integermin_value` but we will have one multiplication for every `compareto`another solution is:``` java    public static <t extends comparable<t>> observable<t> min(            observable<t> source) {        return minmax(source true)    }    public static <t extends comparable<t>> observable<t> max(            observable<t> source) {        return minmax(source false)    }    public static <t extends comparable<t>> observable<t> minmax(            observable<t> source final boolean ismin) {        return sourcereduce(new func2<t t t>() {            @override            public t call(t acc t value) {                if (ismin) {                    if (acccompareto(value) < 0) {                        return acc                    }                } else {                    if (acccompareto(value) > 0) {                        return acc                    }                }                return value            }        })    }```@samuelgruetter  do you have other better solution? || i like both of these two solutions with a slight preference for the first one -)nice catch with integermin_value :-)a third solution would be to implement max using min and wrapping the given comparator such that it inverts the ordering but i think the first solution is the bestanother issue: what if there are several minimal elements? does min return the first of them the last of them or is it unspecified? this should be documented || @samuelgruetter  thanks for your review i used the +1/-1 way to implement it and also updated the document || #407 looks good @zsxwing and thanks @samuelgruetter for the reviewsome nice use of generics in those signatures! ||
478,1,0,0,0,1,1,1,1,implemented the "operator: min and minby" and "operator: max and maxby" hi this pr implemented the `operator: min and minby` #63 and `operator: max and maxby` #61 every operator has 2 variants one for `comparable` another for `comparator` please take a look thanks! #404  `operationmin` and `operationmax` are exactly the same except that `<` and `>` are swapped cant you implement one in terms of the other? or create a general one which takes +1 or -1 to know whether we want `<` or `>`? || is the following solution ok?``` java    public static <t extends comparable<t>> observable<t> min(            observable<t> source) {        return minmax(source -1)    }    public static <t extends comparable<t>> observable<t> max(            observable<t> source) {        return minmax(source 1)    }    public static <t extends comparable<t>> observable<t> minmax(            observable<t> source final long flag) {        return sourcereduce(new func2<t t t>() {            @override            public t call(t acc t value) {                if (flag * acccompareto(value) > 0) {                    return acc                }                return value            }        })    }````flag` must be `long` as `integermin_value  -1 * integermin_value` but we will have one multiplication for every `compareto`another solution is:``` java    public static <t extends comparable<t>> observable<t> min(            observable<t> source) {        return minmax(source true)    }    public static <t extends comparable<t>> observable<t> max(            observable<t> source) {        return minmax(source false)    }    public static <t extends comparable<t>> observable<t> minmax(            observable<t> source final boolean ismin) {        return sourcereduce(new func2<t t t>() {            @override            public t call(t acc t value) {                if (ismin) {                    if (acccompareto(value) < 0) {                        return acc                    }                } else {                    if (acccompareto(value) > 0) {                        return acc                    }                }                return value            }        })    }```@samuelgruetter  do you have other better solution? || i like both of these two solutions with a slight preference for the first one -)nice catch with integermin_value :-)a third solution would be to implement max using min and wrapping the given comparator such that it inverts the ordering but i think the first solution is the bestanother issue: what if there are several minimal elements? does min return the first of them the last of them or is it unspecified? this should be documented || @samuelgruetter  thanks for your review i used the +1/-1 way to implement it and also updated the document || #407 looks good @zsxwing and thanks @samuelgruetter for the reviewsome nice use of generics in those signatures! ||
478,1,0,0,1,1,1,1,1,implemented the "operator: min and minby" and "operator: max and maxby" hi this pr implemented the `operator: min and minby` #63 and `operator: max and maxby` #61 every operator has 2 variants one for `comparable` another for `comparator` please take a look thanks! #404  `operationmin` and `operationmax` are exactly the same except that `<` and `>` are swapped cant you implement one in terms of the other? or create a general one which takes +1 or -1 to know whether we want `<` or `>`? || is the following solution ok?``` java    public static <t extends comparable<t>> observable<t> min(            observable<t> source) {        return minmax(source -1)    }    public static <t extends comparable<t>> observable<t> max(            observable<t> source) {        return minmax(source 1)    }    public static <t extends comparable<t>> observable<t> minmax(            observable<t> source final long flag) {        return sourcereduce(new func2<t t t>() {            @override            public t call(t acc t value) {                if (flag * acccompareto(value) > 0) {                    return acc                }                return value            }        })    }````flag` must be `long` as `integermin_value  -1 * integermin_value` but we will have one multiplication for every `compareto`another solution is:``` java    public static <t extends comparable<t>> observable<t> min(            observable<t> source) {        return minmax(source true)    }    public static <t extends comparable<t>> observable<t> max(            observable<t> source) {        return minmax(source false)    }    public static <t extends comparable<t>> observable<t> minmax(            observable<t> source final boolean ismin) {        return sourcereduce(new func2<t t t>() {            @override            public t call(t acc t value) {                if (ismin) {                    if (acccompareto(value) < 0) {                        return acc                    }                } else {                    if (acccompareto(value) > 0) {                        return acc                    }                }                return value            }        })    }```@samuelgruetter  do you have other better solution? || i like both of these two solutions with a slight preference for the first one -)nice catch with integermin_value :-)a third solution would be to implement max using min and wrapping the given comparator such that it inverts the ordering but i think the first solution is the bestanother issue: what if there are several minimal elements? does min return the first of them the last of them or is it unspecified? this should be documented || @samuelgruetter  thanks for your review i used the +1/-1 way to implement it and also updated the document || #407 looks good @zsxwing and thanks @samuelgruetter for the reviewsome nice use of generics in those signatures! ||
478,1,0,0,0,0,0,1,0,implemented the "operator: min and minby" and "operator: max and maxby" hi this pr implemented the `operator: min and minby` #63 and `operator: max and maxby` #61 every operator has 2 variants one for `comparable` another for `comparator` please take a look thanks! #404  `operationmin` and `operationmax` are exactly the same except that `<` and `>` are swapped cant you implement one in terms of the other? or create a general one which takes +1 or -1 to know whether we want `<` or `>`? || is the following solution ok?``` java    public static <t extends comparable<t>> observable<t> min(            observable<t> source) {        return minmax(source -1)    }    public static <t extends comparable<t>> observable<t> max(            observable<t> source) {        return minmax(source 1)    }    public static <t extends comparable<t>> observable<t> minmax(            observable<t> source final long flag) {        return sourcereduce(new func2<t t t>() {            @override            public t call(t acc t value) {                if (flag * acccompareto(value) > 0) {                    return acc                }                return value            }        })    }````flag` must be `long` as `integermin_value  -1 * integermin_value` but we will have one multiplication for every `compareto`another solution is:``` java    public static <t extends comparable<t>> observable<t> min(            observable<t> source) {        return minmax(source true)    }    public static <t extends comparable<t>> observable<t> max(            observable<t> source) {        return minmax(source false)    }    public static <t extends comparable<t>> observable<t> minmax(            observable<t> source final boolean ismin) {        return sourcereduce(new func2<t t t>() {            @override            public t call(t acc t value) {                if (ismin) {                    if (acccompareto(value) < 0) {                        return acc                    }                } else {                    if (acccompareto(value) > 0) {                        return acc                    }                }                return value            }        })    }```@samuelgruetter  do you have other better solution? || i like both of these two solutions with a slight preference for the first one -)nice catch with integermin_value :-)a third solution would be to implement max using min and wrapping the given comparator such that it inverts the ordering but i think the first solution is the bestanother issue: what if there are several minimal elements? does min return the first of them the last of them or is it unspecified? this should be documented || @samuelgruetter  thanks for your review i used the +1/-1 way to implement it and also updated the document || #407 looks good @zsxwing and thanks @samuelgruetter for the reviewsome nice use of generics in those signatures! ||
478,1,0,1,0,0,1,1,0,implemented the "operator: min and minby" and "operator: max and maxby" hi this pr implemented the `operator: min and minby` #63 and `operator: max and maxby` #61 every operator has 2 variants one for `comparable` another for `comparator` please take a look thanks! #404  `operationmin` and `operationmax` are exactly the same except that `<` and `>` are swapped cant you implement one in terms of the other? or create a general one which takes +1 or -1 to know whether we want `<` or `>`? || is the following solution ok?``` java    public static <t extends comparable<t>> observable<t> min(            observable<t> source) {        return minmax(source -1)    }    public static <t extends comparable<t>> observable<t> max(            observable<t> source) {        return minmax(source 1)    }    public static <t extends comparable<t>> observable<t> minmax(            observable<t> source final long flag) {        return sourcereduce(new func2<t t t>() {            @override            public t call(t acc t value) {                if (flag * acccompareto(value) > 0) {                    return acc                }                return value            }        })    }````flag` must be `long` as `integermin_value  -1 * integermin_value` but we will have one multiplication for every `compareto`another solution is:``` java    public static <t extends comparable<t>> observable<t> min(            observable<t> source) {        return minmax(source true)    }    public static <t extends comparable<t>> observable<t> max(            observable<t> source) {        return minmax(source false)    }    public static <t extends comparable<t>> observable<t> minmax(            observable<t> source final boolean ismin) {        return sourcereduce(new func2<t t t>() {            @override            public t call(t acc t value) {                if (ismin) {                    if (acccompareto(value) < 0) {                        return acc                    }                } else {                    if (acccompareto(value) > 0) {                        return acc                    }                }                return value            }        })    }```@samuelgruetter  do you have other better solution? || i like both of these two solutions with a slight preference for the first one -)nice catch with integermin_value :-)a third solution would be to implement max using min and wrapping the given comparator such that it inverts the ordering but i think the first solution is the bestanother issue: what if there are several minimal elements? does min return the first of them the last of them or is it unspecified? this should be documented || @samuelgruetter  thanks for your review i used the +1/-1 way to implement it and also updated the document || #407 looks good @zsxwing and thanks @samuelgruetter for the reviewsome nice use of generics in those signatures! ||
478,1,0,0,0,0,0,1,0,implemented the "operator: min and minby" and "operator: max and maxby" hi this pr implemented the `operator: min and minby` #63 and `operator: max and maxby` #61 every operator has 2 variants one for `comparable` another for `comparator` please take a look thanks! #404  `operationmin` and `operationmax` are exactly the same except that `<` and `>` are swapped cant you implement one in terms of the other? or create a general one which takes +1 or -1 to know whether we want `<` or `>`? || is the following solution ok?``` java    public static <t extends comparable<t>> observable<t> min(            observable<t> source) {        return minmax(source -1)    }    public static <t extends comparable<t>> observable<t> max(            observable<t> source) {        return minmax(source 1)    }    public static <t extends comparable<t>> observable<t> minmax(            observable<t> source final long flag) {        return sourcereduce(new func2<t t t>() {            @override            public t call(t acc t value) {                if (flag * acccompareto(value) > 0) {                    return acc                }                return value            }        })    }````flag` must be `long` as `integermin_value  -1 * integermin_value` but we will have one multiplication for every `compareto`another solution is:``` java    public static <t extends comparable<t>> observable<t> min(            observable<t> source) {        return minmax(source true)    }    public static <t extends comparable<t>> observable<t> max(            observable<t> source) {        return minmax(source false)    }    public static <t extends comparable<t>> observable<t> minmax(            observable<t> source final boolean ismin) {        return sourcereduce(new func2<t t t>() {            @override            public t call(t acc t value) {                if (ismin) {                    if (acccompareto(value) < 0) {                        return acc                    }                } else {                    if (acccompareto(value) > 0) {                        return acc                    }                }                return value            }        })    }```@samuelgruetter  do you have other better solution? || i like both of these two solutions with a slight preference for the first one -)nice catch with integermin_value :-)a third solution would be to implement max using min and wrapping the given comparator such that it inverts the ordering but i think the first solution is the bestanother issue: what if there are several minimal elements? does min return the first of them the last of them or is it unspecified? this should be documented || @samuelgruetter  thanks for your review i used the +1/-1 way to implement it and also updated the document || #407 looks good @zsxwing and thanks @samuelgruetter for the reviewsome nice use of generics in those signatures! ||
480,1,0,0,0,0,0,1,0,bugfix: emit an illegalargumentexception instead of arithmeticexception if the observable is empty this pr  the `average` issue in #423 if an observable is empty `average` will emit an `illegalargumentexception` instead of `arithmeticexception` thanks! #405 
480,1,0,0,1,1,1,1,1,bugfix: emit an illegalargumentexception instead of arithmeticexception if the observable is empty this pr  the `average` issue in #423 if an observable is empty `average` will emit an `illegalargumentexception` instead of `arithmeticexception` thanks! #405 
480,1,0,1,0,1,1,1,1,bugfix: emit an illegalargumentexception instead of arithmeticexception if the observable is empty this pr  the `average` issue in #423 if an observable is empty `average` will emit an `illegalargumentexception` instead of `arithmeticexception` thanks! #405 
481,1,0,0,0,0,0,1,0,implement the using operator hi this pr implemented the `using` operator #99 please take a look thanks! #406  interesting operator  hadnt really ever looked at this onethank you @zsxwing for the implementation! ||
481,1,0,0,1,1,1,1,1,implement the using operator hi this pr implemented the `using` operator #99 please take a look thanks! #406  interesting operator  hadnt really ever looked at this onethank you @zsxwing for the implementation! ||
481,1,0,0,0,1,1,1,1,implement the using operator hi this pr implemented the `using` operator #99 please take a look thanks! #406  interesting operator  hadnt really ever looked at this onethank you @zsxwing for the implementation! ||
492,1,0,0,0,0,0,1,0,implement the scheduler overloads for range from startwith hi this pr implemented the scheduler overloads for range #68 from #98  startwith #82 please take a look thanks! #415  this conflicts and cant merge can you rebase and update the pr please? || i have updated the pr || #420 
492,1,0,0,1,1,1,1,1,implement the scheduler overloads for range from startwith hi this pr implemented the scheduler overloads for range #68 from #98  startwith #82 please take a look thanks! #415  this conflicts and cant merge can you rebase and update the pr please? || i have updated the pr || #420 
492,1,0,1,0,0,0,1,0,implement the scheduler overloads for range from startwith hi this pr implemented the scheduler overloads for range #68 from #98  startwith #82 please take a look thanks! #415  this conflicts and cant merge can you rebase and update the pr please? || i have updated the pr || #420 
492,1,0,0,0,0,0,1,0,implement the scheduler overloads for range from startwith hi this pr implemented the scheduler overloads for range #68 from #98  startwith #82 please take a look thanks! #415  this conflicts and cant merge can you rebase and update the pr please? || i have updated the pr || #420 
492,1,0,0,1,1,1,1,1,implement the scheduler overloads for range from startwith hi this pr implemented the scheduler overloads for range #68 from #98  startwith #82 please take a look thanks! #415  this conflicts and cant merge can you rebase and update the pr please? || i have updated the pr || #420 
492,1,1,0,0,0,0,1,0,implement the scheduler overloads for range from startwith hi this pr implemented the scheduler overloads for range #68 from #98  startwith #82 please take a look thanks! #415  this conflicts and cant merge can you rebase and update the pr please? || i have updated the pr || #420 
492,1,0,0,0,0,0,1,0,implement the scheduler overloads for range from startwith hi this pr implemented the scheduler overloads for range #68 from #98  startwith #82 please take a look thanks! #415  this conflicts and cant merge can you rebase and update the pr please? || i have updated the pr || #420 
492,1,0,0,1,1,1,1,1,implement the scheduler overloads for range from startwith hi this pr implemented the scheduler overloads for range #68 from #98  startwith #82 please take a look thanks! #415  this conflicts and cant merge can you rebase and update the pr please? || i have updated the pr || #420 
492,1,0,0,0,0,1,1,1,implement the scheduler overloads for range from startwith hi this pr implemented the scheduler overloads for range #68 from #98  startwith #82 please take a look thanks! #415  this conflicts and cant merge can you rebase and update the pr please? || i have updated the pr || #420 
496,1,0,0,0,0,0,1,0,add contravariant for min and max hi this pr added  contravariant for min and max mentioned in #494 #419 
496,1,0,1,0,0,0,1,0,add contravariant for min and max hi this pr added  contravariant for min and max mentioned in #494 #419 
496,1,0,0,1,1,1,1,1,add contravariant for min and max hi this pr added  contravariant for min and max mentioned in #494 #419 
506,1,0,0,0,0,0,1,0,operators: and then when issue #23 issue #88 issue #100can be extended to plan4plan9 and pattern4pattern9 if action4action9 is available not sure about the actionn version #430 i dont understand i used the master havent touched groupby or the schedulers the build succeeds on my machine (although with jdk 7) now what?edit: i found the logical error in operationgroupbytest:334 assuming the thread will finish if it emits 29-49 items is unreliable should that assertion be tested at all? || just another case of  the operationgroupbytest test issue has not be  yet || that is an impressive contribution @akarnokd i dont see any problems in my review the unit tests were essential to understanding and trusting this so thank you for being thoroughim going to merge this and leverage the fact that were still pre 10 so that if there are any issues found we can still fix them even if we need to break a signature ||
506,1,1,0,1,1,1,1,1,operators: and then when issue #23 issue #88 issue #100can be extended to plan4plan9 and pattern4pattern9 if action4action9 is available not sure about the actionn version #430 i dont understand i used the master havent touched groupby or the schedulers the build succeeds on my machine (although with jdk 7) now what?edit: i found the logical error in operationgroupbytest:334 assuming the thread will finish if it emits 29-49 items is unreliable should that assertion be tested at all? || just another case of  the operationgroupbytest test issue has not be  yet || that is an impressive contribution @akarnokd i dont see any problems in my review the unit tests were essential to understanding and trusting this so thank you for being thoroughim going to merge this and leverage the fact that were still pre 10 so that if there are any issues found we can still fix them even if we need to break a signature ||
506,1,0,0,1,1,1,1,1,operators: and then when issue #23 issue #88 issue #100can be extended to plan4plan9 and pattern4pattern9 if action4action9 is available not sure about the actionn version #430 i dont understand i used the master havent touched groupby or the schedulers the build succeeds on my machine (although with jdk 7) now what?edit: i found the logical error in operationgroupbytest:334 assuming the thread will finish if it emits 29-49 items is unreliable should that assertion be tested at all? || just another case of  the operationgroupbytest test issue has not be  yet || that is an impressive contribution @akarnokd i dont see any problems in my review the unit tests were essential to understanding and trusting this so thank you for being thoroughim going to merge this and leverage the fact that were still pre 10 so that if there are any issues found we can still fix them even if we need to break a signature ||
506,1,0,0,0,0,0,1,0,operators: and then when issue #23 issue #88 issue #100can be extended to plan4plan9 and pattern4pattern9 if action4action9 is available not sure about the actionn version #430 i dont understand i used the master havent touched groupby or the schedulers the build succeeds on my machine (although with jdk 7) now what?edit: i found the logical error in operationgroupbytest:334 assuming the thread will finish if it emits 29-49 items is unreliable should that assertion be tested at all? || just another case of  the operationgroupbytest test issue has not be  yet || that is an impressive contribution @akarnokd i dont see any problems in my review the unit tests were essential to understanding and trusting this so thank you for being thoroughim going to merge this and leverage the fact that were still pre 10 so that if there are any issues found we can still fix them even if we need to break a signature ||
506,1,0,0,1,1,1,1,1,operators: and then when issue #23 issue #88 issue #100can be extended to plan4plan9 and pattern4pattern9 if action4action9 is available not sure about the actionn version #430 i dont understand i used the master havent touched groupby or the schedulers the build succeeds on my machine (although with jdk 7) now what?edit: i found the logical error in operationgroupbytest:334 assuming the thread will finish if it emits 29-49 items is unreliable should that assertion be tested at all? || just another case of  the operationgroupbytest test issue has not be  yet || that is an impressive contribution @akarnokd i dont see any problems in my review the unit tests were essential to understanding and trusting this so thank you for being thoroughim going to merge this and leverage the fact that were still pre 10 so that if there are any issues found we can still fix them even if we need to break a signature ||
506,1,0,0,1,1,1,1,1,operators: and then when issue #23 issue #88 issue #100can be extended to plan4plan9 and pattern4pattern9 if action4action9 is available not sure about the actionn version #430 i dont understand i used the master havent touched groupby or the schedulers the build succeeds on my machine (although with jdk 7) now what?edit: i found the logical error in operationgroupbytest:334 assuming the thread will finish if it emits 29-49 items is unreliable should that assertion be tested at all? || just another case of  the operationgroupbytest test issue has not be  yet || that is an impressive contribution @akarnokd i dont see any problems in my review the unit tests were essential to understanding and trusting this so thank you for being thoroughim going to merge this and leverage the fact that were still pre 10 so that if there are any issues found we can still fix them even if we need to break a signature ||
506,1,0,0,0,0,0,1,0,operators: and then when issue #23 issue #88 issue #100can be extended to plan4plan9 and pattern4pattern9 if action4action9 is available not sure about the actionn version #430 i dont understand i used the master havent touched groupby or the schedulers the build succeeds on my machine (although with jdk 7) now what?edit: i found the logical error in operationgroupbytest:334 assuming the thread will finish if it emits 29-49 items is unreliable should that assertion be tested at all? || just another case of  the operationgroupbytest test issue has not be  yet || that is an impressive contribution @akarnokd i dont see any problems in my review the unit tests were essential to understanding and trusting this so thank you for being thoroughim going to merge this and leverage the fact that were still pre 10 so that if there are any issues found we can still fix them even if we need to break a signature ||
506,1,0,0,1,1,1,1,1,operators: and then when issue #23 issue #88 issue #100can be extended to plan4plan9 and pattern4pattern9 if action4action9 is available not sure about the actionn version #430 i dont understand i used the master havent touched groupby or the schedulers the build succeeds on my machine (although with jdk 7) now what?edit: i found the logical error in operationgroupbytest:334 assuming the thread will finish if it emits 29-49 items is unreliable should that assertion be tested at all? || just another case of  the operationgroupbytest test issue has not be  yet || that is an impressive contribution @akarnokd i dont see any problems in my review the unit tests were essential to understanding and trusting this so thank you for being thoroughim going to merge this and leverage the fact that were still pre 10 so that if there are any issues found we can still fix them even if we need to break a signature ||
506,1,0,0,1,1,1,1,1,operators: and then when issue #23 issue #88 issue #100can be extended to plan4plan9 and pattern4pattern9 if action4action9 is available not sure about the actionn version #430 i dont understand i used the master havent touched groupby or the schedulers the build succeeds on my machine (although with jdk 7) now what?edit: i found the logical error in operationgroupbytest:334 assuming the thread will finish if it emits 29-49 items is unreliable should that assertion be tested at all? || just another case of  the operationgroupbytest test issue has not be  yet || that is an impressive contribution @akarnokd i dont see any problems in my review the unit tests were essential to understanding and trusting this so thank you for being thoroughim going to merge this and leverage the fact that were still pre 10 so that if there are any issues found we can still fix them even if we need to break a signature ||
513,1,0,0,0,0,0,1,0,operators tomap and tomultimap again issue #96 and issue #97tomap: 3 overloadstomultimap: 4 overloadsadded groovy test to verify overloading #438  ah  this cant merge anymore because of other commits (probably the join operator on your other pr) can you rebase? ||
513,1,0,0,1,1,1,1,1,operators tomap and tomultimap again issue #96 and issue #97tomap: 3 overloadstomultimap: 4 overloadsadded groovy test to verify overloading #438  ah  this cant merge anymore because of other commits (probably the join operator on your other pr) can you rebase? ||
513,1,0,1,0,0,1,1,1,operators tomap and tomultimap again issue #96 and issue #97tomap: 3 overloadstomultimap: 4 overloadsadded groovy test to verify overloading #438  ah  this cant merge anymore because of other commits (probably the join operator on your other pr) can you rebase? ||
513,1,0,0,0,0,0,1,0,operators tomap and tomultimap again issue #96 and issue #97tomap: 3 overloadstomultimap: 4 overloadsadded groovy test to verify overloading #438  ah  this cant merge anymore because of other commits (probably the join operator on your other pr) can you rebase? ||
513,1,1,0,1,1,1,1,1,operators tomap and tomultimap again issue #96 and issue #97tomap: 3 overloadstomultimap: 4 overloadsadded groovy test to verify overloading #438  ah  this cant merge anymore because of other commits (probably the join operator on your other pr) can you rebase? ||
513,1,0,0,1,1,1,1,1,operators tomap and tomultimap again issue #96 and issue #97tomap: 3 overloadstomultimap: 4 overloadsadded groovy test to verify overloading #438  ah  this cant merge anymore because of other commits (probably the join operator on your other pr) can you rebase? ||
560,1,0,0,0,0,0,1,0,add type variances for dooneach actions this fixes the use of contravariant actions (issue #532) #487  
560,1,0,1,1,0,1,1,0,add type variances for dooneach actions this fixes the use of contravariant actions (issue #532) #487  
560,1,0,1,0,0,0,1,0,add type variances for dooneach actions this fixes the use of contravariant actions (issue #532) #487  
563,1,0,0,0,0,0,1,0,operation groupbyuntil issue #52rebased #491 
563,1,1,0,1,1,1,1,1,operation groupbyuntil issue #52rebased #491 
563,1,0,1,0,0,0,1,0,operation groupbyuntil issue #52rebased #491 
565,1,0,0,0,0,0,1,0,operator groupjoin v2 issue #53rebasedstill: @headinthebox while writing the test for the operator ive noticed that when both duration selectors are never() rxnet never calls oncompleted on the group subjects even though the left and right sources oncomplete() i havent seen rxnet test for this scenario this comes into play when i want to emulate join() with groupjoin(): the outer merge never oncompletes() if i understand the behavior corretly when both left and right sources get depleted there is no way a new group or new group value would arrive and all the open groups and the main observer can be oncompleted() this is somewhat similar to join() and groupbyuntil() behavior #493 
565,1,1,0,1,1,1,1,1,operator groupjoin v2 issue #53rebasedstill: @headinthebox while writing the test for the operator ive noticed that when both duration selectors are never() rxnet never calls oncompleted on the group subjects even though the left and right sources oncomplete() i havent seen rxnet test for this scenario this comes into play when i want to emulate join() with groupjoin(): the outer merge never oncompletes() if i understand the behavior corretly when both left and right sources get depleted there is no way a new group or new group value would arrive and all the open groups and the main observer can be oncompleted() this is somewhat similar to join() and groupbyuntil() behavior #493 
565,1,0,1,0,0,1,1,0,operator groupjoin v2 issue #53rebasedstill: @headinthebox while writing the test for the operator ive noticed that when both duration selectors are never() rxnet never calls oncompleted on the group subjects even though the left and right sources oncomplete() i havent seen rxnet test for this scenario this comes into play when i want to emulate join() with groupjoin(): the outer merge never oncompletes() if i understand the behavior corretly when both left and right sources get depleted there is no way a new group or new group value would arrive and all the open groups and the main observer can be oncompleted() this is somewhat similar to join() and groupbyuntil() behavior #493 
571,1,0,0,0,0,0,1,0,operation sample with observable v2 issue #74- sample will terminate if either the source or the sampler terminates or throws an error- the sampler now emits values only in its onnext() method therefore if the sampler completes and there is a sampled value available (`valuetaken  false`) it wont emit the value before terminating #506 
571,1,1,1,0,0,0,1,0,operation sample with observable v2 issue #74- sample will terminate if either the source or the sampler terminates or throws an error- the sampler now emits values only in its onnext() method therefore if the sampler completes and there is a sampled value available (`valuetaken  false`) it wont emit the value before terminating #506 
571,1,0,0,1,1,1,1,1,operation sample with observable v2 issue #74- sample will terminate if either the source or the sampler terminates or throws an error- the sampler now emits values only in its onnext() method therefore if the sampler completes and there is a sampled value available (`valuetaken  false`) it wont emit the value before terminating #506 
575,1,0,0,0,0,0,1,0,reimplement the sequenceequal operator hi this pr reimplemented the `sequenceequal` operator #76 and should fix the issue #564the wiki page  still needs to be updated @davidmgross could you help update the marble diagram of `sequenceequal`? thanks! #512  okay i think ive got it corrected it only covers one condition so mightbenefit from having some more examples but itll do for nowon fri dec 6 2013 at 7:13 am cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #512 this pull request looks good> > —> reply to this email directly or view it on github ## david m grossplp consulting || @davidmgross looks cool  #514 good job just a few things - you are using `gate` to ensure concurrency and you access the `firstdone` and `seconddone` while synchronizing over `gate` i believe these two can be simple boolean fields instead of atomicbooleans- you are setting the `firstvalues` and `secondvalues` in the `init` method into a volatile fields i believe these can be moved into the constructor and set to a regular `private final list` type and accessor - [optional] you might want to call clear on both `firstvalues` and `secondvalues` if there was a termination condition so they dont hold onto queued values until the client observer disappears || i really think that `sequenceequal` should be implemented in terms of other operators dont reinvent the wheel with every operator you add -)in scala id do it like this:``` scaladef sequenceequal[t](o1: observable[t] o2: observable[t]): observable[boolean]  {  val obs1: observable[option[t]]  o1map(some(_)) ++ observable(none) // ++ is concat  val obs2: observable[option[t]]  o2map(some(_)) ++ observable(none)  // if different length comparing the `none` of the shorter with `some(element)`   // of the longer will return false  (obs1 zip obs2)forall(pair > pair_1  pair_2)}``` || @samuelgruetter  great idea really thanks i overrode the previous commit as their is no option in java i use notification instead || #515 looks good || i also have a question about `notificationhasvalue```` java    /**     * retrieves a value indicating whether this notification has a value     *      * @return a value indicating whether this notification has a value     */    public boolean hasvalue() {        return isonnext() && value ! null    }```here it checks if value is not null but i think value can be nulli also checked the rxnet codes here:  c#            /// <summary>            /// returns true            /// </summary>            public override bool hasvalue { get { return true } }```it returns true directly in `onnextnotification`if `notificationhasvalue` has the same meaning in rxjava and rxnet i think `&& value ! null` needs to be removed || [rxjava-pull-requests #516]( successthis pull request looks good || much nicer now -)regarding hasvalue: i dont know what is it good for if its the same as isonnext? and why would one need the current version? imho it could just be removedsomething else regarding null values and sequenceequal with default equality: i think you shouldnt call onerror(nullpointerexception) but just onnext(true) or onnext(false) || @samuelgruetter thanks for reminding me the null issue || [rxjava-pull-requests #517]( successthis pull request looks good ||
575,1,0,0,1,1,1,1,1,reimplement the sequenceequal operator hi this pr reimplemented the `sequenceequal` operator #76 and should fix the issue #564the wiki page  still needs to be updated @davidmgross could you help update the marble diagram of `sequenceequal`? thanks! #512  okay i think ive got it corrected it only covers one condition so mightbenefit from having some more examples but itll do for nowon fri dec 6 2013 at 7:13 am cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #512 this pull request looks good> > —> reply to this email directly or view it on github ## david m grossplp consulting || @davidmgross looks cool  #514 good job just a few things - you are using `gate` to ensure concurrency and you access the `firstdone` and `seconddone` while synchronizing over `gate` i believe these two can be simple boolean fields instead of atomicbooleans- you are setting the `firstvalues` and `secondvalues` in the `init` method into a volatile fields i believe these can be moved into the constructor and set to a regular `private final list` type and accessor - [optional] you might want to call clear on both `firstvalues` and `secondvalues` if there was a termination condition so they dont hold onto queued values until the client observer disappears || i really think that `sequenceequal` should be implemented in terms of other operators dont reinvent the wheel with every operator you add -)in scala id do it like this:``` scaladef sequenceequal[t](o1: observable[t] o2: observable[t]): observable[boolean]  {  val obs1: observable[option[t]]  o1map(some(_)) ++ observable(none) // ++ is concat  val obs2: observable[option[t]]  o2map(some(_)) ++ observable(none)  // if different length comparing the `none` of the shorter with `some(element)`   // of the longer will return false  (obs1 zip obs2)forall(pair > pair_1  pair_2)}``` || @samuelgruetter  great idea really thanks i overrode the previous commit as their is no option in java i use notification instead || #515 looks good || i also have a question about `notificationhasvalue```` java    /**     * retrieves a value indicating whether this notification has a value     *      * @return a value indicating whether this notification has a value     */    public boolean hasvalue() {        return isonnext() && value ! null    }```here it checks if value is not null but i think value can be nulli also checked the rxnet codes here:  c#            /// <summary>            /// returns true            /// </summary>            public override bool hasvalue { get { return true } }```it returns true directly in `onnextnotification`if `notificationhasvalue` has the same meaning in rxjava and rxnet i think `&& value ! null` needs to be removed || [rxjava-pull-requests #516]( successthis pull request looks good || much nicer now -)regarding hasvalue: i dont know what is it good for if its the same as isonnext? and why would one need the current version? imho it could just be removedsomething else regarding null values and sequenceequal with default equality: i think you shouldnt call onerror(nullpointerexception) but just onnext(true) or onnext(false) || @samuelgruetter thanks for reminding me the null issue || [rxjava-pull-requests #517]( successthis pull request looks good ||
575,1,0,1,0,1,1,1,1,reimplement the sequenceequal operator hi this pr reimplemented the `sequenceequal` operator #76 and should fix the issue #564the wiki page  still needs to be updated @davidmgross could you help update the marble diagram of `sequenceequal`? thanks! #512  okay i think ive got it corrected it only covers one condition so mightbenefit from having some more examples but itll do for nowon fri dec 6 2013 at 7:13 am cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #512 this pull request looks good> > —> reply to this email directly or view it on github ## david m grossplp consulting || @davidmgross looks cool  #514 good job just a few things - you are using `gate` to ensure concurrency and you access the `firstdone` and `seconddone` while synchronizing over `gate` i believe these two can be simple boolean fields instead of atomicbooleans- you are setting the `firstvalues` and `secondvalues` in the `init` method into a volatile fields i believe these can be moved into the constructor and set to a regular `private final list` type and accessor - [optional] you might want to call clear on both `firstvalues` and `secondvalues` if there was a termination condition so they dont hold onto queued values until the client observer disappears || i really think that `sequenceequal` should be implemented in terms of other operators dont reinvent the wheel with every operator you add -)in scala id do it like this:``` scaladef sequenceequal[t](o1: observable[t] o2: observable[t]): observable[boolean]  {  val obs1: observable[option[t]]  o1map(some(_)) ++ observable(none) // ++ is concat  val obs2: observable[option[t]]  o2map(some(_)) ++ observable(none)  // if different length comparing the `none` of the shorter with `some(element)`   // of the longer will return false  (obs1 zip obs2)forall(pair > pair_1  pair_2)}``` || @samuelgruetter  great idea really thanks i overrode the previous commit as their is no option in java i use notification instead || #515 looks good || i also have a question about `notificationhasvalue```` java    /**     * retrieves a value indicating whether this notification has a value     *      * @return a value indicating whether this notification has a value     */    public boolean hasvalue() {        return isonnext() && value ! null    }```here it checks if value is not null but i think value can be nulli also checked the rxnet codes here:  c#            /// <summary>            /// returns true            /// </summary>            public override bool hasvalue { get { return true } }```it returns true directly in `onnextnotification`if `notificationhasvalue` has the same meaning in rxjava and rxnet i think `&& value ! null` needs to be removed || [rxjava-pull-requests #516]( successthis pull request looks good || much nicer now -)regarding hasvalue: i dont know what is it good for if its the same as isonnext? and why would one need the current version? imho it could just be removedsomething else regarding null values and sequenceequal with default equality: i think you shouldnt call onerror(nullpointerexception) but just onnext(true) or onnext(false) || @samuelgruetter thanks for reminding me the null issue || [rxjava-pull-requests #517]( successthis pull request looks good ||
575,1,0,0,0,0,0,1,0,reimplement the sequenceequal operator hi this pr reimplemented the `sequenceequal` operator #76 and should fix the issue #564the wiki page  still needs to be updated @davidmgross could you help update the marble diagram of `sequenceequal`? thanks! #512  okay i think ive got it corrected it only covers one condition so mightbenefit from having some more examples but itll do for nowon fri dec 6 2013 at 7:13 am cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #512 this pull request looks good> > —> reply to this email directly or view it on github ## david m grossplp consulting || @davidmgross looks cool  #514 good job just a few things - you are using `gate` to ensure concurrency and you access the `firstdone` and `seconddone` while synchronizing over `gate` i believe these two can be simple boolean fields instead of atomicbooleans- you are setting the `firstvalues` and `secondvalues` in the `init` method into a volatile fields i believe these can be moved into the constructor and set to a regular `private final list` type and accessor - [optional] you might want to call clear on both `firstvalues` and `secondvalues` if there was a termination condition so they dont hold onto queued values until the client observer disappears || i really think that `sequenceequal` should be implemented in terms of other operators dont reinvent the wheel with every operator you add -)in scala id do it like this:``` scaladef sequenceequal[t](o1: observable[t] o2: observable[t]): observable[boolean]  {  val obs1: observable[option[t]]  o1map(some(_)) ++ observable(none) // ++ is concat  val obs2: observable[option[t]]  o2map(some(_)) ++ observable(none)  // if different length comparing the `none` of the shorter with `some(element)`   // of the longer will return false  (obs1 zip obs2)forall(pair > pair_1  pair_2)}``` || @samuelgruetter  great idea really thanks i overrode the previous commit as their is no option in java i use notification instead || #515 looks good || i also have a question about `notificationhasvalue```` java    /**     * retrieves a value indicating whether this notification has a value     *      * @return a value indicating whether this notification has a value     */    public boolean hasvalue() {        return isonnext() && value ! null    }```here it checks if value is not null but i think value can be nulli also checked the rxnet codes here:  c#            /// <summary>            /// returns true            /// </summary>            public override bool hasvalue { get { return true } }```it returns true directly in `onnextnotification`if `notificationhasvalue` has the same meaning in rxjava and rxnet i think `&& value ! null` needs to be removed || [rxjava-pull-requests #516]( successthis pull request looks good || much nicer now -)regarding hasvalue: i dont know what is it good for if its the same as isonnext? and why would one need the current version? imho it could just be removedsomething else regarding null values and sequenceequal with default equality: i think you shouldnt call onerror(nullpointerexception) but just onnext(true) or onnext(false) || @samuelgruetter thanks for reminding me the null issue || [rxjava-pull-requests #517]( successthis pull request looks good ||
575,1,1,0,1,1,1,1,1,reimplement the sequenceequal operator hi this pr reimplemented the `sequenceequal` operator #76 and should fix the issue #564the wiki page  still needs to be updated @davidmgross could you help update the marble diagram of `sequenceequal`? thanks! #512  okay i think ive got it corrected it only covers one condition so mightbenefit from having some more examples but itll do for nowon fri dec 6 2013 at 7:13 am cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #512 this pull request looks good> > —> reply to this email directly or view it on github ## david m grossplp consulting || @davidmgross looks cool  #514 good job just a few things - you are using `gate` to ensure concurrency and you access the `firstdone` and `seconddone` while synchronizing over `gate` i believe these two can be simple boolean fields instead of atomicbooleans- you are setting the `firstvalues` and `secondvalues` in the `init` method into a volatile fields i believe these can be moved into the constructor and set to a regular `private final list` type and accessor - [optional] you might want to call clear on both `firstvalues` and `secondvalues` if there was a termination condition so they dont hold onto queued values until the client observer disappears || i really think that `sequenceequal` should be implemented in terms of other operators dont reinvent the wheel with every operator you add -)in scala id do it like this:``` scaladef sequenceequal[t](o1: observable[t] o2: observable[t]): observable[boolean]  {  val obs1: observable[option[t]]  o1map(some(_)) ++ observable(none) // ++ is concat  val obs2: observable[option[t]]  o2map(some(_)) ++ observable(none)  // if different length comparing the `none` of the shorter with `some(element)`   // of the longer will return false  (obs1 zip obs2)forall(pair > pair_1  pair_2)}``` || @samuelgruetter  great idea really thanks i overrode the previous commit as their is no option in java i use notification instead || #515 looks good || i also have a question about `notificationhasvalue```` java    /**     * retrieves a value indicating whether this notification has a value     *      * @return a value indicating whether this notification has a value     */    public boolean hasvalue() {        return isonnext() && value ! null    }```here it checks if value is not null but i think value can be nulli also checked the rxnet codes here:  c#            /// <summary>            /// returns true            /// </summary>            public override bool hasvalue { get { return true } }```it returns true directly in `onnextnotification`if `notificationhasvalue` has the same meaning in rxjava and rxnet i think `&& value ! null` needs to be removed || [rxjava-pull-requests #516]( successthis pull request looks good || much nicer now -)regarding hasvalue: i dont know what is it good for if its the same as isonnext? and why would one need the current version? imho it could just be removedsomething else regarding null values and sequenceequal with default equality: i think you shouldnt call onerror(nullpointerexception) but just onnext(true) or onnext(false) || @samuelgruetter thanks for reminding me the null issue || [rxjava-pull-requests #517]( successthis pull request looks good ||
575,1,0,0,0,0,0,1,0,reimplement the sequenceequal operator hi this pr reimplemented the `sequenceequal` operator #76 and should fix the issue #564the wiki page  still needs to be updated @davidmgross could you help update the marble diagram of `sequenceequal`? thanks! #512  okay i think ive got it corrected it only covers one condition so mightbenefit from having some more examples but itll do for nowon fri dec 6 2013 at 7:13 am cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #512 this pull request looks good> > —> reply to this email directly or view it on github ## david m grossplp consulting || @davidmgross looks cool  #514 good job just a few things - you are using `gate` to ensure concurrency and you access the `firstdone` and `seconddone` while synchronizing over `gate` i believe these two can be simple boolean fields instead of atomicbooleans- you are setting the `firstvalues` and `secondvalues` in the `init` method into a volatile fields i believe these can be moved into the constructor and set to a regular `private final list` type and accessor - [optional] you might want to call clear on both `firstvalues` and `secondvalues` if there was a termination condition so they dont hold onto queued values until the client observer disappears || i really think that `sequenceequal` should be implemented in terms of other operators dont reinvent the wheel with every operator you add -)in scala id do it like this:``` scaladef sequenceequal[t](o1: observable[t] o2: observable[t]): observable[boolean]  {  val obs1: observable[option[t]]  o1map(some(_)) ++ observable(none) // ++ is concat  val obs2: observable[option[t]]  o2map(some(_)) ++ observable(none)  // if different length comparing the `none` of the shorter with `some(element)`   // of the longer will return false  (obs1 zip obs2)forall(pair > pair_1  pair_2)}``` || @samuelgruetter  great idea really thanks i overrode the previous commit as their is no option in java i use notification instead || #515 looks good || i also have a question about `notificationhasvalue```` java    /**     * retrieves a value indicating whether this notification has a value     *      * @return a value indicating whether this notification has a value     */    public boolean hasvalue() {        return isonnext() && value ! null    }```here it checks if value is not null but i think value can be nulli also checked the rxnet codes here:  c#            /// <summary>            /// returns true            /// </summary>            public override bool hasvalue { get { return true } }```it returns true directly in `onnextnotification`if `notificationhasvalue` has the same meaning in rxjava and rxnet i think `&& value ! null` needs to be removed || [rxjava-pull-requests #516]( successthis pull request looks good || much nicer now -)regarding hasvalue: i dont know what is it good for if its the same as isonnext? and why would one need the current version? imho it could just be removedsomething else regarding null values and sequenceequal with default equality: i think you shouldnt call onerror(nullpointerexception) but just onnext(true) or onnext(false) || @samuelgruetter thanks for reminding me the null issue || [rxjava-pull-requests #517]( successthis pull request looks good ||
587,1,0,0,0,0,0,1,0,operation longcount issue #60straightforward version of the regular count() (however i would have implemented it differently so the constant boxing-unboxing could be avoided) #524 
587,1,0,0,0,1,1,1,1,operation longcount issue #60straightforward version of the regular count() (however i would have implemented it differently so the constant boxing-unboxing could be avoided) #524 
593,1,0,0,0,0,0,1,0,lock-free subscriptions - uniform naming of inner components: issue #592- lock-free approach to avoid deadlocks: issue #577- serialsubscriptionisunsubscribe added: issue #590remarks:- imo an unsubscribed single/serial/multiple subscription return subscriptionsempty() instead of null so unless the user put a null in there he/she shouldnt worry about null- there was a concurrency bug in @jloisel s reimplementation of compositesubscription it allowed multiple threads to enter the mutation part if the current state was already mutate ive added the necessary checks to allow only normal -> mutate transitions it cannot return subscriptionsempty() since the rx contract is to return null also returning empty() when unsubscribed is ambiguous: has it been unsubscribed or has empty() been set by the client code ? || #527  good that you  the race condition in multipleassignementsubscription as well as the contract (it was unsubscribing the previous subscription although it shouldnt) || ive checked the rxnet sources:- singleassignmentdisposable returns defaultdisposableinstance- serialdisposabe returns null- refcountdisposable returns disposableempty- scheduleddisposable returns defaultdisposableinstanceso my question is why only serialdisposable returns null? checking the return of the getsubscription to determine if unsubscription happened is wrong since serialsubscription can be started with null this is why `isunsubscribed()` is to be used to check the state || > it cannot return subscriptionsempty() since the rx contract is to return nulli dont think that is actually this strict that is what the implementation does i think it is better to return empty than null the real "state" is is isunsubscribed (and the properties might as well be write-only) || i think the disposable / subscription contract lakes precision and uniformity it doesnt matter to return null or empty what matters is a constant behavior following the "least astonishment" principle || 
593,1,1,0,0,0,0,1,0,lock-free subscriptions - uniform naming of inner components: issue #592- lock-free approach to avoid deadlocks: issue #577- serialsubscriptionisunsubscribe added: issue #590remarks:- imo an unsubscribed single/serial/multiple subscription return subscriptionsempty() instead of null so unless the user put a null in there he/she shouldnt worry about null- there was a concurrency bug in @jloisel s reimplementation of compositesubscription it allowed multiple threads to enter the mutation part if the current state was already mutate ive added the necessary checks to allow only normal -> mutate transitions it cannot return subscriptionsempty() since the rx contract is to return null also returning empty() when unsubscribed is ambiguous: has it been unsubscribed or has empty() been set by the client code ? || #527  good that you  the race condition in multipleassignementsubscription as well as the contract (it was unsubscribing the previous subscription although it shouldnt) || ive checked the rxnet sources:- singleassignmentdisposable returns defaultdisposableinstance- serialdisposabe returns null- refcountdisposable returns disposableempty- scheduleddisposable returns defaultdisposableinstanceso my question is why only serialdisposable returns null? checking the return of the getsubscription to determine if unsubscription happened is wrong since serialsubscription can be started with null this is why `isunsubscribed()` is to be used to check the state || > it cannot return subscriptionsempty() since the rx contract is to return nulli dont think that is actually this strict that is what the implementation does i think it is better to return empty than null the real "state" is is isunsubscribed (and the properties might as well be write-only) || i think the disposable / subscription contract lakes precision and uniformity it doesnt matter to return null or empty what matters is a constant behavior following the "least astonishment" principle || 
593,1,0,0,0,0,0,1,0,lock-free subscriptions - uniform naming of inner components: issue #592- lock-free approach to avoid deadlocks: issue #577- serialsubscriptionisunsubscribe added: issue #590remarks:- imo an unsubscribed single/serial/multiple subscription return subscriptionsempty() instead of null so unless the user put a null in there he/she shouldnt worry about null- there was a concurrency bug in @jloisel s reimplementation of compositesubscription it allowed multiple threads to enter the mutation part if the current state was already mutate ive added the necessary checks to allow only normal -> mutate transitions it cannot return subscriptionsempty() since the rx contract is to return null also returning empty() when unsubscribed is ambiguous: has it been unsubscribed or has empty() been set by the client code ? || #527  good that you  the race condition in multipleassignementsubscription as well as the contract (it was unsubscribing the previous subscription although it shouldnt) || ive checked the rxnet sources:- singleassignmentdisposable returns defaultdisposableinstance- serialdisposabe returns null- refcountdisposable returns disposableempty- scheduleddisposable returns defaultdisposableinstanceso my question is why only serialdisposable returns null? checking the return of the getsubscription to determine if unsubscription happened is wrong since serialsubscription can be started with null this is why `isunsubscribed()` is to be used to check the state || > it cannot return subscriptionsempty() since the rx contract is to return nulli dont think that is actually this strict that is what the implementation does i think it is better to return empty than null the real "state" is is isunsubscribed (and the properties might as well be write-only) || i think the disposable / subscription contract lakes precision and uniformity it doesnt matter to return null or empty what matters is a constant behavior following the "least astonishment" principle || 
593,1,0,1,0,0,1,1,1,lock-free subscriptions - uniform naming of inner components: issue #592- lock-free approach to avoid deadlocks: issue #577- serialsubscriptionisunsubscribe added: issue #590remarks:- imo an unsubscribed single/serial/multiple subscription return subscriptionsempty() instead of null so unless the user put a null in there he/she shouldnt worry about null- there was a concurrency bug in @jloisel s reimplementation of compositesubscription it allowed multiple threads to enter the mutation part if the current state was already mutate ive added the necessary checks to allow only normal -> mutate transitions it cannot return subscriptionsempty() since the rx contract is to return null also returning empty() when unsubscribed is ambiguous: has it been unsubscribed or has empty() been set by the client code ? || #527  good that you  the race condition in multipleassignementsubscription as well as the contract (it was unsubscribing the previous subscription although it shouldnt) || ive checked the rxnet sources:- singleassignmentdisposable returns defaultdisposableinstance- serialdisposabe returns null- refcountdisposable returns disposableempty- scheduleddisposable returns defaultdisposableinstanceso my question is why only serialdisposable returns null? checking the return of the getsubscription to determine if unsubscription happened is wrong since serialsubscription can be started with null this is why `isunsubscribed()` is to be used to check the state || > it cannot return subscriptionsempty() since the rx contract is to return nulli dont think that is actually this strict that is what the implementation does i think it is better to return empty than null the real "state" is is isunsubscribed (and the properties might as well be write-only) || i think the disposable / subscription contract lakes precision and uniformity it doesnt matter to return null or empty what matters is a constant behavior following the "least astonishment" principle || 
593,1,0,0,0,0,0,1,0,lock-free subscriptions - uniform naming of inner components: issue #592- lock-free approach to avoid deadlocks: issue #577- serialsubscriptionisunsubscribe added: issue #590remarks:- imo an unsubscribed single/serial/multiple subscription return subscriptionsempty() instead of null so unless the user put a null in there he/she shouldnt worry about null- there was a concurrency bug in @jloisel s reimplementation of compositesubscription it allowed multiple threads to enter the mutation part if the current state was already mutate ive added the necessary checks to allow only normal -> mutate transitions it cannot return subscriptionsempty() since the rx contract is to return null also returning empty() when unsubscribed is ambiguous: has it been unsubscribed or has empty() been set by the client code ? || #527  good that you  the race condition in multipleassignementsubscription as well as the contract (it was unsubscribing the previous subscription although it shouldnt) || ive checked the rxnet sources:- singleassignmentdisposable returns defaultdisposableinstance- serialdisposabe returns null- refcountdisposable returns disposableempty- scheduleddisposable returns defaultdisposableinstanceso my question is why only serialdisposable returns null? checking the return of the getsubscription to determine if unsubscription happened is wrong since serialsubscription can be started with null this is why `isunsubscribed()` is to be used to check the state || > it cannot return subscriptionsempty() since the rx contract is to return nulli dont think that is actually this strict that is what the implementation does i think it is better to return empty than null the real "state" is is isunsubscribed (and the properties might as well be write-only) || i think the disposable / subscription contract lakes precision and uniformity it doesnt matter to return null or empty what matters is a constant behavior following the "least astonishment" principle || 
593,1,0,0,1,1,1,1,1,lock-free subscriptions - uniform naming of inner components: issue #592- lock-free approach to avoid deadlocks: issue #577- serialsubscriptionisunsubscribe added: issue #590remarks:- imo an unsubscribed single/serial/multiple subscription return subscriptionsempty() instead of null so unless the user put a null in there he/she shouldnt worry about null- there was a concurrency bug in @jloisel s reimplementation of compositesubscription it allowed multiple threads to enter the mutation part if the current state was already mutate ive added the necessary checks to allow only normal -> mutate transitions it cannot return subscriptionsempty() since the rx contract is to return null also returning empty() when unsubscribed is ambiguous: has it been unsubscribed or has empty() been set by the client code ? || #527  good that you  the race condition in multipleassignementsubscription as well as the contract (it was unsubscribing the previous subscription although it shouldnt) || ive checked the rxnet sources:- singleassignmentdisposable returns defaultdisposableinstance- serialdisposabe returns null- refcountdisposable returns disposableempty- scheduleddisposable returns defaultdisposableinstanceso my question is why only serialdisposable returns null? checking the return of the getsubscription to determine if unsubscription happened is wrong since serialsubscription can be started with null this is why `isunsubscribed()` is to be used to check the state || > it cannot return subscriptionsempty() since the rx contract is to return nulli dont think that is actually this strict that is what the implementation does i think it is better to return empty than null the real "state" is is isunsubscribed (and the properties might as well be write-only) || i think the disposable / subscription contract lakes precision and uniformity it doesnt matter to return null or empty what matters is a constant behavior following the "least astonishment" principle || 
594,1,0,0,0,0,0,1,0,implement the start operator hi this pr implemented the `start` operator #81 please take a look #528  nice! so `observablestart(func0)` might become the new way of creating futures maybe add some tests which illustrate what happens if i subscribe to `observablestart` before/while/after its calculation has terminated and what happens if there are several subscribers (i think its correctly implemented but just to make everything more stable and better documented) || thanks @samuelgruetter  i added more tests is it necessary to construct a special test that `subscribe` and `func` run at the same time? i think "before" and "after" are enough || #533 #537 looks good || 
594,1,0,1,0,0,0,1,0,implement the start operator hi this pr implemented the `start` operator #81 please take a look #528  nice! so `observablestart(func0)` might become the new way of creating futures maybe add some tests which illustrate what happens if i subscribe to `observablestart` before/while/after its calculation has terminated and what happens if there are several subscribers (i think its correctly implemented but just to make everything more stable and better documented) || thanks @samuelgruetter  i added more tests is it necessary to construct a special test that `subscribe` and `func` run at the same time? i think "before" and "after" are enough || #533 #537 looks good || 
612,1,0,0,0,0,0,1,0,replay additional overloads issue #71- added several overloads of the `replay` operator:   - limited buffer limited time window buffer+time   - scheduler overloads   - versions which perform a projection before the replay- added missing `multicast` overload #548  could you give me an explanation of what the "selector" does and why itsuseful and also what the version of replay that uses a subject factory isall about?  the javadocs are opaque to me and the msdn docs / intro-to-rxarent helpful eitheron thu dec 12 2013 at 12:53 pm cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #548 this pull request looks good> > —> reply to this email directly or view it on github ## david m grossplp consulting || im not sure myself i think it allows transforming the subjects output without the danger of resubscribing to the uplink source i couldnt find any tests for them in the rxnet sources || 
612,1,0,1,0,0,0,1,0,replay additional overloads issue #71- added several overloads of the `replay` operator:   - limited buffer limited time window buffer+time   - scheduler overloads   - versions which perform a projection before the replay- added missing `multicast` overload #548  could you give me an explanation of what the "selector" does and why itsuseful and also what the version of replay that uses a subject factory isall about?  the javadocs are opaque to me and the msdn docs / intro-to-rxarent helpful eitheron thu dec 12 2013 at 12:53 pm cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #548 this pull request looks good> > —> reply to this email directly or view it on github ## david m grossplp consulting || im not sure myself i think it allows transforming the subjects output without the danger of resubscribing to the uplink source i couldnt find any tests for them in the rxnet sources || 
635,1,0,0,0,0,0,1,0,operators: switchcase (case) ifthen (if) dowhile (dowhile) whiledo (w hile)issue #634no msdn references available #565 
635,1,0,0,0,0,1,1,1,operators: switchcase (case) ifthen (if) dowhile (dowhile) whiledo (w hile)issue #634no msdn references available #565 
657,1,0,0,0,0,0,1,0,operations aggregate average and sum with selector issue #653remarks:- i know we can combine ops to get one of the new aggregate variant but i think it might be worth having a direct version which avoids nesting several layers of observables observers and subscriptions- the `averageinteger` and `suminteger` (and the other types) are handy if we want to use chained operation invocations (with less overhead):``` javaobservablefrom("a" "bb" "ccc")suminteger(s -> slength())    toblockingobservable()single()```instead of``` javaobservablesumintegers(observablefrom("a" "bb" "ccc")map(s -> slength()))    toblockingobservable()single()``` #590  this establishes (or strengthens) a precedent of adding a large number of helper methods for very specific cases to the already massive `observable` so id like to explore one of two routes:1) move mathematical operators to a separate `observable` in `rxobservablenumericalobservable` or something like that2) move them into a contrib module like  || id go for `numericalobservable` on this one as it is primarily useful out-of-box whereas futures may go into contrib ||
657,1,0,1,0,0,1,1,1,operations aggregate average and sum with selector issue #653remarks:- i know we can combine ops to get one of the new aggregate variant but i think it might be worth having a direct version which avoids nesting several layers of observables observers and subscriptions- the `averageinteger` and `suminteger` (and the other types) are handy if we want to use chained operation invocations (with less overhead):``` javaobservablefrom("a" "bb" "ccc")suminteger(s -> slength())    toblockingobservable()single()```instead of``` javaobservablesumintegers(observablefrom("a" "bb" "ccc")map(s -> slength()))    toblockingobservable()single()``` #590  this establishes (or strengthens) a precedent of adding a large number of helper methods for very specific cases to the already massive `observable` so id like to explore one of two routes:1) move mathematical operators to a separate `observable` in `rxobservablenumericalobservable` or something like that2) move them into a contrib module like  || id go for `numericalobservable` on this one as it is primarily useful out-of-box whereas futures may go into contrib ||
667,1,0,0,0,0,0,1,0,operators skip skiplast take with time rebased version without the drain scheduler variant- fixes issue mentioned in #666 as well #601
667,1,0,1,0,1,1,1,1,operators skip skiplast take with time rebased version without the drain scheduler variant- fixes issue mentioned in #666 as well #601
733,1,0,0,0,0,0,1,0,buffer with observable boundary mentined in issue #653- 1 overload where the user can specify the capacity of the internal buffer #647 
733,1,0,1,0,0,1,1,0,buffer with observable boundary mentined in issue #653- 1 overload where the user can specify the capacity of the internal buffer #647 
734,1,0,0,0,0,0,1,0,delay with subscription and item delaying observables listed in #653note: onerror and oncompleted events of the source are immediately propagated and will prevent emitting any pending values #648  #660
734,1,0,0,1,1,1,1,1,delay with subscription and item delaying observables listed in #653note: onerror and oncompleted events of the source are immediately propagated and will prevent emitting any pending values #648  #660
735,1,0,0,0,0,0,1,0,window with observable boundary listed in issue #653 #649 
735,1,0,0,1,0,1,1,1,window with observable boundary listed in issue #653 #649 
736,1,0,0,0,0,0,1,0,mergemap with iterable and resultselector overloads listed in #653 forgot an overload || #650  #651 looks these operators can be implemented by composing the existing operators || i agree there is likely some simplification we can do on this but im going to merge as the public apis look correct and unit tests are good we can iterate on the implementation internally ||
736,1,0,0,1,0,1,1,1,mergemap with iterable and resultselector overloads listed in #653 forgot an overload || #650  #651 looks these operators can be implemented by composing the existing operators || i agree there is likely some simplification we can do on this but im going to merge as the public apis look correct and unit tests are good we can iterate on the implementation internally ||
738,1,0,0,0,0,0,1,0,publish and publishlast overloads listed in #653these operators use the existing multicast and subject infrastructure so i omitted any direct tests #652  #653
738,1,0,1,0,1,1,1,1,publish and publishlast overloads listed in #653these operators use the existing multicast and subject infrastructure so i omitted any direct tests #652  #653
740,1,0,0,0,0,0,1,0,timeout with selector overloads listed in #653 #655 
740,1,0,0,1,0,1,1,1,timeout with selector overloads listed in #653 #655 
741,1,0,0,0,0,0,1,0,zip with iterable removed old aggregator version and updated tests listed in #653 #656  these are instance methods none of our `zip` operators are at the instance level i would have thought wed add the `zip` overloads with `iterable` to match the existing static ones? || i went according to #653 where there was 2 zip overloads without strike-through || agreed on the overloads but they should be static correct? || no the intention was to chain them to an existing observable:``` javaobservablefrom(1 2 3)zip(arraysaslist(4 5 6) (a b) -> a * b)``` || makes sense wasnt sure as it was different than all the other zip methods thanks for confirming  ||
741,1,0,0,1,1,1,1,1,zip with iterable removed old aggregator version and updated tests listed in #653 #656  these are instance methods none of our `zip` operators are at the instance level i would have thought wed add the `zip` overloads with `iterable` to match the existing static ones? || i went according to #653 where there was 2 zip overloads without strike-through || agreed on the overloads but they should be static correct? || no the intention was to chain them to an existing observable:``` javaobservablefrom(1 2 3)zip(arraysaslist(4 5 6) (a b) -> a * b)``` || makes sense wasnt sure as it was different than all the other zip methods thanks for confirming  ||
825,1,0,0,0,0,0,1,0,issue #799 - commenting out the call to attachcallingthreadstack when co nstructing a compositeexception should i merge this manually into 017? ||
825,1,0,1,0,0,0,1,0,issue #799 - commenting out the call to attachcallingthreadstack when co nstructing a compositeexception should i merge this manually into 017? ||
860,1,0,0,0,0,0,1,0,fixing the generics for merge and lift ive tracked down to two problems #858 the first is that lift wasnt quite right i changed the lift argument from `operator<r t>` to `operator<? extends r ? super t>`  unfortunately java wont let us hide that away in the `operator` class so we have to redeclare that everywhere in the debug hooks but its still better than the alternative of having to use the full `func1<? extends subscriber<? super r> ? super subscriber<? super t>>` everywherethe second problem was in the return type of merge `observable<t>`  because of operators like `merge(observable<? extends t> t1 observable<? extends t> t2)` the only thing that can be said for the return type is that it is also `observable<? extends t>` but at the moment it is returning `observable<t>`this pull request changes all of them and leads to some silly return values like```observable<string> a bobservable<? extends string> x  merge(a b)``` #784 we should avoid return types such as `a<? extends b>` || #787 #788  @akarnokd you were right the return type change wasnt necessary  ive reverted and rebased the branch to clean out all the mistakes || [rxjava-pull-requests #789 i almost did a pr on this when i saw you now did the same thing as i but was it necessary to change the debugs as well? || yes there is a plugin hook inside lift that the debug plugin implements and spreads from there ||
860,1,0,0,0,0,0,1,0,fixing the generics for merge and lift ive tracked down to two problems #858 the first is that lift wasnt quite right i changed the lift argument from `operator<r t>` to `operator<? extends r ? super t>`  unfortunately java wont let us hide that away in the `operator` class so we have to redeclare that everywhere in the debug hooks but its still better than the alternative of having to use the full `func1<? extends subscriber<? super r> ? super subscriber<? super t>>` everywherethe second problem was in the return type of merge `observable<t>`  because of operators like `merge(observable<? extends t> t1 observable<? extends t> t2)` the only thing that can be said for the return type is that it is also `observable<? extends t>` but at the moment it is returning `observable<t>`this pull request changes all of them and leads to some silly return values like```observable<string> a bobservable<? extends string> x  merge(a b)``` #784 we should avoid return types such as `a<? extends b>` || #787 #788  @akarnokd you were right the return type change wasnt necessary  ive reverted and rebased the branch to clean out all the mistakes || [rxjava-pull-requests #789 i almost did a pr on this when i saw you now did the same thing as i but was it necessary to change the debugs as well? || yes there is a plugin hook inside lift that the debug plugin implements and spreads from there ||
955,1,0,0,1,0,1,1,1, replaysubject leak fix for issue #939 #889  i can confirm this 939 for me thanks @akarnokd !this might in fact be the final nail in the coffin for any workarounds we used on android to prevent activities from leaking this is great || @benjchristensen do you think we could get this in for 0171 that would be fantastic it would simplify reasoning about requirements for android operators a lot since the use of `cache` and `replay` is quite common on android and some design decisions for `operatorobservefromandroidcomponent` were made purely due to the existence of this bug (no one actually thought to question the correctness of the underlying operator back then hah) ||
955,1,0,0,1,1,1,1,1, replaysubject leak fix for issue #939 #889  i can confirm this 939 for me thanks @akarnokd !this might in fact be the final nail in the coffin for any workarounds we used on android to prevent activities from leaking this is great || @benjchristensen do you think we could get this in for 0171 that would be fantastic it would simplify reasoning about requirements for android operators a lot since the use of `cache` and `replay` is quite common on android and some design decisions for `operatorobservefromandroidcomponent` were made purely due to the existence of this bug (no one actually thought to question the correctness of the underlying operator back then hah) ||
964,1,0,0,1,0,1,1,1,subjectsubscriptionmanager fix fix for #961if an already unsubscribed subscriber is added the subscription function ends up in an infinite loop as the inner unsubscription logic changes the state to another object before the outer state machine continues- the outer state machine loop now exits if unsubscription happened and doesnt attempt to modify the state- the removeobserver method is changed so that if the subscription to be removed is not in the array it returns this instead of an unnecessary copy in addition copyof calls have been replaced by arraycopy to avoid reflective array creation #904 interesting bug thanks for the fix!as for the test failure looks like `testnumberofthreadsonscheduledmerge` has become non-deterministic as a result of recent changes (not your commit) ||
964,1,0,1,0,0,1,1,0,subjectsubscriptionmanager fix fix for #961if an already unsubscribed subscriber is added the subscription function ends up in an infinite loop as the inner unsubscription logic changes the state to another object before the outer state machine continues- the outer state machine loop now exits if unsubscription happened and doesnt attempt to modify the state- the removeobserver method is changed so that if the subscription to be removed is not in the array it returns this instead of an unnecessary copy in addition copyof calls have been replaced by arraycopy to avoid reflective array creation #904 interesting bug thanks for the fix!as for the test failure looks like `testnumberofthreadsonscheduledmerge` has become non-deterministic as a result of recent changes (not your commit) ||
965,0,0,0,0,0,0,1,0,bugfix: chain subscription in timeoutsubscriber and serializedsubscriber this pr chains subscription in timeoutsubscriber  and serializedsubscriber found by @rbramw #951 thanks for your unit tests @rbramw #905 i have no idea why `rxoperatorsoperationparallelmergetesttestnumberofthreadsonscheduledmerge` failed in my local machine it fails sometimes is it nondeterministic? || rebased || #915  thank you ||
965,1,1,0,0,0,0,1,0,bugfix: chain subscription in timeoutsubscriber and serializedsubscriber this pr chains subscription in timeoutsubscriber  and serializedsubscriber found by @rbramw #951 thanks for your unit tests @rbramw #905 i have no idea why `rxoperatorsoperationparallelmergetesttestnumberofthreadsonscheduledmerge` failed in my local machine it fails sometimes is it nondeterministic? || rebased || #915  thank you ||
972,1,0,0,1,0,0,1,0, deadlock in subjects + operatorcache fix for issue #971- i had to rewrite operatorcache to allow testing for deadlocks in all subject types- the terminationlatch was unnecessarily waiting for existing subscribers to deliver their termination events which caused deadlock with repeat()- treating subjects as internal implementations was not necessary to fix the problem #912  i dont understand these changes yet but on first review they are very awkward as the `subjectsubscriptionmanager` methods now both invoke a function and return a collection || true the rewritten subjects dont require an action1 they are fine with action0 the changes had to be made since the countdonwlatch logic acted as a synchronization block and emitting events while holding locks is prone to deadlocks as the associated issue demonstrates || ah holding the lock is the issue we should find a way of doing that without the latches at all as it is blocking  || the latch has its use because once the state has been swapped to terminal state we still need to perform some tasks on any related state within the particular subject before client notifications can resume: usually it is to set the last event which then will be available to newcomers || i havent merged this yet as i need to spend time better understanding this and the impact on design || since this has conflicts and i did some cleanup based on our discussion above ive opened  for merging this  ||
972,1,0,1,0,0,0,1,0, deadlock in subjects + operatorcache fix for issue #971- i had to rewrite operatorcache to allow testing for deadlocks in all subject types- the terminationlatch was unnecessarily waiting for existing subscribers to deliver their termination events which caused deadlock with repeat()- treating subjects as internal implementations was not necessary to fix the problem #912  i dont understand these changes yet but on first review they are very awkward as the `subjectsubscriptionmanager` methods now both invoke a function and return a collection || true the rewritten subjects dont require an action1 they are fine with action0 the changes had to be made since the countdonwlatch logic acted as a synchronization block and emitting events while holding locks is prone to deadlocks as the associated issue demonstrates || ah holding the lock is the issue we should find a way of doing that without the latches at all as it is blocking  || the latch has its use because once the state has been swapped to terminal state we still need to perform some tasks on any related state within the particular subject before client notifications can resume: usually it is to set the last event which then will be available to newcomers || i havent merged this yet as i need to spend time better understanding this and the impact on design || since this has conflicts and i did some cleanup based on our discussion above ive opened  for merging this  ||
1073,1,0,0,0,0,0,1,0,operatorbuffer operator buffer split into 4 variantsissue #1060there are some important behavioral changes compared to the original versions:- when an onerror event appears from anywhere the currently accumulated chunk(s) are _not_ emitted before the error is propagated this conforms with rx design guideline 66- the observable returned by the func0 inside the `buffer(func0<observable<b>>)` now is used as long as possible and whenever it fires an event a new buffer chunk is started the func0 is called only once per subscriber the original called it and subscribed to it all the time causing all-increasing resubscriptions #986 
1073,1,0,0,0,1,1,1,1,operatorbuffer operator buffer split into 4 variantsissue #1060there are some important behavioral changes compared to the original versions:- when an onerror event appears from anywhere the currently accumulated chunk(s) are _not_ emitted before the error is propagated this conforms with rx design guideline 66- the observable returned by the func0 inside the `buffer(func0<observable<b>>)` now is used as long as possible and whenever it fires an event a new buffer chunk is started the func0 is called only once per subscriber the original called it and subscribed to it all the time causing all-increasing resubscriptions #986 
1079,1,0,0,0,0,0,1,0,operatorcombinelatest operator combinelatestissue #1060remarks:- added an overload to observable which accepts any number of sources not sure why it wasnt exposed before? perhaps removed?- relying on just the sos onnext is not enough as leaving the synchronized block allows reordering of onnext calls therefore the combinator uses the trick from serializedobserver to make sure the combination order is consistent with whe winning of the synchronization "race"  #990 
1079,1,1,0,0,0,0,1,0,operatorcombinelatest operator combinelatestissue #1060remarks:- added an overload to observable which accepts any number of sources not sure why it wasnt exposed before? perhaps removed?- relying on just the sos onnext is not enough as leaving the synchronized block allows reordering of onnext calls therefore the combinator uses the trick from serializedobserver to make sure the combination order is consistent with whe winning of the synchronization "race"  #990 
1083,1,0,0,0,0,0,1,0,operatordematerialize operator dematerializeissue #1060two notes:- since the dematerialize() is an instance method there is no correct type parametrization for the operator therefore i just used a raw version in the call- the original dematerialize could send out two oncompleted or an onerror followed by an oncompleted because the materialize() always adds an oncompleted after the raw events this affected operators due to unsafesubscribe this new version ensures this doesnt happen #994 
1083,1,0,1,0,0,0,1,0,operatordematerialize operator dematerializeissue #1060two notes:- since the dematerialize() is an instance method there is no correct type parametrization for the operator therefore i just used a raw version in the call- the original dematerialize could send out two oncompleted or an onerror followed by an oncompleted because the materialize() always adds an oncompleted after the raw events this affected operators due to unsafesubscribe this new version ensures this doesnt happen #994 
1084,1,0,0,0,0,0,1,0,operatordistinct operator distinctissue #1060i didnt port the variant with the custom key comparator because it has been decided to rely on `objectequals` and there were not exposed anyway #995 
1084,1,0,0,0,0,0,1,0,operatordistinct operator distinctissue #1060i didnt port the variant with the custom key comparator because it has been decided to rely on `objectequals` and there were not exposed anyway #995 
1085,1,0,0,0,0,0,1,0,operatordistinctuntilchanged operator distinctuntilchangedissue #1060again i havent ported the custom comparator version #996
1085,1,0,0,0,1,1,1,1,operatordistinctuntilchanged operator distinctuntilchangedissue #1060again i havent ported the custom comparator version #996
1095,1,0,0,0,0,0,1,0,operatorgroupbyuntil operator groupbyuntilfor issue #1060while rewriting ive noticed a common pitfall with the observation of the duration: many other operators react to onnext or oncompleted but one should only "expire" once ill review my recent operators and post a separate pr if any #1005
1095,1,0,0,1,0,1,1,1,operatorgroupbyuntil operator groupbyuntilfor issue #1060while rewriting ive noticed a common pitfall with the observation of the duration: many other operators react to onnext or oncompleted but one should only "expire" once ill review my recent operators and post a separate pr if any #1005
1096,1,0,0,0,0,0,1,0,operatorgroupjoin operator groupjoinfor issue #1060maybe this could be moved to the new joins #1006 is this better associated with rxjava-joins? ||
1096,1,1,0,0,0,0,1,0,operatorgroupjoin operator groupjoinfor issue #1060maybe this could be moved to the new joins #1006 is this better associated with rxjava-joins? ||
1103,1,0,0,0,0,0,1,0,operatorjoin operator joinissue #1060remark: now that the clientonnext is called outside the synchronization block joint results may appear in arbitrary order in case both left and right observables emit values concurrently i suppose the strict ordering is not really expected here but someone who uses this operator can tell (@duncani perhaps?) #1014 rxoperatorsoperatorpivottesttestconcurrencyandserialization needs some fixing || > rxoperatorsoperatorpivottesttestconcurrencyandserialization needs some fixing yes it does ||
1103,1,0,1,0,0,0,1,0,operatorjoin operator joinissue #1060remark: now that the clientonnext is called outside the synchronization block joint results may appear in arbitrary order in case both left and right observables emit values concurrently i suppose the strict ordering is not really expected here but someone who uses this operator can tell (@duncani perhaps?) #1014 rxoperatorsoperatorpivottesttestconcurrencyandserialization needs some fixing || > rxoperatorsoperatorpivottesttestconcurrencyandserialization needs some fixing yes it does ||
1120,1,0,0,0,0,0,1,0,operatorsequenceequal operator sequenceequal#1060lightened the operator but note that notificationlite escaping an operator may cause undesired effects in other operators relying on notificationlite as well #1032 
1120,1,0,0,1,1,1,1,1,operatorsequenceequal operator sequenceequal#1060lightened the operator but note that notificationlite escaping an operator may cause undesired effects in other operators relying on notificationlite as well #1032 
1121,1,0,0,0,0,0,1,0,operatorskiptimed operator skiptimed#1060there was an unexpected dependency in `operationtaketimedtest` and is surely to cause conflict when `taketimed` is rewritten once all operators have been merged i suggest we create a primary `testexception` and rewrite tests to use it instead of all those custom exception classes everywhere #1033
1121,1,0,0,0,1,1,1,1,operatorskiptimed operator skiptimed#1060there was an unexpected dependency in `operationtaketimedtest` and is surely to cause conflict when `taketimed` is rewritten once all operators have been merged i suggest we create a primary `testexception` and rewrite tests to use it instead of all those custom exception classes everywhere #1033
1132,1,0,0,0,0,0,1,0,manual merge of several prs merging many prs that were conflictingheroic work by @akarnokd and @zsxwing on #1060 all unit tests are passing on my machine going to let this bake a while before a release other prs on still on their way  
1132,1,0,0,1,1,1,1,1,manual merge of several prs merging many prs that were conflictingheroic work by @akarnokd and @zsxwing on #1060 all unit tests are passing on my machine going to let this bake a while before a release other prs on still on their way  
1160,1,0,0,0,0,0,1,0,add `replay` and `multicast` variants to rxscala this pr has some breaking changes:- change `def multicast[r >: t](subject: rxlangscalasubject[r]): (() > subscription observable[r])` to `def multicast[r >: t](subject: rxlangscalasubject[r]): connectableobservable[r]`- change `def replay: (() > subscription observable[t])` to `def replay: connectableobservable[t]`- remove `observableapply(int)`so its better to merge it at the next major release#1152 #1153/cc @headinthebox @samuelgruetter #1072  id like someone with better scala skills that me to review this please || ill code review it later today but in principle these are simple fixes to bring the other variants of publish in sync with returning connectable observable || #1081 #1087 looks good || is this reviewed and ready to go? it is conflicting against master so can you please rebase? || this is also conflicting against #1178 i would like to rebase it after #1178 is merged to master || waiting until #1210 is  already merged || [rxjava-pull-requests #1129]( successthis pull request looks good || should this wait until were ready to do 019? || i think this one can be merged since #1188 has already broken the api @headinthebox @samuelgruetter  do you mind it? || go for it ||
1160,1,0,1,0,0,1,1,1,add `replay` and `multicast` variants to rxscala this pr has some breaking changes:- change `def multicast[r >: t](subject: rxlangscalasubject[r]): (() > subscription observable[r])` to `def multicast[r >: t](subject: rxlangscalasubject[r]): connectableobservable[r]`- change `def replay: (() > subscription observable[t])` to `def replay: connectableobservable[t]`- remove `observableapply(int)`so its better to merge it at the next major release#1152 #1153/cc @headinthebox @samuelgruetter #1072  id like someone with better scala skills that me to review this please || ill code review it later today but in principle these are simple fixes to bring the other variants of publish in sync with returning connectable observable || #1081 #1087 looks good || is this reviewed and ready to go? it is conflicting against master so can you please rebase? || this is also conflicting against #1178 i would like to rebase it after #1178 is merged to master || waiting until #1210 is  already merged || [rxjava-pull-requests #1129]( successthis pull request looks good || should this wait until were ready to do 019? || i think this one can be merged since #1188 has already broken the api @headinthebox @samuelgruetter  do you mind it? || go for it ||
1160,1,0,0,0,0,0,1,0,add `replay` and `multicast` variants to rxscala this pr has some breaking changes:- change `def multicast[r >: t](subject: rxlangscalasubject[r]): (() > subscription observable[r])` to `def multicast[r >: t](subject: rxlangscalasubject[r]): connectableobservable[r]`- change `def replay: (() > subscription observable[t])` to `def replay: connectableobservable[t]`- remove `observableapply(int)`so its better to merge it at the next major release#1152 #1153/cc @headinthebox @samuelgruetter #1072  id like someone with better scala skills that me to review this please || ill code review it later today but in principle these are simple fixes to bring the other variants of publish in sync with returning connectable observable || #1081 #1087 looks good || is this reviewed and ready to go? it is conflicting against master so can you please rebase? || this is also conflicting against #1178 i would like to rebase it after #1178 is merged to master || waiting until #1210 is  already merged || [rxjava-pull-requests #1129]( successthis pull request looks good || should this wait until were ready to do 019? || i think this one can be merged since #1188 has already broken the api @headinthebox @samuelgruetter  do you mind it? || go for it ||
1160,1,0,0,1,0,1,1,1,add `replay` and `multicast` variants to rxscala this pr has some breaking changes:- change `def multicast[r >: t](subject: rxlangscalasubject[r]): (() > subscription observable[r])` to `def multicast[r >: t](subject: rxlangscalasubject[r]): connectableobservable[r]`- change `def replay: (() > subscription observable[t])` to `def replay: connectableobservable[t]`- remove `observableapply(int)`so its better to merge it at the next major release#1152 #1153/cc @headinthebox @samuelgruetter #1072  id like someone with better scala skills that me to review this please || ill code review it later today but in principle these are simple fixes to bring the other variants of publish in sync with returning connectable observable || #1081 #1087 looks good || is this reviewed and ready to go? it is conflicting against master so can you please rebase? || this is also conflicting against #1178 i would like to rebase it after #1178 is merged to master || waiting until #1210 is  already merged || [rxjava-pull-requests #1129]( successthis pull request looks good || should this wait until were ready to do 019? || i think this one can be merged since #1188 has already broken the api @headinthebox @samuelgruetter  do you mind it? || go for it ||
1185,1,0,0,1,0,0,1,0,behavior subject time gap fix 2 based on discussions in #1181 ive unified the behavior among the subjectsbehaviorsubject doesnt seem to exhibit issue #658 and #1184a second pair of eyes would be great to confirm the correctness and check if the removal of the countdownlatch was the correct approach #1095 wow this is quite the change :-) i need fresher eyes on this one so will come back to it thank you very much for tackling this! || this is non-trivial code so i may have missed something but this looks like excellent forward progress on what we had to add the functionality needed for `behaviorsubject` and sharing the logic across all of the `subject` implsvery nice work ||
1185,1,0,1,1,1,1,1,1,behavior subject time gap fix 2 based on discussions in #1181 ive unified the behavior among the subjectsbehaviorsubject doesnt seem to exhibit issue #658 and #1184a second pair of eyes would be great to confirm the correctness and check if the removal of the countdownlatch was the correct approach #1095 wow this is quite the change :-) i need fresher eyes on this one so will come back to it thank you very much for tackling this! || this is non-trivial code so i may have missed something but this looks like excellent forward progress on what we had to add the functionality needed for `behaviorsubject` and sharing the logic across all of the `subject` implsvery nice work ||
1185,1,0,0,1,0,0,1,0,behavior subject time gap fix 2 based on discussions in #1181 ive unified the behavior among the subjectsbehaviorsubject doesnt seem to exhibit issue #658 and #1184a second pair of eyes would be great to confirm the correctness and check if the removal of the countdownlatch was the correct approach #1095 wow this is quite the change :-) i need fresher eyes on this one so will come back to it thank you very much for tackling this! || this is non-trivial code so i may have missed something but this looks like excellent forward progress on what we had to add the functionality needed for `behaviorsubject` and sharing the logic across all of the `subject` implsvery nice work ||
1185,1,0,1,0,0,0,1,0,behavior subject time gap fix 2 based on discussions in #1181 ive unified the behavior among the subjectsbehaviorsubject doesnt seem to exhibit issue #658 and #1184a second pair of eyes would be great to confirm the correctness and check if the removal of the countdownlatch was the correct approach #1095 wow this is quite the change :-) i need fresher eyes on this one so will come back to it thank you very much for tackling this! || this is non-trivial code so i may have missed something but this looks like excellent forward progress on what we had to add the functionality needed for `behaviorsubject` and sharing the logic across all of the `subject` implsvery nice work ||
1185,1,0,0,1,0,0,1,0,behavior subject time gap fix 2 based on discussions in #1181 ive unified the behavior among the subjectsbehaviorsubject doesnt seem to exhibit issue #658 and #1184a second pair of eyes would be great to confirm the correctness and check if the removal of the countdownlatch was the correct approach #1095 wow this is quite the change :-) i need fresher eyes on this one so will come back to it thank you very much for tackling this! || this is non-trivial code so i may have missed something but this looks like excellent forward progress on what we had to add the functionality needed for `behaviorsubject` and sharing the logic across all of the `subject` implsvery nice work ||
1185,1,1,0,0,0,0,1,0,behavior subject time gap fix 2 based on discussions in #1181 ive unified the behavior among the subjectsbehaviorsubject doesnt seem to exhibit issue #658 and #1184a second pair of eyes would be great to confirm the correctness and check if the removal of the countdownlatch was the correct approach #1095 wow this is quite the change :-) i need fresher eyes on this one so will come back to it thank you very much for tackling this! || this is non-trivial code so i may have missed something but this looks like excellent forward progress on what we had to add the functionality needed for `behaviorsubject` and sharing the logic across all of the `subject` implsvery nice work ||
1195,1,0,0,0,0,0,1,0,swingscheduler: allow negative schedule fix for issue #1193 the new `scheduleperiodic` may calculate negative delay times if the next task was already due this change will allow negative timing on the swing scheduler indicating an immediate schedule #1106 i suggest adding some comments in the `schedulerschedule` and `schedulescheduleperiodically` about negative timing eg "negative delay time should be regarded as 0" it would be helpful for anyone who wants to implement special `scheduler` || ive added extra comments || #1109 
1195,1,0,1,0,1,1,1,1,swingscheduler: allow negative schedule fix for issue #1193 the new `scheduleperiodic` may calculate negative delay times if the next task was already due this change will allow negative timing on the swing scheduler indicating an immediate schedule #1106 i suggest adding some comments in the `schedulerschedule` and `schedulescheduleperiodically` about negative timing eg "negative delay time should be regarded as 0" it would be helpful for anyone who wants to implement special `scheduler` || ive added extra comments || #1109 
1236,1,0,0,0,0,0,1,0,compositesubscription with atomic field updater this pr is aimed at #1204 to reduce unnecessary memory overhead in frequently used classes this change in `compositesubscription` saves about 24 bytes per instancein addition the field updaters may be faster by about 8-15% for small adds and removals ive changed the implementation of unsubscribe to use getandset which leverages platform intrinsics and is usually compiled to a single instruction: this makes unsubscribing a tiny bit faster and thus reducing latency in benchmarks that only pass on single element around #1137 
1236,1,0,0,0,1,1,1,1,compositesubscription with atomic field updater this pr is aimed at #1204 to reduce unnecessary memory overhead in frequently used classes this change in `compositesubscription` saves about 24 bytes per instancein addition the field updaters may be faster by about 8-15% for small adds and removals ive changed the implementation of unsubscribe to use getandset which leverages platform intrinsics and is usually compiled to a single instruction: this makes unsubscribing a tiny bit faster and thus reducing latency in benchmarks that only pass on single element around #1137 
1237,0,0,0,0,0,0,1,0,safesubscriber memory reduction for #1204 this saves 24 bytes per instance #1138  thanks i think we probably should do this all over i havent merged my change to `compositesubscription` yet so that needs to be done as well || oh you already have a pr for `compositesubscription` as well :-) || @akarnokd @benjchristensen why was there a change from boolean to int? || there is no atomicbooleanfieldupdater and the nearest thing is an atomicintegerfieldupdater since classes are padded to 4-8 byte boundaries anyway moving from 1 byte boolean to 4 byte integer is no extra overhead || oh i just checked you are right that explains a lot but i have no clue why they didnt add that ||
1237,1,0,0,0,0,0,1,0,safesubscriber memory reduction for #1204 this saves 24 bytes per instance #1138  thanks i think we probably should do this all over i havent merged my change to `compositesubscription` yet so that needs to be done as well || oh you already have a pr for `compositesubscription` as well :-) || @akarnokd @benjchristensen why was there a change from boolean to int? || there is no atomicbooleanfieldupdater and the nearest thing is an atomicintegerfieldupdater since classes are padded to 4-8 byte boundaries anyway moving from 1 byte boolean to 4 byte integer is no extra overhead || oh i just checked you are right that explains a lot but i have no clue why they didnt add that ||
1269,1,0,0,0,0,0,1,0,fix the bug that int overflow can bypass the range check fix the bug mentioned in #1266 #1164 #1165 #1166 
1269,1,0,0,0,0,0,1,0,fix the bug that int overflow can bypass the range check fix the bug mentioned in #1266 #1164 #1165 #1166 
1271,1,0,0,0,0,0,1,0,operator retry with predicate operator retry with predicate + 1 overload for issue #1214the func1 version is simply named `retry` the func2 version is named `retryif` due to lack of ideas and because to avoid overload resolution issues i also had to open up the operatorretrytest classes a bit #1169  thanks for implementing this should we just keep one of those two instead of both so we dont have to deal with the naming/overload issue? || i dont know which one to keep? || probably the one that includes attempts? this is the advanced use case for retry so it should probably provide both attempts and error it just feels awkward to need to come up with a new name just so we can have one with `attempts` and one without@headinthebox do you have an opinion on this? || agree with @benjchristensen if you are using this one you (should) know what you are doing || #1176 thanks @akarnokd and @headinthebox for the review ||
1271,1,1,0,0,0,0,1,0,operator retry with predicate operator retry with predicate + 1 overload for issue #1214the func1 version is simply named `retry` the func2 version is named `retryif` due to lack of ideas and because to avoid overload resolution issues i also had to open up the operatorretrytest classes a bit #1169  thanks for implementing this should we just keep one of those two instead of both so we dont have to deal with the naming/overload issue? || i dont know which one to keep? || probably the one that includes attempts? this is the advanced use case for retry so it should probably provide both attempts and error it just feels awkward to need to come up with a new name just so we can have one with `attempts` and one without@headinthebox do you have an opinion on this? || agree with @benjchristensen if you are using this one you (should) know what you are doing || #1176 thanks @akarnokd and @headinthebox for the review ||
1272,1,0,0,1,0,1,1,0,executorscheduler to wrap an executor for issue #1219 (and #1206)this implementation should conform with the scheduler contract except it is not possible to avoid thread-hopping (dont worry the tasks execute serially but maybe not on the same physical thread)few open improvement possibilities:- usage of `mpsclinkedqueue` once available- a better performing subscription container for this kind of queue-drain task tracking instead of `compositesubscription`- ability to remove a `subscription` from a `compositesubscription` without it calling unsubscribe on the removed subscription á la `multipleassignmentsubscriptionset()` #1170  thanks @akarnokd for this looks good for a first cut the trade-offs (thread hopping) are expected and why we wont use this as a default for anything and agreed on possible improvements but those can come later ||
1272,1,0,0,1,1,1,1,1,executorscheduler to wrap an executor for issue #1219 (and #1206)this implementation should conform with the scheduler contract except it is not possible to avoid thread-hopping (dont worry the tasks execute serially but maybe not on the same physical thread)few open improvement possibilities:- usage of `mpsclinkedqueue` once available- a better performing subscription container for this kind of queue-drain task tracking instead of `compositesubscription`- ability to remove a `subscription` from a `compositesubscription` without it calling unsubscribe on the removed subscription á la `multipleassignmentsubscriptionset()` #1170  thanks @akarnokd for this looks good for a first cut the trade-offs (thread hopping) are expected and why we wont use this as a default for anything and agreed on possible improvements but those can come later ||
1272,1,0,0,1,0,1,1,0,executorscheduler to wrap an executor for issue #1219 (and #1206)this implementation should conform with the scheduler contract except it is not possible to avoid thread-hopping (dont worry the tasks execute serially but maybe not on the same physical thread)few open improvement possibilities:- usage of `mpsclinkedqueue` once available- a better performing subscription container for this kind of queue-drain task tracking instead of `compositesubscription`- ability to remove a `subscription` from a `compositesubscription` without it calling unsubscribe on the removed subscription á la `multipleassignmentsubscriptionset()` #1170  thanks @akarnokd for this looks good for a first cut the trade-offs (thread hopping) are expected and why we wont use this as a default for anything and agreed on possible improvements but those can come later ||
1272,1,0,1,0,0,0,1,0,executorscheduler to wrap an executor for issue #1219 (and #1206)this implementation should conform with the scheduler contract except it is not possible to avoid thread-hopping (dont worry the tasks execute serially but maybe not on the same physical thread)few open improvement possibilities:- usage of `mpsclinkedqueue` once available- a better performing subscription container for this kind of queue-drain task tracking instead of `compositesubscription`- ability to remove a `subscription` from a `compositesubscription` without it calling unsubscribe on the removed subscription á la `multipleassignmentsubscriptionset()` #1170  thanks @akarnokd for this looks good for a first cut the trade-offs (thread hopping) are expected and why we wont use this as a default for anything and agreed on possible improvements but those can come later ||
1286,1,0,0,0,0,0,1,0,rename some operator* classes to onsubscribe* as per #1270 see discussion in issue #1270 numerous classes in the `rxoperator` package are not implementations of `operator` but are actually implementations of `onsubscribe` the classes have been renamed in this pull requestexcuse me not squashing commits looked complicated after doing a pull from upstream in the middle #1187 
1286,1,0,0,0,0,1,1,1,rename some operator* classes to onsubscribe* as per #1270 see discussion in issue #1270 numerous classes in the `rxoperator` package are not implementations of `operator` but are actually implementations of `onsubscribe` the classes have been renamed in this pull requestexcuse me not squashing commits looked complicated after doing a pull from upstream in the middle #1187 
1287,1,0,0,0,0,0,1,0,replaysubject remove replaystate chm and related subjectobserver changes for issue #1204this change should help avoid chm garbage (although boxed integers will still fly around) in addition i moved the notificationlite around to make room for the index ive also removed the callback onadd in publishsubject because it was unnecessary #1188  awesome ill try this against the tests i was doing || this looks like it does improve performance and object allocation when using my hystrix tests i get this:new```run: 10 - 208720 ops/sec run: 11 - 209834 ops/sec run: 12 - 209217 ops/sec run: 13 - 208026 ops/sec run: 14 - 211303 ops/sec ```old```run: 10 - 153523 ops/sec run: 11 - 162289 ops/sec run: 12 - 162347 ops/sec run: 13 - 159153 ops/sec run: 14 - 160194 ops/sec ```new```run: 10 - 572909 ops/sec run: 11 - 568987 ops/sec run: 12 - 572521 ops/sec run: 13 - 571594 ops/sec run: 14 - 572979 ops/sec ```old```run: 10 - 487791 ops/sec run: 11 - 491292 ops/sec run: 12 - 480598 ops/sec run: 13 - 484517 ops/sec run: 14 - 489212 ops/sec ```old:![old]( i need to go give hystrix some love too as there are some obvious things to go solve therethanks @akarnokd for getting to this so quickly ||
1287,1,1,0,0,0,0,1,0,replaysubject remove replaystate chm and related subjectobserver changes for issue #1204this change should help avoid chm garbage (although boxed integers will still fly around) in addition i moved the notificationlite around to make room for the index ive also removed the callback onadd in publishsubject because it was unnecessary #1188  awesome ill try this against the tests i was doing || this looks like it does improve performance and object allocation when using my hystrix tests i get this:new```run: 10 - 208720 ops/sec run: 11 - 209834 ops/sec run: 12 - 209217 ops/sec run: 13 - 208026 ops/sec run: 14 - 211303 ops/sec ```old```run: 10 - 153523 ops/sec run: 11 - 162289 ops/sec run: 12 - 162347 ops/sec run: 13 - 159153 ops/sec run: 14 - 160194 ops/sec ```new```run: 10 - 572909 ops/sec run: 11 - 568987 ops/sec run: 12 - 572521 ops/sec run: 13 - 571594 ops/sec run: 14 - 572979 ops/sec ```old```run: 10 - 487791 ops/sec run: 11 - 491292 ops/sec run: 12 - 480598 ops/sec run: 13 - 484517 ops/sec run: 14 - 489212 ops/sec ```old:![old]( i need to go give hystrix some love too as there are some obvious things to go solve therethanks @akarnokd for getting to this so quickly ||
1347,1,0,0,0,0,1,1,1,allow use of the returned subscription to cancel periodic scheduling the documentation for scheduleperiodically indicates that the returnedsubscription can be used to unsubscribe from the periodic action or tounschedule it if it has not been scheduled yet that was the case onlybefore the first action took place and it was then impossible tounsubscribe using the given subscription although unsubscribing theworker did workthis 1344 #1257  this new version contains a  fix by @akarnokd || #1258 thank you ||
1347,1,0,1,1,1,1,1,1,allow use of the returned subscription to cancel periodic scheduling the documentation for scheduleperiodically indicates that the returnedsubscription can be used to unsubscribe from the periodic action or tounschedule it if it has not been scheduled yet that was the case onlybefore the first action took place and it was then impossible tounsubscribe using the given subscription although unsubscribing theworker did workthis 1344 #1257  this new version contains a  fix by @akarnokd || #1258 thank you ||
1367,0,0,0,0,0,0,1,0,fix the bug that flatmap swallows onerrornotimplementedexception  #1365not sure if any other place will swallow `onerrornotimplementedexception` or the fatal errors #1292  #1293 hi allim new here so i may be missing something but im afraid that this issue should not be closed just yetindeed it looks like there is still a problem if there is more than one flatmap in the chainhere is a unit test to reproduce the bug (i used the previous unit test that was added as part of this bugfix and simply added an additional flatmap stage) :```    @test(expected  onerrornotimplementedexceptionclass)    public void testsubscribewithoutonerror() {        observablejust("a" "b")        flatmap(s -> observablejust(s + "1" s + "2"))        flatmap(s -> observableerror(new exception("test")))        foreach(systemout::println)    }```the output i get is nothing and no error eithershould i submit a new issue or can you reopen this one? think the issue still exists there needs to be clear functionality by which exception can be cleanly trapped and rethrown if needed(user preference) to upper layers 
1367,1,0,1,0,0,0,1,0,fix the bug that flatmap swallows onerrornotimplementedexception  #1365not sure if any other place will swallow `onerrornotimplementedexception` or the fatal errors #1292  #1293 hi allim new here so i may be missing something but im afraid that this issue should not be closed just yetindeed it looks like there is still a problem if there is more than one flatmap in the chainhere is a unit test to reproduce the bug (i used the previous unit test that was added as part of this bugfix and simply added an additional flatmap stage) :```    @test(expected  onerrornotimplementedexceptionclass)    public void testsubscribewithoutonerror() {        observablejust("a" "b")        flatmap(s -> observablejust(s + "1" s + "2"))        flatmap(s -> observableerror(new exception("test")))        foreach(systemout::println)    }```the output i get is nothing and no error eithershould i submit a new issue or can you reopen this one? think the issue still exists there needs to be clear functionality by which exception can be cleanly trapped and rethrown if needed(user preference) to upper layers 
1393,1,0,0,0,0,0,1,0,add cache(int capacity) to observable proposed patch for #1303 #1335 
1393,1,0,1,0,1,1,1,1,add cache(int capacity) to observable proposed patch for #1303 #1335 
1422,1,0,1,0,0,0,1,0,concurrency fixes for rxringbuffer & merge possible fix for #1420i was unable to exactly reproduce the issue but was able to create a possibly related one this fixes itit also simplifies the logic and code somewhat at a possible small performance cost for these:```rooperatormergeperfmerge1syncstreamofn            1000  thrpt         5    59407716     2073945    ops/srooperatormergeperfmerge1syncstreamofn         1000000  thrpt         5       66557        2693    ops/srooperatormergeperfmergensyncstreamsofn           1000  thrpt         5       59293        5046    ops/s```  
1422,1,0,1,0,0,0,1,0,concurrency fixes for rxringbuffer & merge possible fix for #1420i was unable to exactly reproduce the issue but was able to create a possibly related one this fixes itit also simplifies the logic and code somewhat at a possible small performance cost for these:```rooperatormergeperfmerge1syncstreamofn            1000  thrpt         5    59407716     2073945    ops/srooperatormergeperfmerge1syncstreamofn         1000000  thrpt         5       66557        2693    ops/srooperatormergeperfmergensyncstreamsofn           1000  thrpt         5       59293        5046    ops/s```  
1431,1,0,0,0,0,1,1,0,compositeexception fix for android 1405- revert changes from f4ae92aa- remove duplicated causes in stack trace chain #1385 this will take a while to review as those changes were done for good reason || maybe i should provide some explanation about what was wrong with the previous implementationheres how most of java programmers will rethrow an exception if not handled:```        observablecreate((subscriber<? super object> subscriber) ->                subscriberonerror(new runtimeexception("ex1")))                observeon(androidschedulersmainthread())                subscribeon(schedulersio())subscribe(                object -> {                    //                 } error -> {                    // handle some exceptions                                        // rethrow unhandled                    throw new runtimeexception("ex2" error)                }        )```now we have `compositeexception` with two nested exceptions:- `ex1`- `ex2` which cause is `ex1`the previous implementation will create a loop in this situation:```onerrorfailedexception   compositeexception      ex1         ex2             ex1                 ex2                     ``` ive provided test for this scenario and additional method to remove throwables which are causes of another throwable it means `ex1` will not be attached as a cause of the `compositeexception` because it is a cause of `ex2` so it will be automatically attached with `ex2` and printed in the stack trace output ```onerrorfailedexception   compositeexception         ex2             ex1``` || /cc @mattrjacobs matt can you get involved here (now that youre back) since you have the most recent history and context in this code discussion at  || given the new constraint that android does something unexpected (to me anyway) with the set of printstacktrace methods its probably preferable to modify the structure of compositeexception so that any arbitrary output of a compositeexception is correct  relying on the implementation details of precisely how android does the printstacktrace doesnt protect us from any other edge cases  so i generally think the sort of change proposed by @tomrozb is good - im validating what the output looks like in our prod env now  thanks @tomrozb for the pr || im merging this now thanks for the clear explanation and fix with a test @tomrozb || thanks @mattrjacobs and @tomrozb  || 
1431,1,0,1,0,0,1,1,0,compositeexception fix for android 1405- revert changes from f4ae92aa- remove duplicated causes in stack trace chain #1385 this will take a while to review as those changes were done for good reason || maybe i should provide some explanation about what was wrong with the previous implementationheres how most of java programmers will rethrow an exception if not handled:```        observablecreate((subscriber<? super object> subscriber) ->                subscriberonerror(new runtimeexception("ex1")))                observeon(androidschedulersmainthread())                subscribeon(schedulersio())subscribe(                object -> {                    //                 } error -> {                    // handle some exceptions                                        // rethrow unhandled                    throw new runtimeexception("ex2" error)                }        )```now we have `compositeexception` with two nested exceptions:- `ex1`- `ex2` which cause is `ex1`the previous implementation will create a loop in this situation:```onerrorfailedexception   compositeexception      ex1         ex2             ex1                 ex2                     ``` ive provided test for this scenario and additional method to remove throwables which are causes of another throwable it means `ex1` will not be attached as a cause of the `compositeexception` because it is a cause of `ex2` so it will be automatically attached with `ex2` and printed in the stack trace output ```onerrorfailedexception   compositeexception         ex2             ex1``` || /cc @mattrjacobs matt can you get involved here (now that youre back) since you have the most recent history and context in this code discussion at  || given the new constraint that android does something unexpected (to me anyway) with the set of printstacktrace methods its probably preferable to modify the structure of compositeexception so that any arbitrary output of a compositeexception is correct  relying on the implementation details of precisely how android does the printstacktrace doesnt protect us from any other edge cases  so i generally think the sort of change proposed by @tomrozb is good - im validating what the output looks like in our prod env now  thanks @tomrozb for the pr || im merging this now thanks for the clear explanation and fix with a test @tomrozb || thanks @mattrjacobs and @tomrozb  || 
1559,1,0,0,1,0,0,1,0,more consistent hooks for scheduler plugins  this is a rework of #1514 - deprecated rxjavadefaultschedulers and rxjavadefaultschedulersdefault (i think these names are confusing)- added rxjavaschedulershook- ability to override entire schedulers from scratch- ability to decorate action0 before submission to schedulerthe main change from #1514 is the decoration of action0 instead of runnable  action0 is an improvement as all schedulers must handle these whereas not all schedulers handle runnables #1473  reviewed with @benjchristensen and merging ||
1559,1,1,0,0,0,0,1,0,more consistent hooks for scheduler plugins  this is a rework of #1514 - deprecated rxjavadefaultschedulers and rxjavadefaultschedulersdefault (i think these names are confusing)- added rxjavaschedulershook- ability to override entire schedulers from scratch- ability to decorate action0 before submission to schedulerthe main change from #1514 is the decoration of action0 instead of runnable  action0 is an improvement as all schedulers must handle these whereas not all schedulers handle runnables #1473  reviewed with @benjchristensen and merging ||
1602,1,0,0,0,0,0,1,0,make retrywhen the same with the scheduler as the retrywhen without the scheduler came up in #1580 #1510  #1511
1602,1,0,0,1,1,1,1,1,make retrywhen the same with the scheduler as the retrywhen without the scheduler came up in #1580 #1510  #1511
1705,0,0,0,0,0,1,1,0,issue #1642 fix null-emitting combinelatest @benjchristensen  thanks for fixing this stupid bug on my partit should have been:``` javabuffergetvalue(o)// orbufferaccept(o child)```your fix does the same thing || @benjchristensen just saw that this didnt make it into 0205  do i need to do something to make sure it gets into 0206?  cant tell how you guys are managing the various release branches || this was merged into 1x and is in the 10 releases (it was in 100-rc4  you want it also in the 020x releases go ahead and submit another pr against that branch1x is where most of the focus is as we work towards the 10 final release scheduled for november 18th || ah  i tried switching us over to 100-rc4 but one of our dependencies uses the comnetflix packaging and android wont let us include both in our apk (dex complains about duplicate classes)   || > one of our dependencies uses the comnetflix packagingyes its going to be a painful one-time migration to get onto 10 once we hit 10 final ill encourage everyone to do so ||
1705,1,0,0,0,0,1,1,1,issue #1642 fix null-emitting combinelatest @benjchristensen  thanks for fixing this stupid bug on my partit should have been:``` javabuffergetvalue(o)// orbufferaccept(o child)```your fix does the same thing || @benjchristensen just saw that this didnt make it into 0205  do i need to do something to make sure it gets into 0206?  cant tell how you guys are managing the various release branches || this was merged into 1x and is in the 10 releases (it was in 100-rc4  you want it also in the 020x releases go ahead and submit another pr against that branch1x is where most of the focus is as we work towards the 10 final release scheduled for november 18th || ah  i tried switching us over to 100-rc4 but one of our dependencies uses the comnetflix packaging and android wont let us include both in our apk (dex complains about duplicate classes)   || > one of our dependencies uses the comnetflix packagingyes its going to be a painful one-time migration to get onto 10 once we hit 10 final ill encourage everyone to do so ||
1742,1,0,0,0,0,1,1,1,emptyobserver and testobserver - remove `emptyobserver` as it was confusing compared to `observersempty()` (1741)- make `testobserver` not throw `onerrornotimplemented` if a delegate is not provided (fixes #1571)  
1742,1,0,0,1,1,1,1,1,emptyobserver and testobserver - remove `emptyobserver` as it was confusing compared to `observersempty()` (1741)- make `testobserver` not throw `onerrornotimplemented` if a delegate is not provided (fixes #1571)  
1742,1,0,0,0,0,1,1,1,emptyobserver and testobserver - remove `emptyobserver` as it was confusing compared to `observersempty()` (1741)- make `testobserver` not throw `onerrornotimplemented` if a delegate is not provided (fixes #1571)  
1761,0,0,0,0,0,1,1,0,issue #1642 fix null-emitting combinelatest same as  but for the 020\* folks  
1767,1,0,0,1,0,1,1,0,executorscheduler delivers uncaught exceptions instead of swallowing unhandled errors executorscheduler delivers themto the executing threads uncaughtexceptionhandlerthis addresses the same issue as reactivex/rxjava#1682 but forexecutorscheduler which does not used scheduledaction  
1777,1,0,0,1,0,1,1,0,excluding things from the javadoc for one of the sub issues in #1502exclude rxinternalexclude rxjavaerrorhandlerdefault by deleting it  
1784,1,0,0,0,0,0,1,0,publish with backpressure implementation of `publish` with backpressure:  moves away from using the `multicast` operator and `publishsubject` as per discussion in #1732 and #1779  
1802,1,0,0,1,0,1,1,1,add hasobservers method to subjects (#1772) as per  now keeps track of the actual subjectbufferuntilsubscriber synchronizes on the state guard looks good thanks @simonbasle  ||
1866,1,0,0,1,0,0,1,0,fix memory leak in bounded replaysubject due to retaining the node index indefinitely once the subscriber caught upfor issue #1865 this test failed both times:```rxinternaloperatorsoperatormergedelayerrortest > testerrorinparentobservabledelayed failed    orgmockitoexceptionsverificationtoolittleactualinvocations:     stringobserveronnext("hello")    wanted 2 times:    -> at rxinternaloperatorsoperatormergedelayerrortesttesterrorinparentobservabledelayed(operatormergedelayerrortestjava:516)    but was 1 time:    -> at rxobserverstestobserveronnext(testobserverjava:78)        at rxinternaloperatorsoperatormergedelayerrortesttesterrorinparentobservabledelayed(operatormergedelayerrortestjava:516)```no idea why or if its related but id like to understand before merging this || i dont think mergedelayerror uses replaysubject i dont fully understand the operatormerge but it contains a lot of mutable variables and synchronized blocks and im not sure but i found some anomalies in: synchronizes on the mergeproducers this but reads the mergesubscribers `wip` field which generally is accessed through the mergesubscribers this same seems to be true for the `scalarvaluequeue` || ive tested things locally and its working for me  || i opened an issue to track the issue you brought up regarding `merge`:  || 
1884,1,0,0,0,0,0,1,0,fix scan/reduce/collect factory ambiguity this puts the seed factory on `collect` and removes it from `scan` and `reduce` due to ambiguitysee  and  `collect` api was already very close so this fixes it to use a seed factory so the signature is now:``` javapublic final <r> observable<r> collect(func0<r> statefactory final action2<r ? super t> collector) {```i remove the factory overloads for `scan` and `reduce` due to the issue in #1881 related to generics type erasure and lambdas causing ambiguity and compilation failureswe may want to add at least a `scan` impl in the future with a seed factory but it will need a different name if we do such as `scanto` i dont want to do that now for 10 so well need to revisit that for 11 with more time to think about it this code is now possible:``` java        observablerange(0 10)collect(() -> new arraylist<integer>() (list i) -> {            listadd(i)        })foreach(systemout::println)```this will no longer compile:``` java        observablerange(0 10)scan(() -> new arraylist<integer>() (list i) -> {            listadd(i)            return list        })foreach(systemout::println)     ``` ||
1922,1,0,0,0,0,0,1,0,set removeoncancelpolicy on the threadpool if supported this should solve the task retention problem of unused timeout tasks mentioned in #1919i know java 7+ scheduledthreadpoolexecutor has the `setremoveoncancelpolicy` and i remember seeing it in android although i cant tell from which api versionin java 6 this cant be solved without rewriting the entire scheduler or using a backported executor @akarnokd cool thanks for whipping this up so quickly since rxjava supports java 6 we need to fix that too right? || i looked at the packages of jsr166_ but couldnt find one that ports this flag back to java 6 || @benjchristensen are there plans to "fix" this for java 6 too? since we technically support it or do we mark it as a limitation and people that are hit by this need to go to java 7? im asking because we have lots of users on java 6 and some of the requests have 75s timeouts  || im open to a fix that works for java 6 if someone can suggest what to do and/or submit a pr i personally dont have the time to tackle this anytime soon but would accept the change if it solves the problem without breaking anything else (including performance) for java 7/8  || @benjchristensen okay thanks for the info ill tackle it if customers start to "complain" for now i also think its not as high priority - since technically jdk 6 is eol anyway :) || yes :-) the strongest reason actually that rxjava supports java 6 rather than 7 as the minimum is for android support if it becomes an issue for your customers and you want to tackle this ill happily review discuss and merge  || youd need to backport the java 7 scheduledthreadpoolexecutor and a bunch of helper classes i looked for a backport on doug leas site but no luck || how about calling `scheduledthreadpoolexecutorremove(runnable task)` in `unsubscribe` for java 6? although its a o(n) action while its o(log n) in java 7+ its better than oom || that doesnt work on `submit()` tasks because they are wrapped maybe a better option is to have `purge()` be called periodically || > that doesnt work on submit() tasks because they are wrappedthe returned `scheduledfuture` is exactly the object in the workqueue || 
1973,1,0,0,0,0,1,1,0, test issuing non-serialized messages to the subject should resolve the test failure of #1972 when the main part of the test succeded an oncompleted was sent out from the main thread which was not serialized in respect to the onnext(1) issued from the worker thread therefore two replay was attempted sometimes at first the caughtup was seen false the replay was entered but the next instruction cleared the index causing the illegalstateexception failed in  > testreplaysubjectemissionsubscriptionrace failed    javalangnullpointerexception        at rxsubjectsreplaysubject$boundedstatereplayobserverfromindex(replaysubjectjava:628)        at rxsubjectsreplaysubject$boundedstatereplayobserver(replaysubjectjava:619)        at rxsubjectsreplaysubjectcaughtup(replaysubjectjava:430)        at rxsubjectsreplaysubjectoncompleted(replaysubjectjava:410)        at rxsubjectsreplaysubjectboundedconcurrencytesttestreplaysubjectemissionsubscriptionrace(replaysubjectboundedconcurrencytestjava:399)``` || thanks! forgot about the other test class ||
2465,1,0,0,0,0,1,1,0,scheduledexecutorservice: call purge periodically on jdk 6 to avoid cancelled task-retentionfirst debated in #1922 see also #1919we may want to discuss the naming of system parameters i chose these so rxjava 20 specific properties may be trivially separated:`ioreactivexrxjavaschedulerjdk6purge-frequency-millis`specifies the purge frequency in milliseconds default is 1000`ioreactivexrxjavaschedulerjdk6purge-force`forces the use of the purge (if set to true) even if the setremoveoncancelpolicy is supported the benefit is that removing cancelled tasks now runs on a different thread so the main pool thread doesnt waste time on them the drawback is the retention window can be still to largedo we have a wiki page where such parameters are listed? i did run the unit test by forcing a jdk 6 runtime and seems to work merging to allow progress on schedulers ||
2470,1,0,0,1,0,0,1,0,subject state information methods & bounded replaysubject termination fixthis pr aims to support the requests in #2331 and #1897 by adding methods to the (final) subject classes that let developers access in-flight state in a snapshot fashion this may be considered safe api change because all subject classes were final already so adding extra methods wont break anyones code (and we will be careful with our observable in the future)- `notificationlite` is now extended with two missing value checks: isnull and isnext- each subject has `hascompleted` `hasthrowable` and `getthrowable` methods however i cant add them to `subject` because that would be an incompatible api change- where applicable `getvalue` and `getthrowable` return `null` instead of throwing exceptions so users are encouraged to call hasxxx methods beforehand- there was a chaining bug in the bounded replaysubject: because the terminal value was added after a potential pruning the node links could get broken and concurrent replays might not have seen the terminal value- since `replaysubject` can have multiple values ive added `size()` `hasanyvalue()` (isempty is taken) and `getvalues()` methods to make a snapshot of the current buffer contents whether or not the `replaysubject` has terminated (the usual tolist() would wait until the subject has terminated) - the unrelated `operatormergetesttestconcurrency` hangs for me for some reason without activity (either a buffer bug or a merge bug is in play there) ive added a timeout so it doesnt stop the other tests im merging this: changes are either internal or annotated with experimental on final classes ||
2470,1,0,0,1,0,0,1,0,subject state information methods & bounded replaysubject termination fixthis pr aims to support the requests in #2331 and #1897 by adding methods to the (final) subject classes that let developers access in-flight state in a snapshot fashion this may be considered safe api change because all subject classes were final already so adding extra methods wont break anyones code (and we will be careful with our observable in the future)- `notificationlite` is now extended with two missing value checks: isnull and isnext- each subject has `hascompleted` `hasthrowable` and `getthrowable` methods however i cant add them to `subject` because that would be an incompatible api change- where applicable `getvalue` and `getthrowable` return `null` instead of throwing exceptions so users are encouraged to call hasxxx methods beforehand- there was a chaining bug in the bounded replaysubject: because the terminal value was added after a potential pruning the node links could get broken and concurrent replays might not have seen the terminal value- since `replaysubject` can have multiple values ive added `size()` `hasanyvalue()` (isempty is taken) and `getvalues()` methods to make a snapshot of the current buffer contents whether or not the `replaysubject` has terminated (the usual tolist() would wait until the subject has terminated) - the unrelated `operatormergetesttestconcurrency` hangs for me for some reason without activity (either a buffer bug or a merge bug is in play there) ive added a timeout so it doesnt stop the other tests im merging this: changes are either internal or annotated with experimental on final classes ||
2471,1,0,0,0,0,0,1,0,fixes npes reported in reactivex#1702 by synchronizing queue also adds a unit test for regressionit appears there is a potential race condition if something adds to/removes from the pq while its _inside_ the poll operation which is where the exceptions in #1702 seem to have actually come from therefore the initial null check didnt really address the original problem the test here seems to reliably recreate those conditionsi considered using a priorityblockingqueue instead of synchronized but since the isempty and poll calls should not allow something to interleave between them and access the queue a synchronized block seemed wiser here almost good two things:- since we only use offer/poll you can use the unbounded priorityblockingqueue now- could you move `counter` and `counter_updater` into the `innercurrentthreadscheduler` class both non-static fields? || we are using atomicfieldupdaters to save on the instance cost of `atomicinteger`s could you change the counter to use `atomiclongfieldupdater`? || done on a related but side-note do you know if these field updaters are proguard-safe for obfuscation? they reflect on field name for sure it might be worth looking into the fix would probably be implementing the abstract setters and getters which would obviously be a bit more boilerplate and kinda less fun but might be worth it if it reduces custom proguard rules required to use rx || thanks for the changes looks good to me i dont know about proguard || looks like per the proguard manual it does indeed recognize fieldupdater declarations so this should be fine || wow i did not expect that how uncharacteristically useful of them! good to know for the future ||  the reflection section (no anchor link) that lists the basic reflection methods it automatically detects ||
2493,1,0,0,0,0,0,1,0,operator takeuntil with predicate take values and check the condition after the value is emittedfor enhancement request #1649 thanks for adding this! not convinced on the name though the do prefix is used to represent side-effects everywhere else i think the prefix should still be `take`-something || the question then remains should it stop if predicate turns into false or should it stop if predicate turns into true? because classically `do { } while (true)` and `repeat until false` (pascal) || i like it how its currently implemented  do until trueit fits the "takeuntil" term  "take until a value  predicate java        systemoutprintln(""------------------------"")        observablejust(1 2 3 4 5 6 7)                dooneach(systemout::println)                takeuntil(i -> i  3)                foreach(systemout::println)        systemoutprintln(""------------------------"")        observablejust(1 2 3 4 5 6 7)                dooneach(systemout::println)                takewhile(i -> i < 3)                foreach(systemout::println)```that code shows the difference with `takewhile` and it works well we emit 1 2 3 and then stop```------------------------[rxnotification@891cd479 onnext 1]1[rxnotification@891cd47a onnext 2]2[rxnotification@891cd47b onnext 3]3------------------------[rxnotification@891cd479 onnext 1]1[rxnotification@891cd47a onnext 2]2[rxnotification@891cd47b onnext 3]3[rxnotification@891cd47c onnext 4]``` || "
2548,1,0,1,0,0,1,1,1,subscriberrequest should throw exception if negative request made as per discussion in #1956 and #2545 making a call to `subscriberrequest(n)` with negative n should throw an `illegalargumentexception`includes unit test i think the iae should be mentioned in requests javadoc || javadoc added || great! ||
2548,1,0,1,0,0,1,1,1,subscriberrequest should throw exception if negative request made as per discussion in #1956 and #2545 making a call to `subscriberrequest(n)` with negative n should throw an `illegalargumentexception`includes unit test i think the iae should be mentioned in requests javadoc || javadoc added || great! ||
2550,1,0,1,0,0,1,1,1,subscriberonstart requests should be additive (and check for overflow) as per discussion in #2544 looks good  that looks helpful thanks @davidmoten  ||
2553,1,0,0,0,0,0,1,0,rxringbuffer with synchronization changed rxringbuffer to use synchronized blocks for correctness we are relying here upon biased locking and lock-elision it gets pretty close to the baselinebenchmark:```benchmark              (size)        1x   |    pr#2333  |    this   1syncstreamofn              1  3779678748 | 3767936028 | 37751571951syncstreamofn           1000    21250675 |   18530542 |   207599001syncstreamofn        1000000       20406 |      17712 |      19768nasyncstreamsofn            1   115390116 |  115629480 |  113859532nasyncstreamsofn         1000        2579 |       2546 |       2435nsyncstreamsof1             1  3543551254 | 3602242709 | 3539162675nsyncstreamsof1           100   299166910 |  301703721 |  302642458nsyncstreamsof1          1000    28404751 |   28420833 |   28030881nsyncstreamsofn             1  4054571577 | 4003156953 | 4061124105nsyncstreamsofn          1000       24324 |      20601 |      23137twoasyncstreamsofn          1    85846727 |   85682983 |   86691331twoasyncstreamsofn       1000     1823137 |    1889458 |    1761977reamofnthatmergesin1        1  3724179351 | 3725068220 | 3715637985reamofnthatmergesin1     1000    19051928 |   19392595 |   19487059reamofnthatmergesin1  1000000       18265 |      18069 |      18102```changes (in respect of 1x):- using spscarrayqueue removed look-ahead and null check- using peek to check for emptyness in certain positions- using short-as-possible synchronization blocks here is my perf comparison building on what i did at   1x branch as of jan 22ndpr2333  pr #2333 after rebasing onto 1x (jan 22nd)pr2189  pr #2189 after rebasing onto 1x (jan 22nd)pr2553  pr #2553 on 1x as of jan 28benchmark                                          (size)   mode   samples          1x        pr2189        pr2333       pr2553rooperatormergeperfmerge1syncstreamofn               1  thrpt         5  4879535663   4773501735   4807008476  4701375614rooperatormergeperfmerge1syncstreamofn            1000  thrpt         5    43295567     37341214     34950819    41735196rooperatormergeperfmerge1syncstreamofn         1000000  thrpt         5       41255        40202        32236       36977rooperatormergeperfmergenasyncstreamsofn             1  thrpt         5    99885768    101321745     97689264   100134213rooperatormergeperfmergenasyncstreamsofn          1000  thrpt         5        4846         4715         4973        4552rooperatormergeperfmergensyncstreamsof1              1  thrpt         5  4684222432   4747380010   4751592996  4704340700rooperatormergeperfmergensyncstreamsof1            100  thrpt         5   456736726    468609567    467310110   451615231rooperatormergeperfmergensyncstreamsof1           1000  thrpt         5    40504652     41472463     41146594    41767150rooperatormergeperfmergensyncstreamsofn              1  thrpt         5  4993477475   5268523818   5414652857  5166606822rooperatormergeperfmergensyncstreamsofn           1000  thrpt         5       44460        42820        32926       40496rooperatormergeperfmergetwoasyncstreamsofn           1  thrpt         5    79546448     76853391     73846697    76358122rooperatormergeperfmergetwoasyncstreamsofn        1000  thrpt         5     3138932      3140582      2672720     2283587rooperatormergeperfonestreamofnthatmergesin1         1  thrpt         5  5248113569   5136570967   5225289115  4471499594rooperatormergeperfonestreamofnthatmergesin1      1000  thrpt         5    39001895     39254876     39235506    35812513rooperatormergeperfonestreamofnthatmergesin1   1000000  thrpt         5       35039        35282        33375       33375```the degradations of this are incremental and i think worth the correctnesscrazy to me that we cant find a non-blocking approach that performs better than the jvm doing lock-elisioni suggest we move forward with this after cleaning up the comments in the code that are no longer valid || > i suggest we move forward with this after cleaning up the comments in the code that are no longer validokay if you feel ready you can merge it at your will ill take care of #2541 ||
2585,1,0,0,0,0,0,1,0,operator: switchifempty changes to #2091 thanks @akarnokd for fixing up and merging! ||
2622,1,0,0,0,0,0,1,0,changed observableempty() into a stateless constant observable empty was always stateless so creating a new instance all the time (especially through a `from(iterable)`) is wasteful besides `oncompleted` events dont have to be backpressuredshould enable identity based optimizations discussed in #1653  
2627,1,0,0,0,0,0,1,0,flatmap overloads with maximum concurrency parameter for issue #2626there is no point in adding maxconcurrent to flatmapiterable because each iterable is subscribed to sequentially and run to completion  > there is no point in adding maxconcurrent to flatmapiterable because each iterable is subscribed to sequentially and run to completioni was wrong with this statement depending on the request pattern reordering may still happen and the downstream may be still slower unboundedness of `flatmapiterable` may still cause excessive source iterable generation that fills in the tracking arrays inside `flatmap`having the `maxconcurrency` parameter is valuable and prevents buffer bloat ||
2630,1,0,0,0,0,0,1,0,cast back observer to subscriber if passed to subscribe(observer) rebased #2600  
2648,1,0,1,0,0,0,1,0,takewhile: dont unsubscribe downstream 2647 issue with takewhile  
2759,1,0,0,0,0,0,1,0,observableusing should use unsafesubscribe and enable eager disposal see #2604 where it was discovered that `observableusing` used `subscribe` instead of `unsafesubscribe` which provoked a race condition leading to an illegalargumentexception from the merge operatorthis pr uses `unsafesubscribe` and adds an overload for `using` to optionally dispose of resources eagerly (just before completion or error) the use case for this is a _synchronous_ observable where a downstream operation wants to reuse a resource (but because the observable is synchronous the resource cannot get disposed till the downstream completes)unit tests included thanks @akarnokd ive made the change and squashed commits || replaced tabs with spaces added @experimental annotation to new overload and  typo in javadoc squashed commits || this seems reasonable to me i dont use using so trust the conversation youve had to address the necessary functionality reading through the other pr this does seem necessary and i agree that unsafesubscribe is appropriate for this  ||
2762,1,0,0,0,0,0,1,0,optimized isunsubscribed check extracted isunsubscribed optimization from #2603```benchmark                                   (size)   mode   samples          1x        2603    rscomputationschedulerperfobserveon           1  thrpt         5   104110926  104707286rscomputationschedulerperfobserveon          10  thrpt         5   100723402  105825148rscomputationschedulerperfobserveon         100  thrpt         5    24609763   65571461rscomputationschedulerperfobserveon        1000  thrpt         5     3212434   13020027rscomputationschedulerperfobserveon       10000  thrpt         5      955002    1555493  rscomputationschedulerperfobserveon      100000  thrpt         5       96628     160218  rscomputationschedulerperfobserveon     1000000  thrpt         5        9508      16559  rscomputationschedulerperfsubscribeon         1  thrpt         5   114212000  114485516  rscomputationschedulerperfsubscribeon        10  thrpt         5   112376809  112270024  rscomputationschedulerperfsubscribeon       100  thrpt         5    88433002  104240739  rscomputationschedulerperfsubscribeon      1000  thrpt         5    31503640   64446984  rscomputationschedulerperfsubscribeon     10000  thrpt         5     3932988    8200048rscomputationschedulerperfsubscribeon    100000  thrpt         5      437626    1439069rscomputationschedulerperfsubscribeon   1000000  thrpt         5       43104     146385``` nice improvement  ||
2767,1,0,0,0,0,0,1,0,optimized scalar observeon/subscribeon redone #2603run on i7 920 26ghz windows 7 x64 jdk 18u31```benchmark      (size)       this   score error       1x   score errorobserveon           1  160377408     3091205  140913081     7097415observeon          10  132990049     1477661  125288149    14304259observeon         100   43701203     2342570   43840921      944682observeon        1000   11603952     2377205   11400340     1400628observeon        2000    6769716      220476    6853283       71276observeon        3000    4753876      326497    4741108      120612observeon        4000    3616782      212285    3632433      433754observeon       10000    1544141       28796    1548504       61419observeon      100000     149573       14974     150924        8331observeon     1000000      14909        2079      13658        7702subscribeon         1  160639801    16463799  156911862     2463637subscribeon        10  148883172     6885684  151514397     9425348subscribeon       100  133756358     3329421  133327933     3479124subscribeon      1000   56411785    22525962   52902999    19948305subscribeon      2000   35471110    12240514   34272374    16515454subscribeon      3000   25868564     2755244   26291293     2435165subscribeon      4000   20453512     2996777   19598400     4643195subscribeon     10000    8817797      465195    5389428      272784subscribeon    100000     958665       22157     900036      320547subscribeon   1000000      91606        2462      91396        3407```note that since the tests create a lot of garbage some perf numbers have quite some error margin: some appear to be faster with this pr while others appear to be slower even if they are not affected by the changes am i reading it correctly that this should really only benefit this case? >```benchmark      (size)       this   score error       1x   score errorobserveon           1  160377408     3091205  140913081     7097415``` || yes it optimizes for the scalar observing of a value i assume this is a common enough case to warrant an optimized code path || this is exactly the case i need :) || code looks good all internal changes thanks @akarnokd  ||
2804,1,0,0,0,0,0,1,0,observeon throughput enhancements squashed commits of #2773---further optimizations to `observeon`- using spscarrayqueue directly in observeon instead of `ringbuffer` to avoid the synchronization block- split tracking structure to serial (subscriptionlist) and timed (compositesubscription) in `eventloopsscheduler` which improves the sequential scheduling performance because a completing tasks subscription will be most likely the first item in the underlying linkedlistbenchmark: (i7 920 window 7 x64 java 18u31 5x1s warmup 5x5s iteration)```benchmark      (size)         1x    1x error      this pr   this errorobserveon           1  162326012     2458085   166536559     3154174observeon          10  132471205     1857434   142517407     3734424 ++observeon         100   43282527     2145910   112238179     2270103 ++observeon        1000   11779482      173370    25726564      309193 ++observeon        2000    6756211       89196    12123276      276470 ++observeon        3000    4736893      253796     9342673      263667 ++observeon        4000    3661874       51359     7346015      123049 ++observeon       10000    1519282      108503     1546547       21885observeon      100000     151193        2569      156160        1974observeon     1000000      15373        1310       15660        0153subscribeon         1  161290037     2867882   164952259      797408subscribeon        10  151842821     2448734   147906491     4373682subscribeon       100  136418065     1773558   136889052     2362203subscribeon      1000   58389066     4559030    59482225     1372692subscribeon      2000   34089152     9318205    36581203     1264100subscribeon      3000   26712331     1265442    26519320     1319293subscribeon      4000   20118326     2018439    20163395      839709subscribeon     10000    8914213      677164     9059934      200158subscribeon    100000     958038       43349      965663       60708subscribeon   1000000      91849        2148       92706        1202```notes:- at `size  1` the throughput varies in a +/- 3000 range on each run and since the changes dont touch the scalar optimization there is no real improvement there- at `size  10000` my system reached either the cache capacity or the os schedulers time resolution so there no improvement there on- at `size  100000` and `size  1000000` the throughput doubles if i introduce some extra delay (ie via sleep(1) or some extra work)- the benchmark generates a lot of garbage due to boxing: switching to a constant emitter increases the throughput `subscribeon(1000000)` from 91 to 136 since it conflicts with #2772 anyway this is pr is to let others verify the optimizations actually work on other oses because on my windows i sometimes get significant variance in the throughput during iterations increased iteration time may be required as well  
2804,1,0,0,0,0,0,1,0,observeon throughput enhancements squashed commits of #2773---further optimizations to `observeon`- using spscarrayqueue directly in observeon instead of `ringbuffer` to avoid the synchronization block- split tracking structure to serial (subscriptionlist) and timed (compositesubscription) in `eventloopsscheduler` which improves the sequential scheduling performance because a completing tasks subscription will be most likely the first item in the underlying linkedlistbenchmark: (i7 920 window 7 x64 java 18u31 5x1s warmup 5x5s iteration)```benchmark      (size)         1x    1x error      this pr   this errorobserveon           1  162326012     2458085   166536559     3154174observeon          10  132471205     1857434   142517407     3734424 ++observeon         100   43282527     2145910   112238179     2270103 ++observeon        1000   11779482      173370    25726564      309193 ++observeon        2000    6756211       89196    12123276      276470 ++observeon        3000    4736893      253796     9342673      263667 ++observeon        4000    3661874       51359     7346015      123049 ++observeon       10000    1519282      108503     1546547       21885observeon      100000     151193        2569      156160        1974observeon     1000000      15373        1310       15660        0153subscribeon         1  161290037     2867882   164952259      797408subscribeon        10  151842821     2448734   147906491     4373682subscribeon       100  136418065     1773558   136889052     2362203subscribeon      1000   58389066     4559030    59482225     1372692subscribeon      2000   34089152     9318205    36581203     1264100subscribeon      3000   26712331     1265442    26519320     1319293subscribeon      4000   20118326     2018439    20163395      839709subscribeon     10000    8914213      677164     9059934      200158subscribeon    100000     958038       43349      965663       60708subscribeon   1000000      91849        2148       92706        1202```notes:- at `size  1` the throughput varies in a +/- 3000 range on each run and since the changes dont touch the scalar optimization there is no real improvement there- at `size  10000` my system reached either the cache capacity or the os schedulers time resolution so there no improvement there on- at `size  100000` and `size  1000000` the throughput doubles if i introduce some extra delay (ie via sleep(1) or some extra work)- the benchmark generates a lot of garbage due to boxing: switching to a constant emitter increases the throughput `subscribeon(1000000)` from 91 to 136 since it conflicts with #2772 anyway this is pr is to let others verify the optimizations actually work on other oses because on my windows i sometimes get significant variance in the throughput during iterations increased iteration time may be required as well  
2883,1,0,0,1,0,1,1,0,proposal: standardized subject state-peeking methods this pr modifies the `subject` class to host the union of the state-peeking methods of the various `subject` implementations and fixes the inconsistent behavior of `replaysubjectgetvalues(t)`the changes enable the `serializedsubject` to relay such state-peeking method calls into the wrapped subject and allows future `subject` wrappers to do the same (#2458) seems to make sense the additions to `subject` all should be non-breaking || due to the experimental marking of these im being a little less stringent in discussing the addition to public apis but it seems to me that the precedent set on the behaviorsubject shows the value of these methods additionally subjects are the stateful side-effecting types and these methods seem to make sense for them ||
2969,1,0,0,0,0,0,1,0,operator cache() now supports backpressure ive removed the controversial features and made the backing cachedobservable internalrelated issue #1483 does it really need to be returning a new type of observable?  it seems the methods `isconnected()` `hasobservers()` and `cachedeventcount()` are only used by the unit tests || yes otherwise one would need ugly reflection magic to get inside the state of this observable || i checked out the branch and took a shot at making it an onsubscribe function again || cache had originally more functionality ie the ability to terminate it manually like a disconnect but was downwoted i forgot about the `tocached()` methods which are just relics and ill update this protherwise i dont really see why i shouldnt extend observable especially if one day there will be a real need to support disconnection of cache() || ive rebased it and im going to merge this if there has concern about it being implemented as a observable a pr can always be submitted with the suggested changes ||
2970,1,0,0,0,0,0,1,0,deprecated onbackpressureblock see #2799 for reasons to deprecate  
2972,1,0,0,0,0,0,1,0, window(time) to work properly with unsubscription added backpressure support to window(size skip)see #1880  
2983,1,0,0,0,0,0,1,0, multiple calls to onstart started investigating multiple calls to onstart based on #2979 and found a bunch but since onstart can be overridden i might have missed cases in addition ive found a single place where a producer is set twice on a subscriber but again many other places may exist (i know that is easy to complain  ) this decorator strategy is not very memory friendly you have this annoying (gwt compatibility perspective) atomicxxxfieldupdater in a lot of places to reduce memory usage and you end up adding this decorators to only disable one method callwhat do you think? thanks to solve the problem anyway   || yikes! theres a lot of stuffed up backpressure  here im hoping we can release soon ||
3048,1,0,0,0,0,1,1,0,compositeexception extra npe protection `compositeexception` wont crash if it received null by some means a `null` collection or `null` collection item is replaced by a `nullpointerexception` instancesee also: #3046  
3049,1,0,0,0,0,0,1,0,single: add tosingle method to observable - closes reactivex/rxjava#3038- this method allows an observable which is guaranteed to return exactly one  item to be converted to a single- note: the semantics of this function are very similar to that of single- ie errors are passed through more than one item results in an  illegalargumentexception completion without emission results in a  nosuchelementexception and exactly one item is passed through the onsuccess  method of singlesubscriber would appreciate feedback since this is my first contribution to rxjava! :) || yes || looks good can you add the license headers to the files please? the block of code to add is shown here:  || have done so || would you mind rebasing to a single commit? || also done :) || thank you @tilal6991 for the contribution and responsiveness on changes || glad to contributeim planning to look into more tricky issues soon so hopefully this is not the last youll see of me :) ||
3081,1,0,0,0,0,0,1,0,revert of cache/replay #3076 i did revert commit of the pr that added back pressure support to the cache operator and ran a canary  our production systems seem stable now even with the new merge thats good news not sure what time @akarnokd has for reviewing `cache` backpressure work if we cant fix this short term would be nice too see a fix for #3026 go in 1013 if backpressure doesnt make it quick summary is in 1012 `cache` emits nothing until source has completed  || can you create an unit test based on the usage pattern? it would be also interesting to verify `replay()autoconnect()` since it ought to be functionally equivalent to `cache()` || i have no clue at the moment what the actual code path is causing the lockup itll take awhile for me to instrument code to narrow which usage pattern is causing the problem  || i believe the issue were seeing comes from use of `cache()` in hystrix:  use hystrix at very high volume and `cache()` will be used by a large percentage of those calls this explains why this impacted our canary so significantly || ive reverted both the cache and revert related commits  the tests and the canary seem to do fine so far ||
3118,1,0,1,0,0,0,1,0,implementing the synconsubscribe this is useful for creating an observable that reads from a data source in a synchronous manner this is a rewrite of the `abstractonsubscribe` experimental class based on the ideas in #3003 you cant delete `abstractonsubscribe` because it is part of the public api and even though marked as experimental such components can be deleted only at a major release such as 11 || experimental apis can be removed or change at any time as per the readme:> @experimental> > apis marked with the @experimental annotation at the class or method level will almost certainly change they can be modified in any way or even removed at any time you should not use or rely on them in any production code they are purely to allow broad testing and feedback || i would have expected to make such apis @deprecated for a few releases before completely removing it besides this pr just gives an alternative to another @experimental class and could live side-by-side then users could decide/vote which to keep at the next major release || @akarnokd you have a good point that the efficacy of both implementations should be compared however i do not think that we should expose multiple alternatives in the public api this ambiguous api leads to confusion and questions about the unexplained differences between one or the other implementation the pull request should not be the place for debate either (since this should be about issues with this implementation) this comparison and debate was what i was hoping to get out of opening issue #3003 would you like to open a separate issue for comparing the 2 implementations? || the latest commit adds work stealing to manage unsubscribe to avoid concurrent modification of `state` while running `onunsubscribe` concurrently with `next` (and a test to exercise) fixes issues with tabs/spaces and adds javadocs || the latest commit makes a few changes - added the `abstractonsubscribe` back into the code base the `@experimental` annotation states clearly that either of these implementations can be removed at any time so its not necessary for anything to be removed now it is up to the consumer when they chose to use a potentially unstable api - added jmh tests to compare performance against `onsubscribefromiterable` the performance is impacted in astounding ways by the additional complexity of a cleanup function this requires object initialization which the `onsubscribefromiterable` does not require - general optimizations removing a volatile and reorganizing the request loop  || @stealthcode can you give us more detail on the jmh comparison? || sure sorry for leaving that out heres the jmh report output```$ /gradlew clean benchmarks -pjmh-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 1 *synconsubscribeperf*``````benchmark                                            (size)   mode   samples        score  score error    unitsrosynconsubscribeperfbenchabstractonsubscribe          1  thrpt         5 10345304158   167899030    ops/srosynconsubscribeperfbenchabstractonsubscribe2         1  thrpt         5 10315525503   519004209    ops/srosynconsubscribeperfbenchabstractonsubscribe2      1000  thrpt         5 10080651937  1249022786    ops/srosynconsubscribeperfbenchabstractonsubscribe2   1000000  thrpt         5  9676927741   799435391    ops/srosynconsubscribeperfbenchfromiterable                 1  thrpt         5 245301608512 25693364239    ops/srosynconsubscribeperfbenchfromiterable2                1  thrpt         5 261726979345 17122836564    ops/srosynconsubscribeperfbenchfromiterable2             1000  thrpt         5 256818323006 17992719065    ops/srosynconsubscribeperfbenchfromiterable2          1000000  thrpt         5 259483656124 12863102025    ops/srosynconsubscribeperfbenchsynconsubscribe              1  thrpt         5 12770780794   146195400    ops/srosynconsubscribeperfbenchsynconsubscribe2             1  thrpt         5 12306631098  2072808101    ops/srosynconsubscribeperfbenchsynconsubscribe2          1000  thrpt         5 12326658468   682619251    ops/srosynconsubscribeperfbenchsynconsubscribe2       1000000  thrpt         5 12519473508   365884932    ops/s```under flight recorder analysis both the aos and sos suffer from the cost of creating a `subscriptionlist` and allocating memory where as a the `onsubscribefromiterable` does not require adding an unsubscribe action so doesnt need to allocate i plan on testing some changes to get around this bottle neck will submit a pull request soon hopefully this upcoming change will be a private change and not have to wait until 2x || here are the updated benchmarks this paints a very different picture than last time the performance of the `synconsubscribe` is now ~  observables in ways that obviate the need to merge at all are there use cases that i am missing?that said i would rather not corrupt the api with a one-off concept of `stop()` without good reason its important that we get the api correct (even in `@experimental`)  || javadoc is now updated || :+1: reviewed the code 
3121,1,0,0,0,0,0,1,0,improve performance of newthreadworker disable search for setremoveoncancelpolicy() on android api < 21 3119this pr adds methods for detecting android api version and disables `newthreadworkertryenablecancelpolicy()` on android api < 21 which has significant performance cost on androidpr also improves performance of `newthreadworkertryenablecancelpolicy()` via caching reflection checked on jvm (java 8) android 412 (api 16) android 511 (api 22) ||  all comments removed test with reflection added more javadoc and comments tests are now compilable on jdk 6 (didnt check but they should work fine) @akarnokd @jakewharton ptal  || great 
3129,1,0,0,0,0,0,1,0,fix retry with predicate ignoring backpressure apparently we forgot about this operator the backpressure handling is a trivial case with `producerarbiter` ive also  some apparent code indentation errororiginally reported in #3128 with a test case which i didnt include due to its lengthy nature however i did run the test manually and both passed after the fix  
3147,1,0,0,0,0,0,1,0,remove unnecessary static modifier ps @benjchristensen @akarnokd sorry for large amount of simple pull requests im doing full code review of rxjava sources  and ill create prs and issues during this reviewill try to group changes by themes so it will be easy to review them looks like this adventure is going to be part of #3145! if it were only me id accept cosmetic changes such as this but history tells me not to  || @akarnokd why? sad that `javac` is not strict enough and allows such things we can add `checkstyle` with only java-lang rules and remove all these things from the code but last time i suggested to add `checkstyle` @benjchristensen was not very happy…i understand that rxjava is not "my project" and i cant just come and force you to use "my codestyle" (which is actually just standard java codestyle) so if you dont want to accept such changes — its okay ill stop doing such prs and will report only major issues || i like this pr too much im going to merge it ) || > i like this pr too much im going to merge it ):-) || 
3149,1,0,0,0,0,1,1,0,scheduler shutdown capability repost of #3022 we still need to decide on the reset vs shutdown distinction:  is your perspective? do you have a strong opinion one way or another? || with start/shutdown there is a clear intention to stop everybody with reset any running code could respawn the threads and the new threads will resume leaking i prefer start/shutdown || agree it will be great to have ability to stop schedulers and prevent new workers from scheduling for apps that run in servlets and other similar containers which can be stopped externally || im happy with the start/shutdown pair which seems to support my primary use cases:- resource release on webapp shutdown in container- resource release on completion of programs run by a framework that looked for unreleased threads (maven)- on ad-hoc basis ensuring schedulers are not running in the background on entry into a unit test (when running a suite)thanks @akarnokd! || the `start`/`shutdown` semantic looks good to me more explicit best enforcement of shutdown   and good compatibility with items mentioned by @davidmoten (which are pretty much our use cases as well)    || ill following this thread to be notified when its merged thanks @akarnokd  || @benjchristensen do you consider we have consensus on naming? after that itd be showtime     ||   because so many customers from us run into this || @daschl   i would like a bit more context on what the goal is for the scheduler shutdown capability @davidmoten and any others please respond thanks > resource release on webapp shutdown in containerwhat resources exactly need to be freed? shutting down the schedulers would prevent new workers from being scheduled and would free up threads from the executor is this the desired behavior or is there some side effect that you are looking for?> resource release on completion of programs run by a framework that looked for unreleased threads (maven)could anyone name a framework thats impacted? is the concern that open threads keep the framework from properly terminating?> on ad-hoc basis ensuring schedulers are not running in the background on entry into a unit test (when running a suite)would the `testscheduler` solve this problem for you? this doesnt rely on singleton values and can be used to precisely test scheduling behavior  || @stealthcode i can answer the question 2 i hope it help you could anyone name a framework thats impacted? is the concern that open threads keep the framework from properly terminating?- couchbase java sdkcb sdk are not able to finish some of they own threads because it is referring rxcomputationthreadpool threads who cant be finishedyou can see more details about how this issue are affecting this framework here || @stealthcode i can give you the answer to your questions tooid like to use rxjava in the container (eg id like to use jersey rx client on tomcat) unfortunately it is impossible to shutdown _rxcomputationthreadpool-*_ threads and container has memory leaks that causes that rxjava is inapplicable for my purposes :( and in my case - regarding question 1 - yes shutting down all schedulers permanently is a desired behaviour and testscheduler is not a solution so im really looking forward to seeing this pr accepted and released! || @mjakubowski84 :+1:  similar case here || @mjakubowski84 understood regarding the testscheduler - this is meant for use in tests and highly recommended when it comes to a container you would definitely want to use a real scheduler so what i hear is that there is no desire to resume the scheduler once it is shut down my concern is that by offering a `schedulerlifecyclestart()` method we are inviting non-deterministic behavior in the case that someone wants to use this to teardown and then resume (in integration tests for example) would it be acceptable to remove the `start()` method from the public interface and rename `shutdown()` to `teardown()` to more accurately describe the intent? || i dont have strong opinion between shutdown/teardown`teardown` makes the intent clearer but `shutdown` is more idiomatic (in the context of java executor)otherwise the code lgtm  another thing if we want to be more java idiomatic maybe hiding the `start()` is the right thing to doit will also have the benefit of avoiding bug by misusage of the library (calling `start()` after a `shutdown()`) || i can make `schedulersstart()` package private so the tests can use it but i the `scheduler` implementations have to keep their start public || please do i believe that would be better || done || @akarnokd @stevegury folks do you think its possible to get this into 1015? || @akarnokd thanks  || i think this is fine  do you guys have a plan date to merge it? || @akarnokd i think its appropriate that you merge this pr since you are most familiar with this code if you think you are happy with it then feel free  || oh sorry didnt recount the number of likes merging || where can i get the latest build with this fix? maven central is still at 1014 || @chiangh123 you can clone the project and build it from master good luck :) || `rxjava` uses bintray for binaries and also publishes snapshots in jfrogs oss artifactory so you can add the following repository to your `pomxml`:``` xml<repository>  <snapshots />  <id>snapshots</id>  <name>libs-snapshot</name>  <url> that you should be able to depend on rxjava `1015-snapshot` ||
3150,1,0,0,0,0,1,1,0,window operators now support backpressure in the inner observable repost of #3050 do we need to maintain both bufferuntilsubscriber v1 and v2 at the same time? || `bufferuntilsubscriber` does some black backpressure magic inside groupby which i wasnt able to figure out and the v2 doesnt pass unit tests with it || it seems like `bufferuntilsubscriber` is being used as a special case buffer for `operatorgroupby` while `bufferuntilsubscriberv2` is custom for the windowing operators if they cannot be reconciled to work for both cases then could you please move them into the operators as static nested classes?also since groupbys back pressure is being patched maybe itd be a good idea to revisit this pull request with those changes to try to combine the two `bufferuntilsubscriber`s  || these are internal classes and can live in their own files the groupby in #3428 no longer uses it and once merged this `bufferuntilsubscriberv2` can be renamed or better yet promoted to a standard api `unicastsubject`i dont think we should be so eager to combine things such combinations end up in monstrous classes which are then sources of misunderstanding and complexity || `bufferuntilsubscriber` was a proposed as a solution to the time gap problem in group by so because `bufferuntilsubscriberv2` doesnt work to solve this problem for group by leads me to question its naming is it built to handle the same problem or a different problem? are you proposing to rename v2 to `unicastsubject`?  || > i dont think we should be so eager to combine things such combinations end up in monstrous classes which are then sources of misunderstanding and complexityim proposing to hide away internal functionality from the public api  || neither of these are public api since they reside in the internal package hiding them further away seems to be unnecessary in addition `bufferuntilsubscriberv2` is effectively turned into the official `unicastsubject` in 2xhistorically `bufferuntilsubscriber` started out to solve the time-gap problem for the non-backpressured `groupby` and `window` when the backpressure was introduced `groupby` had to support backpressure but `bufferuntilsubscriber` wasnt enhanced instead `bufferuntilsubscriber` is used as a middle man and the subscription process is hijacked to inject a producer that attempts to coordinate requests apparently this didnt cover all request pattern hence the original bug due to this very specific hijacking adding backpressure to `bufferuntilsubscriber` directly didnt work out as it conflicted with the request coordination in a way i couldnt resolve therefore i decided to have a separate class that does backpressure but doesnt have to be involved in request coordination for `window` (which i believe cant be established with a reasonable strategy) || all im asking for is a rename from v2 in 1x || maybe i missed it but whats the name youd like? || ive renamed the class to `unicastsubject` and combined the `state` with the `onsubscribebus` class || im going to sleep now (its midnight here) so if you only have concerns about naming location and visibility i suggest merging this pr then posting a separate pr with your changes (and merge it if you can get somebody else to like it in the meantime) || @akarnokd would you mind rebasing this? || done || 
3155,1,0,0,0,0,1,1,1,safesubscriber - report oncompleted unsubscribe error to rxjavaplugin discussed in #2464 when an observable emits `oncompleted` but `unsubscribe` in `safesubscriber` throws then the error should be reported to the `rxjavaplugin` error handler and if that fails a stack trace is written to `systemerr` there are a lot of repeated try catch blocks calling the rxjavaplugins error handler so ive made a `rxjavapluginutils` class it will also be called from the `using` fix which i will submit once this pr has been accepted || one of the tests fails || im going to ponder the issue of throwing after reporting to the error handler a bit || ive been looking for a bit of guidance about what to do when `unsubscribe` throws in `safesubscriber` _rx design guidelines_ doesnt really cover it _reactive-streams-jvm_ does touch upon it saying:> 315 calling subscriptioncancel must return normally the only legal way to signal failure to a subscriber is via the onerror methodi think given that the contract has been breached it is fair to throw an exception and i think a new wrapper `unsubscribefailureexception` would be appropriateid also like to address the case when `oncompleted` throws _reactive-streams-jvm_ has this to say:> 213 calling onsubscribe onnext onerror or oncomplete must return normally except when any provided parameter is null in which case it must throw a javalangnullpointerexception to the caller for all other situations the only legal way for a subscriber to signal failure is by cancelling its subscription in the case that this rule is violated any associated subscription to the subscriber must be considered as cancelled and the caller must raise this error condition in a fashion that is adequate for the runtime environmentso in the existing code if in `safesubscriber` an `onerror` call to the downstream subscriber throws then the rxjavaplugin error handler is called _and_ an `onerrorfailedexception` is thrown comments in the method say this is ok because the contract has been broken and this is probably consistent with the advice in 313:> and the caller must raise this error condition in a fashion that is adequate for the runtime environmentin the existing code if in `safesubscriber` an `oncompleted` call to the downstream subscriber throws then the consequent call to `_onerror` tries to signal `onerror` to the downstream subscriber  im worried that calling `onerror` after calling `oncompleted` is a strong enough breach of the contract that the possible side effects could be worse than just a throw shouldnt we throw only (and notify the plugin error handler of course)? || ive submitted code that matches my thinking above it still fails because i havent amended the existing unit tests associated with throwing ill do that after another round of review if accepted || the failing test is a coverage test for a behavior no longer present i suggest removing it and rerunning the jacoco to see if all current code path is covered || @akarnokd yep thats right are you happy that a throwing `oncompleted()` call should not induce an `onerror()` call? if so ill clean up and update the pr || ive  the unit tests and added more so that `safesubscriber` gets 100% coverage || :+1: looks good to mesince this adds public api classes it requires further approval (otherwise it shouldnt affect programs other than those that badly fail therefore the merge policy would allow me to merge it) || lgtm it would be better if you can fix the indent :+1: for unsubscribefailureexception its a pity that we cannot change `onerrorfailedexception`s that should have been `unsubscribefailureexception` now since its a break change || thanks for review @akarnokd  and @zsxwing ive fixed indent in test and squashed commits || great 
3169,1,0,1,0,0,0,1,0,merge can now operate in horizontally unbounded mode 3156 note that since the default merge operation is unbounded this change could lead to an excessive memory usage when flatmapping fast sources note that the pre 1013 version did this albeit on a slighty slower paththe change also affects the scalar optimization as well pre 1013 implicitly limited the concurrency level to rxringbuffersize when scalars were received this version now fills the queue up to the concurrency levelfor 20 i suggest having a bounded behavior by default and require the developer to specify integermax_value to go for the unbounded behavior so he/she knows about the consequences ill have to allocate some time to review this later as it is somewhat detailed thank you for tackling this || > pre 1013 implicitly limited the concurrency level to rxringbuffersize when scalars were receivedthat was done by design since scalars behave as `onnext` and we can limit the number of `observable`s being merged if we have scalars queued up for deliverythe reason we cant limit the number of async `observable`s is because we dont know if they will emit or not and thus risk deadlock ||  ill rebase this || rebased lets get this finally in || 
3286,1,0,0,0,0,1,1,1,1x: implements blockingsingle adds blockingsingle (issue #3252) the blocking version of rxsingleblockingsingle has the following methods:- `from(single)` -- factory method for creating a `blockingsingle` from a  `single`- `value()` -- returns the value emitted from the single- `tofuture()` -- returns a `javautilconcurrentfuture`couldnt actually think of any other useful operations to perform on `blockingsingle` - in comparison to `blockingobservable` theres not much to this class (at the moment) ~~hmmmgot a test failure that i cant reproduce locally:~~ ( by #3285)```rxobservablessynconsubscribetest > testsubscribeon failed    javalangassertionerror: expected:<4> but was:<3>        at orgjunitassertfail(assertjava:93)        at orgjunitassertfailnotequals(assertjava:647)        at orgjunitassertassertequals(assertjava:128)        at orgjunitassertassertequals(assertjava:472)        at orgjunitassertassertequals(assertjava:456)        at rxobservablessynconsubscribetesttestsubscribeon(synconsubscribetestjava:734``` || this test failure should be resolved now  || @hyleung is this ready to be reviewed/merged? || @abersnaze not quite yet there are a couple of things from @artem-zinnatullins pr (#3416) that i want to pull in (splitting out a separate `blockingutils` class to hold `awaitcomplete` for example) also im going to rebase it against head of 1x since its been about a month || @abersnaze the pr is ready for review btw ill keep the commits separate as i incorporate the feedback and squash it down at the end || maybe move `blockingsingle` from `rxobservables` to `rxsingles`? || @artem-zinnatullin re `rxsingles` - that would be a new package then? ~~dont have a particular option either way tbh - anybody else?~~ ah i see what youre getting atmoved to `rxsingles` which other operators are you thinking of adding to `single` btw? || lgtm just a few nits left  im ready to merge this as long as we can add the necessary `@experimental` annotations and rebase onto 1x || @stealthcode done!  ||  :+1:thanks for contributing ||
3352,1,0,1,0,0,0,1,0,2x: perf checks for flatmap and merge ported the two perf tests to evaluate 2x throughput( primary suspect for the extra overhead are the atomics of queue-drain the 1x uses a synchronized-based emitter-loop which is elided by the jit compiler but atomics cant be elided as i mentioned before synchronized works better for light-to-none asynchronous use whereas atomics work better for asynchronous usealso quote from #3157> exceptions that do not require a :+1: would be:> > javadoc changes> unit test additions or refactoring> **perf test additions fixes or refactoring**> grammatical and presentation fixes to readme contributing and other such metadata files  
3357,1,0,0,0,0,0,1,0,eager concatmap related discussion in #3017 thanks a lot for contributing this one @akarnokd ive had one look through and no problems jump out at me but i will review further this will be useful || thanks for the review @davidmoten  usually i use one letter variables because i find it easier to parse the code and instead of long variable names i use newlines to separate logical blocks this way i dont have to type that many letters and i dont have to wait while eclipse returns with the content assist (which is blocking by the way and may take hundreds of milliseconds even on my i7 + ssd)i took the time and renamed variables as you asked for and added some more unit tests that check the code paths that being said i dont plan to do such renames in my contributions very often in the future and encourage anybody to post their prs with their proposed cleanups/renames || thanks for the feedback ive updated the method names to `concatmapeager` and `concateager` added the `@experimental` tags some javadoc and a missing test for a 2-parameter `concateager` overload || updated with a capacity fix for the `spsclinkedarrayqueue` || i reviewed in details in the code and i believe it is correctbut i wonder if subscribing to the sources in a "unbounded mode" is the right thing to doat the expense of complexifying the code i believe it could be possible to split the `request(n)` between the sources maybe requesting `1` to all the `m` sources expect the first one which we request `n - m + 1`  and so onthe devil is in the details and i believe this would significantly complexify the code but i would like to know what you are thinking about this? || @stevegury this operator consumes source observables in order and doesnt make sense to split any request from downstream if the downstream requests n and the first is requested n / count that would hang the sequence because only the first is allowed to emit and it wont emit enough to trigger a new requestit is possible to use a bounded buffer per source so while they are not consumed they dont grow indefinitely however it means that each of them can produce only `rxringbuffersize` elements before stopping and thus the operator wouldnt be eager anymore || @akarnokd sorry i wasnt very clear but what i proposed was roughly what you described (replacing `rxringbuffersize`  1`)my main concern here is the use of unbounded buffer which i think could be avoided || @davidmoten what do you think about the bounded buffering and the fact that such sources would act more like a delayed source? || id be happy to see bounded buffering (`rxringbuffersize` sounds a better default size than 1 to me and would be consistent with the request eagerness of other operators like `merge` for instance) could we add an overload to allow the specification of buffer size as well?if this is significant rework im content to see this unbounded version documented with its buffering characteristics merged and we can defer the bounding work to another pr || done || great thanks @akarnokd ! lightning quick as always || lgtm  the three of you seem happy with it so im merging it || 
3382,1,0,0,0,0,0,1,0,2x: fix spsclinkedarrayqueue leaves 1 slot null just before growing discovered while debugging #3381 confirmed with jctools in https://githubcom/jctools/jctools/pull/80  
3417,1,0,0,0,0,1,1,1,add singledoonsuccess() closes #3385  @artem-zinnatullin rebase please || @abersnaze rebased! ||
3444,1,0,0,0,0,1,1,1,1x: completable class to support valueless event composition + tests this is a backport of #3439 looks good should we annotate `@experimental` on all the public methods and operators?  || now the class annotation should indicate all methods are experimental if individual methods get promoted we can add direct annotations then || sounds good :+1:on sat dec 5 2015 01:38 david karnok notifications@githubcom wrote:> now the class annotation should indicate all methods are experimental if> individual methods get promoted we can add direct annotations then> > —> reply to this email directly or view it on github>  || since this adds to the api surface id like to get another like before merging ||  awesome 
3447,1,0,0,0,0,0,1,0,1x: delaysubscription with a plain other observable requested in #3445this is an efficient implementation as it avoids allocating the lifter object doesnt require a function wrapper and doesnt use producer arbitration(bonus points to those who can recognize the similarities with #3446) any thoughts about this? ||  
3447,1,0,0,0,0,0,1,0,1x: delaysubscription with a plain other observable requested in #3445this is an efficient implementation as it avoids allocating the lifter object doesnt require a function wrapper and doesnt use producer arbitration(bonus points to those who can recognize the similarities with #3446) any thoughts about this? ||  
3467,1,0,0,0,0,1,1,0,1x: compensation for significant clock drifts in scheduleperiodically there is a problem reported in #3461 and #2943 in which if the system clock drifts the periodic calculation inside schedulerworker gets off and either taking a longer time for the next invocation of the task or doing "catching-up" with all the lost invocationsthe solution checks the wall clock difference between the last run and the current run and if it went back or forward significantly it rebases the timer period and schedules the next execution relative to nowif the clock goes back the original code scheduled the next invocation way into the future this pr will schedule it after the periodif the clock goes forward the original code scheduled executions for all the missed time between the last run and the new time immediately yielding a bunch of 0 delays this pr will simply schedule the next invocation after the periodthe algorithm for both cases is the same: make sure the next invocation is scheduled relative to now and recalculate the start timestamp as if the whole sequence run under the new drifted clock all along the subsequent invocations will be scheduled at a  rate againive added the system parameter `rxschedulerdrift-tolerance` (unit: minutes default: 15 minutes) which is used to determine if the clock drifted too far between invocations of the periodic task time drift is pretty nasty we spent a lot of time on this in rxnet  || ive updated the code with the suggestion of @stealthcode  || :+1:  do you need additional changes? if not feel free to merge this pr ||  yay! this was important issueso i did test (similar to #3530):``` javaobservable  interval(5 10 seconds)  subscribe(along -> loggerd("interval: %d" along))```and then changed system clock to +2 hours at runtime of the app**before fix**as expected computation scheduler gone crazy and fired about 700 events during one second<img width"1160" alt"screen shot 2015-12-15 at 08 44 57" src" width"944" alt"screen shot 2015-12-15 at 08 43 54" src" fix**everything was just fine! no incorrect events no cpu consuming<img width"1165" alt"screen shot 2015-12-15 at 09 01 06" src" width"1006" alt"screen shot 2015-12-15 at 09 00 42" src" i think #3461 and #3530 can be closed now!thanks @akarnokd! || 
3467,1,0,0,0,0,1,1,0,1x: compensation for significant clock drifts in scheduleperiodically there is a problem reported in #3461 and #2943 in which if the system clock drifts the periodic calculation inside schedulerworker gets off and either taking a longer time for the next invocation of the task or doing "catching-up" with all the lost invocationsthe solution checks the wall clock difference between the last run and the current run and if it went back or forward significantly it rebases the timer period and schedules the next execution relative to nowif the clock goes back the original code scheduled the next invocation way into the future this pr will schedule it after the periodif the clock goes forward the original code scheduled executions for all the missed time between the last run and the new time immediately yielding a bunch of 0 delays this pr will simply schedule the next invocation after the periodthe algorithm for both cases is the same: make sure the next invocation is scheduled relative to now and recalculate the start timestamp as if the whole sequence run under the new drifted clock all along the subsequent invocations will be scheduled at a  rate againive added the system parameter `rxschedulerdrift-tolerance` (unit: minutes default: 15 minutes) which is used to determine if the clock drifted too far between invocations of the periodic task time drift is pretty nasty we spent a lot of time on this in rxnet  || ive updated the code with the suggestion of @stealthcode  || :+1:  do you need additional changes? if not feel free to merge this pr ||  yay! this was important issueso i did test (similar to #3530):``` javaobservable  interval(5 10 seconds)  subscribe(along -> loggerd("interval: %d" along))```and then changed system clock to +2 hours at runtime of the app**before fix**as expected computation scheduler gone crazy and fired about 700 events during one second<img width"1160" alt"screen shot 2015-12-15 at 08 44 57" src" width"944" alt"screen shot 2015-12-15 at 08 43 54" src" fix**everything was just fine! no incorrect events no cpu consuming<img width"1165" alt"screen shot 2015-12-15 at 09 01 06" src" width"1006" alt"screen shot 2015-12-15 at 09 00 42" src" i think #3461 and #3530 can be closed now!thanks @akarnokd! || 
3470,0,0,0,0,0,1,1,0,1x: replay request coordination reduce overhead reported in #3469this change will make sure whenever a new subscriber arrives therequest coordination doesnt scan every other subscriber unnecessary(they will trigger a managerequests individually anyway)unfortunately i cant make the subscription registration constant (via a hashset) because that would slow down the dispatching loop (which is quite expensive to for-each over compared to a plain array)note also that this will likely conflict with #3454i get the following numbers with the program in #3469```subscribingsubscribed so far 10000 took 54ms to subscribe last 10000 at rate: 185185 per secsubscribed so far 20000 took 110ms to subscribe last 10000 at rate: 90909 per secsubscribed so far 30000 took 157ms to subscribe last 10000 at rate: 63694 per secsubscribed so far 40000 took 267ms to subscribe last 10000 at rate: 37453 per secsubscribed so far 50000 took 211ms to subscribe last 10000 at rate: 47393 per secsubscribed so far 60000 took 320ms to subscribe last 10000 at rate: 31250 per secsubscribed so far 70000 took 331ms to subscribe last 10000 at rate: 30211 per secsubscribed so far 80000 took 369ms to subscribe last 10000 at rate: 27100 per secsubscribed so far 90000 took 415ms to subscribe last 10000 at rate: 24096 per secsubscribed so far 100000 took 462ms to subscribe last 10000 at rate: 21645 per secsubscribed so far 110000 took 516ms to subscribe last 10000 at rate: 19379 per secsubscribed so far 120000 took 547ms to subscribe last 10000 at rate: 18281 per secsubscribed so far 130000 took 647ms to subscribe last 10000 at rate: 15455 per secsubscribed so far 140000 took 720ms to subscribe last 10000 at rate: 13888 per secsubscribed so far 150000 took 811ms to subscribe last 10000 at rate: 12330 per secsubscribed so far 160000 took 806ms to subscribe last 10000 at rate: 12406 per secsubscribed so far 170000 took 873ms to subscribe last 10000 at rate: 11454 per secsubscribed so far 180000 took 911ms to subscribe last 10000 at rate: 10976 per secsubscribed so far 190000 took 986ms to subscribe last 10000 at rate: 10141 per secsubscribed so far 200000 took 1003ms to subscribe last 10000 at rate: 9970 per secsubscribed so far 210000 took 1168ms to subscribe last 10000 at rate: 8561 per secsubscribed so far 220000 took 1213ms to subscribe last 10000 at rate: 8244 per secsubscribed so far 230000 took 1340ms to subscribe last 10000 at rate: 7462 per secsubscribed so far 240000 took 1314ms to subscribe last 10000 at rate: 7610 per secsubscribed so far 250000 took 1548ms to subscribe last 10000 at rate: 6459 per secsubscribed so far 260000 took 1372ms to subscribe last 10000 at rate: 7288 per secsubscribed so far 270000 took 1835ms to subscribe last 10000 at rate: 5449 per secsubscribed so far 280000 took 2087ms to subscribe last 10000 at rate: 4791 per secsubscribed so far 290000 took 1910ms to subscribe last 10000 at rate: 5235 per secsubscribed so far 300000 took 1966ms to subscribe last 10000 at rate: 5086 per secunsubscribingunsubscribed so far 10000 took 1910ms to unsubscribe last 10000 at rate: 5235 per secunsubscribed so far 20000 took 1782ms to unsubscribe last 10000 at rate: 5611 per secunsubscribed so far 30000 took 1730ms to unsubscribe last 10000 at rate: 5780 per secunsubscribed so far 40000 took 1593ms to unsubscribe last 10000 at rate: 6277 per secunsubscribed so far 50000 took 1514ms to unsubscribe last 10000 at rate: 6605 per secunsubscribed so far 60000 took 1468ms to unsubscribe last 10000 at rate: 6811 per secunsubscribed so far 70000 took 1188ms to unsubscribe last 10000 at rate: 8417 per secunsubscribed so far 80000 took 1234ms to unsubscribe last 10000 at rate: 8103 per secunsubscribed so far 90000 took 1271ms to unsubscribe last 10000 at rate: 7867 per secunsubscribed so far 100000 took 1358ms to unsubscribe last 10000 at rate: 7363 per secunsubscribed so far 110000 took 1103ms to unsubscribe last 10000 at rate: 9066 per secunsubscribed so far 120000 took 1100ms to unsubscribe last 10000 at rate: 9090 per secunsubscribed so far 130000 took 990ms to unsubscribe last 10000 at rate: 10101 per secunsubscribed so far 140000 took 953ms to unsubscribe last 10000 at rate: 10493 per secunsubscribed so far 150000 took 854ms to unsubscribe last 10000 at rate: 11709 per secunsubscribed so far 160000 took 789ms to unsubscribe last 10000 at rate: 12674 per secunsubscribed so far 170000 took 779ms to unsubscribe last 10000 at rate: 12836 per secunsubscribed so far 180000 took 624ms to unsubscribe last 10000 at rate: 16025 per secunsubscribed so far 190000 took 634ms to unsubscribe last 10000 at rate: 15772 per secunsubscribed so far 200000 took 514ms to unsubscribe last 10000 at rate: 19455 per secunsubscribed so far 210000 took 411ms to unsubscribe last 10000 at rate: 24330 per secunsubscribed so far 220000 took 373ms to unsubscribe last 10000 at rate: 26809 per secunsubscribed so far 230000 took 337ms to unsubscribe last 10000 at rate: 29673 per secunsubscribed so far 240000 took 286ms to unsubscribe last 10000 at rate: 34965 per secunsubscribed so far 250000 took 234ms to unsubscribe last 10000 at rate: 42735 per secunsubscribed so far 260000 took 222ms to unsubscribe last 10000 at rate: 45045 per secunsubscribed so far 270000 took 159ms to unsubscribe last 10000 at rate: 62893 per secunsubscribed so far 280000 took 96ms to unsubscribe last 10000 at rate: 104166 per secunsubscribed so far 290000 took 63ms to unsubscribe last 10000 at rate: 158730 per secunsubscribed so far 300000 took 31ms to unsubscribe last 10000 at rate: 322580 per sec``` ive updated the code to have o(1) subscription/unsubscription cost as well the program from #3469 now produces stunning results:```subscribingsubscribed so far 10000 took 32ms to subscribe last 10000 at rate: 312500 per secsubscribed so far 20000 took 12ms to subscribe last 10000 at rate: 833333 per secsubscribed so far 30000 took 14ms to subscribe last 10000 at rate: 714285 per secsubscribed so far 40000 took 6ms to subscribe last 10000 at rate: 1666666 per secsubscribed so far 50000 took 12ms to subscribe last 10000 at rate: 833333 per secsubscribed so far 60000 took 4ms to subscribe last 10000 at rate: 2500000 per secsubscribed so far 70000 took 5ms to subscribe last 10000 at rate: 2000000 per secsubscribed so far 80000 took 5ms to subscribe last 10000 at rate: 2000000 per secsubscribed so far 90000 took 4ms to subscribe last 10000 at rate: 2500000 per secsubscribed so far 100000 took 13ms to subscribe last 10000 at rate: 769230 per secsubscribed so far 110000 took 4ms to subscribe last 10000 at rate: 2500000 per secsubscribed so far 120000 took 5ms to subscribe last 10000 at rate: 2000000 per secsubscribed so far 130000 took 5ms to subscribe last 10000 at rate: 2000000 per secsubscribed so far 140000 took 4ms to subscribe last 10000 at rate: 2500000 per secsubscribed so far 150000 took 5ms to subscribe last 10000 at rate: 2000000 per secsubscribed so far 160000 took 6ms to subscribe last 10000 at rate: 1666666 per secsubscribed so far 170000 took 41ms to subscribe last 10000 at rate: 243902 per secsubscribed so far 180000 took 5ms to subscribe last 10000 at rate: 2000000 per secsubscribed so far 190000 took 5ms to subscribe last 10000 at rate: 2000000 per secsubscribed so far 200000 took 19ms to subscribe last 10000 at rate: 526315 per secsubscribed so far 210000 took 4ms to subscribe last 10000 at rate: 2500000 per secsubscribed so far 220000 took 3ms to subscribe last 10000 at rate: 3333333 per secsubscribed so far 230000 took 4ms to subscribe last 10000 at rate: 2500000 per secsubscribed so far 240000 took 4ms to subscribe last 10000 at rate: 2500000 per secsubscribed so far 250000 took 4ms to subscribe last 10000 at rate: 2500000 per secsubscribed so far 260000 took 4ms to subscribe last 10000 at rate: 2500000 per secsubscribed so far 270000 took 4ms to subscribe last 10000 at rate: 2500000 per secsubscribed so far 280000 took 4ms to subscribe last 10000 at rate: 2500000 per secsubscribed so far 290000 took 4ms to subscribe last 10000 at rate: 2500000 per secsubscribed so far 300000 took 4ms to subscribe last 10000 at rate: 2500000 per secunsubscribingunsubscribed so far 10000 took 13ms to unsubscribe last 10000 at rate: 769230 per secunsubscribed so far 20000 took 8ms to unsubscribe last 10000 at rate: 1250000 per secunsubscribed so far 30000 took 7ms to unsubscribe last 10000 at rate: 1428571 per secunsubscribed so far 40000 took 5ms to unsubscribe last 10000 at rate: 2000000 per secunsubscribed so far 50000 took 5ms to unsubscribe last 10000 at rate: 2000000 per secunsubscribed so far 60000 took 5ms to unsubscribe last 10000 at rate: 2000000 per secunsubscribed so far 70000 took 3ms to unsubscribe last 10000 at rate: 3333333 per secunsubscribed so far 80000 took 3ms to unsubscribe last 10000 at rate: 3333333 per secunsubscribed so far 90000 took 3ms to unsubscribe last 10000 at rate: 3333333 per secunsubscribed so far 100000 took 3ms to unsubscribe last 10000 at rate: 3333333 per secunsubscribed so far 110000 took 3ms to unsubscribe last 10000 at rate: 3333333 per secunsubscribed so far 120000 took 3ms to unsubscribe last 10000 at rate: 3333333 per secunsubscribed so far 130000 took 3ms to unsubscribe last 10000 at rate: 3333333 per secunsubscribed so far 140000 took 2ms to unsubscribe last 10000 at rate: 5000000 per secunsubscribed so far 150000 took 3ms to unsubscribe last 10000 at rate: 3333333 per secunsubscribed so far 160000 took 2ms to unsubscribe last 10000 at rate: 5000000 per secunsubscribed so far 170000 took 3ms to unsubscribe last 10000 at rate: 3333333 per secunsubscribed so far 180000 took 2ms to unsubscribe last 10000 at rate: 5000000 per secunsubscribed so far 190000 took 3ms to unsubscribe last 10000 at rate: 3333333 per secunsubscribed so far 200000 took 2ms to unsubscribe last 10000 at rate: 5000000 per secunsubscribed so far 210000 took 2ms to unsubscribe last 10000 at rate: 5000000 per secunsubscribed so far 220000 took 2ms to unsubscribe last 10000 at rate: 5000000 per secunsubscribed so far 230000 took 2ms to unsubscribe last 10000 at rate: 5000000 per secunsubscribed so far 240000 took 2ms to unsubscribe last 10000 at rate: 5000000 per secunsubscribed so far 250000 took 2ms to unsubscribe last 10000 at rate: 5000000 per secunsubscribed so far 260000 took 2ms to unsubscribe last 10000 at rate: 5000000 per secunsubscribed so far 270000 took 2ms to unsubscribe last 10000 at rate: 5000000 per secunsubscribed so far 280000 took 2ms to unsubscribe last 10000 at rate: 5000000 per secunsubscribed so far 290000 took 2ms to unsubscribe last 10000 at rate: 5000000 per secunsubscribed so far 300000 took 3ms to unsubscribe last 10000 at rate: 3333333 per sec```(the numbers could be actually higher but windows timer resolution is about 3ms at best) || ive updated the code to avoid the synchronized block on each replay attempt in case the cached version of the innerproducers is still the same as the sets version || i havent reviewed the changes in detail yet but i do notice that openhashset doesnt have any dedicated unit tests || ive added a unit test for `openhashset` || strangely the test doesnt crash with java 8 must be some difference between what type for-each extracts || @akarnokd needs rebase on latest `1x` || thanks working on it || rebased || i like this a lot and the results are really impressive code looks good to me cleaner than the previous implementation too  i finally find some time to review this one sorry for the delay
3512,0,0,0,0,0,0,1,0,1x: fix safesubscriber documentation regarding unsubscribe the documentation was wrong in two points: unsubscription doesnt call`oncompleted` and unsubscription doesnt directly prevent delivery of `onxxx` events since the implementation doesnt even check isunsubscribed: (it is the responsibility of the upstream to do that)related issue: #3059  
3513,1,0,0,1,0,1,1,0,1x: add shorter rxjavaplugin class lookup approach this adds a new pattern and lookup method that lets the developer specify the custom plugins with shorter system property keys android is quite restrictive and allows only 31 charactersthe new pattern splits the target simple class name and its implementation into two separate system properties:```rxjavaplugin1classsimpleclassnamerxjavaplugin1implpathtoimplclass```the index tag (`1`) can be any string of your chosing:```rxjavapluginmykeyclasssimpleclassnamerxjavapluginmykeyimplpathtoimplclass```but make sure they are paired otherwise nothing will happenif there are multiple `class` entries with the same `simpleclassname` one of them will be chosen (depending on the walk order in `javautilproperties`)related issue #2835  updated: made strings local constants and using `length`˙instead of magic numbers plus if the default keying matches the properties is not traversed for an alternate specification || an alternative pattern could be this:```rxjavaplugin1simpleclassnameorgpackagenamingactualclass``` || i agree that if the plugin cannot be found we should crash the app  || updated the code to crash if the plugin implementation is missing || 
3524,1,0,0,0,0,0,1,0,fix subscribe() javadoc fix for javadoc issue #3523    
3584,1,0,0,0,0,0,1,0,clarify behaviour of groupby in javadoc as discussed in #3411 some clarification of the behaviour of `groupby` looks necessary re its behaviour when the `groupedobservable` terminates early (for example has `first()` applied to it) see also  #3581i also took the liberty of recommending `ignoreelements` instead of `take(0)` for the section in the javadoc that recommends how to ignore emissions because the `take(0)` approach would have more overhead (every emission from source would prompt the emission of a new `groupedobservable`) than the `ignoreelements` approachonce this is accepted ill look to submit a pr with `groupbyonce` (mentioned in #3411) corrected the documentation that said resubscription occurs when it is rather a new groupedobservable is emittted for a group || incorporated @akarnokd suggestion ||  :+1: > i also took the liberty of recommending ignoreelements instead of take(0) for the section in the javadoc that recommends how to ignore emissions because the take(0) approach would have more overhead (every emission from source would prompt the emission of a new groupedobservable) than the ignoreelements approachby the way `ignoreelements` has a drawback: it keeps all group `observable`s in memory even some of them wont emit items ||
3584,1,0,0,0,0,0,1,0,clarify behaviour of groupby in javadoc as discussed in #3411 some clarification of the behaviour of `groupby` looks necessary re its behaviour when the `groupedobservable` terminates early (for example has `first()` applied to it) see also  #3581i also took the liberty of recommending `ignoreelements` instead of `take(0)` for the section in the javadoc that recommends how to ignore emissions because the `take(0)` approach would have more overhead (every emission from source would prompt the emission of a new `groupedobservable`) than the `ignoreelements` approachonce this is accepted ill look to submit a pr with `groupbyonce` (mentioned in #3411) corrected the documentation that said resubscription occurs when it is rather a new groupedobservable is emittted for a group || incorporated @akarnokd suggestion ||  :+1: > i also took the liberty of recommending ignoreelements instead of take(0) for the section in the javadoc that recommends how to ignore emissions because the take(0) approach would have more overhead (every emission from source would prompt the emission of a new groupedobservable) than the ignoreelements approachby the way `ignoreelements` has a drawback: it keeps all group `observable`s in memory even some of them wont emit items ||
3614,1,0,0,0,0,0,1,0,1x: just() now supports backpressure (+ related fixes/changes) updated `just()` to fully support backpressurethis is a repost of #3496 due to merge and rebase problems we were waiting to hear from @benjchristensen on this one i think any news? || +1 for correctness despite my hesitance due to perf impact  ||
3655,1,0,0,0,0,1,1,1,1x: add singleonerrorresumenext(single) part of #3652 will submit a pr for `onerrorresumenext(func1<throwable single>)` later @akarnokd changed to `implements singleonsubscribe`! ptal ||  @zsxwing ptal :) ||  
3661,1,0,0,0,0,0,1,0,1x: combinelatest now supports any number of sources this pr is a backport of the 2x `combinelatest` with `null` support and lets the programmer combine more than 128 sources at once note that 2x supports manual sizing of the prefetch buffer and allows delaying the exceptions to the last moment i kept these in case such features are required by 1x some daythe original had this 128 limit due to using a single and non-parametric rxringbuffer to store values from sources in addition the original algorithm divided downstream requests among the sources with some strange logic in order to keep them running and not overflow the bufferthis pr uses an unbounded-linked spsc queue which can now hold as many elements as there are sources times the default ring buffer size (this is not preallocated and grows/shrinks as necessary)the algorithm stores the current latest array and the source subscriber in the queue in pairs so when that particular row is emitted to downstream that source subscriber gets the request() replenishment call that generated the rowin addition ive added an iterator overload from #3660 as well  
3682,1,0,0,0,0,0,1,0,1x: fix observeon resource handling add delayerror capability this pr fixes the "messing around" reported in #3002 and adds an overload to `observeon` that allows delaying errors without the need for wrapping (see #3542 and maybe there are other reports)in addition this pr adds a proper override of the `isempty` method to simply compare the two indexes for emptiness directly instead of `size()  0` to avoid looping multi-reading and castingbenchmark comparison (i7 4790 windows 7 x64 java 8u66):( that the benchmark is generally quite noisy yielding hectic results (ie firing up a thread with newthread may take quite some random microseconds) for example `observeonimmediate` shouldnt be affected by any of the changes yet the run-to-run variance is +/- 10% im fine with the results of the benchmark  
3682,1,0,0,0,0,0,1,0,1x: fix observeon resource handling add delayerror capability this pr fixes the "messing around" reported in #3002 and adds an overload to `observeon` that allows delaying errors without the need for wrapping (see #3542 and maybe there are other reports)in addition this pr adds a proper override of the `isempty` method to simply compare the two indexes for emptiness directly instead of `size()  0` to avoid looping multi-reading and castingbenchmark comparison (i7 4790 windows 7 x64 java 8u66):( that the benchmark is generally quite noisy yielding hectic results (ie firing up a thread with newthread may take quite some random microseconds) for example `observeonimmediate` shouldnt be affected by any of the changes yet the run-to-run variance is +/- 10% im fine with the results of the benchmark  
3689,1,0,0,0,0,0,1,0,1x: unified onerrorx and onexceptionresumenext and  backpressure the operators didnt honor backpressure when they switched over to the other observablethis pr also includes the 3685 there was a test failure in backpressureteststestmergeasync run before any of the changes of this pr and shouldnt have any effect overloaded servers? || 
3696,1,0,0,1,0,1,1,1,1x: added single execution hooks 3595 would you also apply these plugin methods in single?- onsubscribestart- onsubscribereturn- onsubscribeerror- onlift || below hooks are already called (i replaced previous calls of `rxjavaobservableexecutionhook`  rxjavasingleexecutionhook` calls)- onsubscribereturn- onsubscribeerror- onlifthowever there is problem with `onsubscribestart` this hook should be called in `onsubscribe` and `unsafesubscribe` unfortunately in `single` `onsubscribe` and `unsafesubscribe` methods get `subscriber` type as parameter instead of `singlesubscriber` i will make a commit to cover it soon || there is something wrong a bunch of single test failed ||  as far i see that failing test is not related with my changes is `rxschedulerscachedthreadschedulertest > testunsubscribeforscheduler` some kind of flaky test? || more tests would be appreciated but otherwise  could you squash the commits and rebase this pr? || :+1: (after you rebase/squash the commits) || 
3701,1,0,0,0,0,1,1,1,1x: add completabledooncompleted and deprecate completabledooncomplete closes #3700 wait what? i thought you wanted to add `completabledooncompleted()` i see no reason to change the established naming of `observabledooncompleted()` in fact for consistency id rather prefer adding `completabledooncompleted` || that makes sense the only reason i did it this way is because on the 2x branch both [observable]( and [completable]( use `dooncomplete()` || yes those follow the reactive-streams convention and completable started out as a 2x addition in the meantime ill fix that test failure || changed `completable` instead updated tests to match ||  @zach-klippenstein thanks! just updated the title  
3712,1,0,0,0,0,1,1,1,add takeuntil support in single as discussed in #3708this adds `takeuntil(observable)` and `takeuntil(single)` support in `single` it was mostly just adapting the logic from the existing `operatortakeuntil` and adjusting it for accepting a `single` and sending a `cancelattionexception` in the event of a submission from `other` prior to a terminal event in the source `single`any feedback is appreciated it this is my first time contributing an implementation to this project particularly wondering if its worth keeping both overloads or if the user should just coerce their `other` to one type or ther other also particularly looking for feedback on what information to include in the `cancellationexception` just noticed my ide swapped the wildcard imports for explicit ones let me know if i should revert that || yes please || just style issues otherwise lgtm  cc @akarnokd @artem-zinnatullin for the tests most of them are adapted from `operatortakeuntiltest`  it looks like these tests have two different styles (one with `testobservable` and the other with `subject`) i reused both of them here but would we maybe want to stick with one or the other? especially with single i think some now overlapalso if we stick with one style here should we update the style in `operatortakeuntiltest` as well to match?  || im not too keen on how the tests are named or what test framework objects you useplease squash your commits || squashed ||  @zsxwing @stevegury any input? need another collaborator reviewmain points im wondering about:- should we only support one overload? if we support more than one should it support all three (including `completable`?)- should `takeuntil` test styles formalized looks like there are two styles right now judging  operatortakeuntiltest`: subject-based and `testobservable`-based || :+1: yes i think it makes sense to had an override for `completable`regarding test styles i dont think its a big deal the best thing to do slowly convert all the tests to the new convention (ideally in separated commits that dont change the behavior) || > sending a cancelattionexception in the event of a submission from other prior to a terminal event in the source singlethis behavior is really confusing why not be same as observable? am i missing anything? || @akarnokd and i discussed it in #3708 `single` currently emits a `nosuchelementexception` if the stream is terminated prior to any event emission by signaling a `cancellationexception` we can at least signal to the subscriber if the error was due to `takeuntil` unsubscribing it or normal missing emissions || @hzsweers thanks for clarifying however i would expect `singletakeuntil` returns something that contains 0 or 1 item how about returning observable instead? then the semantics of `singletakeuntil` is `onnext{0 1} (oncompleted | onerror)` which is consistent with `observabletakeuntil` (`onnext{0 n} (oncompleted | onerror)`) || the operators should stay in the same type as long as they can and there are operators that simply cant behave the same as their counterpart in other reactive types if one wishes the `observabletakeuntil` behavior one can use toobservable()takeuntil() and get that behavior || > the operators should stay in the same type as long as they can and there are operators that simply cant behave the same as their counterpart in other reactive types if one wishes the observabletakeuntil behavior one can use toobservable()takeuntil() and get that behaviorif so i vote for `nosuchelementexception` as `cancellationexception` seems counterintuitive to me `cancellationexception` looks some codes cancel single (eg i call `unsubscribe` in some place) but here the error is that `singletakeuntil` returns something that is not `single` hence i would expect `nosuchelementexception` || thats fair but is there something we could do to at least indicate whether the source was just unsubscribed or actually misbehaved? i was of the impression that `onerror` was primarily for serious unexpected errors whereas this seems like not unexpected or seriousconsider the followingwith `nosuchelementexception`:``` javapublishsubject<integer> source  publishsubjectcreate()publishsubject<integer> until  publishsubjectcreate()sourcetake(1)tosingle()        takeuntil(untiltake(1)tosingle())        subscribe(                new action1<integer>() {                    @override                    public void call(integer integer) {                        systemoutprintln("success")                    }                }                new action1<throwable>() {                    @override                    public void call(throwable throwable) {                        systemoutprintln("i dont know if it was due to unsubscribing or the source is misbehaving")                    }                })untilonnext(1)```vs with `cancellationexception```` javapublishsubject<integer> source  publishsubjectcreate()publishsubject<integer> until  publishsubjectcreate()sourcetake(1)tosingle()        takeuntil(untiltake(1)tosingle())        subscribe(                new action1<integer>() {                    @override                    public void call(integer integer) {                        systemoutprintln("success")                    }                }                new action1<throwable>() {                    @override                    public void call(throwable throwable) {                        if (throwable instanceof cancellationexception) {                            systemoutprintln("it was canceled")                        } else {                            systemoutprintln("source didnt emit")                        }                    }                })untilonnext(1)```the example i gave in the issue is probably the best example for me we use something similar to this for lifecycle binding in android when the lifecycle ends it might unsubscribe this in the middle for a normal error we might show a generic "an error occurred" message in the event that its just the lifecycle ending we dont want to react that way and rather likely just want to do nothing at all or clean up resources im fine with not using `cancellationexception` but i think it would be useful to add a means of being able to differentiate between unsubscription reasons i thought about just specifying a message but felt that @akarnokds `cancellationexception` suggestion made it more clear || ill add an overload for `completable` as well and remove the old test style in the new tests here for now @stevegury just to be clear the "new" style would be the `subject`-based approach right? || @hzsweers i actually typed "its a big deal" but i was willing to say "its **not** a big deal" (i corrected my previous comment) i prefer the subject based approach but i am not strongly opinionated about thati still :+1: on the current implementation || > thats fair but is there something we could do to at least indicate whether the source was just unsubscribed or actually misbehaved?my point here is if singletakeuntil() returns a single that emits nothing it should be `misbehaved` rather than `unsubscribed` || i think "cancellationexception" is the clearer reaction here remember the problems around the observablesingle() and how it is a source of problem to find out exactly who didnt signal? here you know that if takeuntil is tripped and not some upstream machinery ends up being empty || > i think "cancellationexception" is the clearer reaction here remember the problems around the observablesingle() and how it is a source of problem to find out exactly who didnt signal? here you know that if takeuntil is tripped and not some upstream machinery ends up being emptywhat if we want to add other operator that may return something doesnt signal? if it also emits `cancellationexception` then we still cannot find out exactly who didnt signal so why not use `nosuchelementexception` to indicate all cases that didnt signal? || what about a subclass of `nosuchelementexception`? a `cancelednosuchelementexception` so to speak wouldnt break the downstream apis but still allows for the subscriber to differentiate || > what about a subclass of nosuchelementexception? a cancelednosuchelementexception so to speak wouldnt break the downstream apis but still allows for the subscriber to differentiatemaybe a more general question should we add special exceptions for different operators or we just use a general exception to indicate the same error? || i think people should be aware of the implications of operators they use would `compositeexception` possibly be precedent for this? || > i think people should be aware of the implications of operators they use would compositeexception possibly be precedent for this?compositeexception is fine and clear it indicates there are multiple errors thrown all classes in rxexceptions are well defined and its very easy to connect them with the bad cases i can just read the exception name and tell what my codes violate but for `cancellationexception` its hard to connect it with `takeuntil` especially people use some library that calls `takeuntil` internally in addition imo if i see `cancellationexception` my first thought is `futurecancel` is called somewhereif we can define clearly that when should throw cancellationexception/cancelednosuchelementexception(or whatever you propose) when should throw nosuchelementexception i wont be against that for now the confusing thing for me is that if a single doesnt signal i may receive cancellationexception or nosuchelementexception || im fine with either i think we could be clear in the documentation and subclassing would still allow downstream subscribers to treat it as a `nosuchelementexception` @akarnokd @stevegury thoughts? || added `takeuntil(completable)` support and standardized tests updated with a separate commit for easier reviewing let me know if you want me to squash againping @akarnokd @stevegury ||   
3714,1,0,0,0,0,0,1,0,1x: add maxconcurrent parameter to concatmapeager relevant issue #3710 will you update this pr? || yes on it ! || i submitted a commit with your proposed changes sorry for the delay feel free to give me more comments/changes also i can squash if needed || :+1:dont squash this time github has now a new feature for the merge button where it offers squashing id like to test if it really squashes everything and the main just gets 1 commit || nothing critical :+1: // @akarnokd squashing on github works and it works especially great when author of the pr just commits on top of previous commits because github now remembers what code youve checked and what not and you can continue reviewing from previous point (doesnt work for me when pr is always squashed) || i have updated the pr do pr commits trigger github notifications ? (should i comment after i do an update ? ) || unfortunately no notification || 
3722,1,0,0,0,0,0,1,0,add maxconcurrent parameter to flatmapiterable refs #3711 should these new overloaded functions be annotated with `@beta`? the failing test (`testnomorerequestsafterunsubscribe`) seems unrelated all tests pass locally || if you could add one unit test for each method that verifies maxconcurrent is honored that would be great || while writing the test i figured you might have been right when commenting on issue #2627 if i am not mistaken all the observables created with `operatormappairconvertselector` use the same scheduler (there is no way to subscribe them to different schedulers) and thus are run sequentially and until completion would adding a scheduler parameter make sense? || there is no scheduler involved here so no || :+1: as it is now || 
3733,1,0,0,0,1,1,1,1,avoid swallowing errors in completable instead deliver them up to the threads uncaught exception handlerfixes reactivex/rxjava#3726 what happened to `completabletest`? || @akarnokd sorry ij formatted it  will clean up and push again ||  just a nit about `timeout` in tests otherwise  removed timeouts || 
3741,1,0,0,0,0,1,1,1,add doonsubscribe for single ref #3740i didnt write much unit tests for `doonsubscribe` because it internally uses `operatordoonsubscribe` which is well covered    thanks @aaronhe42!  ||
3752,1,0,0,0,0,1,1,1,1x: singleusing() this pr adds the factory method `using()` +1 overload to `single` as requested in #3732for convenience ive also added `singlesubscribe(observer)`  lgtm
3756,1,0,0,0,0,0,1,0,1x: clarify join/groupjoin no ordering guarantees original issue: #3616   
3766,1,0,0,0,0,1,1,1,1x: add singleonerrorresumenext(func) closes #3440 closes #3731 closes #3472 (whoa 3 issues at a time!) @akarnokd  your comments btw should i add `@experimental` to these operators? || yes and copy over the experimental and since tags into the javadoc || :+1: there is this new like option but do you get a notification for them? || noon mon mar 14 2016 8:10 pm david karnok notifications@githubcom wrote:> [image: :+1:] there is this new like option but do you get a notification> for them?> > —> you are receiving this because you are subscribed to this thread> > reply to this email directly or view it on github:>  ||  
3766,1,0,0,0,0,1,1,1,1x: add singleonerrorresumenext(func) closes #3440 closes #3731 closes #3472 (whoa 3 issues at a time!) @akarnokd  your comments btw should i add `@experimental` to these operators? || yes and copy over the experimental and since tags into the javadoc || :+1: there is this new like option but do you get a notification for them? || noon mon mar 14 2016 8:10 pm david karnok notifications@githubcom wrote:> [image: :+1:] there is this new like option but do you get a notification> for them?> > —> you are receiving this because you are subscribed to this thread> > reply to this email directly or view it on github:>  ||  
3766,1,0,0,0,0,1,1,1,1x: add singleonerrorresumenext(func) closes #3440 closes #3731 closes #3472 (whoa 3 issues at a time!) @akarnokd  your comments btw should i add `@experimental` to these operators? || yes and copy over the experimental and since tags into the javadoc || :+1: there is this new like option but do you get a notification for them? || noon mon mar 14 2016 8:10 pm david karnok notifications@githubcom wrote:> [image: :+1:] there is this new like option but do you get a notification> for them?> > —> you are receiving this because you are subscribed to this thread> > reply to this email directly or view it on github:>  ||  
3777,1,0,0,0,0,0,1,0,observeon: allow configurable buffer size the observeon operator is backed by a small queue of 128 slots that mayoverflow quickly on slow producers  this could only be avoided byadding a backpressure operator before the observeon (not onlyinconvenient but also taking a perf hit as it forces hops between twoqueues)this patch allows modifying the default queue size on the observeonoperatorfixes: #3751signed-off-by: galo navarro anglorvaroa@gmailcom  :+1: though id leave old test for default buffer size and just add a new one  || rebased  the javadoc link and a spelling mistake@artem-zinnatullin i reused this one to avoid redundancy as the code path is virtually the same and there are tests (the ones referenced in the @link) which use the default size let me know if you still prefer the 2 cases and ill fix that || yeah i understand just afraid that one may change linked  tests and we wont cover overload // one day well setup code coverage i hope || agh thanks @akarnokd i didnt notice i changed computers so i was back on the 1st patch and lost the overload resubmitted based on the one with all overloads and added the extra test instead of rewriting it hopefully fine now ||  ive seen some failures on the test locally and there is also a bug in the test (the loop should start at 2 not 1) i cant look into it right now but will take a look asap ||  im merging this the changes are algorithmically solid so im not sure what failures you see locally || thanks @akarnokd the failure was no error notifications emitted at random sizes but i did notice travis didnt complain ping me if it surfaces ||
3787,0,0,0,0,0,1,1,0,1x: fix groupby delaying group completion till all groups were emitted in 111 `groupby` was  to properly honor backpressure on the outer `observable` the change included a drain loop that emitted `oncompleted()` to the groups only when all `groupedobservable`s were drained from the main queue this delayed the groups completion unnecessarily causing the `concat` operator to hang in some source-consumer cases such as #3775this pr fixes the behavior by signalling `oncompleted()` to the groups the moment the main completes note however that concatenating groups is eventually prone to hangs due to the groups not completing until the source completes thus `concat` cant switch to the next source one should use `flatmap` or `concatmapeager` instead  
3789,1,0,0,0,0,1,1,1,1x: prevent singlezip() of zero singles closes #3784  
3790,1,0,0,0,0,0,1,0,1x: expose singlelift() closes #3161  
3822,1,0,0,1,0,0,1,0,1x: make defensive copy of the properties in rxjavaplugins possible solution to #3749  
3856,1,0,0,0,0,0,1,0,provide factories for creating the default scheduler instances unlike other hooks the `rxjavaschedulershook` has no access to the real `scheduler` instances in order to do wrapping/delegation with these factory methods a hook can access what would otherwise be the instance used since there is often no other means of creating these specialized schedulersfor android this wrapping/delegation use-case is important for ui testing we have a means to tell the testing framework when the app is idle and to do that we need to hook into the schedulers to know when theyre empty this is easy to do currently but you cannot wrap the real instance and instead have to supply alternate implementations which might subtly alter the behavior under testthese three methods are referenced in #3724 and i think providing the defaults is useful as well as eventually adding overloads which take `threadfactory` instances for each please correct me if im wrong but looks like as soon as you access one of the new methods `static final schedulersinstance` will be instantiated which will make impossible to use `rxjavaschedulershook` as you described have you checked described use case? maybe add such tests as example if possible?> we have a means to tell the testing framework when the app is idle and to do that we need to hook into the schedulers to know when theyre emptyjust wanted to say for those who may find this pr later: empty/non-empty state of schedulers is not 100% source of truth for ui tests you may have some background or time related (periodic/etc) code that does not affect the ui directly and may even freeze tests || you are accessing the methods from the hook which was called from the static initializer of this class on first reference to `schedulersio()` or the like ill add a test || yup but there is still potential problem if somebody will try to create schedulers using these methods outside of the hook for example in `@beforeclass`/etc or probably even just for non-test needs -> may result in hours of trying to understand why hook is not overriding schedulers…maybe move these methods to `rxjavaschedulershook`? || that prevents package scoped methods from being used in the factory || > that prevents package scoped methods from being used in the factorywe can move schedulers to `internalschedulers` to "defend" from that (otherwise somebody can always use reflection to break package scope) and make constructors publicideal solution would be to return schedulers in `rxjavaschedulershook` by default instead of returning `null` like it does now so calling `supergetsomescheduler()` will give original instance that you can wrap/etc as you wish though well have to handle `null` as default too// sorry im very tired and want to sleep so i may come to wrong conclusions || the factories were moved to the hook ||  :+1: now but let me ask again what about this:> ideal solution would be to return schedulers in `rxjavaschedulershook` by default instead of returning `null` like it does now so calling `supergetsomescheduler()` will give original instance that you can wrap/etc as you wish though well have to handle `null` as default toono need for new methods no need to fight with instantiation order and package scope visibility yes user wont be able to instantiate new scheduler of required type outside of the hook but its not possible at the moment so nobody loses nothing ||  
3866,1,0,0,0,0,1,1,1,1x: add singletocompletable() closes #3865   seems github doesnt add the pr description to the commit message automatically when squashing a pr i added it manually ||
3879,1,0,0,0,0,1,1,0,expose scheduler factories which accept thread factories this allows hooks to create schedulers whose threads have different prioritiescloses #3724  thanks!on fri apr 29 2016 at 2:13 pm david karnok notifications@githubcomwrote:> merged #3879  > —> you are receiving this because you authored the thread> reply to this email directly or view it on github>  ||
3883,1,0,0,0,0,1,1,0,1x: fix multiple chained singledoafterterminate not calling actions 3881the bug is caused by the impedance mismatch between `observable`s `subscriber` and `single`s `singlesubscriber` the original code called `onnext()` which immediately signalled an `onsuccess` but also caused an unsubscription preventing a delivery of `oncompleted()` in the inner singlethe fix keeps `onsuccess`/`onerror` rails intact  throughout the chain  
3886,1,0,0,0,0,1,1,0,throwiffatal() now throws oncompletedfailedexception otherwise if theres an error in oncompleted the exception isswallowed and unreported3885  
3907,1,0,0,0,0,0,1,0,1x: doonunsubscribe javadoc clarifications see #3877  
3941,1,0,0,0,0,1,1,1,1x: fix singleflatmap not composing subscription through see #3940  
3942,1,0,0,1,0,0,1,0,1x: add completablesafesubscribe option + rxjavaplugins hook support add option to safely subscribe a `completablesubscriber` / regular `subscriber` and handle `onxxx` failuressee also: #3938naming and whether or not the safe wrapping should be the default is open to discussion in my opinion safe wrapping should be the default as its the default in `observable` and `single` at least the 3 should behave the same way when using them one should expect them to have a difference in their essential semantics and not in these kind of things || should the tests about error handling plugin in #3938 be here? or we leave it in that pr? || @bryant1410 your pr has a test failure:```rxpluginsrxjavapluginstest > testonerrorwhenusingcompletable failed    javalangassertionerror: expected:<javalangruntimeexception: test onerror> but was:<null>        at orgjunitassertfail(assertjava:93)        at orgjunitassertfailnotequals(assertjava:647)        at orgjunitassertassertequals(assertjava:128)        at orgjunitassertassertequals(assertjava:147)        at rxpluginsrxjavapluginstesttestonerrorwhenusingcompletable(rxjavapluginstestjava:314)``` ||  typo renamed methods || @akarnokd they fail on purpose because i made the test but didnt fix the problem (completable is not calling the error handling plugin) || the methods should be the other way around following `single` and `observable` there should be a single `unsafesubscribe` method which accepts a parameter of type `completablesubscriber` and `subscribe` should be present in the following ways: `subscribe()` `subscribe(action0)` `subscribe(action1<? super throwable> action0)` `subscribe(subscriber)` and `subscribe(completablesubscriber)` || the `subscribe()` methods wrap with `safecomletablesubscriber` similar to how observablesubscribe wraps with `safesubscriber` subscribe(subscriber) is there to allow conversion and cross-type apis to bypass the safety overhead || updated with plugin support || can you cherry-pick the [commit that adds tests for the error handling plugn in `completable` and `single`]( from #3938? || sure || done || the comment `// todo plugin wrapping onsubscribe` in `completable#create` can be deleted as the constructor is already calling the hook now  || removed comment changed to reuse methods added onstart call || please add the missing `@experimental` otherwise  added missing annotations || 
3948,1,0,0,0,0,1,1,1,add completableandthen(completable) deprecate endwith() see #3947 please update unit tests that use these deprecated methods || done ||  👍 but id either duplicate tests or make universal test functions and test both `endwith` and `andthen` to make sure that we dont break old behavior of public api  || the question is also since completable is still `@experimental` we could if this is wanted go the hard way and remove the deprecated methods and make everyone force to use the standard (new) methods since there are already quite a few deprecated / duplicated methods || 👍 > but id either duplicate tests or make universal test functions and test both endwith and andthen to make sure that we dont break old behavior of public api@artem-zinnatullin im not against it but this is really minor as `andthen` just calls `endwith` im going to merge this feel free to add tests in a separate pr if you wish ||
3966,1,0,0,0,0,0,1,0,1x: add multi-other withlatestfrom operators add `withlatestfrom` operator version that can take 2 to n other sources and combine them with the main sourcerelated: #3779  
3971,1,0,0,0,0,0,1,0,1x: request rebatch operator this is a follow-up on #3964 but with a separate operator on `observable`  @abersnaze @stealthcode you had some use cases for this any objections? || the reuse of the observeon is interesting but couldnt it be done without the allocation of a queue? || if the downstream request is unbounded and the downstream has caught up then the queue can be skipped in this case `observeon` cant be reused anymore and a custom drain logic has to be implementedotherwise the upstream emissions have to be stored temporarily for an underrequesting downstream ||  i know that @abersnaze still had reservations about this i think that this should not be using `observeon` || my concern is this - if @abersnaze implemented the batching functionality then why wouldnt we use that? the queue in observeon scheduling creates a layer of indirection that seems unnecessary  || remember this started out as a change to `observeon` to not ignore the `immediate` scheduler but people wanted this behavior exposed behind a proper name || thanks for reminding me of the context of this work it seems like we have 2 implementations for the same functionality i think @abersnaze and i agree that the 2 features of request batching and request valve type functionality could be composed however i think that using `observeon` for this functionality is not necessarily the best way to accomplish this  || i personally would be okay with either implementation i think `observeon` is a nice choice because of the request management but would prefer it more if there wasnt a queue but realistically i think the choice is fine also its interesting to note that users are gravitating more and more to taking direct control over the `requester-producer` interactions  || for example this pr does something similar but exactly n (could be modified to have optional 25%) and without a queue #3781  ||
3974,1,0,0,0,0,0,1,0,1x: add terminal clarification to switchmap operators see #3576  
3977,1,0,0,0,0,1,1,0,1x: use the correct throwable to set the cause for compositeexception the cause of #3679 is we use a wrong throwable (its cause has been set) to set the cause and `initcause` will throw an exception hence the cause chain is not created correctly in this pr it searches the root cause (which doesnt have a cause) and use it to call `initcause`  
3981,1,0,0,0,0,0,1,0,1x: document zip() eagerness see #3960 and #3124  
3981,1,0,0,0,0,0,1,0,1x: document zip() eagerness see #3960 and #3124  
3986,1,0,0,0,0,0,1,0,add schedulersreset() for better testing 3985this adds a `reset()` method to `schedulers` with the main benefit being improved testing support this does slightly tweak the internal api of `schedulers` to use a `getinstance()` approach to allow lazy init this way we dont have to replace the singleton instance during `reset()` and allow it to lazily re-evaluate upon next usage otherwise if you change your scheduler hook youd always have to make sure you set it before you call `schedulersreset()`will run perf tests overnight in case im not sure how much of a tradeoff moving to an internal `getinstance()` approach costs if anythingcc @zsxwing i think the failing test might be flaky it doesnt fail for me locally  ||  thanks! i dont suppose this could be squeezed into the `requires review` of #3970 could it? || that test doesnt fail for me locally im not really sure what do do about it any ideas? || ive extended the timeout in some tests in pr #3987 once it appears it was enough ill merge that and this pr should work || cool ill rebase after thats merged then  non need to rebase but to rerun the travis job did it for you || ah i pushed the rebase as you commented oh well ¯\_(ツ)_/¯ || cool looks like the timeout tweaks worked || code is ok so 👍 but> resetting the schedulers is dangerous>    during application runtime and also bad code could invoke it in>    the middle of an application life-cycle and really break applications>    if not used cautiouslywhy were adding more and more apis to break things and allow people use bad practices? || its two and theyre largely targeted at testing i dont think having a reset is bad practice and like most code only breaks things if you make poor decisions with it i could just as easily add a bad scheduling hook or buggy global error handlerhaving to otherwise use di to inject schedulers everywhere gets tedious fast and inadvertantly discourages people from actually using the conventional static apis with this it can be wrapped up in a nice test rule and enforces a clean state before and after tests using the plugins api also allows you to control the schedulers used across modules and 3rd party libraries as wellfor me its a missing and much needed api i dont think requiring di everywhere you use a scheduler just to test is a scalable approach considering how ubiquitous they are could you imagine injecting say `timber` everywhere you wanted to use it?thats my speel for why i think this is useful || i wonder why people with such testing needs dont roll their own global "myschedulers" class which lets them easily switch scheduler types and use that like `observeon(myschedulersforcomputation())` of course this means you have to remember to use the `scheduler`-overloaded operators everywhere || i also just copied that doc from the other reset i dont know that its as dangerous though it just forces a re-init if its dangerous its because resetting rx plugins is dangerous since theyre not explicitly bound i wouldnt mind making the doc warning a little less severe? :p || 3rd party libraries dont use your apps global class :/ plus that case still requires you to hook in a delegate scheduler in tests early enough were adding a global scheduler of sorts for background work and still planning to have a reset on the schedulers || libraries should expose the option to customize the `scheduler` they run on do you know a library that doesnt allow such customization? || most actually they just use the built-in schedulerswhatever() or androidschedulersmainthread() i dont see how a wrapper with static methods solves this either you still need some mechanism of resetting the underlying scheduleris there any harm in allowing reset here to facilitate just having developers go through the standard api? || but heres a quick example off the top of my head:  || otherwise i think the whole plugin system in rxjava 1x is getting cumbersome in 2x i did a much simpler and direct approach for overriding stufffor example this is how the schedulers get initialized: is where they are returned: what scheduler is returned from schedulers is easy via adding a function that can wrap or completely replace the scheduleri dont know if netflix wants 12 at all but if so id be glad to rewrite the plugin system || > but heres a quick example off the top of my head:  where does it use rxjava schedulers forcefully? || found one: [reversegeocodeobservablejava]( should have provided a way to customize that scheduler anyway ||  this one || may sound crazy but what about marking `reset()` as `@deprecated` with explanation of better ways? || i think `@experimental` with a doc explaining that the api will be revamped in the future would make more sense i dont have strong feelings for or against `@deprecated` though and can switch to that if others want anything to help move this pr along :) || `@deprecated` will produce compile warning and will be visible in ide pretty sure most of the people who will use `schedulersreset()` will copy-paste from so or some blog post which will arrive as soon as we merge/release this and wont even know that its `@experimental`// im not blocking pr if that matters || fair point @akarnokd any thoughts? it seems like this has the requisite 👍s to move forward can add deprecated if you think its worthwhile || do we really expect people to accidentally use this and be surprised?deprecating the method sounds like it punishes those who want to use itid deprecate create() and others long before this methodon mon jun 6 2016 5:19 pm zac sweers notifications@githubcom wrote:> fair point @akarnokd  any thoughts? it> seems like this has the requisite 👍s to move forward can add> deprecated if you think its worthwhile> > —> you are receiving this because you are subscribed to this thread> reply to this email directly view it on github>  or mute the thread>   || when you put it that way i think i agree || dont deprecate it || > do we really expect people to accidentally use this and be surprised?have seen/helped people asking how to solve problems after applying scheduler hooks for testing they didnt realize (mostly) how it can break things`create()` is local evil it doesnt break global state alternative solution would be to move apis like `create()` `reset()` and so on to `rxunsafe` like java rust and so on its there but use it at your own risk || 
3996,1,0,0,0,0,0,1,0,1x: fix reset() shutting down everything other than the schedulers the reset shut down all the main schedulers and the helper pools causing the failure in #3993 @hzsweers you were right with the need for the instance-shutdown method minor nit rest of the code looks good 👍 nice catch sorry for the inadvertent bug and glad it was a relatively simple fix ||  
4024,1,0,0,0,0,0,1,0,1x: update dooneach(observer) javadoc fixes the documentation problem reported in #3721 nice improvement 
4026,1,0,0,0,0,0,1,0,1x: expand and explain cache() in more detail this pr rephrases the `cache` documentation a bit and adds workaround for stopping and forgetting the cached valuesrelated: #3007 👍 this obviously isnt related to that but `testreplaysubjectconcurrentsubscriptions` failed in ci || thanks will look into it before merging this could be a bug due a pattern they share || nothing obvious so far the test passes for me locally when run 1000 times will investigate it further through #4028 ||
4034,1,0,0,0,0,0,1,0,1x: distinctuntilchanged with direct value comparator - alternative alternative implementation to #4001 lgtm  thanks jake for the review! || 
4036,1,0,0,0,0,0,1,0,1x: added zip function with observable array as discussed in #4035 with @akarnokd thanks! almost forgot please also add a unit test that verifies this overload works with 0 1 or a couple of sources (you can add a unit test that for example loops from 0 to 31 generates an array with that many simple sources and checks if all source values actually zipped into the final value) || @akarnokd sorry for the delay i just added tests for 0 1 and multiple array sizes let me know if thats ok ||  
4051,1,0,0,1,0,1,1,0,1x: fix replaysubject anomaly around caughtup by removing that optimization adding the backpressure support to `replaysubject` exposed a race condition around the `caughtup` optimizationthe problem occurs when the source thread has caught up after `drain()` returned true but at the same time a concurrent `drain()` starts running (due to a subscribe() process finishing or requesting on top of the previous `longmax_value`) this concurrent drain may think the replay hasnt started yet (by finding `rpnode` null) or seeing that the buffer has more elements (that may get double emitted)the current solution is to remove this optimization until we come up with a correct optimizationrelated: #4028  
4053,1,0,0,1,0,0,1,0,2x: convert schedulersupport annotation to accept a string value closes #4052   i meant to include in the pr description that i removed the `single` value it was unused and the javadoc didnt make it clear as to what the exact usage would be anyway || no problem can be added later if necessary although `singlescheduler` is not (planned to be) a default for any operators right now ||
4063,1,0,0,0,0,0,1,0,1x: scan & reduce give javadoc about unsharing the initialvalue replacement for #3959  **  this to not get in conflict with other prs targeting `observable` ||
4069,1,0,0,1,0,1,1,1,remove second type parameter from subject and flowprocessor closes #4056  
4070,1,0,0,0,0,1,1,1,2x: merge serialdisposable and multipleassignmentdisposable closes #4057 although doesnt address the name of the class   excellent :+1:> although doesnt address the name of the classno problem ||
4102,1,0,0,1,0,1,1,1,2x: expose isdisposed method on disposable this is a fairly "dumb" addition theres lots of room for follow-up improvement in the utilization of base helper classes and even removing some now-duplicated state managementcloses #4075 there are a bunch of compilation errors:  || probably missing imports i have to edit those by hand in each file so thediffs dont go wildon fri jun 24 2016 at 2:59 am david karnok notifications@githubcomwrote:> there are a bunch of compilation errors:>  > —> you are receiving this because you authored the thread> reply to this email directly view it on github>  or mute the thread>   ||   :+1: thanks  ||
4139,1,0,0,1,0,1,1,1,2x: fix flaky tests this pr should fix some test timing out otherwise sensitive to thread hiccups#4138#4109#4054   
4139,1,0,0,1,0,1,1,1,2x: fix flaky tests this pr should fix some test timing out otherwise sensitive to thread hiccups#4138#4109#4054   
4139,1,0,0,1,0,1,1,1,2x: fix flaky tests this pr should fix some test timing out otherwise sensitive to thread hiccups#4138#4109#4054   
4140,1,0,0,0,0,1,1,1,1x: change completablesubscribe(onerror oncomplete) to (oncomplete onerror) closes #3851 closes #4137 actually i can deprecate old one and add new one as overload it will have less impact on user code because only calls like `subscribe(actionsempty() actionsempty())` will be ambiguous to the compilerthoughts? ||    dynamic languages have trouble with the two methods lets only have 1 method || 
4140,1,0,0,0,0,1,1,1,1x: change completablesubscribe(onerror oncomplete) to (oncomplete onerror) closes #3851 closes #4137 actually i can deprecate old one and add new one as overload it will have less impact on user code because only calls like `subscribe(actionsempty() actionsempty())` will be ambiguous to the compilerthoughts? ||    dynamic languages have trouble with the two methods lets only have 1 method || 
4154,1,0,0,0,0,1,1,0,ability to create custom schedulers with behavior based on composing operators based on #4115allows the use of operators for controlling the timing around when actions scheduled on workers are actually done this makes it possible to layer additional behavior on an existing `scheduler` the main parameter is a function that flattens an `observable<completable>` into just one `completable` there must be a chain of operators connecting the returned value to the source observable otherwise any work scheduled on the scheduler will not be executedwhen `schedulercreateworker()` is invoked a `completable` is onnextd to the combinator to be flattened if the `completable` is not immediately subscribed to an calls to `workerschedule()` are buffered once the `completable` is subscribed to actions are then scheduled on the actual scheduler when the `worker` is unsubscribed the `completable` emits an oncomplete and triggers any behavior in the flattening operator the `observable<completable>` and all `completable`s give to the flattening function never onerrorslowing down the rate to no more than than 1 a second``` java scheduler slowsched  new schedulewhen(workers -> {    // use concatenate to make each worker happen one at a time    return completableconcat(workersmap(worker -> {        // delay the starting of the next worker by 1 second        return workerdelay(1 timeunitseconds)    })) } schedulerscomputation())```limit the amount concurrency two at a time without creating a new fix size thread pool:``` java scheduler limitsched  new schedulewhen(workers -> {    // use merge max concurrent to two at a time    return completablemerge(workers 2) } schedulerscomputation())``` this test changes its timing pattern when run on one of the merging-customization of this scheduler:``` java@testpublic void fasttasks() {    final scheduler sched  new schedulewhen(new func1<observable<completable> completable>() {        @override        public completable call(observable<completable> workers) {            return completablemerge(workers 2)        }    } schedulerscomputation())    observablerange(1 4)flatmap(new func1<integer observable<string>>() {        @override        public observable<string> call(final integer v) {            return observableinterval(500 timeunitmilliseconds sched)            take(10)map(new func1<long string>() {                @override                public string call(long u) {                    return v + " refresh " + u                }            })        }    }    )    timeinterval()    toblocking()    subscribe(new action1<timeinterval<string>>() {        @override        public void call(timeinterval<string> v) {            systemoutprintln(v)        }    })}```what i get is that for the first 5 seconds i get `1 refresh x` and `2 refresh x` in 500 ms intervals but after thet all the `3 refresh x` and `4 refresh x` gets printed instantly```timeinterval [intervalinmilliseconds515 value2 refresh 0]timeinterval [intervalinmilliseconds0 value1 refresh 0]timeinterval [intervalinmilliseconds500 value1 refresh 1]timeinterval [intervalinmilliseconds0 value2 refresh 1]timeinterval [intervalinmilliseconds500 value2 refresh 2]timeinterval [intervalinmilliseconds0 value1 refresh 2]timeinterval [intervalinmilliseconds500 value2 refresh 3]timeinterval [intervalinmilliseconds0 value1 refresh 3]timeinterval [intervalinmilliseconds485 value2 refresh 4]timeinterval [intervalinmilliseconds0 value1 refresh 4]timeinterval [intervalinmilliseconds516 value2 refresh 5]timeinterval [intervalinmilliseconds0 value1 refresh 5]timeinterval [intervalinmilliseconds486 value1 refresh 6]timeinterval [intervalinmilliseconds0 value2 refresh 6]timeinterval [intervalinmilliseconds500 value1 refresh 7]timeinterval [intervalinmilliseconds0 value2 refresh 7]timeinterval [intervalinmilliseconds499 value2 refresh 8]timeinterval [intervalinmilliseconds0 value1 refresh 8]timeinterval [intervalinmilliseconds500 value2 refresh 9]timeinterval [intervalinmilliseconds0 value1 refresh 9]timeinterval [intervalinmilliseconds516 value3 refresh 0]timeinterval [intervalinmilliseconds0 value4 refresh 0]timeinterval [intervalinmilliseconds0 value3 refresh 1]timeinterval [intervalinmilliseconds0 value4 refresh 1]timeinterval [intervalinmilliseconds0 value4 refresh 2]timeinterval [intervalinmilliseconds0 value4 refresh 3]timeinterval [intervalinmilliseconds0 value4 refresh 4]timeinterval [intervalinmilliseconds0 value4 refresh 5]timeinterval [intervalinmilliseconds0 value4 refresh 6]timeinterval [intervalinmilliseconds0 value4 refresh 7]timeinterval [intervalinmilliseconds0 value4 refresh 8]timeinterval [intervalinmilliseconds0 value3 refresh 2]timeinterval [intervalinmilliseconds0 value4 refresh 9]timeinterval [intervalinmilliseconds0 value3 refresh 3]timeinterval [intervalinmilliseconds0 value3 refresh 4]timeinterval [intervalinmilliseconds0 value3 refresh 5]timeinterval [intervalinmilliseconds0 value3 refresh 6]timeinterval [intervalinmilliseconds0 value3 refresh 7]timeinterval [intervalinmilliseconds0 value3 refresh 8]timeinterval [intervalinmilliseconds0 value3 refresh 9]```if i understand the purpose of this scheduler especially with the `merge(workers 2)` case you want to limit the number of concurrently running tasks however the implementation blocks out further workers from executing anything until a previous worker is released for example given a service that accepts 2 connections per client if i have to periodically execute 3 or more tasks against this service (via the `interval()` above) only the first two would execute periodically in addition the other 2 would slowly pile up tasks in the internal queue and if the associated sequence uses timeout this will make it timeouti think the solution is to use a  thread pool instead: it limits the number of concurrent tasks while allowing all workers to make progressmy second reservation is that since the `schedulewhen` is a self-contained class (unlike operators that need a method in `observable`) this can live in any external library (just like `androidschedulers`) || this isnt intended for long running observables your example is a pathological case rather than scheduling on the outer timer if flatmap and schedule on the inner observables it would not block and all three would be able to runthere are many was to misuse this but if used in a controlled setting of a service library it can be use to protect service from bursts of traffic the main point is to be able to reuse an existing scheduler with some additional behavior rather than having to create new thread pools to enforce rate limits || to address your concern ive changed the api from `ob<comp> -> comp` to `ob<ob<comp>> -> comp` this is a more direct mapping of scheduler of workers of actions that give the user complete control how and when the actions  in the example above the actions from all workers can be merged into one stream of actions and then the merge max (n) concurrent could be applied to the actions to better simulate running on a n threads ||   @akarnokd i think ive addressed all the concerns regrading this pr what can i do help get this experiment merged? || oh sorry was busy with something elseokay lets continue with the experiment :+1:/cc @zsxwing @artem-zinnatullin  || does 👍  mean the pr is merged now? should we wait for a review from @zsxwing and/or @artem-zinnatullin? || lets wait for at least one of them || 👍  for this experiment api just one comment about `synchronized (actionqueue)` || very interesting api @abersnaze! few comments and im 👍 with it || i dont know how i would draw the marble diagram for this one || @abersnaze if all feedback is resolved feel free to merge this pr and if you want post any short description of this addition beyond the ref to this pr || thanks for the feed back || as far as im concerned the feedback cycle hadnt really finished on this im hoping that api changes etc are not out of scope if i raise an issue || my comment about the use of `subscribe()` in the constructor was not addressed should be `unsafesubscribe()` i think || @davidmoten if you have further concerns dont hesitate to open an issue or post a pr the file needs some javadoc tidying up anyway || 
4225,1,0,0,0,0,0,1,0,1x: publishsubject fail-fast when backpressured this pr modifies the `publishsubject` to fail fast if the child subscriber cant keep up therefore instead of some other operator failing somewhere downstream the `missingbackpressureexception` now points to the `publishsubject` instead in addition there were complaints in #3850 that cross-unsubscription doesnt stop another subscriber from receiving events if it comes after the unsubscribe() call in the dispatch loop since `publishsubject` now tracks request - which is the main extra overhead - it is trivial to add the necessary eager check for the unsubscribed statebenchmark comparison (i7 4790 windows 7 x64 java 8u102)( expected this adds some overhead although most noticeably for the mid-range only short-lived publishing is now slightly faster eveninterestingly many benchmarks behave oddly in these 1000s range - we could be hitting some jit threshold while in other benchmarks the warmup iteration numbers keep increasing as jit does its work but here it starts out quite nicely then drops 25% and stays that way im on windows so jmh -perfasm doesnt workif this direction is accepted ill update `behaviorsubject` `timer()` and `interval()` do do the same tracking   4225  **<  
4226,1,0,0,0,0,1,1,1,1x: singleflatmapcompletable addresses #4216 happy to receive feedback on the implementation also should i take the documentation from `flatmapobservable` and adjust it?   4226 also should i take the documentation from flatmapobservable and adjust it?yes || updated the documentation i hope the wording is okay now also im pointing to  which does not exist yet but  @davidmgross already tracked it at  i hope thats okaythanks for the `completableflatmapsingletocompletable` i knew something was missing i also created two more tests that cover some of the previously missing behaviour ||  would it be possible to get this one into 118? || if @zsxwing or anyone from netflix approves it in time || 
4251,1,0,0,0,0,0,1,0,tomap - prevent multiple terminal events support backpressure as per discussion in #4242 if an operator maps an `onnext` emission to an `onerror` emission downstream then it needs be defensive about an `oncompleted` being sent from upstream even if upstream has been unsubscribedincludes three unit tests that failed on the original code the fix also has the side effect of enabling gc of `map` when the factory fails (`onerror` was called on the child not `this` so `map` was not set to null) i thought it supported backpressure could you rewrite it by using `deferredscalarsubscription`? || unrelated test failure:```rxschedulerscomputationschedulertests > testhandlederrorisnotdeliveredtothreadhandler failed    javalangassertionerror: handler should not have received anything expected:<0> but was:<1>        at orgjunitassertfail(assertjava:88)        at orgjunitassertfailnotequals(assertjava:834)        at orgjunitassertassertequals(assertjava:645)        at rxschedulersschedulerteststesthandlederrorisnotdeliveredtothreadhandler(schedulertestsjava:102)        at rxschedulerscomputationschedulerteststesthandlederrorisnotdeliveredtothreadhandler(computationschedulertestsjava:153)``` || > i thought it supported backpressure could you rewrite it by using deferredscalarsubscription?sure || what i might do is fix multiple terminal emissions in  `onsubscribecollect` first and make necessary `done` changes to `deferredscalarsubscriber` in that pr ill follow that with the backpressure fix for `operatortomap` || @akarnokd in terms of releasing a value so can be gcd i thought to modify `deferredscalarsubscriber` in this method so that the field `thisvalue` is set to null just before the call to `aonnext()`:``` javaprotected final void complete(r value) {        subscriber<? super r> a  actual        for () {            int s  stateget()            if (s  no_request_has_value || s  has_request_has_value || aisunsubscribed()) {                return            }            if (s  has_request_no_value) {                r v  value // <--------------------------------                value  null // <--------------------------------                aonnext(v)                if (!aisunsubscribed()) {                    aoncompleted()                }                statelazyset(has_request_has_value)                return            }            thisvalue  value            if (statecompareandset(no_request_no_value no_request_has_value)) {                return            }        }    }```is that ok? || dont review latest change just committed so could work on it from another location || im not sure if its worth it many operators dont really do that because it is also likely the whole chain gets forgotten and gc claims all of them on its own if you want to make sure there is no leak use `onterminatedetach` || could you rebase the whole thing? somehow you picked up changes to master and they show up in the diff ||   4251   - rebased- rewrote to use `deferredscalarsubscribersafe`- use singleton of `defaultmapfactory`- moved to `onsubscribe` to save allocations- added backpressure test  ||  good idea ive updated the pr || 
4261,1,0,0,0,0,0,1,0,1x: concatdelayerror multiple arguments this pr adds multiple arguments to concatdelayerror operatorrelated to: #4152   4261    /cc @artem-zinnatullin @stevegury @zsxwing  ||
4262,1,0,0,0,0,0,1,0,dooneach - reduce allocations report to rxjavahooks as discussed in #4260 - call `rxjavahooksonerror` for secondary errors- reduced allocations (`actionsubscriber` -> `actionobserver` `operator` -> `onsubscribe`)- added 5 unit tests   4262    actionsubscriber usage and removed empty test ta || 
4288,1,0,0,1,1,1,1,1,2x: move exceptions to public area + exceptionhelper related: #4280the `exceptionspropagate` and `exceptionsthrowiffatal` are too useful to be hidden in an internal package so this pr moves them into the public `ioreactivexexceptions` package the terminal atomics related to throwable containers lives in the `exceptionhelper` enum   4288   lgtm 
4297,1,0,1,1,0,1,1,1,2x: rename single base interface types for consistency addresses #4044   4297   lgtm   @jakewharton if you want me to and you havent started yet id continue on that list and rename the other classes / interfaces as well || sure go for it!on sun aug 7 2016 at 1:55 pm niklas baudy notifications@githubcomwrote:> @jakewharton  if you want me too and you> havent started yet id continue on that list and rename the other classes> / interfaces as well> > —> you are receiving this because you were mentioned> > reply to this email directly view it on github>  or mute the thread>   ||
4299,1,0,0,1,0,1,1,1,2x: rename flowable base interface types for consistency addresses #4044 lgtm    4299   
4300,1,0,0,1,1,1,1,1,2x: rename observable base interface types for consistency addresses #4044 there are a large amount of compilation errors || rebased against 2x and re-did the last changes || looks good this time    4300  **< 
4302,1,0,0,1,0,1,1,1,2x: rename completable base interface types for consistency addresses #4044    4302   
4309,1,0,0,0,0,1,1,0,2x: remove unused exceptions in public api as wanted in #4306   4309   /cc @jakewharton  || :+1: if the test changes are acceptable for your setup || 
4317,1,0,1,1,1,1,1,1,2x: rename create to unsafecreate add "safe" create methods this is a proposal to solve #4255 but for 2x and closes #4286 built around one goal: make the `create` methods actually usable by developers!currently the advice given to most developers using 1x is avoid `create` unless you are absolutely 100% sure you understand backpressure and cancellation and even then avoid it if possible this method is a trap that most new developers fall into _the method is named "create" after all so it must be how i create these things!_ i want to make that statement not only correct but advisable (at least when the still-convenient "from" methods are not suitable such as when wrapping callback-based apis)because `observable` `single` and `completable` are backpressure-free this amounts to just suppressing downstream notifications when disposed this doesnt seem too controversialthe most controversial part is that i have renamed `flowablefromasync` to `flowablecreate` thus making it the canonical way for users to create `flowable`s directly im much less opinionated on this change but it felt wrong to have an `flowableunsafecreate` with no associated `create` and `fromasync` is the "safest" version we have   4317   i think its also important to point out i replaced `consumer<asynemitter<t>>` with `flowablesource<t>` for parity with other "safe" `create` method parameter types the unsafe variant still takes a raw `publisher<t>` however ||     ||  
4317,1,0,1,1,1,1,1,1,2x: rename create to unsafecreate add "safe" create methods this is a proposal to solve #4255 but for 2x and closes #4286 built around one goal: make the `create` methods actually usable by developers!currently the advice given to most developers using 1x is avoid `create` unless you are absolutely 100% sure you understand backpressure and cancellation and even then avoid it if possible this method is a trap that most new developers fall into _the method is named "create" after all so it must be how i create these things!_ i want to make that statement not only correct but advisable (at least when the still-convenient "from" methods are not suitable such as when wrapping callback-based apis)because `observable` `single` and `completable` are backpressure-free this amounts to just suppressing downstream notifications when disposed this doesnt seem too controversialthe most controversial part is that i have renamed `flowablefromasync` to `flowablecreate` thus making it the canonical way for users to create `flowable`s directly im much less opinionated on this change but it felt wrong to have an `flowableunsafecreate` with no associated `create` and `fromasync` is the "safest" version we have   4317   i think its also important to point out i replaced `consumer<asynemitter<t>>` with `flowablesource<t>` for parity with other "safe" `create` method parameter types the unsafe variant still takes a raw `publisher<t>` however ||     ||  
4330,1,0,0,0,0,1,1,0,added observableconcat(iterable) see #4329 i also adjusted the test as it was testing the wrong thing before   4330     
4337,1,0,0,0,0,0,1,0,2x: move disposableobserver to public area add some javadocs move `disposableobserver` to `ioreactivexobservers` + some documentationrelated: #4082   4337   :+1:having these in the public api make it seem like `asyncobserver` becomes obsolete in the case where its not managing any additional resources should we rename it to `resourceobserver` (or something) and have it always manage resources? || sure will you do it? || yep! ||
4370,1,0,0,1,0,1,1,1,2x: remove try+optional introduce notification this pr removes the `try` and `optional` classes and (re)introduces `notification<t>`there are several ways to implement it this pr uses the abstract class + private subclasses approach that saves on instance sizerelated discussion: #4365 > this pr uses the abstract class + private subclasses approach that saves on instance sizethis seems like it would prevent a lot of inlining of the simple "is"ers and "get"ers because the callsites become polymorphic instead of monomorphicwhen i check the object layout having two fields in a root object doesnt increase the size because of object padding```$ cat notificationjavafinal class notification<t> {  private static final object completed  new object()  private final t value  private final throwable error  notification(t value throwable error) {    thisvalue  value    thiserror  error  }}$ javac notificationjava$ java -cp :/users/jw/downloads/jol-cli-05-fulljar orgopenjdkjolmain internals notificationobjc[95020]: class javalaunchhelper is implemented in both /library/java/javavirtualmachines/jdk180_92jdk/contents/home/bin/java and /library/java/javavirtualmachines/jdk180_92jdk/contents/home/jre/lib/libinstrumentdylib one of the two will be used which one is undefined# warning: unable to attach serviceability agent you can try again with escalated privileges two options: a) use -djoltrywithsudotrue to try with sudo b) echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope# running 64-bit hotspot vm# using compressed oop with 3-bit shift# using compressed klass with 3-bit shift# warning | compressed references base/shifts are guessed by the experiment!# warning | therefore computed addresses are just guesses and are not reliable# warning | make sure to attach serviceability agent to get the reliable addresses# objects are 8 bytes aligned# field sizes by type: 4 1 1 2 2 4 4 8 8 [bytes]# array element sizes: 4 1 1 2 2 4 4 8 8 [bytes]vm fails to invoke the default constructor falling back to class-only introspectionnotification object internals: offset  size      type description                    value      0    12           (object header)                n/a     12     4    object notificationvalue             n/a     16     4 throwable notificationerror             n/a     20     4           (loss due to the next object alignment)instance size: 24 bytesspace losses: 0 bytes internal + 4 bytes external  4 bytes total``` || oops i wrote my comparison wrong (and left it out of the comment)youre right the individual classes are only 16 bytes (12 header + 4 field) that said 24 vs 16 isnt that big of a deal to gain guaranteed monomorphism || there are other ways of doing it ie single object field + private wrapper for throwables: 16 bytes per onnext and 32 bytes per onerror || true ill leave it up to you though or getting at least bimorphic by having value  null represent oncomplete || updated now we have the smaller size but an instanceof check for every isonnext() and getvalue calls ||   4370   looks good! || 
4371,1,0,1,1,1,1,1,1,2x: move blocking operators into the base classes this pr removes the `blockingflowable` and `blockingobservable` classes and moves the blocking operators into the respective reactive classes and names pre with `blocking`in addition many of the mentions of `flowable` has been replaced with `observable` in `observable`related: #4366   4371   lgtm 
4421,1,0,0,0,0,0,1,0,2x: fixes cleanups renames changes:- fix spelling mistakes- more consistent parameter naming scheme based on #1353 (but incomplete rc2)- fix bugs due to wrong variable naming- compact logic expressions- fix `completabledoafterterminate` not called the right time- `onerrorreturnvalue` renamed to `onerrorreturnitem`@davidmgross once this pr has been merged it would be great you submitted one that has `//todo` markers on those lines that need attention the naming scheme you suggested doesnt come intuitively to me so i may skip many of them without the markers   4421   
4422,1,0,0,0,0,1,1,0,2x: add subscribewith to get back the subscriber/observer fluently this pr adds the `subscribewith` methods to the base reactive types to mainly help with the 1x to 2x changeover as 2x `subscribe(subscriber)` return void instead of the resource/cancellation/unsubscription type `disposable` see the javadocs and the unit test for example userelated: #4400   4422   
4425,1,0,0,0,0,1,1,1,1x: remove completable prefix from nested interfaces move its subscription to top-level this is only the `completable` part of #4420 it does not make `completablesubscriber` an abstract class nor create `singleoperator` [compiler error]( ||   4425   looks okay what about the `@deprecated` markers? || oh sure ill add them in real quick i wasnt sure on your stance on them but i think itll make migration easier || yes having deprecated markers is more forgiveable than lacking the entire type i dont know how extensively `completable` is in use by other libraries right now (beyond rxjavareactivestreams reactors converter retrofit`) || updated! ||  || compilation issue resolved || i know  still waiting for a second approval || okay lets have this one can complain anytime later ||
4436,1,0,0,0,0,0,1,0,2x: maybe for lazy optional in #4321 i hit on the problem of needing a lazy object that could either be zero or one value in that issue the idea of switching the return value of `reduce(r func2<rtr>)` from `observable<r>` to `single<r>` because that operator can only ever produce an observable that emits exactly one value the problem was that `reduce(func2<ttt>)` could not be changed to `single<t>` because the source observable could be empty and therefore not produce one and only one valueto solve this problem i mentioned we could create a lazy type that represents either 1 or no value could fill the gap between `completable` and `single<t>`this pr is for the introduction of the `maybe<t>` type you referenced java 8 types in your code || my problem with adding another base type is the increased mainte ce cost currently we have 3 + 4 types in the major versions and it is likely adding a new operator overload or making a fix has to be done for all of them im one-man armying rxjava for a considerable time now but i have my limits therefore my suggestion is that you have this `maybe` as a separate library that depends on rxjava 2 but rxjava 2 doesnt depend on it since rxjava 2 offers fluent conversion method(s) it should be only a small inconvenience to convert to `maybe`:``` javaflowable<integer> source  flowablerange(1 10)maybe<integer> mb  sourceto(maybereduceflowable((a b) -> a + b))mbfilter(v -> false)subscribe(    systemout::println throwable::printstacktrace () -> systemoutprintln("done"))mbtoflowable()subscribe(    systemout::println throwable::printstacktrace () -> systemoutprintln("done"))``` || as i mentioned my plans were to greatly increase the coupling between observable & flowable to single & maybe by having the various operators that return exactly 1 or sometimes 1 value to these two types ||   4436 type exactly for this purpose i suggest you try that first || im not strictly opposed because> my plans were to greatly increase the coupling between observable & flowable to single & maybe by having the various operators that return exactly 1 or sometimes 1 value to these two typesappeals to me but i dont have a really strong feeling without using it more || okay then lets merge this and see how it works out || please dont post prs targeting maybe - im working on cleaning it up a bit (plus a few other classes if i find something wrong) the code copied from an older commit of the other types || 
4442,1,0,0,1,0,1,1,1,1x: cleanup javadoc completablefromemitter - add javadoc to `asyncemitterbackpressuremode` (#4199)- deprecate `observablefromasync` add `observablefromemitter` instead (#4255)- add `completablefromemitter()` (#4356)- add missing placeholder `@since` tags- fix some generics error `rxjavahooks`- add race helper to `testutil`- fix javadoc warnings   4442   
4442,1,0,0,1,0,1,1,1,1x: cleanup javadoc completablefromemitter - add javadoc to `asyncemitterbackpressuremode` (#4199)- deprecate `observablefromasync` add `observablefromemitter` instead (#4255)- add `completablefromemitter()` (#4356)- add missing placeholder `@since` tags- fix some generics error `rxjavahooks`- add race helper to `testutil`- fix javadoc warnings   4442   
4442,1,0,0,1,0,1,1,1,1x: cleanup javadoc completablefromemitter - add javadoc to `asyncemitterbackpressuremode` (#4199)- deprecate `observablefromasync` add `observablefromemitter` instead (#4255)- add `completablefromemitter()` (#4356)- add missing placeholder `@since` tags- fix some generics error `rxjavahooks`- add race helper to `testutil`- fix javadoc warnings   4442   
4458,1,0,0,0,0,0,1,0,2x: rename observable and single #dooncancel to #doondispose #4456completable already used doondispose() however i renamed the arguments to match observable and single the diff for observable doesnt show but the offline-comparison only lists 30-40 lines changes did you run some whitespace cleanup? || @akarnokd whoops youre right sorry auto formatter seems to have changed some whitespaces ill revert that ||   4458    this update is missing in release notes on github please remember to mention such changes in the future ||
4460,1,0,0,0,0,1,1,1,1x: completable add dooneach first part of #4457 is it okay that i reused notification like that?also are there any java 6 generics missing? it would be nice if this project was set up to target java sdk 6 as my default seems to be java 8 and i dont get any errors shown in the ide okay but you have [generics problem]( || alright its  now ||   4460  **< 
4461,1,0,0,0,0,0,1,0,1x: single add dooneach really not that happy with `onnotificationcall(notification<t>createonnext(t))` do you guys have any other way of doing this? theres no way of creating a notification that has the `oncompleted` plus a value a new one could be introduced there though also the `dooneachsuccess` test feels clunkyalso why does single when using the `do` methods does the job by using an observable? and later converting it back to a single again is it due to the way single was implemented in 1x? with completable there is no converting of back and forth neededjavadoc will follow once we sorted out the few nits here4457   4461 fails although im not quite sure what the purpose of that test is also it seems a bit off to me can you give some insights there? || looks like removing the toobservabletosingle no longer wraps the subscriber into a safesubscriber and the test just crashes with a different exception || no exception is being thrown at all || can you single step the test? in the orginal dooneach it has throwiffatal an throworreport you missed btw || 
4466,1,0,0,0,0,0,1,0,1x: deprecate notificationcreateoncompleted 4462 it might just as well shine some light into which method should be used and explain why there are 2   4466  
4488,1,0,0,0,0,0,1,0,2x: add new methods to maybe observable and single from 4481 this pr adds just the new methods from #4481 to allow a much cleaner change of return types later on    4488   updated with corrections ||
4503,1,0,0,0,0,0,1,0,2x: add system properties to adjust thread priorities of schedulers this pr adds the ability to specify the default thread priorities of `computation()` `io()` `newthread()` and `single()` schedulers via system properties ive added the property names to the `schedulers` javadocrelated: #4389   4503   thanks! 
4504,1,0,0,0,0,0,1,0,2x: add disposable observer for maybe completable & single also any reason the dispoable is called `s`? is it still from the subscription time?4501 seems unrelated:```ioreactivexinternaloperatorsobservableobservablerefcounttest > testrepeat failed    javalangassertionerror: error(s) present: [javalangillegalstateexception: onsubscribe not called in proper order] (latch  1 values  51 errors  1 completions  0)        at ioreactivexobserverstestobserverfail(testobserverjava:363)        at ioreactivexobserverstestobserverassertnoerrors(testobserverjava:411)        at ioreactivexinternaloperatorsobservableobservablerefcounttesttestrepeat(observablerefcounttestjava:195)        caused by:        ioreactivexexceptionscompositeexception            at ioreactivexobserverstestobserverfail(testobserverjava:364)             2 more            caused by:            ioreactivexexceptionscompositeexception$compositeexceptioncausalchain: chain of causes for compositeexception in order received >                caused by:                javalangillegalstateexception: onsubscribe not called in proper order``` || yep ill fix that next - started to become annoying to me too ||
4513,1,0,0,0,0,1,1,1,2x: fix switchmap bad cancellation both `switchmap` implementations didnt properly cancel the current inner consumer (but instead cancelled the outer connection only)reported in #4512    4513  **< 
4516,1,0,0,0,0,1,1,1,2x: fix singleusing add unit tests and coverage ive forgotten to create a branch so the first part of todays coverage work [landed in 2x direct]( removed unused methods from various classes- compacted `spscarrayqueue`- added null checks to `spsclinkedarrayqueueoffer()` and `mpsclinkedqueueoffer()`-  `resourceobserver` not calling `onstart`- added direct notificationlite-emission methods to `appendonlylinkedarraylist` updated `serializedobserver` and `serializedsubscriber` to use it directly instead of the former indirection- `testobserverisdisposed` now reports true if terminal events were received (#4514)- `resourcesubscriber` to use `subscriptionhelper`s deferred subscription/requesting management- added unit tests to cover `disposablexobserver`s- `serializedobserver` and `serializedsubscriber` now have proper unit tests eachthis current pr fixes `singleusing` not properly managing the resource and adds unit tests to verify the behavior along with a few extra coverage improvements    4516  
4518,1,0,0,0,0,1,1,0,2x: add missing resource observer for maybe completable & single and adjust some javadoc 4517   4518   it might be worth considering removing the protected `cancel()` methods as they are duplicates of `dispose` for `resourcesubscriber` i dont know because it works with `subscriptioncancel()` but also is a `disposable` so `dispose()` is there as well || so should i remove the `cancel()` method on all `resource*observer`? || @jakewharton your opinion on the removal? || im supportive of removing `cancel()` i much prefer when theres only one way to do something! || 
4522,1,0,0,0,0,1,1,1,observable/flowable/completable/singledelay should always call onerror on the provided scheduler 4521   4522    great job applying the changes to all of the base types! ||
4525,1,0,0,0,0,0,1,0,2x: fix generics t in zip & combinelatest 4524test for combinelatest fill follow   4525  **< 
4580,1,0,0,0,0,0,1,0,rename asyncemitter to emitter as per discussion in #4577 renaming `asyncemitter` to `emitter` via deprecationthere is a catch though `completableemitter` is correctly named now and depends on `asyncemitter` via the method:``` java void setcancellation(asyncemittercancellable c)```when can we break the api of that class?    4580   thanks for review @akarnokd  i take it we have to wait for 13 to break the api of experimental `completableemitter`? || deleting experimental apis has to wait one patch version so 121 will have both and 122 can remove the asyncemitter || ok ill patch again once 121 is outon thu 22 sep 2016 21:25 david karnok notifications@githubcom wrote:> deleting experimental apis has to wait one patch version so 121 will> have both and 122 can remove the asyncemitter> > —> you are receiving this because you authored the thread> reply to this email directly view it on github>  or mute the thread>   || /cc @jakewharton @artem-zinnatullin  || make the cancelable interfaces extend each other as wellon thu sep 22 2016 6:33 pm dave moten notifications@githubcom wrote:> ## _@davidmoten_ commented on this pull request> > in src/main/java/rx/asyncemitterjava>  > >   */> >  @experimental> > +@deprecated> >  public interface asyncemitter<t> extends observer<t> {> > cannot extend emitter because of two versions of cancellable would break> existing asyncemitter use> > —> you are receiving this because you were mentioned> > reply to this email directly view it on github>  or mute the thread>   || > make the cancelable interfaces extend each other as wellgood idea  um i dont think its worth it juggling with inheritance of these interfaces straight after next release im just going to delete the deprecated stuff || ive added a `@deprecated` annotation to `completableemitter` let me know if you guys still want the interface inheritance business || forgot to move `cancellable` to `rxfunctions` thats done now || thanks for working this out! ||
4585,1,0,0,1,0,1,1,0,2x: evaluate schedule initialization via callable this implements the solution proposed in #4572 - to initialize the schedulers via a callable rather than directly via a value   4585   @akarnokd correct me if im wrong but in order to avoid the evaluation of the default scheduler instance when it is being overridden i still need to change the `oninit[single|io|new|computation]handler` signatures to be `function<callable<scheduler> scheduler>` as per -```    static volatile function<callable<scheduler> scheduler> oninitsinglehandler```otherwise the invocation of `initsinglescheduler` will cause the evaluation of the default value to pass it as a parameter to the overriding/transforming function: `oninitsinglehandler` || yes you still need `callable` as the indirection but the inner class will be evaluated only if `call` is actually invoked || ive added the remaining lazy initializationive also fairly aggressively enforced non-null in the associated functions for example:``` javapublic static scheduler initioscheduler(callable<scheduler> defaultscheduler) {    objecthelperrequirenonnull(defaultscheduler "scheduler callable cant be null")    callable<scheduler> scheduler> f  oninitiohandler    if (f  null) {        return callrequirenonnull(defaultscheduler)    }    return applyrequirenonnull(f defaultscheduler)}```however to me this seems slightly out of place / over the top is that enforcement necessary or should the resultant null scheduler be left unasserted and left to the eventual nullpointerexception when the scheduler is used? either way im happy to keep or remove that based upon review feedback || aggressive input validation is never over the top if you defer checkingthen the stacktrace tells you nothing about what actually caused the brokenstateon sun sep 25 2016 7:09 am peter tackage notifications@githubcomwrote:> ive added the remaining lazy initialization> > ive also fairly aggressively enforced non-null in the associated> functions for example:> > public static scheduler initioscheduler(callable<scheduler> defaultscheduler) {>     objecthelperrequirenonnull(defaultscheduler "scheduler callable cant be null")>     callable<scheduler> scheduler> f  oninitiohandler>     if (f  null) {>         return callrequirenonnull(defaultscheduler)>     }>     return applyrequirenonnull(f defaultscheduler)> }> > however to me this seems slightly out of place / over the top is that> enforcement necessary or should the resultant null scheduler be left> unasserted and left to the eventual nullpointerexception when the scheduler> is used? either way im happy to keep or remove that based upon review> feedback> > —> you are receiving this because you commented> > reply to this email directly view it on github>  or mute the thread>   || @akarnokd all done as far as i am concerned do i need to anything else for this to be merged?  || i was waiting for you to settle with the implementation thanks for the contribution || 
4586,1,0,0,0,0,1,1,1,2x: add error assertion with predicate to testsubscriber and testobserver added support for error assertions with to testsubscriber requested in #4498 to support custom error evaluation removes the need to implement equals and hashcode in exceptions could you do it for testobserver as well? || sure i will update the pr ||   4586  
4629,1,0,0,0,0,1,1,1,2x: add completablefromrunnable() addresses #4628> theres `maybefromrunnable` but `completable` is missing this method   4629    thanks! ||
4636,1,1,0,1,1,1,1,1,update mockito to 210-rc2 equivalent of #4634  but now for the 2x branch the test `ioreactivexmaybemaybetest > onterminatedetach` seems to be failing claiming there is a memory leak i sadly have no experience with this test to fix it || that test is a bit flaky (maybe the new mockito increased the base memory usage?) ill fix that test and rerun this one ||     thanks a lot and enjoy   ! || fyi mockito 210 has been released which is equivalent to 210-rc2 once again thanks a lot for using mockito    ||
4641,0,0,0,0,0,0,1,0,1x: safesubscriber not to call rxjavahooks before delivering the original error before the introduction of `rxjavahooks` the `safesubscriber_onerror` called the original error handler with the exception it received which was by default an empty handler the default `rxjavahooksonerror` behavior however is to signal errors to the uncaught exception handler of the caller thread which leads to unnecessary logging or app crashes even though the error itself is to be handled properlythis pr restores the `safesubscriber_onerror` to skip the `rxjavahooks` and call the original handler directy so old tracking code should still get all safe error while newer hooking doesnt get calledrelated: #4332   4641   /cc @dlew || lgtm thanks for doing this ||
4645,1,0,0,1,0,1,1,0,2x signal npe observableamb flowableamb this pr addresses #4640   4645  **< 
4647,1,0,0,1,0,1,1,1,2x: merge ambarray and ambiterable into amb for single maybe and completable types this pr addresses #4633- merge singleambarray and singleambiterable operators into singleamb- merge maybeambarray and maybeambiterable operators into maybeamb- merge completableambarray and completableambiterable operators into completableamb   4647  **< 
4651,1,0,0,1,0,1,1,0,switch maybe and single to use their transformers in compose() 4650 whoops forgot to update the tests will update in a sec || intellij user i presume? || indeed does (i presume 😉) eclipse do something to protect against this? || eclipse has an error view which doesnt obscure the project structure plus when one shows the breadcrumbs they get error icons indicating theres still something wrong (also the project tree gets error icons) so it is much harder to miss these kinds of errors  ||   4651   interesting ill have to check that out! ||
4654,1,0,0,0,0,0,1,0,upcast concurrenthashmap to map to avoid compatibility issue resovles #4653see http://stackoverflowcom/a/32955708/61158   4654  
4681,1,0,0,0,0,1,1,0,2x: fix flowable + single elementat and elementatorerror operators on empty sources this will 4680- elementatorerror(1) on an empty source just leaves the new single hanging without signalling onerror()- elementat(1) on an empty source just leaves the maybe hanging without signalling oncomplete()- i also noticed that elementat() with a default value on an empty source did not work either   4681   you may have to check the build and restart it a few times if it fails with `jacocotestreport` ||
4686,1,0,0,0,0,1,1,0,2: fix flatmapx over-cancellation in case of an inner error a non-delayed error set the cancellation flag and thus any subsequent drain would just quit instead of delivering the error(and while im at it ill try to figure out a way to not get killed by oomkiller)reported in #4684  
4687,1,0,0,0,0,1,1,1,2x: add observablerangelong & flowablerangelong will 4683- adds observablerangelong()- adds flowablerangelong()both implementations are copied same for the unit testswhat should we do about the range overflow check? we could use bigdecimal to check that   4687  
4690,1,0,0,0,0,1,1,1,2x: basetestconsumer add assertvalueat(index predicate<t>) 4688- adds assertvalueat(index predicate) to basetestconsumer   4690  **< 
4710,1,0,0,1,0,1,1,0,2x: remove checked exceptions from transformer interfaces these functions are for transforming the stream shape not doing work any operation that would throw a checked exception should happen inside the stream not when shaping itcloses #4709   4710  
4716,1,0,0,0,0,1,1,1,1x: fix subscribe(action1 [ action1]) to report isunsubscribed the lambda version didnt report `isunsubscribed()` as before because of the removal of the `safesubscriber` wrapping this pr makes sure it reports consistently againrepored in: #4715note that there is no `unsafesubscribe(singlesubscriber)` so a regular `subscribe(singlesubscriber)` by default wont report `isunsubscribed()  true` unless the implementation of `onsuccess` and `onerror` - controlled by the user - doesnt call `unsubscribe` on itself   4716  **< 
4729,1,0,0,0,0,1,1,0,merge flowableemitterbackpressuremode into backpressurestrategy this is the implementation of #4727   4729   i have implemented the changes from the code commentsill keep in mind to rely on code coverage in the futureshould i reply to the review comments directly ? || no need in this case 
4747,1,0,0,1,0,1,1,1,2x: distinctuntilchanged to store the selected key instead of the value fix `distinctuntilchanged` to store the selected key instead of the input valuereported in #4743  
4751,1,1,0,1,1,1,1,1,2x: fix flowableconcatmapeager hang due to bad request management `flowableconcatmapeager`s drain loop when encountering a finished inner jumped back to the beginning of the loop but disregarded the potentially changed request amount and just stopped emitting the fix is to use the typical request management approach of reading the current request at the beginning of the loop and then committing the emission amount before trying to leave the looprelated: #4620in addition `testhelperasserterror` has been changed to attach the whole unexpected exception to the `assertionerror`   4751  
4757,1,0,0,0,0,0,1,0,1x: add cache() to single #4702uses the same test as the observable one   4757   sorry im late to the party here this seems to be rxjava1x only is this going to reach 2x ? || its in 2 || uupps right ! thanks ! ||
4767,1,0,0,0,0,1,1,0,2x: rename backpressurestrategynone to missing as discussed in #4643   4767  **< 
4783,1,0,0,0,0,1,1,1,2x: fix observablerepeatwhen & retrywhen not disposing the inner the `observer` that is subscribing to the `observable` returned by the handler function was not properly linked to the disposing of the end observer this pr fixes it by making that `observer` do async `disposable` management and make sure the end `observer` receives a disposable list with both the main and the handler `disposable`sthe `flowable` versions worked properly but added unit tests to them regardlessreported in #4782   4783  
4810,1,0,0,0,0,0,1,0,subtle change in completables documentation for retrywhen small change as discussed in #4809   4810  
4828,1,0,0,0,0,0,1,0,changing inner classes to package-private to  in #4826   4828  
4830,1,0,0,0,0,1,1,1,1x: completabledoafterterminate to run after onerror as well doafterterminate was intended to call the callback after either oncompleted or onerror but somehow missed that behavior in 1xrelated: #4822   4830  **< 
4858,1,0,0,0,0,1,1,0,2x: add maybeflatmapsingleelement returning maybe this pr adds the `maybeflatmapsingleelement()` operator that returns a `maybe` and completes if the source completes unlike `flatmapsingle` where the returned `single` signals `nosuchelementexception`related #4857   4858  
4873,1,0,0,0,0,1,1,1,2x: testobserver shouldnt clear the upstream disposable on terminated `testobserver` replaced the upstreams `disposable` with the disposed-sentinel when it got a terminal event (unlike `testsubscriber`) and there seems to be a need for triggering `dispose` in some upstream even after that this pr changes this behavior and also updates unit tests that expect `isdisposed()` true without actually calling `dispose()`related #4872   4873  
4881,0,0,0,1,0,1,1,0,add checkreturnvalue annotation first draft on thisso far i have only annotated `subscribewith()` and `test()` methodsi checked this against error prone and their [check]( is able of picking up the rxjava annotationhow do you feel if i extend `basetypeannotations` to test for `@checkreturnvalue` too?related #4878   4881   would you manually ignore methods like `disposable subscribe()`? || @vanniktech see  || @artem-zinnatullin weird somehow findbugs didnt pick it up though could be a configuration error on my sideid argue that not annotating `diposable subscribe()` is fine however i feel like `disposable subscribe(consumer<t>)` and the others should be annotated i personally almost never use subscribewith and prefer the variations with lambdaswere on the same point that static factory methods and operators such as flatmap first() last() etc should be annotated right? if so id apply those and then we can see which might need an annotation too || @akarnokd added the `@checkreturnvalue` annotation to all public api methods of `flowable` `maybe` `single` `observable` and `completable` except for private methods void methods and the `disposable subscribe()` method is that okay now? || yes/cc @jakewharton  ||
4884,1,0,0,0,0,1,1,1,1x: enable testscheduler with  osecond periodic scheduling the default periodic scheduling code accessed the current worker time as milliseconds which prevents running microsecond and  osecond scale unit tests with testscheduler as its internal  osecond resolution time is always converted losing precisionthis pr introduces the internal `scheduleperiodichelper` class moves the default scheduling code into a static method and defines a `now osupplier` interface that is now implemented by testschedulerworker to return the current  o time the default `workerscheduleperiodically` delegates to this static method and given a `null` `no osupplier` the `workernow()` is converted to  oseconds as usualrelated: #4883   4884  
4911,1,0,0,0,0,1,1,1,2x: fix & update observablerepeatwhen and retrywhen (again) this pr fixes the `observablerepeatwhen` not completing properly if the handler completes in addition the `observableredo` has been split to `observableretrywhen` and `observablerepeatwhen` just like their `flowable` counterpart and are now they use a less convoluted algorithmrelated: #4909 i dont know why the travis-ci/push still shows up ||   4911  
4921,1,0,0,0,0,0,1,0,2x: fix testsubscriber/observer message texts fix the wrong messages in `testsubscriber` and `testobserver`related: #4920   4921  
4924,1,0,0,0,0,0,1,0,2x: change completable to completablesource changing `completable` to `completablesource` also found one other wrong spot that i  within this pr4923   4924  
4927,1,0,0,0,0,1,1,1,2x: fix timer() ise due to bad resource mgmt both `observabletimer()` and `flowabletimer()` could report `illegalstateexception` because if the delayed task completed before the tasks `disposable` was set the `setonce` found a non-null non-terminal reference already setrelated: #4926   4927  
4932,1,0,0,0,0,1,1,0,2x: add safeguards to generate() `flowablegenerate()` and `observablegenerate()` lacked the safeguards that were present in 1x this adds those and adds extra state cleanuprelated: #4931   4932  **< 
4943,1,0,0,0,0,1,1,0,2x: fix publish(function) not replenishing its queue i was working on converting the [monte carlo pi benchmark]( to rxjava 2 and it turned out i forgot to replenish the internal queue of `publish(function)` in case the upstream was not sync-fuseablethis pr fixes the replenishment problem for non-fused and async-fused sources by requesting after 75% consumptionin addition if an inner subscriber cancelled while it was at request 0 the other inner subscribers might not have resumed drainingive also  two unit tests with wrong timeout unit of measure that randomly failed the tests on a slow machine or travis (#4902)   4943  
4945,1,0,0,0,1,1,1,1,2x: fix timeout with fallback not cancelling the main source this pr fixes the lack of dispose/cancel call towards the upstream in the timed+fallback `timeout` operator versionin addition the selector version received similar unit tests to ensure they work properly (they did)related: #4944   4945  
4955,1,0,0,0,0,1,1,1,2x: add sample() overload that can emit the very last buffered item the `sample()` operator in 1x has been changed to always emit the very last buffered item before completion for [113]( [discussion]( [pr]( change has been forgotten in 2x (because 2x `sample()` was implemented several months earlier) but unlike 1x i dont want to break existing use cases hence the introduction of 6 overloads (3 for each base type) that lets one define the "tail" behaviornote that the associated marble diagrams are inconsistent with the operators implemented we need a new diagram where the timed-sample also emits the last value:( one new diagram where the sampler-sample doesnt emit the last value:![image]( default sampler-sample should use this and the `emitlast  true` version can use the current diagram(i dont have a mac thus cant run omnigraffle)related: #4952   4955  
4957,1,0,0,0,0,1,1,0,2x: fix lambdaobserver calling dispose when terminating this pr changes the `lambdaobserver` to not dispose the upstream when it receives a terminal event the `lambdasubscriber` has been previoulsy updated but apparently not syncedreported in #4956this pr fixes 2 unit test methods of `flowableignoreelements()` as they were not actually testing the operator (discovered when the `observableignoreelements()` initially failed after the patch to `lambdaobserver`)   4957  
4962,1,0,0,0,0,1,1,0,2x: fix singletakeuntil() other triggering twice this pr fixes the double termination of `singletakeuntil(publisher)` when the `other` fires an item and then completes while ignoring the cancellation in between trying to signal a `cancellationexception` again which is routed to the `rxjavapluginsonerror` and crashing on androidin addition the `maybetakeuntil()` received a unit test verifying this doesnt also happen to itrelated: #4961   4962  **< 
4972,1,0,0,0,0,1,1,0,improve compose() generics 4950i tested and built with the added tests on java 6 7 and 8 not sure if you want to keep them in before merging since theyre not really functional in nature just there to make sure they compile side-note: gets even better on java 8 which removes the need for a type argument at all in those examples!<img width"680" alt"screen shot 2017-01-08 at 2 58 20 am" src" ||   4972    
4982,1,0,0,1,0,1,1,0,2x: fix observableconcatmapeager bad logic for immediate scalars the operator `observableconcatmapeager` had a bad optimization targeting scalar and callable sources and emitted their values immediately even if it wasnt that particular sources turn for itthe `flowable` is not affected added unit tests for bothreported in #4981   4982  
4987,1,0,0,1,0,1,1,1,2x: make obscombinelatest consistent with flowable + doc cornercase this pr fixes `observablecombinelatest` to be consistent with `flowablecombinelatest` by not subscribing to additional input sources if the operator reached a terminal state due to a valueless source (that completes or errors) in addition such early termination didnt properly cancel the other sources when `delayerrors  true`ive also extended the documentation on the overloads to warn about empty sources that will terminate the operator even with `combinelatestdelayerror` and thus subscription side-effects may not happenthere is a related issue #4414 where the operator should fully consume each input source no matter what and terminate when all terminate im still considering what would be the best way to introduce thisreported in #4986   4987  **<  
4987,1,0,0,1,0,1,1,1,2x: make obscombinelatest consistent with flowable + doc cornercase this pr fixes `observablecombinelatest` to be consistent with `flowablecombinelatest` by not subscribing to additional input sources if the operator reached a terminal state due to a valueless source (that completes or errors) in addition such early termination didnt properly cancel the other sources when `delayerrors  true`ive also extended the documentation on the overloads to warn about empty sources that will terminate the operator even with `combinelatestdelayerror` and thus subscription side-effects may not happenthere is a related issue #4414 where the operator should fully consume each input source no matter what and terminate when all terminate im still considering what would be the best way to introduce thisreported in #4986   4987  **<  
5002,1,0,1,1,0,1,1,1,2x: add scheduler creation factories 4993this is a pretty vanilla copy from rxjava 1s implementation note that i had to tune newthread scheduler to not be a singleton to support thiswe had talked about borrowing from project reactors apis for different overloads let me know if you think we should add more fine-grained controls through these one other thing im worried about - is `schedulers` the best place for this? rxjava 1 had them in its `rxjavahooks` class my concern is that having these alongside the normal `io()`/`computation()`/etc factories will make them look overly inviting for use and accidental abuse || > one other thing im worried about - is schedulers the best place for this? rxjava 1 had them in its rxjavahooks class my concern is that having these alongside the normal io()/computation()/etc factories will make them look overly inviting for use and accidental abuseanother problem is that people will try to override the scheduler-init with these method calls for `rxjavaplugins` but referencing `schedulers` will init the default schedulers regardlessindeed `rxjavaplugins` sounds like a better place for the methods but keep only the `threadfactory` variants || heading to bed right now but will update the pr in the morning with requested changes also let me know if theres anywhere i should put tests as i wasnt sure what the right place would be || > indeed rxjavaplugins sounds like a better place for the methods but keep only the threadfactory variantssounds good to me will do that in my updates tomorrow || yes tests that verify the custom thread factory actually worked by checking a custom thread name for each case ||   5002   > indeed rxjavaplugins sounds like a better place for the methods8b4d461> but keep only the threadfactory variants8009333also tweaked the naming a bit `newnewthread` was a little weird (went with `create`) and added `scheduler` suffix since were not in the `schedulers` class anymore> yes tests that verify the custom thread factory actually worked by checking a custom thread name for each casei tried setting this up matching some of the cdl-based approaches in the plugin tests but want able to get it working (just hangs) pushed what i had in a1029b4 any insight? || heading on vacation for a couple weeks but let me know what you think of getting the tests to work i should have some time here and there to update the pr || ive already told you: use the runnable in the factory method on the thread constructor || > use the runnable in the factory method on the thread constructorarent i just testing the test threadfactory implementations then and not that the schedulers are hooked up properly to power the scheduler? ||  || whats the problem with the tests? they seem to be verifying that the supplied factory was used || oh you didnt pass the supplied `runnable` when calling `new thread()` inside the factory || > oh you didnt pass the supplied runnable when calling new thread() inside the factoryah! this is what i was missing thanks for pointing that out ive updated tests (which should now all be passing) and also made them a bit more robust (full integration with schedulers) to simulate a more real world use case  || failing test looks like a flake || wait no its not reprod locally will fix ||  i think i added manual shutdowns of schedulers after theyre done only io had this lifecycle issue over tests but i did the shutdown in all to be safe || ok this time it seems actually flaky as the same commit passed in a different travis job against my fork -  || 
5005,1,0,0,1,0,1,1,1,2x: executorschedulerscheduledirect to report isdisposed on complete this pr makes the `disposable` returned by the `executorschedulerscheduledirect()` report `isdisposed` `true` if the task has actually finished which should now be consistent with the `worker` behavior of other schedulersreported in #5004   5005  
5007,1,0,0,0,0,0,1,0,1x: update sample(time) diagram to indicate emission of last this pr updates the 1x `sample(time)` diagram to indicate the last value is emitted when the sequence completes it is the same (style) as for 2x:default scheduler:( scheduler:![image]( #4952   5007  
5027,1,0,0,1,0,1,1,0,2x: dedicated singlezip implementation no dispose on all-success this adds a dedicated implementation for zipping `single`s (adapted from `maybezipx`)routing the original `zip` through `flowable` added the usually unwanted behavior of cancelling the sources if one of them reports a completion after a row has been consumed from all (when converted to `flowable` `singleobserveronsuccess` becomes `subscriberonnext` + `oncomplete`) since there is only `onsuccess` and `onerror` in `single` there is no need to dispose the sources once all signalled their only `onsuccess`related: #5024   5027  
5047,1,0,0,1,0,1,1,1,2x: document and test amb subscription ordering refs #5044 once wording and tests are approved ill port to 1x as well || hmm i seem to be fighting the cool documentation checker which is being a bit too clever in this instance im using the word "subscription" at the beginning of a sentence which it thinks means `subscription` the type ill figure out a wording tweak to make it end up as a lowercase "subscription" || also with regard to signal types i figure the other tests cover those already so in these cases were just guarding against ordering changes || yes lowercase it as `subscription` is interpreted as the reference to the type ||  merging 5047  
5049,1,0,0,1,0,1,1,0,use bounded wildcards for errorhandler (5045) adding bound wildcards for error handler - 5045  merging 5049 
5051,0,0,0,1,0,0,0,0,feature/#4876 nonnull annotations issue: #4876starting to add @nonnull and @nullable annotationsi decided to add a compileonly dependency to findbugs:jsr305 artifactwe could also use "ioreactivexannotationsnonnull" which already exists but there is no "ioreactivexannotationsnullable" annotation which is at least as important in my experiencesince these are only annotations it is no problem when the class files are missing at compile time (jls 9612 retention)i have started to add annotations in the scheduler and rxjavapluginsthe test rxjavaplugins contains some invalid checks using null (lines 1353 and following)this pull request is work in progress and should be discussedquestions so far:- use jsr305 (compileonly) or existing annotation in ioreactivex?- (if not using jsr305): use own @nullable annotation or try to get one added to "ioreactivex"? or skip these completely (which misses the point of the static code analysis)- why has there been tests calling the rxjavapluginson*scheduler with null arguments? can these be removed securely? maybe it wasnt well articulated but based on #5023 i thought we try with just the functional interfaces and come back later if it was not enough> i decided to add a compileonly dependency to findbugs:jsr305 artifactwe rather use our own annotations as most tools allow customizing what annotations to considerexpect futher comments inline || thanks for the feedback i will improve the pull request further ||
5054,1,0,0,0,0,1,1,1,2x: add nullable annotation to simple queue (5053) as explained in  simplequeue might return nullto document this behavior a nullable annotation has been added  merging 5054 
5055,1,0,0,0,0,1,1,0,2x: feature/#4876 more null checks i have added some more null checks to help the static code analysisi think i have also  one possible npe in newthreadworker  merging 5055 
5058,1,0,0,1,0,1,1,0,feature/#5045 more generics in rxjavaplugins i widened the bounds for the functions looks good for merelated to #5045 looks like this needs rebasing im sorrry im trying to merge your prs in proper order but multiple recent prs change the same file(s) || yeah no problem rebasing isnt too difficult -) ||  import and rebased || looks like there is a [compilation error]( with the changes || uups fixed it (at least i hope) ||  merging 5058  - 
5064,1,0,0,1,0,1,1,1,2x: fix replay() cancel/dispose npe this pr fixes both `flowablereplay()` and `observablereplay()` throwing a `nullpointerexception` if the connection is disconnect before the upstream calls `onsubscribe` on the connection being established in practice this requires an async cancellation to happen through `refcount()unsubscribeon()` for example the validation tests simulate this by not calling `onsubscribe` until the synchronous connect/disconnect happensreported in #5060  
5086,1,0,1,0,1,1,1,1,1x: deprecate create() add alternatives looks like `create()` wont go away unless we get the ide mark it someway such as being deprecatedthis pr deprecates `create()` and adds `unsafecreate` for internal use and deprecate-renames `fromemitter` to `create(action1 backpressuremode)`there was an earlier attempt at deprecating `create` #4253 but it was not followed up this pr executes what i suggested in one of the [comments](https://githubcom/reactivex/rxjava/pull/4253#issuecomment-235913860)  merging 5086  - 
5087,1,0,0,1,0,0,1,0,2x: correct marble diagram dimensions this fixes part of #4535 as requested in #5067these changes were generated using the following script:```sh#!/usr/bin/env bashfind  -name *java -print0 \  | xargs -0 grep ^\s*\* \  | grep -op  \  | sort -u \  | while read -r i do      echo "updating ${i}"      # gather image details      data"$(identify <(curl -f -l -s "${i}"))"      # extract the images true width and height      width"$(echo "${data}" | grep -op (?<png )\d+)"      height"$(echo "${data}" | grep -op png \d+x\d+ | grep -op (?<x)\d+)"      # determine the images scaled height assuming a width of 640 pixels      new_height"$(echo scale100 s"${width}" / 640 scale0 "${height}" / s | bc)"      # update all `<img/>` tags referencing the image      find  -name *java -print0 \        | xargs -0 perl -i -p -e s<img( (width|height)"[^"]*")* src"\q"${i}"\e"<img width"640" height""${new_height}"" src""${i}""g    done``` (note that i assumed that its okay to just fix the width of all images at 640px that seemed to be the prevailing style) || great scripting job! || thanks! :) since the change only touches javadoc i assume the travis ci job failure is spurious/unrelated? otherwise ill need a pointer on how to correct the situation || the failure is due to time sensitive tests failing on an overloaded ci ill try to resolve it separately dont worry about it ||  merging 5087 
5090,1,0,0,0,0,1,1,1,2x: fix scan(seed f) to emit accumulated values asap for performance reasons the `scan` delayed the emission of accumulated items by one which worked well with sources that pushed new items frequently unfortunately if the source stopped emitting (without completion) the very last accumulated item was stuck and no way to get it out of `scan` i considered this type of use being rare but apparently i was wrongthe pr changes `scan` to emit accumulated items including the initial seed as soon as there is request for it the operator now uses a stable-prefetch queue-drain found throughout other operators such as `observeon` remark: sadly request trickery such as capturing the first `request` call emitting the seed and then requesting n - 1 doesnt work because if the `request()` call itself happens from another thread and the source is empty the `onnext` and `oncomplete` could run concurrentlyreported in #5089  
5091,1,0,0,0,0,0,1,0,1x: create+subscribeon avoid same-pool deadlock this pr allows to fix the same-pool deadlock that may happen with `create()` (formerly `fromemitter`) and `subscribeon` as `subscribeon` by default schedules the requests behind a running emitter and thus the internal request amount may not get updated leading to unnecessary datalosssee #4735in the update if `subscribeon` detects its upstream is `onsubscribecreate` it no longer reschedules requests for it for other non-immediate cases a new overload allows specifying the `requeston` parameter that should be `false` if there is a `create(action1 backpressurestrategy)` in the sequence upstream  
5092,1,0,0,0,0,1,1,1,1x: add singlemerge(obs) obsflatmapsingle & flatmapcompletable this pr adds specialized operators for merging `single` and `completable` sources:  - `singlemerge(observable<single<t>>)` + `maxconcurrency` overload  - `singlemergedelayerror(observable<single<t>>)` + `maxconcurrency` overload  - `observableflatmapsingle(func1<t single<r>>)` + `delayerrors` + `delayerrors maxconcurrency` overloads  - `observableflatmapcompletable(func1<t completable>)` + `delayerrors` + `delayerrors maxconcurrency` overloadsall of these return `observable`this replaces #4988*sidenote: for some time now contributor(s) from certain party tend to contribute low quality or inadequate code and "disappear" pretty quickly i cant be sure this is just lazyness or a deliberate and elaborate scheme to extract free work out of me for their own partys benefit but it is annoying as hell*  merging 5092 
5101,1,0,0,1,0,1,1,1,2x: fix maybeconcat() subscribe-after-cancel verify others this pr fixes `maybeconcatx` subscribing to the next source when the downstream cancelled the `flowable` sequence from its `onnext` this resulted in executing the subscription side-effects of the source to be immediately cancelled when it called `onsubscribe` on concats `maybeobserver`in addition tests were added to verify the other types dont have this kind of a problemrelated #5100  
5106,1,0,0,0,0,1,1,0,2x: fix window(time size) not completing windows on timeout this pr fixes the operators `flowablewindow(time size)` and `observablewindow(time size)` to complete the current window if the time elapses before the size limit is reachedreported in #5104  merging 5106 
5112,1,1,1,1,1,1,1,1,2x: flowable as a publisher to be fully rs compliant this pr performs the changes suggested in #5110 - introduce `flowablesubscriber` with extra textual specification on its relaxed nature - `flowablesubscribe(subscriber)` checks for `flowablesubscriber` and if not found it wraps the incoming rs `subscriber` into a `strictsubscriber` that follows the rs spec to the letter at any cost - introduce `flowablesubscribe(flowablesubscribe)` that most internal operators will use - change `abstractflowablewithupstream` to accept `flowable` as a source update operators - some operators were useful with raw `publisher` input these were duplicated on their outer containing type but use the same internal `flowablesubscriber` - removed "cheat" from the tck tests adjusted timeout on `delay` - replaced most `implements subscriber` with `implements flowablesubscriber` - replaced most `new subscriber` with `new flowablesubscriber` in tests the rest is required for testing the strictness itself - `strict()` is now an identity operator with suggested scheduled removalperformance impact estimation- most primary use of a `flowable` should go through `subscribe(flowablesubscribe)` and thus no overhead change- where the api mandated `publisher` as input providing a `flowable` will have an `instanceof` check at subscription time and routed to `subscribe(flowablesubscriber) if the consumer is part of rxjava 2 itself okay lets go from here in the unlikely case the spec becomes more forgiving the undo is just to remove cast/wrapping from flowablesubscribe and everything works the same as `flowablesubscriber` is an interface ||
5114,1,0,0,1,0,1,1,1,2x: fix observablecombinelatest to dispose eagerly this pr fixes `observablecombinelatest` to dispose the sources outside the serialization loop just like `flowablecombinelatest` does this allows cancellation even if the serialization loop is busy/blocking inside an `onnext` emissionin addition a unit test was added to `flowablecombinelatest` as wellreported in #5111  merging 5114  - 
5117,1,0,0,1,0,1,1,1,2x: add parallelflowablesequentialdelayerror this pr adds the `sequentialdelayerror` operator to `parallelflowable` that allows awaiting all rails in a parallel flow to terminate normally or with the (composite) exception of the failed rail(s)to enable this the `flowableparallel()` operators behavior regarding rail cancellation had to be changed in v205 if any of the rails cancelled (maybe due to a failure maybe due to an end consumer cancelling the entire parallel flow) the input `flowable` was cancelled this pr alters this by requiring all rails to cancel before cancelling the input `flowable` the change permits one or multiple rails to fail and let others progress in case the new `sequentialdelayerror` is applied as a terminal operator the original `sequential()` operator still cancels all rails if one of them fails (triggering the cancellation of the input `flowable`)note that this change may still drop and never process elements in the internal queues of the operators in the parallel flow (because the parallel processing is not implemented with work-stealing that could pick up elements from a dead queue) in order to get as many elements processed as possible it is recommended to reduce the default prefetch on the `runon` operator to a reasonable tradeoff value (between throughput and fault tolerance)**edit**updated the pr to make sure `parallel()` ignores cancelled rails when it dispatches itemsrelated: #5108  merging 5117  - 
5121,1,0,0,0,0,1,1,1,2x: fix observablezip to dispose eagerly this pr fixes `observablezip` to dispose the sources outside the serialization loop just like `flowablezip` does this allows cancellation even if the serialization loop is busy/blocking inside an `onnext` emissionin addition a unit test was added to `observablezip` as wellreported in #5111  merging 5121  - 
5127,1,0,0,0,0,0,1,0,2x: update javadoc of flatmap() overloads this pr rewords the javadoc of `flowableflatmap()` overloads to correctly express their behavior regarding backpressure towards their upstream in 2x only `merge()` operators are unbounded-in by default `flatmap`s are by default bounded  buffersize()` or the `maxconcurrency` parameterin addition one of the `flatmap` overload still had `resultselector` instead of the common `combiner` parameter name as far as i know there are no language-specific libraries targeting 2x yet where in the language the actual parameter names are also part of the signature and changing them counts as an incompatible changerelated #5126  merging 5127  - 
5133,1,0,0,0,0,1,1,1,2x: fix flatmap not cancelling the upstream eagerly this pr fixes the lack of eager cancellation when flatmapping sources and not stopping the upstream if the inner source failsunit tests were added to verify `single` (in case it receives a dedicated implementation one day as currently it delegates to `flowable`) `flowable` and `observable`reported in #5132  merging 5133 
5136,1,0,0,0,0,0,1,0,2x: fix repeatwhen and retrywhen signatures adjust the `repeatwhen` and `retrywhen` signatures to accept `publisher<?>` on `single` and `completable` matching `flowable`s signaturereported in #5135    no coverage uploaded for pull request base (`2x@2a4b18e`) [click here to learn what that means]( `n/a````                                  2x    #5136   +/-   ##  coverage       ?   9581%             complexity     ?     5601             files          ?      620  ?    39820     ?     5599             hits           ?    38154             misses         ?      672             partials       ?      994```| [impacted files]( | coverage δ | complexity δ | ||---|---|---|---|| [src/main/java/io/reactivex/flowablejava]( | `100% <ø> (ø)` | `522 <ø> (?)` | || [src/main/java/io/reactivex/singlejava]( | `9929% <ø> (ø)` | `131 <ø> (?)` | || [src/main/java/io/reactivex/completablejava]( | `100% <ø> (ø)` | `112 <ø> (?)` | |------[continue to review full report at codecov]( **legend** - [click here to learn more]( `δ  absolute <relative> (impact)` `ø  not affected` `?  missing data`> ( last update [2a4b18ed7bd221]( read the [comment docs]( ||
5140,1,0,0,1,0,1,1,1,2x: fix timed replay-like components replaying outdated items the timed versions of `flowablereplay()` `replayprocessor` `observablereplay()` and `replaysubject` all replay outdated items to new subscribers and through the `getvalues()` and `size()` state-peeking methods similar to issue #3917 resolved via #4023the fix includes a node-walk for new subscribers that skips old entries some unit tests werent logically considering the emission pattern (ie items timed out shouldnt appear) and have been  as wellreported in #5139  merging 5140  - 
5140,1,0,0,1,0,1,1,1,2x: fix timed replay-like components replaying outdated items the timed versions of `flowablereplay()` `replayprocessor` `observablereplay()` and `replaysubject` all replay outdated items to new subscribers and through the `getvalues()` and `size()` state-peeking methods similar to issue #3917 resolved via #4023the fix includes a node-walk for new subscribers that skips old entries some unit tests werent logically considering the emission pattern (ie items timed out shouldnt appear) and have been  as wellreported in #5139  merging 5140  - 
5141,1,0,0,1,0,1,1,1,1x: fix timed replay() not terminating when all items timeout the timed `replay()` operator didnt terminate a late subscriber if all the items timed out in the meantimerelated: #5139  
5146,1,0,0,0,0,1,1,1,1x: add unsubscribeon to single type (#5138) 5138 add unsubscribeon to single type  merging 5146 
5156,0,0,0,0,0,0,1,0,add @nonnull to the methods of emitter this pr is a part of #4876 this pr adds `@nonnull` annotation to some methods of `emitter` so that the users of rxjava migrating from 1x to 2x can easily know passing null to the methods will cause npe sorry ive just noticed there is #5151 related to this pr ||  merging 5156 
5161,1,0,0,0,0,1,1,1,2x: add observableswitchmapsingle and switchmapsingledelayerror this is a new operator discussed in #4853 the issue refers to a goodly number of new operators which ill do bit by bit as my time allows and to ensure review is not too daunting updated with suggested changes || unrelated ci failure```ioreactivexparallelparallelflowabletest > parallelismandprefetchasync failed    javalangassertionerror: value counts differ expected: 1048576 actual: 814189 (latch  1 values  814189 errors  0 completions  0 timeout! disposed!)        at ioreactivexobserversbasetestconsumerfail(basetestconsumerjava:163)        at ioreactivexobserversbasetestconsumerassertvaluecount(basetestconsumerjava:462)        at ioreactivexparallelparallelflowabletestparallelismandprefetchasync(parallelflowabletestjava:741)``` || > unrelated ci failuretracking via #5154 could be due to low timeout settings and travis overload just rerun the build next time i did it just now ||  merging 5161 
5163,1,0,0,0,0,1,1,0,2x: singlesubscribe() to report isdisposed() true on success/error the `consumersingleobserver` didnt report `isdisposed` consistently with its statereported in #5160  merging 5163  - 
5174,1,0,0,0,0,0,1,0,2x: wip removes anonymous inner classes this is a wip since the changes are big an incremental review and pr was recommended by @akarnokd  - removes them  from flowable/observable/operators- issue 5150](https://githubcom/reactivex/rxjava/issues/5150)  merging 5174 
5177,1,0,0,0,0,0,1,0,removes all anonymous inner classes this is a what left to complete [this one]( :  - removes all aics  - issue 5150](https://githubcom/reactivex/rxjava/issues/5150) @sleimanjneidi whats the motivation behind making this change? || @naturalwarren to improve stack-traces and to reduce the footprint   || > @naturalwarren to improve stack-traces and to reduce the footprintmakes sense thanks for filling me in!  ||  merging 5177 
5182,1,0,0,1,0,1,1,1,2x: fix replay()refcount() leaking items between connections this pr updates `observablereplay()` and `flowablereplay()` **for 2x** to not leak items between reconnections when run with `refcount()` the `replay()` operator is designed to hold onto the buffer even after its completion so late subscribers can still receive the cached data only a new `connect()` clears this data which may or may not happen since `refcount` ensures that there wont be any latecommers to an already completed connection (because it also drops its current subscribers on termination or when reaching zero) the `replay()` can be reset to an empty staterelated: #5172 #5181  merging 5182 
5189,1,0,0,1,0,1,1,0,2x: fix concatmapeager should accept 0 for prefetch fixes a bug that  flowableconcatmapeager(mapper  maxconcurrency  prefetch) and observableconcatmapeager(mapper  maxconcurrency  prefetch) operators will not accept 0 and negative numbersreported in #5185 i believe a 0 breaks the internals of the operator and -1 has the completely opposite effect taking more memory || i am sorry with the wrong fixis it only necessary to modify the document? || > is it only necessary to modify the document?yes please modify only the javadoc || thank you! also i think that the test case name is wrong so i modifed it ||  merging 5189 
5195,1,0,0,0,0,0,1,0,1x: unicastsubject fail-fast and delay-error behavior this pr adds support for delay-error behavior to `unicastsubject` with methods `unicastsubject<t> create(boolean delayerror)` `unicastsubject<t> create(int capacityhint action0 onterminated boolean delayerror)` behavior of existing factory methods was not changed and is fail-fastrelates to #5165  merging 5195 
5199,1,0,0,0,0,1,1,1,2x: increase timeout on parallel & completable tests this pr increases the timeout on `completabletest` test methods and on `parallelflowabletestparallelismandprefetchasync`related: #5154 #5179  merging 5199 
5199,1,0,0,0,0,1,1,1,2x: increase timeout on parallel & completable tests this pr increases the timeout on `completabletest` test methods and on `parallelflowabletestparallelismandprefetchasync`related: #5154 #5179  merging 5199 
5202,1,1,0,1,1,1,1,1,2x: add resilient versions of parallel map() filter() & doonnext() this pr adds 2 new overloads to `parallelflowable` operators `map` `filter` and `doonnext` to enable per item error handling in case the main function fails with some exception```javaflowablerange(0 2)parallel(1)map(v -> 1 / v parallelfailurehandlingskip)sequential()test()assertresult(1)```the new `parallelfailurehandling` has some default enumeration values to handle the common cases in addition the `bifunction` overload allows bounded retries and/or conditional handling of failuresrelated: #5128  merging 5202 
5207,1,0,0,1,0,1,1,1,2x: prevent tasks to self interrupt on the standard schedulers task wrappers of the various schedulers and modes (direct & worker) were able to get cancelled via interruption from the same thread they were runningrelated #5203  merging 5207 
5208,1,0,0,0,0,0,1,0,2x: fix images of firstelement flattenasx flatmapiterable this pr links in the new images from #5130 for previously misleading marble diagrams of the operators  merging 5208 
5210,1,0,0,0,0,0,1,0,2x: better documentation on the abstract consumer classes this pr improves the documentation of the abstract consumer classes such as `disposablesubscriber` `resourcesubscriber` and their counterparts for the other base reactive typesit contains a lot of copy-paste so please read through all of the text in case the text was not properly adapted to the abstract class at handrelated: #5148  merging 5210 
5213,1,0,0,0,0,1,1,0,2x: fix window() with time+size emission problems the `window()` operator overload with time and size bound didnt work correctly when some windows were terminated by the timeout and others by the size this pr fixes:  - the case when the operator restarts the time windows when the size bound is reached  - leaking of the worker  - the item counter not reset to zero when the time bound is reached  - periodic window bound stopped working after the first windowrelated #5104 (again)  merging 5213 
5217,1,0,0,0,0,0,1,0,[2x] unicastsubject fail fast support this pr adds support for fail-fast behavior to `unicastsubject` with methods `unicastsubject<t> create(boolean delayerror)` `unicastsubject<t> create(int capacityhint runnable onterminated boolean delayerror)`  relates to #5165  merging 5217 
5223,1,0,0,1,0,0,1,0,2x: improve the documentation of schedulers utility class this pr improves the javadoc of the `ioreactivexschedulersschedulers` utility class plus adds a missing `schedulersupport` constant for the `single()` schedulerlet me know if something needs further explanation (or some new case needs explanation)related: #5145  merging 5223 
5225,1,0,0,0,0,1,1,0,1x: fix completableonerrorresumenext unsubscribe not propagated the `completableonerrorresumenext` did not properly propagate the downstream `unsubscribe()` call to upstreamreported in #5224  merging 5225 
5226,1,0,0,0,0,0,1,0,2x unicastprocessor fail-fast support this pr adds support for fail-fast behavior to `unicastprocessor` with methods `unicastprocessor<t> create(boolean delayerror)` `unicastprocessor<t> create(int capacityhint runnable onterminated boolean delayerror)` relates to #5165 #5217  merging 5226 
5247,1,0,0,0,0,1,1,1,2x: fix flowabletolist() onnext/cancel race this pr fixes the `nullpointerexception` that can happen because `cancel` nulls out the value and `onnext` simply dereferences that value in `flowabletolist`reported in #5246  merging 5247 
5258,1,0,0,0,0,1,1,1,1x use intellij ide friendly assertion failure message the `assertitem` failure message pattern in `testsubscriber` does not match any of the regex patterns defined by intellij to show `<click to see difference>` link ![before]( changing the "_expected to be_" to "_expected:_" the pattern is recognised by intellij and the helpful link is presented![after]( original idea from #5249 was to use the "_expected:<> but was:<>_" pattern used in junit but it is not picked up on its own by intellij the assertionerror must extend from junits comparisonfailure to get it recognised this however requires dependency on junit![junit]( in the end the fix is just a very simple change in the message  merging 5258 
5277,1,0,0,0,0,1,1,0,2x: singlesubscribe(biconsumer) consistent isdisposed fixes the `singlesubscribe(biconsumer)` to report `isdisposed` when terminatingreported in #5276  merging 5277 
5296,1,0,0,0,0,0,1,0,improve doondispose javadoc sorry for the earlier pr #5295 :/ this addresses the javadoc issues discussed in #5283- removes the note in `observabledoondispose` which claims its action would be called on terminal events- slightly adjusts the javadocs of the `maybe`/`single`/`completable` variants- adds `@throws` note to some `observable`/`single`/`maybe` `doondispose` as it was present in the `completable` variant  merging 5296 
5296,1,0,0,0,0,0,1,0,improve doondispose javadoc sorry for the earlier pr #5295 :/ this addresses the javadoc issues discussed in #5283- removes the note in `observabledoondispose` which claims its action would be called on terminal events- slightly adjusts the javadocs of the `maybe`/`single`/`completable` variants- adds `@throws` note to some `observable`/`single`/`maybe` `doondispose` as it was present in the `completable` variant  merging 5296 
5302,1,0,0,0,0,0,1,0,2x: add singleunsubscribeon() this pr adds the `singleunsubscribeon()` operatorrelated: #5300  merging 5302 
5307,1,0,0,1,0,0,1,0,2x: apply promotions for v21 this pr applies the promotions listed in #5243suggested review strategy:- check if the `@experimental` annotation has been removed or turned into `@beta`- check if the `<p>history: 20x` matches the original value of the updated `@since 20x`  merging 5307 
5318,1,0,0,0,0,0,1,0,1x: apply api promotions for 13 this pr applies the api promotions of #5201note that `singleunsubscribeon` remainded experimental and `observablefromemitter` was removedwhere the experimental version was available it was moved up as `<p>history: 1xy - experimental` similar to how 2x versioning/promotions happensuggested review strategy:- verify `@experimental` and `@beta` annotations are removed from the method and from javadoc- verify `@since 13` is present  merging 5318 
5409,1,0,0,0,0,0,1,0,#5382 corrected singledelay documentation corrected singledelay documentation that says that success or error signals will be delayed by the specified amount but in fact errors are not delayed only successes  
5419,1,0,0,0,0,1,1,0,2x: fix periodic scheduling with negative period causing iae this pr adds unit tests to verify the `schedulerscheduleperiodicallydirect` and `schedulerworkerscheduleperiodically` works with non-positive period as required by the javadoc the `computation` and `single` schedulers were not working properly and the underlying `scheduledexecutorservice` crashed with `illegalargumentexception` thus these are now  with custom handler for the `period < 0l` casesrelated: #5416  
5427,1,0,0,0,0,1,1,1,2x: fix buffer(time maxsize) duplicating buffers on time-size race the pr fixes both the time+maxsize bound `buffer` operators of `flowable` and `observable` the logic didnt properly mutually exclude the timer action and the `onnext` action resulting in probabilistic emission of the same buffer twicereported in #5426  merging 5427 
5440,1,0,0,0,0,1,1,1,2x: concat to report isdisposed consistently with termination this pr makes sure the `disposable` of a `concat` operator reports `true` when the sequence terminatesreported in #5439  merging 5440 
5447,1,0,1,0,0,0,1,0,remove @nonnull annotation in consumer method parameter this 5442 this should be safe to merge see the discussion in #5216 ||  merging 5447  
5449,1,0,0,0,0,0,1,0,remove the @nonnull annotation from function as per per the discussion in #5447  merging 5449 
5466,1,0,0,0,0,0,1,0,2x: flowabletimeouttimed - replace atomicreference with mutable field as per discussion in #5461 the timer fields in the subscriber classes in [flowabletimeouttimed]( are `atomicreference`s but this is not required as the fields are accessed synchronouslythe `timer` field in `timeouttimedothersubscriber` did require an `atomicreference` because of the dispose call [here]( but this call is not required if we just call `workerdispose()`no unit test additionsps 9321 unit tests in rxjava 2x! an outrageous amount of work thanks @akarnokd (and other contributors)!  merging 5466 
5486,1,0,0,0,0,1,1,0,2x: small note on maybedefaultifempty regarding tosingle ths pr replaces #5485 regarding the issue of #5480 because our javadoc validation did not allow that type of wording (ie mentioning `single` when the method signature is not related to it)  merging 5486 
5486,1,0,0,0,0,1,1,0,2x: small note on maybedefaultifempty regarding tosingle ths pr replaces #5485 regarding the issue of #5480 because our javadoc validation did not allow that type of wording (ie mentioning `single` when the method signature is not related to it)  merging 5486 
5507,1,0,0,1,0,1,1,1,2x: fix spsclaq nepotism flowablerefcounttesttestrefcountasync flaky this pr fixes the so-called gc nepotism (see #3794) in `spsclinkedarrayqueue` by not nulling out the previous buffers next pointer upon switching buffers in the `peek()`/`poll()` methodsin addition the flowablerefcounttesttestrefcountasync has been reworked to be more forgiving towards unexpected delays due to system load (reported in #5506)  merging 5507 
5507,1,0,0,1,0,1,1,1,2x: fix spsclaq nepotism flowablerefcounttesttestrefcountasync flaky this pr fixes the so-called gc nepotism (see #3794) in `spsclinkedarrayqueue` by not nulling out the previous buffers next pointer upon switching buffers in the `peek()`/`poll()` methodsin addition the flowablerefcounttesttestrefcountasync has been reworked to be more forgiving towards unexpected delays due to system load (reported in #5506)  merging 5507 
5524,1,0,0,0,0,0,1,0,2x: add/update observable marbles (07/30) this pr updates the marbles of the following `observable` operators:- `just` ([image]( by @leonardortlima - `rangelong` ([image]( by @leonardortlima - `startwith` ([image]( by @leonardortlima - `startwitharray` ([image]( by @leonardortlima - `sorted` ([image]( by @leonardortlima see #5319  merging 5524 
5560,1,0,0,0,0,0,1,0,2x: fix obscombinelatestdelayerror sync initial error not emitting this pr fixes the case reported in #5558 where a synchronous first non-empty source triggered an error completion immediately instead of giving a chance to the other sources to form combinationsthe fix also includes:- initialization of the `combineobserver`s now happen in the constructor- the `atomicreference<disposable>` of the inner observers are now inlined into `combineobserver`- cleaned up drain logic- unit tests verifying `flowablecombinelatest` (no changes required there)  merging 5560 
5568,1,0,0,0,0,1,1,1,2x: add assertvaluesonly to basetestconsumer adds `assertvaluesonly` that asserts that the testobserver/testsubscriber received only the specified values in the specified order without terminating5555  merging 5568 
5582,1,0,0,0,0,0,1,0,implement maybeswitchifempty(single) adds `maybeswitchifempty(single)` 4544  merging 5582 
5590,1,0,0,0,0,1,1,0,implement lambdaconsumerintrospection 5569 and allows you to introspect if the resulting observer has missing error consumption and subsequently supplies a default (throwing) one wasnt sure how youd want to do the naming can work on adding some tests if this looks good wanted to get something up for api review early || the naming is fine with me ||  merging 5590  
5600,1,0,0,0,0,0,1,0,updating javadoc with correct return types a small pr with updated javadoc mentioned in the issue #5595 (thanks to @roblewis for reporting it)updated documentation about return types where `observable` was incorrectly mentioned instead of `single` the `flowable` variants [are okay]( ||  merging 5600 
5609,1,0,0,1,0,1,1,0,2x: fix observableconcatmapeager queueing of source items this pr fixes the wrong queue type in `observableconcatmapeager` to be the `spsclinkedarrayqueue` instead of the `spscarrayqueue` (the latter basically ignored items from the main source when it got full - a rem t from its bounded `flowable` cousin) unit tests added that ensure both `flowable` and `observable` variants work properlyreported in: #5608  merging 5609 
5616,1,0,0,1,0,1,1,0,2x: add singledelay overload that delays errors much like #5382 i discovered when trying to fake a slow/flaky backend that `singledelay` doesnt delay errorsthis pr adds an overload that does bringing `singledelay` in line with `observabledelay` it also corrects the javadoc for existing overloads (#5409 only updated 1/2)  merging 5616 
5637,1,0,0,1,0,0,1,0,2x: fixing javadoc warnings minor fixes for warnings reported  javadoc` tool mentioned in #5634 nice could you also fix this:```:javadoc/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observers/resourcemaybeobserverjava  error: bad use of > *     subscribewith(new resourcemaybeobserver&ltinteger>() { ``` || sure amended!  ||  merging 5637 
5647,1,0,0,0,0,0,1,0,2x: fix subscribewith documentation examples this pr improves a documentation of `subscribewith` functions in `single` `maybe` `completable` by making sure examples are compilable (by using classes which implement `disposable`)this should  #5642 in that issue @akarnokd approved my idea to use `disposablemaybeobserver` in the example but as i looked in other classes i noticed that `observablesubscribewith()` documentation uses a `resourceobserver` (which implements `disposable`) so i thought that this is the way to go in all other top-classes?if you think that this is not the case and instead all of them should be switched to use `disposable*observer` in their examples let me know i will do it in this way theni think that all those example should use similar classes `resourcexobserver` is generally not necessary so `disposablexobserver` should be in the docs ||  merging 5647 
5649,1,0,0,0,0,0,1,0,2x add concatmapcompletable() to observable add `concatmapcompletable()` to `observable` as discussed in #4853i didnt think it made sense in other reactive typescode is mostly a copy of `observableconcatmap`  let me know if there is a better style of code to base this off instead  it also does not have the option to delay errors as concatmap() does not sure if that is needed  merging 5649 
5660,1,0,0,0,0,0,1,0,1x: fix timeout (timed selector) unsubscribe bug this pr fixes an unsubscribe bug somewhere in the timed `timeout` operator reported in #5657 by implementing it in a algorithmically fresh manner  merging 5660 
5669,1,0,0,0,0,1,1,1,2x: fix publishprocessor cancel/emission overflow bug this pr should fix the bug that caused the test failure in #5545the bug manifested itself when a cancellation was happening the same time a request 1 was being fulfilled since the same request accounting was used for cancellation indicator if the cancel happened between the `onnext()`s `get()` check and `decrementandget` this `decrementandget` decremented longmin_value unconditionally which lead to a state that would appear the subscriber still can receive events a concurrent `offer` which saves the current array of registered `subscriber`s then would emit an item and overflow the `subscriber`the fix is to use the cancellation-aware `backpressurehelperproducedcancel()` utilityunit test were added to verify the correct behavior on both `publishprocessor` and `behaviorprocessor` (the latter uses different cancellation mechanism via a dedicated field)  merging 5669 
5677,1,0,0,0,0,1,1,0,2x: make parallel() a fusion-async-boundary the `parallel()` supports front-fusion but since the operator is almost always followed by the separate `runon` operator the parallel version of the `observeon` operator such front-fusion should be considered a `boundary`-type fusion just like with `observeon` a `requestfusion` with `boundary` tells the upstream operator(s) that when fused their actions would be executed behind an async boundary and possibly on an unwanted thread operators such as `map` and `doonnext` who are generally expected to be thread-confined can then refuse to fuse restoring the traditional queue hopping behavior (`source -> queue -> op -> queue -> op -> queue -> consumer`)reported in #5676/cc @smaldini & @simonbasle  merging 5677  < 
5696,1,0,0,0,0,1,1,0,1x: fix completableconcat to use replace (dont dispose old) fixes the same bug as with the 2x `completableandthen` and `completableconcat`see #5694 & #5695  merging 5696 
5705,1,0,0,0,1,1,1,1,2x: moved tests to fromcallabletest from fromcompletabletest 5698 there was a test class named `observablefromcompletabletest` which actually was targeting `observablefromcallabletest` this was most likely just a naming issue copied all tests from `observablefromcompletabletest` to `observablefromcallabletest` and deleted the former class  merging 5705 
5718,1,0,0,0,0,0,1,0,2x: add a sentence to documentation of take() operator #5716  merging 5718 
5719,1,0,0,0,0,0,1,0,1x: add a sentence to documentation of take() operator #5716  merging 5719 
5729,1,0,0,0,0,1,1,1,2x: implement as() this implement `as()` support as discussed in #5654i took the opportunity to try to standardize the docs and tests for it (which vary a little bit across implementations of `to()`)related: #5654 let me know if you want to add more tests some usages of `to()` were mixed in other tests and wasnt sure if they were specifically targeting testing it || im not sure i understand the remaining ci errors as the parameters have the nonnull annotation || some style checks failed:  add `as` to `parallelflowable`please add a unit test that has a converter class which combines all interfaces and is applied to the 6 types of sources || could you explain what the style checks fix is? i didnt quite understand the message in the log || parallelflowable - 8adb583started on more converter tests in `convertertest` in c1f26ee composite converter test is in there only thing im stuck on is the `genericssignaturetest` tests (borrowed from `transformerstest`) currently they dont compile but im not sure what the goal is (or if it even makes sense to match the checks `transformerstest` does) let me know what you think || you have to extend the `paramvalidationcheckertest` with instances of your new converter types put something like the following into l562```javadefaultvaluesput(observableconverterclass new observableconverter() {    @override public object apply(observable o) { return o }})``` || as for [these]( you are using the wrong generic types~~`observableconverter<a<t ?> b<t>>` is applied to `observable<integer>` in the test where `integer` is unrelated to `a<t ?>`~~i overlooked the test using `a` ill check code locally || the wildcard definition in those compile errors and the wrong `<integer>` parameter confuses the compiler i suggest going raw-types with these converters and using `suppresswarnings({"unchecked" "rawtypes"})` on the problematic tests || posted a [patch]( for your pr ||  merging 5729  
5740,1,0,0,0,0,0,1,0,2x: marbles for observable all frompublisher ziparray this pr adds a marble diagram to `frompublisher` and updates the marbles of `all` and `ziparray` inside `observable`the images can be seen in [this comment]( of #5319  merging 5740 
5743,1,0,0,0,1,1,1,1,2x: check isdisposed before emitting in singlefromcallable previously singlefromcallable did not check if the subscriber wasunsubscribed before emitting onsuccess or onerror this fixes thatbehavior and adds tests to singlefromcallable completablefromcallableand maybefromcallable5742  merging 5743 
5745,1,0,0,0,0,0,1,0,2x: add/update observable marbles 11/28 this pr adds or updates mable diagrams of `observable`:- [`blockingfirst`]( [`blockingfirst` with default]( [`tofuture`]( [`blockingsubscribe` no arguments]( [`blockingsubscribe` with 1 argument]( [`blockingsubscribe` with 2 arguments]( [`blockingsubscribe` with 3 arguments]( [`collectinto`]( [`dooncomplete`]( [`doonerror`]( [`doonlifecycle`]( [`doonnext`]( [`doondispose`]( #5319: [comment](https://githubcom/reactivex/rxjava/issues/5319#issuecomment-347482919)  merging 5745  < 
5755,1,0,0,0,0,0,1,0,2x: add marbles for observable (12/06) this pr adds some missing marbles to `observable`:- [concatmapcompletable]( [concatmapdelayerror]( [concatmapeager]( [concatmapeagerdelayerror]( [concatmapiterable]( [doafternext]( [dofinally]( in #5319 images in [comment](https://githubcom/reactivex/rxjava/issues/5319#issuecomment-349595094)  merging 5755 
5766,0,0,0,0,0,0,1,0,rename interface parameters #5762 signed-off-by: shaishavgandhi05 <shaishgandhi@gmailcom>  merging 5766 
5773,1,0,0,0,0,0,1,0,2x: improve javadoc of retrywhen() operators this pr improves the javadoc of the `retrywhen` operators in the 5 base classes adds example to handling an asynchronous source with delay where an early `oncomplete` may cause unexpected terminations otherwiserelated: #5772  merging 5773 
5781,1,0,0,0,0,0,1,0,2x: describe merge() error handling this pr adds some clarifications about how `merge` handles (multiple) errors in a new *error handling* section in its `<dl>` javadoc entrythere exist several dozen variants of `merge` in the various base classes that could also include such javadoc addition once the wording has been reviewed the other places will receive a separate prrelated: #5779 #5780  merging 5781 
5781,1,0,0,0,0,0,1,0,2x: describe merge() error handling this pr adds some clarifications about how `merge` handles (multiple) errors in a new *error handling* section in its `<dl>` javadoc entrythere exist several dozen variants of `merge` in the various base classes that could also include such javadoc addition once the wording has been reviewed the other places will receive a separate prrelated: #5779 #5780  merging 5781 
5783,1,0,0,0,0,0,1,0,2x: fix javadoc wording of onterminatedetach a missing `nulls` word from `flowableonterminatedetach` and `observableonterminatedetach` javadoc the other types have this word alreadyrelated: #5782  merging 5783 
5792,1,0,0,0,0,1,1,0,2x: fix flatmap inner fused poll crash not cancelling the upstream this pr fixes the lack of upstream `cancel()` call when an inner fused sources `queuepoll()` crashes in a non-delayed error modeunit tests were added to verify `observableflatmap` `flowableflatmapiterable` and `observableflatmapiterable` as well  5791  merging 5792 
5805,1,0,0,0,0,0,1,0,2x: final planned observable marble additions/fixes this is the final part of the `observable` marble fixes and additions as planned in #5319- [tolist(callable)]( [toflowable(buffer)]( [toflowable(drop)]( [toflowable(latest)]( [toflowable(error)]( [toflowable(missing)]( [unsubscribeon](  position and spacing of the marbles in the `zipwith` overloads (no image change)images in https://githubcom/reactivex/rxjava/issues/5319#issuecomment-356630375  merging 5805 
5811,1,0,0,0,0,1,1,1,2x: fix buffer(open close) not disposing indicators properly the pr fixes the resource management in the `buffer` operator that uses other reactive sources to indicate when a buffer starts and ends both `flowable` and `observable` implementations had to be fixes: #5809 @akarnokd let me know if i understand the spirit of this pr on `flowablebufferboundary`:1 avoids keeping reference to / tracking buffers in subscribers other than the main2 cancel source on open subscriber completion (if it completes and the last buffers close publisher has completed subscribers will have size 0 and we can safely cancel upstream as no new buffer will open at this point)3 in main distinguish a open subscriber error from a close subscriber error (due to 1 the later needs associated buffer cleanup)is that correct/exhaustive? || > avoids keeping reference to / tracking buffers in subscribers other than the mainyes> cancel source on open subscriber completion (if it completes and the last buffers close publisher has completed subscribers will have size 0 and we can safely cancel upstream as no new buffer will open at this pointyes> in main distinguish a open subscriber error from a close subscriber error (due to 1 the later needs associated buffer cleanupno if the `openerror` or `closeerror` is fired both should cancel the main source cancel the subscribers other than themselves clean the buffer and then report the error they could be converted into a common method of `boundserror(disposable d throwable ex)` ||  merging 5811 
5820,1,0,0,1,0,1,1,0,1x: plugin lookup workaround for systemproperties access restrictions the pr adds a `try-catch` around the system property lookup inside the `rxjavaplugins` in case a security manager prevents reading arbitrary property entriesthis mainly affects the `rxjavaplugin[index]class` lookup which were introduced due to the 31 character key limit on androidhowever when running in a container such as tomcat a security manager may prevent reading these type of pre entries (where `[index]` cant be known upfront) crashing the initialization**update**:the `systemgetproperties()` can also fail therefore retrieving the properties has been factored out into a separate method that returns an empty properties5819  merging 5820 
5828,1,0,0,1,0,0,1,0,2x: document replay(n) emission retention caveat adds javadocs indicating a caveat regarding size-bounded replay operators subjects and processors see #5827 for details  merging 5828 
5833,1,0,0,0,0,1,1,1,2x: fix observableswitchmap main onerror not disposing the current inner source the `observableswitchmap` had bad logic in its main `onerror` handler which didnt dispose the current inner `observable`the `flowable` version didnt have this logic error both variants received an unit test to verify the correct behavior5832  merging 5833 
5845,1,0,0,0,0,0,1,0,2x: add efficient concatwith(single|maybe|completable) overloads this pr adds specialized overloads to the `concatwith` operator in `flowable` and `observable`if accepted the marbles will be updated in a separate prrelated: #5350  merging 5845 
5847,1,0,0,1,0,1,1,0,2x: add efficient mergewith(single|maybe|completable) overloads this pr adds specialized overloads to the `mergewith` operator in `flowable` and `observable`if accepted the marbles will be updated in a separate prrelated: #5350  merging 5847 
5860,1,0,0,0,0,1,1,1,2x: flowablegroupby add overload with evicting map factory as per discussion in #5763 this pr adds an overload for `flowablegroupby` that specifies an `evictingmapfactory` an example of usage taken from the new javadoc:```javafunction<consumer<object> map<integer object>> evictingmapfactory     notify ->       cachebuilder         newbuilder()          maximumsize(3)         removallistener(entry -> {               try {                  // emit the value not the key!                  notifyaccept(entrygetvalue())              } catch (exception e) {                  throw new runtimeexception(e)              }            })         <integer object> build()         asmap()          // emit 1000 items but ensure that the // internal map never has more than 3 items in it            flowable   range(1 1000)   // note that number of keys is 10   groupby(x -> x % 10 x-> x true 16 evictingmapfactory)   flatmap(g -> g)   foreach(systemout::println)```note that i based this operator on the 1x version which i think may have a bug that goes as far as the signature of that method the eviction consumer should not be given a key but rather the value from the map ill pursue the 1x issue after dealing with this  merging 5860 
5863,1,0,0,0,0,0,1,0,2x: expand the documentation of the flowablelift() operator this pr expands the documentation of the `flowablelift()` operator used for inserting custom operators into flows in a functional and fluent fashionthe other reactive base classes feature similar `lift()` operators for which the text can be adapted and contributed in a separate pr once the content of this pr is stabilized by review feedbackrelated: #5862  merging 5863 
5870,1,0,0,0,0,1,1,0,2x: add flowableswitchmapcompletable{delayerror} operator this pr adds the `flowableswitchmapcompletable` and `flowableswitchmapcompletabledelayerror` operators as requested by #4853the associated new marbles are:![switchmapcompletable](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/switchmapcompletablefpng)![switchmapcompletabledelayerror](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/switchmapcompletabledelayerrorfpng)  merging 5870 
5871,1,0,0,0,0,1,1,0,2x: add flowableconcatmapcompletable{delayerror} operator this pr adds the `flowableconcatmapcompletable` and `flowableconcatmapcompletabledelayerror` operators as requested by #4853the marbles will be updated in a separate pr  merging 5871 
5872,1,0,0,0,0,0,1,0,2x: add flowableconcatmap{maybesingle}{delayerror} operators this pr adds operators that allow concatenating a mapped sequence of `maybe`s or `single`s with or without delaying their errors:- `concatmapmaybe` (+1 overload with prefetch)- `concatmapmaybedelayerror` (+2 overloads with error mode and prefetch)- `concatmapsingle` (+1 overload with prefetch)- `concatmapsingledelayerror` (+2 overloads with error mode and prefetch)they are in the same pr as the `single` variants implementation is practically the `maybe` implementation minus the `oncomplete` casetheir marbles will be updated in a separate proriginally requested in #4853  merging 5872 
5873,1,0,0,0,0,1,1,0,2x: add flowableswitchmap{maybesingle}{delayerror} operators this pr adds `flowable` operators that allow switching between a mapped sequence of `maybe`s or `single`s with or without delaying their errors:- `switchmapmaybe`- `switchmapmaybedelayerror`- `switchmapsingle`- `switchmapsingledelayerror`they are in the same pr as the `single` variants implementation is practically the `maybe` implementation minus the `oncomplete` casetheir marbles will be updated in a separate proriginally requested in #4853  merging 5873 
5875,1,0,0,0,0,1,1,0,2x: add observable switchmapx and concatmapx operators this pr ports the various `switchmapx` and `concatmapx` operators from #5870 #5871 #5872 and #5873 to `observable`:- `concatmapcompletable` (replaced by the common implementation)- `concatmapcompletabledelayerror`- `concatmapmaybe`- `concatmapmaybedelayerror`- `concatmapsingle`- `concatmapsingledelayerror`- `switchmapcompletable`- `switchmapcompletabledelayerror`- `switchmapmaybe`- `switchmapmaybedelayerror`- `switchmapsingle` (dedicated implementation)- `switchmapsingledelayerror` (dedicated implementation)this pr concludes the requested set of operators in #4853marbles will be updated/adjusted in a separate pr  merging 5875 
5886,1,0,0,0,1,1,1,1,2x: upgrade the algorithm of observabletimeout(time|selector) operators this pr improves the algorithms of the `observabletimeout(time)` and `observabletimeout(selector)` operators to match their `flowable` counterparts implemented in #5661in addition coverage of the `flowable` counterparts have been improved by synchronizing the unit testsnote that they were the last users of `observerfullarbiter` and `fullarbiterobserver` which are now removedcloses #5882  merging 5886 
5887,1,0,0,0,0,1,1,1,2x: fix window(observable|callable) upstream handling this pr fixes the upstream handling in `observablewindow(observablesource)` and `observablewindow(callable<observablesource>)` operators to make sure if both the main output and the inner windows have been disposed the upstream is also disposed5881*remark:*there are a couple of `w ! null` checks showing up as partially covered in theory with the right interleaving `w` can become `null` but unfortunately the usual `testhelperrace()` testing is unlikely to trigger that case there would be a higher chance with 3 threads (one disposing one completing the main and one completing the inner window) but the current ci is effectively 15 - 2 cores/threads that tend to not produce a thorough interleaving  merging 5887 
5888,1,0,0,0,0,1,1,1,2x: fix flowablewindow(publisher|callable) upstream handling this pr fixes the upstream handling in `flowablewindow(publisher)` and `flowablewindow(callable<publisher>)` operators to make sure if both the main output and the inner windows have been cancelled the upstream is also cancelledrelated: #5887 #5881in addition the jacoco code coverage has been updated to 080 mainly due to the [automatic filtering of difficult-to-impossible code paths](https://githubcom/jacoco/jacoco/releases/tag/v080)  merging 5888 
5895,1,0,0,0,0,0,1,0,fix buffer() documentation to correctly describe onerror behaviour 5894 i just copied the sentence from the  docs in 1x and updated to use observablesource/publisher naming  merging 5895 
5904,1,0,0,0,0,1,1,1,2x: fix flowablesingleorerror()toflowable() not signalling nosuchelementexception when a `singleorerror` is followed  toflowable()` the assembly process switches the `flowable->single` operator into a `flowable->flowable` operator implementing the `singleorerror` behavior (saving the back-and-forth type conversion) the backing implementation was shared with `singleelement` and as such did not properly handle the `orerror` case for an empty source the pr fixes the lack of `nosuchelementexception` in this case5903the `observable` variant doesnt have such optimization but the test has been converted to make sure `observable` is verified for this aspect in case the optimization is implemented with it in the future  merging 5904 
5906,1,0,0,0,0,0,1,0,2x: add public constructor for testscheduler that takes the time - adds a time constructor to testscheduler- should i make it experimental or will it just be stable?5901  merging 5906  < 
5923,1,0,0,0,0,0,1,0,2x: fix javadoc warnings of buffer(publisher|callable) text is not allowed between `<dl>` and its child tags5916  merging 5923  < 
5924,1,0,0,0,0,0,1,0,2x: update singleflatmappublisher marble renamed the operator in the box for #5788![flatmappublisher](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleflatmappublisherpng)  
5928,1,0,0,0,0,1,1,0,2x: fix concatmapsingle & concatmapmaybe dispose-cleanup crash this pr fixes the accidental logical mistake in the `cancel`/`dispose` logic of the new `concatmapsingle` and `concatmapmaybe` operators of both `flowable` and `observable` where the internal queue cleanup should happen in a serialized fashion only which is the state when the work-in-progress counter changes from 0 to 1 ensured by a `` check5927 this is severe enough to release **2112** as a hotfix version asap although the mistakes are in the newly introduced operators ive done a quick search for this pattern and doesnt happen in older code luckily also this is on the dispose path and doesnt really the performance in the normal operation mode (ie when data is allowed to flow through till the end without cancellation) ||  merging 5928 
5947,1,0,0,0,0,1,1,1,2x: fix groupby cancellation with evicting map factory 5933when the outer stream is cancelled there may be evicted groups present in the queue to be completedive added code to complete the evicted groups in the `cancel` method as suggested by @akarnokd to protect against a race condition where the evictionaction is called just after the evicted groups are completed in `cancel` ive added a `cancelled` check to `evictionaction` however i am concerned about a race that ill place in the comments on the code below  merging 5947 
5948,1,0,0,0,0,0,1,0,fix observable javadoc (#5944) * replace `dooncancel`  doondispose` in observable javadocthank you for contributing to rxjava before pressing the "create pull request" button please consider the following points:  -  please give a description about what and why you are contributing even if its trivialreplace `dooncancel`  doondispose` in observable javadoc  -  please include the issue list number(s) or other pr numbers in the description if you are contributing in response to those#5944  -  please include a reasonable set of unit tests if you contribute new code or change an existing one if you contribute an operator (if applicable) please make sure you have tests for working with an `empty` `just` `range` of values as well as an `error` source with and/or without backpressure and see if unsubscription/cancellation propagates correctlyjavadoc only  merging 5948 
5972,1,0,0,0,0,1,1,0,2x: fix observableconcatmapsingle dropping upstream items the internal queue of `observableconcatmapsingle` was incorrectly the bounded one from its `flowable` counterpart causing it to drop upstream items if the current `single` was delayed the right queue for `observable`s is the `spsclinkedarrayqueue`added unit tests to both `concatmapsingle` and `concatmapmaybe` to verify the correct behaviorfixes: #5971  merging 5972 
5979,1,0,0,1,0,1,1,1,2x: add throttlelatest operator this pr adds the `throttlelatest` operator to `observable` and `flowable` also known as `conflate` (#4856): it is a combination of `throttlefirst` and `sample` whereby frequent items are sampled but the first item outside the sampling window will be emitted immediately:![throttlelatest]( #4856replaces: #5968  merging 5979 
6014,1,0,0,0,0,1,1,0,2x: fix & prevent null checks on primitives this pr removes the accidental null checks on primitives in two `observable` methods and adds a trap method to `objecthelper` to both highlight and fail the tests in case the null checks are still attempted the method is marked as deprecated so it will also show up in (eclipses) problems windowreplaces #6012 6013  merging 6014 
6014,1,0,0,0,0,1,1,0,2x: fix & prevent null checks on primitives this pr removes the accidental null checks on primitives in two `observable` methods and adds a trap method to `objecthelper` to both highlight and fail the tests in case the null checks are still attempted the method is marked as deprecated so it will also show up in (eclipses) problems windowreplaces #6012 6013  merging 6014 
6019,1,0,0,0,0,1,1,1,2x: fix singletakeuntil maybetakeuntil dispose behavior fix the dispose behavior of the `singletakeuntil` and `maybetakeuntil` operatorstests were also added to the other 3 `takeuntil` variants (for `completable` it is delegated to `amb`)fixes: #6018  merging 6019  < 
6021,1,0,0,0,0,1,1,0,2x: singleflatmappublisher full implementation see discussion in #6015resolves: #6015  merging 6021  < 
6021,1,0,0,0,0,1,1,0,2x: singleflatmappublisher full implementation see discussion in #6015resolves: #6015  merging 6021  < 
6026,1,0,1,0,0,1,1,0,fix flowableblockingsubscribe is unbounded and can lead to oome create and bound new `blockingsubscribe` overloads to `buffersize`* create new overloads with `buffersize`* create a `boundedconsumer`* create a `boundedsubsciber`close: #5988  merging 6026 
6036,1,0,0,0,0,1,1,0,2x: fix disposed lambdaobserver onerror to route to global error handler fix the behaviour of lambdaobserver when disposed to route to the global error handler6025  merging 6036 
6049,1,0,0,0,0,0,1,0,make it explicit that throttlewithtimout is an alias of debounce the documentation implies that these two methods are somewhat different fixing that confusion as discussed in #6043:- made the descriptions of these methods the same- mentioned that it is an alias in the first paragraphs of `throttlewithtimeout` javadoc comments- removed the links to third-party websites build warnings: please avoid dangling `<p>` tags:  ||  merging 6049 
6052,1,0,0,0,0,0,1,0,#5980 made subscribeactual protected ### proposalchanged `subscribeactual` from `public` to `protected` as described in #5980### how i testedran tests locally please let me know if i missed part of the contributing guidelines 👼 fixes: #5980 /cc @vanniktech @artem-zinnatullin @davidmoten strictly speaking this is technically a breaking change on something that shouldnt be in use at all by external developers im fine with this change for 2115 ||  merging 6052 
6053,1,0,0,0,0,0,1,0,2x: add maybe marble diagrams 06/21/a resolved the following diagrams of #5806:#### amb: missing diagram( ambarray: missing diagram![image]( concat(iterable): missing diagram![image]( concat(publisher): missing diagram![image]( concat(publisher int): missing diagram![image]( concatarray: missing diagram![image]( concatarraydelayerror: indicate error delayed 1 marble per source![image]( concatarrayeager: missing diagram![image]( concatdelayerror(iterable): missing diagram![image]( concatdelayerror(publisher): missing diagram![image]( concateager(iterable): missing diagram![image]( concateager(publisher): missing diagram![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeconcateagerppng)  merging 6053 
6060,1,0,0,0,0,1,1,0,2x: fix concatmap{single|maybe} null emission on dispose race this pr fixes a bug in all 4 specialized `concatmap` implementation that allows `null` to be emitted when the success signal of the inner source races with the dispose signal of the sequencelikely fixes: #6059 a very similar thing happened in #5927 just after a release but this bug was there between 2111 and 2114  ||  merging 6060 
6074,1,0,0,0,0,0,1,0,add marble diagram to the singlenever method first of all im extremely grateful to open my first pr for rxjava i hope that ill be able to tick more of the marbles from #5788 but for now this should tick off the `never` operatorplease let me know if i need to change anything on the diagram itself if not please send me url when you upload image within the project so i can change url for the marble in the pr  merging 6074 
6075,1,0,0,0,0,0,1,0,add marble diagram to the singlefilter method hopefully this should tick off the `filter` operator in #5788please let me know if i need to change anything on the diagram itself if not please send me url when you upload image within the project so i can change url for the marble in the pralthough i had a doubt and wanted to double check operator `filter` returns `maybe` which essentially will call `onsuccess` or `oncomplete` by running junit tests i could observe that this is a behavior but if i use `testobserver` then both `assertvalue()` and `assertcomplete()` are invoked when there are elements that satisfy `filter` condition  merging 6075 
6076,1,0,0,0,0,0,1,0,add marble diagrams to the singledelay method here are marbles for `delay` operator in #5788please let me know if i need to change anything on the diagram itself if not please send me url when you upload image within the project so i can change url for the marble in the pr  merging 6076  < 
6077,1,0,0,0,0,0,1,0,add marble diagram for singlehide operator this should complete `hide` operator in #5788please let me know if i need to change anything on the diagram itself if not please send me url when you upload image within the project so i can change url for the marble in the pralthough i wasnt sure if i should represent somehow that `disposable` is hidden as well if so can you please tell me how to represent that on marble?  merging 6077  < 
6079,1,0,0,0,0,1,1,0,2x: add completabletakeuntil(completable) operator this pr adds the missing dedicated `takeuntil` operator to `completable`( the same effect could be achieved via the `ambwith` but there are two benefits of a dedicated operator:- easier to discover based on the `takeuntil` operator in other types- more direct implementation unlike `ambwith` which is built upon an n-ary `amb` operator with additional overheadthere was a feature request in #3708 some time ago but apparently the issue got closed off after `singletakeuntil` was implemented  merging 6079 
6081,1,0,0,0,0,0,1,0,add marble diagrams for singlerepeat operators here are marbles for `repeat` `repeat(times)` and `repeatwhen` operator in #5788please let me know if i need to change anything on the diagram itself if not please send me url when you upload image within the project so i can change url for the marble in the pri intentionally added two diagrams for `repeatwhen` as i would say its interesting case that people should be aware of**edit:**here are marbles`repeat` operator:![repeat]( operator:![repeat with count]( operator:![repeatwhen](https://rawentcom/umfsimke/rxjava/images/images/repeatwhenpng)  merging 6081 
6083,1,0,0,0,0,0,1,0,2x: add completable marble diagrams (07/17a) this pr adds the following marble diagrams to `completable` operators (#5789):#### amb ambarray( complete![image]( concatarray concat![image]( defer![image]( error![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableerrorpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableerrorfpng)  merging 6083 
6084,1,0,0,0,0,0,1,0,add marble diagram for singlerepeatuntil operator here is marble for `repeatuntil` operator in #5788![repeatuntil]( let me know if i need to change anything on the diagram itself if not please send me url when you upload image within the project so i can change url for the marble in the pr ` ||  merging 6084 
6085,1,0,0,0,0,1,1,0,2x: more completable marbles (+18) add completablefrommaybe this pr adds marble diagrams (#5789) to the following operators as well as adds the missing `completablefrommaybe` operator (`fromx` of other types were already there uses existing `maybeignoreelement`s underlying implementation)#### fromaction( fromcallable![image]( fromfuture![image]( frommaybe![image]( fromobservable![image]( frompublisher![image]( fromsingle![image]( mergearray & mergearraydelayerror![image]( merge(both `iterable` and `publisher` variants)![image]( mergedelayerror(both `iterable` and `publisher` variants)![image]( never![image]( timer![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completabletimerpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completabletimerspng)  merging 6085 
6086,1,0,0,0,0,0,1,0,single error operators marbles here are marbles for #5788 for `error(callable)`![errorcallable]( `error(throwable)` only added error event to be red:![errorthrowable]( `onerrorreturn`![onerrorreturn]( `onerrorreturnitem`![onerrorreturnitem]( `onerrorresumenext(singlesource)`![onerrorresumenext]( `onerrorresumenext(function)`![onerrorresumenextfn](https://rawentcom/umfsimke/rxjava/images/images/onerrorresumenextwithfnpng) for the `onerrorx` please indicate the normal case via different marble (ie the usual split diagram)btw you can save yourself a commit if you follow the following naming in the javadocs:` `xxxx` is the name of the operator such as `error` and may contain argument indicator letters:- `s` is for `scheduler`s or `single`- `t` is for timed- `n` is for some numerical value- `f` is for function or `flowable`- `c` is for callable or `completable`- `p` is for `publisher`- `m` is for `maybe` or some other numerical valuethus the image naming of this pr will look like this:-` ||  merging 6086 
6087,1,0,0,0,0,0,1,0,add marbles for singlefrom operators here are marbles for `fromcallable` `frompublisher` and `fromobservable` operators from #5788 marble for `fromcallable`![fromcallable]( for `frompublisher`![frompublisher]( for `fromobservable`![fromobservable](https://rawentcom/umfsimke/rxjava/images/images/fromobservablepng)  merging 6087 
6091,1,0,0,0,0,0,1,0,add marbles for singleamb operators here are operators for `amb` and `ambarray` from #5788 marble for `amb`:![amb]( for `ambarray`:![ambarray](https://rawentcom/umfsimke/rxjava/images/images/ambarraypng)  merging 6091 
6095,1,0,0,0,0,0,1,0,add marbles for singletimer singledefer and singletoxxx operators here are marbles for `defer` `timer(delay unit)` `timer(delay unit scheduler)` `toflowable` `tomaybe` `tofuture` operators in #5788 marble for `defer`:![defer]( for `timer(delay unit)`:![timer]( for `timer(delay unit scheduler)`:![timerscheduler]( for `tofuture` although for this one i believe we should add case when there is no event sent from single as there will be timeout exception thrown:![tofuture]( for `tomaybe`:![tomaybe]( for `toflowable` although here i didnt figured out what will happen if we request more than 1 event from flowable:![toflowable](https://rawentcom/umfsimke/rxjava/images/images/toflowablepng) defer: i would have drawn it with a curly brace listing the 3 options below each other please add the subscribe() indicators as welltofuture: i indicate future<t> with a 6-sided shape and indicate get() call and a return see completablefromfuture for an exampletoflowable: simply indicate request(n) any positive n has the same effect with this operator however an error is always pushed through even without a request just remove the request(1) from that side of the diagram ||  merging 6095  < 
6097,1,0,0,0,0,0,1,0,2x: add missing completable marbles (+19 07/19a) this pr add even more missing marbles to `completable` (tracked by #5789):#### delay( doonx![image]( dofinally![image]( onerrorcomplete![image]( onerrorresumenext![image]( onterminatedetach![image]( mergewith![image]( concatwith![image]( observeon![image]( hide![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completablehidepng)  merging 6097 
6098,1,0,0,0,0,0,1,0,2x: several more completable marbles (7/19b) this pr adds a couple of more marble diagrams to `completable` (#5789):#### subscribeon( unsubscribeon![image]( tosingle tosingledefault![image]( toflowable![image]( tomaybe![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completabletomaybepng)  merging 6098 
6101,1,0,0,0,0,0,1,0,2x: final set of missing completable marbles (+26) this pr contains the final set of missing `completable` marbles (#5789):#### repeat( repeatuntil![image]( repeatwhen![image]( retry![image]( retrywhen![image]( startwith![image]( timeout![image]( create![image]( unsafecreate![image]( lift![image]( subscribe![image]( subscribewith![image]( test![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completabletestpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completabletestbpng)  merging 6101 
6137,1,0,0,0,0,0,1,0,2x: add marbles for singleconcat operator here are marbles for `concat(iterable)` `concat(publisher)` `concat(publisher prefetch)` `concat(observable)`  `concat(source1 source2)` `concat(source1 source2 source3)` `concat(source1 source2 source3 source4)` and `concatarray` operators that should close them at #5788 marble for `concat(iterable)`![concatiterable]( for `concat(publisher)`![concatpublisher]( for `concat(publisher prefetch)`![concatpublishern]( for `concat(observable)`![concatobservable]( for `concat(source1 source2)`![concat2]( for `concat(source1 source2 source3)`![concat3]( for `concat(source1 source2 source3 source4)`![concat4]( for `concatarray`![concatarray]( pay attention to file names in javadoc as i was not sure how to name `concat(iterable)` so ive added at the end `i` for `concat(observable)` ive added `o` for `concat(source1 source2 source3)` and `concat(source1 source2 source3 source4)` ive used `n` and `m` as they are numerical valuesalso is there an error in `concat(publisher)` and `concat(publisher prefetch)` with `request()` commands? i did used as a reference `completableconcat(publisher)` marble but i do not understand why do we have `request(1)` after first event as we already requested prefetching of multiple ones is it because others are still not produced?thanks  merging 6137 
6141,1,0,0,0,0,0,1,0,add marble diagrams for various single operators here are marble diagrams for various single operators that will close some of the #5788 marble for `concateager(publisher)`![concateeagerp]( for `concateager(iterable)`![concateeageri]( for `create`![create]( for `ambwith`![ambwith]( for `equals`![equals]( for `merge(source1 source2)`![merge]( for `merge(source1 source2 source3)`![mergethree]( for `merge(source1 source2 source3 source4)`![mergefour]( for `merge(singlesource<singlesource>)`![mergesinglesource]( for `mergewith`![mergewith]( for `doafterterminate`![doafterterminate]( for `to`![to]( for `as`![as]( for `compose`![compose]( for `doaftersuccess`![doaftersuccess]( for `merge(publisher)`![mergepublisher]( for `merge(iterable)`![mergeiterable](https://rawentcom/umfsimke/rxjava/images/images/mergeiterablepng)  merging 6141 
6143,1,0,0,0,0,0,1,0,2x: add concatarrayeagerdelayerror operator (expose feature) this pr exposes the existing `delayerror` capability of the `concatmapeager` operator as `concatarrayeagerdelayerror` for both `flowable` and `observable`in addition the `concatarrayeager` and these new methods receive marble diagrams:#### observable( flowable![image]( #6082 *(sidenote: one of the validators had to be adjusted due to false positive it produced)*  merging 6143 
6145,1,0,0,0,0,1,1,0,2x: fix boundary fusion of concatmap and publish operator this pr fixes the lack of boundary fusion marker in the `concatmap` and `publish` operators that can break the thread-confinement expectation when using `observeon` upstream and a thread-sensitive operator:```javasourceobserveon(scheduler)    map(/* some thread-sensitive operation */)    publish() // or concatmap```by default these operators may call `poll` from any of the participating threads which would otherwise dequeue `observeon` and execute `map` on that threadthe fix adds the necessary flag to both operators `onsubscribe` logic for a temporary workaround one should use `hide()` before such operators to make sure fusion doesnt happenfixes: #6144  merging 6145 
6152,1,0,0,0,0,0,1,0,2x: clarify testobserverassertvalueset in docs and via tests clarify that `{testobserver|testsubscriber}assertvalueset` checks for all received items to be in the provided set but that set can contain additional elements that could have been received unit tests have been added to demonstrate the expected behaviorresolves: #6151  merging 6152 
6155,1,0,0,0,0,0,1,0,2x: fix marble of maybeflatmap events to maybesource fix the marble diagram of the event-mapping [`maybeflatmap`]( operator:( in: #5806  merging 6155 
6167,1,0,0,0,0,1,1,0,2x: make observeon not let workerdispose() called prematurely some operators may call `dispose()`/`cancel` from `onerror`/`oncomplete` which could trigger a permature call to `workerdispose()` that was about to happen anyway this pr prevents this by moving the operator into its disposed/cancelled state before signaling the terminal event thus a downstream `cancel()`/`dispose()` call wont trigger this premature cleanupsuch premature cleanups may cause unwanted `schedulersio()` reuse in some scenariosrelated: #6146 there are 2 x 2 tests that were relying on a race that the previous behavior always allowed ive updated those tests to avoid the inherent termination-cancel race in them ||  merging 6167 
6175,1,0,0,0,0,1,1,0,2x: explain null observer/subscriber error reports in detail from rxjavaplugins this pr is related to issue 6172]( these changes all reactive types will emit detailed error message when `onsubscribe` hook installed using rxjavaplugins returns null `observer/subscriber`:**observable**> "the rxjavapluginsonsubscribe hook returned a null observer please check the handler provided to rxjavapluginssetonobservablesubscribe for invalid null returns further reading:  the rxjavapluginsonsubscribe hook returned a null flowablesubscriber please check the handler provided to rxjavapluginssetonflowablesubscribe for invalid null returns further reading:  the rxjavapluginsonsubscribe hook returned a null singleobserver please check the handler provided to rxjavapluginssetonsinglesubscribe for invalid null returns further reading:  the rxjavapluginsonsubscribe hook returned a null maybeobserver please check the handler provided to rxjavapluginssetonmaybesubscribe for invalid null returns further reading:  the rxjavapluginsonsubscribe hook returned a null completableobserver please check the handler provided to rxjavapluginssetoncompletablesubscribe for invalid null returns further reading:  :** there was no null check on `observer` returned from `rxjavapluginsonsubscribe(this observer)` method call in `completable`s subscribe() method so ive added it in this pr is that fine?   merging 6175 
6187,1,0,0,0,0,0,1,0,2x: fix refcount termination-reconnect race this pr modifies the `refcount` operator (in both `flowable` and `observable` types) to avoid certain termination-reconnection racesthe original race could happen when the refcounted source terminated at the same time as new observers arrived leaving those new observers hanging as they practically joined a dying connection and got possibly undercut by the `dispose` callthe change involve a new internal interface `resettableconnection` that will allow resetting the connection object inside the connectable source if it is equal to the connection object known by the initiator of the original `connect` call6185  merging 6187  
6193,1,0,0,0,0,0,1,0,add "error handling" java docs section to from callable & co 6179added javadocs describing the regular and canceled/disposed behavior for- `observablefromcallable()`- `singlefromcallable()`- `maybefromaction()`- `completablefromcallable()`- `completablefromaction()`- `flowablefromcallable()`did not alter `maybefromcallable()` because the existing javadoc appears to be adequate  merging 6193  
6197,1,0,0,0,0,0,1,0,#6195 fix flowablereduce(bifunction) javadoc empty source does not signal nosuchelementexception6195  merging 6197 
6199,1,0,0,0,0,0,1,0,fix terminology of cancel/dispose in the javadocs 6196changing terminology from cancel -> dispose wherever appropriate in the following classes:- `observablejava`- `singlejava`- `maybejava`- `completablejava`areas where i did _not_ change from cancel -> disposal include: - where the cancellation was in reference to a `flowable` `publisher` or a `future`- `test()` methods where the `testobserver` returned actually has a `cancel()` method  merging 6199 
6200,1,0,0,0,0,0,1,0,2x: fix tofuture marbles and descriptions this pr fixes the marble diagrams of `flowabletofuture` and `observabletofuture` to indicate:- multi-valued sources signal `indexoutofboundsexception`- source has to be finite for the `future` to terminate( #6198(also fixes the diagram for #5813)  merging 6200 
6232,1,0,0,0,0,1,1,1,2x: cleanup observableflatmap drain logic cleanup the drain logic of `observableflatmap` by removing unnecessary loops and fixing the index management in case of a fused failure in one of the sources triggering another round over the same source unnecessarilyresolves: #6231  merging 6232 
6254,1,0,0,0,0,1,1,1,2x: fix flaky sample() backpressure test improve coverage use processors to trigger the `missingbackpressureexception` case instead of the timer which could fire prematurely and stop the sequence before the first item was sent by the `behaviorprocessor`also small improvements to the code coverage of `flowablesample`6253  merging 6254 
6258,1,0,0,1,0,1,1,1,2x: fix cancel/dispose upon upstream switch for some operators this pr extends the `subscriptionarbiter` to optionally allow or disallow cancelling the current `subscription` if it is replaced by a new one some operators do not need to cancel the current `subscription`: `concat` `concatmap` `repeat` `repeatwhen` `retry` and `retrywhen` in addition `repeatwhen` and `retrywhen` were cancelling when the handler sequence itself terminated the code has been updated to disconnect the upstream upon the completion/failure but before signaling the handlerthe reactive streams specification also disallows synchronous cancellation after the terminal event anywayothers may actually need to cancel such as `timeout` `observable`s dont have a specific arbiter they use the `disposablehelper` methods and the relevant ones were changed to `replace()` instead of the disposing `set` callsome tests actually checking if the dispose/cancel happens and had to be updatedthe `flowabledelaysubscription(publisher)` also used `subscriptionarbiter` but it was unnecessary the code has been replaced with a more apt deferred requesting scheme as the downstream requests need to be delayed until the main subscription happens the other publisher is always consumed unboundedresolves: #6259  merging 6258 
6269,1,0,0,1,0,1,1,1,2x: call the doon{dispose|cancel} handler at most once this pr makes sure the `doondispose` `dooncancel` and `doonlifecycle` execute their cancellation handler onceresolves: #6268  merging 6269 
6275,1,0,0,0,0,1,1,1,2x: improve the observable/flowable cache() operators this pr rewrites the `observablecache` and `flowablecache` operators to allocate less and be more up-to-date algorithmicallyive also added comments to help understand its inner workings in case someone is interestedresolves: #6270  merging 6275  < 
6278,1,0,0,0,0,1,1,0,2x: add materialize() and dematerialize() this pr adds the `materialize` operator to `maybe` `single` and `completable` to turn their signals into the corresponding `notification` object this operator has been available for `observable`s (and `flowable`s) from the beginning of the rx api the methods return `single<notification<t>>`to complement the `dematerialize` operator is only defined for `single` and results in a `maybe`if accepted ill draw the correct marble diagrams for them in a separate prresolves: #6272  merging 6278 
6287,1,0,0,0,0,0,1,0,2x: expose the keep-alive value of the io scheduler as system property (#6279) configuring keep-alive through system propertyresolves: #6279  merging 6287 
6287,1,0,0,0,0,0,1,0,2x: expose the keep-alive value of the io scheduler as system property (#6279) configuring keep-alive through system propertyresolves: #6279  merging 6287 
6297,1,0,0,1,0,1,1,1,2x: fix refcount eager disconnect not resetting the connection this pr fixes the case when an observer/subscriber disposes/cancels immediately upon subscribing to a `refcount` operator before it establishes the connection and ends up with a disposed but non-reset connection preventing further interactions with the connectable sourcethe fix is to detect this case and reset the connection when the `connect()` method signals the dispose handlerboth `connectableflowablerefcount` and `connectableflowablerefcount` is affectedfixes: #6296  merging 6297 
6303,1,0,0,0,0,0,1,0,javadoc: fix incorrect image placement add `<p>` before image elements in javadocresolves: #6302  merging 6303 
6305,1,0,0,0,0,0,1,0,javadoc : explain explicitly about using emitter interface methods synchronously add note in javadoc explicitly explaining about using emitter interface methods synchronously- add notes for `generate` methods in observable and flowable- plus add the similar note to emitter interfaceresolves: #6299  merging 6305  < 
6308,1,0,0,0,0,0,1,0,javadoc updates for rxjava issue 6289 updates to ioreactivexflowable javadocs as per #6289 updated docs for all 6 flowablegroupby() methods  merging 6308  < 
6311,1,0,0,0,0,1,1,1,javadoc: explain that distinctuntilchanged requires non-mutating data to work as expected - add note in javadoc for all `distinctuntilchanged()` methods in `flowable` and `observable` class explaining about unexpected results to expect when using mutable data sources like **mutable charsequence** or **lists**resolves: #6290  merging 6311 
6313,1,0,0,0,0,0,1,0,adding nonnull annotations to observable & single adding nonnull annotations in factory methods for improved code compilationresolves: #6309 #6309 @akarnokd can you pls take a look at this and review ? || thanks for contributing a few points:- you dont have to keep the welcome text of the pr thats for telling contributors what to do see the updated text for future reference- didnt you mean to add `@nonnull` to the arguments rather than to the return value? ||  merging 6313 
6321,1,0,0,0,0,0,1,0,fix flowable#toobservable backpressure support 6320  merging 6321  < 
6359,1,0,0,0,0,1,1,1,2x: fix the error/race in observablerepeatwhen due to flooding repeat signal this pr fixes a race condition in the `observablerepeatwhen` operator for the case when the repeat signal is not 1-for-1 and a new subscription may race with the clearing of the previous disposable because `active` is set to `false` too early the fix is to swap the two operations `observableretrywhen` and the `flowable` versions do not have this bug unit tests were added to all 4 operators to verify the correct behavior regardlessfixes: #6358  merging 6359 
6364,1,0,0,0,0,1,1,0,2x: fix publish not requesting upon client change due to a bug in the `flowablepublish` operator it is not requesting more if there was a change in the subscriber array during an emission run in the non-fused operation modefixes: #6363  merging 6364  < 
6370,1,0,0,0,0,1,1,0,2x: add interruptible mode to schedulersfrom by default the `schedulersfrom` uses a trampoline to ensure worker tasks are executed fifo and non-overlappingly on any potentially multi-threaded `executor` this old setup didnt allow task interruption due to this disconnect between the trampoline task and the operator task (in contrast the standard schedulers use single threaded executors and their `future` is linked and interruptible when the operator task is cancelled)this pr add an interruptible mode to the `schedulersfrom` via a paramerer in a new overload and some internal dispatching based on this mode selector existing `schedulersfrom(executor)` users should still behave the sameresolves: #6368  merging 6370 
6375,1,0,0,0,0,1,1,0,2x: dont dispose the winner of {single|maybe|completable}amb() this pr fixes the `singleamb` `maybeamb` and `completableamb` operators to not dispose the winner source causing potential interruptions as a side-effect on the current threadthe fix is to [delete]( the winner from the composite before disposing the rest to avoid the interruption raceunit tests were added to verify this behavior on all `amb` implementations `flowable` and `observable` were already working correctlyfixes: #6373  merging 6375 
6377,1,0,0,0,0,0,1,0,expand `observable#debounce` and `flowable#debounce` javadoc mention that if the processing of a task takes too longand a newer item arrives then the previous task willget disposed interrupting a long running workfixes: #6288  merging 6377 
6386,1,0,0,0,0,1,1,0,add doonterminate to single/maybe for consistency this pr adds doonterminate operator to single and mayberesolves: #6379  merging 6386 
6405,1,0,0,1,0,1,1,0,2x: fix concateager to dispose sources & clean up properly this pr fixes the `concatmapeager` operator (which drives the static variants as well) to properly dispose and clean up the state of the operator upon cancelling/disposing the sequence- `flowableconcatmapeager` did not cancel the current active inner consumer only the ones coming after- `observableconcatmapeager` did not dispose the main source of the inner observablesboth variants have received the same two unit tests to verify their behaviorfixes: #6404  merging 6405 
6408,1,0,0,0,0,0,1,0,improving javadoc of flattenasflowable and flattenasobservable method improving the javadoc of the `flattenasflowable` and `flattenasobservable` methods of `single` and `maybe` classesresolves: #6276  merging 6408 
6432,1,0,0,0,0,0,1,0,2x composite disposable docs on compositedisposable add and addall methods if the param is null currently the npe error message (produced by objecthelper) is "d is null" which is not very helpfulthis is a small refactor for making the message a bit more helpful6430   merging 6432 
6452,1,0,0,0,0,0,1,0,remove dependency of schedulers from observablerefcount 6451in the constructor of `observablerefcount` that takes `connectableobservable<t> source` as the argument we set `timeout` to `0l` in that specific use case of `observablerefcount` `scheduler` is never needed its only referenced in `cancel()` method but if timeout is 0 it wont be triggered at all because there is early return this commit removes the need to depend on `schedulerstrampoline()` and instead passes null to be scheduler when the ref count is not time-based similarly applies the same change to `flowablerefcount`the reasons for this change are the following:1 in projects that dont depend on `schedulers` class if there is no reference to `schedulers` the whole `schedulers` can be stripped out of the library after optimizations (eg proguard) with constructor that references `schedulers` the optimizer cant properly strip it out in our quick test of our android app we were able to reduce the rxjava library size dependency from 51kb to 37kb (after optimization but before compression) by simply avoiding access to `schedulers` in `observablerefcount`2 in terms of modularity `observablerefcount` is just an operator so it by itself should probably not have dependency on what available pool of schedulers (`schedulers`) there are it should just know that there is some `scheduler` that could be passed to `observablerefcount` when `observablerefcount` needs it  merging 6452 
6458,1,0,0,1,0,1,1,1,update the javadoc of the `retry` operator specify that the `times` function parameter describes "the number of timesto resubscribe if the current observable fails"solves: #6402 bellow is the marble with the number of retries decreased from 2 to 1 if the marble is correct can you upload it to the repository?![retry o n]( || sure could you also make sure all the other counted `retry()` operators in the other base classes have the correct wording? ||  merging 6458  < 
6461,1,0,0,0,0,0,1,0,change error message in observablefromarray changed the error message when an element at position i is null to what was suggested in #6460 could you please update these locations as well?  ||  merging 6461 
6469,1,0,0,1,0,1,1,1,remove redundant methods from sample(observable) resolves: #6468  merging 6469 
6483,1,0,0,0,0,0,1,0,correction for maybecount doc typo 6481  merging 6483 
6488,1,0,0,1,0,1,1,1,2x: fix zip not stopping the subscription upon eager error the `observablezip` did not stop subscribing to the next sources if the previous one failed with an `onerror` `flowablezip` works as intended6487  merging 6488 
6519,1,0,0,1,0,1,1,1,3x: connectableflowable/connetableobservabe redesign this pr changes the connectable api to have a specific `reset` method to reset a terminated connectable source as part of the official apiin 2x when `publish()` terminated it reset itself to a fresh state which could lead to late consumers not receiving events as there might be no one to call `connect()` again (see #6501) however `replay()` did not reset itself thus late consumers got the cached events however a reconnect started the sequence and new consumers may have missed itemsin 3x this two corner cases have been  by the introduction of `reset()` both `publish` and `replay` now remain in their terminated state until `reset` is called if the connection is disposed it will automatically reset their state just like before the state transitions are as follows:1 **fresh** -> `connect()` -> **running** -> `oncomplete()`/`onerror()` -> **terminated** -> `reset()` -> **fresh**2 **fresh** -> `connect()` -> **running** -> `dispose()` -> **fresh**3 **fresh** -> `connect()` -> **running** -> `oncomplete()`/`onerror()` -> **terminated** -> `dispose()` -> **fresh**4 **fresh** -> `connect()` -> **running** -> `oncomplete()`/`onerror()` -> **terminated** -> `connect()` -> **running**this does resolve the race condition with `publish()refcount()` described in #6501in addition there are some changes to `flowablepublish()`s behavior:it no longer keeps consuming the upstream if there are no subscribers this implies if the source terminates while there are unconsumed items in the internal buffer those will be available for observation*i have no strong preference on this property and in comparison `observablepublish` drops items because there is no backpressure buffer in its implementation*upstream errors are not reported to the `rxjavapluginsonerror` handler when if there are no subscribers but have to be observed via a subscriber*because terminal events are available until `reset` now we cant know really if there is going to be a subscriber or not however it might be possible to detect the no-consumer case upon an error and still report it when `reset` or `dispose` is called*5628resolves #5899  merging 6519 
6519,1,0,0,1,0,1,1,1,3x: connectableflowable/connetableobservabe redesign this pr changes the connectable api to have a specific `reset` method to reset a terminated connectable source as part of the official apiin 2x when `publish()` terminated it reset itself to a fresh state which could lead to late consumers not receiving events as there might be no one to call `connect()` again (see #6501) however `replay()` did not reset itself thus late consumers got the cached events however a reconnect started the sequence and new consumers may have missed itemsin 3x this two corner cases have been  by the introduction of `reset()` both `publish` and `replay` now remain in their terminated state until `reset` is called if the connection is disposed it will automatically reset their state just like before the state transitions are as follows:1 **fresh** -> `connect()` -> **running** -> `oncomplete()`/`onerror()` -> **terminated** -> `reset()` -> **fresh**2 **fresh** -> `connect()` -> **running** -> `dispose()` -> **fresh**3 **fresh** -> `connect()` -> **running** -> `oncomplete()`/`onerror()` -> **terminated** -> `dispose()` -> **fresh**4 **fresh** -> `connect()` -> **running** -> `oncomplete()`/`onerror()` -> **terminated** -> `connect()` -> **running**this does resolve the race condition with `publish()refcount()` described in #6501in addition there are some changes to `flowablepublish()`s behavior:it no longer keeps consuming the upstream if there are no subscribers this implies if the source terminates while there are unconsumed items in the internal buffer those will be available for observation*i have no strong preference on this property and in comparison `observablepublish` drops items because there is no backpressure buffer in its implementation*upstream errors are not reported to the `rxjavapluginsonerror` handler when if there are no subscribers but have to be observed via a subscriber*because terminal events are available until `reset` now we cant know really if there is going to be a subscriber or not however it might be possible to detect the no-consumer case upon an error and still report it when `reset` or `dispose` is called*5628resolves #5899  merging 6519 
6519,1,0,0,1,0,1,1,1,3x: connectableflowable/connetableobservabe redesign this pr changes the connectable api to have a specific `reset` method to reset a terminated connectable source as part of the official apiin 2x when `publish()` terminated it reset itself to a fresh state which could lead to late consumers not receiving events as there might be no one to call `connect()` again (see #6501) however `replay()` did not reset itself thus late consumers got the cached events however a reconnect started the sequence and new consumers may have missed itemsin 3x this two corner cases have been  by the introduction of `reset()` both `publish` and `replay` now remain in their terminated state until `reset` is called if the connection is disposed it will automatically reset their state just like before the state transitions are as follows:1 **fresh** -> `connect()` -> **running** -> `oncomplete()`/`onerror()` -> **terminated** -> `reset()` -> **fresh**2 **fresh** -> `connect()` -> **running** -> `dispose()` -> **fresh**3 **fresh** -> `connect()` -> **running** -> `oncomplete()`/`onerror()` -> **terminated** -> `dispose()` -> **fresh**4 **fresh** -> `connect()` -> **running** -> `oncomplete()`/`onerror()` -> **terminated** -> `connect()` -> **running**this does resolve the race condition with `publish()refcount()` described in #6501in addition there are some changes to `flowablepublish()`s behavior:it no longer keeps consuming the upstream if there are no subscribers this implies if the source terminates while there are unconsumed items in the internal buffer those will be available for observation*i have no strong preference on this property and in comparison `observablepublish` drops items because there is no backpressure buffer in its implementation*upstream errors are not reported to the `rxjavapluginsonerror` handler when if there are no subscribers but have to be observed via a subscriber*because terminal events are available until `reset` now we cant know really if there is going to be a subscriber or not however it might be possible to detect the no-consumer case upon an error and still report it when `reset` or `dispose` is called*5628resolves #5899  merging 6519 
6522,1,0,0,0,0,1,1,0,2x: fix concatmapdelayerror not continuing on fused inner source crash the `callable` fused path didnt consider the error-delay settings and cut the sequence shortfixes: #6520  merging 6522  < 
6523,1,0,0,0,0,1,1,0,3x: fix concatmapdelayerror not continuing on fused inner source crash the `supplier` fused path didnt consider the error-delay settings and cut the sequence shortfixes: #6520  
6525,1,0,0,0,0,1,1,0,3x: remove `test` from `testxxx` method names create a validator 6518-  create validator-  automatically rename methods "testxxx" to "xxx" (analog to [fixlicenseheaders]( check)-  rename methods  merging 6525 
6528,1,0,0,0,0,1,1,0,rename test methods and enable the check 6518    no coverage uploaded for pull request base (`3x@edb1f71`) [click here to learn what that means]( `n/a`(                                  3x    #6528   +/-   ##  coverage       ?   9822%             complexity     ?     6157             files          ?      675  ?    44785     ?     6181             hits           ?    43989             misses         ?      274             partials       ?      522```------[continue to review full report at codecov]( **legend** - [click here to learn more]( `δ  absolute <relative> (impact)` `ø  not affected` `?  missing data`> ( last update [edb1f7135e510a]( read the [comment docs]( ||
6532,1,0,0,1,0,1,1,1,3x: add eager truncation to bounded replay() to avoid item retention this pr adds the `eagertruncate` option to the `replay` operator so that the `head` node will lose the item reference it holds upon truncationthe bounded buffers in `replay` implement a linked list that when truncated moves the head reference forward along the links atomically this allows late consumers to pick up the head and follow the links between them to get items replayed however the truncation may happen concurrently with a consumer working on some prior nodes so if the truncation would `null` out the value the consumer reaching the same node would see `null` as well and fail( avoid this type of retention the head node has to be refreshed with a new node still pointing to the next node in the chain but without any value ![image]( reason this is not the default is that it requires an additional allocation for each new incoming value when the buffer is full which would reduce performance in cases where the excess retention is not a problemoverloads to both the direct and function-variants of both `flowablereplay()` and `observablereplay()` have been added to avoid too many overloads only one extra overload has been added extending the signature of the longest parameterized method per each bounds mode (size time time+size)their unit test files have been cloned so that both the non-eager (original) behavior and the eager behavior is tested separately6475  merging 6532  < 
6534,1,0,0,0,0,1,1,1,3x: make using() resource disposal order consistent with eager-mode make the resource disposal order in all `using` implementations are consistent with the eagerness of the operator:**eager**: dispose resource then dispose the upstream**non-eager**: dispose the upstream then dispose the resourcefixes: #6347  merging 6534 
6538,1,0,0,1,0,1,1,1,3x: add concatmap with scheduler guaranteeing where the mapper runs this pr adds an overload to `concatmap` and `concatmapdelayerror` in both `flowable` and `observable` which makes sure the `mapper` function is always executed on a dedicated schedulerby default `concatmap` may execute the `mapper` function on various threads: the subscribing thread the upstream thread generating the items to be mapped or the thread where the generated inner source terminates these overloads remove this kind of uncertaintythe implementation is a copy of the original concatmap instead of an extension so that optimizations for the non-scheduled variants still work without extra overheadoverloads to the `concatmap{single|maybe|completable}` and `concatmap{single|maybe|completable}delayerror` *may be added* in a separate pr later6447  merging 6538 
6544,1,0,0,0,0,0,1,0,fixing version tag on schedulersfrom(executor boolean) 6543 updating the version tag on `schedulersfrom(executor boolean)` since it was promoted  merging 6544 
6556,1,0,0,1,0,1,1,1,3x rename on error resume next methods to disambiguate when calling from kotlin (#6551) 6551 - renamed `onerrorresumenext(source)` to `onerrorresumewith(source)` for `observable` `maybe` `single` and `flowable`- renamed some unit tests and their classes to reflect the method name change- changed parameter type of `singleonerrorresumewith` from `single` to `singlesource`  - updated javadocs for all renamed methods- removed redundant casts for unit tests- deleted duplicate unit test that arose from no longer needing to cast arguments  
6559,1,0,0,0,0,1,1,1,3x fix npe when debouncing empty source **background** related issue #6558 debounce with selector on the empty `observable` leads to npeit happens because of `debounceobserver#debouncer` field is set up only when `onnext` is called when `onnext` isnt called at all like when debouncing `observableempty()` we get a null reference from `debouncer` and call `emit` on `null` which actually leads to npe**change**wrap `emit` call with null check both in `observabledebounce` and `flowabledebounce`**test plan**to check `observable`:```/gradlew test --tests "ioreactivexinternaloperatorsobservableobservabledebouncetestdebounceonempty`to check `flowable`:```/gradlew test --tests ""ioreactivexinternaloperatorsflowableflowabledebouncetestdebounceonempty""````"  merging 6559 
6560,1,0,0,0,0,1,1,1,2x fix npe when debouncing empty source **background** related issue #6558 cherry pick of #6559 for 2x versiondebounce with selector on the empty `observable` leads to npeit happens because of `debounceobserver#debouncer` field is set up only when `onnext` is called when `onnext` isnt called at all like when debouncing `observableempty()` we get a null reference from `debouncer` and call `emit` on `null` which actually leads to npe**change**wrap `emit` call with null check both in `observabledebounce` and `flowabledebounce`**test plan**to check `observable`:```/gradlew test --tests "ioreactivexinternaloperatorsobservableobservabledebouncetestdebounceonempty`to check `flowable`:```/gradlew test --tests ""ioreactivexinternaloperatorsflowableflowabledebouncetestdebounceonempty""````"  merging 6560 
6564,1,0,0,1,0,1,1,1,3x: remove buffer/window with supplier & onexceptionresumenext this pr removes 3 kinds of operators that had no noticeable use bases or use cases on their own in the past years- `buffer(supplier [ supplier])`- `window(supplier [ int])`- `onexceptionresumenext(<source>)`6554 resolves #6555  merging 6564  < 
6564,1,0,0,1,0,1,1,1,3x: remove buffer/window with supplier & onexceptionresumenext this pr removes 3 kinds of operators that had no noticeable use bases or use cases on their own in the past years- `buffer(supplier [ supplier])`- `window(supplier [ int])`- `onexceptionresumenext(<source>)`6554 resolves #6555  merging 6564  < 
6577,1,0,0,0,0,0,1,0, #6576 - observableblockingsubscribe compares blockingobserverterminated with wrong object 6576  compare with `v` instead of `o`  merging 6577  < 
6589,1,0,0,0,0,1,1,1,create a base test class and have all unit tests extend it this commit creates the `rxjavatest` class defining a defaulttimeout to 5 minutes an ignored test announce itself for eachrunning class extending it preventing travis ci from killing thebuildhave `completable` tests extend from `rxjavatest`have `disposable` tests extend from `rxjavatest`have `exception` tests extend from `rxjavatest`related: #6583  merging 6589 
6594,1,0,0,1,1,1,1,1,have unit tests extends `rxjavatest` - 2 this commit updates the unit tests of the following operators:* flowable* maybe* observable* disposable* observer* parallel* processors* schedulersand rxjava pluginrelated: #6583  merging 6594  < 
6595,1,0,0,1,1,1,1,1,have unit tests extends `rxjavatest` - 3 this commit updates the unit tests of the following operators:* single* subjects* subscribersand for internal operators:* internaldisposable* internalfuctions* internalobservers* internalqueue* interanlschedulers* internalsubscribers* internalsubscriptions* internaloperatorcompletablerelated: #6583  merging 6595 
6600,1,0,0,1,1,1,1,1,3x: have `internaloperatorflowable` unit tests extends `rxjavatest` - 4 this commit updates the unit tests for `internaloperatorflowable`related: #6583  merging 6600  < 
6601,1,0,0,0,0,0,1,0,2x: observableblockingsubscribe compares with wrong object it should compare the terminated instance with the value received from the blocking queuefixes: #6576 related: #6577  
6602,1,0,0,1,0,1,1,1,2x: fix truncation bugs in replay() and replaysubject/processor this pr fixes several truncation bugs with the time and size-bound replay() operators and their hot class versions:- unexpected removal of the last item just added due to becoming out-of-date at the lowest time resolution creating a hole in the linked chain and hanging the consumer [related failure]( incorrect size accounting upon removing old entries leading to more items dropped than expectedrelated: #6582  
6604,1,0,0,1,1,1,1,1,3x: have unit tests extends `rxjavatest` - 5 this commit updates the unit tests of the following operators:* internaloperatorsmaybe* internaloperatormixed* internaloperatorsinglerelated: #6583  
6607,1,0,0,1,1,1,1,1,3x: have `internaloperatorobservable` unit tests extends `rxjavatest` - 6 this commit updates the unit tests for `internaloperatorobservable`related: #6583  merging 6607 
6609,1,0,0,1,0,1,1,1,3x: fix refcount not resetting when termination triggers cross-cancel this pr fixes both `refcount` implementation to properly reset the source when the source terminates multiple consumersin the original when the source terminated multiple sources the first termination handler cleared the connection but since the `--subscribercount` wasnt zero the source was not reset if this termination triggered a cancel on the second consumer that path would not get the source reset either due to losing the connection object unfortunately one cant just take the first termination handler and reset there immediately either because that could disrupt the termination of the rest of the consumers it has to wait for the source to terminate all consumers or have the consumers cancel allthis affects 2x and will be backported in a separate pr6608  merging 6609 
6612,1,0,0,0,0,1,1,0,3x: fix many operators swallowing undeliverable exceptions fix many operators to emit the collected exception in case of a cancel/dispose call to the plugin error handler (ie becoming undeliverable excptions)in addition the terminal event/error delivery has been unified in many other operators so that the terminal-indicator exception is never leakedthere will be a separate pr about cleaning up the `addthrowable` usage cases (#6611)fixes: #6587  merging 6612 
6612,1,0,0,0,0,1,1,0,3x: fix many operators swallowing undeliverable exceptions fix many operators to emit the collected exception in case of a cancel/dispose call to the plugin error handler (ie becoming undeliverable excptions)in addition the terminal event/error delivery has been unified in many other operators so that the terminal-indicator exception is never leakedthere will be a separate pr about cleaning up the `addthrowable` usage cases (#6611)fixes: #6587  merging 6612 
6620,1,0,0,0,0,0,1,0,3x: elementat first - constrain upstream requests as discussed in #6569 this pr constrains upstream requests for the `elementat` and `first` overloads other operators will be covered in other prs  merging 6620 
6626,1,0,0,0,0,0,1,0,3x: fix blockingiterable not unblocking when force-disposed when the iterator was cast to `disposable` and disposed the subsequent `hasnext` would block indefinitely that interface is not intended to be part of the public api and `iterator` in general does not support any form of official cancellation (unlike stream) this pr makes sure that if that dispose is called it unblocks the iteratora separate pr will be posted for 2xrelated #6625  
6627,1,0,0,0,0,1,1,1,2x: fix blockingiterable hang when force-disposed when the iterator was cast to `disposable` and disposed the subsequent `hasnext` would block indefinitely that interface is not intended to be part of the public api and `iterator` in general does not support any form of official cancellation (unlike stream) this pr makes sure that if that dispose is called it unblocks the iterator6625  
6629,1,0,0,1,0,1,1,1,2x: fix refcount() not resetting when cross-canceled this pr fixes the issue with `refcount` not resetting the connection when the termination triggers cross-cancellation over it6608the fix is more involved than #6609 because how 2x uses two `publish()` implementation internally due to bug6505 the old/classic implementation does not fail #6608 but the newer implementation fails #6608 if the fix is applied unconditionally the old/classic implementation fails an older unit test verifying an error allows reconnection therefore the pr checks and applies the new code path only if `refcount` isnt talking to the classic publish implementationas a reminder #6609 for 3x has a redesigned `connectable` with a much more clearer reset semantics and thus the restructuring of the termination handling had no trouble passing the aforementioned error-allows-reconnect unit test  merging 6629 
6635,1,0,0,1,0,1,1,1,3x: remove vararg overloads for combinelatest in observable + flowable started removing the vararg function from #6634 hmm after looking at the tests the varag variant for `combinelatestdelayerror` might be useful since there are no 2-x overloads available what do you think? || let me guess intellij refactor? || the varargs is a convenience over the array variant so `combinelatestdelayerror`s can go ||  merging 6635  < 
6637,1,0,0,0,0,1,1,0,3x: avoid using systemgetproperties() due to security restrictions change the code in the `schedulerpoolfactory` to use `systemgetproperty` directly also fix property names to `rx3` as now both v2 and v3 could run together6636  merging 6637 
6650,1,0,0,1,0,1,1,1,3x: constrain upstream requests from take remove limit operator as per discussion in #6569 this pr constrains upstream requests from the `take` operator and removes the `limit` operatorive also added a couple of unit tests for coverage of `elementat` that i didnt include in #6620  merging 6650 
6652,1,0,0,0,0,1,1,0,3x: fix size+time bound window not creating windows properly there was a logic error in the size+time bound `window` operator for when to close a window if timers are not restarted when the size-bound is hitdue to this bug two tests were not receiving and thus accounting for empty windows that are happening when the size-bound is hit followed by the periodic time-bound hit2x will be  in a separate pr6651    no coverage uploaded for pull request base (`3x@9a36930`) [click here to learn what that means]( ` 
6657,1,0,0,0,0,1,1,0,2x: fix size+time bound window not creating windows properly there was a logic error in the size+time bound `window` operator for when to close a window if timers are not restarted when the size-bound is hitdue to this bug two tests were not receiving and thus accounting for empty windows that are happening when the size-bound is hit followed by the periodic time-bound hit6651  merging 6657  < 
6664,1,0,0,0,0,1,1,1,3x: fix groupby group emission in some cases this pr fixes two issues:- when the `observablegroupby` operator would abandon a newly created group before the groups only item was emitted causing dataloss- when the `groupby`s value selector failed for a new group thus the new group would never be emitted and report the failureit should fix the first test failure of #6663 but may not be the cause for the second  merging 6664  < 
6668,1,0,0,0,0,0,1,0,3x: add missing marble diagams to single add (hopefully) all remaining missing marble diagrams to `single`5788(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleconcatarrayeagerpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlemergedelayerroripng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlemergedelayerrorppng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlemergedelayerror2png)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlemergedelayerror3png)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlemergedelayerror4png)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleunsafecreatepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleusingpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleusingbpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlewrappng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlecachepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlecastpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singledelaysubscriptiontpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singledelaysubscriptiontspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singledooneventpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleblockinggetpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleliftpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlecontainsfpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlecontainspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleonerrorresumewithpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleonterminatedetachpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleretrypng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleretryf2png)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleretrynpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleretryfpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleretrynfpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleretrywhenpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlesubscribepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlesubscribecpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlesubscribeccpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlesubscribec2png)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlesubscribewithpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singletakeuntilcpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singletakeuntilspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singletakeuntilppng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singletimeoutpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singletimeoutspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singletimeoutbpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singletimeoutsbpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleunsubscribeonpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singletestpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singletestbpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singledelaysubscriptionppng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singledelaysubscriptionopng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singledelaysubscriptionspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singledelaysubscriptioncpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singledematerializepng)  merging 6668 
6700,1,0,0,0,0,0,1,0,3x: update javadoc for observeon to mention its eagerness update javadoc to reflect the eagerness property of `observeon` in `flowable` and `observable` classes6697  merging 6700 
6714,1,0,0,0,0,1,1,0,3x: fix multicastprocessor not requesting more after limit is reached after reaching the prefetch limit the updated `consumed` counter was not written back so the processor stopped requesting more (consumed > limit)affects 2x to a separate pr will be posted for it6713  merging 6714 
6715,1,0,0,0,0,1,1,0,2x: fix multicastprocessor not requesting more after limit is reached after reaching the prefetch limit the updated `consumed` counter was not written back so the processor stopped requesting more (consumed > limit)6713  merging 6715  < 
6720,1,0,0,0,0,1,1,1,2x: fix parallel() on grouped flowable not replenishing properly ## backport of #6719 fix a case when the groupedflowable is consumed by a parallel() in fusion mode causing the source to stop replenishing items from the upstream hanging the whole sequenceparallel() was slightly different from the usual queue consumers because it checks for isempty before trying to pull for an item this was necessary because the rails may not be ready for more and an eager pull to check for emptyness would lose that item the replenishing was done in groupedflowablepull but a call to groupedflowableisempty would not replenishthe fix is to have isempty replenish similar to when poll detects emptyness and replenishesreported in reactor/reactor-core#1959  merging 6720 
6729,1,0,0,0,0,0,1,0,3x: fix self-see references some comments - some `@see` should point to the other party (plain <-> `delayerror`)- add a few `@see` to the nearby operators- comments no longer apply in `blockingxmostrecent` source code- add a comment from #6728 to `actiondisposable`replaces #6728  
6729,1,0,0,0,0,0,1,0,3x: fix self-see references some comments - some `@see` should point to the other party (plain <-> `delayerror`)- add a few `@see` to the nearby operators- comments no longer apply in `blockingxmostrecent` source code- add a comment from #6728 to `actiondisposable`replaces #6728  
6730,1,0,0,0,0,0,1,0,3x: add maybe marble diagrams (14 cases) related #5806----(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybezipipng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybezipnpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeziparraypng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybezipwithpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybecontainsopng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeunsubscribeonpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeonterminatedetachpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybecastpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeliftpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedooneventpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedelaysubscriptiontpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedelaysubscriptiontspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedelaysubscriptionppng)  merging 6730 
6732,1,0,0,0,0,0,1,0,3x: update singlezip marble diagrams (4 cases) related #5788-----(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlezipipng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlezipnpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleziparraypng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlezipwithpng)  
6744,1,0,0,1,0,1,1,0,3x: add fair mode overload to schedulersfrom(executor) the default `schedulersfrom` implementation uses an eager approach to execute tasks on the underlying `executor` which can lead to excessive thread occupation on its own even if operators use buffering/prefetch of 1this pr introduces a new overload with a fairness option so that tasks are submitted to the `executor` in a non-overlapping and fifo manner one by onein addition the scheduler retention tests have been cleaned up and reworked to not wait unnecessarily long for the gc to finishrelated: #6696 #6697  merging 6744  < 
6745,1,0,0,0,0,0,1,0,3x: make disposablecontainer public api make the internal interface `disposablecontainer` public as it can be one safely(ive seen some 3rd party usage in custom containers this will make them now legit on 3x)**edit**also [should resolve]( the osgi private reference warning6742  merging 6745 
6748,1,0,0,0,0,1,1,0,3x: change how the cause of compositeexception is generated this pr changes how `compositeexceptiongetcause` creates a cause exception on demand in 1x and 2x the code tried to link up the various inner exceptions via their `initcause` which was in on itself fishy as well as could lead to excessive memory usageinstead the new code will present the inner exceptions as part of a formatted message which in theory should be still picked up by ide exception listings and allow navigation:```multiple exceptions (2)|-- ioreactivexrxjava3exceptionstestexception: ex3    at ioreactivexrxjava3exceptionscompositeexceptiontestnestedmultilinemessage(compositeexceptiontestjava:341)|-- ioreactivexrxjava3exceptionstestexception: ex4    at ioreactivexrxjava3exceptionscompositeexceptiontestnestedmultilinemessage(compositeexceptiontestjava:342)  |-- ioreactivexrxjava3exceptionscompositeexception: 2 exceptions occurred       at ioreactivexrxjava3exceptionscompositeexceptiontestnestedmultilinemessage(compositeexceptiontestjava:337)    |-- ioreactivexrxjava3exceptionscompositeexceptionexceptionoverview:         multiple exceptions (2)        |-- ioreactivexrxjava3exceptionstestexception: ex1            at ioreactivexrxjava3exceptionscompositeexceptiontestnestedmultilinemessage(compositeexceptiontestjava:335)        |-- ioreactivexrxjava3exceptionstestexception: ex2            at ioreactivexrxjava3exceptionscompositeexceptiontestnestedmultilinemessage(compositeexceptiontestjava:336)```( are a few formatting conveniences:- if there is only one inner exception the `compositeexception`s cause will be simply that exception this can happen when the very same exception is aggregated into the composite and get deduplicated- if an inner exceptions message is multi-lined the message and cause traces should be indented properly- reoccurring causes are not expanded over and over:```multiple exceptions (2)|-- ioreactivexrxjava3exceptionstestexception: ex1    at ioreactivexrxjava3exceptionscompositeexceptiontestreoccurringexception(compositeexceptiontestjava:316)  |-- ioreactivexrxjava3exceptionstestexception: ex0      at ioreactivexrxjava3exceptionscompositeexceptiontestreoccurringexception(compositeexceptiontestjava:315)|-- ioreactivexrxjava3exceptionstestexception: ex2    at ioreactivexrxjava3exceptionscompositeexceptiontestreoccurringexception(compositeexceptiontestjava:319)  |-- ioreactivexrxjava3exceptionstestexception: ex1      at ioreactivexrxjava3exceptionscompositeexceptiontestreoccurringexception(compositeexceptiontestjava:316)      |-- (cause not expanded again) ioreactivexrxjava3exceptionstestexception: ex0```currently only the first line of the stacktraces are shown because it can get quite long (and thus memory consuming) to list them all maybe a system parameter can be introduced to control the verbosity6747  merging 6748 
6754,1,0,0,0,0,1,1,1,2x: zip combinelatest and amb operators throw when supplied with observablesource implementation that doesnt subclass observable 6753 please add unit tests so this doesnt happen again in case of any future change ||  merging 6754  < 
6756,1,0,0,1,0,1,1,1,3x: fix observable amb combinelatest & zip arraystoreexception when using iterable of sources the initial array is the wrong type and causes `arraystoreexception`unit tests were added to verify the other implementations6753  merging 6756 
6762,1,0,0,0,0,1,1,1,3x: fix window (boundary start/end) cancel and abandonment this pr fixes the `window` operator (with boundary and start-end sources) so that- cancelling the inner windows allows cancelling the upstream once neither the main output nor other windows are being consumed further- ignoring a window still allows cancelling the upstreamfollow-up to #6758 and #6761  merging 6762 
6765,1,0,0,0,0,0,1,0,3x: [java 8] upgrade to java 8 add flowablefromx operators this pr upgrades rxjava to use and compile with java 8- build target set to 8- animalsniffer set to 8- javadocs link to the official jdk set to 8- implemented operators:  - `flowablefromoptional`  - `flowablefromcompletionstage`  - `flowablefromstream`- applied `@safevarargs` to many methods- created marblesrelated #6695(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/fromoptionalfpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/fromcompletionstagefpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/fromstreamfpng)  merging 6765 
6773,1,0,1,0,0,0,1,0,add functionalinterface annotations 6768  merging 6773  < 
6779,1,1,0,1,1,1,1,1,3x: [java 8] add blockingstream & flatmapstream to flowable add java 8 interoperation methods to `flowable`:- `blockingstream` - essentially `blockingiterable` with close support- `concatmapstream` - map and concatenate streams- `flatmapstream` - map and concatenate streams inherently same as `concatmapstream`related #6776 marbles:(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/blockingstreamfpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/blockingstreamfipng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/concatmapstreamfpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/concatmapstreamfipng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flatmapstreamfpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flatmapstreamfipng)  merging 6779  < 
6780,1,0,0,0,0,0,1,0,3x: [java 8] add autocloseable <-> disposable conversions nicen docs add `disposablesfromautocloseable` and `disposablestoautocloseable` methods improve javadocs styling6772resolves #6777 you could also do```javainterface disposable extends autocloseable {  boolean isdisposed()  void dispose()  default void close() {    dispose()  }}``` ||  merging 6780 
6780,1,0,0,0,0,0,1,0,3x: [java 8] add autocloseable <-> disposable conversions nicen docs add `disposablesfromautocloseable` and `disposablestoautocloseable` methods improve javadocs styling6772resolves #6777 you could also do```javainterface disposable extends autocloseable {  boolean isdisposed()  void dispose()  default void close() {    dispose()  }}``` ||  merging 6780 
6783,1,0,0,1,0,1,1,1,3x: [java 8] add fromopt/stage mapoptional tocompletionstage to m/s/c add the following java 8 operators to various reactive base classes:| operator | `maybe` | `single` | `completable` ||---|:---:|:---:|:---:|| `fromoptional` | ( | (1) | (2) || `fromcompletionstage` | ![image]( | ![image]( | ![image]( || `mapoptional` | ![image]( | ![image]( | (3) || `tocompletionstage` | ![image]( | ![image]( | (4) || `tocompletionstage(t)` | ![image]( | (5) | ![image]( |1 should it be implemented as `optionalempty() -> singleerror(new nosuchelementexception())`?2 no reason to implement always `completablecomplete()`3 no value to map4 no value to emit thus it is better to ask the user for a completion value5 never empty no reason to implementrelated #6776 marbles:![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/fromoptionalmpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/fromcompletionstagespng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/fromcompletionstagecpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mapoptionalmpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mapoptionalspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/tocompletionstagempng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/tocompletionstagemvpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/tocompletionstagespng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/tocompletionstagecpng)  merging 6783  < 
6786,1,0,0,1,1,1,1,1,diamond operators in unit tests observable package hello in this pull request ive changed all ide marked explicit types with diamond operator affected package is internal/operators/observable there is one test fail in completabletestrepeatnormal  but diamond is not the cause there is last stack entry: javalangassertionerror: expected:<6> but was:<5>	at orgjunitassertfail(assertjava:88)this pr is part of  #6767 issue resolving  merging 6786 
6787,1,0,0,1,1,1,1,1,diamond operators in unit tests flowable package hello in this pull request ive changed all ide marked explicit types with diamond operator affected package is internal/operators/flowable there is one test fail in completabletestrepeatnormal  but diamond is not the cause there is last stack entry: javalangassertionerror: expected:<6> but was:<5>	at orgjunitassertfail(assertjava:88)this pr is part of  #6767 issue resolving  
6788,1,0,0,1,1,1,1,1,diamond operators in tests hello in this pull request ive changed all ide marked explicit types with diamond operator affected packages is internal/  internal/operators/there is one test fail in completabletestrepeatnormal  but diamond is not the cause there is last stack entry: javalangassertionerror: expected:<6> but was:<5>	at orgjunitassertfail(assertjava:88)this pr is part of  #6767 issue resolving  merging 6788  < 
6789,1,1,0,1,1,1,1,1,diamond operators in tests small packages hello in this pull request ive changed all ide marked explicit types with diamond operator affected packages is in tests rootthere is one test fail in completabletestrepeatnormal  but diamond is not the cause there is last stack entry: javalangassertionerror: expected:<6> but was:<5>	at orgjunitassertfail(assertjava:88)this pr is part of  #6767 issue resolving  merging 6789 
6791,1,0,0,1,0,1,1,1,3x: add nonnull & safevarargs annotations + validator this pr cleans up the main classes:- add missing `@nonnull` annotations- add missing `@safevarargs` annotations- add validator code that scans the sources to verify the annotations are present- remove unnecessary `@suppresswarnings` annotations- fix a few type argumentsrelated #6766  merging 6791 
6797,1,0,0,1,0,1,1,1,3x: [java 8] add observable operators + cleanup add the following java 8 operators to `observable`:- `fromoptional`- `fromcompletionstage`- `fromstream`- `firststage`- `firstorerrorstage`- `singestage`- `singleorerrorstage`- `laststage`- `lastorerrorstage`- `blockingstream`- `mapoptional`- `collect`- `concatmapstream` / `flatmapstream`in addition some validators received reporting improvements (such as using ` at ` so the ide can jump to the exact line of the issue) consequently all local variable misnaming of `unicastsubject up` and `unicastprocessor us` have been  as wellrelated #6776 marbles:( ||  merging 6797 
6799,1,0,0,0,0,1,1,1,3x: xprocessoroffer to throw npe immediately make `offer` throw a `nullpointerexception` immediately instead of turning it into an error signal in addition have `multicastprocessoroffer` throw an `illegalstateexception` if called when the processor is in fusion mode6794  merging 6799 
6800,1,0,0,0,0,0,1,0,3x: add blockingforeach(consumer int) overload the underlying `blockingiterable` already supported the custom prefetch overload and this pr exposes it as a new `blockingforeach` overloadin addition the javadocs incorrectly stated `blockingforeach` operated in an unbounded-in fashion it uses the usual stable-prefetch with 75% re-request amount6784  merging 6800 
6801,1,0,0,0,0,1,1,1,3x: add missing throwiffatal calls - add missing `exceptionsthrowiffatal` calls in `catch (throwable ` blocks- add validator that checks for the existence of these `throwiffatal` `wraporthrow` or `fail` calls- fix `autocloseabledisposable` to use `wraporthrow` like the other `disposable` wrapper implementations6796  merging 6801  < 
6805,1,0,0,0,0,1,1,0,3x: [java 8] add flattenstreamasx to maybe/single add- `maybeflattenstreamasflowable`- `maybeflattenstreamasobservable`- `singleflattenstreamasflowable`- `singleflattenstreamasobservable`related #6776(in addition adjust the validators to appreciate the new patterns)marbles:(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flattenstreamasflowablempng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flattenstreamasobservablempng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flattenstreamasflowablespng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flattenstreamasobservablespng)  merging 6805 
6814,1,0,0,1,0,1,1,1,3x: remove fromfuture( scheduler) overloads those overloads were only applying `subscribeon` with no other benefitsresolves: #6811  merging 6814 
6817,1,0,0,0,0,0,1,0,deleted functionsnaturalorder removes a duplication of the natural order comparator6816  merging 6817  < 
6826,1,0,0,0,0,1,1,1,3x: fix flowableflatmap not canceling the inner sources on outer error the outer `onerror` did not cancel the inner sources the `observable` variant works correctly but both received an unit test to verify the behavior2x will be  in a separate prrelated #6825  merging 6826  < 
6827,1,0,0,0,0,1,1,1,2x: fix flowableflatmap not canceling the inner sources on outer error the outer `onerror` did not cancel the inner sources the `observable` variant works correctly but both received an unit test to verify the behaviorfixes: #6825  merging 6827 
6837,1,0,0,0,0,1,1,1,3x: remove a pointless observableconcatmapiterable overload remove the `concatmapiterable(function int)` overload as there is no buffering involved with the operator6828  
6838,1,0,0,1,0,1,1,1,3x: rename to combinelatestarraydelayerror the operator missed a rename with 2x to match the `combinelatestarray` variant6820  merging 6838 
6839,0,0,0,0,0,1,0,0,3x: enable javac parameter saving in class files related #6832  merging 6839 
6840,1,0,1,1,0,1,1,0,3x: add nullability annotations to type arguments annotate type argument use with `@nonnull`6766  merging 6840 
6843,1,0,0,0,0,1,1,0,3x: improve wording of operators - reword sentences with "modifies" and "instructs"- reword "the source x" to "the current x"- reword a couple of other operator sentencesrelated #6819 6821  merging 6843 
6843,1,0,0,0,0,1,1,0,3x: improve wording of operators - reword sentences with "modifies" and "instructs"- reword "the source x" to "the current x"- reword a couple of other operator sentencesrelated #6819 6821  merging 6843 
6844,1,0,0,0,0,1,1,0,3x: remove maybeonexceptionresumenext it was always very peculiar to let only checked exceptions resumed6842  merging 6844 
6847,1,0,0,0,0,1,1,0,3x: simplify @return sentences in flowable javadocs simplify the wording of `@return` in javadocs6834  merging 6847 
6853,1,0,0,0,0,1,1,0,3x: fix method argument naming across types make method argument naming consistent between the base reactive classes adjust some of the naming for allin addition the null-check was missing from `blockingmostrecent`6832 the utility program has to be run manually to list the inconsistencies the remaining inconsistency is due to `merge` because its argument is `sources` for `flowable`/`observable` but `source` for `single`/`maybe` nested  merging 6853 
6856,1,0,0,0,0,0,1,0,rename singleequals to singlesequenceequal renamed singleequals to singlesequenceequal and renamed argument names for consistent naming6854  merging 6856 
6857,1,0,0,1,0,0,1,0,3x: [wiki] improve operator-matrix with links and notes update the `operatormatrixgenerator` to add anchors and links to notes about why operators are not present in one or another class operators are missing and will be added as part of #68526855  merging 6857 
6857,1,0,0,1,0,0,1,0,3x: [wiki] improve operator-matrix with links and notes update the `operatormatrixgenerator` to add anchors and links to notes about why operators are not present in one or another class operators are missing and will be added as part of #68526855  merging 6857 
6860,1,0,0,0,0,1,1,0,3x: add last missing throws tag to javadocs added the last missing `@throws` tag to methods and one missing `@nonnull` annotationi included a small program that will list javadocs without `@throws` for future use6829  merging 6860 
6862,1,0,0,0,0,0,1,0,3x: add maybe/single/completable blockingsubscribe add the missing `blockingsubscribe` methods to `maybe` `single` and `completable` for symmetry with `flowable` and `observable`usually wed like to avoid blocking but now that project loom (preview) transparently turns latch-based awaiting into suspension inside virtual threads they will act as free interop operators for exiting the reactive world into the continuation worldrelated: #6852marbles:#### maybe( single![image]( completable![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableblockingsubscribepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableblockingsubscribeapng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableblockingsubscribeacpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableblockingsubscribeopng)  merging 6862 
6864,1,0,0,1,0,1,1,0,adding delayerror to maybedelay 6863  merging 6864  < 
6867,1,0,0,0,0,0,1,0,3x: add onerrorcomplete to flowable observable and single add the `onerrorcomplete()` and `onerrorcomplete(predicate)` operators to the remaining base classesalso created the missing marble for `maybeonerrorcomplete` + 1related #6852 #5806 (https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowableonerrorcompletepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowableonerrorcompletefpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observableonerrorcompletepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observableonerrorcompletefpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleonerrorcompletepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleonerrorcompletefpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeonerrorcompletepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeonerrorcompletefpng)  merging 6867 
6867,1,0,0,0,0,0,1,0,3x: add onerrorcomplete to flowable observable and single add the `onerrorcomplete()` and `onerrorcomplete(predicate)` operators to the remaining base classesalso created the missing marble for `maybeonerrorcomplete` + 1related #6852 #5806 (https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowableonerrorcompletepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowableonerrorcompletefpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observableonerrorcompletepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observableonerrorcompletefpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleonerrorcompletepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleonerrorcompletefpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeonerrorcompletepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeonerrorcompletefpng)  merging 6867 
6868,1,0,0,0,0,1,1,1,3x: add completableonerrorresumewith this pr adds the missing `completableonerrorresumewith` present in the rest of the base classesalso marbles for `maybeonerrorresumenext` and `maybeonerrorresumewith` have been updatedrelated #6852 #5806(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableonerrorresumewithpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeonerrorresumenextpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeonerrorresumewithpng)  merging 6868 
6868,1,0,0,0,0,1,1,1,3x: add completableonerrorresumewith this pr adds the missing `completableonerrorresumewith` present in the rest of the base classesalso marbles for `maybeonerrorresumenext` and `maybeonerrorresumewith` have been updatedrelated #6852 #5806(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableonerrorresumewithpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeonerrorresumenextpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeonerrorresumewithpng)  merging 6868 
6869,1,0,0,0,0,1,1,0,3x: add single/completable retryuntil + marbles `retryuntil` was missing from `single` and `completable`added marble for `maybe` as wellrelated #6852 #5806(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableretryuntilpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleretryuntilpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mayberetryuntilpng)  merging 6869 
6869,1,0,0,0,0,1,1,0,3x: add single/completable retryuntil + marbles `retryuntil` was missing from `single` and `completable`added marble for `maybe` as wellrelated #6852 #5806(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableretryuntilpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleretryuntilpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mayberetryuntilpng)  merging 6869 
6870,1,0,0,0,0,0,1,0,3x: add maybe/single/completable switchonnext & switchonnextdelayerror add the missing `switchonnext` and `switchonnextdelayerror` operators which are essentially delegated to the respective `flowable::switchmapx` operators with identity mappingrelated #6852(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableswitchonnextpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableswitchonnextdelayerrorpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleswitchonnextpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleswitchonnextdelayerrorpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeswitchonnextpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeswitchonnextdelayerrorpng)  
6871,1,0,0,0,0,1,1,1,3x: add maybedematerialize add the `dematerialize` operator to `maybe` to be in sync with the other classesrelated #6852 (https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedematerializepng)  merging 6871 
6873,1,0,0,1,0,1,1,1,3x: add many fromx operators + marbles add a cross section of `from` operators (![present]( [`fromaction`](  `fromsingle`) :operator | f | o | m | s | c |-|-|-|-|-|-|<a namefromaction></a>`fromaction`|![present]( <sup titlenever empty>([23](#notes-23))</sup>|![present]( namefromcompletable></a>`fromcompletable`|![present]( <sup titlealways error>([72](#notes-72))</sup>|![absent]( <sup titleuse wrap()>([73](#notes-73))</sup>|<a namefrommaybe></a>`frommaybe`|![present]( <sup titleuse wrap()>([73](#notes-73))</sup>|![present]( namefromobservable></a>`fromobservable`|![present]( <sup titleuse wrap()>([73](#notes-73))</sup>|![present]( namefrompublisher></a>`frompublisher`|![present]( namefromrunnable></a>`fromrunnable`|![present]( <sup titlenever empty>([23](#notes-23))</sup>|![present]( namefromsingle></a>`fromsingle`|![present]( <sup titleuse wrap()>([73](#notes-73))</sup>|![present]( #6852 (https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowablefromactionpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowablefromcompletablepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowablefrommaybepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowablefromobservablebufferpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowablefromobservablelatestpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowablefromobservabledroppng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowablefromobservableerrorpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowablefromobservablemissingpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowablefromrunnablepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowablefromsinglepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observablefromactionpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observablefromcompletablepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observablefrommaybepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observablefromrunnablepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observablefromsinglepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybefrompublisherpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybefromobservablepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlefrommaybepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlefrommaybevpng)  merging 6873 
6874,1,0,0,0,0,0,1,0,3x: add timeinterval & timestamp to m/s add `timeinterval` and `timestamp` operators  (4 overloads each) to `maybe` and `single`related #6852 (https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetimeintervalpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetimeintervalspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetimestamppng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetimestampspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singletimeintervalpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singletimeintervalspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singletimestamppng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singletimestampspng)  merging 6874 
6875,1,0,0,0,0,0,1,0,3x: add maybe/completable tofuture add `tofuture` to `maybe` and `completable`related #6852 (https://githubcom/reactivex/rxjava/wiki/images/rx-operators/maybetofuturepng)![image](https://githubcom/reactivex/rxjava/wiki/images/rx-operators/completabletofuturepng)  merging 6875 
6876,1,1,0,1,1,1,1,1,3x: add singleoftype add `oftype` to `single` already available to the other non-empty base typesrelated #6852 ( addition diagrams for `maybefilter` and `maybeoftype` have been updated:![image]( #5806  merging 6876 
6876,1,1,0,1,1,1,1,1,3x: add singleoftype add `oftype` to `single` already available to the other non-empty base typesrelated #6852 ( addition diagrams for `maybefilter` and `maybeoftype` have been updated:![image]( #5806  merging 6876 
6877,1,0,0,0,0,1,1,1,3x: add doonlifecycle to maybe single & completable add the `doonlifecycle` operator to the remaining classesrelated #6852 (https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedoonlifecyclepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singledoonlifecyclepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completabledoonlifecyclepng)  merging 6877 
6879,1,0,0,1,0,1,1,0,3x: add concatmapx operators (aliases) add the following operator aliases:- `maybeconcatmapcompletable`- `maybeconcatmapsingle`- `singleconcatmapcompletable`- `singleconcatmap`- `singleconcatmapmaybe`related #6852 ( addition some missing or wrong `maybe` marbles have been :![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeconcatmappng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeflatmapcompletable3png)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeflatmapsingle3png)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeflatmapsingleelementpng)  merging 6879 
6881,1,0,0,1,0,1,1,1,3x: add various concatxdelayerror operators add the following concat kind of operators:- `maybeconcatarrayeagerdelayerror`- `maybeconcatdelayerror(publisher int)`- `singleconcatarraydelayerror`- `singleconcatarrayeagerdelayerror`- `singleconcatdelayerror` + 2- `completableconcatarraydelayerror`- `completableconcatdelayerror` + 2related #6852 ( addition the `maybeconcatdelayerror(publisher)` marble has been :![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeconcatdelayerror3ipng)  merging 6881 
6882,1,0,0,0,0,0,1,0,3x: add singlemergearray & mergearraydelayerror `single` was missing the `mergearray` and `mergearraydelayerror` operators already present in the other classesrelated #6852(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlemergearraypng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlemergearraydelayerrorpng)  merging 6882 
6884,1,0,0,0,0,1,1,0,3x: add completablesequenceequal the operator was available in all other classesrelated #6852 (https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completablesequenceequalpng)  merging 6884 
6885,1,0,0,0,0,0,1,0,3x: add missing startwith overloads add missing ( ![add]( ) `startwith` overloads source \ other | f | o | m | s | c |--|--|--|--|--|--|flowable | ![present]( | ![absent]( | ![add]( | ![add]( | ![add]( | ![absent]( | ![present]( ![add]( | ![add]( | ![add]( | ![add]( | ![add]( | ![add]( | ![add]( | ![add]( | ![add]( | ![add]( | ![add]( | ![add]( | ![add]( | ![present]( | ![present]( | ![add]( | ![add]( | ![present]( #6852(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowablestartwithmpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowablestartwithspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowablestartwithcpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observablestartwithmpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observablestartwithspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observablestartwithcpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybestartwithppng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybestartwithopng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybestartwithmpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybestartwithspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybestartwithcpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlestartwithppng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlestartwithopng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlestartwithmpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlestartwithspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlestartwithcpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completablestartwithmpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completablestartwithspng)  merging 6885 
6886,1,0,0,0,0,1,1,0,3x: add completableonerrorreturn[item] the operators were already available elsewhererelated #6852( addition the `maybe` variants have received updated marbles as well:![image]( #5806  merging 6886 
6886,1,0,0,0,0,1,1,0,3x: add completableonerrorreturn[item] the operators were already available elsewhererelated #6852( addition the `maybe` variants have received updated marbles as well:![image]( #5806  merging 6886 
6887,1,0,0,1,0,1,1,1,3x: add safesubscribe to maybe single & completable add the final missing method `safesubscribe` to `maybe` `single` & `completable`6852  merging 6887 
6888,1,0,0,0,0,1,1,0,3x: use more appropriate operators when delegating to flowable ops many `single` and `maybe` operators delegate to `flowable` operators this pr makes sure they use the most appropriate ones since there are `single`- and `maybe`-specific operators on `flowable` for some time nowsome concatenating non-delayed single operators now use the `flowableconcatmapsingledelayerror(functionsidentity() false)` because an array or `iterable` of `single`s cant just throw anytime like a `publisher<single<t>>`s `publisher` could hence a delay-error until boundary mode works the same but without the extra coordination of the more general `publisher` variant6865`completable` didnt have any delegation required changing  merging 6888 
6890,1,1,1,0,0,0,1,0,3x: fix marble dimensions add program that checks them 6872also added 2 diagrams missing(  1 diagram wrongly exported![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableconcatarraydelayerrorpng)  merging 6890 
6891,1,0,0,0,0,1,1,0,3x: swap maybeflatmapsingle and maybeflatmapsingleelement 6878dropped the old `maybeflatmapsingle` and replaced it with `maybeflatmapsingleelement` hmm for xflatmaptestmaybesingle if i replace `flatmapsingle()tosingle()` with `tosingle()flatmap()` then the test will pass || the test checks if disposing while in the function the returned `single` never gets subscribed to and thus no error is signaled to the downstream or the global error handler put an `@ignore` on it for now and ill look into the operator tomorrow ||  merging 6891  < 
6893,1,0,0,0,0,1,1,0,3x: reenable xflatmaptestmaybesingle add missing single operators reenable the `xflatmaptestmaybesingle` and make sure all flatmap variants behave the same when the flow is cancelled/disposed while the mapper function is executing thus the returned inner source doesnt get subscribed to at all6892while adding the extra tests i noticed two `flatmap` variant is missing from `single`:- a combiner of the original and inner success item: `flatmap(function<t single<u>> bifunction<t u r>)`- a notification-type mapper: `flatmap(function<t single<r>> function<throwable single<r>>)`( the same combiner variant for `maybe` received a marble diagram too:![image]( #5806  merging 6893 
6893,1,0,0,0,0,1,1,0,3x: reenable xflatmaptestmaybesingle add missing single operators reenable the `xflatmaptestmaybesingle` and make sure all flatmap variants behave the same when the flow is cancelled/disposed while the mapper function is executing thus the returned inner source doesnt get subscribed to at all6892while adding the extra tests i noticed two `flatmap` variant is missing from `single`:- a combiner of the original and inner success item: `flatmap(function<t single<u>> bifunction<t u r>)`- a notification-type mapper: `flatmap(function<t single<r>> function<throwable single<r>>)`( the same combiner variant for `maybe` received a marble diagram too:![image]( #5806  merging 6893 
6897,1,0,0,0,0,0,1,0,3x: add remaining maybe marbles (+50) 5806 (https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeambwithpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeblockinggetpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeblockinggetvpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybecachepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybecomposepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeconcatwithpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybecountpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedefaultifemptypng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedelayppng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedelaytpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedelaytbpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedelaytspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedelaytsbpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedoaftersuccesspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedoafterterminatepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedofinallypng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedoondisposepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedoonsubscribepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedoonterminatepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeflatmapobservablepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeflatmappublisherpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeisemptypng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybemergewithpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mayberepeatnpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mayberepeatpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mayberepeatuntilpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mayberepeatwhenpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mayberetryfpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mayberetrygpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mayberetrynpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mayberetrynfpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mayberetrypng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mayberetrywhenpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeswitchifemptympng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeswitchifemptyspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetakeuntilmpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetakeuntilppng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetimeoutmpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetimeoutmmpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetimeoutppng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetimeoutpmpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetimeouttpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetimeouttmpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetimeouttspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetimeouttsmpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetopng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetoflowablepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetoobservablepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetosinglepng)  merging 6897  < 
6899,1,0,0,0,0,0,1,0,3x: add concateagerdelayerror across `flowable` `observable` `maybe` and `single` now have a `concateagerdelayerror` delegating to the appropriate `concatmapeagerdelayerror` operatorin addition `maybe` and `single` received an overload `concateager(iterable int)` to expose the `maxconcurrency` option already present in the rest of the typesnote that `completableconcateagerdelayerror` is essentially the same as `mergedelayerror` because there are no items to keep emitting in order6880the `flowable` and `observable` variant of `concateager` also received fresh marble diagrams (related #5813)#### flowable( observable![image]( maybe![image]( single![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleconcateagerinpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleconcateagerpnpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleconcateagerdelayerroripng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleconcateagerdelayerrorinpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleconcateagerdelayerrorppng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleconcateagerdelayerrorpnpng)  merging 6899  < 
6921,1,0,0,1,0,1,1,1,3x: fix replay() not resetting when the connection is disposed disposing a `replay()`-based connectable should reset the operator to its fresh state this was supposed to happen but the relevant code changes were not enabled the pr fixes this for both `flowable` and `observable`-based implementationsthe `publish`-based connectables work as intended6920  merging 6921 
6960,1,0,0,0,0,1,1,1,2x: fix observableflatmap with maxconcurrency hangs (#6947) just a backport to 2x of the fix for the scalar-queue max-concurrency issue already  for 3x in #6946the code for the fix has been added and also the test for itin addition as was also done for #6946 the corresponding test for `flowableflatmap` has been added6947  merging 6960 
6969,1,0,0,1,0,1,1,1,3x: allow setting the drift tolerance timeunit via system property adds the new system property `rx3schedulerdrift-tolerance-unit` to allow specifying a more fine-grained tolerance amount6968  merging 6969 
6996,1,0,0,1,1,1,1,1,suppress undeliverableexception handling in tests (#6987) i used a junit testrule to suppress handling of undeliverableexception for test methods annotated with @suppressundeliverable this approach is coarser than the suggested approach (it suppresses the handling of all undeliverableexceptions for the entire annotated test method)i thought this approach was clean but i can switch to the suggested approach if preferredi added @suppressundeliverable to most tests that were logging undeliverableexceptions with the test method in the stack trace this may be more suppression than was required so just let me know6987  merging 6996 
7028,1,0,0,0,0,1,1,1,3x: allow mbe in flowablegroupbytestissue6974runpart2noevict issue #7001 above test can probabilistically throw an exception thus: above assertion would be invalid i have removed the invalid assertion7001  merging 7028 
7033,1,0,0,0,0,0,1,0,{flowableobservable}collect(collector) contravariant on t added `? super` twice would 7032 compilation errors:```> task :compilejava/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/rxjava3/core/flowablejava  error: cannot infer type arguments for flowablecollectwithcollectorsingle<>        return rxjavapluginsonassembly(new flowablecollectwithcollectorsingle<>(this collector))                                        ^  reason: inferred type does not conform to equality constraint(s)    inferred: cap#1    equality constraints(s): cap#1t  where t is a type-variable:    t extends object declared in class flowable  where cap#1 is a fresh type-variable:    cap#1 extends object super: t from capture of ? super t/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/rxjava3/core/observablejava  error: cannot infer type arguments for observablecollectwithcollectorsingle<>        return rxjavapluginsonassembly(new observablecollectwithcollectorsingle<>(this collector))                                        ^  reason: inferred type does not conform to equality constraint(s)    inferred: cap#1    equality constraints(s): cap#1t  where t is a type-variable:    t extends object declared in class observable  where cap#1 is a fresh type-variable:    cap#1 extends object super: t from capture of ? super t2 errors``` || hehe i thought i would get away with not even compiling the sources ||  merging 7033 
7040,1,0,0,0,0,1,1,1,3x: fix map() conditional chain causing npe fix the case when an (async) fused `filter`-`map`-`filter` chain does not handle the null indicator in its conditional path inside `map`7039 ❤️ wow so happy with the turnaround on this! ||  merging 7040 
7049,1,0,0,0,0,1,1,1,3x: fix observablewindow (size skip overlap) dispose behavior disposing the main output of the `observablewindow` operator did not properly propagate the dispose call under certain circumstances such as no current active window or the window(s) were abandoned immediately7048  merging 7049 
7080,1,0,0,0,0,0,1,0,change a method name to make consistent with pr#6801 thank you for contributing to rxjava before pressing the "create pull request" button please consider the following points:  -  please give a description about what and why you are contributing even if its trivialin #6801 a method name `flowablezipiterable#error` is changed to `fail` but its similar class `observablezipiterable` was not changedi changed it for consistency  -  please include the issue list number(s) or other pr numbers in the description if you are contributing in response to thosethis pr is related to #6801  -  please include a reasonable set of unit tests if you contribute new code or change an existing one if you contribute an operator (if applicable) please make sure you have tests for working with an `empty` `just` `range` of values as well as an `error` source with and/or without backpressure and see if unsubscription/cancellation propagates correctlythis change will not affect external behavior  merging 7080 
7126,1,0,0,0,0,1,1,1,3x: improve error messages in the test consumers this pr improves the error messages reported in the `testobserver` and `testsubscriber`:- `assertvalue(predicate)` now shows the value that didnt pass the predicate- `assertvalueat(index t)`:  - if the index is out of range the message includes the valid range  - the message now includes the index argument where the failure happened- `assertvalueat(index predicate)`:  - if the index is out of range the message includes the valid range  - shows the value at index that didnt pass the predicate  - the message now includes the index argument where the failure happened- `asserterror(predicate)` is now worded to indicate the exception did not pass the predicatein addition the verification tests for the error messages were not actually testing the error message with `assertthrows` and have been updated7125  merging 7126 
7144,1,0,0,0,0,0,1,0,3x: update marbles of amb() ambarray() and ambwith() update the marble diagrams in `flowable` and `observable` indicating cancellation of the non-winners6995(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowableambpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowableambarraypng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowableambwithpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observableambpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observableambarraypng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observableambwithpng)  merging 7144 
7163,1,0,0,0,0,1,1,1,3x: testscheduler option to use onschedule hook the `testscheduler` is a bit inconsistent regarding the use of `rxjavapluginsonschedule` it extends `scheduler` so the `scheduledirect` methods do invoke the hook whereas the workers `schedule` methods dontthis pr adds a constructor flag to enable the use of the hook in the workers `schedule` methods as well this addition should avoid issues with existing tests not expecting the hook to be invoked all of a sudden7119  merging 7163 
7164,1,0,0,0,0,0,1,0,updating documentation for scheduleactual method remove unnecessary sentence from `newthreadworkerscheduleactual`7161  merging 7164 
7165,1,1,0,1,1,1,1,1,3x: add fusion support to concatmap{maybe|single|completable} this pr adds front fusion support to- `flowableconcatmapcompletable`- `flowableconcatmapmaybe`- `flowableconcatmapsingle`- `observableconcatmapcompletable`- `observableconcatmapmaybe`- `observableconcatmapsingle`the operators have been tidied up by factoring out common code pathsin addition the `deferredscalarsubscription`s fusion-emission had to be  in async fusion mode `onnext(null)` is generally expected from the upstream but `deferredscalarsubscription` sent the value itself now it correctly sends `null` (`deferredscalardisposable` already did this correctly)7061  merging 7165 
7170,1,0,0,1,0,1,1,1,2x: introduce property rx2scheduleruse- otime (#7154) 7169 @akarnokd  i had to create a new `schedulertest` class because on the 2x branch the package did not match the package of `scheduler` therefore i could not access the field (package-private) ||  merging 7170 
7191,1,0,0,1,0,1,1,0,3x: add onsubscribe hook to parallelflowable operators parallel operators were missing an `rxjavapluginsonsubscribe` hook7190  merging 7191 
7196,1,0,0,0,0,0,1,0,3x: allow singlezip and maybezip result to be garbage collected 7195 @akarnokd sorry hit re-review accidentally    ||  merging 7196 
7203,1,0,0,0,0,1,1,1,3x: fix schedulersfrom to honor interruptibleworker across methods the direct scheduling methods of the `executorscheduler` created via `schedulersfrom(executor boolean)` did not fully honor the `interruptibleworker` settings7201  merging 7203 
7212,1,0,0,0,0,0,1,0,3x: compositeexceptionprintstacktrace to write directly into printstream/printwriter i dont remember why the stacktrace it wasnt printed directly via the printstream/printwriter no reason to aggregate the entire string outputfixes: #7211  merging 7212 
