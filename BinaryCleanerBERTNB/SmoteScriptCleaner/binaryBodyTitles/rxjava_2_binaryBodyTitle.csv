pr;Util;NLP;APM;Network;DB;Interpreter;Error Handling;Logging;Lang;Data Structure;DevOps;i18n;Setup;Logic;Microservices;ML;Test;Search;IO;UI;Parser;Security;Cloud;Big Data;Event Handling;App;GIS;Title;Body;prIssue;issue;issueTitle;issueBody;issueComments;issueTitleLink;issueBodyLink;issueCommentsLink;isPR;isTrain;commitMessage;Comments
1;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;refactoring conventions;;;0;refactoring conventions;;;;;;1;1;refactoring for consistent implementation approachcombined observableextensions into observable to match how rx works (observable* methods);
4;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove  wrap  functionality;we no longer need this as we ve merged the interface and abstract classes together and don t need to ensure we have the abstract class.;;0;remove wrap functionality;we no longer need this as weve merged the interface and abstract classes together and dont need to ensure we have the abstract class;;;;;1;1;remove wrap functionalitywe no longer need this as weve merged the interface and abstract classes together and dont need to ensure we have the abstract class;
5;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;support multiple class types for language adaptors;;;0;support multiple class types for language adaptors;;;;;;1;1;support multiple class types for language adaptors;
6;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;refactoring;- convert to rx.\* package names   - rx.observables   - rx.observables.operations (private package from javadocs)   - rx.util   - rx.lang   - rx.concurrency (placeholder for schedulers) - change func order to have return type at end => t  r instead of r  t   - this matches the c# and guava conventions - added action as func without return value   - added overload subscribe methods with action typed arguments - added from() alias methods in observable;;0;refactoring;- convert to rx\* package names  - rxobservables  - rxobservablesoperations (private package from javadocs)  - rxutil  - rxlang  - rxconcurrency (placeholder for schedulers)- change func order to have return type at end > t r instead of r t  - this matches the c# and guava conventions- added action as func without return value  - added overload subscribe methods with action typed arguments- added from() alias methods in observable;;;;;1;1;update language adaptors to rx* package;
"106;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;performance optimizations for dynamic function execution.;- memoize dynamic function constructions so executions are statically typed after a single dynamic lookup instead of dynamic on every execution  https://github.com/netflix/rxjava/issues/104;;0;performance optimizations for dynamic function execution;- memoize dynamic function constructions so executions are statically typed after a single dynamic lookup instead of dynamic on every executionhttps://githubcom/netflix/rxjava/issues/104;""test case:``` java    public void runcompositiontest(integer values) {        systemoutprintln(""""runcompositiontest"""")        final atomicinteger onnextsum  new atomicinteger(0)        final long start  systemnanotime()        mathfunction m  new mathfunction()        // 50 levels of composition (same function so thats not the cost)        observablefrom(values)                map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)                map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)                map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)                map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)                map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)                subscribe(new testobserver(onnextsum start))    }```before this commit  710082754 time: **437936ms**after this commit  710082754 time: **60605ms** || "";;;;1;1;performance optimizations for dynamic function execution- memoize dynamic function constructions so executions are statically typed after a single dynamic lookup instead of dynamic on every execution;"
"107;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;performance: reduce synchronization;performance changes as part of  and is an extension of work done in pull   this code was used to test the performance:      java     public void runcompositiontest(integer values) {         system.out.println( runcompositiontest )           final atomicinteger onnextsum = new atomicinteger(0)          final long start = system.nanotime()           mathfunction m = new mathfunction()          // 50 levels of composition (same function so that s not the cost)         observable.from(values)                 .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)                 .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)                 .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)                 .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)                 .map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m).map(m)                 .subscribe(new testobserver(onnextsum  start))      }      before it took:      sum: 710082754 time: 60.605ms      by reducing the nested synchronization (eliminating most of it) it is now running at:      sum: 710082754 time: 22.429ms;;0;performance: reduce synchronization;""performance changes as part of  and is an extension of work done in pull  code was used to test the performance:``` java    public void runcompositiontest(integer values) {        systemoutprintln(""""runcompositiontest"""")        final atomicinteger onnextsum  new atomicinteger(0)        final long start  systemnanotime()        mathfunction m  new mathfunction()        // 50 levels of composition (same function so thats not the cost)        observablefrom(values)                map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)                map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)                map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)                map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)                map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)map(m)                subscribe(new testobserver(onnextsum start))    }```before it took:```sum: 710082754 time: 60605ms```by reducing the nested synchronization (eliminating most of it) it is now running at:```sum: 710082754 time: 22429ms```"";;;;;1;1;format code delete test classes;"
108;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;adding a draft of subject class;https://github.com/netflix/rxjava/issues/19;;0;adding a draft of subject class;https://githubcom/netflix/rxjava/issues/19;;;;;1;1;removing the dependency on groovy;
109;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;creating toobservable for future;simple wrapper that turns a future into a observable.;;0;creating toobservable for future;simple wrapper that turns a future into a observable;this code looks fine though im curious about the implication of it blocking on the futureget()its obviously the only way to do it without spawning another thread that blocks on that future which would take us into this conversation:  this misleading to people to think it would be asynchronous? || ive added comments inline in the code as well || ;;;;1;1;adding more details about how the toobservable behaves;
113;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;concat;;;0;concat;;;;;;1;1;update comment in observable for concat;
120;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fixing javadocs; - added correct links to external images - cleaned up some of the text - improved some function memoization that was missed;;0;fixing javadocs; added correct links to external images- cleaned up some of the text- improved some function memoization that was missed;;;;;1;1;fixing javadocs added correct links to external images- cleaned up some of the text- improved some function memoization that was missed;
129;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;code cleanup;cleaned up some warnings highlighted by intellij idea;;0;code cleanup;cleaned up some warnings highlighted by intellij idea;thank you ||;;;;1;1;code cleanup;
137;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented range operator. fixes issue #68;;;0;implemented range operator fixes issue #68;;looks good mergingthis takes care of the first of 2 signatures in  you @mairbek ||;;;;1;1;implemented range operator;
"138;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented sequenceequal operator;fixes issue #76  since there is no direct analogue of  iequalitycomparer  in java   func2<t  t  boolean>  has been used.;;76.0;implemented sequenceequal operator;fixes issue #76since there is no direct analogue of `iequalitycomparer` in java `func2<t t boolean>` has been used;nice and great use of the zip operator! || thank you again @mairbek  ||;operator: sequenceequal;http://msdnmicrosoftcom/en-us/library/hh229024(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh212108(vvs103)aspx;""looking at these implementations it seems that by using zip it will emit a sequence of true/false values rather than a single boolean specifying if the entire sequence is true/falsei think it is supposed to emit only a single value based on reading the msdn docs@mairbek if you re-read the docs is it supposed to be a single value or sequence of values emitted? if single can you submit a fix? probably a reduce type function that keeps going until it finds a false otherwise if it hits oncomplete/onerror the same on both sides it returns true  || @benjchristensen okay ill submit the patch || reduce doesnt seems to be a good choice in this case since it would wait for all pairs of events even if first two were differenti will start by implementing all operation #21 and applying it to a `zip` of two observables || okay  this happens to be more complicated that ive expectedive come up with a test case that fails on `all` + `zip` implementation looks like `zip` operation completes the observation as fast as first observable completes which leads to wrong behaviour of `sequenceequal` operation``` java        @test        public void testsequenceequal3() {            observable<integer> first  observabletoobservable(1 2)            observable<integer> second  observabletoobservable(1 2 3)            @suppresswarnings(""""unchecked"""")            observer<boolean> result  mock(observerclass)            sequenceequal(first second)subscribe(result)            verify(result times(1))onnext(false)            verify(result times(1))oncompleted()            verifynomoreinteractions(result)        }``` || done || "";1;0;implemented sequenceequal method;"
142;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;rxjava errorhandler plugin; error handler plugin  plugin system;;0;rxjava errorhandler plugin; error handler plugin plugin system;;;;;1;1;rxjavaerrorhandler plugin error handler plugin plugin system;
"146;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;merge of pull #125 for issue #87 operator takewhile;manually merging  from @mairbek;;125.0;merge of pull #125 for issue #87 operator takewhile;manually merging  from @mairbek;implementation of  done by @mairbek ive run the unit tests locally and reviewed the code while doing the manual merge looks good so merging into master branch ||;implemented: takewhile;;""hi @mairbek thank you for contributing im going to checkout your branch to review this and will comment more (or merge if nothing needs to change) once ive done sotalk to you soon  || @mairbek i have reviewed the code and it looks goodthe missing part is the addition of methods to rxobservablethe 2 methods youd need to model after are:  that there is both a static and instance methodsince takewhile includes a func it will also need to support an overload with object such as this:-> typed:  non-typed:  you would end up with:static observabletakewhile(final observable<t> items final func1<t boolean> predicate)static observabletakewhile(final observable<t> items final func2<t integer boolean> predicate)static observabletakewhile(final observable<t> items final object predicate)instance observabletakewhile(final func2<t integer boolean> predicate)instance observabletakewhile(final func1<t boolean> predicate)instance observabletakewhile(final object predicate)one challenge with supporting dynamic languages is that overloading can get tricky and the implementation of takewhile as it currently stands has overloads with func1 and func2 this means that the overload with object will convert to funcn but we wont know which of the func1 or func2 methods to send tothus you may want to look at changing the operationtake to use only func2 for the takewhile methodswhen adding methods involving func\* overloads i then add unit tests for at least one of the dynamic languages to make sure its all working when going via the """"object"""" overloadsfor example:  you want to update this pull request to include the rxobservable methods? || > thus you may want to look at changing the operationtake to use only `func2` for the takewhile methodsi suppose people would mostly look for the `func1` method and use cases when you need `func2` function are pretty rareim going to name `takewhile` with `func2` as `takewhilewithindex` (not sure if this is a good name for this) to avoid overloading what do you think? || i need to spend some time playing with this as id like to try and find a way that doesnt require a different namei havent forgotten this but need to finish some other things then will come back to this || this is for issue  || this can no longer be automatically merged so im manually merging it into my local branch to play with and will either respond back with comments or submit with your commits in another pull request based off of yours || to allow us to avoid having takewhilewithindex (and just have takewhile) is it bad to require all closures to pass in both arguments and just ignore the index if they dont want it?``` groovyobservabletakewhile(observabletoobservable(1 2 3) { x i -> i < 2})subscribe({ result -> areceived(result)})`````` clojure(-> (rxobservable/toobservable [1 2 3]) (takewhile (fn [x i] (< x 2))) (subscribe (fn [arg] (println arg))))```versus``` groovyobservabletakewhile(observabletoobservable(1 2 3) { x -> x < 2})subscribe({ result -> areceived(result)})`````` clojure(-> (rxobservable/toobservable [1 2 3]) (takewhile (fn  (< x 2))) (subscribe (fn [arg] (println arg))))```asking around for opinions  || i have completed the merge in pull request  close this one out nowi stuck with the proposed design by @mairbek for the pull request and it has takewhile and takewhilewithindex since it seems the common use case would be takewhile so it keeps the closure implementations simple with a single argof course since were version 05 we can change this decision prior to 10 if there are strong opinions otherwise || thank you @mairbek great implementation i appreciate how clean and well tested your code is and that you strive to comply with the style of the project || i prefer `takewhile` and `takewhileindexed` two separate names is more explicit || thanks dave i also discussed with jafar who agreed so were good with the takewhilte/takewhileindexed naming convention and ill leave the code as committed || "";1;0;merge operator takewhile pull requestthis is a manual merge of  contributed by @mairbek;"
146;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;merge of pull #125 for issue #87 operator takewhile;manually merging  from @mairbek;;87.0;merge of pull #125 for issue #87 operator takewhile;manually merging  from @mairbek;implementation of  done by @mairbek ive run the unit tests locally and reviewed the code while doing the manual merge looks good so merging into master branch ||;operator: takewhile;http://msdnmicrosoftcom/en-us/library/hh244231(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229131(vvs103)aspx;;1;0;merge operator takewhile pull requestthis is a manual merge of  contributed by @mairbek;
"147;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator: foreach;issue   related to pull https://github.com/netflix/rxjava/pull/131;;0;operator: foreach;issue  to pull https://githubcom/netflix/rxjava/pull/131;""updated in another commit to bring inline with the msdn docs unit tests that show the behavior:``` groovy    @test    public void testforeach() {        observablecreate(new asyncobservable())foreach({ result -> areceived(result)})        verify(a times(1))received(1)        verify(a times(1))received(2)        verify(a times(1))received(3)    }    @test    public void testforeachwitherror() {        try {            observablecreate(new asyncobservable())foreach({ result -> throw new runtimeexception(err)})            fail(""""we expect an exception to be thrown"""")        }catch(exception e) {            // do nothing as we expect this        }        verify(a times(0))received(1)        verify(a times(0))received(2)        verify(a times(0))received(3)    }``` || thanks @mairbek for the review@dcapwell @jhusain or anyone else have comments on this before i merge? ill wait a few hours for feedback before merging and doing a release with this last batch of changes || looks good to me  only comment i would make is in the interruptedexception catch  since not throwing a interruptedexception but runtime it might be good to also add threadgetcurrentthread()interrupt() to set the interrupt flag again```    try {        latchawait()      } catch (interruptedexception e) {          threadgetcurrentthread()interrupt()        throw new runtimeexception(""""interrupted while waiting for subscription to complete"""" e) }``` || interesting point didnt even think of that as i figured the runtimeexception would be sufficient to cause the caller to behave appropriately but they could theoretically swallow runtimeexceptions and continue in a while loop check for isinterrupted() which could be lost in this scenario making that change now || "";;;;1;1;mark the thread as interrupted again;"
156;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented toiterable operation;for issue #18.  this would allow to implement other blocking methods like  single    lastordefault  next.;;18.0;implemented toiterable operation;for issue #18this would allow to implement other blocking methods like `single` `lastordefault` next;this looks good merging ||;operator: toiterable;we already from toobservable(iterable)/from(iterable)  add the reverse blocking toiterable() similar to the non-blocking tolist() which already existstoenumerable from c#: http://msdnmicrosoftcom/en-us/library/hh212132(vvs103)aspx;`toenumerable` dont seems to be different from `tolist`first one returns `iobservable<ilist<tsource>>` second one `ienumerable<tsource>` || the tolist operator is non-blocking as it returns observable<list<t>> whereas to iterable is blocking and returns iterable<t>the key difference is non-blocking versus blocking otherwise yes they behave similarlythe other difference though is that tolist will wait until the observable sequence is oncompleted() and then emit the list whereas toiterable will buffer but start allowing take() to be called immediately as each onnext() value is emitted ||  by the way  a key difference in java is that iterable is not an equal dual with observable whereas ienumerable is a dual to iobservable in net where both have extension methods with all the functional operatorssince java doesnt have extension methods we cant do that here at best we could have another parallel framework for wrapping an iterable ||;1;0;static method plus javadoc;
157;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented single and singleordefault;for issue #77.;;0;implemented single and singleordefault;for issue #77;i completed this merge in  since it had conflicts ||;;;;1;1;updated single/singleordefault according to review request;
159;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented lastordefault operator;for issue #58;;0;implemented lastordefault operator;for issue #58;looks good of note while reviewing this i realized the last() operator ( is wrong and needs to be   ||;;;;1;1;implemented lastordefault;
160;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;manual merge of mairbek/single pull #157;merging  which had conflicts and needed a manual merge.;;0;manual merge of mairbek/single pull #157;merging  which had conflicts and needed a manual merge;;;;;1;1;merge remote-tracking branch mairbek/singleadded @throws javadocssuppressed rawtypes warningsconflicts:	language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/observabletestsgroovy	rxjava-core/src/main/java/rx/observablejava;
165;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fixed bug in ranges;fixed issue #164.;;164.0; bug in ranges; issue #164;#3 ;rxutilrangecreatewithcount(int start int count) yields invalid sequence when start ! 1;createwithcount(1 4) correctly yields (1 2 3 4)createwithcount(2 4) yields (2 3 4 5 6 7 8 9) where it should be (2 3 4 5)createwithcount(0 4) yields () where it should be (0 1 2 3)createwithcount(-1 4) yields () where it should be (-1 0 1 2);thanks @mairbek for the quick fix@christianbourgeois i have merged the fix ( and will include in the next release i just want to review one more pull request to try and get it into that releaseit is okay if i wait until end of day today to release the new code or do you need the fix sooner? || thanks @mairbek for the quick fix and @benjchristensen for the mergeyou are all very fast i was in the process of sending a pull request when i saw the fix by @mairbekthis issue is not critical in any way for me no worries for the release || then ill finish up the other work before doing this release (hoping either end-of-day or over weekend)thanks for reporting the bug and being willing to submit a pull request (until @mairbek beat you to it!) || thank you @christianbourgeois for reporting the issuei had shortly realized what a dumb mistake i made in that code :) ||;1;0; bug in ranges;
167;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;reimplemented last operation;for issue #57.;;0;reimplemented last operation;for issue #57;#6 this looks good  holding off on merging until im ready to release 060 with breaking changesi will bundle this with the subscription ( changes as well since they will likely be breaking because theyll change the package of the subscription object || manually merged in  ||;;;;1;1;reimplemented last operation;
"168;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented most recent;for issue #64.;;0;implemented most recent;for issue #64;""#6  man it is hard to understand the difference between latest next mostrecent etc using msdn docs  || trying to figure out the difference between observablelatest ( and observablemostrecent ( other than the latter having an initialvalueboth return `ienumerable<tsource>` and both say """"samples the most recent value in an observable sequence""""the observablenext operator says """"samples the next value (blocking without buffering) from in an observable sequence"""" and also returns `ienumerable<tsource>` || my understanding of these operators are:- latest  - will cache the latest value and return immediately when iteratornext() is called   - or block if no value is cached until next value  - when the value is emitted it is removed from the cache so only emitted once- next  - will not cache the latest value so will block until next value- mostrecent  - will cache the latest value and return immediately when iteratornext() is called   - or block if no value is cached until next value  - the last value is always retained so if you subscribe to it multiple times it will keep returning the """"most recent"""" value  - the initialvalue guarantees it will never wait and immediately return || this pull request looks good  merging || "";;;;1;1;updated observable api;"
171;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented defer operation;for issue #35.;;0;implemented defer operation;for issue #35;looks good  merging ||;;;;1;1;implemented defer operation;
176;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented groupby;for issue #51.;;0;implemented groupby;for issue #51;#14  this is a difficult one with java as maintaining `groupedobservable` will require manual effort every time a new static is added and it will be very easy for it to drift away from observable in short im not a fan of relying on static method overridesim going to sit on this a bit while i think about and talk to others on this i want to better understand the groupby operator too so need to play with it || i used ide to delegate methods to underlying observable looks like it has generated statics methods as well let me remove them || ah so that wasnt intended   || in c# version `observable` is an interface and `groupedobservable` can simply extend it since in java version `observable` is a class i decided to make `groupedobservable` to be a proxy for `observable` || #17 yes your approach makes sensethe reason for the class rather than interface is because java doesnt have extension methods like c# does - otherwise wed also have observable be an interface (originally inside netflix we had observable as an interface and all implementations in abstractobservable  but everything has to work with abstractobservable  it was very awkward so we did away with it)i need to spend a few more minutes to understand this operator :-) || take a look at a different approach i took for `groupedobservable` in pull request  and let me know if you think that works okay || completed in  ||;;;;1;1;removed static methods delegations;
177;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator: dematerialize - review and manual merge;manual merge of pull request  for issue https://github.com/netflix/rxjava/issues/37;;0;operator: dematerialize - review and manual merge;manual merge of pull request  for issue https://githubcom/netflix/rxjava/issues/37;#15 ;;;;1;1;merge branch dematerialize of git://githubcom/prabirshrestha/rxjava into dematerialize-merge- added javadoc for @throws exception- suppressed unchecked warningsconflicts:	rxjava-core/src/main/java/rx/observablejava;
178;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;review and refactor of getiterator;review of pull request  for issue  along with a simple refactoring to reduce code in observable.java.;;0;review and refactor of getiterator;review of pull request  for issue  along with a simple refactoring to reduce code in observablejava;#16 ;;;;1;1;refactored iterator implementation out of observable into operatortoiterator- trying to keep the massively large observablejava class focused on the api and implementation details off in small classes;
179;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator groupby pull request - review and refactor;refactored version of pull request  for issue   i would like to avoid delegation if possible since it will mean it needs to be kept in sync with observable.  this refactored approach allows inheritance without delegation by composing the observable  inside another operator function.;;0;operator groupby pull request - review and refactor;refactored version of pull request  for issue  would like to avoid delegation if possible since it will mean it needs to be kept in sync with observablethis refactored approach allows inheritance without delegation by composing the observable  inside another operator function;#18  the only thing i dont like right now about this is having groupedobservable in the rx\* package it feels like an implementation detail that should live in a sub-package rather than the top-most packagefor example in rxnet `iobservable` is in system\* and `igroupedobservable` in systemreactivelinqim wondering if we should have rxobservables similar to rxsubscriptions ( belongs at rxobservable (and maybe the rxsubscription interface as well) but all other impls should be in a sub-package i think || #19;;;;1;1;move groupedobservable to rxobservables;
180;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;formatting and cleanup;;;0;formatting and cleanup;;#20;;;;1;1;cleanup various compiler warnings;
182;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;subscriptions utility class and rx.subscriptions package;https://github.com/netflix/rxjava/issues/173;;0;subscriptions utility class and rxsubscriptions package;https://githubcom/netflix/rxjava/issues/173;merging to become part of version 060 - this has breaking changes || #22;;;;1;1;subscriptions utility class and rxsubscriptions packagehttps://githubcom/netflix/rxjava/issues/173;
184;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;convert  last  from non-blocking to blocking to match rx.net;merging pull request  which needed manual merging.  did some other cleanup while in there and added a missing generic  object  override.  thank you @mairbek for doing this work.;;0;convert last from non-blocking to blocking to match rxnet;merging pull request  which needed manual mergingdid some other cleanup while in there and added a missing generic object overridethank you @mairbek for doing this work;#24 ;;;;1;1;convert last from non-blocking to blocking to match rxnetsee  for backgroundnote: this is a breaking change thus we are bumping the version from 05x to 06xmanual merge of branch last of git://githubcom/mairbek/rxjava into issue-57-lastconflicts:	rxjava-core/src/main/java/rx/observablejava;
187;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;confusing javadoc for  toobservable(future)  methods;https://github.com/netflix/rxjava/issues/148;;0;confusing javadoc for `toobservable(future)` methods;https://githubcom/netflix/rxjava/issues/148;#27 ;;;;1;1;confusing javadoc for `toobservable(future)` methodshttps://githubcom/netflix/rxjava/issues/148;
189;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;handful of improvements;some improvements made while reviewing code. - add error handling to videoexample.groovy so it s a better representation of how onerror is used - handle errors from func1 failures when subscribe happens - handle null subscriptions on  trusted  functions  not just untrusted;;0;handful of improvements;some improvements made while reviewing code- add error handling to videoexamplegroovy so its a better representation of how onerror is used- handle errors from func1 failures when subscribe happens- handle null subscriptions on trusted functions not just untrusted;#28 ;;;;1;1;more thorough error handling in case func1 implementation itself fails- func1call may fail (null impl bad impl etc)- func1call may success but the implementation itself may throw an exception instead of properly catching and sending to onerror;
190;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;update dematerialize so can chain correctly;just noticed this when i actually had to chain it.      java observable<file> saveresult = .       current:      java observable<notification<file>> a = saveresult.materialize().dematerialize()       expected:      java observable<file> a = saveresult.materialize().dematerialize()       here is what is happening      java observable<file> x = saveresult  observable<notification<file>> y = x.materialize()  observable<notification<file>> currentresult = y.dematerialize()  observable<file> expectedresult = observable.dematerialize(y)       workaround is to use static method to get the expected result.  with this change you can chain correctly. added unit test.      java observable<integer> obs = observable.just(1)  observable<integer> chained = obs.materialize().dematerialize()       this will be a breaking change. but i think this is the expected way.;;0;update dematerialize so can chain correctly;just noticed this when i actually had to chain it``` javaobservable<file> saveresult  ```current:``` javaobservable<notification<file>> a  saveresultmaterialize()dematerialize()```expected:``` javaobservable<file> a  saveresultmaterialize()dematerialize()```here is what is happening``` javaobservable<file> x  saveresultobservable<notification<file>> y  xmaterialize()observable<notification<file>> currentresult  ydematerialize()observable<file> expectedresult  observabledematerialize(y)```workaround is to use static method to get the expected resultwith this change you can chain correctly added unit test``` javaobservable<integer> obs  observablejust(1)observable<integer> chained  obsmaterialize()dematerialize()```this will be a breaking change but i think this is the expected way;#29  so its just the generics that are wrong? || yeah  this works without this fix:``` javaobservable chained  obsmaterialize()dematerialize()```but the compiler doesnt like this because the generics are wrong:``` javaobservable<integer> chained  obsmaterialize()dematerialize()``` || released in 061  || awesome thanks now need to wait for the maven repo update :(i did notice the `gradle release plugin - pre tag commit: rxjava-061`  the jar in maven and ci the same? || the jar is built by internal netflix build servers and then uploaded to maven centralthe public ci (cloudbees) also builds the jar but that one never goes anywhere ||;;;;1;1;updates dematerialize so can chain correctly;
191;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;where alias to filter;pr for #101;;0;where alias to filter;pr for #101;#30  ;;;;1;1;added where operation to observable;
"196;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;new operation finally (issue #43);hi   i was looking around for some fun stuff to do for the netflix cloud prize  and i figured i might start by contributing some enhancements to rxjava.  i did my best to match your existing style and practices  but i ve doubtless made some mistakes.  if you have time to take a quick look and give me some feedback  i ll accept it gratefully.   cheers  --abliss;;0;new operation finally (issue #43);hii was looking around for some fun stuff to do for the netflix cloud prize and i figured i might start by contributing some enhancements to rxjavai did my best to match your existing style and practices but ive doubtless made some mistakes  if you have time to take a quick look and give me some feedback ill accept it gratefully cheers--abliss;""this implements issue #43 (but apparently github doesnt autolinkify issue numbers in pull-request titles like it does in comments) || #33  @abliss seems like you forgot to add `finally0` in  || #34 @prabirshrestha thanks for the comments i added a static method to observableas for the try/catch it was not at all clear to me from the msdn documentation whether finally would allow the error to propagate or not  i figured it ought to propagate since this matches the semantics of javas """"finally"""" constructor do you mean that finally should be using try/catch to intercept exceptions in the rxjava framework?  this doesnt seem right to me i would expect wed rather trust the source observable to correctly implement all the necessary try/catch blocks and use onerror to propagate exceptions right? || #35 @abliss seems like you forgot to add the non-static method to `observable` tooeven im not sure about the `trycatch` on finally will have to check hence i had put the ? at the end || thanks again @prabirshrestha  i have added it || [rxjava-pull-requests #36 looks good || @abliss here is the net code i checked with``` c#new { 1 2 }    toobservable()    finally(() >        {            consolewriteline(""""finally block"""")            throw new exception(""""finally"""")        })    subscribe(consolewriteline ex > consolewriteline(exmessage) () > consolewriteline(""""completed""""))```output:```12completedfinally block(unhanded exception occurs in finally block)```this mean we dont need `trycatch` on `finally` but `completed` should be called before `finally` || thanks @prabirshrestha and @mairbek for your comments i have  the issues || [rxjava-pull-requests #37]( successthis pull request looks good || welcome to the project @abliss and thank you @prabirshrestha and @mairbek for the reviews on this  || thanks @benjchristensen !  if you have any suggestions for how to make this pull request more attractive or which issues to work on next im all ears  otherwise i will probably send a pull request for issue #14  next  || ive had other things taking my time this week so havent had a chance to review and merge this yet  i will get to it though issue #14 will be good as a next item || no worries at all i know its not exactly a high-priority issueactually i realized that #14 requires a scheduler which seems to be still under discussion instead im working on an enhancement to concat (issue #202 ) and will follow that with switch (issue #13 )   || [rxjava-pull-requests #58]( successthis pull request looks good || thanks for the comments i have fixed them all || "";;;;1;1;incorporate review suggestions- changes finally0 to finallydo- removes unnecessary subscription-wrapping- handle exceptions in oncompleted/onerror;"
"205;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;reimplementation of concat  improved handling of observable<observable<t;>>.  the old version required all of the observable<t>s to be generated and buffered before the concat could begin.  if the outer observable was asynchronous  items could be dropped (test added).  the new version passes the test  and does the best job i could (after examining several possible strategies) of achieving clear and consistent semantics in accordance with the principle of least surprise.  (my attempt to  #202);;202.0;reimplementation of concat improved handling of observable<observable<t;>>the old version required all of the observable<t>s to be generated and bufferedbefore the concat could begin  if the outer observable was asynchronous itemscould be dropped (test added)  the new version passes the test and does thebest job i could (after examining several possible strategies) of achievingclear and consistent semantics in accordance with the principle of leastsurprise(my attempt to  #202);""#45] there is another issue with this implementation  the countdown latch will always block the calling thread which is not desirable  anything that returns an observable should never be blocking  rx is meant to support composition of operations and allows each operation to run concurrently || while reviewing this i started playing with the unit tests and added 2 new ones i also made them use inorderverify so they ensure correct ordering ive pasted it below so you can merge into your branch instead of me complicating the merge with another branch the tests pass pass except `testconcatunsubscribe` which deadlocks it does this because a list<observable> wont return the subscription asynchronously so it cant unsubscribe meanwhile a countdownlatch is waiting for the change to trigger and the two latches end up waiting on each otheri havent thought through enough yet to determine if there is a way to solve that or if the unit test is just testing the wrong thing and thus a bad testthe comment above from @billy about countdownlatch originated from a discussion between him and i - but while reviewing this it is probably the right approachi was playing with other approaches that are purely non-blocking while retaining the correct concat sequential behavior but they all seem to require either:- another wrapping thread- stealing work from one of the child observable threads and making it do work that is queued on the others  and that seems like a bad idea even though it can be hacked to """"work"""" but it does so in a way that is very unexpected and thus not something i want to pursue- queueing all onnext values which could be a bad memory issue  and also means we eagerly subscribe which is not what we wantmy biggest issue right now is that concat(o1 o2) is a very common usage but that results in list<observable> which will be blocking and unsubscribe doesnt workill think through this more but id appreciate your thoughts on how to handle `testconcatunsubscribe` ``` java    public static class unittest {        @test        public void testconcat() {            @suppresswarnings(""""unchecked"""")            observer<string> observer  mock(observerclass)            final string o  { """"1"""" """"3"""" """"5"""" """"7"""" }            final string e  { """"2"""" """"4"""" """"6"""" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            @suppresswarnings(""""unchecked"""")            observable<string> concat  observablecreate(concat(odds even))            concatsubscribe(observer)            verify(observer times(7))onnext(anystring())        }        @test        public void testconcatwithlist() {            @suppresswarnings(""""unchecked"""")            observer<string> observer  mock(observerclass)            final string o  { """"1"""" """"3"""" """"5"""" """"7"""" }            final string e  { """"2"""" """"4"""" """"6"""" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            final list<observable<string>> list  new arraylist<observable<string>>()            listadd(odds)            listadd(even)            observable<string> concat  observablecreate(concat(list))            concatsubscribe(observer)            verify(observer times(7))onnext(anystring())        }        @test        public void testconcatunsubscribe() {            final countdownlatch callonce  new countdownlatch(1)            final countdownlatch oktocontinue  new countdownlatch(1)            final testobservable<string> w1  new testobservable<string>(""""one"""" """"two"""" """"three"""")            final testobservable<string> w2  new testobservable<string>(callonce oktocontinue """"four"""" """"five"""" """"six"""")            @suppresswarnings(""""unchecked"""")            observer<string> aobserver  mock(observerclass)            @suppresswarnings(""""unchecked"""")            observable<string> concat  observablecreate(concat(w1 w2))            systemoutprintln(""""before subscribe"""")            subscription s1  concatsubscribe(aobserver)            systemoutprintln(""""after subscribe"""")            try {                //block main thread to allow observable """"w1"""" to complete and observable """"w2"""" to call onnext once                systemoutprintln(""""before callonceawait"""")                callonceawait()                systemoutprintln(""""after callonceawait"""")                s1unsubscribe()                systemoutprintln(""""after s1unsubscribe"""")                //unblock the observable to continue                oktocontinuecountdown()                systemoutprintln(""""after countdown"""")                w1tjoin()                w2tjoin()            } catch (exception e) {                eprintstacktrace()                fail(egetmessage())            }            inorder inorder  inorder(aobserver)            inorderverify(aobserver times(1))onnext(""""one"""")            inorderverify(aobserver times(1))onnext(""""two"""")            inorderverify(aobserver times(1))onnext(""""three"""")            inorderverify(aobserver times(1))onnext(""""four"""")            inorderverify(aobserver never())onnext(""""five"""")            inorderverify(aobserver never())onnext(""""six"""")            inorderverify(aobserver times(1))oncompleted()        }        @test        public void testmergeobservableofobservables() {            @suppresswarnings(""""unchecked"""")            observer<string> observer  mock(observerclass)            final string o  { """"1"""" """"3"""" """"5"""" """"7"""" }            final string e  { """"2"""" """"4"""" """"6"""" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {                @override                public subscription call(observer<observable<string>> observer) {                    // simulate what would happen in an observable                    observeronnext(odds)                    observeronnext(even)                    observeroncompleted()                    return new subscription() {                        @override                        public void unsubscribe() {                            // unregister  will never be called here since we are executing synchronously                        }                    }                }            })            observable<string> concat  observablecreate(concat(observableofobservables))            concatsubscribe(observer)            verify(observer times(7))onnext(anystring())        }        /**         * simple concat of 2 asynchronous observables ensuring it emits in correct order         */        @suppresswarnings(""""unchecked"""")        @test        public void testsimpleasyncconcat() {            observer<string> observer  mock(observerclass)            testobservable<string> o1  new testobservable<string>(""""one"""" """"two"""" """"three"""")            testobservable<string> o2  new testobservable<string>(""""four"""" """"five"""" """"six"""")            observableconcat(o1 o2)subscribe(observer)            try {                // wait for async observables to complete                o1tjoin()                o2tjoin()            } catch (exception e) {                throw new runtimeexception(""""failed waiting on threads"""")            }            inorder inorder  inorder(observer)            inorderverify(observer times(1))onnext(""""one"""")            inorderverify(observer times(1))onnext(""""two"""")            inorderverify(observer times(1))onnext(""""three"""")            inorderverify(observer times(1))onnext(""""four"""")            inorderverify(observer times(1))onnext(""""five"""")            inorderverify(observer times(1))onnext(""""six"""")        }        /**         * test an async observable that emits more async observables         */        @suppresswarnings(""""unchecked"""")        @test        public void testnestedasyncconcat() throws exception {            observer<string> observer  mock(observerclass)            final testobservable<string> o1  new testobservable<string>(""""one"""" """"two"""" """"three"""")            final testobservable<string> o2  new testobservable<string>(""""four"""" """"five"""" """"six"""")            final testobservable<string> o3  new testobservable<string>(""""seven"""" """"eight"""" """"nine"""")            final countdownlatch allowthird  new countdownlatch(1)            final atomicreference<thread> parent  new atomicreference<thread>()            observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {                @override                public subscription call(final observer<observable<string>> observer) {                    final booleansubscription s  new booleansubscription()                    parentset(new thread(new runnable() {                        @override                        public void run() {                            try {                                // emit first                                if (!sisunsubscribed()) {                                    systemoutprintln(""""emit o1"""")                                    observeronnext(o1)                                }                                // emit second                                if (!sisunsubscribed()) {                                    systemoutprintln(""""emit o2"""")                                    observeronnext(o2)                                }                                // wait until sometime later and emit third                                try {                                    allowthirdawait()                                } catch (interruptedexception e) {                                    observeronerror(e)                                }                                if (!sisunsubscribed()) {                                    systemoutprintln(""""emit o3"""")                                    observeronnext(o3)                                }                            } catch (exception e) {                                observeronerror(e)                            } finally {                                systemoutprintln(""""done parent observable"""")                                observeroncompleted()                            }                        }                    }))                    parentget()start()                    return s                }            })            observablecreate(concat(observableofobservables))subscribe(observer)            // wait for parent to start            while (parentget()  null) {                threadsleep(1)            }            try {                // wait for first 2 async observables to complete                while (o1t  null) {                    threadsleep(1)                }                systemoutprintln(""""thread1 started  waiting for it to complete """")                o1tjoin()                while (o2t  null) {                    threadsleep(1)                }                systemoutprintln(""""thread2 started  waiting for it to complete """")                o2tjoin()            } catch (exception e) {                throw new runtimeexception(""""failed waiting on threads"""" e)            }            inorder inorder  inorder(observer)            inorderverify(observer times(1))onnext(""""one"""")            inorderverify(observer times(1))onnext(""""two"""")            inorderverify(observer times(1))onnext(""""three"""")            inorderverify(observer times(1))onnext(""""four"""")            inorderverify(observer times(1))onnext(""""five"""")            inorderverify(observer times(1))onnext(""""six"""")            // we shouldnt have the following 3 yet            inorderverify(observer never())onnext(""""seven"""")            inorderverify(observer never())onnext(""""eight"""")            inorderverify(observer never())onnext(""""nine"""")            // we should not be completed yet            verify(observer never())oncompleted()            verify(observer never())onerror(any(exceptionclass))            // now allow the third            allowthirdcountdown()            try {                while (o3t  null) {                    threadsleep(1)                }                // wait for 3rd to complete                o3tjoin()            } catch (exception e) {                throw new runtimeexception(""""failed waiting on threads"""" e)            }            inorderverify(observer times(1))onnext(""""seven"""")            inorderverify(observer times(1))onnext(""""eight"""")            inorderverify(observer times(1))onnext(""""nine"""")            inorderverify(observer times(1))oncompleted()            verify(observer never())onerror(any(exceptionclass))        }        @suppresswarnings(""""unchecked"""")        @test        public void testblockedobservableofobservables() {            observer<string> observer  mock(observerclass)            final string o  { """"1"""" """"3"""" """"5"""" """"7"""" }            final string e  { """"2"""" """"4"""" """"6"""" }            final observable<string> odds  observabletoobservable(o)            final observable<string> even  observabletoobservable(e)            final countdownlatch callonce  new countdownlatch(1)            final countdownlatch oktocontinue  new countdownlatch(1)            testobservable<observable<string>> observableofobservables  new testobservable<observable<string>>(callonce oktocontinue odds even)            func1<observer<string> subscription> concatf  concat(observableofobservables)            observable<string> concat  observablecreate(concatf)            concatsubscribe(observer)            try {                //block main thread to allow observables to serve up o1                callonceawait()            } catch (exception ex) {                exprintstacktrace()                fail(exgetmessage())            }            // the concated observable should have served up all of the odds            verify(observer times(1))onnext(""""1"""")            verify(observer times(1))onnext(""""3"""")            verify(observer times(1))onnext(""""5"""")            verify(observer times(1))onnext(""""7"""")            try {                // unblock observables so it can serve up o2 and complete                oktocontinuecountdown()                observableofobservablestjoin()            } catch (exception ex) {                exprintstacktrace()                fail(exgetmessage())            }            // the concatenated observable should now have served up all the evens            verify(observer times(1))onnext(""""2"""")            verify(observer times(1))onnext(""""4"""")            verify(observer times(1))onnext(""""6"""")        }        private static class testobservable<t> extends observable<t> {            private final subscription s  new subscription() {                @override                public void unsubscribe() {                    subscribed  false                }            }            private final list<t> values            private thread t  null            private int count  0            private boolean subscribed  true            private final countdownlatch once            private final countdownlatch oktocontinue            public testobservable(t values) {                this(null null values)            }            public testobservable(countdownlatch once countdownlatch oktocontinue t values) {                thisvalues  arraysaslist(values)                thisonce  once                thisoktocontinue  oktocontinue            }            @override            public subscription subscribe(final observer<t> observer) {                t  new thread(new runnable() {                    @override                    public void run() {                        try {                            while (count < valuessize() && subscribed) {                                observeronnext(valuesget(count))                                count++                                //unblock the main thread to call unsubscribe                                if (null ! once)                                    oncecountdown()                                //block until the main thread has called unsubscribe                                if (null ! once)                                    oktocontinueawait()                            }                            if (subscribed)                                observeroncompleted()                        } catch (interruptedexception e) {                            eprintstacktrace()                            fail(egetmessage())                        }                    }                })                tstart()                return s            }        }    }``` || thanks for the comments and the extra tests i have merged them anduploaded a new versionregarding testconcatunsubscribe: im still not entirely sure of my footingbut i believe the test is in error it is demonstrating exactly the issuewhich i mentioned in the new javadoc for operationconcat specifically itsets up a situation wherein the inner observables thread is blocked on theouter observables thread: the inner thread cannot proceed until the testcalls oktocontinuecountdown() which happens-afterconcatsubscribe(aobserver) which blocks until the list has delivered bothw1 and w2am i right that in general an observer should block onnext() until it hasfinished processing the item? this pushes the flow-control upstream ratherthan excessive buffering or throttling (which can be done explicitly in theoperation-chain if desired) if thats right then i think concat mustblock the outer onnext until it has finished servicing the inner sequencei do find it a little strange that observablefrom(iterable) is a """"shotgunobservable"""" ie the subscribe() blocks until all downstream operationshave completed on all items which means it is impossible to everunsubscribe() but given that this is correct behavior i think that itmakes sense that concat(o1 o2) also cannot be unsubscribed-from i added acautionary comment to the javadoci have updated the test case to call concatsubscribe(aobserver) in abackground thread which fixes the deadlock and to expect all items to bedelivered despite an unsubscribe which makes the test pass(i had also tried those three non-blocking approaches before uploading thisversion thanks for checking my work :)on mar 27 2013 6:56 am """"ben christensen"""" notifications@githubcom wrote:> while reviewing this i started playing with the unit tests and added 2 new> ones i also made them use inorderverify so they ensure correct ordering> ive pasted it below so you can merge into your branch instead of me> complicating the merge with another branch> > the tests pass pass except testconcatunsubscribe which deadlocks it does> this because a list wont return the subscription asynchronously so it> cant unsubscribe meanwhile a countdownlatch is waiting for the change to> trigger and the two latches end up waiting on each other> > i havent thought through enough yet to determine if there is a way to> solve that or if the unit test is just testing the wrong thing and thus a> bad test> > the comment above from @billy  about> countdownlatch originated from a discussion between him and i - but while> reviewing this it is probably the right approach> > i was playing with other approaches that are purely non-blocking while> retaining the correct concat sequential behavior but they all seem to> require either:> - another wrapping thread> - stealing work from one of the child observable threads and making it>   do work that is queued on the others  and that seems like a bad idea>   even though it can be hacked to """"work"""" but it does so in a way that is very>   unexpected and thus not something i want to pursue> - queueing all onnext values which could be a bad memory issue  and>   also means we eagerly subscribe which is not what we want> > my biggest issue right now is that concat(o1 o2) is a very common usage> but that results in list which will be blocking and unsubscribe doesnt> work> > ill think through this more but id appreciate your thoughts on how to> handle testconcatunsubscribe> > ```> public static class unittest {> >     @test>     public void testconcat() {>         @suppresswarnings(""""unchecked"""")>         observer<string> observer  mock(observerclass)> >         final string o  { """"1"""" """"3"""" """"5"""" """"7"""" }>         final string e  { """"2"""" """"4"""" """"6"""" }> >         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)> >         @suppresswarnings(""""unchecked"""")>         observable<string> concat  observablecreate(concat(odds even))>         concatsubscribe(observer)> >         verify(observer times(7))onnext(anystring())>     }> >     @test>     public void testconcatwithlist() {>         @suppresswarnings(""""unchecked"""")>         observer<string> observer  mock(observerclass)> >         final string[] o  { """"1"""" """"3"""" """"5"""" """"7"""" }>         final string[] e  { """"2"""" """"4"""" """"6"""" }> >         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)>         final list<observable<string>> list  new arraylist<observable<string>>()>         listadd(odds)>         listadd(even)>         observable<string> concat  observablecreate(concat(list))>         concatsubscribe(observer)> >         verify(observer times(7))onnext(anystring())>     }> >     @test>     public void testconcatunsubscribe() {>         final countdownlatch callonce  new countdownlatch(1)>         final countdownlatch oktocontinue  new countdownlatch(1)>         final testobservable<string> w1  new testobservable<string>(""""one"""" """"two"""" """"three"""")>         final testobservable<string> w2  new testobservable<string>(callonce oktocontinue """"four"""" """"five"""" """"six"""")> >         @suppresswarnings(""""unchecked"""")>         observer<string> aobserver  mock(observerclass)>         @suppresswarnings(""""unchecked"""")>         observable<string> concat  observablecreate(concat(w1 w2))>         systemoutprintln(""""before subscribe"""")>         subscription s1  concatsubscribe(aobserver)>         systemoutprintln(""""after subscribe"""")>         try {>             //block main thread to allow observable """"w1"""" to complete and observable """"w2"""" to call onnext once>             systemoutprintln(""""before callonceawait"""")>             callonceawait()>             systemoutprintln(""""after callonceawait"""")>             s1unsubscribe()>             systemoutprintln(""""after s1unsubscribe"""")>             //unblock the observable to continue>             oktocontinuecountdown()>             systemoutprintln(""""after countdown"""")>             w1tjoin()>             w2tjoin()>         } catch (exception e) {>             eprintstacktrace()>             fail(egetmessage())>         }> >         inorder inorder  inorder(aobserver)>         inorderverify(aobserver times(1))onnext(""""one"""")>         inorderverify(aobserver times(1))onnext(""""two"""")>         inorderverify(aobserver times(1))onnext(""""three"""")>         inorderverify(aobserver times(1))onnext(""""four"""")>         inorderverify(aobserver never())onnext(""""five"""")>         inorderverify(aobserver never())onnext(""""six"""")>         inorderverify(aobserver times(1))oncompleted()>     }> >     @test>     public void testmergeobservableofobservables() {>         @suppresswarnings(""""unchecked"""")>         observer<string> observer  mock(observerclass)> >         final string[] o  { """"1"""" """"3"""" """"5"""" """"7"""" }>         final string[] e  { """"2"""" """"4"""" """"6"""" }> >         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)> >         observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {> >             @override>             public subscription call(observer<observable<string>> observer) {>                 // simulate what would happen in an observable>                 observeronnext(odds)>                 observeronnext(even)>                 observeroncompleted()> >                 return new subscription() {> >                     @override>                     public void unsubscribe() {>                         // unregister  will never be called here since we are executing synchronously>                     }> >                 }>             }> >         })>         observable<string> concat  observablecreate(concat(observableofobservables))>         concatsubscribe(observer)>         verify(observer times(7))onnext(anystring())>     }> >     /**         * simple concat of 2 asynchronous observables ensuring it emits in correct order         */>     @suppresswarnings(""""unchecked"""")>     @test>     public void testsimpleasyncconcat() {>         observer<string> observer  mock(observerclass)> >         testobservable<string> o1  new testobservable<string>(""""one"""" """"two"""" """"three"""")>         testobservable<string> o2  new testobservable<string>(""""four"""" """"five"""" """"six"""")> >         observableconcat(o1 o2)subscribe(observer)> >         try {>             // wait for async observables to complete>             o1tjoin()>             o2tjoin()>         } catch (exception e) {>             throw new runtimeexception(""""failed waiting on threads"""")>         }> >         inorder inorder  inorder(observer)>         inorderverify(observer times(1))onnext(""""one"""")>         inorderverify(observer times(1))onnext(""""two"""")>         inorderverify(observer times(1))onnext(""""three"""")>         inorderverify(observer times(1))onnext(""""four"""")>         inorderverify(observer times(1))onnext(""""five"""")>         inorderverify(observer times(1))onnext(""""six"""")>     }> >     /**         * test an async observable that emits more async observables         */>     @suppresswarnings(""""unchecked"""")>     @test>     public void testnestedasyncconcat() throws exception {>         observer<string> observer  mock(observerclass)> >         final testobservable<string> o1  new testobservable<string>(""""one"""" """"two"""" """"three"""")>         final testobservable<string> o2  new testobservable<string>(""""four"""" """"five"""" """"six"""")>         final testobservable<string> o3  new testobservable<string>(""""seven"""" """"eight"""" """"nine"""")>         final countdownlatch allowthird  new countdownlatch(1)> >         final atomicreference<thread> parent  new atomicreference<thread>()>         observable<observable<string>> observableofobservables  observablecreate(new func1<observer<observable<string>> subscription>() {> >             @override>             public subscription call(final observer<observable<string>> observer) {>                 final booleansubscription s  new booleansubscription()>                 parentset(new thread(new runnable() {> >                     @override>                     public void run() {>                         try {>                             // emit first>                             if (!sisunsubscribed()) {>                                 systemoutprintln(""""emit o1"""")>                                 observeronnext(o1)>                             }>                             // emit second>                             if (!sisunsubscribed()) {>                                 systemoutprintln(""""emit o2"""")>                                 observeronnext(o2)>                             }> >                             // wait until sometime later and emit third>                             try {>                                 allowthirdawait()>                             } catch (interruptedexception e) {>                                 observeronerror(e)>                             }>                             if (!sisunsubscribed()) {>                                 systemoutprintln(""""emit o3"""")>                                 observeronnext(o3)>                             }> >                         } catch (exception e) {>                             observeronerror(e)>                         } finally {>                             systemoutprintln(""""done parent observable"""")>                             observeroncompleted()>                         }>                     }>                 }))>                 parentget()start()>                 return s>             }>         })> >         observablecreate(concat(observableofobservables))subscribe(observer)> >         // wait for parent to start>         while (parentget()  null) {>             threadsleep(1)>         }> >         try {>             // wait for first 2 async observables to complete>             while (o1t  null) {>                 threadsleep(1)>             }>             systemoutprintln(""""thread1 started  waiting for it to complete """")>             o1tjoin()>             while (o2t  null) {>                 threadsleep(1)>             }>             systemoutprintln(""""thread2 started  waiting for it to complete """")>             o2tjoin()>         } catch (exception e) {>             throw new runtimeexception(""""failed waiting on threads"""" e)>         }> >         inorder inorder  inorder(observer)>         inorderverify(observer times(1))onnext(""""one"""")>         inorderverify(observer times(1))onnext(""""two"""")>         inorderverify(observer times(1))onnext(""""three"""")>         inorderverify(observer times(1))onnext(""""four"""")>         inorderverify(observer times(1))onnext(""""five"""")>         inorderverify(observer times(1))onnext(""""six"""")>         // we shouldnt have the following 3 yet>         inorderverify(observer never())onnext(""""seven"""")>         inorderverify(observer never())onnext(""""eight"""")>         inorderverify(observer never())onnext(""""nine"""")>         // we should not be completed yet>         verify(observer never())oncompleted()>         verify(observer never())onerror(any(exceptionclass))> >         // now allow the third>         allowthirdcountdown()> >         try {>             while (o3t  null) {>                 threadsleep(1)>             }>             // wait for 3rd to complete>             o3tjoin()>         } catch (exception e) {>             throw new runtimeexception(""""failed waiting on threads"""" e)>         }> >         inorderverify(observer times(1))onnext(""""seven"""")>         inorderverify(observer times(1))onnext(""""eight"""")>         inorderverify(observer times(1))onnext(""""nine"""")> >         inorderverify(observer times(1))oncompleted()>         verify(observer never())onerror(any(exceptionclass))>     }> >     @suppresswarnings(""""unchecked"""")>     @test>     public void testblockedobservableofobservables() {>         observer<string> observer  mock(observerclass)> >         final string[] o  { """"1"""" """"3"""" """"5"""" """"7"""" }>         final string[] e  { """"2"""" """"4"""" """"6"""" }>         final observable<string> odds  observabletoobservable(o)>         final observable<string> even  observabletoobservable(e)>         final countdownlatch callonce  new countdownlatch(1)>         final countdownlatch oktocontinue  new countdownlatch(1)>         testobservable<observable<string>> observableofobservables  new testobservable<observable<string>>(callonce oktocontinue odds even)>         func1<observer<string> subscription> concatf  concat(observableofobservables)>         observable<string> concat  observablecreate(concatf)>         concatsubscribe(observer)>         try {>             //block main thread to allow observables to serve up o1>             callonceawait()>         } catch (exception ex) {>             exprintstacktrace()>             fail(exgetmessage())>         }>         // the concated observable should have served up all of the odds>         verify(observer times(1))onnext(""""1"""")>         verify(obser"
"er times(1))onnext(""""3"""")>         verify(observer times(1))onnext(""""5"""")>         verify(observer times(1))onnext(""""7"""")> >         try {>             // unblock observables so it can serve up o2 and complete>             oktocontinuecountdown()>             observableofobservablestjoin()>         } catch (exception ex) {>             exprintstacktrace()>             fail(exgetmessage())>         }>         // the concatenated observable should now have served up all the evens>         verify(observer times(1))onnext(""""2"""")>         verify(observer times(1))onnext(""""4"""")>         verify(observer times(1))onnext(""""6"""")>     }> >     private static class testobservable<t> extends observable<t> {> >         private final subscription s  new subscription() {> >             @override>             public void unsubscribe() {>                 subscribed  false>             }> >         }>         private final list<t> values>         private thread t  null>         private int count  0>         private boolean subscribed  true>         private final countdownlatch once>         private final countdownlatch oktocontinue> >         public testobservable(t values) {>             this(null null values)>         }> >         public testobservable(countdownlatch once countdownlatch oktocontinue t values) {>             thisvalues  arraysaslist(values)>             thisonce  once>             thisoktocontinue  oktocontinue>         }> >         @override>         public subscription subscribe(final observer<t> observer) {>             t  new thread(new runnable() {> >                 @override>                 public void run() {>                     try {>                         while (count < valuessize() && subscribed) {>                             observeronnext(valuesget(count))>                             count++>                             //unblock the main thread to call unsubscribe>                             if (null ! once)>                                 oncecountdown()>                             //block until the main thread has called unsubscribe>                             if (null ! once)>                                 oktocontinueawait()>                         }>                         if (subscribed)>                             observeroncompleted()>                     } catch (interruptedexception e) {>                         eprintstacktrace()>                         fail(egetmessage())>                     }>                 }> >             })>             tstart()>             return s>         }> >     }> > }> ```> > > reply to this email directly or view it on github  || #59  #60 thanks for update  let me take a look and i will do some moreresearch/thought on the testconcatsubscribe test caseon fri mar 29 2013 at 2:22 am cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #60 > this pull request looks good> > > reply to this email directly or view it on github  || [rxjava-pull-requests #72 looks good || my original test case was intended to test the unsubscribe inside one ofchild observable   the countdownlatch was used so that the code will havea chance to unsubscribe in a predicable manner (unsubscribe after """"four"""") in a normal case there should be no blocking between inner and outerobservable  i rewrote the case for better clarity and having the outerobservable is in a separate thread (so the test will pass now)  youbrought up a good point about """"when"""" you can unsubscribe  should it onlyallow unsubscribe to happen during the outer onnext()?  i need to do moreresearch on it  here is the test i plan to add```    @test``` public void testconcatunsubscribeobservableofobservable() {```        final countdownlatch callonce  new countdownlatch(1)        final countdownlatch oktocontinue  new countdownlatch(1)        final testobservable<string> w1  new testobservable<string>(```""""one"""" """"two"""" """"three"""")```        final testobservable<string> w2 ```newtestobservable<string>(callonce oktocontinue""""four"""" """"five"""" """"six"""")```        @suppresswarnings(""""unchecked"""")        observer<string> aobserver  mock(observerclass)        @suppresswarnings(""""unchecked"""")```   testobservable<observable<string>> observableofobservables newtestobservable<observable<string>>(w1 w2)```        func1<observer<string> subscription> concatf ```concat(observableofobservables)```        observable<string> concat  observablecreate(concatf)        subscription s1  concatsubscribe(aobserver)        try {            //block main thread to allow observable """"w1"""" to complete```and observable """"w2"""" to call onnext exactly once```        callonceawait()        //""""four"""" has been processed by onnext()            s1unsubscribe()            //""""five"""" and """"six"""" will not be processed by onnext()            //unblock the observable to continue            oktocontinuecountdown()            w1tjoin()            w2tjoin()        } catch (exception e) {            eprintstacktrace()            fail(egetmessage())        }        inorder inorder  inorder(aobserver)        inorderverify(aobserver times(1))onnext(""""one"""")        inorderverify(aobserver times(1))onnext(""""two"""")        inorderverify(aobserver times(1))onnext(""""three"""")        inorderverify(aobserver times(1))onnext(""""four"""")        inorderverify(aobserver never())onnext(""""five"""")        inorderverify(aobserver never())onnext(""""six"""")        verify(aobserver never())oncompleted()        verify(aobserver never())onerror(any(exceptionclass))```  }on tue apr 2 2013 at 8:55 pm cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #72 > this pull request looks good> > > reply to this email directly or view it on github  || the rx net version of concat uses the immediatescheduler to execute theoperation which will execute the operation on the same calling thread  soif the observables are running on the same thread it will besynchronous/blocked   i have pulled in your changes from your fork andadded the additional unit test to test unsubscribe() with observablesrunning in different thread  i have also updated the javadoc about theblocking with observable on the same thread  from my side it looks goodon wed apr 3 2013 at 10:20 am billy yuen billyy@gmailcom wrote:> my original test case was intended to test the unsubscribe inside one of> child observable   the countdownlatch was used so that the code will have> a chance to unsubscribe in a predicable manner (unsubscribe after """"four"""")>  in a normal case there should be no blocking between inner and outer> observable  i rewrote the case for better clarity and having the outer> observable is in a separate thread (so the test will pass now)  you> brought up a good point about """"when"""" you can unsubscribe  should it only> allow unsubscribe to happen during the outer onnext()?  i need to do more> research on it  here is the test i plan to add> > ```>     @test> ```> >  public void testconcatunsubscribeobservableofobservable() {> > ```>         final countdownlatch callonce  new countdownlatch(1)> >         final countdownlatch oktocontinue  new countdownlatch(1)> >         final testobservable<string> w1  new testobservable<string>(> ```> > """"one"""" """"two"""" """"three"""")> > ```>         final testobservable<string> w2  newtestobservable<string>(callonce oktocontinue> ```> > """"four"""" """"five"""" """"six"""")> > ```>         @suppresswarnings(""""unchecked"""")> >         observer<string> aobserver  mock(observerclass)> >         @suppresswarnings(""""unchecked"""")> ```> >    testobservable<observable<string>> observableofobservables  newtestobservable<observable<string>>(w1 w2)> > ```>         func1<observer<string> subscription> concatf > ```> > concat(observableofobservables)> > ```>         observable<string> concat  observablecreate(concatf)> > > >         subscription s1  concatsubscribe(aobserver)> > > >         try {> >             //block main thread to allow observable """"w1"""" to complete> ```> > and observable """"w2"""" to call onnext exactly once> > ```>         callonceawait()> >         //""""four"""" has been processed by onnext()> >             s1unsubscribe()> >             //""""five"""" and """"six"""" will not be processed by onnext()> >             //unblock the observable to continue> >             oktocontinuecountdown()> >             w1tjoin()> >             w2tjoin()> >         } catch (exception e) {> >             eprintstacktrace()> >             fail(egetmessage())> >         }> > >         inorder inorder  inorder(aobserver)> >         inorderverify(aobserver times(1))onnext(""""one"""")> >         inorderverify(aobserver times(1))onnext(""""two"""")> >         inorderverify(aobserver times(1))onnext(""""three"""")> >         inorderverify(aobserver times(1))onnext(""""four"""")> >         inorderverify(aobserver never())onnext(""""five"""")> >         inorderverify(aobserver never())onnext(""""six"""")> >         verify(aobserver never())oncompleted()> >         verify(aobserver never())onerror(any(exceptionclass))> ```> >   }> > on tue apr 2 2013 at 8:55 pm cloudbees pull request builder plugin <> notifications@githubcom> wrote:> > > rxjava-pull-requests #72 > > > this pull request looks good> > > > > > reply to this email directly or view it on github >  || > i do find it a little strange that observablefrom(iterable) is a """"shotgun> observable"""" ie the subscribe() blocks until all downstream operations> have completed on all items which means it is impossible to ever> unsubscribe() but given that this is correct behavior i think that it> makes sense that concat(o1 o2) also cannot be unsubscribed-from i added a> cautionary comment to the javadocrx does not (or rarely does) add concurrency (see guideline 612) thus `observablefrom` is wrapping a synchronous iterable therefore the observable will be synchronousa `scheduler` could be used to make the subscription to an iterable happen on another thread or a custom `observable` could be created that handles an iterable asynchronouslyall rx operators must be capable of handling both synchronous and asynchronous sequences and if its synchronous that means unsubscribe will not work (which means its up to the implementor of an observable to understand this and decided if its okay to firehose the results)for the case of concat my concern is that if all the sequences being combined are async then we need to retain the async behavior and not block and prevent unsubscriptionfor example:- async or synchronous observablea with 10 items- async or synchronous observableb with 20 items- async observablec with infinite items (hot observable that never completed)i should be able to do this: `concat(a b c)take(50)` this should get the 10 items from a 20 items from b and first 20 items from c and then unsubscribe and continuedoes this work with the current implementation and correctly unsubscribe from observablec? || good point  the best way to tell is to build an unit test for this case i can expand my new test to include this case and see what happenon wed apr 3 2013 at 2:29 pm ben christensen notifications@githubcomwrote:> i do find it a little strange that observablefrom(iterable) is a """"shotgun> observable"""" ie the subscribe() blocks until all downstream operations> have completed on all items which means it is impossible to ever> unsubscribe() but given that this is correct behavior i think that it> makes sense that concat(o1 o2) also cannot be unsubscribed-from i added a> cautionary comment to the javadoc> > rx does not (or rarely does) add concurrency (see guideline 612) thus> observablefrom is wrapping a synchronous iterable therefore the> observable will be synchronous> > a scheduler could be used to make the subscription to an iterable happen> on another thread or a custom observable could be created that handles> an iterable asynchronously> > all rx operators must be capable of handling both synchronous and> asynchronous sequences and if its synchronous that means unsubscribe will> not work (which means its up to the implementor of an observable to> understand this and decided if its okay to firehose the results)> > for the case of concat my concern is that if all the sequences being> combined are async then we need to retain the async behavior and not block> and prevent unsubscription> > for example:> - async or synchronous observablea with 10 items> - async or synchronous observableb with 20 items> - async observablec with infinite items (hot observable that never>   completed)> > i should be able to do this:> > concat(a b c)take(50)> > this should get the 10 items from a 20 items from b and first 20 items> from c and then unsubscribe and continue> > does this work with the current implementation and correctly unsubscribe> from observablec?> > > reply to this email directly or view it on github  || "";behavior of concat(observable<observable<t>>);""i have a question about the behavior of concat when given an observable of observables  currently it seems to materialize its input into a list then concat the list this runs counter to my expectation which would be that new observables could be produced while the concat is underway  in other words (a) elements from the first observable<t> should be rendered by concat() even if the observable<observable<t>> is blocked and (b) the concat()ed observable should not start pulling elements from the next observable<t> (or call oncompleted) until the current observable<t> calls oncompletedi have written a failing unit test which illustrates the behavior i was expecting: question then is (1) does this match the behavior of net (2) if so is this a design decision youre comfortable emulating and (3) if so does this match everyone elses intuition given the current documentation (which is silent on this issue)?if the answer to any of the above is """"no"""" im happy to provide a patch  "";""the observable of observable in concat was something i put in last minutefor completeness  it was not the desired implementation  i meant toupdate that code but never got around to it  if you have patch pleasesend it  i probably will take a look at this weekend again    thanks forbringing this upon wed mar 20 2013 at 8:01 am abliss notifications@githubcom wrote:> i have a question about the behavior of concat when given an observable of> observables currently it seems to materialize its input into a list then> concat the list this runs counter to my expectation which would be that> new observables could be produced while the concat is underway in other> words (a) elements from the first observable should be rendered by> concat() even if the observable<observable<t>> is blocked and (b) the> concat()ed observable should not start pulling elements from the next> observable (or call oncompleted) until the current observable<t> calls> oncompleted> > i have written a failing unit test which illustrates the behavior i was> expecting:>  > my question then is (1) does this match the behavior of net (2) if so> is this a design decision youre comfortable emulating and (3) if so does> this match everyone elses intuition given the current documentation (which> is silent on this issue)?> > if the answer to any of the above is """"no"""" im happy to provide a patch> > > reply to this email directly or view it on github  || "";1;0;merge branch master of git://githubcom/netflix/rxjava into issue202;"
"221;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;error handling improvements - user provided observers/functions;improve error handling as per discussion in issue   this is by no means exhaustive in the search for places needing this protection but gets the most obvious ones entering via  subscribe  and  foreach .  the intention is to protect against exceptions being thrown and ensure onnext/onerror/oncompleted contract compliance.;;0;error handling improvements - user provided observers/functions;improve error handling as per discussion in issue  is by no means exhaustive in the search for places needing this protection but gets the most obvious ones entering via `subscribe` and `foreach`the intention is to protect against exceptions being thrown and ensure onnext/onerror/oncompleted contract compliance;""#68  #69 ive incorporated the change to restrict """"internal"""" identification to rxoperatorsmerging as this seems to be a good step forward  further changes can always come in via another pull request || "";;;;1;1;""restrict identification of """"internal"""" operators to only the rxoperators package- based on discussion at  dont wrap at atomicobserver again- anything outside of rxoperators will be wrapped"";"
222;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;pull issue 43 merge;manual merge of https://github.com/netflix/rxjava/pull/196;;0;pull issue 43 merge;manual merge of https://githubcom/netflix/rxjava/pull/196;#73  this finished  ||;;;;1;1;merge branch issue43 of  into pull-issue-43-mergeconflicts:	rxjava-core/src/main/java/rx/observablejava;
224;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;rxjavaobservableexecutionhook;allow a plugin to intercept invocations of an observable via its subscribe method.  use cases: - extra logging or metrics for start  return and error events when subscribing - decorate (or replace) an  onsubscribe  function with additional behavior - decorate an exception - decorate a subscription  this is modeled after hystrix plugins:   javadocs will be at http://netflix.github.com/rxjava/javadoc/;;0;rxjavaobservableexecutionhook;allow a plugin to intercept invocations of an observable via its subscribe methoduse cases:- extra logging or metrics for start return and error events when subscribing- decorate (or replace) an onsubscribe function with additional behavior- decorate an exception- decorate a subscriptionthis is modeled after hystrix plugins:  will be at http://netflixgithubcom/rxjava/javadoc/;#76 ;;;;1;1;rxjavaobservableexecutionhookallow a plugin to intercept invocations of an observable via its subscribe methoduse cases: - extra logging or metrics for start return and error events when subscribing - decorate (or replace) an onsubscribe function with additional behavior - decorate an exception - decorate a subscriptionthis is modeled after hystrix plugins:  will be at http://netflixgithubcom/rxjava/javadoc/;
"225;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;schedulers (merge of pull #199);manual merge of  by @mairbek plus the following changes: - made some classes non-public so they don t become part of the published api (if we find they have value in the public api we can make them so but once published it s hard to remove them so i d rather keep them implementation details until then) - consolidated executorscheduler and scheduledexecutorscheduler - made executorscheduler use a system-wide scheduledexecutorscheduler for handling delayed events when only an executor is available - made the iothreadpool use a non-bounded cached thread-pool   next step from here is to review all operator implementations and add the scheduler overloads.;;199.0;schedulers (merge of pull #199);manual merge of  by @mairbek plus the following changes:- made some classes non-public so they dont become part of the published api (if we find they have value in the public api we can make them so but once published its hard to remove them so id rather keep them implementation details until then)- consolidated executorscheduler and scheduledexecutorscheduler- made executorscheduler use a system-wide scheduledexecutorscheduler for handling delayed events when only an executor is available- made the iothreadpool use a non-bounded cached thread-pool next step from here is to review all operator implementations and add the scheduler overloads;""#77  #78 the unit test is poorly written (non-deterministic) ill fix in the morning  || awesome work! - with this it should be easy to implement operators like """"sample"""" etc || yes it should open the gates to many operators we havent been able to pursue || committed a few tweaks and fixesopen questions for me are:- were not using the schedulernow value anywhere should we be? or is that only for the virtual scheduler used for testing?- not quite sure how the overloads should work on `merge` etc  ive implemented them but the behavior might not yet match c# || can someone with an rxnet environment setup implement a test similar to this from java and tell me the output?``` java@test    public void testmixedschedulers() throws interruptedexception {        final string mainthreadname  threadcurrentthread()getname()        observable<string> o  observable<string> create(new func1<observer<string> subscription>() {            @override            public subscription call(observer<string> observer) {                systemoutprintln(""""origin observable is running on: """" + threadcurrentthread()getname())                assertfalse(threadcurrentthread()getname()equals(mainthreadname))                asserttrue(""""actually: """" + threadcurrentthread()getname() threadcurrentthread()getname()startswith(""""rxiothreadpool""""))                observeronnext(""""one"""")                observeronnext(""""two"""")                observeronnext(""""three"""")                observeroncompleted()                return subscriptionsempty()            }        })subscribeon(schedulersthreadpoolforio()) // subscribe to the source on the io thread pool        // now merge on the cpu threadpool        o  observable<string> merge(o observable<string> from(""""four"""" """"five""""))                subscribeon(schedulersthreadpoolforcomputation())                map(new func1<string string>() {                    @override                    public string call(string v) {                        // opportunity to see what thread the merge is running on                        systemoutprintln(""""merge is running on: """" + threadcurrentthread()getname())                        return v                    }                })        final countdownlatch latch  new countdownlatch(1)        final atomicreference<runtimeexception> onerror  new atomicreference<runtimeexception>()        // subscribe on a new thread        osubscribe(new observer<string>() {            @override            public void oncompleted() {                systemoutprintln(""""> received oncompleted"""")                latchcountdown()            }            @override            public void onerror(exception e) {                systemoutprintln(""""> received onerror: """" + egetmessage())                onerrorset((runtimeexception) e)                latchcountdown()            }            @override            public void onnext(string v) {                systemoutprintln(""""> final subscribe is running on: """" + threadcurrentthread()getname())                systemoutprintln(""""> onnext: """" + v)            }        } schedulersnewthread())        // wait for the above to finish or blow up if its blocked        latchawait(5 timeunitseconds)    }```im trying to understand how a sequence should work when multiple `subscribeon` operators are applied at different steps of a sequenceof course rxnet doesnt have the io and cpu thread pools  those are just helper methods to executors which would be 2 separate threadpools for different work types so youll need to adjust that || #79 is there any reason to use `schedulerschedule` on an internal operator implementation instead of just leveraging `subscribeon` (other than when we need the delay arguments of course)?for example on a method overload of `merge` is this okay?``` java        return merge(source)subscribeon(scheduler)```or is there some reason to inside the `operationmerge` do this:``` java                return schedulerschedule(new func0<subscription>() {                    @override                    public subscription call() {                        return new mergeobservable<t>(o)call(observer)                    }                })```they seem to accomplish the same thing but would like to know if theres a reason to prefer one over the otheri prefer just reusing `subscribeon` i cant tell from reading c# code what it does as i cant find the extensions that implement the override methods! || im pulling the trigger and merging this into master so people can start playing with it and providing feedbackthe public api changes are fairly limited still so most changes (which i fully expect) will be implementation details || [rxjava-pull-requests #80 looks good || "";subscribeon/observeon implementation;implementation subscribeon #11 and observeon #12 alongside with basic schedulers implementation #19;#39 net implementation of a scheduler interface contains methods like``` c#schedule<tstate>(tstate func<ischeduler tstate idisposable>) ```to be honest i dont quite understand why it is designed to use `func<ischeduler tstate idisposable>` function as an action i used `func0<subscription>` in the implementation and it seems to fit well || #40 this is great stuff @mairbek thank you!this one is going to result in a lot of discussion so wont be pulled in right away and will likely involve some changesfor example a discussion is being kicked off with erik meijer (inventor of rx at microsoft) to clarify some design decisions on this || @sgudiboina if you can join in on the review of this it would be helpful@mairbek erik himself has stated on twitter that rxjava needs schedulers so this is definitely high priority!anyone else with time to get involved please do the design of schedulers will have long-lasting impact so we want to get it as close to right as possible now || anyone getting involved please review  for context || @mairbek this is great work thank you for the research and thought you obviously did for this and the clean and well-written codeive posted my questions and comments via the inline code mechanism so they are contextual  || #71 [rxjava-pull-requests #74]( failurelooks like theres a problem with this pull request || this request can no longer be automatically merged so i have manually merged it and done some further work on top of your commits at  review what ive done if possible id like to merge and release within the next 24 hoursim closing this request since all of your commits are now contained on  work @mairbek i appreciate you taking this on ||;1;0;removing scheduler overloads on operators (for now)i have some outstanding questions on how these should be implemented (or even why we need them when the subscribeon operator is far cleaner) so want to remove them for now so they dont make it into the public incorrectly;"
"228;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;interval;i have attempted to implement the  interval  operator (#55) here. as far as i can see  it seems to work. this is based on the quite fresh work on schedulers.  it doesn t work with the  currentthread  or  newthread  schedulers  i guess due to the simple  sleepingaction . it does work with a  scheduledexecutorservice   though.  for testing this conveniently  i also wrote a test scheduler with adjustable time.  looking forward to any review comments.;;55.0;interval;""i have attempted to implement the """"interval"""" operator (#55) here as far as i can see it seems to work this is based on the quite fresh work on schedulersit doesnt work with the `currentthread` or `newthread` schedulers i guess due to the simple `sleepingaction` it does work with a `scheduledexecutorservice` thoughfor testing this conveniently i also wrote a test scheduler with adjustable timelooking forward to any review comments"";#83 #84  lets consider adding new method to the `scheduler```` javascheduleperiodically(action0 action long initialdelay long period timeunit unit) ```it would allow to leverage `scheduledexecutorservice#scheduleatrate` for the `executorscheduler` for other schedulers we could use recursive action scheduling from pull request #229  || i agree `scheduleperiodically` would be helpful here || @jmhofer do you plan to work on this feature? im thinking about implementing buffer operator #16 and this one will be very helpful for me || ill have a look at it || maybe we should also combine all the longs and units into a timespan class? - it doesnt feel right to always have them as separate parameters || anyone know why net wouldnt have a `scheduleperiodically` concept? if we were to add that it would only really work with `scheduledexecutorservice` and thus most `scheduler` implementations would have to rely upon the generic `scheduledexecutorservice` that ive added in  called `genericscheduledexecutorservice`this suggests to me that it isnt the right solution to add another interface method as it seems very tied to a particular implementation cant this be achieved with recursive schedulers which now work after the changes you did in  || im curious about this:> it doesnt work with the currentthread or newthread schedulers i guess due to the simple sleepingaction it does work with a scheduledexecutorservice thoughit seems that this operator needs to be async and must default to using something like `schedulersthreadpoolforcomputation()`documentation at msdn ( suggests that this defaults to using a thread-pool scheduler:> the following example code uses the interval operator to generate a sequence of long integers staring at zero each integer in the sequence is generated after the two second period has expired each integer is written to the console window along with the current time to show the period parameter in effect the generation of the integer sequence is scheduled to run on a thread from the net thread pool so the main thread is not blocked and can process the enter key being pressed to stop the intervalperhaps `newthreadscheduler` will work as of  because it now uses `genericscheduledexecutorservice` when a delay is passed in instead of `sleepingaction`what happens in net if someone tries to use `immediatescheduler` or `currentthreadscheduler`? anyone have access to net to try that? || > maybe we should also combine all the longs and units into a timespan class? - it doesnt feel right to always have them as separate parametersif were going to consider doing this then we should do it as part of  before i release another version since this would change the `schedulers` interfacejava itself always keeps the 2 separate though so perhaps the idiomatic thing to do in java is to keep them separate? i dont have a strong opinion on this one but the decision made now will last a very long time || actually net does have `scheduleperiodic` see here:  its useful to avoid recursive scheduling where the schedulers support this directly as well as to do the slightly messy recursive scheduling ourselves for other types of schedulers so that the user doesnt have to || ah interesting thanks for educating me on that || this doesnt look like its been integrated into observable but im going to merge as it looks useful to get this in  the testscheduler especially while interval continues getting work done || great thanks (this still needs a bit of work if/when we do periodic scheduling) || are you okay with me releasing current code on the master branch and then the rest of `interval` coming later?is there anything else about master branch as it stands that should be changed before i release? id like to do so today || thats alright with me || @benjchristensen now the `interval` operators in rxjava and rxnet have different behaviors when the scheduler is `currentthread`in rxnet the following codes``` c#            var o  observableinterval(timespanfrommilliseconds(100) schedulercurrentthread)            otake(5)subscribe(                x > consolewriteline(x)            )            otake(4)subscribe(                x > consolewriteline(x)            )            consolereadline()```output```012340123```in rxjava the following codes``` java            observable<long> o   observableinterval(100 timeunitmilliseconds                    schedulerscurrentthread())            otake(5)subscribe(new action1<long>() {                @override                public void call(long t1) {                    systemoutprintln(t1)                }            })            otake(4)subscribe(new action1<long>() {                @override                public void call(long t1) {                    systemoutprintln(t1)                }            })```output```01234```and the current thread is blocked at the first `subscribe`is it ok or the `interval` operator should not be used with `currentthread`? ||;operator: interval;http://msdnmicrosoftcom/en-us/library/hh229027(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh228911(vvs103)aspx;""it seems like `interval` shares logic with the `timer` from issue #92`interval` could be implemented as a [`timer` call]( with `duetime  0` || sure as soon as timer is implemented or schedulers can do periodic scheduling the implementation of `interval` will get a lot simpler || is the `interval` operator intended to work if there are several subscribers? it looks as if this was simply forgotten || actually im not sure whether `interval` itself should or shouldnt support this - however you should always be able to use `publish`/`connect` if that doesnt work then theres definitely something wrong i can go check that later i probably didnt think of that when implementing it || i just tried it out in c# this code:```static void main() {    var onenumberpersecond  observableinterval(timespanfromseconds(1))take(5)    onenumberpersecondsubscribe(    x > consolewriteline(""""subscriber 1 got """" + x)    )    onenumberpersecondsubscribe(    x > consolewriteline(""""subscriber 2 got """" + x)    )    consolereadline()}```produces this output:```subscriber 2 got 0subscriber 1 got 0subscriber 2 got 1subscriber 1 got 1subscriber 2 got 2subscriber 1 got 2subscriber 2 got 3subscriber 1 got 3subscriber 2 got 4subscriber 1 got 4```so i think we should update the rxjava version to support multiple subscribers || compare to java code:```public static void main(string args) {    observable<long> onenumberpersecond  observableinterval(1 timeunitseconds)take(5)    onenumberpersecondsubscribe(new action1<long>() {        public void call(long x) {            systemoutprintln(""""subscriber 1 got """" + x)        }               })    onenumberpersecondsubscribe(new action1<long>() {        public void call(long x) {            systemoutprintln(""""subscriber 2 got """" + x)        }               })     }```output:```subscriber 1 got 0subscriber 2 got 1subscriber 1 got 2subscriber 2 got 3subscriber 1 got 4subscriber 2 got 5subscriber 1 got 6subscriber 2 got 7subscriber 1 got 8subscriber 2 got 9```i think this will be used a lot for small examples and so it should be  soon @benjchristensen could you please reopen this issue? || what does rxnet do when you wait a bit before subscribing the second time?will it do this?```subscriber 1 got 0subscriber 1 got 1subscriber 1 got 2subscriber 2 got 2subscriber 1 got 3subscriber 2 got 3subscriber 1 got 4subscriber 2 got 4```or will it still start at 0 with subscriber 2? || i added a first test for that use case here:  fails as expected from your comment above || the rx design guidelines (510) say:> as many observable sequences are cold (see cold vs hot on channel 9) each subscription will have a separate set of side-effects certain situations require that these side-effects occur only once the publish operator provides a mechanism to share subscriptions by broadcasting a single subscription to multiple subscribersso i guess it would be okay for the second subscriber to always start at 0 too when subscribing to the same observable later (and not using `publish`/`connect`)? || there are probably other operators that are affected by this too because multiple subscribers are currently normally not getting tested by the unit tests || heres another  example from c#:```    static void main() {        var onenumberpersecond  observableinterval(timespanfromseconds(1))take(5)        var watch  new stopwatch()        watchstart()        threadsleep(2200)        consolewriteline(""""subscriber 1 subscribes at t"""" + watchelapsedmilliseconds)        onenumberpersecondsubscribe(            x > consolewriteline(""""subscriber 1 got """" + x + """" at t"""" + watchelapsedmilliseconds)        )        threadsleep(1300)        consolewriteline(""""subscriber 2 subscribes at t"""" + watchelapsedmilliseconds)        onenumberpersecondsubscribe(            x > consolewriteline(""""subscriber 2 got """" + x + """" at t"""" + watchelapsedmilliseconds)        )        consolereadline()    }```outputs:```subscriber 1 subscribes at t2200subscriber 1 got 0 at t3322subscriber 2 subscribes at t3615subscriber 1 got 1 at t4319subscriber 2 got 0 at t4642subscriber 1 got 2 at t5329subscriber 2 got 1 at t5643subscriber 1 got 3 at t6331subscriber 2 got 2 at t6643subscriber 1 got 4 at t7344subscriber 2 got 3 at t7655subscriber 2 got 4 at t8656```so each subscriber starts at 0 || great thanks this means that my pr above should fix this || yes every new subscriber should start the observable from the beginning i have tried to make sure thats the case everywhere but apparently missed this oneif an observable does not want that behavior that is what the various `multicast` options are for such as `publish` `replay` `cache` etc || merged in  so closing again || "";1;0;oops the test scheduler has to go into the main sources;"
"229;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;trying to extend the scheduler interface according to the comments at;i ve tried to extend the  scheduler  interface according to the discussion at issue #19. if i understand this correctly  most of it can be done via the  abstractscheduler .  i hope this helps. please have a look.;;19.0;trying to extend the scheduler interface according to the comments at;ive tried to extend the `scheduler` interface according to the discussion at issue #19 if i understand this correctly most of it can be done via the `abstractscheduler`i hope this helps please have a look;""#85  awesome looks like it doesnt break a `scheduler` interface i thought about two examples``` java        final scheduler scheduler  schedulerscurrentthread()        observable<integer> obs  observablecreate(new func1<observer<integer> subscription>() {            @override            public subscription call(final observer<integer> observer) {                return schedulerschedule(0 new func2<scheduler integer subscription>() {                    @override                    public subscription call(scheduler scheduler integer i) {                        if (i > 42) {                            observeroncompleted()                            return subscriptionsempty()                        }                        observeronnext(i)                        return schedulerschedule(i + 1 this)                    }                })            }        })        obssubscribe(new observer<integer>() {            @override            public void oncompleted() {                systemoutprintln(""""completed"""")            }            @override            public void onerror(exception e) {                systemoutprintln(""""error"""")            }            @override            public void onnext(integer args) {                systemoutprintln(args)            }        })```and``` java        final scheduler scheduler  schedulersthreadpoolforcomputation()        observable<integer> obs  observablecreate(new func1<observer<integer> subscription>() {            @override            public subscription call(final observer<integer> observer) {                return schedulerschedule(new booleansubscription() new func2<scheduler booleansubscription subscription>() {                    @override                    public subscription call(scheduler scheduler booleansubscription cancel) {                        if (cancelisunsubscribed()) {                            observeroncompleted()                            return subscriptionsempty()                        }                        observeronnext(42)                        try {                            threadsleep(1000)                        } catch (interruptedexception e) {                            eprintstacktrace()                        }                        schedulerschedule(cancel this)                        return cancel                    }                })            }        })        subscription subscribe  obssubscribe(new observer<integer>() {            @override            public void oncompleted() {                systemoutprintln(""""completed"""")            }            @override            public void onerror(exception e) {                systemoutprintln(""""error"""")            }            @override            public void onnext(integer args) {                systemoutprintln(args)            }        })        threadsleep(10000)        subscribeunsubscribe()        systemoutprintln(""""unsubscribe"""")        threadsleep(10000)```and they worked well for me || im wondering if the `scheduler` interface really needs all of these overloads?rx has 3 primary methods (the rest are extension methods that look like they do transformations) the 2 key ones are:``` java<t> subscription schedule(t state func2<scheduler t subscription> action)<t> subscription schedule(t state func2<scheduler t subscription> action long duetime timeunit unit)```we dont have one with an explicit time to run only relative at this time || it appears the overloads all make sense  but again net is able to use extension methods to make the design much more elegant where only the main 3 are part of the interface and the rest come along for the rideit means we end up with a scheduler/abstractscheduler interface/abstract pairing to make this workshould we just make scheduler an abstract? im very tempted to do so because of the following problems:- adding methods to scheduler will be breaking changes requiring major version increments- people implementing schedulers will basically always have to also extend abstractscheduler or copy/paste all of those method overloadsor should be remove all but the main 3 methods from scheduler and put all the overloads as utility functions on the schedulers class instead?the precedent for using abstract (or concrete) classes instead of interfaces (which net then augments with extension methods) is already done - observable is a concrete class instead of interface for this very reasonall plugins  as abstracts instead of interfaces for this reason as wellthoughts? || while reviewing and playing with this i considered some changes id like to propose i have submitted another pull request ( that builds on top of your work @jmhofer and includes the unit tests from @mairbek i would appreciate your thoughts on it and whether they are beneficial changes or just pedantic || merged manually via  || "";rx schedulers;implementation of rx schedulers (  probably to go into the rxconcurrency package (https://githubcom/netflix/rxjava/tree/master/rxjava-core/src/main/java/rx/concurrency);""interesting quote from that page""""if you do not use the overload which takes a scheduler as an argument rx will pick a default scheduler by using the principle of least concurrency  this means that the scheduler which introduces the least amount of concurrency that satisfies the needs of the operator is chosen  for example for operators returning an observable with a finite and small number of messages rx calls immediate  for operators returning a potentially large or infinite number of messages currentthread is called for operators which use timers threadpool is used"""" || how would an operator know how many messages it is going to have? only the origin observable could know that - a given operator along the chain wont know so how does this get accomplished? || i guess this would mean that things like """"toobservable(1 2 3 4)"""" are a known thing and can be done immediately without a thread but merging 4 unknown sequences cant be knownobviously when timers are used a thread of some kind is needed (javautiltimer or another implementation like this:  the majority of cases though where the """"cost"""" of the observable sequence is unknown i dont know that i like automatically spawning them off on threads it has worked well for the netflix api to leave that choice to the origin of the observable (to be synchronous or asynchronous one thread or many etc)the introduction of schedulers makes perfect sense when an app is dealing with data structures their own synchronous io operations or cpu bound computations but it becomes awkward when consuming from a 3rd party api exposing observables who can and will make their own choice about being synchronous or asynchronousin fact thats been a huge part of the draw to rx is that the api doesnt need to change when the backend implementations moves between synchronous and asynchronous for whatever reason it may choose to do soif the observable is already asynchronous it would be inefficient to spin up another thread that in turn blocks on an async callother than documentation on the api calls that return observables is there a better way to handle that scenario?i can imagine a scenario where some apps (such as the netflix api) may want to disable any use of schedulers so the origin retains control since rx has allowed us to decouple the writing of business logic from the decisions of concurrencybefore flaming me  i do like schedulers its very powerful and we will definitely get them added i just have some questions about balancing that power (and inevitable inefficiencies of making poor scheduler choices) with the elegant simplicity of rx observables without them where concurrency is not a thought - everything is just asynchronousim interested in all of your perspectives so please chime in || the docs say """"least amount of concurrency"""" which i interpreted to mean that if the amount of work is unknown that it would it default to immediate  we could still manipulate the defaults and probably ignore schedulers passed in through a strategy || yes i think a strategy pattern will be needed to accomplish the netflix api use case || some thoughts while working on the design of this:- the scheduler interface should be capable of supporting different sources of concurrency such as executors threads actors eventloops- we should be capable of supporting rxjava-contrib modules with new types of schedulers such as for akka/scala actors- we need the ability (via plugins probably) of a system to override or prevent usage of schedulers where they want for example if a system doesnt want client code starting threads they should be able to intercept and ignore or throw unsupportedoperationexception || sections 69 through 612 of the rx design guidelines pdf ( should be read by anyone involved in schedulers design and implementation || theres also [this video]( explaining the motivation behind introducing schedulers in rx || good video  thanks for the link || first round of schedulers implementation committed via pull request  contribued by @mairbekit implements observeon ( and subscribeon ( || open questions:### 1) scheduler timewere not using the schedulernow value anywhere should we be? or is that only for the virtual scheduler used for testing?### 2) use of subscribeon vs schedulerschedulerim trying to understand how operator overloads should use schedulerhere is a potential implementation:  and another  have not yet found c# source code or documentation that clarifies thisi have also had feedback (that i agree with) that it this is clearer:``` javamerge(o1 o2)subscribeon(scheduler)```than this``` javamerge(o1 o2 scheduler)```so is there anything different between this? ### 3) multiple schedulers in sequenceim trying to understand how a sequence should work when multiple `subscribeon` operators are applied at different steps of a sequence and it is unclear to me  how the unit test below should behavecan someone with an rxnet environment setup implement a test similar to this from java and tell me the output?``` java@test    public void testmixedschedulers() throws interruptedexception {        final string mainthreadname  threadcurrentthread()getname()        observable<string> o  observable<string> create(new func1<observer<string> subscription>() {            @override            public subscription call(observer<string> observer) {                systemoutprintln(""""origin observable is running on: """" + threadcurrentthread()getname())                assertfalse(threadcurrentthread()getname()equals(mainthreadname))                asserttrue(""""actually: """" + threadcurrentthread()getname() threadcurrentthread()getname()startswith(""""rxiothreadpool""""))                observeronnext(""""one"""")                observeronnext(""""two"""")                observeronnext(""""three"""")                observeroncompleted()                return subscriptionsempty()            }        })subscribeon(schedulersthreadpoolforio()) // subscribe to the source on the io thread pool        // now merge on the cpu threadpool        o  observable<string> merge(o observable<string> from(""""four"""" """"five""""))                subscribeon(schedulersthreadpoolforcomputation())                map(new func1<string string>() {                    @override                    public string call(string v) {                        // opportunity to see what thread the merge is running on                        systemoutprintln(""""merge is running on: """" + threadcurrentthread()getname())                        return v                    }                })        final countdownlatch latch  new countdownlatch(1)        final atomicreference<runtimeexception> onerror  new atomicreference<runtimeexception>()        // subscribe on a new thread        osubscribe(new observer<string>() {            @override            public void oncompleted() {                systemoutprintln(""""> received oncompleted"""")                latchcountdown()            }            @override            public void onerror(exception e) {                systemoutprintln(""""> received onerror: """" + egetmessage())                onerrorset((runtimeexception) e)                latchcountdown()            }            @override            public void onnext(string v) {                systemoutprintln(""""> final subscribe is running on: """" + threadcurrentthread()getname())                systemoutprintln(""""> onnext: """" + v)            }        } schedulersnewthread())        // wait for the above to finish or blow up if its blocked        latchawait(5 timeunitseconds)    }```of course rxnet doesnt have the io and cpu thread pools  those are just helper methods to executors which would be 2 separate threadpools for different work types so youll need to adjust that || concerning 1) i guess it will come in handy when implementing #90 (or clock-like observables in general) at least if i understand this correctly im currently figuring out how working with the schedulers feels by playing around with an implementation for #74 which also requires a """"clock"""" though it doesnt seem to require the current time) || i received the following feedback that will require a breaking change to the scheduler interface:---> it is essential to be able to access the scheduler inside the action to recursively schedule yourself just having a func1<subscription is not very useful since there is no opportunity to return the subscription before the function terminates``` c#interface ischeduler{schedule<tstate>(tstate s func<ischeduler tstate idisposable> a)                         schedule<tstate>(tstate s datetimeoffset d func<ischeduler tstate idisposable> a)               schedule<tstate>(tstate s timespan t func<ischeduler tstate idisposable> a)}```> you want to be able to write something like this``` c#void main(){     var repeat  observablecreate<int>(observer >     {         while(true) observeronnext(42)         return () > {}     })     //var dispose  repeatsubscribe(consolewriteline)     var dispose  observableextoobservable(newthreadschedulerdefault)                  select(_ > 42)                  subscribe(x > consolewriteline(x))     consolereadline()     disposedispose()     consolewriteline(""""bye"""")}static class observableex{     public static iobservable<unit> toobservable(this ischeduler scheduler)     {    return observablecreate<unit>(observer >         {              return schedulerscheduleasync(async (_scheduler token) >              {                  while(!tokeniscancellationrequested)                  {                     observeronnext(unitdefault)                       await _schedulersleep(timespanfromseconds(2))                   }              })         })     }}``` || here is another use case:``` c#var scheduler  taskpoolschedulerdefaultvar xs  observablegenerate     ( 0      i>true      i>i+1      i>i      i>timespanfromseconds(1)      scheduler     )var ys  observablecreate<int>(observer >{     return schedulerscheduleasync(async (_scheduler cancel) >     {         await _scheduleryield()         for(var i  0 !canceliscancellationrequested i++)         {              observeronnext(i)              await _schedulersleep(timespanfromseconds(1))         }     })})//var dispose  ystimestamp()subscribe(x > consolewriteline(xtostring()))var dispose  ystimestamp()dumplive()subscribe()consolereadline()disposedispose()consolewriteline(""""disposed"""")consolereadline()``` || note that im unavailable to work on this until the 15th anyone else who wants to jump in and determine the changes needed based on this feedback please do  || here is some simple code i was playing with to prove out the use of `subscribeon` from an """"observable api"""" and it appears to be working as we want and from what i can tell it is conforming to the rx contract and not injecting concurrency where it shouldntanyone find faults in this?``` groovyimport rx*import rxconcurrencyschedulers/* * ******** producer code ********  * this is the """"observable api"""" */observable<video> getvideos() {    return observablecreate({        observer ->        threadsleep(200) // simulate network traffic        // 10 videos are fetched in a batch and emitted        observeronnext(new video(1))        observeronnext(new video(2))        observeronnext(new video(3))        observeronnext(new video(4))        observeronnext(new video(5))        observeronnext(new video(6))        observeronnext(new video(7))        observeronnext(new video(8))        observeronnext(new video(9))        observeronnext(new video(10))        observeroncompleted()    })}class video {    final int id    public video(int id) {        thisid  id    }    observable<rating> getrating() {        return observablecreate({            observer ->            threadsleep(200) // simulate network traffic            observeronnext(new rating(id))            observeroncompleted()        })subscribeon(schedulersthreadpoolforio())    }    observable<bookmark> getbookmark() {        return observablecreate({            observer ->            threadsleep(200) // simulate network traffic            observeronnext(new bookmark(id))            observeroncompleted()        })subscribeon(schedulersnewthread())    }}class rating {    final string value    public rating(int id) {        thisvalue  """"ratingfor_"""" + id    }}class bookmark {    final string value    public bookmark(int id) {        thisvalue  """"bookmarkfor_"""" + id    }}/* * ******** consumer code ******** * this is a client consuming the """"observable api"""" */long start  systemcurrenttimemillis()getvideos()mapmany({    video video ->    // fetch and transform bookmark    observable ob  videogetbookmark()map({b ->         return """"transformed-"""" + bvalue    })    // fetch ratings and zip together with bookmark    return observablezip(ob videogetrating() {b r -> return [bvalue rvalue]})    map({ tuple ->        // combine all metadata for a single video        return [""""id"""" : videoid """"bookmark"""" : tuple[0] """"rating"""": tuple[1]]    })})foreach({    videomap ->    systemoutprintln(""""video: """" + videomap[""""id""""] + """"   bookmark: """" + videomap[""""bookmark""""] + """"   rating: """" + videomap[""""rating""""] + """" thread: """" + threadcurrentthread())})long end  systemcurrenttimemillis()systemoutprintln(""""time: """" + (end-start))```output is:```video: 5   bookmark: transformed-bookmarkfor_5   rating: ratingfor_5 thread: thread[rxiothreadpool-55main]video: 9   bookmark: transformed-bookmarkfor_9   rating: ratingfor_9 thread: thread[rxiothreadpool-95main]video: 10   bookmark: transformed-bookmarkfor_10   rating: ratingfor_10 thread: thread[rxiothreadpool-105main]video: 2   bookmark: transformed-bookmarkfor_2   rating: ratingfor_2 thread: thread[rxiothreadpool-25main]video: 4   bookmark: transformed-bookmarkfor_4   rating: ratingfor_4 thread: thread[rxiothreadpool-45main]video: 8   bookmark: transformed-bookmarkfor_8   rating: ratingfor_8 thread: thread[rxiothreadpool-85main]video: 6   bookmark: transformed-bookmarkfor_6   rating: ratingfor_6 thread: thread[rxiothreadpool-65main]video: 3   bookmark: transformed-bookmarkfor_3   rating: ratingfor_3 thread: thread[rxiothreadpool-35main]video: 7   bookmark: transformed-bookmarkfor_7   rating: ratingfor_7 thread: thread[rxiothreadpool-75main]video: 1   bookmark: transformed-bookmarkfor_1   rating: ratingfor_1 thread: thread[rxiothreadpool-15main]time: 659``` || @benjchristensen im left wondering if or how question 3) from your comment ( was addressed or whether this is still an open question?in our app we havent quite figured out yet which layer should be responsible for scheduling an observable if we schedule on the service layer--which would make sense when trying to make client code oblivious as to whether code runs concurrently or not--then what does that mean for reusability of observables? would say service a be able to take an observable from service b which has already been scheduled by b transform and re-schedule it?with the pre-08 schedulers this is not possible since subscribeon/observeon will wrap as many times as you call these methods || i think the javadocs havent been updated yet:  there any documentation / examples around what the state parameter is used for? looking at the existing schedulers i only ever see it being passed through so i wonder what this accomplishes? || heres an example (by @mairbek) using state:  || i forgot to upload the new javadocs  will do so once im at my laptop sorry about that  || @mttkay i found wifi  uploaded javadocs for 080also the example from @mairbek was incorporated into unit tests here:  || i believe were pretty comfortable with the `schedulers` implementation and interface as of 011/012 so closing this out || "";1;0;trying to extend the scheduler interface according to the comments at#19;"
232;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;corrected naming;renamed  operator  to  operation  to be consistent.;;0;corrected naming;renamed `operator` to `operation` to be consistent;#89 ;;;;1;1;corrected naming operator -> operation;
235;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;schedulers interface (merging and adding to pull request 229);merging and adding to pull request  from @jmhofer which adds functionality discussed in the scheduler issue   work done in  added the following methods to  scheduler : -  subscription schedule(t state  func2<scheduler  t  subscription> action  long delaytime  timeunit unit)  -  subscription schedule(t state  func2<scheduler  t  subscription> action)   these are in fact the primary methods from rxnet ( and the others are just helper overloads.  it seems beneficial to use these 2 methods for actual implementation logic while all other methods are just decorating and forwarding from abstractscheduler to these methods.  i propose these changes on top of pull request  to achieve this.  i also added unit tests that @mairbek created (  all unit tests are passing  but we don t yet have enough unit test coverage so i won t be surprised if bugs are found.;;0;schedulers interface (merging and adding to pull request 229);merging and adding to pull request  from @jmhofer which adds functionality discussed in the scheduler issue  done in  added the following methods to `scheduler`:- `subscription schedule(t state func2<scheduler t subscription> action long delaytime timeunit unit)`- `subscription schedule(t state func2<scheduler t subscription> action)`these are in fact the primary methods from rxnet ( and the others are just helper overloadsit seems beneficial to use these 2 methods for actual implementation logic while all other methods are just decorating and forwarding from abstractscheduler to these methodsi propose these changes on top of pull request  to achieve thisi also added unit tests that @mairbek created ( unit tests are passing  but we dont yet have enough unit test coverage so i wont be surprised if bugs are found;#94  @jmhofer @mairbek (and any others of course) i have added various inline comments and questions about the scheduler code and would appreciate your thoughts (even if its stating agreement but especially if you disagree) to determine if our approaches to these various things are correctthank you both for your involvement in this so far and continuing to do so! || @mairbek and @jmhofer i think this pull request is ready to merge though im not yet ready to release id like to leave some more time to review consider and fix thingsagree? disagree? || #96 +1 from me to merging but not releasing yet ||;;;;1;1;implement scheduler method with duetime- added method: schedule(t state func2<scheduler t subscription> action date duetime);
236;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fixed sleeping action;sleeping action wasn t working correctly.;;0; sleeping action;sleeping action wasnt working correctly;#95  #98;;;;1;1;merge branch master into sleepingfixconflicts:	rxjava-core/src/main/java/rx/concurrency/sleepingactionjava;
240;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;update testscheduler to match merged scheduler changes;- i accidentally merged this code before fixing it to match the changes to abstractscheduler/scheduler;;0;update testscheduler to match merged scheduler changes;- i accidentally merged this code before fixing it to match the changes to abstractscheduler/scheduler;#101 ;;;;1;1;update testscheduler to match merged scheduler changes- i accidentally merged this code before fixing it to match the changes to abstractscheduler/scheduler;
241;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;replaysubject - manual merge of pull 218;manual merge of replaysubject from pull request  - merged defaultsubject and publishedsubject which were the same thing (lots more unit tests though from this pull request) - still not sure what the right name is for defaultsubject/publishsubject - renamed repeatsubject to replaysubject to match .net - tweaked unit tests with inorder while reviewing them to understand behavior - moved unsubscribetester into a package private class as i m still undecided on long-term placement of this and the operatortester class;;0;replaysubject - manual merge of pull 218;manual merge of replaysubject from pull request  merged defaultsubject and publishedsubject which were the same thing (lots more unit tests though from this pull request)- still not sure what the right name is for defaultsubject/publishsubject- renamed repeatsubject to replaysubject to match net- tweaked unit tests with inorder while reviewing them to understand behavior- moved unsubscribetester into a package private class as im still undecided on long-term placement of this and the operatortester class;i have some open questions but want to get this merged so we can unblock progress in this area of subjects || #102 ;;;;1;1;merge branch replay of git://githubcom/johngmyers/rxjava into pull-218-merge-replayconflicts:	rxjava-core/src/main/java/rx/operators/operationtakejava	rxjava-core/src/main/java/rx/operators/operationtakewhilejava	rxjava-core/src/main/java/rx/subjects/subjectjava- moved unsubscribetester into a package private class as im still undecided on long-term placement of this and the operatortester class- merged defaultsubject and publishedsubject which were the same thing (lots more unit tests though from this pull request)- still not sure what the right name is for defaultsubject/publishsubject- renamed repeatsubject to replaysubject to match net- tweaked unit tests with inorder while reviewing them to understand behavior;
244;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;pre 0.8.0 release changes;some cleanup before releasing.;;0;pre 080 release changes;some cleanup before releasing;this fixes  || @johngmyers @mairbek and @jmhofer is there anything else needing to be done before i release 080?id like to release it today so that the new schedulers behavior is useable || #103  i know of no release blockers || go ahead my other branches still need work anyway || ill proceed with the release thanks for the feedback @johngmyers and @jmhofer  ||;;;;1;1;rename from operator* to operation* to match convention;
246;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;scheduling actions periodically;as proposed earlier by @mairbek in   i extended the  scheduler  by yet another method  scheduleperiodically . this has a default implementation that works via recursion. i tried it out with all existing schedulers  and it seems to work fine. i also wrote a unit test for it using the  testscheduler .  i switched scheduled executor services to use their fixed rate scheduling instead of the recursive default implementation. and i also switched the  operationinterval  implementation to use periodic scheduling.;;0;scheduling actions periodically;as proposed earlier by @mairbek in  i extended the `scheduler` by yet another method `scheduleperiodically` this has a default implementation that works via recursion i tried it out with all existing schedulers and it seems to work fine i also wrote a unit test for it using the `testscheduler`i switched scheduled executor services to use their  rate scheduling instead of the recursive default implementation and i also switched the `operationinterval` implementation to use periodic scheduling;#106  from what i can tell this looks functionally correct and like a valid addition (based on previous discussions in #228) so im mergingthank you @jmhofer this is a nice addition and good quality code ||;;;;1;1;removed unused imports;
247;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add flatmap alias to mapmany;this is to match with what java 8 is adding to stream so we support the duality of iterable/collection to observable.  http://download.java.net/lambda/b86/docs/api/java/util/stream/stream.html#flatmap(java.util.function.function);;0;add flatmap alias to mapmany;this is to match with what java 8 is adding to stream so we support the duality of iterable/collection to observablehttp://downloadjavanet/lambda/b86/docs/api/java/util/stream/streamhtml#flatmap(javautilfunctionfunction);#107 ;;;;1;1;add flatmap alias to mapmanythis is to match with what java 8 is adding to stream so we support the duality of iterable/collection to observablehttp://downloadjavanet/lambda/b86/docs/api/java/util/stream/streamhtml#flatmap(javautilfunctionfunction);
248;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented sample operation;now that  operationinterval  is in   operationsample  (see  #74) was kind of straightforward. i also added a unit test against sampling  and allowed for specifying a scheduler used by the sample operation.;;74.0;implemented sample operation;now that `operationinterval` is in `operationsample` (see  #74) was kind of straightforward i also added a unit test against sampling and allowed for specifying a scheduler used by the sample operation;#108  we want methods on `observable` dont we? || sure i just completely forgot about that ill add them || #113;operator: sample;http://msdnmicrosoftcom/en-us/library/hh211615(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211892(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229742(vvs103)aspx;still have one overload to do:``` c#public static iobservable<tsource> sample<tsource tsample>(    this iobservable<tsource> source    iobservable<tsample> sampler)``` || i can take this || done ||;1;0;added sample methods to observable;
249;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;timestamp operation;straightforward implementation of issue #93  based on  operationmap  (without the scheduler version  as  map  doesn t take a scheduler yet either).;;93.0;timestamp operation;straightforward implementation of issue #93 based on `operationmap` (without the scheduler version as `map` doesnt take a scheduler yet either);#109 the failing test has nothing to do with my changes - i guess its a sporadic test problem as theres not much difference between 10 and 30 milliseconds || this should also be added to `observable` shouldnt it? || #112 my eclipse configuration also automatically added a lot of `@override` annotations i hope you dont mind otherwise i can remove them again of course || the @override annotations are fine - they are standard java they may be missing in some places because this project started with java 5 compliance and it had the annotations in less places than java 6  ||;operator: timestamp;http://msdnmicrosoftcom/en-us/library/hh211605(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229003(vvs103)aspx;the scheduler overload has not done yet || can i take this? || done ||;1;0;merged with master from netflix repo;
250;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;initial implementation of asyncsubject;i ve done some work on asyncsubject<t>  including unit tests and i m looking for feedback.   i don t expect to get this pull request immediately accepted. but i hope to find out if this is the correct workflow for this repository  and if the code is up to your standards  before i start pouring in more hours into issue #17. if you guys are ok with the asyncsubject<t> implementation i ll start working on the others.  looking forward to some feedback!;;17.0;initial implementation of asyncsubject;ive done some work on asyncsubject<t> including unit tests and im looking for feedback i dont expect to get this pull request immediately accepted but i hope to find out if this is the correct workflow for this repository and if the code is up to your standards before i start pouring in more hours into issue #17 if you guys are ok with the asyncsubject<t> implementation ill start working on the otherslooking forward to some feedback!;#110  hi @michaeldejong thanks for getting involved!based on my reading of the msdn docs for `asyncsubject` and your code this looks goodthank for you following the coding style of the project and making sure the copyright unit tests etc are all in placemerging now  ||;subject implementations; issue is intended to cover the implementation of various subjects as part of rxnet intended for placement in rxsubjects;the replaysubject was implemented in  || hey i noticed this issue is still open did i forget to implement a subject? || looks like they are now all done thank you @michaeldejong  ||;1;0;initial implementation of asyncsubject;
252;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;observable.tofuture;;;0;observabletofuture;;#111 ;;;;1;1;observabletofuture;
256;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;created the initial implementation of behaviorsubject;i ve been trying to implement the behaviorsubject. functionally it works as it should  but i m not entirely happy with the static  createwithdefaultvalue(t)  method. i can t create a static method  create(t)  because subject extends observable  which has a static  create(object)  method. so to resolve that i had to give the static method in behaviorsubject a different name.  additionally i m using an  atomicreference<t>  in this static method to keep track of the last published value. i tried coming up with different solutions to push the last published value to the observer when it s subscribing  but this seems to be the most clean solution.  if there s any feedback on either issue  please let me know.;;0;created the initial implementation of behaviorsubject;ive been trying to implement the behaviorsubject functionally it works as it should but im not entirely happy with the static `createwithdefaultvalue(t)` method i cant create a static method `create(t)` because subject extends observable which has a static `create(object)` method so to resolve that i had to give the static method in behaviorsubject a different nameadditionally im using an `atomicreference<t>` in this static method to keep track of the last published value i tried coming up with different solutions to push the last published value to the observer when its subscribing but this seems to be the most clean solutionif theres any feedback on either issue please let me know;#119  i agree its obnoxious that the `create` method cant be used but i cant see a way around it when its also an `observable`if anyone else has other ideas on how to deal with this please suggest them otherwise i think the `createwithdefaultvalue(t)` name is fine || #127;;;;1;1;improved documentation of the behavioursubject;
257;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;improved scan  reduce  aggregate;scan  is currently restricted to accumulators of type  func2<t  t  t>  where  func2<r  t  r>  would be possible for initial values of type  r . this pull request tries to fix this by generalizing the  scan  implementation. i had to restructure the scan operator a bit for this to stay typesafe. imho it s more readable now  though.  this indirectly leads to generalized  reduce   too.  also   aggregate  is added as an alias for  reduce  (see #20).;;20.0;improved scan reduce aggregate;`scan` is currently restricted to accumulators of type `func2<t t t>` where `func2<r t r>` would be possible for initial values of type `r` this pull request tries to fix this by generalizing the `scan` implementation i had to restructure the scan operator a bit for this to stay typesafe imho its more readable now thoughthis indirectly leads to generalized `reduce` tooalso `aggregate` is added as an alias for `reduce` (see #20);#120  #121 #122 thank you for working on this  - `observable` had not had any changes done to it to expose the new `reduce` or `scan` methods so that should probably be added to this pull request- what names should we use on the public api?rxnet never used `reduce` it uses `aggregate` others call it fold accumulate etc (more here  8 is using the `reduce` and `collector` names ( what names should we use and what aliases if any should we include in `observable`? || about `observable` - hmm seems that the changes got lost somehow ill go dig them out againand about the names to use: imho rxjava should have the java 8 names as well as the orginial rxnet names || agreed with your opinion on naming can you add those when you update the observable and make sure the javadocs of the methods are clear in linking to each other when they are aliases of each other? || ive had a look at the java 8 stream operations to me it looks like theres no explicit `scan` equivalent in java 8 or am i missing something?`collect` seems to be specifically made for mutable operations i dont see where we would use thatso i would just alias `reduce` with `aggregate` and `scan` stays unaliased if thats okay  || that works for me we can always add more aliases if java 8 adds a `scan` equivalent || i plan on doing a release tomorrow (about 12 hours from now) if you want to try and have this ready for that || [rxjava-pull-requests #131 looks good || as soon as this is in my `swing` branch becomes finally ready for a merge it offers a few simple observables created from button click keyboard and mouse events looking forward to this :) ||;operator: aggregate;add aggregate (or alias to reduce?)http://msdnmicrosoftcom/en-us/library/hh229154(vvs103)aspx;done in pull request #257  ||;1;0; method signatures and respective javadocs of various aggregate/reduce/scan overloads;
263;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;publish  replay and cache operators;(redo of  after merging)  added basic publish ( and replay ( operators to observable. i have not done any of the overloads (particularly  replay  which has 10+ in .net.  i also added a new  cache  operator as discussed by @johngmyers and i at   playing with  replay  and  connectableobservable  it does not cater well to the typical use case of needing to just de-dupe calls (cache the responses) so this  cache  operator can be thought of as an automatic version of  replay . it comes with the same risk as  tolist  if used with infinite or very large sequences as you can not unsubscribe from it.;;0;publish replay and cache operators;(redo of  after merging)added basic publish ( and replay ( operators to observable i have not done any of the overloads (particularly `replay` which has 10+ in neti also added a new `cache` operator as discussed by @johngmyers and i at  with `replay` and `connectableobservable` it does not cater well to the typical use case of needing to just de-dupe calls (cache the responses) so this `cache` operator can be thought of as an automatic version of `replay` it comes with the same risk as `tolist` if used with infinite or very large sequences as you can not unsubscribe from it;#134 hii noticed that calling observablereplay() doesnt merely wrap the given observable into a replaysubject but also combines this with operationmulticasti have several questions around this1) why do this? arent multicasting and caching/replaying both independent concepts in their own right?2) when combined it raises questions about how to deal with the (different) subscription instances returned from replay()subscribe and replay()connect unfortunately there are no samples or unit/integration tests (that im aware of) which actually combine both operators so looking at the tests didnt help more precisely:connectableobservable obs  sourceobservablereplay()subscription s1  obssubscribe(observer)subscription s2  obsconnect()s1 and s2 are entirely different subscriptions looking at the sources s1 is a repeatsubjectsubscription which is put in an internal map and removed upon unsubscription s1 however is an anonymous inner class instance in operationmulticast which delegates to the subscription the sourceobservable would return normallynow to which one do i hold on and unsubscribe from when i want to go through a disconnect/reconnect cycle? i actually tried a few combinations and none worked for me i either ended up triggering the sourceobservable twice upon reconnection (which i dont want) or i end up not getting previous emissions replayed on my observerany insight around this would be great || have you read this? >   it helped me understand it quite a bit here is a snippet from it:> fortunately we have replay() for this it literally has 15 overloads which cover just about every permutation of windowing by count and/or time and supplying an optional scheduler and/or selector the parameterless call however just remembers everything replay is just like publish in the sense that it also forwards a call to multicast but this time with a replaysubject<t>the reason `multicast` is involved is because it gives a `connectedobservable` associated with a `subject` it supports multiple subscriptions to a single observable which is exactly what `replay` and `publish` both wantanything with `connectedobservable` has the underlying source managed by the `connectedobservable` itself thus in your example it would be `s2` which you then unsubscribe from when you want to shut down the sourceif you just want simple caching behavior then the `cache` operator may help since it does not require the `connectedobservable` interaction the `connectedobservable` behavior is important for use cases when the start/stop of the underlying sequence needs to be controlled independently of when child subscriptions subscribe/unsubscribe the `refcount` operator is another example (we havent yet implemented this one) of controlling this situation i have found `cache` to be exactly what i need for most use cases (though we need to add overloads for time count limits etc) as i just want everything replayed as long as the reference is not garbage collected - but that is not how `connectedobservable` behaveshope this helps || thanks @benjchristensen as always this was very helpful i think what got me confused was the terminology the fact that both replay() and cache() are implemented in terms of `replaysubject` is a little confusing at first (the name replay() clearly implies that items will be re-emitted while cache() doesnt make that clear) the former wraps the `replaysubject` in a `connectableobservable` using `operationmulticast` while the latter simply forwards the subscription to `replaysubject`(re)reading the article you posted (i did read it before but that was before replaysubject had been released so it had slipped off my mind) and looking at the implementation would you say this summary is correct:- `replay`: creates a connectable event stream where upon _reconnection_ events that had been in flight during the period of disconnection will be replayed onto the observer- `cache`: creates an event stream where upon _subscription_ events will be replayed onto the observer- `publish`: creates a connectable event stream where upon reconnection new events will be received by the observer but events that were in flight during the period of disconnection will not be replayed || sorry i lost this question in my backlog yes those summaries make sense to me the `cache` one could be expanded further though:> creates an event stream where upon subscription all previously emitted events will be replayed onto the observer and future events if not completed || ;;;;1;1;remove debug statements from unit tests;
264;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;merge behaviorsubject from pull 256;manual merge of    additionally removes synchronizedobserver usage from subject implementations. - we don t need to add synchronization as the subjects can trust their source observables to comply with the rx contract. - this optimization follows rx design guidelines 6.8. avoid serializing operators  this was discussed at https://github.com/netflix/rxjava/pull/256;;0;merge behaviorsubject from pull 256;manual merge of  additionally removes synchronizedobserver usage from subject implementations- we dont need to add synchronization as the subjects can trust their source observables to comply with the rx contract- this optimization follows rx design guidelines 68 avoid serializing operatorsthis was discussed at https://githubcom/netflix/rxjava/pull/256;;;;;1;1;removing synchronizedobserver usage from subject implementations- we dont need to add synchronization as the subjects can trust their source observables to comply with the rx contract- this optimization follows rx design guidelines 68 avoid serializing operatorsthis was discussed at https://githubcom/netflix/rxjava/pull/256;
275;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;move foreach to blockingobservable;- was missed in previous refactoring;;0;move foreach to blockingobservable;- was missed in previous refactoring;#150 ;;;;1;1;move foreach to blockingobservable- was missed in previous refactoring;
279;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;adding marble diagrams;several new marble diagrams for previously undiagrammed methods;;0;adding marble diagrams;several new marble diagrams for previously undiagrammed methods;awesome thanks david! || #151 ;;;;1;1;adding several marble diagramsseveral new marble diagrams for previously undiagrammed methods;
280;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;diagrams and some new javadoc content for observable subclasses;some marble or marblish diagrams and a bit of new documentation for the blockingobservable and connectableobservable subclasses.;;0;diagrams and some new javadoc content for observable subclasses;some marble or marblish diagrams and a bit of new documentation for theblockingobservable and connectableobservable subclasses;#152 ;;;;1;1;diagrams and some new docs for observable subclassessome marble or marblish diagrams and a bit of new documentation for theblockingobservable and connectableobservable subclasses;
281;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operation: buffer;the buffer operation is an operation which allows you to buffer incoming events into one or more buffers. depending on their purpose  these buffers can be emitted to an  observer  when needed. in essence this means that events are collected and propagated to the  observer  in batches. the [original issue](  which this pull request addresses  mentions a total of 10 variations on this operator. this pull request contains code which supports all of them.  ![buffer](  the 10 variations which exist in rx .net  can be subdivided into two categories: single and multi buffers. with single buffers  only one buffer at any time is actively collecting incoming events  whereas with multi buffers  multiple buffers are actively collecting incoming events. in the first case the  observer  will receive every original event only once in one buffer  whereas in the latter case  the  observer  will receive every original event zero or more times. ### single buffers ##### buffer(bufferclosingselector)  the bufferclosingselector parameter is a  func0<observable<bufferclosing>> . it uses to  func0  object to construct an  observable  which produces a  bufferclosing  object. once this object has been produced by the  observable  the currently active buffer will be closed and emitted to the  observer . at the same time a new buffer will be created which will start recording incoming events.  ##### buffer(count)  this operator closes and emits the current buffer after counting a certain amount of received events. at the same time it will create a new buffer which will start recording incoming events. one example would be  buffer(2)   which with the following input:  [0  1  2  3  4  5]  will output the following buffers:  [0  1]  [2  3]  [4  5] . ##### buffer(timespan)  this operator closes and emits the current buffer after a certain amount of time has elapsed. at the same time it will create a new buffer which will start recording incoming events. ##### buffer(timespan  scheduler)  same as previous operator  but now with a custom scheduler. ##### buffer(timespan  count)  this operator closes and emits the current buffer after counting a certain amount of received events or after a certain amount of time has elapsed. at the same time it will create a new buffer which will start recording incoming events. ##### buffer(timespan  count  scheduler)  same as previous operator  but now with a custom scheduler. ### multiple buffers ##### buffer(count  skip)  this operator will create a new buffer after it has received  skip  amount of events. each buffer will be closed once it has reached a capacity of  [count . one example would be  buffer(3  1)   which with the following input:  0  1  2  3  4  5]   will output the following buffers:  [0  1  2]  [1  2  3]  [2  3  4]  [3  4  5] . ##### buffer(bufferopenings  bufferclosingselector)  this operator takes two parameters: an  observable<bufferopening>  and a  func1<bufferopening  observable<bufferclosing>> . the first parameter determines when buffers are created. the second parameter determines when the buffers are closed. every time a  bufferopening  object is received from the  observable  a new buffer is created. the received  bufferopening  object is fed into the second parameter which yields an  observable<bufferclosing>  object. when this  observable  produces a  bufferclosing  object  the associated buffer is closed and emitted. ##### buffer(timespan  timeshift)  this operator is very similar to  buffer(count  skip)   but in stead of counting events  it s based on time. the  timeshift  period defines how often a new buffer will be created. the  timespan  period defines the period between buffer construction and buffer emission. ##### buffer(timespan  timeshift  scheduler)  same as previous operator  but now with a custom scheduler.  as always  **feedback is welcome!**;;0;operation: buffer;the buffer operation is an operation which allows you to buffer incoming events into one or more buffers depending on their purpose these buffers can be emitted to an `observer` when needed in essence this means that events are collected and propagated to the `observer` in batches the [original issue]( which this pull request addresses mentions a total of 10 variations on this operator this pull request contains code which supports all of them![buffer]( 10 variations which exist in rx net can be subdivided into two categories: single and multi buffers with single buffers only one buffer at any time is actively collecting incoming events whereas with multi buffers multiple buffers are actively collecting incoming events in the first case the `observer` will receive every original event only once in one buffer whereas in the latter case the `observer` will receive every original event zero or more times### single buffers##### buffer(bufferclosingselector)the bufferclosingselector parameter is a `func0<observable<bufferclosing>>` it uses to `func0` object to construct an `observable` which produces a `bufferclosing` object once this object has been produced by the `observable` the currently active buffer will be closed and emitted to the `observer` at the same time a new buffer will be created which will start recording incoming events ##### buffer(count)this operator closes and emits the current buffer after counting a certain amount of received events at the same time it will create a new buffer which will start recording incoming events one example would be `buffer(2)` which with the following input: `[0 1 2 3 4 5]` will output the following buffers: `[0 1] [2 3] [4 5]`##### buffer(timespan)this operator closes and emits the current buffer after a certain amount of time has elapsed at the same time it will create a new buffer which will start recording incoming events##### buffer(timespan scheduler)same as previous operator but now with a custom scheduler##### buffer(timespan count)this operator closes and emits the current buffer after counting a certain amount of received events or after a certain amount of time has elapsed at the same time it will create a new buffer which will start recording incoming events##### buffer(timespan count scheduler)same as previous operator but now with a custom scheduler### multiple buffers##### buffer(count skip)this operator will create a new buffer after it has received skip amount of events each buffer will be closed once it has reached a capacity of [count one example would be `buffer(3 1)` which with the following input: `0 1 2 3 4 5]` will output the following buffers: `[0 1 2] [1 2 3] [2 3 4] [3 4 5]`##### buffer(bufferopenings bufferclosingselector)this operator takes two parameters: an `observable<bufferopening>` and a `func1<bufferopening observable<bufferclosing>>` the first parameter determines when buffers are created the second parameter determines when the buffers are closed every time a `bufferopening` object is received from the `observable` a new buffer is created the received `bufferopening` object is fed into the second parameter which yields an `observable<bufferclosing>` object when this `observable` produces a `bufferclosing` object the associated buffer is closed and emitted##### buffer(timespan timeshift)this operator is very similar to `buffer(count skip)` but in stead of counting events its based on time the `timeshift` period defines how often a new buffer will be created the `timespan` period defines the period between buffer construction and buffer emission##### buffer(timespan timeshift scheduler)same as previous operator but now with a custom scheduleras always **feedback is welcome!**;#153  thank you @michaeldejong i will review and either merge or provide feedback || this is a great piece of code @michaeldejong  i dont fully understand all the nuances yet but im going to start posting some questions inline on the code the code looks good and is very well documented and the unit tests are awesome very key to me understanding the code || #166 @michaeldejong sorry for not responding to this yet  i will but have become very busy on some other things for a bit || anyone else interested and able to provide a code review? || @michaeldejong at nearly 1500 concise lines of code and tests this pr could be daunting for someone to start reviewing   id estimate review at somewhere around an hour minimumwhy dont you draw in folks in by adding usage examples into your pr description as a first step ask someone who uses javarx if they dont mind taking a pass at review?  i can make time next week sometime too || #169 ive updated the pr description with an explanation of what each operator variation does and how it does it i hope this helps in understanding the concepts behind this operator || fyi: might want to bump this commit as i think the above failure might be transient || @michaeldejong can you respond to bens question about the test returning 3 empty events? || [rxjava-pull-requests #179 [rxjava-pull-requests #180;;;;1;1;merged master into buffer-operation branch;
285;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;several new or more-precise marble diagrams;add several new or more-specific marble diagrams  correct two bad image links  correct some typos;;0;several new or more-precise marble diagrams;add several new or more-specific marble diagrams correct two bad imagelinks correct some typos;#157 ;;;;1;1;add to marble diagramsadd several new or more-specific marble diagrams correct two bad imagelinks correct some typos;
"287;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;error handling and validation;refactoring related to arg validation and error handling.   throw if no onerror handler specified  subscribe argument validation;;0;error handling and validation;refactoring related to arg validation and error handling throw if no onerror handler specified subscribe argument validation;#158 ;;;;1;1;""throw if no onerror handler specified per rx design guidelines 52: """"when calling the subscribe method that only has an onnext argument the onerror behavior will be to rethrow the exception on the thread that the message comes out from the observable sequence the oncompleted behavior in this case is to do nothing""""a new onerrornotimplementedexception was created so it is explicit as to where the exception is coming from and why"";"
288;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix publishsubject non-deterministic behavior on concurrent modification;- changed to take snapshot of observers.values() before iterating in onnext/onerror/oncompleted so that nested subscriptions that add to observers can t change the values() iteration - single-threaded nested subscriptions are now deterministic - multi-threaded subscriptions will no longer be allowed to race to get into an interating onnext/onerror/oncompleted loop  they will always wait until the next - also improved terminal state behavior when subscribing to a publishsubject that has already received onerror/oncompleted  https://github.com/netflix/rxjava/issues/282;;0;fix publishsubject non-deterministic behavior on concurrent modification;- changed to take snapshot of observersvalues() before iterating in onnext/onerror/oncompleted so that nested subscriptions that add to observers cant change the values() iteration- single-threaded nested subscriptions are now deterministic- multi-threaded subscriptions will no longer be allowed to race to get into an interating onnext/onerror/oncompleted loop they will always wait until the next- also improved terminal state behavior when subscribing to a publishsubject that has already received onerror/oncompletedhttps://githubcom/netflix/rxjava/issues/282;#159  #161;;;;1;1;synchronize terminalstate and subscription logic- remove the race condition that existed between a subscription coming in while onerror/oncompleted was being called;
290;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;issue 103;adding the zip operator that works on collection of observables and a funcn.  https://github.com/netflix/rxjava/issues/103;;0;issue 103;adding the zip operator that works on collection of observables and a funcnhttps://githubcom/netflix/rxjava/issues/103;#164  #168 so is the idea here that someone will use this with ? or object types and it will up to them to handle the typing of the arguments passed in rather than having overloads for all possible arities (ie t1 t2 t3 t4 t5  tn)? || it doesnt prevent us from adding them and maintaining type safety for more situations  type safety is also lost when use zip(observable&ltobservable&lt?>> funcn) ||;;;;1;1;adding zip(ob<ob<?>>);
"302;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;update observable.isinternalimplementation  get rid of nullpointerexcept;ion  nullpointerexception has been encountered during my tests. it is because java.lang.class.getpackage() may return null  ... if no package information is available from the archive or codebase  (documented feature).;;0;update observableisinternalimplementation get rid of nullpointerexcept;""ionnullpointerexception has been encountered during my tests it is because javalangclassgetpackage() may return null """" if no package information is available from the archive or codebase"""" (documented feature)"";#172 ;;;;1;1;""update observableisinternalimplementation get rid of nullpointerexceptionnullpointerexception has been encountered during my tests it is because javalangclassgetpackage() may return null """" if no package information is available from the archive or codebase"""" (documented feature)"";"
"303;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;pull 267 - merge combinelatest;spent some time reviewing it and it seems good. any bugs can be dealt with as people start playing with it instead of me holding this up as a pull request any longer since this exposes  combinelatest  in  observable  for i believe the first time and is thus a low risk to breaking any existing users.;;0;pull 267 - merge combinelatest;spent some time reviewing it and it seems good any bugs can be dealt with as people start playing with it instead of me holding this up as a pull request any longer since this exposes `combinelatest` in `observable` for i believe the first time and is thus a low risk to breaking any existing users;""#173  i noticed there is no marble diagram in the documentation i find these extremely helpful to understand how an operator works is `combinelatest` different from `zip` only in how events are timed? it looks like it accomplishes something very similar || its different in that it doesnt keep the sources """"synced"""" how do you create those diagrams? id draw one if i knew how || theres a marble diagram for combinelatest at: it should also be in the javadocs as of the next releaseon sat jul 20 2013 at 1:37 am joachim hofer notifications@githubcomwrote:> its different in that it doesnt keep the sources """"synced"""" how do you> create those diagrams? id draw one if i knew how> > > reply to this email directly or view it on github  || thanks that clarifies it a lot! || "";;;;1;1;merge branch combinelatest of git://githubcom/jmhofer/rxjava into pull-267-combinelatestconflicts:	rxjava-core/src/main/java/rx/observablejava	rxjava-core/src/main/java/rx/operators/operationcombinelatestjava;"
308;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;ensure now() is always updated in testscheduler.advanceto/by;the testscheduler advancetimeto() and advancetimeby() methods only update now() correctly if there is a scheduled event in the work queue after the target time. if the queue is empty  now() is not updated at all. if it has no items after the target time  then now() is updated to the time of the last event on the queue.  the pull request ensures now() is always updated to the target time. there is no check to make sure time always moves forwards  but then that check is not in the current implementation either.;;0;ensure now() is always updated in testscheduleradvanceto/by;the testscheduler advancetimeto() and advancetimeby() methods only update now() correctly if there is a scheduled event in the work queue after the target time if the queue is empty now() is not updated at all if it has no items after the target time then now() is updated to the time of the last event on the queuethe pull request ensures now() is always updated to the target time there is no check to make sure time always moves forwards but then that check is not in the current implementation either;#184  makes sense to me thanks @northnick  ||;;;;1;1;ensure time is always updated;
311;1;0;0;0;0;1;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;various javadoc improvements and corrections.;i ve been exploring the rxjava source code for the last week or two in my spare time and along the way i cleaned up and made minor corrections and improvements to the javadocs. here s the changes if they re of interest.;;0;various javadoc improvements and corrections;ive been exploring the rxjava source code for the last week or two in my spare time and along the way i cleaned up and made minor corrections and improvements to the javadocs heres the changes if theyre of interest;#186 ;;;;1;1;various javadoc improvements and corrections;
"315;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;change onerror(exception) to onerror(throwable) - issue #296;this changes  observer#onerror(exception e)  to  observer#onerror(throwable e)   see  observer#onerror should use throwable   for discussion that led to this change.  this is a breaking change and will result in a version bump from 0.9.x to 0.10.x.;;0;change onerror(exception) to onerror(throwable) - issue #296;""this changes `observer#onerror(exception e)` to `observer#onerror(throwable e)`see """"observer#onerror should use throwable""""  for discussion that led to this changethis is a breaking change and will result in a version bump from 09x to 010x "";#190  diff isnt easy to unveil pitfalls as `catch (throwable e)` diffs dont have a large enough window to show whether or not error propagation occurs after signalingmight be worthwhile doing a visual scan via reference check or string search in the ide where `catch (throwable e)` to see if errors are propagated after signaling or not  we could possibly assume that a `catch (throwable e)` conversion is more likely to imply a change in the next line or two than not  not sure || another option would be to make static utility methods like guavas `throwablespropagate` and use in common cases such as coercing to exception runtimeexception or propagating errorsex ``` javacatch (throwable e) {  thingthattakesexceptionsignal(asexception(e))  propagateiferror(e)}``` || @adriancole > diff isnt easy to unveil pitfalls as catch (throwable e) diffs dont have a large enough window to show whether or not error propagation occurs after signalingthis change is very bad for reviewing with a diff that only include a couple lines on either side when i review the 60+ files before submitting the pull request i had to keep flipping back to the full source code to read the contextits just the nature of the change  || #191 @adriancole > another option would be to make static utility methods like guavas throwablespropagate and use in common cases such as coercing to exception runtimeexception or propagating errorsthis already exists in rxjava (`exceptionspropagate(throwable)`) but i just updated it to also throw `error` now as id missed doing that change last night:  || #192 looks good || cool sounds like an easy adjustment then!on thursday august 1 2013 ben christensen wrote:> @adriancole  > another option would be to make static utility methods like guavas> throwablespropagate and use in common cases such as coercing to exception> runtimeexception or propagating errors> > this already exists in rxjava (exceptionspropagate(throwable)) but i> just updated it to also throw error now as id missed doing that change> last night: benjchristensen@87e308a#l0l25 > > reply to this email directly or view it on github  || [rxjava-pull-requests #193]( successthis pull request looks good || moving forward with the merge   ||;;;;1;1;test with error instead of runtimeexception test the throwable catch instead of exception;"
"331;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;adding super/extends so that observable is covariant;ok  so this pull request changes a _lot_ of lines. it s mostly generalizing all the  funcx s to be used like  funcx[-t1  -t2    -tx  +r]  (contravariant parameters  covariant return type) and all the  observer s to be used  in a contravariant way . a few of the  observable  uses are covariant  now  too (mostly  zip ).  this is the pull request for #326.  this doesn t look very good in the code (thanks java). also  it doesn t seem to make scala interop easier at all (at least not yet).  please take a look. i m not exactly happy with the result. - maybe i m doing something wrong here? - i ve still got hope that there s an easier way...  the pull request compiles and tests ok for me (except for the clojure module  but that s another story and not due to my changes).;;326.0;adding super/extends so that observable is covariant;""ok so this pull request changes a _lot_ of lines its mostly generalizing all the `funcx`s to be used like `funcx[-t1 -t2  -tx +r]` (contravariant parameters covariant return type) and all the `observer`s to be used """"in a contravariant way"""" a few of the `observable` uses are covariant now too (mostly `zip`)this is the pull request for #326this doesnt look very good in the code (thanks java) also it doesnt seem to make scala interop easier at all (at least not yet)please take a look im not exactly happy with the result - maybe im doing something wrong here? - ive still got hope that theres an easier waythe pull request compiles and tests ok for me (except for the clojure module but thats another story and not due to my changes)"";""#213 ill have to spend some time later playing with this anyone else able to try this out and comment on the changes?@jmhofer  can you provide examples or use cases of using the updated code that demonstrates covariant/contravariant usage that couldnt be achieved before? || ok heres an example of what you can do now with the improved `zip`:``` javaimport rxobservableimport rxutilfunctionsfunc2class media {}class movie extends media {}class horrormovie extends movie {}class rating {}class coolrating extends rating {}class result {}class extendedresult extends result {}public class covariance {  public static void main(string args) {    observable<horrormovie> horrors  observablefrom(new horrormovie())    observable<coolrating> ratings  observablefrom(new coolrating())    func2<media rating extendedresult> combine  new func2<media rating extendedresult>() {      @override public extendedresult call(media m rating r) {        return null      }    }    observablezip(horrors ratings combine)    // 011: the method zip(observable<t0> observable<t1> func2<t0t1r>)     // in the type observable is not applicable for the arguments     // (observable<horrormovie> observable<coolrating> func2<mediaratingextendedresult>)    //    // but works in super-extends branch  }}``` || lots more `observable` usages to go however the `observer`s are probably mostly done || #216 let me know when youre ready for this to be merged and released i plan on releasing this as 0120 as it does have some breaking changes || that cloudbees build failure is legit i also cant build `rxjava-scala` on my machine with this branch the core library is fine```* what went wrong:execution failed for task :language-adaptors:rxjava-scala:compilescala> compilation failed because of an internal compiler error see the error output for details``` || in this line:``` javaobservable<string> observable  observablecreate(new func1<observer<? super string> subscription>()```is it the case that java programmers creating an `observable` this way would always have to include the `? super` bit? or is this just for completeness? is this what you mean by """"im not exactly happy with the result""""? i havent thought through it but this doesnt seem like it should be necessary if its done right || @benjchristensen i just noticed that too and adapted the `rximplicits`@daveray looks like it yes i couldnt make the compiler happy without it but maybe im missing something if you find something that avoids this then please let me know || #217  still to do: future is covariant and timestamped and notification are probably tooalso: lots of operators can be used standalone and therefore should be generalized too || [rxjava-pull-requests #218 [rxjava-pull-requests #219 huh? - very interesting (compiles for me) || [rxjava-pull-requests #220 looks good || [rxjava-pull-requests #221]( successthis pull request looks good || [rxjava-pull-requests #222]( successthis pull request looks good || [rxjava-pull-requests #223]( successthis pull request looks good || i would call this ready to merge now i looked through all the code and adapted everything i found i cant guarantee that i havent overlooked something but i guess a few places here and there can still be adapted later on without too much harmthe one caveat is @daverays comment maybe the observers are overgeneralized somewhere and we can really avoid people having to write `? super x` when creating their own observers i havent found a solution for this but im probably blind to it by nowof course one could still add a lot of """"tests"""" or """"use cases"""" in `covariancetest` to show that everything compiles as it should - in that respect im rather optimistic thoughmaybe we can also get rid of more rawtype/unchecked annotations now ill check this later onnow i need some time to recover from all that toiling through java boilerplatery :) || i need to spend some more time on this in my playing around i wasnt thrilled by how it forces this type of user code that has `? super` in it:``` java    public static observable<string> o  observablecreate(new func1<observer<? super string> subscription>() {        @override        public subscription call(observer<? super string> t1) {            return null        }    })``` || i have the same concern guava seems to takes the same approach but i dont recall ever having to use type constraints like that when using it briefly looking through the guava code nothing stood out to me though that would make it behave differently though || re-reading effective java josh bloch says this on page 137:> properly used wildcard types are nearly invisible to users of a class they cause methods to accept the parameters they should accept and reject those they should reject if the user of a class has to think about wildcard types there is probably something wrong with the classs apihowever all of his examples are about methods they arent about instantiating classes like `func1<t r>` where `<t r>` ends up as `<? super observer<? super t> ? extends subscription>` || perhaps if this is what covariant generics truly requires we create a new function type specifically for this extremely common case of creating an `observable` and have it be something like this:``` javapublic interface observablefunction<t> extends func1<observer<? super t> subscription> {    public subscription call(observer<? super t> t1)}```it can then be used like this:``` java    public static observable<movie> o2  observablecreate(new observablefunction<movie>() {        @override        public subscription call(observer<? super movie> t1) {            return null        }    })    public static class myobserver implements observer<media> {        @override        public void oncompleted() {            // todo auto-generated method stub        }        @override        public void onerror(throwable e) {            // todo auto-generated method stub        }        @override        public void onnext(media args) {            // todo auto-generated method stub        }    }    public static void testthis() {        o2subscribe(new myobserver())    }```this still requires `public subscription call(observer<? super movie> t1)` but that is auto-generated by an ide (and lets face it  anyone writing java is using an ide) whereas the function definition is far easier: `new observablefunction<movie>`probably need a better name than `observablefunction` but thus far it feels better to use || unfortunately it cant be an overload of the existing create method as type erasure (and dynamic languages) see it as the same thing``` javapublic static <t> observable<t> create(func1<? super observer<? super t> ? extends subscription> func)```using the `observablefunction` works against that but then people would have to discover that new type in some other way to be truly user-friendly the method signature would need to change to:``` javapublic static <t> observable<t> create(observablefunction<t> func)```this way people would get prompted by their ides and javadoc to use the easiest approachthis whole thing (with or without a new type) is a wide-impact breaking change  all places someone does `observablecreate` || i tried again to do without observer<? super t> in several relevant places but i failed yet again it seems to be just necessary it stands to reason though if you think about it because observer is a contravariant type and java cant deal with that in any other way and in the case of observers api users are not just using them theyre creating themi like bens `observablefunction` idea above i think it would probably even be possible to get around the overloading problem by not inheriting from `func1` delegating to it instead however its still a wide-impact breaking change due to the `? super` that has to be added within every `call` method signature concerning observersstill if the `create` method is the biggest problem maybe its not so big after all or is `create` really so widely used? - id think that mostly api users will be using already created observables combining them and subscribing to them || here is a trivial example using java 8 demonstrating how `? super` needs to exist even here if retaining type safety:``` java        observable<string> omovie  observablecreate((observer<? super movie> o) -> {            oonnext(new movie())            oonnext(new movie())            return subscriptionsempty()        })map((movie) -> {            return """"movie transformed: """" + movie        })        observable<string> omedia  observablecreate((observer<? super media> o) -> {            oonnext(new media())            oonnext(new horrormovie())            return subscriptionsempty()        })map((movie) -> {            return """"media transformed: """" + movie        })        observablezip(omovie omedia (a b) -> {           return a + """" ----- """" + b        })subscribe((movie) -> {            systemoutprintln(""""media/movie: """" + movie)        })```or type safety can be thrown away:``` java        observable<string> omovie  observablecreate((observer o) -> {            oonnext(new movie())            oonnext(new movie())            return subscriptionsempty()        })map((movie) -> {            return """"movie transformed: """" + movie        })```but now that allows this to compile:``` java        observable<string> omovie  observablecreate((observer o) -> {            oonnext(new movie())            oonnext(""""hello"""") // this is not a movie object            return subscriptionsempty()        })map((movie) -> {            return """"movie transformed: """" + movie        })``` || @jmhofer the `create` method is how `observable`s are created so this affects all producers this should not affect consumers other than making the prompts/docs verbose:![screen shot 2013-09-03 at 4 41 21 pm]( and @mustafasezgin do you have any input on this discussion since you are using rxjava from plain java? || groovy is similar  but the generics dont actually do much for it as they are more-or-less ignored at compile time as best i can tell:``` groovy        observable<string> omovie  observablecreate({ observer o ->            oonnext(new movie())            oonnext(new movie())            return subscriptionsempty()        })map({ movie ->            return """"movie transformed: """" + movie        })        observable<string> omedia  observablecreate({ observer<? super media> o ->            oonnext(new media())            oonnext(new horrormovie())            return subscriptionsempty()        })map({ movie ->            return """"media transformed: """" + movie        })        observablezip(omovie omedia { a b ->            return a + """" ----- """" + b        })subscribe({ movie ->            systemoutprintln(""""media/movie: """" + movie)        })``` || this groovy code works against current master as well as the new code with `? super`:``` groovy        observable<movie> omovie  observablecreate({ observer<? super movie> o ->            oonnext(new movie())            oonnext(new movie())            ooncompleted()            return subscriptionsempty()        })        observable<media> omedia  observablecreate({ observer<? super media> o ->            oonnext(new media())            oonnext(new horrormovie())            ooncompleted()            return subscriptionsempty()        })        observablezip(omovie omedia { movie a media b ->            return stringvalueof(a) + """" ----- """" + stringvalueof(b)        })subscribe({ media ->            systemoutprintln(""""media/movie: """" + media)        })```and here it is again in plain java:``` java        observable<movie> omovie  observablecreate(new func1<observer<? super movie> subscription>() {            @override            public subscription call(observer<? super movie> o) {                oonnext(new movie())                oonnext(new movie())                ooncompleted()                return subscriptionsempty()            }        })        observable<media> omedia  observablecreate(new func1<observer<? super media> subscription>() {            @override            public subscription call(observer<? super media> o) {                oonnext(new media())                oonnext(new horrormovie())                ooncompleted()                return subscriptionsempty()            }        })        observablezip(omovie omedia new func2<movie media string>() {            @override            public string call(movie a media b) {                return stringvalueof(a) + """" ----- """" + stringvalueof(b)            }        })subscribe(new action1<string>() {            @override            public void call(string media) {                systemoutprintln(""""media/movie: """" + media)            }        })```it seems that `? super` is fine on the outer generics and doesnt need to be typed everywhere its just when its a generic inside a generic the type of the `observer` that it becomes annoying || it seems the only option (while supporting covariance) for reducing code verbosity is to create a new type that hides the `func1<? super observer<? super t> ? extends subscription>` complexityso my question now is: should we change the api to make all uses of `create` use the new type or should it remain as `func1` and the other type is just a nice utility that can be used to fulfill the signature?in other words do we leave it as this:``` javapublic static <t> observable<t> create(func1<? super observer<? super t> ? extends subscription> func)```or change it to ``` javapublic static <t> observable<t> create(observablefunction<t> func)```and what do we call the new type if we go that route? options ive considered are:- `observablefunction`- `observablefunc`- `onsubscribefunction`- `onsubscribefunc`- `funconsubscribe`and should that live in `rxutilfunctions` or `rx` alongside `rxobservable`? it feels that this is not generic and should therefore live inside `rx`unfortunately we can not overload this method and support both as type erasure makes them the same (and it will confuse dynamic languages implicits etc) if we had two methods with similar single function signaturesnormally id rather leave the lower level `func1` method signature and just have a helper class but code completion and javadocs will be far less obvious and not very discoverable thus for discoverability i think it makes more sense to use `create(observablefunction<t> func)` i cant yet think of any forward-compatibility reason why this would be a bad thing this pull request is breaking either direction we pursue || one last spam to everyone  please weigh in if you have an opinion as i intend on making a decision and releasing this weekthis will be a breaking change and affect usage for everyone || here is what the `observablefunction` interface looks like:``` java/** * function interface for work to be performed when an {@link observable} is subscribed to via {@link observable#subscribe(observer)} *  * @param <t> */public interface observablefunction<t> extends func1<observer<? super t> subscription> {    public subscription call(observer<? super t> t1)}```and the updated `create` method:``` javapublic static <t> observable<t> create(observablefunction<t> func) ```and sample code using this:``` java        observable<movie> omovie  observablecreate(new observablefunction<movie>() {            @override            public subscription call(observer<? super movie> o) {                oonnext(new movie())                oonnext(new movie())                ooncompleted()                return subscriptionsempty()            }        })``` || here is a fork including these changes so we can review and discuss:  still not thrilled by any of the directions we can take here i cant argue against making rxjava support covariant types josh bloch certainly supports it in effective java when he says """"if you write a library that will be widely used the proper use of wildcard types should be considered mandatory""""on the flip-side it forces the use of ? super/? extends everywhere even when covariant requirements are rarei think the only decision at this point to make is whether we should use something like `observablefunction<t>` to minimize the verbosity or just leave `func1<? super observer<? super t> ? extends subscription>` and if we do use `observablefunction` do we provide similar solutions elsewhere? that feels wrong to have special function interfaces for so many things even though it likely will improve readability and usabilityother operators that are awkward include:- `defer(func0<? extends observable<? extends t>> observablefactory)`- `aggregate(func2<? super t ? super t ? extends t> accumulator)`- `buffer(func0<? extends observable<? extends bufferclosing>> bufferclosingselector)`- `flatmap(func1<? super t ? extends observable<? extends r>> func)`flatmap is very common and ends up like this:``` java        omediaflatmap(new func1<media observable<? extends string>>() {            @override            public observable<? extends string> call(media s) {                            }        })```compare this with current:``` java        omediaflatmap(new func1<media observable<string>>() {            @override            public observable<string> call(media s) {                            }        })```however lambdas do make a big different on instance methods (not as much on statics) as they can infer the types for example in java 8 the above can become this:``` java        omediaflatmap(value -> {            return null        })```so without `observablefunction<t>` in java 8 we have:``` java        observablecreate((observer<? super media> o) -> {            oonnext(new media())            oonnext(new horrormovie())            return subscriptionsempty()        })flatmap(movie -> {            return observablefrom(""""media transformed: """" + moviegetname())        })```with `observablefunction<t>` in java 8 we get this:``` java        observablecreate((observer<media> o) -> {            oonnext(new media())            oonnext(new horrormovie())            return subscriptionsempty()        })flatmap(movie -> {            return observablefrom(""""media transformed: """" + moviegetname())        })```it seems that type inference will handle the instance methods for example `aggregate`/`reduce` becomes this:``` java        observablecreate((observer<integer> o) -> {            oonnext(1)            oonnext(2)            return subscriptionsempty()        })aggregate((previous current) -> {            return previous + current        })```so its only the static methods of concern `create` being the most significantjava 6/7 (and android) are going to be ugly no matter what - but we already knew that and they already are this makes it worse || experiencing some of the pain with generic method signatures and nestingfirst hand i prefer the type alias in form of an interface i would arguethat the subscription function is so widely used that the interfacecloaking it will be understood quickly enough by developers so the loss indirect clarity should be negligible || [rxjava-pull-requests #229]( failurelooks like theres a problem with this pull request || +1 observablefunction interface but call it something else maybe with subscription/subscribe in the name || @benjchristensen we could overload `create` etc - for this wed have to make `observablefunction` delegate to `func1` then instead of inheriting from it im not sure if thats a good idea though it would probably be even more confusingim not sure about the naming although it is kind of _the_ internal `observable` function i think id prefer `subscriptionfunction` or `subscriberfunction` or something like that || [rxjava-pull-requests #230]( successthis pull request looks good || how about these names?- `onsubscribefunction`- `onsubscribefunc`- `funconsubscribe` || based on my highly scientific poll of people around me at my office  and the few who have commented above im going with `onsubscribefunc`  || @benjchristensen works for me will it extend `func1` or be an independent type as @jmhofer suggests above i think id prefer the latter || i havent played with it not extending func1 it will need to at least extend `function` so it fits with all other functions in the codebase in what way will it improve things if it doesnt extend? || since this function is only intended for us by the `observablecreate` does anyone have issues with it being namespaced as `rxobservableonsubscribefunc` as a static inner class of `observable` rather than a first-class citizen `rxonsubscribefunc`?this works great in java are there any issues from clojure or scala doing it this way?create looks like this:``` javapublic static <t> observable<t> create(onsubscribefunc<t> func)```use of it looks like this:``` java        import rxobservable        import rxobservableonsubscribefunc        observable<string> observable  observablecreate(new onsubscribefunc<string>() {            @override            public subscription call(observer<? super string> observer) {                observeronnext(""""one"""")                observeronnext(""""two"""")                observeronnext(""""three"""")                observeroncompleted()                return subscriptionsempty()            }        })```the function definition looks like:``` java    /**     * function interface for work to be performed when an {@link observable} is subscribed to via {@link observable#subscribe(observer)}     *      * @param <t>     */    public static interface onsubscribefunc<t> extends function<t> {        public subscription call(observer<? super t> t1)    }``` || good idea and shouldnt be a problem for scala || great ill proceed with this change then thanks for the feedback || final interface looks like this:``` java    /**     * function interface for work to be performed when an {@link observable} is subscribed to via {@link observable#subscribe(observer)}     *      * @param <t>     */    public static interface onsubscribefunc<t> extends function {        public subscription onsubscribe(observer<? super t> t1)    }```this is being merged in  || "";make observable covariant (and observer contravariant) etc;now that rxjava is typesafe theres one thing im still dearly missing: a covariant `observable` (or generally making everything in the library properly co- contra- and invariant which especially means functions and observers too)rxnet has this for example see  and notice the `out` in `public interface iobservable<out t>`unfortunately variance can not be as easily defined in java as in c# (or scala) instead this will lead to an aweful lot of `super`/`extends` generics in method signatures - this means that the longer we wait with this the more it will hurt to introduce it everywhereso id like to try my hand at this if you agree that its worthwhile at all;i agree it is worth pursuing and would appreciate you tackling it   || like!on aug 31 2013 at 1:05 am ben christensen notifications@githubcom wrote:> i agree it is worth pursuing and would appreciate you tackling it> > > reply to this email directly or view it on github || started with `func0` and `func1` see  i dont think its worthy of a pull request yet will work towards that ||;1;0;merged in master so that the gradle pull request build has a chance to work again;"
343;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;covariant support with super/extends and onsubscribefunc;merging and adding to work by @jmhofer in   in particular this adds the following change to the previous pull request:      java public static <t> observable<t> create(func1<? super observer<? super t>  ? extends subscription> func)      to      java public static <t> observable<t> create(onsubscribefunc<t> func);;0;covariant support with super/extends and onsubscribefunc;merging and adding to work by @jmhofer in  particular this adds the following change to the previous pull request:``` javapublic static <t> observable<t> create(func1<? super observer<? super t> ? extends subscription> func)```to``` javapublic static <t> observable<t> create(onsubscribefunc<t> func)```;#233  #234;;;;1;1;change onsubscribefunccall to onsubscribefunconsubscribeavoid name collions for `call` method with func* interfaces to simplify interop with clojure etc;
345;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove unnecessary observable constructor;- fixed unit tests that relied on it;;0;remove unnecessary observable constructor;-  unit tests that relied on it;;;;;1;1;remove unnecessary observable constructor-  unit tests that relied on it;
348;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;switchdo to switchonnext;see  for original question.  does anyone have an opinion on this?;;0;switchdo to switchonnext;see  for original questiondoes anyone have an opinion on this?;#238 ;;;;1;1;switchdo- remove instance method- rename to switchonnext (leaving behind deprecated switchdo for now)see https://githubcom/netflix/rxjava/issues/342;
349;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;window operator;manual merge of   since this pull request was submitted there were significant changes to the  create  operator and generics  so i manually merged into master. i have not actually reviewed for behavior  but unit tests are passing and code structure looked good.  this is for issue https://github.com/netflix/rxjava/issues/102?source=c;;0;window operator;manual merge of  this pull request was submitted there were significant changes to the `create` operator and generics so i manually merged into master i have not actually reviewed for behavior but unit tests are passing and code structure looked goodthis is for issue https://githubcom/netflix/rxjava/issues/102?sourcec;@bcotton great pull request i like how you also worked on `buffer`now that ive merged this with master ill add some inline comments on the code with questions if another pull request is needed so you can take back control of the branch go right ahead and just cherry pick these 2 commits on to a new branch of your own || #239  this looks like a great addition of code and not a trival one so thank you @bcotton!i do not have the time to review it for thread-safety but nothing jumps out as obviously wrongthe unit tests appear to cover the use cases well and based on them the behavior looks correct i have not done a comparison with rxnet to determine if we have covered all cases if anyone else could do that id appreciate itonce weve got resolutions to the (1) generics and (2) func0 questions i posted above this appears good to merge unless anyone else can find issues || if possible id like to get the above items resolved today so i can merge this and release 012 by end of today (us time) || i know that im being kind of a pain in the butt here but theres also the question whether the various `chunk` and `window` classes are co-/contra- or invariant in their type parametersill go examine the code more closely now || i made the wi(n)dow maker typesafe - there are also some more raw types in `chunkedoperation` though || now i think im done with the important things the chunks look invariant to me at first sight i tried to get everything typesafe that wasnt already and again added a lot of wildcards - its all [here]( should i put up a pull request against your `window-merge` branch? || i just pulled them off your branch to this pull requestlooks like both of my questions/concerns are now addressedany last thoughts on placement of util classes? otherwise this looks ready to merge (if the build passes) || #240 thanks for the reviews @jmhofer@bcotton it looks like this pull request only has you as the author but not commiter due to the crazy merge i had to do if you want to take these commits and reapply them so you get the credit please do soill wait a few hours if you can do it otherwise ill proceed with this pull request || go ahead no need for glory :-) happy to help || thanks @bcotton  ill merge now and release 012 fairly soon || im confused these methods all are instance methods but they do not depend in any way on `this` so they could be made static however the better way would probably be to remove the argument called `source` and replace all occurences of `source`  this`am i missing something? || no youre not missing anything  we all did who reviewed this! so funny  an earlier review had the methods change from static to instance but apparently only the static keyword got removed ill go submit a fix and release 0121  too funny (and embarrassing) we all missed thisthanks for reporting it || oops embarrassing :-)  completely missed this too || just release 0121  making its way through sonatype now ||;;;;1;1;made the public window methods more generic via the basic (lol) super/extends fluff also simplified api by removing a few useless super definitions (theres no super of opening and closing);
351;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;fix observable.window static/instance bug;- reported at https://github.com/netflix/rxjava/pull/349#issuecomment-23946707;;0;fix observablewindow static/instance bug;- reported at https://githubcom/netflix/rxjava/pull/349#issuecomment-23946707;#242 ;;;;1;1;fix observablewindow static/instance bug- reported at https://githubcom/netflix/rxjava/pull/349#issuecomment-23946707;
"354;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;count  sum  average implementations;i implemented three easy  operations here simply using  reduce .  two things were tricky however: 1. how to name the various  overloads  (have to use different names due to identical erasure). i propose  sum    sumlongs    sumfloats    sumdoubles  here (and the same for the averages). 2. how to handle empty source observables when averaging. i propose throwing an  arithmeticexception  here.  any other opinions?;;0;count sum average implementations;""i implemented three easy  operations here simply using `reduce`two things were tricky however:1 how to name the various """"overloads"""" (have to use different names due to identical erasure) i propose `sum` `sumlongs` `sumfloats` `sumdoubles` here (and the same for the averages)2 how to handle empty source observables when averaging i propose throwing an `arithmeticexception` hereany other opinions?"";#245  ;;;;1;1;implemented average operation (#25);"
355;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented skipwhile and skipwhilewithindex (#80);the title says it all already.;;0;implemented skipwhile and skipwhilewithindex (#80);the title says it all already;#246 ;;;;1;1;implemented skipwhile and skipwhilewithindex (#80);
356;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;added interval methods to observable  where they were still missing;this was simply missing and forgotten in #55.;;0;added interval methods to observable where they were still missing;this was simply missing and forgotten in #55;#247 ;;;;1;1;removed unused imports;
"357;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented  first  and  firstordefault  operations;this pr builds upon the  skipwhile   pr (#355) which makes implementing the two  first  variants extremely easy.  i changed  firstordefault  slightly from what rx.net does by explicitly requiring a default value as parameter of the function call. i don t know what default value i should return otherwise  except  null  (and imho this would be pretty useless).  this pr addresses issue #44.;;0;""implemented """"first"""" and """"firstordefault"""" operations"";this pr builds upon the `skipwhile`  pr (#355) which makes implementing the two `first` variants extremely easyi changed `firstordefault` slightly from what rxnet does by explicitly requiring a default value as parameter of the function call i dont know what default value i should return otherwise except `null` (and imho this would be pretty useless)this pr addresses issue #44;#248  in scala `first` would be called `head` - do we have some kind of `skipfirst` (aka `tail`) too?im okay with both naming schemes with a slight preference for leaving the `take`s awayi was also playing around with `firstorelse` instead of `firstordefault` btw - the `orelse` naming scheme is quite common in scala and the default is not really much of a default anyway when you have to explicitly specify it in a parameter i left it as is because of the net naming scheme though || i need to look at what java 8 is calling these things as that is the more important naming convention for the core lib to match || java 8 uses `findfirst` which doesnt seem all that helpful:  ||;;;;1;1;added link urls to the msdn descriptions;"
362;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;merge  first  operator;merge pull request  with  first  and  firstordefault  operators.;;0;merge first operator;merge pull request  with `first` and `firstordefault` operators;#255 ;;;;1;1;merge branch first-firstdefault of git://githubcom/jmhofer/rxjava into operator-first-mergeconflicts:	rxjava-core/src/test/java/rx/observabletestsjavathis merges pull request  aliased first with takefirst to match takelast;
363;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;unit tests for covariance;- refactoring so not everything for the entire observable ends up in a single class;;0;unit tests for covariance;- refactoring so not everything for the entire observable ends up in a single class;#256 ;;;;1;1;unit tests for covariance- refactoring so not everything for the entire observable ends up in a single class;
364;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;additions to tests;;;0;additions to tests;;#257 ;;;;1;1;additions to tests;
"368;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operators: throttle and debounce;this adds  throttlefirst    throttlelast  (alias of  sample ) and  debounce  (aliased with  throttlewithtimeout ).  this merges pull request   unfortunately the rx  throttle  operator behavior is actually  debounce   not  throttle . this pull request tries to address that.  here is a good place to get a description of  throttle  versus  debounce :   > debounce: think of it as  grouping multiple events in one . imagine that you go home  enter in the elevator  doors are closing and suddenly your neighbor appears in the hall and tries to jump on the elevator. be polite! and open the doors for him: you are debouncing the elevator departure. consider that the same situation can happen again with a third person  and so on... probably delaying the departure several minutes. >  > throttle: think of it as a valve  it regulates the flow of the executions. we can determine the maximum number of times a function can be called in certain time. so in the elevator analogy.. you are polite enough to let people in for 10 secs  but once that delay passes  you must go!  other links includes: -  -   i feel we need some kind of  throttle*  operator name as an alias to  debounce  to help people discover it  especially those coming from rx.net or rxjs. i m not fond of  throttlewithtimeout  which is what i have it as right now. perhaps  throttleviadebounce  even though that doesn t actually make sense?   i do not want to use  throttle  because it s not actually the definition of  throttle . to confirm this i have asked over a dozen server-side engineers what their definition of  throttle  is and their expectations of an operator is. it never matches the rx definition and they are always surprised by the  debounce  behavior.  i have included  throttlelast  as an alias to  sample  so that as people start typing  throttle...  it prompts them for the different options and discoverability will be improved instead of knowing to go look for  sample .  the  throttlefirst  operator is included as an efficient approach to throttling tht does not involve ticking time  intervals or buffering in any way. it simply allows an  onnext  value through if the last  onnext  event was greater than x time units ago. all others are discarded. this matches server-side throttling expectations and is limited overhead.  questions:  1) is there a better name for  throttlewithtimeout  as an alias to  debounce ? 2) does the documentation sufficiently explain the different strategies? 3) if ambitious in your review  does anyone see concurrency bugs?;;0;operators: throttle and debounce;""this adds `throttlefirst` `throttlelast` (alias of `sample`) and `debounce` (aliased with `throttlewithtimeout`)this merges pull request  the rx `throttle` operator behavior is actually `debounce` not `throttle` this pull request tries to address thathere is a good place to get a description of `throttle` versus `debounce`:  debounce: think of it as """"grouping multiple events in one"""" imagine that you go home enter in the elevator doors are closing and suddenly your neighbor appears in the hall and tries to jump on the elevator be polite! and open the doors for him: you are debouncing the elevator departure consider that the same situation can happen again with a third person and so on probably delaying the departure several minutes> > throttle: think of it as a valve it regulates the flow of the executions we can determine the maximum number of times a function can be called in certain time so in the elevator analogy you are polite enough to let people in for 10 secs but once that delay passes you must go!other links includes:-   feel we need some kind of `throttle*` operator name as an alias to `debounce` to help people discover it especially those coming from rxnet or rxjs im not fond of `throttlewithtimeout` which is what i have it as right now perhaps `throttleviadebounce` even though that doesnt actually make sense? i do not want to use `throttle` because its not actually the definition of `throttle` to confirm this i have asked over a dozen server-side engineers what their definition of `throttle` is and their expectations of an operator is it never matches the rx definition and they are always surprised by the `debounce` behaviori have included `throttlelast` as an alias to `sample` so that as people start typing `throttle` it prompts them for the different options and discoverability will be improved instead of knowing to go look for `sample`the `throttlefirst` operator is included as an efficient approach to throttling tht does not involve ticking time intervals or buffering in any way it simply allows an `onnext` value through if the last `onnext` event was greater than x time units ago all others are discarded this matches server-side throttling expectations and is limited overheadquestions:1) is there a better name for `throttlewithtimeout` as an alias to `debounce`?2) does the documentation sufficiently explain the different strategies?3) if ambitious in your review does anyone see concurrency bugs?"";#262  i would appreciate feedback on this today so i can merge (or fix with feedback) tomorrow (wednesday us time) and get ready to release version 013 || ive created marble diagrams for these new methods if you want to includethem in the javadocs you can use a similar url pattern to those that arealready found there the diagrams are called:throttlelastpngthrottlefirstpngthrottlewithtimeoutpngdebouncepng || thank you @davidmgross one change to make  on `throttlefirst` there would not be a delay in delivering thus it would emit red yellow turquoise immediately not after a delay thats the big difference with throttlefirst there is no scheduling or delaying thus no threading overhead it only skips until skipduration has passed since the last onnext was emitted then emits the next onnext it receives || #264 no feedback so im moving forward with this ||;;;;1;1;javadoc with images;"
"369;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove covariance of scan/reduce;remove covariance of scan/reduce since consumer/producer are the same <t  t  t>  see https://github.com/netflix/rxjava/issues/360#issuecomment-24203016;;0;remove covariance of scan/reduce;remove covariance of scan/reduce since consumer/producer are the same <t t t>see https://githubcom/netflix/rxjava/issues/360#issuecomment-24203016;""#263  this method and friends    public &ltr&gt observable&ltr&gt reduce(r initialvalue func2&lt? super r ? super t ? extends r&gt accumulator) {also needs to changed to    public &ltr&gt observable&ltr&gt reduce(r initialvalue func2&ltr ? super t r&gt accumulator) {t2 should remain """"? super t"""" because it is only consumed || i didnt change those yet as i wasnt sure if they behave differently because they consume and produce different types i wasnt able to get an example that proved or disproved anything so left it until i cando you have example code that shows that method doesnt benefit from `? super t`?and what t2 are you referring to? there isnt anything with a type t2 in `reduce` || func2&ltt1 t2 r&gt || (george and i chatted in person)we looked at jdk 8 to try and get a final representation of others doing this and it does it like this:``` java<u> u reduce(u identity             bifunction<u? super tu> accumulator             binaryoperator<u> combiner)```this is at:  javaoptional<t> reduce(binaryoperator<t> accumulator)```the `binaryoperator` is this:``` javapublic interface binaryoperator<t>extends bifunction<ttt>```thus this seems to confirm the decision to remove `? super` in reduce without a seed and in the one with a seed value do what george recommended:``` javareduce(r initialvalue func2<r ? super t r> accumulator)``` || #267 "";;;;1;1;simplify reduce/scan genericsupdates based on discussion at https://githubcom/netflix/rxjava/pull/369#issuecomment-24255958;"
370;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;change zip method signature from collection to iterable;fix javadoc typos.;;0;change zip method signature from collection to iterable;fix javadoc typos;#265 ;;;;1;1;change zip method signature from collection to iterablefix javadoc typos;
371;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator: retry;https://github.com/netflix/rxjava/issues/72;;0;operator: retry;https://githubcom/netflix/rxjava/issues/72;this completes  || #266 ;;;;1;1;operator: retryhttps://githubcom/netflix/rxjava/issues/72;
"373;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;a few warnings  javadoc  and one missing scheduler parameter;this is just a quick fix for #368 according to @samuelgruetter s comments.  i also removed a few unnecessary  @suppresswarnings( unchecked )  and one unnecessary semicolon.;;0;a few warnings javadoc and one missing scheduler parameter;""this is just a quick fix for #368 according to @samuelgruetters commentsi also removed a few unnecessary `@suppresswarnings(""""unchecked"""")` and one unnecessary semicolon"";#268  #270 thank you! ||;;;;1;1; all the javadoc build warnings;"
375;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented  distinct  operator;this pr implements  distinct   as speficied by #38.   again  i haven t implemented the .net methods taking an  iequalitycomparator  (see #374).;;38.0;implemented `distinct` operator;this pr implements `distinct` as speficied by #38 again i havent implemented the net methods taking an `iequalitycomparator` (see #374);#272 ;operator: distinct;http://msdnmicrosoftcom/en-us/library/hh229764(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211630(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh244310(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229050(vvs103)aspx;;1;0;added javadoc comments to observabledistinct;
377;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;distinct operator;merging https://github.com/netflix/rxjava/pull/375;;0;distinct operator;merging https://githubcom/netflix/rxjava/pull/375;#274 ;;;;1;1;merge branch distinct of git://githubcom/jmhofer/rxjava into distinct-mergeconflicts:	rxjava-core/src/main/java/rx/observablejava;
378;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;unittests while working on eventstream use cases;;;0;unittests while working on eventstream use cases;;#275 ;;;;1;1;unittests while working on eventstream use cases;
381;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented  mapwithindex;as requested by @samuelgruetter in #372.;;372.0;implemented `mapwithindex`;as requested by @samuelgruetter in #372;#278 (test failure again due to sporadic timing problems) || i just submitted an [issue]( for this || ;zip/map/select with index;im looking for a function corresponding to this rx c# function: we already have this in rxjava? im asking this because i want to implement the `zipwithindex` function in the scala adaptor;no we do not have that yet your naming convention will be what we need to use so we dont overload methods with functions of different arities as that causes issuesso `mapwithindex` and `zipwithindex` make sense || id be happy with `mapwithindex` and `zipwithindex` || i dont think we have the arity problem with `map` (`mapwithindex`) or do we? i think it should be specific to `zip` so we could name it `map` instead of `mapwithindex` if we wanted to but probably we should be consistent and still call it `mapwithindex` || i take that back i just experimented with this and noticed that at least clojure does indeed have a problem with that so `mapwithindex` it is ||;1;0;implemented mapwithindex;
"385;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented the  any  operator;this implements the operator  any  from #24 in all two variants.  however  i encountered two problems.  updated: the online document  is wrong. see my later discussion.  another question is if i add the  any  method to  rx.observable<t>   some unit tests will fail as the method  any  in   rx.observable<t>  overrides the method  org.mockito.matchers.any(java.lang.class<t>)  in some unit tests (e.g.   rx.subjects.replaysubject<t> ). do i need to use another method name  or just modify the unit tests? now the  any  methods in  rx.observable<t>  are commented out.  thanks.;;24.0;implemented the any operator;this implements the operator `any` from #24 in all two variantshowever i encountered two problemsupdated: the online document  is wrong see my later discussionanother question is if i add the `any` method to `rxobservable<t>` some unit tests will fail as the method `any` in  `rxobservable<t>` overrides the method `orgmockitomatchersany(javalangclass<t>)` in some unit tests (eg `rxsubjectsreplaysubject<t>`) do i need to use another method name or just modify the unit tests? now the `any` methods in `rxobservable<t>` are commented outthanks;""#284  i havent looked at the first question yet but on the second one well likely need to stop importing `orgmockitomatchers*` and call it directly `orgmockitomatchersany` || sorry that i missed the keyword `empty` in my description the first question is im not sure how to handle an `empty` observable sequence || #285] i tested the c# `any` today the environment is vs2010 net 40i found the description in my vs is `determines whether any element of an observable sequence satisfies a condition` this is totally different from the online document  always did some tests for `any` here is the code:<pre>using systemusing systemcollectionsgenericusing systemlinqusing systemtextusing systemreactivelinqnamespace consoleapplication1{    class program    {        static void main(string args)        {            var any  observableempty<int>()any()            anysubscribe(                x > consolewriteline(""""subscriber got """" + x) // subscriber got false            )            any  observablerange(1 5)any()            anysubscribe(                x > consolewriteline(""""subscriber got """" + x) // subscriber got true            )                        any  observableempty<int>()any(                x > true            )            anysubscribe(                x > consolewriteline(""""subscriber got """" + x) // subscriber got false            )            any  observablerange(1 5)any(                x > x > 3            )            anysubscribe(                x > consolewriteline(""""subscriber got """" + x) // subscriber got true            )            any  observablerange(1 5)any(                x > x > 5            )            anysubscribe(                x > consolewriteline(""""subscriber got """" + x) // subscriber got false            )            consolereadline()        }    }}</pre>here is the output:<pre>subscriber got falsesubscriber got truesubscriber got falsesubscriber got truesubscriber got false</pre>in summary  - if an observable sequence is empty `any` emits `false`- if one element of an observable sequence satisfies the condition `any` emits `true`- if all elements of an observable sequence do not satisfy the condition `any` emits `false` || i have implemented the correct any operator please take a look  #286] in scala we will probably use `isempty` instead of `any()` (negated) and `exists(somepredicate)` instead of `any(somepredicate)` you could use these names also in java to avoid confusion and name conflicts || @zsxwing i dont have time tonight but will definitely get to this in the near future thank you for getting involved! || "";operator: any;http://msdnmicrosoftcom/en-us/library/hh229905(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211993(vvs103)aspx;i think this issue can be closed ||;1;0;follow the correct logic of any operator see #385;"
390;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented the  elementat  and  elementatordefault  operators. see #41;hi   this implements the  elementat  and  elementatordefault  operators from #41.  for  elementat   if the index is less than 0  or greater than or equal to the number of elements in the source sequence  an indexoutofboundsexception will be threw.  for  elementatordefault    if the index is less than 0  an indexoutofboundsexception will be threw. what s more  i added a  defaultvalue  parameter. i can not get the element type in the source observable due to type erasure. so i can not determine the default value automatically. that s why  elementatordefault  needs  a  defaultvalue  parameter.;;41.0;implemented the elementat and elementatordefault operators see #41;hithis implements the `elementat` and `elementatordefault` operators from #41for `elementat` if the index is less than 0 or greater than or equal to the number of elements in the source sequence an indexoutofboundsexception will be threwfor `elementatordefault`  if the index is less than 0 an indexoutofboundsexception will be threw whats more i added a `defaultvalue` parameter i can not get the element type in the source observable due to type erasure so i can not determine the default value automatically thats why `elementatordefault` needs  a `defaultvalue` parameter;#288  thank you @zsxwing  ||;operator: elementat and elementatordefault;http://msdnmicrosoftcom/en-us/library/hh229725(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229845(vvs103)aspx;i think this issue can be closed ||;1;0;implemented the elementat and elementatordefault operators see #41;
398;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;merge  any  pull request;merges pull   i changed  any  to  isempty  and  exists  as i agree with @samuelgruetter comment at  these names feel more idiomatic to java languages.;;0;merge any pull request;merges pull  changed `any` to `isempty` and `exists` as i agree with @samuelgruetter comment at  these names feel more idiomatic to java languages;#297];;;;1;1;change any to isempty/exists;
400;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;removing  comparator  overloads of  distinct;removing these fairly recently added overloads as they turn out to not be the best approach.  discussion ongoing as to how to implement them at https://github.com/netflix/rxjava/issues/395;;0;removing comparator` overloads of `distinct`;removing these fairly recently added overloads as they turn out to not be the best approachdiscussion ongoing as to how to implement them at https://githubcom/netflix/rxjava/issues/395;#299];;;;1;1;removing comparator` overloads of `distinct`removing these fairly recently added overloads as they turn out to not be the best approachdiscussion ongoing as to how to implement them at https://githubcom/netflix/rxjava/issues/395;
407;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented refcount operator;please note that i placed the unit tests under the test root rather than inline with the implementation as has been done for other operators.  this is due to a bug in idea that prohibits running unit tests in folders designated as source rather than test.  i can see that a bunch of other operators follow this convention so hopefully that s okay.;;0;implemented refcount operator;please note that i placed the unit tests under the test root rather than inline with the implementation as has been done for other operators  this is due to a bug in idea that prohibits running unit tests in folders designated as source rather than test  i can see that a bunch of other operators follow this convention so hopefully thats okay;#310] i notice this was aborted due to a timeout in the scala language adaptors tests  i didnt make any changes in this area so am guessing theres an intermittent bug somewhere || #311] the problem with the scala tests should be  by  but that only saves 48 seconds there must be also another problem with the cloudbees-pull-request-builder || hopefully the builds should improve now ive changed the cloudbees config to allow twice as much time || thank you for implementing `refcount` its been one ive wanted for a while but havent had time to dowill review it and merge as soon as i can || #314] thanks @johnhmarks for submitting this ||;;;;1;1;removed static variant of refcount;
409;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented  synchronize  with  lock;hi   i implemented #84 to support that sending a lock to the  synchronize  operator.  i also found that there was a issue that  testmultithreadedwithnpe  and  testmultithreadedwithnpeinmiddle  might fail in some special situation. when  onerror  is invoked before any  onnext   the last statement  assertequals(1  busyobserver.maxconcurrentthreads.get())   in these methods will fail. i also fixed this issue in the pull request.;;84.0;implemented synchronize with lock;hii implemented #84 to support that sending a lock to the `synchronize` operatori also found that there was a issue that `testmultithreadedwithnpe` and `testmultithreadedwithnpeinmiddle` might fail in some special situation when `onerror` is invoked before any `onnext` the last statement `assertequals(1 busyobservermaxconcurrentthreadsget())` in these methods will fail i also  this issue in the pull request;#313] looks good thank you! ||;operator: synchronize (overload);another overload to the existing synchronize //msdnmicrosoftcom/en-us/library/hh229790(vvs103)aspx;;1;0;implemented synchronize with lock;
415;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented the  empty  operator with scheduler;hi   i implemented the  empty  operator with scheduler #42. please take a look. thanks.;;42.0;implemented the empty operator with scheduler;hii implemented the empty operator with scheduler #42 please take a look thanks;#323  #325;operator: empty with scheduler;http://msdnmicrosoftcom/en-us/library/hh229066(vvs103)aspx;;1;0;added msdn links;
416;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented the  throw  operator with scheduler;hi   i implemented the  throw  operator #89 with scheduler. i found that rxjava had an  error  method. so i just implemented the scheduler overload.;;89.0;implemented the throw operator with scheduler;hii implemented the `throw` operator #89 with scheduler i found that rxjava had an `error` method so i just implemented the scheduler overload;#324  @benjchristensen i agree with you i updated the codes and rebased it to master || #338;operator: throw;http://msdnmicrosoftcom/en-us/library/hh244299(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211711(vvs103)aspx;;1;0;used subscribeon instead of observeon;
424;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented the  ignoreelements  operator;hi   i implemented the  ignoreelements  operator #54. please take a look. thanks.;;54.0;implemented the ignoreelements operator;hii implemented the `ignoreelements` operator #54 please take a look thanks;#333  can you rebase this with the changes to master so it can be cleanly merged again? with all the other changes this no longer cleanly mergesthank you @zsxwing for this and all the other pull requests i really appreciate your involvement in the project || i rebased the pull request now it should be able to merge to master directly || #336 #337 looks good ||;operator: ignoreelements;http://msdnmicrosoftcom/en-us/library/hh229242(vvs103)aspx;;1;0;implemented the ignoreelements operator;
425;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;manual merge of pull request #407;added a unit test to #407 while testing it.;;0;manual merge of pull request #407;added a unit test to #407 while testing it;#334 ;;;;1;1;unit test while testing refcount submission;
"426;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;publishsubject resubscribe for publish().refcount() behavior;allow  publish  +  refcount  to support re-subscribing to the origin after decrementing the count to 0 then adding new observers which increment count to 1+.  the publishsubject implementation was performing onerror/oncompleted unsubscribe logic that was put in place long ago and i am now pretty sure it was wrong.  this was revealed while playing with  refcount  which intends on allowing a re-subscription to the source once new observers arrive. publishsubject was preventing that.  the one use case that i m still wondering about though is if someone subscribes to a publishsubject after it has emitted oncompleted and isn t  restarted . that observer would wait forever if it is a  single-shot  publishsubject use case. i m not sure if that s just a bad use and fits into the  don t do that  scenario  or if it s a legit issue that has a solution.  right now this code is  thread-safe  in the visibility sense  but it s not atomic and could have race conditions between adding/removing observers and event notifications. i don t think that s an issue as if someone is concurrently adding/removing it s always a race  but am not 100% sure if there s a use case i m missing. this also assumes (as it always did) that someone is not invoking onnext concurrently as that would break the rx contract.;;0;publishsubject resubscribe for publish()refcount() behavior;""allow `publish` + `refcount` to support re-subscribing to the origin after decrementing the count to 0 then adding new observers which increment count to 1+the publishsubject implementation was performing onerror/oncompleted unsubscribe logic that was put in place long ago and i am now pretty sure it was wrongthis was revealed while playing with `refcount` which intends on allowing a re-subscription to the source once new observers arrive publishsubject was preventing thatthe one use case that im still wondering about though is if someone subscribes to a publishsubject after it has emitted oncompleted and isnt """"restarted"""" that observer would wait forever if it is a """"single-shot"""" publishsubject use case im not sure if thats just a bad use and fits into the """"dont do that"""" scenario or if its a legit issue that has a solutionright now this code is """"thread-safe"""" in the visibility sense but its not atomic and could have race conditions between adding/removing observers and event notifications i dont think thats an issue as if someone is concurrently adding/removing its always a race but am not 100% sure if theres a use case im missing this also assumes (as it always did) that someone is not invoking onnext concurrently as that would break the rx contract"";see this part of the unit test for the use case that triggered finding this:  appreciate someone confirming behavior from rxnet and my questions/assumptions in the description above || #335 ;;;;1;1;""remove publishsubject terminal state behaviorthe publishsubject implementation was performing onerror/oncompleted unsubscribe logic that was put in place long ago and i am now pretty sure it was wrongthis was revealed while playing with `refcount` which intends on allowing a re-subscription to the source once new observers arrive publishsubject was preventing thatthe one use case that im still wondering about though is if someone subscribes to a publishsubject after it has emitted oncompleted and isnt """"restarted"""" that observer would wait forever if it is a """"single-shot"""" publishsubject use case im not sure if thats just a bad use and fits into the """"dont do that"""" scenario or if its a legit issue that has a solutionrightn now this code is """"thread-safe"""" in the visibility sense but its not atomic and could have race conditions between adding/removing observers and event notifications i dont think thats an issue as if someone is concurrently adding/removing its always a race but am not 100% sure if theres a use case im missing this also assumes (as it always did) that someone is not invoking onnext concurrently as that would break the rx contract"";"
434;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented serialsubscription and timeout operator;implemented timeout operator and serialsubscription upon which it is based.;;0;implemented serialsubscription and timeout operator;implemented timeout operator and serialsubscription upon which it is based;#345  merging this as it functions and is well written and well documented and will then look at whether modifications based on #446 make sense ||;;;;1;1; a couple of warnings and reverted change to imports;
447;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;caching the result of  isinternalimplementation;currently  reflective getpackage() call happens on every subscribe() invocation.  this pr sets up a concurrent hashmap to cache the result of this call per-class.;;0;caching the result of isinternalimplementation;currently reflective getpackage() call happens on every subscribe() invocation  this pr sets up a concurrent hashmap to cache the result of this call per-class;#367;;;;1;1;caching the result of isinternalimplementation so that reflection doesnt get invoked on every subscribe;
450;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented the  timeinterval  operator;hi  this pr implemented the  timeinterval  operator #90. please take a look. thanks.;;90.0;implemented the timeinterval operator;hi this pr implemented the `timeinterval` operator #90 please take a look thanks;#370 looks good thanks @zsxwing  ||;operator: timeinterval;http://msdnmicrosoftcom/en-us/library/hh212107(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229092(vvs103)aspx;;1;0;implemented the timeinterval operator;
452;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented the scheduler version of the  return  operator;hi  this is the scheduler version of the  return  operator #73.;;0;implemented the scheduler version of the return operator;hi this is the scheduler version of the return operator #73;#371;;;;1;1;updated the comments;
460;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented the  amb  operator;hi  this pr implemented the  amb  operator #22. i used varargs to support the array version and first-second version in one method. so in my pr  there are only two variants.;;22.0;implemented the amb operator;hi this pr implemented the `amb` operator #22 i used varargs to support the array version and first-second version in one method so in my pr there are only two variants;#379 you shouldnt define a vararg method taking a generic type because you cannot use it without getting warnings (weve already had this with other operators) instead define an overload for 2 args 3 args 4 args  || yup its a pain but this is what we ended up doing for zip merge etc instead of using varargs || #382 thank you ||;operator: amb;http://msdnmicrosoftcom/en-us/library/hh229115(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229733(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211783(vvs103)aspx;;1;0;removed the vararg overload and added 2-9 args overloads;
463;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;added the rest overloads of timeout operator;hi  this pr implemented the rest overloads of  timeout  operator #91. please take a look. thanks.;;91.0;added the rest overloads of timeout operator;hi this pr implemented the rest overloads of `timeout` operator #91 please take a look thanks;#383 due to pull request  which touched virtually every file in the project can you please rebase this so it can merge cleanly again? || #388 i have rebased it || thank you @zsxwing  ||;operator: timeout;http://msdnmicrosoftcom/en-us/library/hh244331(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh244283(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh244232(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh244293(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229512(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh228946(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh244303(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211676(vvs103)aspx;think this can be closed now ||;1;0;added the rest overloads of timeout operator;
465;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;moving unit tests to test source folders #439;;;0;moving unit tests to test source folders #439;;#385 that is an impressive amount of work @pasviegas and changes look mostly cleani have to say this reminds me why i prefer not having tests separatednot thrilled with some of the privates being made package public especially on ones where it breaks the singleton contract im looking at those right now so i can try and merge without sacrificing those before anything else in the codebase changes and causes conflicts as this is a nasty thing to merge with conflicts || i have merged these changes thank you! ||;;;;1;1;moving tests to test source folder #439;
"466;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;refactor unit tests from inner classes to /src/test;manual merge of and additions to pull request  to refactor unit tests from inner classes to separate /src/test/ folder to accomplish issue    minimize library size .  great work by @pasviegas on this pull request!;;0;refactor unit tests from inner classes to /src/test;""manual merge of and additions to pull request  to refactor unit tests from inner classes to separate /src/test/ folder to accomplish issue   """"minimize library size""""great work by @pasviegas on this pull request!"";#386;;;;1;1;add missing license headers;"
472;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;bugfix: issue 431 unsubscribe with schedulers.newthread;fix bug => unsubscribing does not work when using subscribeon(schedulers.newthread())  i believe this fixes   the newthreadscheduler was not using discardableaction that supports being unsubscribed.;;0;bugfix: issue 431 unsubscribe with schedulersnewthread;fix bug > unsubscribing does not work when using subscribeon(schedulersnewthread())i believe this fixes  newthreadscheduler was not using discardableaction that supports being unsubscribed;#396;;;;1;1;bugfix: unsubscribing does not work when using subscribeon(schedulersnewthread())i believe this fixes https://githubcom/netflix/rxjava/issues/431;
"474;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;bugfix: reduce an empty observable;this fixes issue   the fix is based on this comment by @headinthebox:   thank you @zsxwing  for your involvement on this.  if i have mis-interpreted the results of the discussion and this is still wrong  please correct me.  here is the unit test asserting the behavior:      java     /**      * a reduce should fail with an illegalargumentexception if done on an empty observable.      */     @test(expected = illegalargumentexception.class)     public void testreducewithemptyobservable() {         observable<integer> observable = observable.range(1  0)          observable.reduce(new func2<integer  integer  integer>() {              @override             public integer call(integer t1  integer t2) {                 return t1 + t2              }          }).toblockingobservable().foreach(new action1<integer>() {              @override             public void call(integer t1) {                 // do nothing ... we expect an exception instead             }         })           fail( expected an exception to be thrown )      };;0;bugfix: reduce an empty observable;""this fixes issue  fix is based on this comment by @headinthebox:  you @zsxwing  for your involvement on thisif i have mis-interpreted the results of the discussion and this is still wrong  please correct mehere is the unit test asserting the behavior:``` java    /**     * a reduce should fail with an illegalargumentexception if done on an empty observable     */    @test(expected  illegalargumentexceptionclass)    public void testreducewithemptyobservable() {        observable<integer> observable  observablerange(1 0)        observablereduce(new func2<integer integer integer>() {            @override            public integer call(integer t1 integer t2) {                return t1 + t2            }        })toblockingobservable()foreach(new action1<integer>() {            @override            public void call(integer t1) {                // do nothing  we expect an exception instead            }        })        fail(""""expected an exception to be thrown"""")    }```"";#399;;;;1;1;bugfix: reduce an empty observablethis fixes issue  fix is based on this comment by @headinthebox: https://githubcom/netflix/rxjava/issues/423#issuecomment-27642532;"
476;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;don t emit null oncomplete when no onnext received in asyncsubject;reported via email by @axel22 and @headinthebox;;0;dont emit null oncomplete when no onnext received in asyncsubject;reported via email by @axel22 and @headinthebox;#401;;;;1;1;dont emit null oncomplete when no onnext received;
477;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;compositesubscription bugfixes;- remove now also unsubscribes the removed subscription - added clear method;;0;compositesubscription bugfixes;- remove now also unsubscribes the removed subscription- added clear method;#402;;;;1;1;unsubscribe idempotence test;
"478;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented the  operator: min and minby  and  operator: max and maxby;hi  this pr implemented the  operator: min and minby  #63 and  operator: max and maxby  #61. every operator has 2 variants  one for  comparable   another for  comparator . please take a look. thanks!;;61.0;""implemented the """"operator: min and minby"""" and """"operator: max and maxby"""""";hi this pr implemented the `operator: min and minby` #63 and `operator: max and maxby` #61 every operator has 2 variants one for `comparable` another for `comparator` please take a look thanks!;#404  `operationmin` and `operationmax` are exactly the same except that `<` and `>` are swapped cant you implement one in terms of the other? or create a general one which takes +1 or -1 to know whether we want `<` or `>`? || is the following solution ok?``` java    public static <t extends comparable<t>> observable<t> min(            observable<t> source) {        return minmax(source -1)    }    public static <t extends comparable<t>> observable<t> max(            observable<t> source) {        return minmax(source 1)    }    public static <t extends comparable<t>> observable<t> minmax(            observable<t> source final long flag) {        return sourcereduce(new func2<t t t>() {            @override            public t call(t acc t value) {                if (flag * acccompareto(value) > 0) {                    return acc                }                return value            }        })    }````flag` must be `long` as `integermin_value  -1 * integermin_value` but we will have one multiplication for every `compareto`another solution is:``` java    public static <t extends comparable<t>> observable<t> min(            observable<t> source) {        return minmax(source true)    }    public static <t extends comparable<t>> observable<t> max(            observable<t> source) {        return minmax(source false)    }    public static <t extends comparable<t>> observable<t> minmax(            observable<t> source final boolean ismin) {        return sourcereduce(new func2<t t t>() {            @override            public t call(t acc t value) {                if (ismin) {                    if (acccompareto(value) < 0) {                        return acc                    }                } else {                    if (acccompareto(value) > 0) {                        return acc                    }                }                return value            }        })    }```@samuelgruetter  do you have other better solution? || i like both of these two solutions with a slight preference for the first one -)nice catch with integermin_value :-)a third solution would be to implement max using min and wrapping the given comparator such that it inverts the ordering but i think the first solution is the bestanother issue: what if there are several minimal elements? does min return the first of them the last of them or is it unspecified? this should be documented || @samuelgruetter  thanks for your review i used the +1/-1 way to implement it and also updated the document || #407 looks good @zsxwing and thanks @samuelgruetter for the reviewsome nice use of generics in those signatures! ||;operator: max and maxby;http://msdnmicrosoftcom/en-us/library/hh211633(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh228920(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211789(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229262(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229205(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211692(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229793(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229567(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229001(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211981(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211837(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211635(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229058(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh244330(vvs103)aspx;;1;0;use the +1/-1 way to implement the min and max operators;"
"478;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented the  operator: min and minby  and  operator: max and maxby;hi  this pr implemented the  operator: min and minby  #63 and  operator: max and maxby  #61. every operator has 2 variants  one for  comparable   another for  comparator . please take a look. thanks!;;63.0;""implemented the """"operator: min and minby"""" and """"operator: max and maxby"""""";hi this pr implemented the `operator: min and minby` #63 and `operator: max and maxby` #61 every operator has 2 variants one for `comparable` another for `comparator` please take a look thanks!;#404  `operationmin` and `operationmax` are exactly the same except that `<` and `>` are swapped cant you implement one in terms of the other? or create a general one which takes +1 or -1 to know whether we want `<` or `>`? || is the following solution ok?``` java    public static <t extends comparable<t>> observable<t> min(            observable<t> source) {        return minmax(source -1)    }    public static <t extends comparable<t>> observable<t> max(            observable<t> source) {        return minmax(source 1)    }    public static <t extends comparable<t>> observable<t> minmax(            observable<t> source final long flag) {        return sourcereduce(new func2<t t t>() {            @override            public t call(t acc t value) {                if (flag * acccompareto(value) > 0) {                    return acc                }                return value            }        })    }````flag` must be `long` as `integermin_value  -1 * integermin_value` but we will have one multiplication for every `compareto`another solution is:``` java    public static <t extends comparable<t>> observable<t> min(            observable<t> source) {        return minmax(source true)    }    public static <t extends comparable<t>> observable<t> max(            observable<t> source) {        return minmax(source false)    }    public static <t extends comparable<t>> observable<t> minmax(            observable<t> source final boolean ismin) {        return sourcereduce(new func2<t t t>() {            @override            public t call(t acc t value) {                if (ismin) {                    if (acccompareto(value) < 0) {                        return acc                    }                } else {                    if (acccompareto(value) > 0) {                        return acc                    }                }                return value            }        })    }```@samuelgruetter  do you have other better solution? || i like both of these two solutions with a slight preference for the first one -)nice catch with integermin_value :-)a third solution would be to implement max using min and wrapping the given comparator such that it inverts the ordering but i think the first solution is the bestanother issue: what if there are several minimal elements? does min return the first of them the last of them or is it unspecified? this should be documented || @samuelgruetter  thanks for your review i used the +1/-1 way to implement it and also updated the document || #407 looks good @zsxwing and thanks @samuelgruetter for the reviewsome nice use of generics in those signatures! ||;operator: min and minby;http://msdnmicrosoftcom/en-us/library/hh229286(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh228994(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229117(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229224(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229230(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229859(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229084(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh212002(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh244289(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh228951(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229715(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229095(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh228970(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229505(vvs103)aspx;;1;0;use the +1/-1 way to implement the min and max operators;"
"480;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;bugfix: emit an illegalargumentexception instead of arithmeticexception if the observable is empty;this pr fixed the  average  issue in #423. if an observable is empty   average  will emit an  illegalargumentexception  instead of  arithmeticexception . thanks!;;423.0;bugfix: emit an illegalargumentexception instead of arithmeticexception if the observable is empty;this pr  the `average` issue in #423 if an observable is empty `average` will emit an `illegalargumentexception` instead of `arithmeticexception` thanks!;#405 ;reduce an empty observable;""hiin rxjava `reduce(func2<t t t> accumulator)` may be not implemented correctly now `reduce` is implemented using `scan` when reducing on empty observable  it will invoke `oncompleted` and do nothing  this is against my expectation i suppose that reducing an empty observable should throw an exceptionactually `scan` and `aggregate`(i think this is `reduce` in c#) have different behaviors in c# `scan` an empty observable will do nothing but `aggregate` will throw a `systeminvalidoperationexception`here are my test codes in c#scan:``` c#observableempty<int>()scan((x y) > x + y)subscribe(                x >                     consolewriteline(""""subscriber got """" + x)            )```aggregate:``` c#observableempty<int>()aggregate((x y) > x + y)subscribe(                x >                     consolewriteline(""""subscriber got """" + x)            )```i also tried the `reduce` method in other languages`list[int]()reduce(_ + _)` will throw `javalangunsupportedoperationexception: emptyreduceleft` in scala`reduce(lambda x y:  x + y )` will throw `reduce() of empty sequence with no initial value` in pythonif reducing an empty observable throws an exception we can implement `min` and `max`  reduce` directly"";""@zsxwing thanks for diving into this  (aside: when you write snippets like this it is a good idea to also look at oncompleted and onerror aggregate does not """"throw"""" an exception but sends out an onerror with an exception and return the empty sequence by immediately calling oncompleted which is not the same as """"do nothing"""" subtle but important to be super precise as we look at the edge cases)var xs  new{ 1 2  3}toobservable()var ys  new int{}toobservable()xsaggregate(accumulator: (xy)>x+y)subscribe( x > consolewriteline(""""[1 2 3]aggregate((xy)>x+1)  {0}"""" x) e > consolewriteline(""""boom  {0}"""" e) () > consolewriteline(""""done""""))// [1 2 3]aggregate((xy)>x+1)  6// doneysaggregate(accumulator: (xy)>x+y)subscribe( x > consolewriteline(""""aggregate((xy)>x+1)  {0}"""" x) e > consolewriteline(""""boom  {0}"""" e) () > consolewriteline(""""done""""))// boom  systeminvalidoperationexception: sequence contains no elementsxsaggregate(seed: 0 accumulator: (xy)>x+y)subscribe(x > consolewriteline(""""[1 2 3]aggregate((xy)>x+1)  {0}"""" x) e > consolewriteline(""""boom  {0}"""" e) () > consolewriteline(""""done""""))// [1 2 3]aggregate((xy)>x+1)  6// doneysaggregate(seed: 0 accumulator:(xy)>x+y)subscribe(x > consolewriteline(""""aggregate((xy)>x+1)  {0}"""" x) e > consolewriteline(""""boom  {0}"""" e) () > consolewriteline(""""done""""))// aggregate((xy)>x+1)  0// donexsaggregate(seed: 0 accumulator: (xy)>x+y resultselector: x > stringformat(""""[{0}]"""" x))subscribe( x > consolewriteline(""""[1 2 3]aggregate((xy)>x+1)  {0}"""" x) e > consolewriteline(""""boom  {0}"""" e) () > consolewriteline(""""done""""))// [1 2 3]aggregate((xy)>x+1)  [6]// doneysaggregate(seed: 0 accumulator:(xy)>x+y resultselector: x > stringformat(""""[{0}]"""" x))subscribe( x > consolewriteline(""""aggregate((xy)>x+1)  {0}"""" x) e > consolewriteline(""""boom  {0}"""" e) () > consolewriteline(""""done""""))// aggregate((xy)>x+1)  [0]// done || no looking at scan i would say that scan in rxnet is brokenin haskell the seed in a scan is sent out as wellprelude> scanl (+) 0 [0]prelude> scanl (+) 0 [123][0136]with no seed the results look like thisprelude> scanl1 (+) [123][136]prelude> scanl1 (+) but in c# the seed is not send outvar xs  new[]{ 1 2  3}toobservable()var ys  new int[]{}toobservable()xsscan(accumulator: (xy)>x+y)subscribe( x > consolewriteline(""""[1 2 3]scan((xy)>x+1)  {0}"""" x) e > consolewriteline(""""boom  {0}"""" e) () > consolewriteline(""""done""""))// [1 2 3]scan((xy)>x+1)  1// [1 2 3]scan((xy)>x+1)  3// [1 2 3]scan((xy)>x+1)  6// doneysscan(accumulator: (xy)>x+y)subscribe( x > consolewriteline(""""[]scan((xy)>x+1)  {0}"""" x) e > consolewriteline(""""boom  {0}"""" e) () > consolewriteline(""""done""""))// donexsscan(seed: 0 accumulator: (xy)>x+y)subscribe(x > consolewriteline(""""[1 2 3]scan((xy)>x+1)  {0}"""" x) e > consolewriteline(""""boom  {0}"""" e) () > consolewriteline(""""done""""))// [1 2 3]scan((xy)>x+1)  1// [1 2 3]scan((xy)>x+1)  3// [1 2 3]scan((xy)>x+1)  6// doneysscan(seed: 0 accumulator:(xy)>x+y)subscribe(x > consolewriteline(""""[]scan((xy)>x+1)  {0}"""" x) e > consolewriteline(""""boom  {0}"""" e) () > consolewriteline(""""done""""))// done || id say we define for once and for all that (see   xsscan(op)lastasync()xsaggregate(e op)  xsscan(e op)lastasync()xsaggregate(e op f)  xsscan(e op)lastasync()map(f) || rxjava misses lastasync() and instead uses takelast(n) which behaves differentlyvar xs  observableempty<int>()xstakelast(1)dump() // oncompleted()xslastasync()dump()// onerror( invalidoperation exception ) || i found  was out of date now rxnet has a blocking version of `last` and `first` and a unblocking version of `lastasync` and `firstasync`here is the document i copy from vs:``` c#        // summary:        //     returns the first element of an observable sequence        //        // parameters:        //   source:        //     source observable sequence        //        // type parameters:        //   tsource:        //     the type of the elements in the source sequence        //        // returns:        //     sequence containing the first element in the observable sequence        //        // exceptions:        //   systemargumentnullexception:        //     source is null        //        //   systeminvalidoperationexception:        //     (asynchronous) the source sequence is empty        public static iobservable<tsource> firstasync<tsource>(this iobservable<tsource> source)        //        // summary:        //     returns the first element of an observable sequence that satisfies the condition        //     in the predicate        //        // parameters:        //   source:        //     source observable sequence        //        //   predicate:        //     a predicate function to evaluate for elements in the source sequence        //        // type parameters:        //   tsource:        //     the type of the elements in the source sequence        //        // returns:        //     sequence containing the first element in the observable sequence that satisfies        //     the condition in the predicate        //        // exceptions:        //   systemargumentnullexception:        //     source or predicate is null        //        //   systeminvalidoperationexception:        //     (asynchronous) no element satisfies the condition in the predicate -or-        //     the source sequence is empty        public static iobservable<tsource> firstasync<tsource>(this iobservable<tsource> source func<tsource bool> predicate)        //        // summary:        //     returns the last element of an observable sequence        //        // parameters:        //   source:        //     source observable sequence        //        // type parameters:        //   tsource:        //     the type of the elements in the source sequence        //        // returns:        //     sequence containing the last element in the observable sequence        //        // exceptions:        //   systemargumentnullexception:        //     source is null        //        //   systeminvalidoperationexception:        //     (asynchronous) the source sequence is empty        public static iobservable<tsource> lastasync<tsource>(this iobservable<tsource> source)        //        // summary:        //     returns the last element of an observable sequence that satisfies the condition        //     in the predicate        //        // parameters:        //   source:        //     source observable sequence        //        //   predicate:        //     a predicate function to evaluate for elements in the source sequence        //        // type parameters:        //   tsource:        //     the type of the elements in the source sequence        //        // returns:        //     sequence containing the last element in the observable sequence that satisfies        //     the condition in the predicate        //        // exceptions:        //   systemargumentnullexception:        //     source or predicate is null        //        //   systeminvalidoperationexception:        //     (asynchronous) no element satisfies the condition in the predicate -or-        //     the source sequence is empty        public static iobservable<tsource> lastasync<tsource>(this iobservable<tsource> source func<tsource bool> predicate)``` || @benjchristensen do we need to add the new rxnet interfaces? || i have an implementation for this ready this will fax the issue for reduce/scan did you see the commentssent from my ipad> on nov 4 2013 at 3:51 am shixiong zhu notifications@githubcom wrote:> > @benjchristensen do we need to add the new rxnet interfaces?> > > reply to this email directly or view it on github || @headinthebox sorry i mean that do we need to add these rxnet interfaces (lastasync firstasync)  into rxjava || @zsxwing yes thats what i meant i have an implementation for them but then recursively found some bugs in other operators || @zsxwing @headinthebox we already have a `first` operator in `observable` that is async:  solved the problem of duplicate naming for blocking/non-blocking in rxjava by separating all blocking operators into the `blockingobservable` class so it is explicit everything on `observable` is non-blocking and returns an observable except for `subscribe` which returns `subscription`the `takelast` operator could have a `last` method aliased to `takelast(1)` in `observable` || > rxjava misses lastasync() and instead uses takelast(n) which behaves differently> var xs  observableempty()> xstakelast(1)dump() // oncompleted()> xslastasync()dump()// onerror( invalidoperation exception )that seems non-obvious why 2 variants of `last` should behave differently regarding error propagation why should `lastasync` behave differently than `takelast(1)` when `last` means """"take the last value"""" should `takelast(1)` emit an error since you have asked for more than are available? same with `takelast(5)` if less than 5 are available? if wanted without errors then `takeuptolast(5)` would take 0-5 items but `takelast(5)` would only take 5 or error || i just realized that the question """"what should the operator do if the source observable does not have enough elements?"""" should be asked for some other operators as well:-    elementat-    reduce(func2<t t t>) and aggregate(func2<t t t>)-    average{longs/floats/doubles}-    min-    max-    skip-    first (2 overloads) and takefirst (2 overloads)-    take-    takelast-    skiplastid prefer that onerror be called instead of ignoring that there were not enough elements thats also what scala collections doand if takelast on an empty observable calls onerror reduce can nicely be implemented using scan || @headinthebox i am not aware of a rule that covers this can you provide an answer for @samuelgruetters question? we can then go build the unit tests and get code to match the rule || elementat > onerror(""""out of range"""")reduce(func2) and aggregate(func2) > thats what started this discussion see aboveaverage{longs/floats/doubles} > same defined as reducemin > > same defined as reducemax > same defined as reduceskip > oncompleted()first (2 overloads) > throws for blocking observable onerror(""""empty sequence"""")and takefirst (2 overloads) > as many elements as it can get ending with oncompletedtake > i think this is an alias for takefirsttakelast > as many elements as it can get ending with oncompletedskiplast > oncompleted || the behavior in rxnet is the same as in haskell except for the bug in scan discussed up hereprelude> take 5 [13][123]etc || i reviewed these operators in rxjava here is my conclusion- `elementat` is correct- `reduce` and `aggregate`  is wrong- `min` and `max` are not implemented however i have already finished it in my branch:   once the reduce issue is  ill send a pr- `average` uses `reduce` for an empty observable it will emit a divisionbyzero error i think this error is not correct it should be something like `unsupportedoperationexception` in rxnet its `systeminvalidoperationexception: sequence contains no elements`- `takefirst` `takelast` `skip` and `skiplast` is correct- blocking `last` is wrong see #464- non-blocking `last` is missing- blocking `first` is missing- non-blocking `first` is wrongplease correct me if i have misunderstood something  || i have completed the blocking and non-blocking `last` impls in  || @zsxwing are you working on any of these others already so we dont duplicate effort? || actually seems like `reduce` is the only one needing fixing as `average` will fix itself once `reduce` is done || the `reduce` operator is now fixed for the empty observable casewhen the observable is empty but a seed is passed in it just emits the seed:``` java    /**     * a reduce on an empty observable and a seed should just pass the seed through     *      * this is confirmed at      */    @test    public void testreducewithemptyobservableandseed() {        observable<integer> observable  observablerange(1 0)        int value  observablereduce(1 new func2<integer integer integer>() {            @override            public integer call(integer t1 integer t2) {                return t1 + t2            }        })toblockingobservable()last()        assertequals(1 value)    }```please confirm that current code and unit test match the expected behavior and then we can close this  or we correct again || there is still a difference between average in rxjava and rxnet when the observable is emptythis is a unit test for average in rxjava``` java    @test    public void testemptyaverage() throws throwable {        observable<integer> src  observableempty()        average(src)subscribe(w)        verify(w never())onnext(anyint())        verify(w times(1))onerror(any(arithmeticexceptionclass))        verify(w never())oncompleted()    }```if the observable is empty average emits an arithmeticexceptionhere is a sample for average in rxnet``` c#            iobservable<double> o  observableempty<int>()average()            osubscribe(                x > consolewriteline(""""onnext: """" + x)                e > consolewriteline(""""onerror: """" + e)                () > consolewriteline(""""done"""")                )```it outputs """"onerror: systeminvalidoperationexception: sequence contains no elements"""" || @benjchristensen now im only working on `min` and `max` operators || i sent the pr #478 for `min` and `max` || i fixed the `average` issue for the empty observable case in #480 please help me confirm it || closed as its fixed || "";1;0;bugfix: throw an illegalargumentexception instead of arithmeticexception if the observable is empty;"
481;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implement the  using  operator;hi  this pr implemented the  using  operator #99. please take a look. thanks!;;99.0;implement the using operator;hi this pr implemented the `using` operator #99 please take a look thanks!;#406  interesting operator  hadnt really ever looked at this onethank you @zsxwing for the implementation! ||;operator: using;http://msdnmicrosoftcom/en-us/library/hh229585(vvs103)aspx;;1;0;implement the using operator;
483;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;doon tweaks;- do not have 2 method overloads with similar method signatures  dynamic languages can not negotiate method dispatch using function arity - add dooncompleted and doonerror methods instead of different dooneach overloads  this is a very slight breaking change by deleting a method added in the last release. i did not catch this when i did the code review.;;0;doon tweaks;- do not have 2 method overloads with similar method signatures dynamic languages can not negotiate method dispatch using function arity- add dooncompleted and doonerror methods instead of different dooneach overloadsthis is a very slight breaking change by deleting a method added in the last release i did not catch this when i did the code review;@nullstyle take note of this as youre planning on refactoring this code somewhat also as an example of design we need to account for due to the polyglot nature of the library || #409;;;;1;1;doon tweaks- do not have 2 method overloads with similar method signatures dynamic languages can not negotiate method dispatch using function arity- add dooncompleted and doonerror methods instead of different dooneach overloads;
486;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;bugfix: asyncsubject;- it was not emitting values to observers that subscribed after oncompleted/onerror;;0;bugfix: asyncsubject;- it was not emitting values to observers that subscribed after oncompleted/onerror;#411 ;;;;1;1;bugfix: asyncsubject- it was not emitting values to observers that subscribed after oncompleted/onerror;
492;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implement the scheduler overloads for range  from  startwith;hi  this pr implemented the scheduler overloads for range #68  from #98   startwith #82. please take a look. thanks!;;68.0;implement the scheduler overloads for range from startwith;hi this pr implemented the scheduler overloads for range #68 from #98  startwith #82 please take a look thanks!;#415  this conflicts and cant merge can you rebase and update the pr please? || i have updated the pr || #420 ;operator: range;http://msdnmicrosoftcom/en-us/library/hh229460(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211896(vvs103)aspx;the first ( is implemented in  second is waiting on schedulers || leaving open for the schedulers implementation ||;1;0;implement the scheduler overloads for range from startwith;
492;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implement the scheduler overloads for range  from  startwith;hi  this pr implemented the scheduler overloads for range #68  from #98   startwith #82. please take a look. thanks!;;82.0;implement the scheduler overloads for range from startwith;hi this pr implemented the scheduler overloads for range #68 from #98  startwith #82 please take a look thanks!;#415  this conflicts and cant merge can you rebase and update the pr please? || i have updated the pr || #420 ;operator: startwith;http://msdnmicrosoftcom/en-us/library/hh229340(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229372(vvs103)aspx;;1;0;implement the scheduler overloads for range from startwith;
492;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implement the scheduler overloads for range  from  startwith;hi  this pr implemented the scheduler overloads for range #68  from #98   startwith #82. please take a look. thanks!;;98.0;implement the scheduler overloads for range from startwith;hi this pr implemented the scheduler overloads for range #68 from #98  startwith #82 please take a look thanks!;#415  this conflicts and cant merge can you rebase and update the pr please? || i have updated the pr || #420 ;operator: toobservable with scheduler;http://msdnmicrosoftcom/en-us/library/hh212140(vvs103)aspx;;1;0;implement the scheduler overloads for range from startwith;
"496;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add contravariant for min and max;hi  this pr added  contravariant for min and max mentioned in #494.;;494.0;add contravariant for min and max;hi this pr added  contravariant for min and max mentioned in #494;#419 ;operators without co- or contravariance;""im looking at the operator definition and found a bunch of places where the """"lambda"""" functions do not have wildcard bounds specified egreduce(func2[t t t])max(comparator[t])etcis there a particular reason these are not:reduce(func2[? super t ? super t ? extends t])max(comparator[? super t])?"";reduce:thats a long story see     and   in short:-    its considered unnecessary (or not necessary enough to complicate the signature)-    note though that the signature of reduce is not entirely correct because the covariant type parameter t appears in a contravariant position so you cant use reduce on an `observable<? extends xxx>`  but only on an `observable<xxx>`  to fix this one would need lower bounds for type parameters but java doesnt support thismin/max:imho it would be a good idea to add wildcards what do others think? || for min/max i agree with you ill fix it || it seems we can close this issue now ||;1;0;add contravariant for min and max;"
499;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;observeon refactor;refactor and small fixes of observeon with @headinthebox;;0;observeon refactor;refactor and small fixes of observeon with @headinthebox;#423 ;;;;1;1;refactored observeon without scheduledobserver;
501;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;parallelmerge operator;;;0;parallelmerge operator;;#425 ;;;;1;1;parallelmerge operator;
502;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix observeon and add parallelmerge scheduler overload;- observeon was not correctly recursing when the source was async. it would create a new scheduler (i.e. a new thread) each time. - also added unit tests to parallelmerge;;0;fix observeon and add parallelmerge scheduler overload;- observeon was not correctly recursing when the source was async it would create a new scheduler (ie a new thread) each time- also added unit tests to parallelmerge;this is debugged and pair programmed with @headinthebox  || #426 ;;;;1;1;fix observeon and add parallelmerge scheduler overload- observeon was not correctly recursing when the source was async it would create a new scheduler (ie a new thread) each time- also added unit tests to parallelmerge;
506;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operators: and  then  when;issue #23  issue #88  issue #100  can be extended to plan4..plan9 and pattern4..pattern9 if action4..action9 is available. not sure about the actionn version.;;100.0;operators: and then when;issue #23 issue #88 issue #100can be extended to plan4plan9 and pattern4pattern9 if action4action9 is available not sure about the actionn version;#430 i dont understand i used the master havent touched groupby or the schedulers the build succeeds on my machine (although with jdk 7) now what?edit: i found the logical error in operationgroupbytest:334 assuming the thread will finish if it emits 29-49 items is unreliable should that assertion be tested at all? || just another case of  the operationgroupbytest test issue has not be  yet || that is an impressive contribution @akarnokd i dont see any problems in my review the unit tests were essential to understanding and trusting this so thank you for being thoroughim going to merge this and leverage the fact that were still pre 10 so that if there are any issues found we can still fix them even if we need to break a signature ||;operator: when;http://msdnmicrosoftcom/en-us/library/hh229558(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229889(vvs103)aspx;;1;0;operators: and then whenissue #23 issue #88 issue #100;
506;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operators: and  then  when;issue #23  issue #88  issue #100  can be extended to plan4..plan9 and pattern4..pattern9 if action4..action9 is available. not sure about the actionn version.;;23.0;operators: and then when;issue #23 issue #88 issue #100can be extended to plan4plan9 and pattern4pattern9 if action4action9 is available not sure about the actionn version;#430 i dont understand i used the master havent touched groupby or the schedulers the build succeeds on my machine (although with jdk 7) now what?edit: i found the logical error in operationgroupbytest:334 assuming the thread will finish if it emits 29-49 items is unreliable should that assertion be tested at all? || just another case of  the operationgroupbytest test issue has not be  yet || that is an impressive contribution @akarnokd i dont see any problems in my review the unit tests were essential to understanding and trusting this so thank you for being thoroughim going to merge this and leverage the fact that were still pre 10 so that if there are any issues found we can still fix them even if we need to break a signature ||;operator: and;http://msdnmicrosoftcom/en-us/library/hh229153(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229905(vvs103)aspx;this operation requires a join-pattern sub-framework to be created (rxjoins) additionally due to method arities this might require action4action9 actionn classes (i have these in pull #505) if decidedhowever i dont quite understand the join patterns as most of the rxnet classes are internal and without documentation i can convert it to java but no idea what tests to create for them ||;1;0;operators: and then whenissue #23 issue #88 issue #100;
506;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operators: and  then  when;issue #23  issue #88  issue #100  can be extended to plan4..plan9 and pattern4..pattern9 if action4..action9 is available. not sure about the actionn version.;;88.0;operators: and then when;issue #23 issue #88 issue #100can be extended to plan4plan9 and pattern4pattern9 if action4action9 is available not sure about the actionn version;#430 i dont understand i used the master havent touched groupby or the schedulers the build succeeds on my machine (although with jdk 7) now what?edit: i found the logical error in operationgroupbytest:334 assuming the thread will finish if it emits 29-49 items is unreliable should that assertion be tested at all? || just another case of  the operationgroupbytest test issue has not be  yet || that is an impressive contribution @akarnokd i dont see any problems in my review the unit tests were essential to understanding and trusting this so thank you for being thoroughim going to merge this and leverage the fact that were still pre 10 so that if there are any issues found we can still fix them even if we need to break a signature ||;operator: then;http://msdnmicrosoftcom/en-us/library/hh211662(vvs103)aspx;;1;0;operators: and then whenissue #23 issue #88 issue #100;
508;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;empty subscribe;;;0;empty subscribe;;#432 ;;;;1;1;empty subscribe;
"512;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;scala adaptor details;with   some files were lost  so i added them again  and i also fixed many other details. there are no changes in functionality/inheritance  only  cosmetics . except  : @headinthebox could you please confirm this one-line change?;;0;scala adaptor details;""with  some files were lost so i added them again and i also  many other details there are no changes in functionality/inheritance only """"cosmetics"""" except  : @headinthebox could you please confirm this one-line change?"";""@headinthebox @samuelgruetter please confirm the two of you agree on this and ill merge || #437  looks good  || found a small bug (copy & paste)object publishsubject {  def apply[t](value: t): publishsubject[t]  {    new publishsubject[t](rxsubjectspublishsubjectcreate%28%29)  }}we need to add as well (and have the above call this one) i use the above to force type inference object publishsubject {  def apply[t](): publishsubject[t]  {    new publishsubject[t](rxsubjectspublishsubjectcreate%28%29)  }} || 2x exactly the same?(btw please indent code by 4 spaces -) ) || @headinthebox i still dont understand what you mean with this [comment]( || this is a trick we often use in c# you pass in a dummy """"witness"""" of type t to help the compiler infer types if you say publishsubject() it will infer publishsubject[nothing] and you are forced tp write publishsubject[t]() i _never_ want to write a concrete type anywhere || with the current code``` scalaobject publishsubject {  def apply[t](): publishsubject[t]  {    new publishsubject[t](rxsubjectspublishsubjectcreate())  }}```we can do the following:``` scalaval s1  publishsubject[int]() // inferred type of s1: publishsubject[int]val s2  publishsubject()      // inferred type of s2: publishsubject[nothing]val s3: publishsubject[int]  publishsubject() // also works```what else do you want to be possible? || so you want to write```val s4  publishsubject(0)```because you prefer writing `0` over writing `int`? thats never done in scala and looks very weird to me || "";;;;1;1;merge branch master of githubcom:netflix/rxjava into scalaadaptor;"
513;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operators tomap and tomultimap again;issue #96 and issue #97  tomap: 3 overloads tomultimap: 4 overloads added groovy test to verify overloading;;96.0;operators tomap and tomultimap again;issue #96 and issue #97tomap: 3 overloadstomultimap: 4 overloadsadded groovy test to verify overloading;#438  ah  this cant merge anymore because of other commits (probably the join operator on your other pr) can you rebase? ||;operator: todictionary;http://msdnmicrosoftcom/en-us/library/hh229137(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh212046(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh212075(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229073(vvs103)aspx;i believe the equivalent to idictionary is a map in java but there are a lot of map classes (linked concurrent etc) which one should be the default value type? is it okay to call the methods observabletomap() ? || i vote for javautilhashmap by default with an overload that lets you pass in a map class of any type you want```public <k v m extends javautilmap<k v>> observable<m> tomap(class<m> mapclass func1<? super t ? extends k> keyselector func1<? super t ? extends v> elementselector) {}```ps: not sure if i got the co/contra-variance right on thatpps: i think the consensus was to ignore equalitycomparators overloads because the idiomatic java way is to implement equals/hashcode on the class || two questions:-    how many times will this operator call onnext? just once or every time it gets a new item?-    are users allowed to modify the returned map? || this is how i did it somewhere else (below):- takes a factory which returns a map instance on subscription- emits the map once the source finishes- no variance on the output observables type``` javapublic class operationtomap {    public static class tomap<t k v> implements onsubscribefunc<map<k v>> {        private final observable<t> source        private final func1<? super t ? extends k> keyselector        private final func1<? super t ? extends v> valueselector        private final func0<? extends map<k v>> mapfactory        public tomap(                observable<t> source                func1<? super t ? extends k> keyselector                func1<? super t ? extends v> valueselector                func0<? extends map<k v>> mapfactory                ) {            thissource  source            thiskeyselector  keyselector            thisvalueselector  valueselector            thismapfactory  mapfactory        }        @override        public subscription onsubscribe(observer<? super map<k v>> t1) {            return sourcesubscribe(new tomapobserver(t1))        }        public class tomapobserver implements observer<t> {            map<k v> map            private final observer<? super map<k v>> t1            public tomapobserver(observer<? super map<k v>> t1) {                map  mapfactorycall()                thist1  t1            }            @override            public void oncompleted() {                map<k v> map0  map                map  null                t1onnext(map0)                t1oncompleted()            }            @override            public void onerror(throwable e) {                map  null                t1onerror(e)            }            @override            public void onnext(t args) {                k key  keyselectorcall(args)                v value  valueselectorcall(args)                mapput(key value)            }        }    }}``` ||;1;0;merge upstream/master into tomapandtomultimap;
513;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operators tomap and tomultimap again;issue #96 and issue #97  tomap: 3 overloads tomultimap: 4 overloads added groovy test to verify overloading;;97.0;operators tomap and tomultimap again;issue #96 and issue #97tomap: 3 overloadstomultimap: 4 overloadsadded groovy test to verify overloading;#438  ah  this cant merge anymore because of other commits (probably the join operator on your other pr) can you rebase? ||;operator: tolookup;http://msdnmicrosoftcom/en-us/library/hh212098(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211805(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229101(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211616(vvs103)aspx;;1;0;merge upstream/master into tomapandtomultimap;
514;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operation join again;issue #56;;0;operation join again;issue #56;#439 ;;;;1;1;merge upstream/master into operationjoin2conflicts:	rxjava-core/src/main/java/rx/observablejava;
518;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;rx java repeat;implementation of repeat.   there is an issue with toblockingobservable when using currentthread().;;0;rx java repeat;implementation of repeat there is an issue with toblockingobservable when using currentthread();#443 as per comment in  this will be looked at again after @headinthebox and i finish some work on schedulers were doing ||;;;;1;1;added test;
525;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;bugfix: handling of terminal state for behavior/publish subjects;- they were not correctly emitting oncompleted when new observers subscribed after the subject was terminated. - added same logic that already existed on asyncsubject;;0;bugfix: handling of terminal state for behavior/publish subjects;- they were not correctly emitting oncompleted when new observers subscribed after the subject was terminated- added same logic that already existed on asyncsubject;#453;;;;1;1;bugfix: handling of terminal state for behavior/publish subjects- they were not correctly emitting oncompleted when new observers subscribed after the subject was terminated- added same logic that already existed on asyncsubject;
526;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;manual merge of tomap/tomultimap;manual merge of https://github.com/netflix/rxjava/pull/513;;0;manual merge of tomap/tomultimap;manual merge of https://githubcom/netflix/rxjava/pull/513;#454;;;;1;1;merge branch tomapandtomultimap of githubcom:akarnokd/rxjava into pull-513-tomapconflicts:	rxjava-core/src/main/java/rx/observablejava;
527;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;docs;javadoc improvements  including diagrams & wiki links for new operators.;;0;docs;javadoc improvements including diagrams & wiki links for new operators;#456;;;;1;1;update observablejavaimprove javadocs including diagrams and wiki links for new operators;
531;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;visually distinguish operators that use schedulers  etc.;visually distinguish operators that use schedulers  add distinct dooneach diagrams;;0;visually distinguish operators that use schedulers etc;visually distinguish operators that use schedulers add distinct dooneach diagrams;#459 ;;;;1;1;visually distinguish operators that use schedulers add distinct dooneach diagrams;
555;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;skipuntil() marble diagram and wiki link in javadoc;;;0;skipuntil() marble diagram and wiki link in javadoc;;#484 ;;;;1;1;skipuntil() marble diagram and wiki link in javadoc;
560;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add type variances for dooneach actions.;this fixes the use of contravariant actions (issue #532);;532.0;add type variances for dooneach actions;this fixes the use of contravariant actions (issue #532);#487  ;dooneach variance;just to make sure we dont forget about this one: `dooneach` & friends still need `? extends t` / `? super t`;this is completed along with a refactoring to having `dooneach` `doonnext` `dooncompleted` and `doonerror` ||;1;0;add type variances for dooneach actionsthis fixes the use of contravariant actions;
561;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;creating observables in scala: approach04;this implements **approach04** from  . i also moved the  toscalaxxx / tojavaxxx  methods into a separate file  so that one can import only these without importing the implicit function conversions.  there s now also  observable.from(future)  and to test it  some tweaks in  notification  were necessary. note that this is a breaking change.;;0;creating observables in scala: approach04;this implements **approach04** from  i also moved the `toscalaxxx`/`tojavaxxx` methods into a separate file so that one can import only these without importing the implicit function conversions theres now also `observablefrom(future)` and to test it some tweaks in `notification` were necessarynote that this is a breaking change;#488  is this a breaking change for scala? || yes || this needs to be rebased since this is breaking it makes sense to merge before releasing 0160 with the other breaking scala changesi would appreciate if you provided release notes for this and the other breaking scala changes to include when i release 0160 || rebasing done || #494;;;;1;1;manually merge branch master of githubcom:netflix/rxjava into scala-constructorsconflicts:	language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/rxscalademoscala	language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/implicitfunctionconversionsscala	language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/observablescala;
563;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operation groupbyuntil;issue #52  rebased.;;52.0;operation groupbyuntil;issue #52rebased;#491 ;operator: groupbyuntil;http://msdnmicrosoftcom/en-us/library/hh211932(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229872(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229433(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229392(vvs103)aspx;groupbyuntil is implemented if we need/want other overloads they can come via new issues ||;1;0;operation groupbyuntil v5;
565;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator groupjoin v2;issue #53  rebased.  still: @headinthebox while writing the test for the operator  i ve noticed that when both duration selectors are never()  rx.net never calls oncompleted on the group subjects  even though the left and right sources oncomplete(). i haven t seen rx.net test for this scenario. this comes into play when i want to emulate join() with groupjoin(): the outer merge never oncompletes(). if i understand the behavior corretly  when both left and right sources get depleted  there is no way a new group or new group value would arrive  and all the open groups and the main observer can be oncompleted(). this is somewhat similar to join() and groupbyuntil() behavior.;;53.0;operator groupjoin v2;issue #53rebasedstill: @headinthebox while writing the test for the operator ive noticed that when both duration selectors are never() rxnet never calls oncompleted on the group subjects even though the left and right sources oncomplete() i havent seen rxnet test for this scenario this comes into play when i want to emulate join() with groupjoin(): the outer merge never oncompletes() if i understand the behavior corretly when both left and right sources get depleted there is no way a new group or new group value would arrive and all the open groups and the main observer can be oncompleted() this is somewhat similar to join() and groupbyuntil() behavior;#493 ;operator: groupjoin;http://msdnmicrosoftcom/en-us/library/hh244235(vvs103)aspx;;1;0;operator groupjoin v2;
567;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operation timestamp with scheduler;issue #93;;0;operation timestamp with scheduler;issue #93;#496 ;;;;1;1;operation timestamp with scheduler;
568;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;use lock free strategy for several subscription implementations;reduce contention by using cas (compare and swap) operations to replace subscription in several subscription implementations.;;0;use lock free strategy for several subscription implementations;reduce contention by using cas (compare and swap) operations to replacesubscription in several subscription implementations;#497  can you use 4-space indent to make this modification more clear? its better that keeping consistent || right there is a potential race condition im going to try to reproduce it via a unit test and find an alternative || i checked nullity because it was checked by the previous code as no unit test was covering nullity cases i chose to keep it compatible with null subscription do you suggest not to check for nullity ? || you need something like this:``` javapublic void setsubscription(final subscription subscription) {    subscription q  null    do {        subscription r  referenceget()        if (r  sentinel) {            q  newreg            break        }        if (referencecompareandset(r subscription)) {            q  r            break        }    } while (true)    if (q ! null) {        qunsubscribe()    }}```similar to [this]( || what about this version using a read/write lock to minimize contention between concurrent setsubscription() calls ? || #498 thanks to akarnokd i could get ride of the atomicboolean and read/write lock using a sentinel || #499 looks good || [rxjava-pull-requests #501 [rxjava-pull-requests #502]( successthis pull request looks good || [rxjava-pull-requests #503]( successthis pull request looks good || we should add isunsubscribed to serialsubscription || not sure if i understand the role of `unsubscribe` it is set to current when you actually unsubscribe (assuming single threaded execution)   sunsubscribe()   ~~>   setsubscription(unsubscribed)   ~~>   current  referenceget()   ~~~> [referencecompareandset(current subscription)  true ]   currentunsubscribe()   ~~~> [subscription  unsubscribed]  unsubscribe  currentnow we do ```ssetsubscription(x)~~~>current  referenceget()~~~> [ current  unsubscribed because we unsubscribed above ]subscriptionunsubscribe()```and then we do```sgetsubscription() ~~~>  subscription  referenceget()  ~~> [ subscription  unsubscribed] return unsubscribe // which was set above to current```so we are returning an arbitrary old subscription when you do getsubscription seems you can do without it``` @override public void unsubscribe() {    setsubscription(unsubscribed) }public void setsubscription(final subscription subscription) {    do {        final subscription current  referenceget()        if (current  unsubscribed) {            subscriptionunsubscribe()            break        }        if (referencecompareandset(current subscription)) {            currentunsubscribe()            if(subscription  unsubscribed) {                    unsubscribe  current            }            break        }    } while (true)}public subscription getsubscription() {        subscription subscription  referenceget()            return subscription  unsubscribed ? unsubscribe : subscription}``` || because we need a way to indicate completion of the subscription and empty is public so clients might swap it in or out reactivating the subscription my example matches the rxnet way || dont get what you say if you are unsubscribed anyway why not return unsubscribed? || sorry i couldnt follow jloisels commits due to the heavy rewriting the field `private volatile subscription unsubscribe` seems to be useless one should return `subscriptionsempty()` when unsubscribedthe `setsubscription(unsubscribed)` is an overkill we could just use `referencegetandset(unsubscribed)` and unsubscribe the returned value if not nullthe correct class should look like this:``` javapublic class serialsubscription implements subscription {    private final atomicreference<subscription> reference  new atomicreference<subscription>()    private static final subscription unsubscribed  new subscription() {        @override        public void unsubscribe() {        }    }    @override    public void unsubscribe() {        subscription q  referencegetandset(unsubscribed)        if (q ! null) {            qunsubscribe()        }    }    public void setsubscription(final subscription subscription) {        subscription q  null        do {            final subscription current  referenceget()            if (current  unsubscribed) {                q  subscription                break            }            if (referencecompareandset(current subscription)) {                q  current                break            }        } while (true)        if (q ! null) {            qunsubscribe()        }    }    public subscription getsubscription() {            subscription subscription  referenceget()            return subscription  unsubscribed ? subscriptionsempty() : subscription    }    public boolean isunsubscribed() {        return referenceget()  unsubscribed    }}``` || headinthebox > unsubscribed is the internal sentinel it should not escape from serialsubscription internal implementation since it could lead to unexpected behaviorwe could another complete different approach: since managing a thread-safe mutable state is difficult shouldnt we make the serial subscription immutable ? i mean:- getsubscription() method violates encapsulation: it lets the internal state escape one could unsubscribe the internal subscription from outside the serial subscription which could lead to double unscribe() if then unscribed from serial- shouldnt serialsubscription be package protected or have at least a static factory method with a private constructor like:```public static subscription serial(final subscription delegate) {    return new serialsubscription(delegate)}```and remove getsubscription() since its never used in the api of course this tends to no backward compatibility on this class since its public || if we tend to have the same behavior as before getsubscription() should return null when previously unscribed || [rxjava-pull-requests #505]( successthis pull request looks good || i think we cannot use subscriptionsempty() as unsubscribed sentinel since it would behave unexpectedly it one sets empty() from outside via setsubscription()i tend also to avoid null references in implementation to avoid unnecessary burden which reduces comprehensionrx-core code base analysis shows that serialsubscription could be easily immutable but it diverges with rx contract: than try to have a complex contract for serialsubscription i would give a try to make it immutable immutable is thread-safe by nature as well as contention free || oh it seems like due to cyclic dependencies (like on resultsink) its not possible to make it immutable || [rxjava-pull-requests #525]( successthis pull request looks good || looks like an improvement on current implementation and dont see problems using a state machine here is far preferable to the previous lock based implementation  this should help or fix  ||;;;;1;1;use non-locking state machine based on atomic reference;
"569;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;javadoc improvements (groupjoin  groupbyuntil  timestamp w/scheduler);adding marble diagrams and links to the rxjava wiki  standardizing javadoc comment formatting;;0;javadoc improvements (groupjoin groupbyuntil timestamp w/scheduler);adding marble diagrams and links to the rxjava wiki standardizing javadoc comment formatting;""#500  @davidmgross it would be nice to have a separate diagram for this overload of zip:``` javapublic static <r> observable<r> zip(observable<? extends observable<?>> ws funcn<? extends r> zipfunction)```today i wanted to explain this operator to some people and a nice marble diagram for this would have been useful as `zipfunction` maybe just take a `func3` which puts its 3 arguments into one """"box"""" || ill see what i can come up withon fri dec 6 2013 at 4:43 am samuelgruetter notifications@githubcomwrote:> @davidmgross  it would be nice to have a> separate diagram for this overload of zip:> > public static <r> observable<r> zip(observable<? extends observable<?>> ws funcn<? extends r> zipfunction)> > today i wanted to explain this operator to some people and a nice marble> diagram for this would have been useful as zipfunction maybe just take> a func3 which puts its 3 arguments into one """"box""""> > > reply to this email directly or view it on github ## david m grossplp consulting || how does this look? fri dec 6 2013 at 9:59 am plp consulting (david gross) <davgross@netflixcom> wrote:> ill see what i can come up with> > on fri dec 6 2013 at 4:43 am samuelgruetter notifications@githubcomwrote:> > > @davidmgross  it would be nice to have a> > separate diagram for this overload of zip:> > > > public static <r> observable<r> zip(observable<? extends observable<?>> ws funcn<? extends r> zipfunction)> > > > today i wanted to explain this operator to some people and a nice marble> > diagram for this would have been useful as zipfunction maybe just take> > a func3 which puts its 3 arguments into one """"box""""> > > > > > reply to this email directly or view it on github > > > ## > > david m gross> plp consulting## david m grossplp consulting || nice! two ideas for improvement:-    having the three observables overlap each other in time would make the diagram more instructive-    `-->` binds stronger than `` in most languages so you really should add parentheses ie write `zip{ ( cloud circle triangle ) --> triangle }` because otherwise it is read as `zip{ cloud circle (triangle --> triangle) }` this confused me a lot even though i already knew the semantics of the operator || good suggestions  ill see what i can doon sun dec 8 2013 at 7:12 am samuelgruetter notifications@githubcomwrote:> nice! two ideas for improvement:> - having the three observables overlap each other in time would make>   the diagram more instructive> - --> binds stronger than  in most languages so you really should>   add parentheses ie write zip{ ( cloud circle triangle ) -->>   triangle } because otherwise it is read as zip{ cloud circle>   (triangle --> triangle) } this confused me a lot even though i>   already knew the semantics of the operator> > > reply to this email directly or view it on github ## david m grossplp consulting || "";;;;1;1;javadoc improvements (groupjoin groupbyuntil timestamp w/scheduler);"
571;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operation sample with observable v2;issue #74 - sample will terminate if either the source or the sampler terminates or throws an error. - the sampler now emits values only in its onnext() method. therefore  if the sampler completes and there is a sampled value available ( valuetaken == false )  it won t emit the value before terminating.;;74.0;operation sample with observable v2;issue #74- sample will terminate if either the source or the sampler terminates or throws an error- the sampler now emits values only in its onnext() method therefore if the sampler completes and there is a sampled value available (`valuetaken  false`) it wont emit the value before terminating;#506 ;operator: sample;http://msdnmicrosoftcom/en-us/library/hh211615(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211892(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229742(vvs103)aspx;still have one overload to do:``` c#public static iobservable<tsource> sample<tsource tsample>(    this iobservable<tsource> source    iobservable<tsample> sampler)``` || i can take this || done ||;1;0;operation sample with observable v2;
574;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;clarify documentation on cache();i lost some time because i didn t read the documentation of  cache()  carefully enough. to make it easier for others  i tried to make the documentation more explicit here.;;0;clarify documentation on cache();i lost some time because i didnt read the documentation of `cache()` carefully enough to make it easier for others i tried to make the documentation more explicit here;#511 ;;;;1;1;clarify documentation on cache();
"575;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;reimplement the  sequenceequal  operator;hi  this pr reimplemented the  sequenceequal  operator #76 and should fix the issue #564.  the wiki page  still needs to be updated. @davidmgross could you help update the marble diagram of  sequenceequal ? thanks!;;564.0;reimplement the sequenceequal operator;hi this pr reimplemented the `sequenceequal` operator #76 and should fix the issue #564the wiki page  still needs to be updated @davidmgross could you help update the marble diagram of `sequenceequal`? thanks!;#512  okay i think ive got it corrected it only covers one condition so mightbenefit from having some more examples but itll do for nowon fri dec 6 2013 at 7:13 am cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #512 this pull request looks good> > > reply to this email directly or view it on github ## david m grossplp consulting || @davidmgross looks cool  #514 good job just a few things - you are using `gate` to ensure concurrency and you access the `firstdone` and `seconddone` while synchronizing over `gate` i believe these two can be simple boolean fields instead of atomicbooleans- you are setting the `firstvalues` and `secondvalues` in the `init` method into a volatile fields i believe these can be moved into the constructor and set to a regular `private final list` type and accessor - [optional] you might want to call clear on both `firstvalues` and `secondvalues` if there was a termination condition so they dont hold onto queued values until the client observer disappears || i really think that `sequenceequal` should be implemented in terms of other operators dont reinvent the wheel with every operator you add -)in scala id do it like this:``` scaladef sequenceequal[t](o1: observable[t] o2: observable[t]): observable[boolean]  {  val obs1: observable[option[t]]  o1map(some(_)) ++ observable(none) // ++ is concat  val obs2: observable[option[t]]  o2map(some(_)) ++ observable(none)  // if different length comparing the `none` of the shorter with `some(element)`   // of the longer will return false  (obs1 zip obs2)forall(pair > pair_1  pair_2)}``` || @samuelgruetter  great idea really thanks i overrode the previous commit as their is no option in java i use notification instead || #515 looks good || i also have a question about `notificationhasvalue```` java    /**     * retrieves a value indicating whether this notification has a value     *      * @return a value indicating whether this notification has a value     */    public boolean hasvalue() {        return isonnext() && value ! null    }```here it checks if value is not null but i think value can be nulli also checked the rxnet codes here:  c#            /// <summary>            /// returns true            /// </summary>            public override bool hasvalue { get { return true } }```it returns true directly in `onnextnotification`if `notificationhasvalue` has the same meaning in rxjava and rxnet i think `&& value ! null` needs to be removed || [rxjava-pull-requests #516]( successthis pull request looks good || much nicer now -)regarding hasvalue: i dont know what is it good for if its the same as isonnext? and why would one need the current version? imho it could just be removedsomething else regarding null values and sequenceequal with default equality: i think you shouldnt call onerror(nullpointerexception) but just onnext(true) or onnext(false) || @samuelgruetter thanks for reminding me the null issue || [rxjava-pull-requests #517]( successthis pull request looks good ||;different behaviors of `sequenceequal` in rxnet and rxjava;""looks `sequenceequal` in rxjava is not correct in rxnet `sequenceequal` returns an observable which only has one element indicating if these two sequences are same for example``` c#            var o  observablesequenceequal(observablerange(1 100) observablerange(1 100))            var s  osubscribe(                v > consolewriteline(""""equal  """" + v)                e >  consolewriteline(e)                () > consolewriteline(""""oncompleted"""")                )            consolewriteline(""""press any key"""")            consolereadkey()```outputs:<pre>equal  trueoncompletedpress any key</pre>but in rxjava the following codes:``` java        observable                sequenceequal(observablerange(1 100)                        observablerange(1 100))toblockingobservable()                foreach(new action1<boolean>() {                    @override                    public void call(boolean t1) {                        systemoutprintln(t1)                    }                })```output 100 `true`s"";ive noticed that using `zip` to pair up values is not the same behavior as in rxnet in rxnet the operator checks if the length of the streams are the same or not even if we dont want to do that one could add a simple `all` operator after the zip:``` javapublic static <t> observable<boolean> sequenceequal(observable<? extends t> first         observable<? extends t> second func2<? super t ? super t boolean> equality) {    return zip(first second equality)all(functions<boolean>identity())}```using the materialized view is not an option as errors need to be propagated directly and not compared (and generally equals doesnt work on throwables) || i can take this this weekend ||  in #575 ||;1;0;fix the null issue in the default equality;"
"575;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;reimplement the  sequenceequal  operator;hi  this pr reimplemented the  sequenceequal  operator #76 and should fix the issue #564.  the wiki page  still needs to be updated. @davidmgross could you help update the marble diagram of  sequenceequal ? thanks!;;76.0;reimplement the sequenceequal operator;hi this pr reimplemented the `sequenceequal` operator #76 and should fix the issue #564the wiki page  still needs to be updated @davidmgross could you help update the marble diagram of `sequenceequal`? thanks!;#512  okay i think ive got it corrected it only covers one condition so mightbenefit from having some more examples but itll do for nowon fri dec 6 2013 at 7:13 am cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #512 this pull request looks good> > > reply to this email directly or view it on github ## david m grossplp consulting || @davidmgross looks cool  #514 good job just a few things - you are using `gate` to ensure concurrency and you access the `firstdone` and `seconddone` while synchronizing over `gate` i believe these two can be simple boolean fields instead of atomicbooleans- you are setting the `firstvalues` and `secondvalues` in the `init` method into a volatile fields i believe these can be moved into the constructor and set to a regular `private final list` type and accessor - [optional] you might want to call clear on both `firstvalues` and `secondvalues` if there was a termination condition so they dont hold onto queued values until the client observer disappears || i really think that `sequenceequal` should be implemented in terms of other operators dont reinvent the wheel with every operator you add -)in scala id do it like this:``` scaladef sequenceequal[t](o1: observable[t] o2: observable[t]): observable[boolean]  {  val obs1: observable[option[t]]  o1map(some(_)) ++ observable(none) // ++ is concat  val obs2: observable[option[t]]  o2map(some(_)) ++ observable(none)  // if different length comparing the `none` of the shorter with `some(element)`   // of the longer will return false  (obs1 zip obs2)forall(pair > pair_1  pair_2)}``` || @samuelgruetter  great idea really thanks i overrode the previous commit as their is no option in java i use notification instead || #515 looks good || i also have a question about `notificationhasvalue```` java    /**     * retrieves a value indicating whether this notification has a value     *      * @return a value indicating whether this notification has a value     */    public boolean hasvalue() {        return isonnext() && value ! null    }```here it checks if value is not null but i think value can be nulli also checked the rxnet codes here:  c#            /// <summary>            /// returns true            /// </summary>            public override bool hasvalue { get { return true } }```it returns true directly in `onnextnotification`if `notificationhasvalue` has the same meaning in rxjava and rxnet i think `&& value ! null` needs to be removed || [rxjava-pull-requests #516]( successthis pull request looks good || much nicer now -)regarding hasvalue: i dont know what is it good for if its the same as isonnext? and why would one need the current version? imho it could just be removedsomething else regarding null values and sequenceequal with default equality: i think you shouldnt call onerror(nullpointerexception) but just onnext(true) or onnext(false) || @samuelgruetter thanks for reminding me the null issue || [rxjava-pull-requests #517]( successthis pull request looks good ||;operator: sequenceequal;http://msdnmicrosoftcom/en-us/library/hh229024(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh212108(vvs103)aspx;""looking at these implementations it seems that by using zip it will emit a sequence of true/false values rather than a single boolean specifying if the entire sequence is true/falsei think it is supposed to emit only a single value based on reading the msdn docs@mairbek if you re-read the docs is it supposed to be a single value or sequence of values emitted? if single can you submit a fix? probably a reduce type function that keeps going until it finds a false otherwise if it hits oncomplete/onerror the same on both sides it returns true  || @benjchristensen okay ill submit the patch || reduce doesnt seems to be a good choice in this case since it would wait for all pairs of events even if first two were differenti will start by implementing all operation #21 and applying it to a `zip` of two observables || okay  this happens to be more complicated that ive expectedive come up with a test case that fails on `all` + `zip` implementation looks like `zip` operation completes the observation as fast as first observable completes which leads to wrong behaviour of `sequenceequal` operation``` java        @test        public void testsequenceequal3() {            observable<integer> first  observabletoobservable(1 2)            observable<integer> second  observabletoobservable(1 2 3)            @suppresswarnings(""""unchecked"""")            observer<boolean> result  mock(observerclass)            sequenceequal(first second)subscribe(result)            verify(result times(1))onnext(false)            verify(result times(1))oncompleted()            verifynomoreinteractions(result)        }``` || done || "";1;0;fix the null issue in the default equality;"
587;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operation longcount;issue #60  straightforward version of the regular count().   (however  i would have implemented it differently so the constant boxing-unboxing could be avoided.);;60.0;operation longcount;issue #60straightforward version of the regular count() (however i would have implemented it differently so the constant boxing-unboxing could be avoided);#524 ;operator: longcount; we really need count and longcount?perhaps count should just use a long so we only need one of them?;;1;0;operation longcount;
"593;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;lock-free subscriptions;- uniform naming of inner components: issue #592 - lock-free approach to avoid deadlocks: issue #577 - serialsubscription.isunsubscribe added: issue #590  remarks: - imo  an unsubscribed single/serial/multiple subscription return subscriptions.empty() instead of null. so unless the user put a null in there he/she shouldn t worry about null. - there was a concurrency bug in @jloisel  s reimplementation of compositesubscription. it allowed multiple threads to enter the mutation part if the current state was already mutate. i ve added the necessary checks to allow only normal -> mutate transitions.;;577.0;lock-free subscriptions;- uniform naming of inner components: issue #592- lock-free approach to avoid deadlocks: issue #577- serialsubscriptionisunsubscribe added: issue #590remarks:- imo an unsubscribed single/serial/multiple subscription return subscriptionsempty() instead of null so unless the user put a null in there he/she shouldnt worry about null- there was a concurrency bug in @jloisel s reimplementation of compositesubscription it allowed multiple threads to enter the mutation part if the current state was already mutate ive added the necessary checks to allow only normal -> mutate transitions;""it cannot return subscriptionsempty() since the rx contract is to return null also returning empty() when unsubscribed is ambiguous: has it been unsubscribed or has empty() been set by the client code ? || #527  good that you  the race condition in multipleassignementsubscription as well as the contract (it was unsubscribing the previous subscription although it shouldnt) || ive checked the rxnet sources:- singleassignmentdisposable returns defaultdisposableinstance- serialdisposabe returns null- refcountdisposable returns disposableempty- scheduleddisposable returns defaultdisposableinstanceso my question is why only serialdisposable returns null? checking the return of the getsubscription to determine if unsubscription happened is wrong since serialsubscription can be started with null this is why `isunsubscribed()` is to be used to check the state || > it cannot return subscriptionsempty() since the rx contract is to return nulli dont think that is actually this strict that is what the implementation does i think it is better to return empty than null the real """"state"""" is is isunsubscribed (and the properties might as well be write-only) || i think the disposable / subscription contract lakes precision and uniformity it doesnt matter to return null or empty what matters is a constant behavior following the """"least astonishment"""" principle || "";deadlock in 015x between multipleassignmentsubscription and compositesubscription;""heres the relevant thread dump:""""rxcomputationthreadpool-8"""":    at rxsubscriptionscompositesubscriptionunsubscribe(compositesubscriptionjava:100)    - waiting to lock <0x00007f2a2846be00> (a rxsubscriptionscompositesubscription)    at rxsubscriptionsmultipleassignmentsubscriptionunsubscribe(multipleassignmentsubscriptionjava:43)    - locked <0x00007f2a26de2a80> (a rxsubscriptionsmultipleassignmentsubscription)    at rxsubscriptionscompositesubscriptionadd(compositesubscriptionjava:92)    - locked <0x00007f2a2846be60> (a rxsubscriptionscompositesubscription)    at rxconcurrencyexecutorscheduler$4run(executorschedulerjava:128)    at javautilconcurrentexecutors$runnableadaptercall(executorsjava:471)    at javautilconcurrentfuturetask$syncinnerrun(futuretaskjava:334)    at javautilconcurrentfuturetaskrun(futuretaskjava:166)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskaccess$201(scheduledthreadpoolexecutorjava:178)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:292)    at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1145)    at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:615)    at javalangthreadrun(threadjava:724)""""rxcomputationthreadpool-7"""":    at rxsubscriptionsmultipleassignmentsubscriptionunsubscribe(multipleassignmentsubscriptionjava:40)    - waiting to lock <0x00007f2a26de2a80> (a rxsubscriptionsmultipleassignmentsubscription)    at rxsubscriptionscompositesubscriptionadd(compositesubscriptionjava:92)    - locked <0x00007f2a2846be00> (a rxsubscriptionscompositesubscription)    at rxconcurrencyexecutorscheduler$4run(executorschedulerjava:128)    at javautilconcurrentexecutors$runnableadaptercall(executorsjava:471)    at javautilconcurrentfuturetask$syncinnerrun(futuretaskjava:334)    at javautilconcurrentfuturetaskrun(futuretaskjava:166)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskaccess$201(scheduledthreadpoolexecutorjava:178)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:292)"";in english:2 compositesubscriptions (denoted using last 2 letters of memory address): 00 and 601 multipleassignmentsubscription : 80thread 7:composite-00addmultipleassignment-80unsubscribethread 8:composite-60addmultipleassignment-80unsubscribecomposite-00unsubscribeso i believe there are 2 bugs here - a circular reference between subscriptions and a deadlock when unsubscribes happen on circular subscriptions || also based on our codebase rolling back to 01410 did not exhibit the problem (yet)  we also believe that the schedulerschedule(action1) method is the one creating the multipleassignmentsubscription (the only other places are operationretry and operationswitch) || generally unsubscribing should not happen while holding locks especially inside these subscription instances ill take a look at them || thanks for the really quick work @akarnokd  once weve got the next release of rxjava into our codebase well let you know if the issue is resolved   || should be  in  ||;1;0;lock-free subscriptions;"
"593;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;lock-free subscriptions;- uniform naming of inner components: issue #592 - lock-free approach to avoid deadlocks: issue #577 - serialsubscription.isunsubscribe added: issue #590  remarks: - imo  an unsubscribed single/serial/multiple subscription return subscriptions.empty() instead of null. so unless the user put a null in there he/she shouldn t worry about null. - there was a concurrency bug in @jloisel  s reimplementation of compositesubscription. it allowed multiple threads to enter the mutation part if the current state was already mutate. i ve added the necessary checks to allow only normal -> mutate transitions.;;590.0;lock-free subscriptions;- uniform naming of inner components: issue #592- lock-free approach to avoid deadlocks: issue #577- serialsubscriptionisunsubscribe added: issue #590remarks:- imo an unsubscribed single/serial/multiple subscription return subscriptionsempty() instead of null so unless the user put a null in there he/she shouldnt worry about null- there was a concurrency bug in @jloisel s reimplementation of compositesubscription it allowed multiple threads to enter the mutation part if the current state was already mutate ive added the necessary checks to allow only normal -> mutate transitions;""it cannot return subscriptionsempty() since the rx contract is to return null also returning empty() when unsubscribed is ambiguous: has it been unsubscribed or has empty() been set by the client code ? || #527  good that you  the race condition in multipleassignementsubscription as well as the contract (it was unsubscribing the previous subscription although it shouldnt) || ive checked the rxnet sources:- singleassignmentdisposable returns defaultdisposableinstance- serialdisposabe returns null- refcountdisposable returns disposableempty- scheduleddisposable returns defaultdisposableinstanceso my question is why only serialdisposable returns null? checking the return of the getsubscription to determine if unsubscription happened is wrong since serialsubscription can be started with null this is why `isunsubscribed()` is to be used to check the state || > it cannot return subscriptionsempty() since the rx contract is to return nulli dont think that is actually this strict that is what the implementation does i think it is better to return empty than null the real """"state"""" is is isunsubscribed (and the properties might as well be write-only) || i think the disposable / subscription contract lakes precision and uniformity it doesnt matter to return null or empty what matters is a constant behavior following the """"least astonishment"""" principle || "";serialsubscription is missing isunsubscribed;public class serialsubscription implements subscription {    @override    public void unsubscribe() {}}    public void setsubscription(final subscription subscription) {}      public subscription getsubscription() {}}http://msdnmicrosoftcom/en-us/library/systemreactivedisposablesserialdisposable_properties(vvs103)aspx; in  ||;1;0;lock-free subscriptions;"
"593;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;lock-free subscriptions;- uniform naming of inner components: issue #592 - lock-free approach to avoid deadlocks: issue #577 - serialsubscription.isunsubscribe added: issue #590  remarks: - imo  an unsubscribed single/serial/multiple subscription return subscriptions.empty() instead of null. so unless the user put a null in there he/she shouldn t worry about null. - there was a concurrency bug in @jloisel  s reimplementation of compositesubscription. it allowed multiple threads to enter the mutation part if the current state was already mutate. i ve added the necessary checks to allow only normal -> mutate transitions.;;592.0;lock-free subscriptions;- uniform naming of inner components: issue #592- lock-free approach to avoid deadlocks: issue #577- serialsubscriptionisunsubscribe added: issue #590remarks:- imo an unsubscribed single/serial/multiple subscription return subscriptionsempty() instead of null so unless the user put a null in there he/she shouldnt worry about null- there was a concurrency bug in @jloisel s reimplementation of compositesubscription it allowed multiple threads to enter the mutation part if the current state was already mutate ive added the necessary checks to allow only normal -> mutate transitions;""it cannot return subscriptionsempty() since the rx contract is to return null also returning empty() when unsubscribed is ambiguous: has it been unsubscribed or has empty() been set by the client code ? || #527  good that you  the race condition in multipleassignementsubscription as well as the contract (it was unsubscribing the previous subscription although it shouldnt) || ive checked the rxnet sources:- singleassignmentdisposable returns defaultdisposableinstance- serialdisposabe returns null- refcountdisposable returns disposableempty- scheduleddisposable returns defaultdisposableinstanceso my question is why only serialdisposable returns null? checking the return of the getsubscription to determine if unsubscription happened is wrong since serialsubscription can be started with null this is why `isunsubscribed()` is to be used to check the state || > it cannot return subscriptionsempty() since the rx contract is to return nulli dont think that is actually this strict that is what the implementation does i think it is better to return empty than null the real """"state"""" is is isunsubscribed (and the properties might as well be write-only) || i think the disposable / subscription contract lakes precision and uniformity it doesnt matter to return null or empty what matters is a constant behavior following the """"least astonishment"""" principle || "";serialsubscription and singleassignementsubscription naming subscriptions in general;serialsubscription hasprivate static final subscription unsubscribed  new subscription() {singleassignmentsubscription hasprivate static final subscription sentinel  new subscription() {for the same purposealso these use lockfree implementations the other subscriptions use locksperhaps someone can go over all subscriptions and implement them in the same style and using the same naming conventions;i have to rebase my subscription changes anyway so ill do the renaming to unsubscribed_sentinel || i may help again to use lock free strategy in other subscription implementations || @akarnod you should be able to have serialsubscription inherit from multipleassignmentsubscription the difference is that the latter unsubscribes when swapping in a new subscription i think that would show the intent better and make the code more maintanablein fact i think multipleassignmentsubscription itself can inherit from booleansubscription || i dont know i can create many prs for all kinds of variants but at the end @benjchristensen has to decide id rather avoid look-and-feel development ||;1;0;lock-free subscriptions;"
"594;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implement the  start  operator;hi  this pr implemented the  start  operator #81. please take a look.;;81.0;implement the start operator;hi this pr implemented the `start` operator #81 please take a look;""#528  nice! so `observablestart(func0)` might become the new way of creating futures maybe add some tests which illustrate what happens if i subscribe to `observablestart` before/while/after its calculation has terminated and what happens if there are several subscribers (i think its correctly implemented but just to make everything more stable and better documented) || thanks @samuelgruetter  i added more tests is it necessary to construct a special test that `subscribe` and `func` run at the same time? i think """"before"""" and """"after"""" are enough || #533 #537 looks good || "";operator: start;http://msdnmicrosoftcom/en-us/library/hh229265(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211971(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229036(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211721(vvs103)aspx;it would be nice to have the `start` operator not only for `action0` but also for `func0` with this we could use the java observable to simulate futures:``` javaobservable<integer> future  observablestart(new func0<integer>() {    public integer call() {        return someexpensivecalculation()    }} schedulersthreadpoolforcomputation())``` || implemented and then moved to async-util contrib module:  ||;1;0;remove the action0 overloads;"
597;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;javadoc updates (longcount  sample(sampler));;;0;javadoc updates (longcount sample(sampler));;#531 ;;;;1;1;* corrects grammar of sequenceequal() javadoc* updates link to wiki description of count()* adds sample(sampler) marble diagram/wiki link* adds longcount() marble diagram/wiki link;
599;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;refactor rx.concurrency to rx.schedulers;to match the naming convention of rx.observables  rx.subjects and rx.subscriptions we have decided to rename rx.concurrency to rx.schedulers prior to the 1.0 release. these commits makes this change.  since this is a non-trivial breaking change to anyone using schedulers  this leaves the  rx.concurrency.*  classes in place and deprecates them to give time to migrate. these deprecated classes will be deleted prior to the 1.0 release.;;0;refactor rxconcurrency to rxschedulers;to match the naming convention of rxobservables rxsubjects and rxsubscriptions we have decided to rename rxconcurrency to rxschedulers prior to the 10 release these commits makes this changesince this is a non-trivial breaking change to anyone using schedulers this leaves the `rxconcurrency*` classes in place and deprecates them to give time to migrate these deprecated classes will be deleted prior to the 10 release;#534 ;;;;1;1;add missing license headers;
600;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;bugfix: replay subject;;;0;bugfix: replay subject;;#536 ;;;;1;1;544 replaysubject emits items received after onerror;
"602;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;observeon fixes;- refactor to remove imperative assignment of innerscheduler for clearer concurrency and data access - fix subscription leak (composite+multipleassignment instead of just composite) - remove confusing conditional logic for inner/outer scheduler;;0;observeon fixes;- refactor to remove imperative assignment of innerscheduler for clearer concurrency and data access- fix subscription leak (composite+multipleassignment instead of just composite)- remove confusing conditional logic for inner/outer scheduler;""#538] @akarnokd good question but in your code you would call onerror on the same observer which is strange and then the call to onerror can fail itselfwhat you propose is when the onnext of an observer in a subscribe fails you would call the onerror of that same observer || @headinthebox true maybe the `notaccept` needs to be altered or left out entirely and `not` switch-cased  here with the proper handling of onerror throws case || generally `onnext` errors are left to the outer `safeobserver` wrapper to handle and only user-provided functions are directly handled there may be an edge-case to make this work though since were hopping threads ill need to play with some unit testssee here for where the on\* methods are handled:  is the `safeobserver` handling the `onnext` failure:  then if `onerror` fails it handles it as well:  is not logic we want to replicate everywhere nor should we need to do this at every layer of wrapping which is why we only add it to externally provided `observer` instances || this unit test suggests that the error handling is working okay due to `safeobserver` wrapping the user provided `observer`:``` java    /**     * test that an error from a user provided observeronnext is handled and emitted to the onerror     * even when done across thread boundaries with observeon     */    @test    public void testonnexterroracrossthread() throws interruptedexception {        final countdownlatch latch  new countdownlatch(1)        final atomicreference<throwable> caughterror  new atomicreference<throwable>()        observable<long> o  observableinterval(50 timeunitmilliseconds)        observer<long> observer  new observer<long>() {            @override            public void oncompleted() {                systemoutprintln(""""completed"""")                latchcountdown()            }            @override            public void onerror(throwable e) {                systemoutprintln(""""error: """" + e)                caughterrorset(e)                latchcountdown()            }            @override            public void onnext(long args) {                throw new runtimeexception(""""forced failure"""")            }        }        oobserveon(schedulersnewthread())subscribe(observer)        latchawait(2000 timeunitmilliseconds)        assertnotnull(caughterrorget())    }```is there some use case im missing? || #545] a bit unexpected in rxjavaval xs  observablefrom(1 to 200 newthreadscheduler())subscribe(     x > { throw new exception(""""boom"""") }     e > { println(egetmessage) throw e })prints """"boom""""in net it throws the exception on the worker thread || which is unexpected net or java behavior? || the java behavior you cannot totally guard against exceptions thrown in user-supplied subscribe  what happens when an exception is thrown in oncompleted or in onerror on in when the onerror that get invoked because the onnext threw throws(similarly when you inside observablecreate() you have to catch exceptions inside closures) || it correctly will throw on the thread if the `onerror` handler also failsif they have a valid `onerror` handler why would we not want to call it? thats completely unexpected for an error to be thrown when they have provided a valid `onerror` handler thus we always try and pass to `onerror` and only if that also fails then throw on whatever random thread its onsee here:  || imho it give a false sense of security and it is unpredictable when you see xssubscribe() it may (a) call onerror (b) swallow the exception (c) throw on a random thread or (d) (a) and (b) or (e) (a) and (c)which is not any better than not doing anything special since then you have the same set of outcomes || yes it may result in that if the user implemented both a bad onnext and onerror but that is a valid case for unexpected behavior we found in production that it was a real surprise and problem when onnext errors werent propagated to onerror because we teach everyone that when using rx all errors will be propagated to onerror also when people do things right and push side-effects into the subscribe onnext its easy to get failures there but very rarely is their onerror handler complex enough to also fail in short catching an onnext failure and propagating to onerror is the least surprising way of propagating errors and handles the most common cases if someones inerror handler is also broken we have no choice but to throw but then do so with a message that very clearly states how bad that is and what happened im going to proceed with this merge and we can discuss safeobserver behavior elsewhere as it is a different topic than this  || no im not going to merge  unit tests arent passing on this but they are on the master branch :-) || go ahead || this change has caused non-determinism with the following unit tests:```rxoperatorsoperationparalleltest > testparallelrxoperatorsoperationparallelmergetest > testnumberofthreadsrxoperatorsoperationmergedelayerrortest > testcompositeerrordelayed2rxoperatorsoperationparallelmergetest > testnumberofthreadsonscheduledmergerxoperatorsoperationgroupbytest > testerror``` || i have revised this pull request the previous update was accidentally subscribing to the source observable on the new thread instead of only observing on the new threadi reverted the code added the unit tests and then refactored to just fix the subscription leak otherwise the structure is similar as before || #552  "";;;;1;1;observeon fixes- fix subscription leak (composite+multipleassignment instead of just composite)- add unit tests;"
607;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;javadoc improvements:;- consistent nomenclature - consistent/standard javadoc formatting - more-precise descriptions - timer() marble digram & wiki link - delay() marble diagram & wiki link;;0;javadoc improvements:;- consistent nomenclature- consistent/standard javadoc formatting- more-precise descriptions- timer() marble digram & wiki link- delay() marble diagram & wiki link;#544 ;;;;1;1;javadoc improvements:* consistent nomenclature* consistent/standard javadoc formatting* more-precise descriptions* timer() marble digram & wiki link* delay() marble diagram & wiki link;
609;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operation timer 3.0;rebased.;;0;operation timer 30;rebased;#546 ;;;;1;1;operation timer 30;
"612;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;replay additional overloads;issue #71 - added several overloads of the  replay  operator:    - limited buffer  limited time window  buffer+time     - scheduler overloads     - versions which perform a projection before the replay - added missing  multicast  overload;;71.0;replay additional overloads;issue #71- added several overloads of the `replay` operator:   - limited buffer limited time window buffer+time   - scheduler overloads   - versions which perform a projection before the replay- added missing `multicast` overload;""#548  could you give me an explanation of what the """"selector"""" does and why itsuseful and also what the version of replay that uses a subject factory isall about?  the javadocs are opaque to me and the msdn docs / intro-to-rxarent helpful eitheron thu dec 12 2013 at 12:53 pm cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #548 this pull request looks good> > > reply to this email directly or view it on github ## david m grossplp consulting || im not sure myself i think it allows transforming the subjects output without the danger of resubscribing to the uplink source i couldnt find any tests for them in the rxnet sources || "";operator: replay;http://msdnmicrosoftcom/en-us/library/hh229288(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211976(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211699(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229232(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229814(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229874(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211811(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211759(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229653(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211675(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh211644(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229526(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229928(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh228952(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh244327(vvs103)aspxhttp://msdnmicrosoftcom/en-us/library/hh229404(vvs103)aspx;good intro here:  || we only have the single `replay` method implemented missing all of the overloads || ill take these || done ||;1;0;operation: replay additional overloads;"
617;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;replay() and timer() javadocs: diagrams & wiki links;;;0;replay() and timer() javadocs: diagrams & wiki links;;#551 ;;;;1;1;replay() and timer() javadocs: diagrams & wiki links;
621;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;serialsubscription & from;update scala bindings for serialsubscription since underlying type now implements isunsubscribed.  changed observable.from to use currentthreadscheduler (principle of least surprise). used scheduler in create instead of observeron. fixed blocking tests.;;0;serialsubscription & from;update scala bindings for serialsubscription since underlying type now implements isunsubscribedchanged observablefrom to use currentthreadscheduler (principle of least surprise)used scheduler in create instead of observeron blocking tests;#555 ;;;;1;1;observablefrom with scheduler blocking test in observablewindowtest;
"635;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operators: switchcase (case)  ifthen (if)  dowhile (dowhile)  whiledo (w;hile)  issue #634  no msdn references available.;;634.0;operators: switchcase (case) ifthen (if) dowhile (dowhile) whiledo (w;hile)issue #634no msdn references available;#565 ;more operators in rxnet;i extracted the method names from rxjava and rxnet and compared them i find some operators in rxnet(version 20208230) do not appear in the msdn do we need to implement them before 10? here is the list:-   any (exist isempty)-   **asobservable** (#641)-   **case** (#635)-   ~~catch~~ (onerrorresumenext is what we use this was for f# computation expressions)-   **chunkify** (#636)-   **collect** (#636)-   ~~deferasync~~ (not applicable as we dont have `task` or async/await)-   **delaysubscription** (#638)-   do (dooneach)-   **dowhile** (#635)-   finally (finallydo)-   **firstasync** (#520)- [x]  **firstordefaultasync** (firstordefault)- [x]  **for** (#636)- [x]  foreach (blockingobservableforeach)-   ~~foreachasync~~ (blockingobservableforeach since we dont  have `task` or async/await)-   ~~fromasync~~ (from with schedulers does this)- [x]  ~~fromasyncpattern~~ (wont implement)- [x]  ~~fromevent~~ (wont implement)- [x]  ~~fromeventpattern~~ (wont implement)- [x]  **generate** (#519)- [x]  ~~getenumerator~~ (wont implement)- [x]  **if** (#635)- [x]  lastasync (last)- [x]  lastordefault (blockingobservablelastordefault)- [x]  **lastordefaultasync** (#520)- [x]  **latest** (#626)- [x]  mostrecent (blockingobservablemostrecent)- [x]  next (blockingobservablenext)- [x]  refcount (connectableobservablerefcount)- [x]  **repeat** (#518)- [x]  return (from just)- [x]  select (map)- [x]  selectmany (flatmap)- [x]  single (blockingobservablesingle)- [x]  **singleasync** (#520)- [x]  singleordefault (blockingobservablesingleordefault)- [x]  **singleordefaultasync** (#520)-   ~~startasync~~- [x]  switch (switchonnext)- [x]  **takelastbuffer** (#638)- [x]  throttle (debounce)- [x]  throw (error)- [x]  toarray (unnecessary)- [x]  toasync (asynctoasync)- [x]  todictionary (tomap)- [x]  toenumerable (blockingobservabletoiterable)- [x]  ~~toevent~~ (wont implement)- [x]  ~~toeventpattern~~ (wont implement)- [x]  tolookup (tomultimap)- [x]  toobservable (from)-   ~~wait~~ (blockingobservablelast())- [x]  **while** (#635)**strong** means someone is working on it~~strikethrough~~ means it wont be implememted;""nice listcatch -> onerrorresumenext (?)fromasyncpattern: wont implement (#46)generate -> pr available (#519) still debating on return typelastordefault -> bolastordefault (?)mostrecent -> bomostrecentrepeat -> pr available (#518)startasync -> start  (?)switch -> switchonnext (?)throttle -> debouncei dont recognize the rest || updatedstartasync is not the `start` operator:```    //    // summary:    //     invokes the asynchronous function surfacing the result through an observable    //     sequence  the cancellationtoken is shared by all subscriptions on the resulting    //     observable sequence see the remarks section for more information    //    // parameters:    //   functionasync:    //     asynchronous function to run    //    // type parameters:    //   tresult:    //     the type of the result returned by the asynchronous function    //    // returns:    //     an observable sequence exposing the functions result value or an exception    //    // exceptions:    //   systemargumentnullexception:    //     functionasync is null    //    // remarks:    //      the function is started immediately not during the subscription of the    //     resulting sequence  multiple subscriptions to the resulting sequence can    //     observe the functions result  if any subscription to the resulting sequence    //     is disposed the cancellationtoken is set the observer associated to the    //     disposed subscription wont see the taskcanceledexception but other observers    //     will you can protect against this using the catch operator  be careful    //     when handing out the resulting sequence because of this behavior the most    //     common use is to have a single subscription to the resulting sequence which    //     controls the cancellationtoken state alternatively you can control subscription    //     behavior using multicast operators    public static iobservable<tresult> startasync<tresult>(func<cancellationtoken task<tresult>> functionasync)``` || here is whats missing and what they generally do:-  **asobservable**: """"hides the identity of an observable sequence""""-  **case**: """"uses a selector to determine which source to return"""" ie in onsubscribe a func0 selector is called and an observable looked up in a map then subscribed to it-  **chunkify**: """"produces an enumerable sequence of consecutive (possibly empty) chunks of the source sequence"""" ie implemented as `sourcecollect(() -> new arraylist (lst x) -> {lstadd(x) return lst} u -> new arraylist)`-  **collect**: """"produces an enumerable sequence that returns elements collected/aggregated from the source sequence between consecutive iterations"""" for example you start out with an empty list and each onnext adds to the list once the `iteratornext()` takes the current list it is replaced by a fresh list depending on the frequency of `next()` you might get lists with various sizes-  **deferasync**: """"returns an observable sequence that starts the specified asynchronous factory function whenever a new observer subscribes"""" implemented as defer(() -> startasync(factory)merge()) where factory is a `func0<task<iobservable<tvalue>>>`-  **delaysubscription**: """"time shifts the observable sequence by delaying the subscription with the specified relative time duration"""" does not timeshift the unsubscribe-  **dowhile**: """"repeats the given source as long as the specified condition holds where the condition is evaluated after each repeated source completed"""" ie repeat only if condition holds: `do { subscribe & run } while (condition)`-  **for**: """"concatenates the observable sequences obtained by running the resultselector for each element in the given enumerable source"""" the difference from a plain concat is that the source iterable is consumed on demand rather than all at once-  **foreachasync**: """"invokes an action for each element in the observable sequence and returns a task object that will get signaled when the sequence terminates"""" like making a whole sequence of observations into a big future dual of fromfuture & toasync in some sense-  **fromasync**: """"converts to asynchronous function into an observable sequence each subscription to the resulting sequence causes the function to be started the cancellationtoken passed to the asynchronous function is tied to the observable sequences subscription that triggered the functions invocation and can be used for best-effort cancellation"""" implemented as `defer(() -> startasync(functionasync))` where functionasync is `func<task<tresult>>` or `func<cancellationtoken task<tresult>>`- [x] **if**: """"if the specified condition evaluates true select the thensource sequence otherwise select the elsesource sequence"""" condition is evaluated on subscription- [x] **groupby** with capacity overloads (v22)- [x] **groupbyuntil** with capacity overloads (v22)- [x] **singleasync**: """"returns the only element of an observable sequence and reports an exception if there is not exactly one element in the observable sequence"""" returns an observable with a single element or exception- [x] **singleordefaultasync**: """"returns the only element of an observable sequence or a default value if the observable sequence is empty this method reports an exception if there is more than one element in the observable sequence""""- [x] **startasync**: see [comment]( above- [x] **takelast** overload with time window (ie return the last 2 seconds worth of source values once it finishes)- [x] **takelastbuffer**: """"returns a list with the specified number of contiguous elements from the end of an observable sequence"""" has time based overloads almost like takelast but emits a single list of elements - [x] **wait**: """"waits for the observable sequence to complete and returns the last element of the sequence if the sequence terminates with an onerror notification the exception is throw"""" returns t looks like a `sourcetakelast(1)toblockingobservable()single()`- [x] **while**: """"repeats the given source as long as the specified condition holds where the condition is evaluated before each repeated source is subscribed to"""" ie `while(condition) { subscribe }` || @zsxwing or anyone else do you want to do some of these? ill do them in batches do i dont have to rebase and restart from master all the time ill start with `dowhile` `while` `if` `case` || continuing with `chunkify` `collect` `wait` and `for`update: wait is practically bolast() since we dont usually do aliases ill skip wait || next: `defersubscription` `takelast` `takelastbuffer` || i can add singleasync and singleordefaultasync in pr #520 directly || do we really need deferasync foreachasync fromasync startasync? we have no cancellationtoken in java || it appears to me that cancellationtoken is used for cancelling tasks basically a similar way you would use futuretask and check its iscancelled() but since these tokens come from the outside you can signal cancellations to multiple tasks at once since we have the `subscription` infrastructure for that id vote for not implementing those variants || doing `asobservable` `groupby` and `groupbyuntil` variants || anyone want to implement all the testschedulers?(cancellationtoken is really only useful when you have async await) || a can take those as well unless someone else beats me to it while i do the ops mentioned above || doing lastasync and lastordefaultasync || @headinthebox what features do you miss from the current `testscheduler`? im looking at rxnet sources of virtualscheduler testscheduler and historicalscheduler but it is not apparent to me what the functional requirements arenever mind ill start doing it btw im starting to require the enhancements of my prs to avoid feature duplication || these :switch -> switchonnext (?)throttle -> debouncethe """"async"""" ones dont use the async suffix in rxjava since the non-async ones are on `blockingobservable` instead thus some of those in the list are already implemented just without the async suffix || @zsxwing how is the `lastasync` operator you say youre doing different than `last` ( that is already implemented? it is non-blockingwe have `last` and `takelast````last()           returns an observable that emits the last item emitted by the source or an illegalargumentexception if the source observable is emptytakelast(int count)           returns an observable that emits only the last count items emitted by the source observable```difference between `takelast(1)` and `last()` just being the `illegalargumentexception` on `take` you were involved in both of these i though so im confused why were pursuing `lastasync` || what is a use case for `asobservable` to """"hide identity""""? || rxnet uses it all around the place to hide subjects @headinthebox might explain it better || interesting though what value is there in """"hiding"""" it? if it is returned as an `observable` not a `subject` people will use it as an `observable` is it to prevent people reflecting or inspecting a type and then interacting with the `subject`? || yup as @benjchristensen says it is to prevent downcasting etc in net people are pretty paranoid about this say you have a method that returns an iterable<t> but really it is an array<t> now that opens a potential (security) hole since the caller can use the iterable as a an array  || > @zsxwing how is the lastasync operator you say youre doing different than last ( that is already implemented? it is non-blockingsorry forget it we just need to add `lastordefaultasync` hope this comment ( can make these operators clear if no problem i can add this table to the wiki || looking into `deferasync` `startasync` and `singleasync` || > looking into deferasync startasync and singleasyncsingleasync has already done in #520 || doing foreachasync and fromasync and probably will amend pr #645 || the `fromasync` behavior seems to be covered in `from` overloads that take a `scheduler` such as this:  || no this fromasync is a completely different operation: it uses a factory to get a future of a value which is then observed per subscriber || already added the table to the wiki: thu dec 19 2013 at 5:57 pm shixiong zhu notifications@githubcomwrote:> @zsxwing  how is the lastasync operator you> say youre doing different than last (>  that is already implemented? it is non-blocking> > sorry forgot it we just need to add lastordefaultasync hope this> comment (#520 (comment) can make these operators clear if no problem i can add this table to the> wiki> > > reply to this email directly or view it on github ## david m grossplp consulting || @headinthebox and i reviewed the list all remaining items have been struck out as they should not be implementedgreat work getting all the others done! || "";1;0;operators: switchcase (case) ifthen (if) dowhile (dowhile) whiledo (while);"
638;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operators delaysubscription  takelast w/ time  takelastbuffer;issue #634;;0;operators delaysubscription takelast w/ time takelastbuffer;issue #634;#567  this looks good  mergingtwo requests going forward though1) please do not mix different operators into a single pull request that are not related the `delaysubscription` and `take*` operators have nothing to do with each other and confused the review2) when you add method signatures that rxnet does not have it would be helpful for you to call them outthank you! || will separate unrelated ops from now on ||;;;;1;1;operators delaysubscription takelast w/ time takelastbuffer;
"639;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;moved the descriptions of some operators to a new wiki page.;conditional and boolean operators  adjusting the javadoc links accordingly;;0;moved the descriptions of some operators to a new wiki page;""""""conditional and boolean operators""""adjusting the javadoc links accordingly"";#568 ;;;;1;1;""moved the descriptions of some operators to a new """"conditional and boolean operators"""" wiki page"";"
651;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;subjects refactor - non-blocking  common abstraction  performance;these changes evolved out of reviewing pull request  and code reviewing master branch with @headinthebox and validating functionality against .net. i also spent some time to figure out a non-blocking design that i believe is working.  the results for  replaysubject  is that it performs faster than what is currently in master and does not block in almost all cases. i have not yet perf-tested the other 3 subjects. - common logic composed inside subjectsubscriptionmanager used by all 4 subjects - replaysubject does not block while replaying to new subscribers - added unit tests and fixed behavior while reviewing with @headinthebox compared to rx.net - uses mostly non-blocking approach (i believe its all correct  unit and long running tests have been used to prove it. the tests found concurrency problems during development and became stable once i got the design correct. as with all concurrent code i may be missing something.)   - the only place it blocks is if a new observer subscribes  completes replay and  oncomplete / onerror  are in process. it will wait for those to complete before applying the terminal state on itself.  as for performance  for relative comparison my machine gets these numbers for the master branch:           * arraylist with raw values & synchronized access      *       * run: 10 - 11 993 341 ops/sec      * run: 11 - 11 719 523 ops/sec      * run: 12 - 11 965 214 ops/sec      * run: 13 - 11 814 730 ops/sec      * run: 14 - 11 947 459 ops/sec      this commit gets these numbers:           * arraylist with raw values & non-blocking (no synchronization)      *       * run: 10 - 16 069 678 ops/sec      * run: 11 - 15 954 688 ops/sec      * run: 12 - 16 158 874 ops/sec      * run: 13 - 16 209 504 ops/sec      * run: 14 - 16 151 174 ops/sec      i m curious about adding bounded support and using a circular-array rather than arraylist and seeing if it performs better.  the performance tests are inside  subjectperformancetests  and inspired by tests done in the non-blocking code workshop with martin thompson.   some of the code is not as elegant as i d like but was done for performance reasons. for example  i had a much more elegant version using a simple linked list but it had horrible performance. another example is that using  notification  to wrap every  onnext  so we have a single data structure is very inefficient so it maintains  t  without wrapping and then conditional logic to check for terminal state. these and other things have been determined while doing perf tests during development and i have consciously moved towards performance rather than the most elegant code.  i d appreciate feedback on concurrency problems if any exist or ways of getting more performance out while achieving the same functional requirements.;;0;subjects refactor - non-blocking common abstraction performance;these changes evolved out of reviewing pull request  and code reviewing master branch with @headinthebox and validating functionality against net i also spent some time to figure out a non-blocking design that i believe is workingthe results for `replaysubject` is that it performs faster than what is currently in master and does not block in almost all cases i have not yet perf-tested the other 3 subjects- common logic composed inside subjectsubscriptionmanager used by all 4 subjects- replaysubject does not block while replaying to new subscribers- added unit tests and  behavior while reviewing with @headinthebox compared to rxnet- uses mostly non-blocking approach (i believe its all correct unit and long running tests have been used to prove it the tests found concurrency problems during development and became stable once i got the design correct as with all concurrent code i may be missing something)  - the only place it blocks is if a new observer subscribes completes replay and `oncomplete`/`onerror` are in process it will wait for those to complete before applying the terminal state on itselfas for performance for relative comparison my machine gets these numbers for the master branch:```     * arraylist with raw values & synchronized access     *      * run: 10 - 11993341 ops/sec     * run: 11 - 11719523 ops/sec     * run: 12 - 11965214 ops/sec     * run: 13 - 11814730 ops/sec     * run: 14 - 11947459 ops/sec```this commit gets these numbers:```     * arraylist with raw values & non-blocking (no synchronization)     *      * run: 10 - 16069678 ops/sec     * run: 11 - 15954688 ops/sec     * run: 12 - 16158874 ops/sec     * run: 13 - 16209504 ops/sec     * run: 14 - 16151174 ops/sec```im curious about adding bounded support and using a circular-array rather than arraylist and seeing if it performs betterthe performance tests are inside `subjectperformancetests` and inspired by tests done in the non-blocking code workshop with martin thompson some of the code is not as elegant as id like but was done for performance reasons for example i had a much more elegant version using a simple linked list but it had horrible performance another example is that using `notification` to wrap every `onnext` so we have a single data structure is very inefficient so it maintains `t` without wrapping and then conditional logic to check for terminal state these and other things have been determined while doing perf tests during development and i have consciously moved towards performance rather than the most elegant codeid appreciate feedback on concurrency problems if any exist or ways of getting more performance out while achieving the same functional requirements;#584  #591;;;;1;1;reverting to previous safeobserver- performance difference between changes are trivial at best so preferring to keep code that is easier to understandtest numbers:```old safeobserverrun: 0 - 3751704 ops/secrun: 1 - 34619086 ops/secrun: 2 - 30483715 ops/secrun: 3 - 27746023 ops/secrun: 4 - 54078608 ops/secrun: 5 - 55107045 ops/secrun: 6 - 53935396 ops/secrun: 7 - 54947168 ops/secrun: 8 - 57024246 ops/secrun: 9 - 55059712 ops/secrun: 10 - 56904832 ops/secrun: 11 - 55919967 ops/secrun: 12 - 55076087 ops/secrun: 13 - 55066685 ops/secrun: 14 - 55025476 ops/secrun: 0 - 3839266 ops/secrun: 1 - 34115371 ops/secrun: 2 - 29675175 ops/secrun: 3 - 28677042 ops/secrun: 4 - 55405652 ops/secrun: 5 - 55260220 ops/secrun: 6 - 55147464 ops/secrun: 7 - 54261126 ops/secrun: 8 - 53941505 ops/secrun: 9 - 54324501 ops/secrun: 10 - 55125576 ops/secrun: 11 - 56102870 ops/secrun: 12 - 55061834 ops/secrun: 13 - 55476039 ops/secrun: 14 - 55073054 ops/secrun: 0 - 3704536 ops/secrun: 1 - 34694514 ops/secrun: 2 - 30778227 ops/secrun: 3 - 28441329 ops/secrun: 4 - 54116946 ops/secrun: 5 - 55204699 ops/secrun: 6 - 54859450 ops/secrun: 7 - 55214757 ops/secrun: 8 - 55005500 ops/secrun: 9 - 55339118 ops/secrun: 10 - 55501903 ops/secrun: 11 - 55074570 ops/secrun: 12 - 55102187 ops/secrun: 13 - 55756278 ops/secrun: 14 - 54768411 ops/secnew safeobserverrun: 0 - 3983308 ops/secrun: 1 - 34767250 ops/secrun: 2 - 30806957 ops/secrun: 3 - 29855113 ops/secrun: 4 - 57451453 ops/secrun: 5 - 55515152 ops/secrun: 6 - 56086822 ops/secrun: 7 - 56295529 ops/secrun: 8 - 55371905 ops/secrun: 9 - 55816653 ops/secrun: 10 - 55793296 ops/secrun: 11 - 56011426 ops/secrun: 12 - 55568521 ops/secrun: 13 - 55396137 ops/secrun: 14 - 56353267 ops/secrun: 0 - 3933367 ops/secrun: 1 - 34498342 ops/secrun: 2 - 30233584 ops/secrun: 3 - 29179785 ops/secrun: 4 - 55761874 ops/secrun: 5 - 55948124 ops/secrun: 6 - 55264801 ops/secrun: 7 - 56267020 ops/secrun: 8 - 57474567 ops/secrun: 9 - 55879657 ops/secrun: 10 - 55998880 ops/secrun: 11 - 56044073 ops/secrun: 12 - 55498515 ops/secrun: 13 - 56204720 ops/secrun: 14 - 55845954 ops/secrun: 0 - 3981914 ops/secrun: 1 - 34160822 ops/secrun: 2 - 30873631 ops/secrun: 3 - 29135067 ops/secrun: 4 - 55845330 ops/secrun: 5 - 55101883 ops/secrun: 6 - 55724276 ops/secrun: 7 - 56085564 ops/secrun: 8 - 55639942 ops/secrun: 9 - 56464955 ops/secrun: 10 - 55453275 ops/secrun: 11 - 56115463 ops/secrun: 12 - 56509945 ops/secrun: 13 - 53863348 ops/secrun: 14 - 55866858 ops/sec```;
"657;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operations aggregate  average and sum with selector;issue #653  remarks: - i know we can combine ops to get one of the new aggregate variant  but i think it might be worth having a direct version which avoids nesting several layers of observables  observers and subscriptions. - the  averageinteger  and  suminteger  (and the other types) are handy if we want to use chained operation invocations (with less overhead):      java observable.from( a    bb    ccc ).suminteger(s -> s.length())     .toblockingobservable().single()       instead of      java observable.sumintegers(observable.from( a    bb    ccc ).map(s -> s.length()))     .toblockingobservable().single();;653.0;operations aggregate average and sum with selector;""issue #653remarks:- i know we can combine ops to get one of the new aggregate variant but i think it might be worth having a direct version which avoids nesting several layers of observables observers and subscriptions- the `averageinteger` and `suminteger` (and the other types) are handy if we want to use chained operation invocations (with less overhead):``` javaobservablefrom(""""a"""" """"bb"""" """"ccc"""")suminteger(s -> slength())    toblockingobservable()single()```instead of``` javaobservablesumintegers(observablefrom(""""a"""" """"bb"""" """"ccc"""")map(s -> slength()))    toblockingobservable()single()```"";#590  this establishes (or strengthens) a precedent of adding a large number of helper methods for very specific cases to the already massive `observable` so id like to explore one of two routes:1) move mathematical operators to a separate `observable` in `rxobservablenumericalobservable` or something like that2) move them into a contrib module like  || id go for `numericalobservable` on this one as it is primarily useful out-of-box whereas futures may go into contrib ||;more operators/overloads;rxnet 222-  ~~aggregate (pr #657)~~  - `aggregate(seed accumulator resultselector)`-  average (pr #657 m)  -  `average(func1<t number> valueselector)`-  buffer (pr #733)  - `buffer(observable<u> bufferboundaries)`-  ~~create async~~  - ~~`create(func1<observer<r> task>)`~~  - ~~`create(func1<observer<r> task<action>>)`~~  - ~~`create(func1<observer<r> task<idisposable>>)`~~  - ~~`create(func2<observer<r> cancellationtoken task>)`~~  - ~~`create(func2<observer<r> cancellationtoken task<action>>)`~~  - ~~`create(func2<observer<r> cancellationtoken task<idisposable>>)`~~-  delay (pr #734)  - `delay(func1<t observable<tdelay>>)`  - `delay(func0<observable<d1>> subscriptiondelay func1<t observable<d2>> itemdelay)`-  ~~empty (pr #654)~~  - ~~`empty(t witness)`~~  - ~~`empty(scheduler t witness)`~~-  ~~never (pr #654)~~  - ~~`never(t witness)`~~-  publish (pr #738)  - `publish(func1<observable<tsource> observable<tresult>> sel)`  - `publish(tsource initialvalue)`  - `publish(func1<observable<tsource> observable<tresult>> sel tsource initialvalue)`-  publishlast (pr #738)  - `publishlast(func1<observable<tsource> observable<tresult>> sel)`-  selectmany (flatmap) (pr #736)  - `selectmany(func1<t observable<u>> collection func2<t u r> resultsel)`  - `selectmany(func1<t observable<r>> onnext func1<exception observable<r>> onerror func0<observable<r>> oncompleted)`  - `selectmany(func1<t ienumerable<r>>)`  - `selectmany(func2<t ienumerable<u>> func2<t u r>)`  - ~~----------------------------------~~  - ~~`selectmany(func2<t integer observable<r>>)`~~  - ~~`selectmany(func1<t task<r>>)`~~  - ~~`selectmany(func2<t integer task<r>>)`~~  - ~~`selectmany(func2<t cancellationtoken task<r>>)`~~  - ~~`selectmany(func3<t integer cancellationtokenk task<r>>)`~~  - ~~`selectmany(func1<t integer observable<u>> collection func4<t integer  u integr r> resultsel)`~~  - ~~`selectmany(func1<t task<u>> func2<t u r>)`~~  - ~~`selectmany(func2<t integer task<u>> func2<t integer u r>)`~~  - ~~`selectmany(func2<t ct task<u>> func2<t u r>)`~~  - ~~`selectmany(func3<t integer ct task<u>> func2<t integer u r>)`~~  - ~~`selectmany(func2<t integer observable<r>> onnext func1<exception observable<r>> onerror func0<observable<r>> oncompleted)`~~  - ~~`selectmany(func2<t integer ienumerable<r>>)`~~  - ~~`selectmany(func3<t integer ienumerable<u>> func4<t integer u integer r>)`~~- [x] skip (pr #655 m)  - `skip(timespan)`  - `skip(timespan scheduler)`- [x] skiplast  (pr #655 m)  - `skiplast(timespan)`  - `skiplast(timespan scheduler)`- [x] sum (pr #657 m)  - `sum(func1<t number> valueselector)`- [x] take  (pr #655 m)  - `take(timespan)`  - `take(timespan scheduler)`- [x] takelast  (pr #655 m)  - `takelast(timespan)`  - `takelast(timespan scheduler)`  - `takelast(timespan scheduler duration scheduler drain)`- [x] throttle (debounce) (pr #739)  - `throttle(func1<t observable<void>>)`- [x] timeout (pr #740)  - `timeout(func1<t observable<void>>)`  - `timeout(func1<t observable<void>> observable<t> other)`  - `timeout(func0<observable<void>> func1<t observable<void>>)`  - `timeout(func0<observable<void>> func1<t observable<void>> observable<t> other)`- [x] ~~throw (error) (pr #654)~~  - ~~`error(throwable t t witness)`~~  - ~~`error(throwable t scheduler t witness)`~~- [x] ~~using async~~  - ~~`using(func1<cancellationtoken task<tresource>> func2<tresource cancellationtoken task<observable<t>>>)`~~- [x] ~~where~~  - ~~`where(func2<t integer boolean>)`~~- [x] window (pr #735)  - `window(observable<u> windowboundaries)`- [x] zip (pr #741)  - ~~`zip(ienumerable<observable<s>> sources func1<ilist<s> r> selector)`~~ (already have with funcn)  - `zip(iterable<u> other func2<t u r> result)` (instance method)  - `zip(observable<u> other func2<t u r> result)` (instance method)potential java specific operators/overloads:-  `just(func0<r> factory)` return the value of the factory for the subscriber- [x] ~~`lock(lock lock)` or `synchronize(lock lock)` to support juclocks for synchronization~~- [x] ~~using with javaiocloseable~~  - ~~`using(func0<c> func1<c observable<t>>)`~~  - ~~`usingfuture(func1<booleansubscription future<c>> func2<c booleansubscription future<observable<t>>>)`~~;reviewed by @headinthebox and i for things that should not be added and used ~~strikethrough~~ so they are still on the list but marked to not work on || > lock(lock lock) or synchronize(lock lock) to support juclocks for synchronizationwhat is a use case when this would ever be needed? @headinthebox mentioned that its not really used in rxnet so likely not worth us adding  || okay no worries i wont start working on the remaining ones for at least a week || closing this and ignoring `just(func0<r> factory)` ||;1;0;operations aggregate average and sum with selector;"
659;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;missing fixes from the subject rewrite;two small changes: - prevent overwriting the terminal notification in  behaviorsubject  so new subscribers to a terminated subject can see the error/completion. - call  thread.currentthread().interrupt()  if the  terminationlatch.await()  throws.;;0;missing fixes from the subject rewrite;two small changes:- prevent overwriting the terminal notification in `behaviorsubject` so new subscribers to a terminated subject can see the error/completion- call `threadcurrentthread()interrupt()` if the `terminationlatchawait()` throws;#593  thanks @akarnokd  ||;;;;1;1;missing fixes from the subject rewrite;
"661;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;subscriptions rewrite;refactor rewrite of subscriptions by @headinthebox and myself after reviewing the various different implementations. - we removed  singleassignmentsubscription  while trying to reduce surface area and simplify code. - moved to a non-blocking state-machine model that does not lock or busy spin during  mutation states;;0;subscriptions rewrite;""refactor rewrite of subscriptions by @headinthebox and myself after reviewing the various different implementations- we removed `singleassignmentsubscription` while trying to reduce surface area and simplify code- moved to a non-blocking state-machine model that does not lock or busy spin during """"mutation states"""""";#596;;;;1;1;naming and class conventions- make concrete implementations final as extending them is dangerous (use composition and implement subscription instead)- deprecated long get/setsubscription methods in favor of short verbs (add/get/set/clear/remove)- updated unit tests with changes;"
664;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operation asobservable;split from pr #641;;0;operation asobservable;split from pr #641;#599;;;;1;1;operation asobservable;
667;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operators skip  skiplast  take with time;rebased version  without the drain scheduler variant. - fixes issue mentioned in #666 as well.;;666.0;operators skip skiplast take with time;rebased version without the drain scheduler variant- fixes issue mentioned in #666 as well;#601;prs failing;due to refactored subscriptions:- operationtakelast - im about to submit a pr for this- scala override attempt of the now final class:```rxjava-scala\src\main\scala\rx\lang\scala\subscriptions\booleansubscriptionscala  error: illegal inheritance from final class booleansubscriptionoverride val asjavasubscription: rxsubscriptionsbooleansubscription  new rxsubscriptionsbooleansubscription() {```is someone working on this latter?;ill fix the scala one previous there was no overload of belleansubscriptioncreate that took an action || thanks @headinthebox  the scala compiler isnt that nice with me as with you ||  ||;1;0;operators skip skiplast take with time;
669;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;javadoc improvements:;- diagrams for switchcase  dowhile  whiledo  ifthen  delaysubscription  single  singleordefault  takefirst  takelast (and variant forms of these) - standardizing javadoc comment formatting - standardizing nomenclature;;0;javadoc improvements:;- diagrams for switchcase dowhile whiledo ifthen delaysubscription single singleordefault takefirst takelast (and variant forms of these)- standardizing javadoc comment formatting- standardizing nomenclature;#603;;;;1;1;javadoc improvements:* diagrams for switchcase dowhile whiledo ifthen delaysubscription single singleordefault takefirst takelast (and variant forms of these)* standardizing javadoc comment formatting* standardizing nomenclature;
670;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;api design tweaks;some changes resulting from review with @headinthebox and @jhusain  general principles pursued are to simplify the mental model and surface area of the api.;;0;api design tweaks;some changes resulting from review with @headinthebox and @jhusaingeneral principles pursued are to simplify the mental model and surface area of the api;#604;;;;1;1;deprecate aggregate in favor of reducewe have had aggregate from rxnet for a while but long ago migrated to reduce as the primary time to deprecate it;
688;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;fix safeobserver handling of oncomplete errors;fixes https://github.com/netflix/rxjava/issues/630;;0;fix safeobserver handling of oncomplete errors;fixes https://githubcom/netflix/rxjava/issues/630;#605 so the contract becomes `onnext* ( (oncompleted onerror?) | onerror)?` ? || not really this is handling out of contract scenarios a proper observer should never fail on any of these notifications thus safeobserver logic should never apply but bugs exist and this is all about making a system operational despite code not complying with the rx contract and having bugs  || got it ;;;;1;1;fix safeobserver handling of oncomplete errorsfixes https://githubcom/netflix/rxjava/issues/630;
690;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fixed scala bindings;;;0; scala bindings;;#607  thanks erik ||;;;;1;1; scala bindings;
691;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;javadoc improvements:;- diagrams for switchlatest  mergemap  concatmap  switchmap  mapwithindex  doonnext - change text to note deprecation of aggregate - standardized formatting - force image size in replaysubject javadoc;;0;javadoc improvements:;- diagrams for switchlatest mergemap concatmap switchmap mapwithindex doonnext- change text to note deprecation of aggregate- standardized formatting- force image size in replaysubject javadoc;#608  thanks david for keeping on top of this  ||;;;;1;1;javadoc improvements:* diagrams for switchlatest mergemap concatmap switchmap mapwithindex doonnext* change text to note deprecation of aggregate* standardized formatting* force image size in replaysubject javadoc;
697;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;manual merge of pull #667;manual merge of https://github.com/netflix/rxjava/pull/667;;0;manual merge of pull #667;manual merge of https://githubcom/netflix/rxjava/pull/667;#614 ;;;;1;1;manual merge githubcom:akarnokd/rxjava skiptaketimed2conflicts:	rxjava-core/src/main/java/rx/observablejava	rxjava-core/src/main/java/rx/operators/operationtakelastjava;
"698;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;merge of pull 657: average and sum;;;0;merge of pull 657: average and sum;;""#615  im not crazy about the naming:average() / averageinteger(f)averagedoubles() / averagedouble(f)averagefloats() / averagefloat(f)averagelongs() / averagelong(f)it doesnt seem to have much rhyme or reason to it why are the versionsthat take functions singular and the versions that dont are plural (eg""""long"""" vs """"longs"""")? why is the function paired up with averageinteger(f)just called average() instead of averageintegers() when all the otherfunctions follow that pattern?on fri dec 27 2013 at 1:18 pm cloudbees pull request builder plugin <notifications@githubcom> wrote:> rxjava-pull-requests #615 this pull request looks good> > > reply to this email directly or view it on github ## david m grossplp consulting || - i wanted to avoid overload problems in other languages and simply named the ops differently- i wondered why `average()` didnt include the type in the name is it more common to average a stream of ints?- i wondered why the originals where plurals in the first place || > i wanted to avoid overload problems in other languages and simply named the ops differentlythis is actually a problem with type-erasure not the language interopthis code ``` javapublic static observable<integer> average(observable<integer> source) {        return operationaverageaverage(source)}public static observable<double> average(observable<double> source) {        return operationaverageaverage(source)}```results in this error:> method average(observable<integer>) has the same erasure average(observable<t>) as another method in type observable<t> || we can rename the methods doing so now || names standardized here:  || "";;;;1;1;rename to reducetest;"
699;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;repeat operator;- merge and slight modification of  done with @headinthebox;;0;repeat operator;- merge and slight modification of  done with @headinthebox;#616 ;;;;1;1;repeat operator- merge and slight modification of https://githubcom/netflix/rxjava/pull/518;
700;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;various javadoc improvements;- diagrams for skip(t)  single()  take(t)  skiplast(t) - adding diagrams  improving javadocs for sumfoo/averagefoo operators - adding diagram to repeat();;0;various javadoc improvements;- diagrams for skip(t) single() take(t) skiplast(t)- adding diagrams improving javadocs for sumfoo/averagefoo operators- adding diagram to repeat();#617  youre awesome!  || real-time documentation as we write code! ||;;;;1;1;adding diagram to repeat() javadocs;
"701;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;collect operator;added with @headinthebox while reviewing java 8 streams https://github.com/netflix/rxjava/issues/678;;0;collect operator;added with @headinthebox while reviewing java 8 streams https://githubcom/netflix/rxjava/issues/678;""#618  not exactly how stream works:``` java    <r> r collect(supplier<r> supplier                  biconsumer<r ? super t> accumulator                  biconsumer<r r> combiner)```and``` java<r a> r collect(collector<? super t a r> collector)```where``` javapublic interface collector<t a r> {    supplier<a> supplier()    biconsumer<a t> accumulator()    binaryoperator<a> combiner()    function<a r> finisher()}```the main difference is that the steam and my version """"exits"""" the stream/observable the second is that it doesnt let the initial state be per subscriber so if i want to collect into an arraylist multiple subscribers will collect into the same arraylist || > the second is that it doesnt let the initial state be per subscriber so if i want to collect into an arraylist multiple subscribers will collect into the same arraylistthe `reduce` and `scan` operator would have the same problem then correct? || > not exactly how stream worksunderstood its not meant to stream is seeking to achieve something that works in both sequential and parallel execution `observable` only ever emits items sequentiallythe `parallel` operator is the only thing in rxjava that currently """"enables"""" concurrent executionthe valid discussion would be whether we want `observabletoparallel()` that returns a `parallelobservable` with different overloads of certain operators thus far as @headinthebox and i have discussed it there has not been a valid reason for this complication || > wouldnt this cause dependency problems?what dependency problems? || > the reduce and scan operator would have the same problem then correct?thats true but these are used to transfer values which are """"stateless"""" such as integer and double of course one could just create a new arraylist in reduce on each function call and be that the new state but this `collect` doesnt allow to do that so basically its a trivial wrapping around a func2 and reduce and as such might not worth adding imo> understood its not meant to stream is seeking to achieve something that works in both sequential and parallel execution observable only ever emits items sequentiallyi wasnt referring to the parallel capability of the stream but to two things: - you dont end up with a stream<r> after the collection but a direct value of r- you can specify a per-consumer state object via function callback now stream is single consumer only but observable is not> what dependency problems?dependency problem: a reference to junit in observable?`import static orgjunitassert*` || "";;;;1;1;collect operator;"
703;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;small tweaks;some small changes while reviewing code.;;0;small tweaks;some small changes while reviewing code;#619 ;;;;1;1;standardize naming of average/sum methodssee https://githubcom/netflix/rxjava/pull/698#issuecomment-31282416;
705;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;adjust javadocs for new sumfoo()/averagefoo() method names;;;0;adjust javadocs for new sumfoo()/averagefoo() method names;;#621 ;;;;1;1;adjust javadocs for new sumfoo()/averagefoo() method names;
"712;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;fix scheduler memory leaks;the  newthreadscheduler    currentthreadscheduler  and  executorscheduler  all had memory leaks when doing recursion with the  func2  method signature. this pull request fixes that along with improving the unit test coverage.  the fix involved treating  outer  and  inner  schedulers differently  with  inner  being the place where recursion happens.  the memory behavior can be tested using  testrecursionmemoryusage .  this fixes the problems reported in  and   but does not change the  scheduler  or  subscription  interfaces or public implementation details.;;0;fix scheduler memory leaks;""the `newthreadscheduler` `currentthreadscheduler` and `executorscheduler` all had memory leaks when doing recursion with the `func2` method signature this pull request fixes that along with improving the unit test coveragethe fix involved treating """"outer"""" and """"inner"""" schedulers differently with """"inner"""" being the place where recursion happensthe memory behavior can be tested using `testrecursionmemoryusage`this fixes the problems reported in  and   but does not change the `scheduler` or `subscription` interfaces or public implementation details"";@headinthebox working on this made me think our work on outer/inner schedulers may still be worthwhile as the distinction is important in usage particularly for recursion the branch is at  if not all of the issues i found were related to treating outer and inner schedulers the same || #629 apparently i have some non-deterministic tests:```rxschedulersexecutorschedulertestsrecursionusingfunc2rxschedulersexecutorschedulertestsrecursionusingaction0```ill spend some time looking at them a little later before i merge thisif anyone else wants to review or provide guidance on improving this please jump in || #630 #631 ;;;;1;1;remove validation of ordering- this test does a flatmap which uses merge which has non-deterministic ordering since the observablefrom can be on a new thread each time;"
714;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;rxjava-computation-expressions;the conditional operators are going in this contrib module.  see https://github.com/netflix/rxjava/issues/683;;0;rxjava-computation-expressions;the conditional operators are going in this contrib modulesee https://githubcom/netflix/rxjava/issues/683;#632 ;;;;1;1;rxjava-computation-expressionsthe conditional operators are going in this contrib modulesee https://githubcom/netflix/rxjava/issues/683;
723;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;deprecate multiple arity from;- added @deprecated annotations where it was only part of the javadoc - deprecated where which is a duplicate of  filter  kept from early days matching rx.net  see https://github.com/netflix/rxjava/issues/686;;0;deprecate multiple arity from;- added @deprecated annotations where it was only part of the javadoc- deprecated where which is a duplicate of `filter` kept from early days matching rxnetsee https://githubcom/netflix/rxjava/issues/686;#638 ;;;;1;1;deprecate multiple arity from- added @deprecated annotations where it was only part of the javadoc- deprecated where which is a duplicate of `filter` kept from early days matching rxnet;
724;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;revert use of currentthreadscheduler for observable.from;use immediatescheduler as performance is 4x faster and currentthreadscheduler currently offers no benefit (it doesnt solve the unsubscribe problem).  performance numbers:       * observable.from(arrays.aslist(1l  2l  3l  4l  5l  6l  7l  8l  9l  10l)  scheduler)   *  * --- schedulers.immediate() ---  *  * run: 0 - 1 849 947 ops/sec  * run: 1 - 2 076 067 ops/sec  * run: 2 - 2 114 688 ops/sec  * run: 3 - 2 114 301 ops/sec  * run: 4 - 2 102 543 ops/sec  *  * --- schedulers.currentthread() ---  *  * run: 0 - 548 862 ops/sec  * run: 1 - 559 955 ops/sec  * run: 2 - 581 412 ops/sec  * run: 3 - 562 187 ops/sec  * run: 4 - 565 723 ops/sec   * observable.from(arrays.aslist(1l)  scheduler)   *  * --- schedulers.immediate() ---  *  * run: 10 - 4 113 672 ops/sec  * run: 11 - 4 068 351 ops/sec  * run: 12 - 4 070 318 ops/sec  * run: 13 - 4 161 793 ops/sec  * run: 14 - 4 156 725 ops/sec  *  * --- schedulers.currentthread() ---  *  * run: 10 - 1 692 286 ops/sec  * run: 11 - 1 765 054 ops/sec  * run: 12 - 1 763 100 ops/sec  * run: 13 - 1 770 907 ops/sec  * run: 14 - 1 732 291 ops/sec;;0;revert use of currentthreadscheduler for observablefrom;use immediatescheduler as performance is 4x faster and currentthreadscheduler currently offers no benefit (it doesnt solve the unsubscribe problem)performance numbers:``` * observablefrom(arraysaslist(1l 2l 3l 4l 5l 6l 7l 8l 9l 10l) scheduler) * * --- schedulersimmediate() --- * * run: 0 - 1849947 ops/sec * run: 1 - 2076067 ops/sec * run: 2 - 2114688 ops/sec * run: 3 - 2114301 ops/sec * run: 4 - 2102543 ops/sec * * --- schedulerscurrentthread() --- * * run: 0 - 548862 ops/sec * run: 1 - 559955 ops/sec * run: 2 - 581412 ops/sec * run: 3 - 562187 ops/sec * run: 4 - 565723 ops/sec * observablefrom(arraysaslist(1l) scheduler) * * --- schedulersimmediate() --- * * run: 10 - 4113672 ops/sec * run: 11 - 4068351 ops/sec * run: 12 - 4070318 ops/sec * run: 13 - 4161793 ops/sec * run: 14 - 4156725 ops/sec * * --- schedulerscurrentthread() --- * * run: 10 - 1692286 ops/sec * run: 11 - 1765054 ops/sec * run: 12 - 1763100 ops/sec * run: 13 - 1770907 ops/sec * run: 14 - 1732291 ops/sec```;#639];;;;1;1;revert use of currentthreadscheduler for observablefromuse immediatescheduler as performance is 4x faster and currentthreadscheduler currently offers no benefit (it doesnt solve the unsubscribe problem)performance numbers:     * observablefrom(arraysaslist(1l 2l 3l 4l 5l 6l 7l 8l 9l 10l) scheduler)     *     * --- schedulersimmediate() ---     *     * run: 0 - 1849947 ops/sec     * run: 1 - 2076067 ops/sec     * run: 2 - 2114688 ops/sec     * run: 3 - 2114301 ops/sec     * run: 4 - 2102543 ops/sec     *     * --- schedulerscurrentthread() ---     *     * run: 0 - 548862 ops/sec     * run: 1 - 559955 ops/sec     * run: 2 - 581412 ops/sec     * run: 3 - 562187 ops/sec     * run: 4 - 565723 ops/sec     * observablefrom(arraysaslist(1l) scheduler)     *     * --- schedulersimmediate() ---     *     * run: 10 - 4113672 ops/sec     * run: 11 - 4068351 ops/sec     * run: 12 - 4070318 ops/sec     * run: 13 - 4161793 ops/sec     * run: 14 - 4156725 ops/sec     *     * --- schedulerscurrentthread() ---     *     * run: 10 - 1692286 ops/sec     * run: 11 - 1765054 ops/sec     * run: 12 - 1763100 ops/sec     * run: 13 - 1770907 ops/sec     * run: 14 - 1732291 ops/sec;
725;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;simpler computation/io naming for schedulers;- simpler (no one remembers the current names when talking about them) - does not tie naming to a particular implementation involving thread pools versus a pool of event loops or something similar (as we likely will change the implementation  see https://github.com/netflix/rxjava/issues/713);;0;simpler computation/io naming for schedulers;- simpler (no one remembers the current names when talking about them)- does not tie naming to a particular implementation involving thread pools versus a pool of event loops or something similar (as we likely will change the implementation see https://githubcom/netflix/rxjava/issues/713);;;;;1;1;simpler computation/io naming for schedulers- simpler (no one remembers the current names when talking about them)- does not tie naming to a particular implementation involving thread pools versus a pool of event loops or something similar (as we likely will change the implementation see https://githubcom/netflix/rxjava/issues/713);
730;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;improve error handling and stacktraces when unsubscribe fails;the stacktraces were a mess when onerror failed or was not implemented and unsubscribe also failed. that is a far edge case and means code is broken and breaking the rx contracts  but thats just when we need clear stacktraces. the compositeexception and safeobserver class now do a dance and wire together a causal chain to provide a stacktrace that can identity all the points of error. also standardized and simplified the rxjavaplugin.onerrorhandler while working in the vicinity.  this came about after i was asked to help debug a problem and couldnt do it by looking at the thrown exception  i had to use a debugger and step through.;;0;improve error handling and stacktraces when unsubscribe fails;the stacktraces were a mess when onerror failed or was not implemented and unsubscribe also failedthat is a far edge case and means code is broken and breaking the rx contracts  but thats just when we need clear stacktracesthe compositeexception and safeobserver class now do a dance and wire together a causal chain to provide a stacktrace that can identity all the points of erroralso standardized and simplified the rxjavapluginonerrorhandler while working in the vicinitythis came about after i was asked to help debug a problem and couldnt do it by looking at the thrown exception i had to use a debugger and step through;#644 ;;;;1;1;improve error handling and stacktracesthe stacktraces were a mess when onerror failed or was not implemented and unsubscribe also failedthat is a far edge case and means code is broken and breaking the rx contracts  but thats just when we need clear stacktracesthe compositeexception and safeobserver class now do a dance and wire together a causal chain to provide a stacktrace that can identity all the points of erroralso standardized and simplified the rxjavapluginonerrorhandler while working in the vicinitythis came about after i was asked to help debug a problem and couldnt do it by looking at the thrown exception i had to use a debugger and step through;
"732;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;ported groupbyuntil function to scala-adapter;ported the groupbyuntil function to scala-adapter. this is my first time contributing  please let me know if anything is off.;;0;ported groupbyuntil function to scala-adapter;ported the groupbyuntil function to scala-adapter this is my first time contributing please let me know if anything is off;""#646  thanks @chrisgrimm for contributing!some comments:-    if we add wildcards to the duration observable in java ([commit]( then we can get rid of the cast in scala ([commit](    theres an important difference between the signature we have in java and your signature in scala: in java the `durationselector` gets a `groupedobservable` so it can extract the key if it wants to do so but in scala it only gets an `observable` so it cannot know the key-    when we add an operator to the scala observable we usually also add an example to [rxscalademo]( these examples neednt test the functionality because thats already done in java but they """"test the signature"""": if you can write a meaningful example then your signature is good and these examples are also a useful piece of documentation || @samuelgruetter okay cool ill amend my changes to reflect these comments shortly  || if you get these changes in today ill release tomorrow (tuesday us time) || @benjchristensen sorry for the delay i just woke up i added the example changed the groupbyuntil operator so that the conversion in the scala adapter wasnt necessary and changed the signature of the closings function to include the key of the group in question  || #666 thanks @chrisgrimm  || "";;;;1;1;modified groupbyuntil include the key of the group in the closings function;"
733;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;buffer with observable boundary.;mentined in issue #653. - 1 overload where the user can specify the capacity of the internal buffer.;;653.0;buffer with observable boundary;mentined in issue #653- 1 overload where the user can specify the capacity of the internal buffer;#647 ;more operators/overloads;rxnet 222-  ~~aggregate (pr #657)~~  - `aggregate(seed accumulator resultselector)`-  average (pr #657 m)  -  `average(func1<t number> valueselector)`-  buffer (pr #733)  - `buffer(observable<u> bufferboundaries)`-  ~~create async~~  - ~~`create(func1<observer<r> task>)`~~  - ~~`create(func1<observer<r> task<action>>)`~~  - ~~`create(func1<observer<r> task<idisposable>>)`~~  - ~~`create(func2<observer<r> cancellationtoken task>)`~~  - ~~`create(func2<observer<r> cancellationtoken task<action>>)`~~  - ~~`create(func2<observer<r> cancellationtoken task<idisposable>>)`~~-  delay (pr #734)  - `delay(func1<t observable<tdelay>>)`  - `delay(func0<observable<d1>> subscriptiondelay func1<t observable<d2>> itemdelay)`-  ~~empty (pr #654)~~  - ~~`empty(t witness)`~~  - ~~`empty(scheduler t witness)`~~-  ~~never (pr #654)~~  - ~~`never(t witness)`~~-  publish (pr #738)  - `publish(func1<observable<tsource> observable<tresult>> sel)`  - `publish(tsource initialvalue)`  - `publish(func1<observable<tsource> observable<tresult>> sel tsource initialvalue)`-  publishlast (pr #738)  - `publishlast(func1<observable<tsource> observable<tresult>> sel)`-  selectmany (flatmap) (pr #736)  - `selectmany(func1<t observable<u>> collection func2<t u r> resultsel)`  - `selectmany(func1<t observable<r>> onnext func1<exception observable<r>> onerror func0<observable<r>> oncompleted)`  - `selectmany(func1<t ienumerable<r>>)`  - `selectmany(func2<t ienumerable<u>> func2<t u r>)`  - ~~----------------------------------~~  - ~~`selectmany(func2<t integer observable<r>>)`~~  - ~~`selectmany(func1<t task<r>>)`~~  - ~~`selectmany(func2<t integer task<r>>)`~~  - ~~`selectmany(func2<t cancellationtoken task<r>>)`~~  - ~~`selectmany(func3<t integer cancellationtokenk task<r>>)`~~  - ~~`selectmany(func1<t integer observable<u>> collection func4<t integer  u integr r> resultsel)`~~  - ~~`selectmany(func1<t task<u>> func2<t u r>)`~~  - ~~`selectmany(func2<t integer task<u>> func2<t integer u r>)`~~  - ~~`selectmany(func2<t ct task<u>> func2<t u r>)`~~  - ~~`selectmany(func3<t integer ct task<u>> func2<t integer u r>)`~~  - ~~`selectmany(func2<t integer observable<r>> onnext func1<exception observable<r>> onerror func0<observable<r>> oncompleted)`~~  - ~~`selectmany(func2<t integer ienumerable<r>>)`~~  - ~~`selectmany(func3<t integer ienumerable<u>> func4<t integer u integer r>)`~~- [x] skip (pr #655 m)  - `skip(timespan)`  - `skip(timespan scheduler)`- [x] skiplast  (pr #655 m)  - `skiplast(timespan)`  - `skiplast(timespan scheduler)`- [x] sum (pr #657 m)  - `sum(func1<t number> valueselector)`- [x] take  (pr #655 m)  - `take(timespan)`  - `take(timespan scheduler)`- [x] takelast  (pr #655 m)  - `takelast(timespan)`  - `takelast(timespan scheduler)`  - `takelast(timespan scheduler duration scheduler drain)`- [x] throttle (debounce) (pr #739)  - `throttle(func1<t observable<void>>)`- [x] timeout (pr #740)  - `timeout(func1<t observable<void>>)`  - `timeout(func1<t observable<void>> observable<t> other)`  - `timeout(func0<observable<void>> func1<t observable<void>>)`  - `timeout(func0<observable<void>> func1<t observable<void>> observable<t> other)`- [x] ~~throw (error) (pr #654)~~  - ~~`error(throwable t t witness)`~~  - ~~`error(throwable t scheduler t witness)`~~- [x] ~~using async~~  - ~~`using(func1<cancellationtoken task<tresource>> func2<tresource cancellationtoken task<observable<t>>>)`~~- [x] ~~where~~  - ~~`where(func2<t integer boolean>)`~~- [x] window (pr #735)  - `window(observable<u> windowboundaries)`- [x] zip (pr #741)  - ~~`zip(ienumerable<observable<s>> sources func1<ilist<s> r> selector)`~~ (already have with funcn)  - `zip(iterable<u> other func2<t u r> result)` (instance method)  - `zip(observable<u> other func2<t u r> result)` (instance method)potential java specific operators/overloads:-  `just(func0<r> factory)` return the value of the factory for the subscriber- [x] ~~`lock(lock lock)` or `synchronize(lock lock)` to support juclocks for synchronization~~- [x] ~~using with javaiocloseable~~  - ~~`using(func0<c> func1<c observable<t>>)`~~  - ~~`usingfuture(func1<booleansubscription future<c>> func2<c booleansubscription future<observable<t>>>)`~~;reviewed by @headinthebox and i for things that should not be added and used ~~strikethrough~~ so they are still on the list but marked to not work on || > lock(lock lock) or synchronize(lock lock) to support juclocks for synchronizationwhat is a use case when this would ever be needed? @headinthebox mentioned that its not really used in rxnet so likely not worth us adding  || okay no worries i wont start working on the remaining ones for at least a week || closing this and ignoring `just(func0<r> factory)` ||;1;0;buffer with observable boundary;
734;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;delay with subscription and item delaying observables.;listed in #653  note: onerror and oncompleted events of the source are immediately propagated and will prevent emitting any pending values.;;653.0;delay with subscription and item delaying observables;listed in #653note: onerror and oncompleted events of the source are immediately propagated and will prevent emitting any pending values;#648  #660;more operators/overloads;rxnet 222-  ~~aggregate (pr #657)~~  - `aggregate(seed accumulator resultselector)`-  average (pr #657 m)  -  `average(func1<t number> valueselector)`-  buffer (pr #733)  - `buffer(observable<u> bufferboundaries)`-  ~~create async~~  - ~~`create(func1<observer<r> task>)`~~  - ~~`create(func1<observer<r> task<action>>)`~~  - ~~`create(func1<observer<r> task<idisposable>>)`~~  - ~~`create(func2<observer<r> cancellationtoken task>)`~~  - ~~`create(func2<observer<r> cancellationtoken task<action>>)`~~  - ~~`create(func2<observer<r> cancellationtoken task<idisposable>>)`~~-  delay (pr #734)  - `delay(func1<t observable<tdelay>>)`  - `delay(func0<observable<d1>> subscriptiondelay func1<t observable<d2>> itemdelay)`-  ~~empty (pr #654)~~  - ~~`empty(t witness)`~~  - ~~`empty(scheduler t witness)`~~-  ~~never (pr #654)~~  - ~~`never(t witness)`~~-  publish (pr #738)  - `publish(func1<observable<tsource> observable<tresult>> sel)`  - `publish(tsource initialvalue)`  - `publish(func1<observable<tsource> observable<tresult>> sel tsource initialvalue)`-  publishlast (pr #738)  - `publishlast(func1<observable<tsource> observable<tresult>> sel)`-  selectmany (flatmap) (pr #736)  - `selectmany(func1<t observable<u>> collection func2<t u r> resultsel)`  - `selectmany(func1<t observable<r>> onnext func1<exception observable<r>> onerror func0<observable<r>> oncompleted)`  - `selectmany(func1<t ienumerable<r>>)`  - `selectmany(func2<t ienumerable<u>> func2<t u r>)`  - ~~----------------------------------~~  - ~~`selectmany(func2<t integer observable<r>>)`~~  - ~~`selectmany(func1<t task<r>>)`~~  - ~~`selectmany(func2<t integer task<r>>)`~~  - ~~`selectmany(func2<t cancellationtoken task<r>>)`~~  - ~~`selectmany(func3<t integer cancellationtokenk task<r>>)`~~  - ~~`selectmany(func1<t integer observable<u>> collection func4<t integer  u integr r> resultsel)`~~  - ~~`selectmany(func1<t task<u>> func2<t u r>)`~~  - ~~`selectmany(func2<t integer task<u>> func2<t integer u r>)`~~  - ~~`selectmany(func2<t ct task<u>> func2<t u r>)`~~  - ~~`selectmany(func3<t integer ct task<u>> func2<t integer u r>)`~~  - ~~`selectmany(func2<t integer observable<r>> onnext func1<exception observable<r>> onerror func0<observable<r>> oncompleted)`~~  - ~~`selectmany(func2<t integer ienumerable<r>>)`~~  - ~~`selectmany(func3<t integer ienumerable<u>> func4<t integer u integer r>)`~~- [x] skip (pr #655 m)  - `skip(timespan)`  - `skip(timespan scheduler)`- [x] skiplast  (pr #655 m)  - `skiplast(timespan)`  - `skiplast(timespan scheduler)`- [x] sum (pr #657 m)  - `sum(func1<t number> valueselector)`- [x] take  (pr #655 m)  - `take(timespan)`  - `take(timespan scheduler)`- [x] takelast  (pr #655 m)  - `takelast(timespan)`  - `takelast(timespan scheduler)`  - `takelast(timespan scheduler duration scheduler drain)`- [x] throttle (debounce) (pr #739)  - `throttle(func1<t observable<void>>)`- [x] timeout (pr #740)  - `timeout(func1<t observable<void>>)`  - `timeout(func1<t observable<void>> observable<t> other)`  - `timeout(func0<observable<void>> func1<t observable<void>>)`  - `timeout(func0<observable<void>> func1<t observable<void>> observable<t> other)`- [x] ~~throw (error) (pr #654)~~  - ~~`error(throwable t t witness)`~~  - ~~`error(throwable t scheduler t witness)`~~- [x] ~~using async~~  - ~~`using(func1<cancellationtoken task<tresource>> func2<tresource cancellationtoken task<observable<t>>>)`~~- [x] ~~where~~  - ~~`where(func2<t integer boolean>)`~~- [x] window (pr #735)  - `window(observable<u> windowboundaries)`- [x] zip (pr #741)  - ~~`zip(ienumerable<observable<s>> sources func1<ilist<s> r> selector)`~~ (already have with funcn)  - `zip(iterable<u> other func2<t u r> result)` (instance method)  - `zip(observable<u> other func2<t u r> result)` (instance method)potential java specific operators/overloads:-  `just(func0<r> factory)` return the value of the factory for the subscriber- [x] ~~`lock(lock lock)` or `synchronize(lock lock)` to support juclocks for synchronization~~- [x] ~~using with javaiocloseable~~  - ~~`using(func0<c> func1<c observable<t>>)`~~  - ~~`usingfuture(func1<booleansubscription future<c>> func2<c booleansubscription future<observable<t>>>)`~~;reviewed by @headinthebox and i for things that should not be added and used ~~strikethrough~~ so they are still on the list but marked to not work on || > lock(lock lock) or synchronize(lock lock) to support juclocks for synchronizationwhat is a use case when this would ever be needed? @headinthebox mentioned that its not really used in rxnet so likely not worth us adding  || okay no worries i wont start working on the remaining ones for at least a week || closing this and ignoring `just(func0<r> factory)` ||;1;0;modified to conform rxnet;
735;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;window with observable boundary.;listed in issue #653.;;653.0;window with observable boundary;listed in issue #653;#649 ;more operators/overloads;rxnet 222-  ~~aggregate (pr #657)~~  - `aggregate(seed accumulator resultselector)`-  average (pr #657 m)  -  `average(func1<t number> valueselector)`-  buffer (pr #733)  - `buffer(observable<u> bufferboundaries)`-  ~~create async~~  - ~~`create(func1<observer<r> task>)`~~  - ~~`create(func1<observer<r> task<action>>)`~~  - ~~`create(func1<observer<r> task<idisposable>>)`~~  - ~~`create(func2<observer<r> cancellationtoken task>)`~~  - ~~`create(func2<observer<r> cancellationtoken task<action>>)`~~  - ~~`create(func2<observer<r> cancellationtoken task<idisposable>>)`~~-  delay (pr #734)  - `delay(func1<t observable<tdelay>>)`  - `delay(func0<observable<d1>> subscriptiondelay func1<t observable<d2>> itemdelay)`-  ~~empty (pr #654)~~  - ~~`empty(t witness)`~~  - ~~`empty(scheduler t witness)`~~-  ~~never (pr #654)~~  - ~~`never(t witness)`~~-  publish (pr #738)  - `publish(func1<observable<tsource> observable<tresult>> sel)`  - `publish(tsource initialvalue)`  - `publish(func1<observable<tsource> observable<tresult>> sel tsource initialvalue)`-  publishlast (pr #738)  - `publishlast(func1<observable<tsource> observable<tresult>> sel)`-  selectmany (flatmap) (pr #736)  - `selectmany(func1<t observable<u>> collection func2<t u r> resultsel)`  - `selectmany(func1<t observable<r>> onnext func1<exception observable<r>> onerror func0<observable<r>> oncompleted)`  - `selectmany(func1<t ienumerable<r>>)`  - `selectmany(func2<t ienumerable<u>> func2<t u r>)`  - ~~----------------------------------~~  - ~~`selectmany(func2<t integer observable<r>>)`~~  - ~~`selectmany(func1<t task<r>>)`~~  - ~~`selectmany(func2<t integer task<r>>)`~~  - ~~`selectmany(func2<t cancellationtoken task<r>>)`~~  - ~~`selectmany(func3<t integer cancellationtokenk task<r>>)`~~  - ~~`selectmany(func1<t integer observable<u>> collection func4<t integer  u integr r> resultsel)`~~  - ~~`selectmany(func1<t task<u>> func2<t u r>)`~~  - ~~`selectmany(func2<t integer task<u>> func2<t integer u r>)`~~  - ~~`selectmany(func2<t ct task<u>> func2<t u r>)`~~  - ~~`selectmany(func3<t integer ct task<u>> func2<t integer u r>)`~~  - ~~`selectmany(func2<t integer observable<r>> onnext func1<exception observable<r>> onerror func0<observable<r>> oncompleted)`~~  - ~~`selectmany(func2<t integer ienumerable<r>>)`~~  - ~~`selectmany(func3<t integer ienumerable<u>> func4<t integer u integer r>)`~~- [x] skip (pr #655 m)  - `skip(timespan)`  - `skip(timespan scheduler)`- [x] skiplast  (pr #655 m)  - `skiplast(timespan)`  - `skiplast(timespan scheduler)`- [x] sum (pr #657 m)  - `sum(func1<t number> valueselector)`- [x] take  (pr #655 m)  - `take(timespan)`  - `take(timespan scheduler)`- [x] takelast  (pr #655 m)  - `takelast(timespan)`  - `takelast(timespan scheduler)`  - `takelast(timespan scheduler duration scheduler drain)`- [x] throttle (debounce) (pr #739)  - `throttle(func1<t observable<void>>)`- [x] timeout (pr #740)  - `timeout(func1<t observable<void>>)`  - `timeout(func1<t observable<void>> observable<t> other)`  - `timeout(func0<observable<void>> func1<t observable<void>>)`  - `timeout(func0<observable<void>> func1<t observable<void>> observable<t> other)`- [x] ~~throw (error) (pr #654)~~  - ~~`error(throwable t t witness)`~~  - ~~`error(throwable t scheduler t witness)`~~- [x] ~~using async~~  - ~~`using(func1<cancellationtoken task<tresource>> func2<tresource cancellationtoken task<observable<t>>>)`~~- [x] ~~where~~  - ~~`where(func2<t integer boolean>)`~~- [x] window (pr #735)  - `window(observable<u> windowboundaries)`- [x] zip (pr #741)  - ~~`zip(ienumerable<observable<s>> sources func1<ilist<s> r> selector)`~~ (already have with funcn)  - `zip(iterable<u> other func2<t u r> result)` (instance method)  - `zip(observable<u> other func2<t u r> result)` (instance method)potential java specific operators/overloads:-  `just(func0<r> factory)` return the value of the factory for the subscriber- [x] ~~`lock(lock lock)` or `synchronize(lock lock)` to support juclocks for synchronization~~- [x] ~~using with javaiocloseable~~  - ~~`using(func0<c> func1<c observable<t>>)`~~  - ~~`usingfuture(func1<booleansubscription future<c>> func2<c booleansubscription future<observable<t>>>)`~~;reviewed by @headinthebox and i for things that should not be added and used ~~strikethrough~~ so they are still on the list but marked to not work on || > lock(lock lock) or synchronize(lock lock) to support juclocks for synchronizationwhat is a use case when this would ever be needed? @headinthebox mentioned that its not really used in rxnet so likely not worth us adding  || okay no worries i wont start working on the remaining ones for at least a week || closing this and ignoring `just(func0<r> factory)` ||;1;0;window with observable boundary;
736;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;mergemap with iterable and resultselector overloads;listed in #653.;;653.0;mergemap with iterable and resultselector overloads;listed in #653;forgot an overload || #650  #651 looks these operators can be implemented by composing the existing operators || i agree there is likely some simplification we can do on this but im going to merge as the public apis look correct and unit tests are good we can iterate on the implementation internally ||;more operators/overloads;rxnet 222-  ~~aggregate (pr #657)~~  - `aggregate(seed accumulator resultselector)`-  average (pr #657 m)  -  `average(func1<t number> valueselector)`-  buffer (pr #733)  - `buffer(observable<u> bufferboundaries)`-  ~~create async~~  - ~~`create(func1<observer<r> task>)`~~  - ~~`create(func1<observer<r> task<action>>)`~~  - ~~`create(func1<observer<r> task<idisposable>>)`~~  - ~~`create(func2<observer<r> cancellationtoken task>)`~~  - ~~`create(func2<observer<r> cancellationtoken task<action>>)`~~  - ~~`create(func2<observer<r> cancellationtoken task<idisposable>>)`~~-  delay (pr #734)  - `delay(func1<t observable<tdelay>>)`  - `delay(func0<observable<d1>> subscriptiondelay func1<t observable<d2>> itemdelay)`-  ~~empty (pr #654)~~  - ~~`empty(t witness)`~~  - ~~`empty(scheduler t witness)`~~-  ~~never (pr #654)~~  - ~~`never(t witness)`~~-  publish (pr #738)  - `publish(func1<observable<tsource> observable<tresult>> sel)`  - `publish(tsource initialvalue)`  - `publish(func1<observable<tsource> observable<tresult>> sel tsource initialvalue)`-  publishlast (pr #738)  - `publishlast(func1<observable<tsource> observable<tresult>> sel)`-  selectmany (flatmap) (pr #736)  - `selectmany(func1<t observable<u>> collection func2<t u r> resultsel)`  - `selectmany(func1<t observable<r>> onnext func1<exception observable<r>> onerror func0<observable<r>> oncompleted)`  - `selectmany(func1<t ienumerable<r>>)`  - `selectmany(func2<t ienumerable<u>> func2<t u r>)`  - ~~----------------------------------~~  - ~~`selectmany(func2<t integer observable<r>>)`~~  - ~~`selectmany(func1<t task<r>>)`~~  - ~~`selectmany(func2<t integer task<r>>)`~~  - ~~`selectmany(func2<t cancellationtoken task<r>>)`~~  - ~~`selectmany(func3<t integer cancellationtokenk task<r>>)`~~  - ~~`selectmany(func1<t integer observable<u>> collection func4<t integer  u integr r> resultsel)`~~  - ~~`selectmany(func1<t task<u>> func2<t u r>)`~~  - ~~`selectmany(func2<t integer task<u>> func2<t integer u r>)`~~  - ~~`selectmany(func2<t ct task<u>> func2<t u r>)`~~  - ~~`selectmany(func3<t integer ct task<u>> func2<t integer u r>)`~~  - ~~`selectmany(func2<t integer observable<r>> onnext func1<exception observable<r>> onerror func0<observable<r>> oncompleted)`~~  - ~~`selectmany(func2<t integer ienumerable<r>>)`~~  - ~~`selectmany(func3<t integer ienumerable<u>> func4<t integer u integer r>)`~~- [x] skip (pr #655 m)  - `skip(timespan)`  - `skip(timespan scheduler)`- [x] skiplast  (pr #655 m)  - `skiplast(timespan)`  - `skiplast(timespan scheduler)`- [x] sum (pr #657 m)  - `sum(func1<t number> valueselector)`- [x] take  (pr #655 m)  - `take(timespan)`  - `take(timespan scheduler)`- [x] takelast  (pr #655 m)  - `takelast(timespan)`  - `takelast(timespan scheduler)`  - `takelast(timespan scheduler duration scheduler drain)`- [x] throttle (debounce) (pr #739)  - `throttle(func1<t observable<void>>)`- [x] timeout (pr #740)  - `timeout(func1<t observable<void>>)`  - `timeout(func1<t observable<void>> observable<t> other)`  - `timeout(func0<observable<void>> func1<t observable<void>>)`  - `timeout(func0<observable<void>> func1<t observable<void>> observable<t> other)`- [x] ~~throw (error) (pr #654)~~  - ~~`error(throwable t t witness)`~~  - ~~`error(throwable t scheduler t witness)`~~- [x] ~~using async~~  - ~~`using(func1<cancellationtoken task<tresource>> func2<tresource cancellationtoken task<observable<t>>>)`~~- [x] ~~where~~  - ~~`where(func2<t integer boolean>)`~~- [x] window (pr #735)  - `window(observable<u> windowboundaries)`- [x] zip (pr #741)  - ~~`zip(ienumerable<observable<s>> sources func1<ilist<s> r> selector)`~~ (already have with funcn)  - `zip(iterable<u> other func2<t u r> result)` (instance method)  - `zip(observable<u> other func2<t u r> result)` (instance method)potential java specific operators/overloads:-  `just(func0<r> factory)` return the value of the factory for the subscriber- [x] ~~`lock(lock lock)` or `synchronize(lock lock)` to support juclocks for synchronization~~- [x] ~~using with javaiocloseable~~  - ~~`using(func0<c> func1<c observable<t>>)`~~  - ~~`usingfuture(func1<booleansubscription future<c>> func2<c booleansubscription future<observable<t>>>)`~~;reviewed by @headinthebox and i for things that should not be added and used ~~strikethrough~~ so they are still on the list but marked to not work on || > lock(lock lock) or synchronize(lock lock) to support juclocks for synchronizationwhat is a use case when this would ever be needed? @headinthebox mentioned that its not really used in rxnet so likely not worth us adding  || okay no worries i wont start working on the remaining ones for at least a week || closing this and ignoring `just(func0<r> factory)` ||;1;0;added event-merger overload;
738;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;publish and publishlast overloads;listed in #653  these operators use the existing multicast and subject infrastructure so i omitted any direct tests.;;653.0;publish and publishlast overloads;listed in #653these operators use the existing multicast and subject infrastructure so i omitted any direct tests;#652  #653;more operators/overloads;rxnet 222-  ~~aggregate (pr #657)~~  - `aggregate(seed accumulator resultselector)`-  average (pr #657 m)  -  `average(func1<t number> valueselector)`-  buffer (pr #733)  - `buffer(observable<u> bufferboundaries)`-  ~~create async~~  - ~~`create(func1<observer<r> task>)`~~  - ~~`create(func1<observer<r> task<action>>)`~~  - ~~`create(func1<observer<r> task<idisposable>>)`~~  - ~~`create(func2<observer<r> cancellationtoken task>)`~~  - ~~`create(func2<observer<r> cancellationtoken task<action>>)`~~  - ~~`create(func2<observer<r> cancellationtoken task<idisposable>>)`~~-  delay (pr #734)  - `delay(func1<t observable<tdelay>>)`  - `delay(func0<observable<d1>> subscriptiondelay func1<t observable<d2>> itemdelay)`-  ~~empty (pr #654)~~  - ~~`empty(t witness)`~~  - ~~`empty(scheduler t witness)`~~-  ~~never (pr #654)~~  - ~~`never(t witness)`~~-  publish (pr #738)  - `publish(func1<observable<tsource> observable<tresult>> sel)`  - `publish(tsource initialvalue)`  - `publish(func1<observable<tsource> observable<tresult>> sel tsource initialvalue)`-  publishlast (pr #738)  - `publishlast(func1<observable<tsource> observable<tresult>> sel)`-  selectmany (flatmap) (pr #736)  - `selectmany(func1<t observable<u>> collection func2<t u r> resultsel)`  - `selectmany(func1<t observable<r>> onnext func1<exception observable<r>> onerror func0<observable<r>> oncompleted)`  - `selectmany(func1<t ienumerable<r>>)`  - `selectmany(func2<t ienumerable<u>> func2<t u r>)`  - ~~----------------------------------~~  - ~~`selectmany(func2<t integer observable<r>>)`~~  - ~~`selectmany(func1<t task<r>>)`~~  - ~~`selectmany(func2<t integer task<r>>)`~~  - ~~`selectmany(func2<t cancellationtoken task<r>>)`~~  - ~~`selectmany(func3<t integer cancellationtokenk task<r>>)`~~  - ~~`selectmany(func1<t integer observable<u>> collection func4<t integer  u integr r> resultsel)`~~  - ~~`selectmany(func1<t task<u>> func2<t u r>)`~~  - ~~`selectmany(func2<t integer task<u>> func2<t integer u r>)`~~  - ~~`selectmany(func2<t ct task<u>> func2<t u r>)`~~  - ~~`selectmany(func3<t integer ct task<u>> func2<t integer u r>)`~~  - ~~`selectmany(func2<t integer observable<r>> onnext func1<exception observable<r>> onerror func0<observable<r>> oncompleted)`~~  - ~~`selectmany(func2<t integer ienumerable<r>>)`~~  - ~~`selectmany(func3<t integer ienumerable<u>> func4<t integer u integer r>)`~~- [x] skip (pr #655 m)  - `skip(timespan)`  - `skip(timespan scheduler)`- [x] skiplast  (pr #655 m)  - `skiplast(timespan)`  - `skiplast(timespan scheduler)`- [x] sum (pr #657 m)  - `sum(func1<t number> valueselector)`- [x] take  (pr #655 m)  - `take(timespan)`  - `take(timespan scheduler)`- [x] takelast  (pr #655 m)  - `takelast(timespan)`  - `takelast(timespan scheduler)`  - `takelast(timespan scheduler duration scheduler drain)`- [x] throttle (debounce) (pr #739)  - `throttle(func1<t observable<void>>)`- [x] timeout (pr #740)  - `timeout(func1<t observable<void>>)`  - `timeout(func1<t observable<void>> observable<t> other)`  - `timeout(func0<observable<void>> func1<t observable<void>>)`  - `timeout(func0<observable<void>> func1<t observable<void>> observable<t> other)`- [x] ~~throw (error) (pr #654)~~  - ~~`error(throwable t t witness)`~~  - ~~`error(throwable t scheduler t witness)`~~- [x] ~~using async~~  - ~~`using(func1<cancellationtoken task<tresource>> func2<tresource cancellationtoken task<observable<t>>>)`~~- [x] ~~where~~  - ~~`where(func2<t integer boolean>)`~~- [x] window (pr #735)  - `window(observable<u> windowboundaries)`- [x] zip (pr #741)  - ~~`zip(ienumerable<observable<s>> sources func1<ilist<s> r> selector)`~~ (already have with funcn)  - `zip(iterable<u> other func2<t u r> result)` (instance method)  - `zip(observable<u> other func2<t u r> result)` (instance method)potential java specific operators/overloads:-  `just(func0<r> factory)` return the value of the factory for the subscriber- [x] ~~`lock(lock lock)` or `synchronize(lock lock)` to support juclocks for synchronization~~- [x] ~~using with javaiocloseable~~  - ~~`using(func0<c> func1<c observable<t>>)`~~  - ~~`usingfuture(func1<booleansubscription future<c>> func2<c booleansubscription future<observable<t>>>)`~~;reviewed by @headinthebox and i for things that should not be added and used ~~strikethrough~~ so they are still on the list but marked to not work on || > lock(lock lock) or synchronize(lock lock) to support juclocks for synchronizationwhat is a use case when this would ever be needed? @headinthebox mentioned that its not really used in rxnet so likely not worth us adding  || okay no worries i wont start working on the remaining ones for at least a week || closing this and ignoring `just(func0<r> factory)` ||;1;0;added variance to selector functions;
739;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;debounce with selector;listed in #653;;0;debounce with selector;listed in #653;#654 ;;;;1;1;debounce with selector;
740;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;timeout with selector overloads;listed in #653.;;653.0;timeout with selector overloads;listed in #653;#655 ;more operators/overloads;rxnet 222-  ~~aggregate (pr #657)~~  - `aggregate(seed accumulator resultselector)`-  average (pr #657 m)  -  `average(func1<t number> valueselector)`-  buffer (pr #733)  - `buffer(observable<u> bufferboundaries)`-  ~~create async~~  - ~~`create(func1<observer<r> task>)`~~  - ~~`create(func1<observer<r> task<action>>)`~~  - ~~`create(func1<observer<r> task<idisposable>>)`~~  - ~~`create(func2<observer<r> cancellationtoken task>)`~~  - ~~`create(func2<observer<r> cancellationtoken task<action>>)`~~  - ~~`create(func2<observer<r> cancellationtoken task<idisposable>>)`~~-  delay (pr #734)  - `delay(func1<t observable<tdelay>>)`  - `delay(func0<observable<d1>> subscriptiondelay func1<t observable<d2>> itemdelay)`-  ~~empty (pr #654)~~  - ~~`empty(t witness)`~~  - ~~`empty(scheduler t witness)`~~-  ~~never (pr #654)~~  - ~~`never(t witness)`~~-  publish (pr #738)  - `publish(func1<observable<tsource> observable<tresult>> sel)`  - `publish(tsource initialvalue)`  - `publish(func1<observable<tsource> observable<tresult>> sel tsource initialvalue)`-  publishlast (pr #738)  - `publishlast(func1<observable<tsource> observable<tresult>> sel)`-  selectmany (flatmap) (pr #736)  - `selectmany(func1<t observable<u>> collection func2<t u r> resultsel)`  - `selectmany(func1<t observable<r>> onnext func1<exception observable<r>> onerror func0<observable<r>> oncompleted)`  - `selectmany(func1<t ienumerable<r>>)`  - `selectmany(func2<t ienumerable<u>> func2<t u r>)`  - ~~----------------------------------~~  - ~~`selectmany(func2<t integer observable<r>>)`~~  - ~~`selectmany(func1<t task<r>>)`~~  - ~~`selectmany(func2<t integer task<r>>)`~~  - ~~`selectmany(func2<t cancellationtoken task<r>>)`~~  - ~~`selectmany(func3<t integer cancellationtokenk task<r>>)`~~  - ~~`selectmany(func1<t integer observable<u>> collection func4<t integer  u integr r> resultsel)`~~  - ~~`selectmany(func1<t task<u>> func2<t u r>)`~~  - ~~`selectmany(func2<t integer task<u>> func2<t integer u r>)`~~  - ~~`selectmany(func2<t ct task<u>> func2<t u r>)`~~  - ~~`selectmany(func3<t integer ct task<u>> func2<t integer u r>)`~~  - ~~`selectmany(func2<t integer observable<r>> onnext func1<exception observable<r>> onerror func0<observable<r>> oncompleted)`~~  - ~~`selectmany(func2<t integer ienumerable<r>>)`~~  - ~~`selectmany(func3<t integer ienumerable<u>> func4<t integer u integer r>)`~~- [x] skip (pr #655 m)  - `skip(timespan)`  - `skip(timespan scheduler)`- [x] skiplast  (pr #655 m)  - `skiplast(timespan)`  - `skiplast(timespan scheduler)`- [x] sum (pr #657 m)  - `sum(func1<t number> valueselector)`- [x] take  (pr #655 m)  - `take(timespan)`  - `take(timespan scheduler)`- [x] takelast  (pr #655 m)  - `takelast(timespan)`  - `takelast(timespan scheduler)`  - `takelast(timespan scheduler duration scheduler drain)`- [x] throttle (debounce) (pr #739)  - `throttle(func1<t observable<void>>)`- [x] timeout (pr #740)  - `timeout(func1<t observable<void>>)`  - `timeout(func1<t observable<void>> observable<t> other)`  - `timeout(func0<observable<void>> func1<t observable<void>>)`  - `timeout(func0<observable<void>> func1<t observable<void>> observable<t> other)`- [x] ~~throw (error) (pr #654)~~  - ~~`error(throwable t t witness)`~~  - ~~`error(throwable t scheduler t witness)`~~- [x] ~~using async~~  - ~~`using(func1<cancellationtoken task<tresource>> func2<tresource cancellationtoken task<observable<t>>>)`~~- [x] ~~where~~  - ~~`where(func2<t integer boolean>)`~~- [x] window (pr #735)  - `window(observable<u> windowboundaries)`- [x] zip (pr #741)  - ~~`zip(ienumerable<observable<s>> sources func1<ilist<s> r> selector)`~~ (already have with funcn)  - `zip(iterable<u> other func2<t u r> result)` (instance method)  - `zip(observable<u> other func2<t u r> result)` (instance method)potential java specific operators/overloads:-  `just(func0<r> factory)` return the value of the factory for the subscriber- [x] ~~`lock(lock lock)` or `synchronize(lock lock)` to support juclocks for synchronization~~- [x] ~~using with javaiocloseable~~  - ~~`using(func0<c> func1<c observable<t>>)`~~  - ~~`usingfuture(func1<booleansubscription future<c>> func2<c booleansubscription future<observable<t>>>)`~~;reviewed by @headinthebox and i for things that should not be added and used ~~strikethrough~~ so they are still on the list but marked to not work on || > lock(lock lock) or synchronize(lock lock) to support juclocks for synchronizationwhat is a use case when this would ever be needed? @headinthebox mentioned that its not really used in rxnet so likely not worth us adding  || okay no worries i wont start working on the remaining ones for at least a week || closing this and ignoring `just(func0<r> factory)` ||;1;0;timeout with selector overloads;
741;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;zip with iterable  removed old aggregator version and updated tests;listed in #653.;;653.0;zip with iterable removed old aggregator version and updated tests;listed in #653;#656  these are instance methods none of our `zip` operators are at the instance level i would have thought wed add the `zip` overloads with `iterable` to match the existing static ones? || i went according to #653 where there was 2 zip overloads without strike-through || agreed on the overloads but they should be static correct? || no the intention was to chain them to an existing observable:``` javaobservablefrom(1 2 3)zip(arraysaslist(4 5 6) (a b) -> a * b)``` || makes sense wasnt sure as it was different than all the other zip methods thanks for confirming  ||;more operators/overloads;rxnet 222-  ~~aggregate (pr #657)~~  - `aggregate(seed accumulator resultselector)`-  average (pr #657 m)  -  `average(func1<t number> valueselector)`-  buffer (pr #733)  - `buffer(observable<u> bufferboundaries)`-  ~~create async~~  - ~~`create(func1<observer<r> task>)`~~  - ~~`create(func1<observer<r> task<action>>)`~~  - ~~`create(func1<observer<r> task<idisposable>>)`~~  - ~~`create(func2<observer<r> cancellationtoken task>)`~~  - ~~`create(func2<observer<r> cancellationtoken task<action>>)`~~  - ~~`create(func2<observer<r> cancellationtoken task<idisposable>>)`~~-  delay (pr #734)  - `delay(func1<t observable<tdelay>>)`  - `delay(func0<observable<d1>> subscriptiondelay func1<t observable<d2>> itemdelay)`-  ~~empty (pr #654)~~  - ~~`empty(t witness)`~~  - ~~`empty(scheduler t witness)`~~-  ~~never (pr #654)~~  - ~~`never(t witness)`~~-  publish (pr #738)  - `publish(func1<observable<tsource> observable<tresult>> sel)`  - `publish(tsource initialvalue)`  - `publish(func1<observable<tsource> observable<tresult>> sel tsource initialvalue)`-  publishlast (pr #738)  - `publishlast(func1<observable<tsource> observable<tresult>> sel)`-  selectmany (flatmap) (pr #736)  - `selectmany(func1<t observable<u>> collection func2<t u r> resultsel)`  - `selectmany(func1<t observable<r>> onnext func1<exception observable<r>> onerror func0<observable<r>> oncompleted)`  - `selectmany(func1<t ienumerable<r>>)`  - `selectmany(func2<t ienumerable<u>> func2<t u r>)`  - ~~----------------------------------~~  - ~~`selectmany(func2<t integer observable<r>>)`~~  - ~~`selectmany(func1<t task<r>>)`~~  - ~~`selectmany(func2<t integer task<r>>)`~~  - ~~`selectmany(func2<t cancellationtoken task<r>>)`~~  - ~~`selectmany(func3<t integer cancellationtokenk task<r>>)`~~  - ~~`selectmany(func1<t integer observable<u>> collection func4<t integer  u integr r> resultsel)`~~  - ~~`selectmany(func1<t task<u>> func2<t u r>)`~~  - ~~`selectmany(func2<t integer task<u>> func2<t integer u r>)`~~  - ~~`selectmany(func2<t ct task<u>> func2<t u r>)`~~  - ~~`selectmany(func3<t integer ct task<u>> func2<t integer u r>)`~~  - ~~`selectmany(func2<t integer observable<r>> onnext func1<exception observable<r>> onerror func0<observable<r>> oncompleted)`~~  - ~~`selectmany(func2<t integer ienumerable<r>>)`~~  - ~~`selectmany(func3<t integer ienumerable<u>> func4<t integer u integer r>)`~~- [x] skip (pr #655 m)  - `skip(timespan)`  - `skip(timespan scheduler)`- [x] skiplast  (pr #655 m)  - `skiplast(timespan)`  - `skiplast(timespan scheduler)`- [x] sum (pr #657 m)  - `sum(func1<t number> valueselector)`- [x] take  (pr #655 m)  - `take(timespan)`  - `take(timespan scheduler)`- [x] takelast  (pr #655 m)  - `takelast(timespan)`  - `takelast(timespan scheduler)`  - `takelast(timespan scheduler duration scheduler drain)`- [x] throttle (debounce) (pr #739)  - `throttle(func1<t observable<void>>)`- [x] timeout (pr #740)  - `timeout(func1<t observable<void>>)`  - `timeout(func1<t observable<void>> observable<t> other)`  - `timeout(func0<observable<void>> func1<t observable<void>>)`  - `timeout(func0<observable<void>> func1<t observable<void>> observable<t> other)`- [x] ~~throw (error) (pr #654)~~  - ~~`error(throwable t t witness)`~~  - ~~`error(throwable t scheduler t witness)`~~- [x] ~~using async~~  - ~~`using(func1<cancellationtoken task<tresource>> func2<tresource cancellationtoken task<observable<t>>>)`~~- [x] ~~where~~  - ~~`where(func2<t integer boolean>)`~~- [x] window (pr #735)  - `window(observable<u> windowboundaries)`- [x] zip (pr #741)  - ~~`zip(ienumerable<observable<s>> sources func1<ilist<s> r> selector)`~~ (already have with funcn)  - `zip(iterable<u> other func2<t u r> result)` (instance method)  - `zip(observable<u> other func2<t u r> result)` (instance method)potential java specific operators/overloads:-  `just(func0<r> factory)` return the value of the factory for the subscriber- [x] ~~`lock(lock lock)` or `synchronize(lock lock)` to support juclocks for synchronization~~- [x] ~~using with javaiocloseable~~  - ~~`using(func0<c> func1<c observable<t>>)`~~  - ~~`usingfuture(func1<booleansubscription future<c>> func2<c booleansubscription future<observable<t>>>)`~~;reviewed by @headinthebox and i for things that should not be added and used ~~strikethrough~~ so they are still on the list but marked to not work on || > lock(lock lock) or synchronize(lock lock) to support juclocks for synchronizationwhat is a use case when this would ever be needed? @headinthebox mentioned that its not really used in rxnet so likely not worth us adding  || okay no worries i wont start working on the remaining ones for at least a week || closing this and ignoring `just(func0<r> factory)` ||;1;0;zip with iterable removed old aggregator version and updated tests;
752;1;0;0;0;0;1;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;organize  format  alphabetize and finalize;code cleanup after the many new operators that have come in over the past 2 months.  1) organized imports 2) formatted all code for standard whitespace  code formatting etc 3) sorted methods in  observable.java  alphabetically 4) updated all license headers 5) made  observable  methods final as they are not intended to be overridden in the rare cases when inheritance makes sense for  observable . this better communicates the inheritance intent of the class and prevents against accidental misuse (such as overriding  subscribe  which breaks it).;;0;organize format alphabetize and finalize;code cleanup after the many new operators that have come in over the past 2 months1) organized imports2) formatted all code for standard whitespace code formatting etc3) sorted methods in `observablejava` alphabetically4) updated all license headers5) made `observable` methods final as they are not intended to be overridden in the rare cases when inheritance makes sense for `observable` this better communicates the inheritance intent of the class and prevents against accidental misuse (such as overriding `subscribe` which breaks it);#667 ;;;;1;1;updating license headers- since im touching all files for the other commits ill update the copyright headers as well;
"755;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add marble diagrams to new operators & variants.;add javadoc  @deprecated use  where appropriate. some javadoc comment reformatting (e.g. overlong lines).;;0;add marble diagrams to new operators & variants;""add javadoc """"@deprecated use"""" where appropriatesome javadoc comment reformatting (eg overlong lines)"";#673 ;;;;1;1;""add marble diagrams to new operators & variantsadd javadoc """"@deprecated use"""" where appropriatesome javadoc comment reformatting (eg overlong lines)"";"
762;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;adding javadoc marble diagram for the mergemap(next completed error) variety;;;0;adding javadoc marble diagram for the mergemap(nextcompletederror) variety;;#675 ;;;;1;1;adding javadoc marble diagram for the mergemap(nextcompletederror) variety;
765;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;a variety of improvements to the javadoc text.;;;0;a variety of improvements to the javadoc text;;#677 ;;;;1;1;a variety of improvements to the javadoc text;
786;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;careful with that global search and replace  eugene.;restoring the working urls of rxjava wiki pages and marble diagrams in the javadocs http://www.youtube.com/watch?v=aymyxtfwuz8;;0;careful with that global search and replace eugene;restoring the working urls of rxjava wiki pages and marble diagrams in the javadocshttp://wwwyoutubecom/watch?vaymyxtfwuz8;#706  whoops i thought i had  the bad search/replace i did obviously not thanks for fixing those! || i did the same once when working on the scala bindings ||;;;;1;1;careful with that global search and replace eugene;
790;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;convert to scan to use lift;i switched the scan to an operator and cleaned up what looked like a lot of unnecessary code from the summing operations.;;0;convert to scan to use lift;i switched the scan to an operator and cleaned up what looked like a lot of unnecessary code from the summing operations;#711 not sure what went wrong on cloud bees because it works locally from the command line and eclipse || #714 #786 [rxjava-pull-requests #794  to answer @benjchristensens question about the performance of suminteger/float/long/doubleoriginally half of the implementations were based on reduce(r func2<r t r) and the other half were custom  i just removed the custom code for reduce(func2<t t t>) which has the behavior of throwing an error when the observable is emptyim having a hard time imagining a critical situation for sum together an observable numbers to justify so much custom code ||;;;;1;1;convert to scan to use lift;
791;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;improve switchonnext description in javadocs;also: repair anchors in links to rxjava wiki in javadocs;;0;improve switchonnext description in javadocs;also: repair anchors in links to rxjava wiki in javadocs;#712 ;;;;1;1;improve switchonnext description in javadocsrepair anchors in links to rxjava wiki in javadocs;
793;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;observer + subscriber;as per discussion in  the  abstract class observer  has been returned to  interface observer  and there is now  abstract class subscriber implements observer<t>  subscription  to fill that role.  signatures are now:      java // observable.create public final static <t> observable<t> create(onsubscribe<t> f)  // observable.onsubscribe typed function interface public static interface onsubscribe<t> extends action1<subscriber<? super t>>  // observable.subscribe public final subscription subscribe(subscriber<? super t> subscriber) public final subscription subscribe(observer<? super t> observer)  // lift function public <r> observable<r> lift(final func1<subscriber<? super r>  subscriber<? super t>> bind)  // observer public interface observer<t> {      public abstract void onnext(t t)       public abstract void onerror(throwable e)       public abstract void oncompleted()  }  // subscriber public abstract class subscriber<t> implements observer<t>  subscription {      public final void add(subscription s)      public final void unsubscribe()      public final boolean isunsubscribed() }  // subject  public abstract class subject<t  r> extends observable<r> implements observer<t>;;0;observer + subscriber;as per discussion in  the `abstract class observer` has been returned to `interface observer` and there is now `abstract class subscriber implements observer<t> subscription` to fill that rolesignatures are now:``` java// observablecreatepublic final static <t> observable<t> create(onsubscribe<t> f)// observableonsubscribe typed function interfacepublic static interface onsubscribe<t> extends action1<subscriber<? super t>>// observablesubscribepublic final subscription subscribe(subscriber<? super t> subscriber)public final subscription subscribe(observer<? super t> observer)// lift functionpublic <r> observable<r> lift(final func1<subscriber<? super r> subscriber<? super t>> bind)// observerpublic interface observer<t> {     public abstract void onnext(t t)     public abstract void onerror(throwable e)     public abstract void oncompleted()}// subscriberpublic abstract class subscriber<t> implements observer<t> subscription {     public final void add(subscription s)     public final void unsubscribe()     public final boolean isunsubscribed()}// subject public abstract class subject<t r> extends observable<r> implements observer<t>```;#715 ;;;;1;1;fix scala build;
796;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;add subscription.isunsubscribed();with the new model of injecting  subscription  into functions for synchronous loops to check  isunsubscribed()  it now makes sense for this to be on the interface of all  subscription  implementations.;;0;add subscriptionisunsubscribed();with the new model of injecting `subscription` into functions for synchronous loops to check `isunsubscribed()` it now makes sense for this to be on the interface of all `subscription` implementations;#717  thanks ben as you know i wanted this change for a long time!on sat feb 1 2014 at 1:48 am ben christensen notifications@githubcomwrote:> with the new model of injecting subscription into functions for> synchronous loops to check isunsubscribed() it now makes sense for this> > ## to be on the interface of all subscription implementations> > you can merge this pull request by running> >   git pull  subscription-isunsubscribed> > or view comment on or merge it at:> >    commit summary> - add subscriptionisunsubscribed()> > file changes> - _m_>   language-adaptors/rxjava-groovy/src/examples/groovy/rx/lang/groovy/examples/rxexamplesgroovy - _m_>   language-adaptors/rxjava-groovy/src/test/groovy/rx/lang/groovy/observabletestsgroovy - _m_>   language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/subscriptionscala - _m_>   rxjava-contrib/rxjava-android/src/main/java/rx/operators/operationobservefromandroidcomponentjava - _m_ rxjava-core/src/main/java/rx/subscriptionjava - _m_ rxjava-core/src/main/java/rx/operators/chunkedoperationjava - _m_ rxjava-core/src/main/java/rx/operators/operationbufferjava - _m_ rxjava-core/src/main/java/rx/operators/operationconcatjava - _m_ rxjava-core/src/main/java/rx/operators/operationgroupjoinjava - _m_>   rxjava-core/src/main/java/rx/operators/operationmergedelayerrorjava - _m_ rxjava-core/src/main/java/rx/operators/operationmulticastjava - _m_>   rxjava-core/src/main/java/rx/operators/operationonerrorresumenextviafunctionjava - _m_>   rxjava-core/src/main/java/rx/operators/operationonerrorresumenextviaobservablejava - _m_>   rxjava-core/src/main/java/rx/operators/operationonerrorreturnjava - _m_>   rxjava-core/src/main/java/rx/operators/operationonexceptionresumenextviaobservablejava - _m_ rxjava-core/src/main/java/rx/operators/operationreplayjava - _m_ rxjava-core/src/main/java/rx/operators/operationskipuntiljava - _m_ rxjava-core/src/main/java/rx/operators/operationsubscribeonjava - _m_ rxjava-core/src/main/java/rx/operators/operationzipjava - _m_>   rxjava-core/src/main/java/rx/operators/safeobservablesubscriptionjava - _m_>   rxjava-core/src/main/java/rx/schedulers/currentthreadschedulerjava - _m_ rxjava-core/src/main/java/rx/schedulers/discardableactionjava - _m_ rxjava-core/src/main/java/rx/schedulers/executorschedulerjava - _m_ rxjava-core/src/main/java/rx/schedulers/testschedulerjava - _m_>   rxjava-core/src/main/java/rx/subjects/subjectsubscriptionmanagerjava - _m_>   rxjava-core/src/main/java/rx/subscriptions/refcountsubscriptionjava - _m_ rxjava-core/src/main/java/rx/subscriptions/subscriptionsjava - _m_ rxjava-core/src/test/java/rx/operators/operationconcattestjava - _m_>   rxjava-core/src/test/java/rx/operators/operationmaterializetestjava - _m_>   rxjava-core/src/test/java/rx/operators/operationmergedelayerrortestjava - _m_>   rxjava-core/src/test/java/rx/operators/operationsynchronizetestjava - _m_ rxjava-core/src/test/java/rx/operators/operationusingtestjava - _m_ rxjava-core/src/test/java/rx/operators/operatormergetestjava - _m_ rxjava-core/src/test/java/rx/operators/operatortaketestjava - _m_>   rxjava-core/src/test/java/rx/subscriptions/compositesubscriptiontestjava > patch links:> -  -  > ## > > reply to this email directly or view it on github  ||;;;;1;1;add subscriptionisunsubscribed();
801;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;added more possible failure cases to compositeexceptiontest;;;0;added more possible failure cases to compositeexceptiontest;;#726 ;;;;1;1;added more possible failure cases to compositeexceptiontest;
803;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;add testmultiplewithsamecause unittest;also make tests capable of failing with timeouts. before the constructor would immediately go into an infinite loop and hang the tests.;;0;add testmultiplewithsamecause unittest;also make tests capable of failing with timeouts before the constructor would immediately go into an infinite loop and hang the tests;#727 ;;;;1;1;add testmultiplewithsamecause unittestalso make tests capable of failing with timeouts before the constructor would immediately go into an infinite loop and hang the tests;
805;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;fix compositeexception;this fixes possible issues where infinite loops could be created if the right combination of exceptions and causal chains were composed together.;;0;fix compositeexception;this fixes possible issues where infinite loops could be created if the right combination of exceptions and causal chains were composed together;#730;;;;1;1;add testmultiplewithsamecause unittestalso make tests capable of failing with timeouts before the constructor would immediately go into an infinite loop and hang the tests;
816;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;one global oncompleted object;issue https://github.com/netflix/rxjava/issues/662;;0;one global oncompleted object;issue https://githubcom/netflix/rxjava/issues/662;#736 the failing tests are```rxoperatorsoperationconditionalstesttestdowhilemanytimesrxoperatorsoperationconditionalstesttestwhiledomanytimes```and they already failed on my machine before i made any changes || curious what performance/memory gains does this represent? oncompleted by definition happens only once per `observable` so its negligible compared with the cost of wrapping `t` with `notification` || yes i think the performance/memory gains are very small [but > 0 -) ] maybe if someone uses observables which emit 0 elements and just an oncompleted to represent durations (eg for join) and many of these observables are materialized the gains could be somewhat bigger || okay :-) ||;;;;1;1;one global oncompleted object;
818;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;compositesubscription memory reduction;since compositesubscription is now used everywhere with subscriber  i looked at the code again and tried to reduce memory consumption. i ve added clear_state_unsubscribed singleton to transition into when unsubscribed. note that the previous version kept the subscription array after the unsubscription  keeping references to other subscriptions alive (although unsubscribed)  i m not certain why unsubscription didn t simply discard the array before.  i ve played with changing the  add  and  remove  methods (not included in this pr) to do more direct array manipulation with about 10-40% speed increase for tests like add directly followed by remove. the speed increase comes from: - using arraycopy to avoid dynamic array creation in copyof  - handling case where cs contains a single item to be removed and transitions into clear_state instead of creating a new empty state.  similar memory reduction could be implemented in mas and sas.;;0;compositesubscription memory reduction;since compositesubscription is now used everywhere with subscriber i looked at the code again and tried to reduce memory consumption ive added clear_state_unsubscribed singleton to transition into when unsubscribed note that the previous version kept the subscription array after the unsubscription keeping references to other subscriptions alive (although unsubscribed) im not certain why unsubscription didnt simply discard the array beforeive played with changing the `add` and `remove` methods (not included in this pr) to do more direct array manipulation with about 10-40% speed increase for tests like add directly followed by remove the speed increase comes from:- using arraycopy to avoid dynamic array creation in copyof- handling case where cs contains a single item to be removed and transitions into clear_state instead of creating a new empty statesimilar memory reduction could be implemented in mas and sas;#738  this is great stuff thank you ive been considering spending time on this myself so thanks for taking it on the changes involving arraycopy sound great as well  ||;;;;1;1;compositesubscription memory reduction;
819;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;compositesubscription performance increase;- optimized the case when the composite holds only a single element. - replaced arrays.copyof with regular arraycopy to avoid the cost of reflective array creation - included perf test where i got 32% increase on my i7 4770k;;0;compositesubscription performance increase;- optimized the case when the composite holds only a single element- replaced arrayscopyof with regular arraycopy to avoid the cost of reflective array creation- included perf test where i got 32% increase on my i7 4770k;#739  the things we do for performance :-)very nice changesold code on my machine  10 - 14477981 ops/sec run: 11 - 14028905 ops/sec run: 12 - 14738523 ops/sec run: 13 - 14296743 ops/sec run: 14 - 14643646 ops/sec new code  10 - 20500289 ops/sec run: 11 - 19725110 ops/sec run: 12 - 20433601 ops/sec run: 13 - 19659111 ops/sec run: 14 - 20011446 ops/sec  || like! ||;;;;1;1;compositesubscription performance increase;
824;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;set setdaemon on newthreadscheduler;first noticed by @zsxwing.;;0;set setdaemon on newthreadscheduler;first noticed by @zsxwing;#744 passes locally || thank you for catching this ||;;;;1;1;set setdaemon on newthreadscheduler;
825;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;issue #799 - commenting out the call to attachcallingthreadstack when co;nstructing a compositeexception;;799.0;issue #799 - commenting out the call to attachcallingthreadstack when co;nstructing a compositeexception;should i merge this manually into 017? ||;error reporting can enter infinite loop;relevant thread dump:   javalangthreadstate: runnable    at javalangthrowablegetcause(throwablejava:415)    - locked <0x00007f48cf6b4f20> (a javalangnullpointerexception)    at rxutilcompositeexceptionattachcallingthreadstack(compositeexceptionjava:87)    at rxutilcompositeexception(compositeexceptionjava:42)    at rxutilcompositeexception(compositeexceptionjava:51)this is an infinite loop caused by collapsing multiple throwables together  in the presence of compositeexceptions we need to break out of the while-loop in compositeexceptionattachcallingthreadstack on throwables that have self-referential loops;ive got a unit test that duplicates this behavior and a fix  pr coming shortly || after further review i still dont have a complete handle on this  the above pull request successfully limits the symptom of calling attachcallingthreadstack on a malformed exception but the malformed exception is still getting created  since i cant eliminate the malformed exception (yet) im submitting a pull request that does not call attachcallingthreadstack  this should eliminate the source of the malformed exception with the loss of informative debugging of compositeexceptions ||;1;0;adding comment to compositeexception;
826;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;return wrapped subscription;- make sure the safesubscriber is included in what is returned - then return as subscription not subscriber so it can t be cast back to a subscriber;;0;return wrapped subscription;- make sure the safesubscriber is included in what is returned- then return as subscription not subscriber so it cant be cast back to a subscriber;;;;;1;1;return wrapped subscription- make sure the safesubscriber is included in what is returned- then return as subscription not subscriber so it cant be cast back to a subscriber;
828;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;repeat operator;based on code and discussion in https://github.com/netflix/rxjava/pull/807/files;;0;repeat operator;based on code and discussion in https://githubcom/netflix/rxjava/pull/807/files;;;;;1;1;subscribers/observersempty();
829;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;adding marble diagrams  see-also links to javadocs of new repeat() variants;;;0;adding marble diagrams see-also links to javadocs of new repeat() variants;;#751  #752;;;;1;1;changing marble diagrams for repeat() variants to those that operate on a source observable rather than a source item;
835;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;observeon operator with backpressure;this is a re-implementation of observeon done for 3 purposes:  1) migrate to new  lift  style so the  subscription  flows through correctly 2) eliminate the wasted first schedule step (reported by @mttkay   3) eliminate buffering so it naturally provides back pressure   unit tests are passing on my machine for a full build  but i m interested in user experience  particularly from android users where  observeon  behavior is mission critical.  this will change behavior and possibly cause problems if  observeon  was being used to make something async (which is not the purpose of  observeon . the  subscribeon  operator is the one to use for making something ~~async~~ concurrent. [update: per discussions below we may want another operator or  observeon  overload to allow async behavior to use a queue and decouple producer/consumer. the  observeon  operator however should by default only do what it says - switch threads.]  this is a complete re-write so i may very well have created nasty bugs that we don t yet have unit tests for so i d appreciate a thorough review and testing.  one possible concern is performance. in the case of a synchronous firehose (not the normal use case  but a use case nonetheless)  this is far slower because now each  onnext  is sent one-at-a-time across thread boundaries whereas before it would put everything into a queue on one side then read it all from the queue on the other side.   thus  for this code that synchronously firehoses 100000 values it is about 7 times faster on the current code without back-pressure:      java long last = observable.range(0  100000).observeon(schedulers.newthread()).toblockingobservable().last()       however  this code is the same performance:      java long last = observable.interval(1  timeunit.milliseconds).take(1000).observeon(schedulers.newthread()).toblockingobservable().last()       the difference being that we re not just filling up the queue in the second one as it has latency.  i believe this is okay as the intent of  observeon  is moving across thread boundaries  such as for ui events  and eliminating the bad behavior of buffer-bloat is the right thing.   i m sure we can find some performance improvements in this code  but it s worth pointing out how the change in behavior can affect it.;;0;observeon operator with backpressure;this is a re-implementation of observeon done for 3 purposes:1) migrate to new `lift` style so the `subscription` flows through correctly2) eliminate the wasted first schedule step (reported by @mttkay   eliminate buffering so it naturally provides back pressure unit tests are passing on my machine for a full build but im interested in user experience particularly from android users where `observeon` behavior is mission criticalthis will change behavior and possibly cause problems if `observeon` was being used to make something async (which is not the purpose of `observeon` the `subscribeon` operator is the one to use for making something ~~async~~ concurrent [update: per discussions below we may want another operator or `observeon` overload to allow async behavior to use a queue and decouple producer/consumer the `observeon` operator however should by default only do what it says - switch threads]this is a complete re-write so i may very well have created nasty bugs that we dont yet have unit tests for so id appreciate a thorough review and testingone possible concern is performance in the case of a synchronous firehose (not the normal use case but a use case nonetheless) this is far slower because now each `onnext` is sent one-at-a-time across thread boundaries whereas before it would put everything into a queue on one side then read it all from the queue on the other side thus for this code that synchronously firehoses 100000 values it is about 7 times faster on the current code without back-pressure:``` javalong last  observablerange(0 100000)observeon(schedulersnewthread())toblockingobservable()last()```however this code is the same performance:``` javalong last  observableinterval(1 timeunitmilliseconds)take(1000)observeon(schedulersnewthread())toblockingobservable()last()```the difference being that were not just filling up the queue in the second one as it has latencyi believe this is okay as the intent of `observeon` is moving across thread boundaries such as for ui events and eliminating the bad behavior of buffer-bloat is the right thing im sure we can find some performance improvements in this code but its worth pointing out how the change in behavior can affect it;@headinthebox this relates to discussions you and i have had about eliminating implicit buffers to enable natural back-pressure unless operators such as `buffer` and `window` are explicitly requested id appreciate your review of the change in behavior || #756 @benjchristensen will do!we might consider to add an explicit buffer operator to decouple producer and consumers such that is people want they can get the old behavior of observon whith all caveats about buffer bloat of course in net you can that by toenumerable()toobservable() but that is quite a hack and maybe not giving you exactly what you want || > rxjava-pull-requests #756 failurethat test is non-deterministic and needs to get  || > we might consider to add an explicit buffer operator to decouple producer and consumers im open to that are you thinking just an overload of `buffer` or an overload of `observeon` that accepts buffer options? i think a `buffer` overload makes sense || you are thinking of buffer that takes a scheduler then? || > you are thinking of buffer that takes a scheduler then?i was thinking so but looking at the `buffer` signature again i think it may be confusing``` javaobservable<list<t>> buffer(int count)```that would not line up well with:``` javaobservable<t> buffer(scheduler s)```otherwise we could have `observeon(scheduler s queue impl)` or `observeon(scheduler s int buffersize)` (it defaults to 1)i dont think we have enough use case to warrant the `queue` type though  || yes plus that `buffer` has many overloads for overlapping ones also agreed on queue having `observeon` with size (and what about time like replay ie buffer n ticks) seems like a good start || i did some testing speed testing with 1m range observed on newthreadoriginal:473828612 ops/s444320052 ops/s411198937 ops/s416063006 ops/s420909267 ops/sthis pr108350741 ops/s92500636 ops/s104746970 ops/s112972259 ops/s135964434 ops/ssemaphore + queue with permits observeon code is [here](    100 000 ops/s tests pass2:    350 000 ops/s backpressure tests fail4:  1 300 000 ops/s backpressure tests fail testparallel fails8:  1 900 000 ops/s backpressure tests fail testparallel fails16: 2 500 000 ops/s backpressure tests fail testparallel fails32: 2 300 000 ops/s backpressure tests fail testparallel fails64: 2 200 000 ops/s backpressure tests fail testparallel failsthe `testparallel` seems to fail because the scheduling is interrupted before the last values in the queue could beprocessed if i remove the interrupt check from poll any-sized testparallel passessemaphore + queue with permits and batch drain of the queue [code](       95 000 ops/s2:      272 000 ops/s4:      900 000 ops/s8:    1 900 000 ops/s16:   3 074 000 ops/s32:   5 400 000 ops/s64:   8 700 000 ops/s128:  7 700 000 ops/s256:  7 600 000 ops/s512: 11 086 000 ops/susing batch drain appears to be more efficient when the queue size > 16 on my machine i think the reason for this is that permits are released in larger numbers and producers less frequently need to wait for a 0 -> 1 permit transitiongoing above 512 resulted in significant fluctuations between 8m - 13mthe two latter transferqueue based implementations fluctuate quite a bit between 600k - 1200k for some reason (tested on i7 920 @ 266ghz win7x64 6gb ddr3&1333mhz java 7 u51 x64)i tried to improve performance of the 1 permit case via transferqueue but i couldnt get reliable data exchange nor could i implement proper interruption || i have updated the code to support `observeon(scheduler s int buffersize)` and it uses a ring buffer in the implementation the buffer allows getting async behavior and increased throughput:```     * --- version 0171 > with queue size  1     *      * run: 10 - 115033 ops/sec     * run: 11 - 118155 ops/sec     * run: 12 - 120526 ops/sec     * run: 13 - 115035 ops/sec     * run: 14 - 116102 ops/sec     *      * --- version 0171 > with queue size  16     *      * run: 10 - 850412 ops/sec     * run: 11 - 711642 ops/sec     * run: 12 - 788332 ops/sec     * run: 13 - 1064056 ops/sec     * run: 14 - 656857 ops/sec     *      * --- version 0171 > with queue size  1000000     *      * run: 10 - 5162622 ops/sec     * run: 11 - 5271481 ops/sec     * run: 12 - 4442470 ops/sec     * run: 13 - 5149330 ops/sec     * run: 14 - 5146680 ops/sec```however its still slower than the previous implementation with an unbounded queue:```     * --- version 0161     *      * run: 10 - 27098802 ops/sec     * run: 11 - 24204284 ops/sec     * run: 12 - 27208663 ops/sec     * run: 13 - 26879552 ops/sec     * run: 14 - 26658846 ops/sec``` || im going to proceed with the merge as this gets the functionality and api to what is wanted and the performance is adequate for the use case id be interested if anyone else wants to look at how to further improve the performance || ive been playing with this over the weekend with 0170-rc1 and think we need to revert the default back-pressure behavior i think it is relevant as an option to be applied but its too risky as the default behavior if the source `observable` is being emitted from an event loop (such as an nio selector thread)im going to submit a change today that splits out `operatorobserveon` and `operatorobserveonbounded` and leaves the default `observeon(scheduler s)` using the unbounded versionfurther discussion of providing tools for back-pressure will be picked up in the 018 dev cycle ||;;;;1;1;observeon with buffer size;
"836;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;setting up the new subproject for debugging observable chains.;by creating and registering this plugin you get a complete log of all the events (subscribe  onnext  onerror  oncompleted and unsubscribe) that happen in all observables  observers and subscribers. the debug hook also takes a func1 for transforming data before they are sent to actual onnext functions.  this pull request is for the raw data.  there isn t any persistence or visualization of the data generated yet.  here is an example of a simple observable chain      from(1  3).flatmap({ it -> from(it  it + 1) }).take(3).subscribe()      and the stream of notifications sent.      {  nano : 1391761208271225000   thread : 1   observer :  rx.observable$27@3290a11e    type :  subscribe    source :  rx.observable$2@3541d281 } {  nano : 1391761208272832000   thread : 1   observer :  rx.operators.operatortake$1@f81c4a1    type :  subscribe    source :  rx.observable$2@10942dfb    to :  rx.operators.operatortake@7056c23d } {  nano : 1391761208275469000   thread : 1   observer :  rx.operators.operatormerge$1@49c5146e    type :  subscribe    source :  rx.observable$2@29c06798    to :  rx.operators.operatormerge@16d14192 } {  nano : 1391761208275644000   thread : 1   observer :  rx.operators.operatormap$1@427e3f2    type :  subscribe    source :  rx.operators.operatorfromiterable@56e626ff    to :  rx.operators.operatormap@200a5beb } {  nano : 1391761208276707000   thread : 1   observer :  rx.operators.operatormap$1@427e3f2    type :  onnext    value :  1    to :  rx.operators.operatormap@200a5beb } {  nano : 1391761208276839000   thread : 1   observer :  rx.operators.operatormerge$1@49c5146e    type :  onnext    value :  rx.observable@299b78d4    from :  rx.operators.operatormap@200a5beb    to :  rx.operators.operatormerge@16d14192 } {  nano : 1391761208277012000   thread : 1   observer :  rx.operators.operatormerge$1$innerobserver@2b6dd9c5    type :  subscribe    source :  rx.operators.operatorfromiterable@38f42ac9 } {  nano : 1391761208277075000   thread : 1   observer :  rx.operators.operatormerge$1$innerobserver@2b6dd9c5    type :  onnext    value :  1 } {  nano : 1391761208277166000   thread : 1   observer :  rx.operators.operatortake$1@f81c4a1    type :  onnext    value :  1    from :  rx.operators.operatormerge@16d14192    to :  rx.operators.operatortake@7056c23d } {  nano : 1391761208277243000   thread : 1   observer :  rx.observable$27@3290a11e    type :  onnext    value :  1    from :  rx.operators.operatortake@7056c23d } {  nano : 1391761208277338000   thread : 1   observer :  rx.operators.operatormerge$1$innerobserver@2b6dd9c5    type :  onnext    value :  2 } {  nano : 1391761208277397000   thread : 1   observer :  rx.operators.operatortake$1@f81c4a1    type :  onnext    value :  2    from :  rx.operators.operatormerge@16d14192    to :  rx.operators.operatortake@7056c23d } {  nano : 1391761208277471000   thread : 1   observer :  rx.observable$27@3290a11e    type :  onnext    value :  2    from :  rx.operators.operatortake@7056c23d } {  nano : 1391761208277557000   thread : 1   observer :  rx.operators.operatormerge$1$innerobserver@2b6dd9c5    type :  oncompleted } {  nano : 1391761208279076000   thread : 1   observer :  rx.operators.operatormap$1@427e3f2    type :  onnext    value :  3    to :  rx.operators.operatormap@200a5beb } {  nano : 1391761208279154000   thread : 1   observer :  rx.operators.operatormerge$1@49c5146e    type :  onnext    value :  rx.observable@24d8116d    from :  rx.operators.operatormap@200a5beb    to :  rx.operators.operatormerge@16d14192 } {  nano : 1391761208279252000   thread : 1   observer :  rx.operators.operatormerge$1$innerobserver@65601e00    type :  subscribe    source :  rx.operators.operatorfromiterable@951c5ff } {  nano : 1391761208279322000   thread : 1   observer :  rx.operators.operatormerge$1$innerobserver@65601e00    type :  onnext    value :  3 } {  nano : 1391761208279409000   thread : 1   observer :  rx.operators.operatortake$1@f81c4a1    type :  onnext    value :  3    from :  rx.operators.operatormerge@16d14192    to :  rx.operators.operatortake@7056c23d } {  nano : 1391761208279483000   thread : 1   observer :  rx.observable$27@3290a11e    type :  onnext    value :  3    from :  rx.operators.operatortake@7056c23d } {  nano : 1391761208279562000   thread : 1   observer :  rx.observable$27@3290a11e    type :  oncompleted    from :  rx.operators.operatortake@7056c23d } {  nano : 1391761208279692000   thread : 1   observer :  rx.observable$27@3290a11e    type :  unsubscribe    from :  rx.operators.operatortake@7056c23d } {  nano : 1391761208279756000   thread : 1   observer :  rx.operators.operatortake$1@f81c4a1    type :  unsubscribe    from :  rx.operators.operatormerge@16d14192    to :  rx.operators.operatortake@7056c23d } {  nano : 1391761208279830000   thread : 1   observer :  rx.operators.operatormerge$1@49c5146e    type :  unsubscribe    from :  rx.operators.operatormap@200a5beb    to :  rx.operators.operatormerge@16d14192 } {  nano : 1391761208279880000   thread : 1   observer :  rx.operators.operatormap$1@427e3f2    type :  unsubscribe    to :  rx.operators.operatormap@200a5beb } {  nano : 1391761208279946000   thread : 1   observer :  rx.operators.operatormerge$1$innerobserver@2b6dd9c5    type :  unsubscribe } {  nano : 1391761208280018000   thread : 1   observer :  rx.operators.operatormerge$1$innerobserver@65601e00    type :  unsubscribe } {  nano : 1391761208280085000   thread : 1   observer :  rx.operators.operatormap$1@427e3f2    type :  oncompleted    to :  rx.operators.operatormap@200a5beb } {  nano : 1391761208280150000   thread : 1   observer :  rx.operators.operatormerge$1@49c5146e    type :  oncompleted    from :  rx.operators.operatormap@200a5beb    to :  rx.operators.operatormerge@16d14192 };;0;setting up the new subproject for debugging observable chains;""by creating and registering this plugin you get a complete log of all the events (subscribe onnext onerror oncompleted and unsubscribe) that happen in all observables observers and subscribers the debug hook also takes a func1 for transforming data before they are sent to actual onnext functionsthis pull request is for the raw data  there isnt any persistence or visualization of the data generated yethere is an example of a simple observable chain```from(1 3)flatmap({ it -> from(it it + 1) })take(3)subscribe()```and the stream of notifications sent```{ """"nano"""": 1391761208271225000 """"thread"""": 1 """"observer"""": """"rxobservable$27@3290a11e"""" """"type"""": """"subscribe"""" """"source"""": """"rxobservable$2@3541d281""""}{ """"nano"""": 1391761208272832000 """"thread"""": 1 """"observer"""": """"rxoperatorsoperatortake$1@f81c4a1"""" """"type"""": """"subscribe"""" """"source"""": """"rxobservable$2@10942dfb"""" """"to"""": """"rxoperatorsoperatortake@7056c23d""""}{ """"nano"""": 1391761208275469000 """"thread"""": 1 """"observer"""": """"rxoperatorsoperatormerge$1@49c5146e"""" """"type"""": """"subscribe"""" """"source"""": """"rxobservable$2@29c06798"""" """"to"""": """"rxoperatorsoperatormerge@16d14192""""}{ """"nano"""": 1391761208275644000 """"thread"""": 1 """"observer"""": """"rxoperatorsoperatormap$1@427e3f2"""" """"type"""": """"subscribe"""" """"source"""": """"rxoperatorsoperatorfromiterable@56e626ff"""" """"to"""": """"rxoperatorsoperatormap@200a5beb""""}{ """"nano"""": 1391761208276707000 """"thread"""": 1 """"observer"""": """"rxoperatorsoperatormap$1@427e3f2"""" """"type"""": """"onnext"""" """"value"""": """"1"""" """"to"""": """"rxoperatorsoperatormap@200a5beb""""}{ """"nano"""": 1391761208276839000 """"thread"""": 1 """"observer"""": """"rxoperatorsoperatormerge$1@49c5146e"""" """"type"""": """"onnext"""" """"value"""": """"rxobservable@299b78d4"""" """"from"""": """"rxoperatorsoperatormap@200a5beb"""" """"to"""": """"rxoperatorsoperatormerge@16d14192""""}{ """"nano"""": 1391761208277012000 """"thread"""": 1 """"observer"""": """"rxoperatorsoperatormerge$1$innerobserver@2b6dd9c5"""" """"type"""": """"subscribe"""" """"source"""": """"rxoperatorsoperatorfromiterable@38f42ac9""""}{ """"nano"""": 1391761208277075000 """"thread"""": 1 """"observer"""": """"rxoperatorsoperatormerge$1$innerobserver@2b6dd9c5"""" """"type"""": """"onnext"""" """"value"""": """"1""""}{ """"nano"""": 1391761208277166000 """"thread"""": 1 """"observer"""": """"rxoperatorsoperatortake$1@f81c4a1"""" """"type"""": """"onnext"""" """"value"""": """"1"""" """"from"""": """"rxoperatorsoperatormerge@16d14192"""" """"to"""": """"rxoperatorsoperatortake@7056c23d""""}{ """"nano"""": 1391761208277243000 """"thread"""": 1 """"observer"""": """"rxobservable$27@3290a11e"""" """"type"""": """"onnext"""" """"value"""": """"1"""" """"from"""": """"rxoperatorsoperatortake@7056c23d""""}{ """"nano"""": 1391761208277338000 """"thread"""": 1 """"observer"""": """"rxoperatorsoperatormerge$1$innerobserver@2b6dd9c5"""" """"type"""": """"onnext"""" """"value"""": """"2""""}{ """"nano"""": 1391761208277397000 """"thread"""": 1 """"observer"""": """"rxoperatorsoperatortake$1@f81c4a1"""" """"type"""": """"onnext"""" """"value"""": """"2"""" """"from"""": """"rxoperatorsoperatormerge@16d14192"""" """"to"""": """"rxoperatorsoperatortake@7056c23d""""}{ """"nano"""": 1391761208277471000 """"thread"""": 1 """"observer"""": """"rxobservable$27@3290a11e"""" """"type"""": """"onnext"""" """"value"""": """"2"""" """"from"""": """"rxoperatorsoperatortake@7056c23d""""}{ """"nano"""": 1391761208277557000 """"thread"""": 1 """"observer"""": """"rxoperatorsoperatormerge$1$innerobserver@2b6dd9c5"""" """"type"""": """"oncompleted""""}{ """"nano"""": 1391761208279076000 """"thread"""": 1 """"observer"""": """"rxoperatorsoperatormap$1@427e3f2"""" """"type"""": """"onnext"""" """"value"""": """"3"""" """"to"""": """"rxoperatorsoperatormap@200a5beb""""}{ """"nano"""": 1391761208279154000 """"thread"""": 1 """"observer"""": """"rxoperatorsoperatormerge$1@49c5146e"""" """"type"""": """"onnext"""" """"value"""": """"rxobservable@24d8116d"""" """"from"""": """"rxoperatorsoperatormap@200a5beb"""" """"to"""": """"rxoperatorsoperatormerge@16d14192""""}{ """"nano"""": 1391761208279252000 """"thread"""": 1 """"observer"""": """"rxoperatorsoperatormerge$1$innerobserver@65601e00"""" """"type"""": """"subscribe"""" """"source"""": """"rxoperatorsoperatorfromiterable@951c5ff""""}{ """"nano"""": 1391761208279322000 """"thread"""": 1 """"observer"""": """"rxoperatorsoperatormerge$1$innerobserver@65601e00"""" """"type"""": """"onnext"""" """"value"""": """"3""""}{ """"nano"""": 1391761208279409000 """"thread"""": 1 """"observer"""": """"rxoperatorsoperatortake$1@f81c4a1"""" """"type"""": """"onnext"""" """"value"""": """"3"""" """"from"""": """"rxoperatorsoperatormerge@16d14192"""" """"to"""": """"rxoperatorsoperatortake@7056c23d""""}{ """"nano"""": 1391761208279483000 """"thread"""": 1 """"observer"""": """"rxobservable$27@3290a11e"""" """"type"""": """"onnext"""" """"value"""": """"3"""" """"from"""": """"rxoperatorsoperatortake@7056c23d""""}{ """"nano"""": 1391761208279562000 """"thread"""": 1 """"observer"""": """"rxobservable$27@3290a11e"""" """"type"""": """"oncompleted"""" """"from"""": """"rxoperatorsoperatortake@7056c23d""""}{ """"nano"""": 1391761208279692000 """"thread"""": 1 """"observer"""": """"rxobservable$27@3290a11e"""" """"type"""": """"unsubscribe"""" """"from"""": """"rxoperatorsoperatortake@7056c23d""""}{ """"nano"""": 1391761208279756000 """"thread"""": 1 """"observer"""": """"rxoperatorsoperatortake$1@f81c4a1"""" """"type"""": """"unsubscribe"""" """"from"""": """"rxoperatorsoperatormerge@16d14192"""" """"to"""": """"rxoperatorsoperatortake@7056c23d""""}{ """"nano"""": 1391761208279830000 """"thread"""": 1 """"observer"""": """"rxoperatorsoperatormerge$1@49c5146e"""" """"type"""": """"unsubscribe"""" """"from"""": """"rxoperatorsoperatormap@200a5beb"""" """"to"""": """"rxoperatorsoperatormerge@16d14192""""}{ """"nano"""": 1391761208279880000 """"thread"""": 1 """"observer"""": """"rxoperatorsoperatormap$1@427e3f2"""" """"type"""": """"unsubscribe"""" """"to"""": """"rxoperatorsoperatormap@200a5beb""""}{ """"nano"""": 1391761208279946000 """"thread"""": 1 """"observer"""": """"rxoperatorsoperatormerge$1$innerobserver@2b6dd9c5"""" """"type"""": """"unsubscribe""""}{ """"nano"""": 1391761208280018000 """"thread"""": 1 """"observer"""": """"rxoperatorsoperatormerge$1$innerobserver@65601e00"""" """"type"""": """"unsubscribe""""}{ """"nano"""": 1391761208280085000 """"thread"""": 1 """"observer"""": """"rxoperatorsoperatormap$1@427e3f2"""" """"type"""": """"oncompleted"""" """"to"""": """"rxoperatorsoperatormap@200a5beb""""}{ """"nano"""": 1391761208280150000 """"thread"""": 1 """"observer"""": """"rxoperatorsoperatormerge$1@49c5146e"""" """"type"""": """"oncompleted"""" """"from"""": """"rxoperatorsoperatormap@200a5beb"""" """"to"""": """"rxoperatorsoperatormerge@16d14192""""}```"";#757 something is conflicted so it needs to be rebased before i can merge || sorry forgot to push it up to the fork || #763;;;;1;1;merge branch master into debugconflicts:	rxjava-core/src/main/java/rx/observablejava;"
838;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;make scala oncompleted notification an object;this should solve issue  and  .;;0;make scala oncompleted notification an object;this should solve issue  and https://githubcom/netflix/rxjava/pull/584;#759 ;;;;1;1;merge branch master of githubcom:netflix/rxjava into oncompletedscala;
839;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;error handling: onerrornotimplemented and java.lang.error;special handling of java.lang.error and onerrornotimplemented -  -  - https://github.com/netflix/rxjava/issues/789;;0;error handling: onerrornotimplemented and javalangerror;special handling of javalangerror and onerrornotimplemented-   https://githubcom/netflix/rxjava/issues/789;this represents a possible approach to handling `onerrornotimplementedexception` and `javalangerror` im not convinced its the right approach for all `javalangerror` to be caught for `onerrornotimplementedexception` and `stackoverflow` i think they must be thrown from wherever they are caught the reason for it not being obvious to throw is that by throwing on a background thread instead of sending via `onerror` the terminal states of an `observable` will never be triggered and thus will deadlock many `javalangerror` should result in the system shutting down but probably not all it could possibly be limited to these:  advice or insight on what is considered to be the right approach for everything else? || after thinking about it further i decided i didnt like my previous approach and have replaced it with this one that is more generic and doesnt make any specific operators do anything special i found the issue was the `synchronizedobserver` was taking on more responsibility than it should have been and was capturing errors and then ignoring everything after a terminal state occurred which became a problem when `onerror` was called resulted in an exception of its own which invoked `onerror` again this resulted in me doing 3 specific changes:1) `safesubscriber` manages safety and error handling `synchronizedobserver` only does synchronization2) new method `exceptionsthrowiffatal(e)` checks for special handling ``` java    public static void throwiffatal(throwable t) {        if (t instanceof onerrornotimplementedexception) {            throw (onerrornotimplementedexception) t        }        // values here derived from         else if (t instanceof stackoverflowerror) {            throw (stackoverflowerror) t        } else if (t instanceof virtualmachineerror) {            throw (virtualmachineerror) t        } else if (t instanceof threaddeath) {            throw (threaddeath) t        } else if (t instanceof linkageerror) {            throw (linkageerror) t        }    }```3) the `throwiffatal` call is invoked _before_ the terminal state check so even if `onerror` was already invoked and throws only to end up again passed to `onerror` the `throwiffatal` will catch it on the outside of the `isfinished` check so it will still throw``` java    public void onerror(throwable e) {        // we handle here instead of another method so we dont add stacks to the frame        // which can prevent it from being able to handle stackoverflow        exceptionsthrowiffatal(e)        if (isfinishedcompareandset(false true)) {            _onerror(e)        }    }```these changes appear to have resolved the `onerrornotimplemented` and `stackoverflow` issues reported in  and  || local build is passing  merging> build successful> > total time: 2 mins 36851 secs || #761 ;;;;1;1;special handling of javalangerror and onerrornotimplemented-    synchronizedobserver is for synchronization not error handling or contract enforcements thats the job of safesubscriber- removed some unit tests that were asserting unsubscribe behavior that relied on synchronizedobserver they were testing something they are not responsible for;
841;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;range onsubscribe;reimplemented as a simple loop instead of iterable.   simpler code gives a performance bump:           * -- 0.17      *       * run: 10 - 271 147 198 ops/sec      * run: 11 - 274 821 481 ops/sec      * run: 12 - 271 632 295 ops/sec      * run: 13 - 277 876 014 ops/sec      * run: 14 - 274 821 763 ops/sec      *       * -- 0.16.1      *       * run: 10 - 222 104 280 ops/sec      * run: 11 - 224 311 761 ops/sec      * run: 12 - 222 999 339 ops/sec      * run: 13 - 222 344 174 ops/sec      * run: 14 - 225 247 983 ops/sec;;0;range onsubscribe;reimplemented as a simple loop instead of iterable simpler code gives a performance bump:```     * -- 017     *      * run: 10 - 271147198 ops/sec     * run: 11 - 274821481 ops/sec     * run: 12 - 271632295 ops/sec     * run: 13 - 277876014 ops/sec     * run: 14 - 274821763 ops/sec     *      * -- 0161     *      * run: 10 - 222104280 ops/sec     * run: 11 - 224311761 ops/sec     * run: 12 - 222999339 ops/sec     * run: 13 - 222344174 ops/sec     * run: 14 - 225247983 ops/sec```;;;;;1;1;onsubscriberange;
842;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;test unsubscribe;- also cleaned up some stuff i remembered after merging last commits;;0;test unsubscribe;- also cleaned up some stuff i remembered after merging last commits;;;;;1;1;test unsubscribe- also cleaned up some stuff i remembered after merging last commits;
852;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;rxjava-debug;manual merge of https://github.com/netflix/rxjava/pull/836;;0;rxjava-debug;manual merge of https://githubcom/netflix/rxjava/pull/836;;;;;1;1;merge branch debug of githubcom:abersnaze/rxjava into rxjava-debugconflicts:	rxjava-core/src/main/java/rx/observablejava;
854;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;the oncreate hook disappeared;i think in the merging this hook disappeared from the original pull request for the debug hooks.;;0;the oncreate hook disappeared;i think in the merging this hook disappeared from the original pull request for the debug hooks;#778 ;;;;1;1;the oncreate hook disappeared;
857;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;change lift to use rx.observable.operator;the generics insanity has to stop.  this pull request is a result of @abersnaze and i continuing to fail to make generics work with this signature:      java func1<subscriber<? super r>  subscriber<? super t>>      it all fell apart while trying to do things that needed the equivalent of:      java func1<subscriber<? super r>  subscriber<? super ? super t>>       and other such variants.  with this change i can also finally get the  operatormerge  generics to work.   thus  the  operator  type exists inside  observable  just like  onsubscribe  like this:      java     /**      * operator function for lifting into an observable.      */     public interface operator<r  t> extends func1<subscriber<? super r>  subscriber<? super t>> {         // cover for generics insanity     }      this gives us imports like this:      java import rx.observable  import rx.observable.onsubscribe  import rx.observable.operator       i know it s not as pure as having  lift(func1)  but this is far more usable.      java public <r> observable<r> lift(final operator<r  t> bind)      if anyone has a different suggestion that still solves the generics issue please let me know.;;0;change lift to use rxobservableoperator;the generics insanity has to stopthis pull request is a result of @abersnaze and i continuing to fail to make generics work with this signature:``` javafunc1<subscriber<? super r> subscriber<? super t>>```it all fell apart while trying to do things that needed the equivalent of:``` javafunc1<subscriber<? super r> subscriber<? super ? super t>>``` and other such variantswith this change i can also finally get the `operatormerge` generics to work thus the `operator` type exists inside `observable` just like `onsubscribe` like this:``` java    /**     * operator function for lifting into an observable     */    public interface operator<r t> extends func1<subscriber<? super r> subscriber<? super t>> {        // cover for generics insanity    }```this gives us imports like this:``` javaimport rxobservableimport rxobservableonsubscribeimport rxobservableoperator```i know its not as pure as having `lift(func1)` but this is far more usable``` javapublic <r> observable<r> lift(final operator<r t> bind)```if anyone has a different suggestion that still solves the generics issue please let me know;if you doubt the insanity heres an error message for the `merge` operator :-)> the method lift(func1<subscriber<? super r>subscriber<? super capture#210-of ? extends observable<? extends t>>>) in the type observable<capture#210-of ? extends observable<? extends t>> is not applicable for the arguments (operatormerge<t>) || apparently only the ide likes `merge` now  curse generics```/users/bechristensen/development/github/rxjavafork/rxjava-core/src/main/java/rx/observablejava  error: method lift in class observable<t#1> cannot be applied to given types        return sourcelift(new operatormerge<t>())                     ^  required: operator<rcap#1>  found: operatormerge<t#2>  reason: no instance(s) of type variable(s) r exist so that argument type operatormerge<t#2> conforms to formal parameter type operator<rcap#1>  where rt#1t#2 are type-variables:    r extends object declared in method <r>lift(operator<rt#1>)    t#1 extends object declared in class observable    t#2 extends object declared in method <t#2>merge(observable<? extends observable<? extends t#2>>)  where cap#1 is a fresh type-variable:    cap#1 extends observable<? extends t#2> from capture of ? extends observable<? extends t#2>``` || #782  after fixing generics it actually would be:``` javapublic <r> observable<r> lift(final func1<? extends subscriber<? super r> ? super subscriber<? super t>> bind)```using the `operator` type it is instead:``` javapublic <r> observable<r> lift(final operator<? extends r ? super t> bind)```as the type gives cover for:``` javapublic interface operator<r t> extends func1<subscriber<? super r> subscriber<? super t>>``` ||;;;;1;1;change lift to use rxobservableoperatorthe generics insanity has to stop;
"860;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fixing the generics for merge and lift;i ve tracked down to two problems #858   the first is that lift wasn t quite right. i changed the lift argument from  operator<r  t>  to  operator<? extends r  ? super t> .  unfortunately java won t let us hide that away in the  operator  class so we have to redeclare that everywhere in the debug hooks but it s still better than the alternative of having to use the full  func1<? extends subscriber<? super r>  ? super subscriber<? super t>>  everywhere.  the second problem was in the return type of merge  observable<t> .  because of operators like  merge(observable<? extends t> t1  observable<? extends t> t2)  the only thing that can be said for the return type is that it is also  observable<? extends t>  but at the moment it is returning  observable<t> .  this pull request changes all of them and leads to some silly return values like      observable<string> a  b  observable<? extends string> x = merge(a  b);;858.0;fixing the generics for merge and lift;ive tracked down to two problems #858 the first is that lift wasnt quite right i changed the lift argument from `operator<r t>` to `operator<? extends r ? super t>`  unfortunately java wont let us hide that away in the `operator` class so we have to redeclare that everywhere in the debug hooks but its still better than the alternative of having to use the full `func1<? extends subscriber<? super r> ? super subscriber<? super t>>` everywherethe second problem was in the return type of merge `observable<t>`  because of operators like `merge(observable<? extends t> t1 observable<? extends t> t2)` the only thing that can be said for the return type is that it is also `observable<? extends t>` but at the moment it is returning `observable<t>`this pull request changes all of them and leads to some silly return values like```observable<string> a bobservable<? extends string> x  merge(a b)```;#784 we should avoid return types such as `a<? extends b>` || #787 #788  @akarnokd you were right the return type change wasnt necessary  ive reverted and rebased the branch to clean out all the mistakes || [rxjava-pull-requests #789 i almost did a pr on this when i saw you now did the same thing as i but was it necessary to change the debugs as well? || yes there is a plugin hook inside lift that the debug plugin implements and spreads from there ||;generics help please?;generics have me stumped on the `merge` operator the functionality is fine but only if i leave it untypedall other operators im using `lift` with are okay but i cant get this one``` java// this doesnt compile    public final static <t> observable<t> merge(observable<? extends observable<? extends t>> source) {        return sourcelift(new operatormerge<t>())     }// this compiles with untyped warnings (no generic) and functions    public final static <t> observable<t> merge(observable<? extends observable<? extends t>> source) {        return sourcelift(new operatormerge())     }// this compiles (but is only merging itself so not very helpful)    public observable<t> mergeself() {        return from(this)lift(new operatormerge<t>())    }// this doesnt compile    public observable<t> mergeselfwithanother(observable<? extends t> other) {        return from(this other)lift(new operatormerge<t>())    }```here is the compilation error:```/users/bechristensen/development/github/rxjavafork/rxjava-core/src/main/java/rx/observablejava  error: method lift in class observable<t#1> cannot be applied to given types        return sourcelift(new operatormerge<t>())                     ^  required: operator<rcap#1>  found: operatormerge<t#2>  reason: no instance(s) of type variable(s) r exist so that argument type operatormerge<t#2> conforms to formal parameter type operator<rcap#1>  where rt#1t#2 are type-variables:    r extends object declared in method <r>lift(operator<rt#1>)    t#1 extends object declared in class observable    t#2 extends object declared in method <t#2>merge(observable<? extends observable<? extends t#2>>)  where cap#1 is a fresh type-variable:    cap#1 extends observable<? extends t#2> from capture of ? extends observable<? extends t#2>```;""thank you to @abersnaze for fixing the generics! || i am getting the same compilation error now  using `ioreactivex 1010`  what is the solution? || @igorganapolsky what is the code exactly that doesnt compile? || @akarnokd i have this code:`return plugshareservicegetlocationinfo(locationid)                map(new plugshareresponsetolocation())                subscribeon(schedulersio())                observeon(androidschedulersmainthread())`and i get this error:> error:(28 60) error: method map in class observable<t> cannot be applied to given types> required: func1<? super evgolocation? extends r>> found: plugshareresponsetolocation> reason: cannot infer type-variable(s) r> (argument mismatch plugshareresponsetolocation cannot be converted to func1<? super evgolocation? extends r>)> where rt are type-variables:> r extends object declared in method <r>map(func1<? super t? extends r>)> t extends object declared in class observable || nevermind i solved it  i have to use this in my retrofit observable interface:`@post(""""/locations/{id}"""")    observable<plugshareresponse> getlocationinfo(@path(""""id"""") string id)`instead of `@post(""""/locations/{id}"""")    observable<evgolocation> getlocationinfo(@path(""""id"""") string id)` || "";1;0;fixing the generics for merge and lift;"
862;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;update the timeout docs;updated the timeout docs.;;0;update the timeout docs;updated the timeout docs;#790 ;;;;1;1;update the timeout docs;
866;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;update operationscan to operatorscan;migrate to use updated conventions of operator\* classes that implement rx.observable.operator;;0;update operationscan to operatorscan;migrate to use updated conventions of operator\* classes that implement rxobservableoperator;;;;;1;1;update operationscan to operatorscanmigrate to use updated conventions of operator* classes that implement rxobservableoperator;
870;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add the selector variants of timeout in rxscala;this pr added the selector variants of the  timeout  operator in the scala and also added two examples.;;0;add the selector variants of timeout in rxscala;this pr added the selector variants of the `timeout` operator in the scala and also added two examples;#798 ;;;;1;1;add the selector variants of timeout in rxscala;
874;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;update compositesubscriptiontest.java;fix apparent typo  unsubscription of s2 was not checked and should have been.;;0;update compositesubscriptiontestjava;fix apparent typo unsubscription of s2 was not checked and should have been;#804  thanks for the fix! i wont even ask what had you looking that detailed at the test code :-) || no worries i was looking at the interaction of compositesubscription and operatorretry in 0161 for an issue i was having and was perusing the compositesubscriptiontest looking at unsubscribe behaviour i see that youve changed retryoperator significantly in master so ill retest my issue with master next week and raise a github issue with a failing unit test if i still have a problem i suspect schedulerstrampoline will have me sorted thanks for the great library! ||;;;;1;1;update compositesubscriptiontestjavafix apparent typo unsubscription of s2 was not checked and should have been;
"878;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;scheduler.schedulerecursive;make recursive scheduling a first-class citizen without needing to refer to  this  which doesn t work inside lambdas (java8/scala/etc).      java         schedulers.newthread().schedulerecursive(new action1<recurse>() {             @override             public void call(recurse r) {                 system.out.println( do stuff on thread:   + thread.currentthread() +   time:   + system.nanotime())                  r.schedule(100  timeunit.milliseconds)              }         });;0;schedulerschedulerecursive;""make recursive scheduling a first-class citizen without needing to refer to """"this"""" which doesnt work inside lambdas (java8/scala/etc)``` java        schedulersnewthread()schedulerecursive(new action1<recurse>() {            @override            public void call(recurse r) {                systemoutprintln(""""do stuff on thread: """" + threadcurrentthread() + """" time: """" + systemnanotime())                rschedule(100 timeunitmilliseconds)            }        })```"";#810 ;;;;1;1;""schedulerschedulerecursivemake recursive scheduling a first-class citizen without needing to refer to """"this"""" which doesnt work inside lambdas (java8/scala/etc)        schedulersnewthread()schedulerecursive(new action1<recurse>() {            @override            public void call(recurse r) {                systemoutprintln(""""do stuff on thread: """" + threadcurrentthread() + """" time: """" + systemnanotime())                rschedule(100 timeunitmilliseconds)            }        })"";"
888;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;revert bounded observeon;reverting to only having unbounded  observeon  in public api as per comment at   leaving the bounded implementation as an internal operator implementation for now to be discussed further in v0.18 dev cycle.;;0;revert bounded observeon;reverting to only having unbounded `observeon` in public api as per comment at  the bounded implementation as an internal operator implementation for now to be discussed further in v018 dev cycle;while performance testing this it was found that `newthreadscheduler` appears to be the source of performance degradation not `observeon` itself using `immediatescheduler` 016 and 017 were very similar the code for `observeon` in 017 is now basically the same as 016 except using `lift` and avoiding the use of `materialize` to reduce object creation || unit tests passing on local machine  merging:build successfultotal time: 1 mins 20181 secs || #821;;;;1;1;revert bounded observeon;
890;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;split subscribeon into subscribeon/unsubscribeon;working with @headinthebox based on discussions at  and  we determined that there are times when  unsubscribeon  behavior is needed.  the  subscribeon  operator can not mix  subscribe  and  unsubscribe  scheduling behavior without breaking the  lift / subscriber  behavior that allows unsubscribing synchronous sources. the newly added  unsubscribeon  operator will not work with synchronous unsubscribes  but it will work for the targeted use cases such as ui event handlers.;;0;split subscribeon into subscribeon/unsubscribeon;working with @headinthebox based on discussions at  and  we determined that there are times when `unsubscribeon` behavior is neededthe `subscribeon` operator can not mix `subscribe` and `unsubscribe` scheduling behavior without breaking the `lift`/`subscriber` behavior that allows unsubscribing synchronous sources the newly added `unsubscribeon` operator will not work with synchronous unsubscribes but it will work for the targeted use cases such as ui event handlers;i think this still can not guarantee that unsubscribe is always called in the scheduler for example``` java    public static void main(string args) throws interruptedexception {        observablecreate(new onsubscribe<integer>() {            @override            public void call(final subscriber<? super integer> t1) {                final subscription s  subscriptionscreate(new action0() {                    @override                    public void call() {                        systemoutprintln(threadcurrentthread()getname())                    }                })                t1add(s)                t1onnext(1)                t1onnext(2)                t1oncompleted()            }        })take(1)observeon(schedulersio())unsubscribeon(schedulersnewthread())subscribe()    }```will output `main` in my pc || as you said it can not work for synchronous unsubscribes so we still need to write a thread-safe subscription i just feel `unsubscribeon` will confuse users that when to use `unsubscribeon` and when its necessary to write a thread-safe subscription ||;;;;1;1;split subscribeon into subscribeon/unsubscribeonworking with @headinthebox based on discussions at  and  we determined that there are times when `unsubscribeon` behavior is neededthe `subscribeon` operator can not mix `subscribe` and `unsubscribe` scheduling behavior without breaking the `lift`/`subscriber` behavior that allows unsubscribing synchronous sources the newly added `unsubscribeon` operator will not work with synchronous unsubscribes but it will work for the targeted use cases such as ui event handlers;
891;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;eliminate rx.util.* dumping grounds;move all classes into proper homes rather than having  rx.util  as the miscellaneous dumping grounds.  i have attempted to make rx.util.functions.\* have deprecated proxies to ease the migration. i m doing this in 0.17 instead of waiting since 0.17 already has breaking changes.;;0;eliminate rxutil* dumping grounds;move all classes into proper homes rather than having `rxutil` as the miscellaneous dumping groundsi have attempted to make rxutilfunctions\* have deprecated proxies to ease the migration im doing this in 017 instead of waiting since 017 already has breaking changes;;;;;1;1;rxutilfunctions deprecated proxies;
898;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;handle illegal errors thrown from plugin;;;0;handle illegal errors thrown from plugin;;;;;;1;1;handle illegal errors thrown from plugin;
903;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;scheduler.recurse fields should be private;;;0;schedulerrecurse fields should be private;;#835 ;;;;1;1;schedulerrecurse fields should be private;
904;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;merge: unsubscribe completed inner observables;fixing bug report from https://github.com/netflix/rxjava/issues/897;;0;merge: unsubscribe completed inner observables;fixing bug report from https://githubcom/netflix/rxjava/issues/897;#836 ;;;;1;1;merge: unsubscribe completed inner observables;
905;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;rxjavaschedulers plugin;allow setting different default schedulers for use by system.;;0;rxjavaschedulers plugin;allow setting different default schedulers for use by system;;;;;1;1;rename rxjavaschedulers to rxjavadefaultschedulersclearer semantic naming;
909;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;scheduler plugin refactor;1) deprecate direct access to scheduler implementations  this enforces the convention of using  schedulers.*  and then makes the rxjavadefaultschedulers plugin more reliable.  2) scheduler instances should be or behave like singletons  remove the func0 factory signature for scheduler creation.;;0;scheduler plugin refactor;1) deprecate direct access to scheduler implementationsthis enforces the convention of using `schedulers*` and then makes the rxjavadefaultschedulers plugin more reliable2) scheduler instances should be or behave like singletonsremove the func0 factory signature for scheduler creation;#844 ;;;;1;1;scheduler instances should be or behave like singletons- remove the func0 factory signature for scheduler creation;
910;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove groupby with selector.;i think we can use  groupby(keyselector).map(elementselector)  instead. is there any reason to keep this signature?  related to https://github.com/netflix/rxjava/commit/02ccc4d727a9297f14219549208757c6e0efce2a#commitcomment-5430646;;0;remove groupby with selector;i think we can use `groupby(keyselector)map(elementselector)` instead is there any reason to keep this signature?related to https://githubcom/netflix/rxjava/commit/02ccc4d727a9297f14219549208757c6e0efce2a#commitcomment-5430646;well `groupby` returns `observable<observable>` so you need one more level of map to apply `elementselector` im ambivalent || merging for now to remove the broken functionality  can be re-added before 0170 release if we decide to || > well groupby returns observable<observable> so you need one more level of map to apply elementselector im ambivalentyes sorry its within the `map` or `flatmap` but we already have to do that anyways when using `groupby` as thats what it does emit `observable<groupedobservable<t>>>` i dont see the need for a special operator that emits `observable<groupedobservable<r>>>`thanks @daveray for the feedback anyone else have a good reason for the existence of this overload? the preference is allow composition of existing operators || #845 ;;;;1;1;remove groupby with selectoruse groupbymap instead;
918;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator: doonterminate;like finallydo but before emitting the terminal state instead of after.;;0;operator: doonterminate;like finallydo but before emitting the terminal state instead of after;;;;;1;1;operator: doonterminatelike finallydo but before emitting the terminal state instead of after;
919;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;bugfix: zip never completes when zero observables;fixes  and https://github.com/netflix/rxjava/pull/917;;0;bugfix: zip never completes when zero observables;fixes  and https://githubcom/netflix/rxjava/pull/917;#858 ;;;;1;1;bugfix: zip with 0 observablesfixes bug reported at https://githubcom/netflix/rxjava/pull/868;
924;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;localized operator error handling;do error handling in the  lift  function rather than try/catch in  subscribe  since this catches at the operator level rather than for an entire sequence. this then allows  onerrorresumenext  and siblings to handle the error instead of it only being emitted to the final  subscriber .  i derived this fix while working on hystrix 1.4.;;0;localized operator error handling;do error handling in the `lift` function rather than try/catch in `subscribe` since this catches at the operator level rather than for an entire sequence this then allows `onerrorresumenext` and siblings to handle the error instead of it only being emitted to the final `subscriber`i derived this fix while working on hystrix 14;#866 ;;;;1;1;localized operator error handling- use the lift function rather than try/catch in subscribe since this catches at the operator level rather than for an entire sequence- unit tests with onerrorresumenext demonstrating the use cases;
926;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;testsubscriber: default onerror and terminal latch behavior;;;0;testsubscriber: default onerror and terminal latch behavior;;;;;;1;1;testsubscriber: default onerror and terminal latch behavior;
927;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;testsubscriber lastseenthread;;;0;testsubscriber lastseenthread;;;;;;1;1;testsubscriber lastseenthread;
934;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add observable.startwith(observable) method and unit test;add observable.startwith(observable) method and unit test.   i would like to avoid breaking method chaining when want to startwith an observable rather than just an iterator or specific values. this is a very minor change as under the covers startwith uses concat anyway but it is significant in terms of code readability and is a natural completion of the startwith api.;;0;add observablestartwith(observable) method and unit test;add observablestartwith(observable) method and unit test i would like to avoid breaking method chaining when want to startwith an observable rather than just an iterator or specific values this is a very minor change as under the covers startwith uses concat anyway but it is significant in terms of code readability and is a natural completion of the startwith api;#873 looks like a regression that is unrelated to my pull request i suspect the involved test is non-deterministic  because it assumes that specific asynchronous work is done by the time the line`latchawait(1000 timeunitmilliseconds)` completes one second of lockup for the build machine and the test fails  || #874  as suspected the failing test is non-deterministic and nothing to do with this pull request ill raise an issue || looks good ;;;;1;1;add space to a comment to force ci rebuild to see if suspected non-deterministic test fails again;
"942;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;mathobservable;moving the average/sum/min/max functionality to the mathobservable similar to stringobservable.  similar to the rxjava-string module this is seeking to achieve the goal of keeping rxjava-core focused on core functionality.;;0;mathobservable;moving the average/sum/min/max functionality to the mathobservable similar to stringobservablesimilar to the rxjava-string module this is seeking to achieve the goal of keeping rxjava-core focused on core functionality;""#879  hi being a fan of method chaining id like to see more operator implementations of for example the math operations and many more moreover id like to have an idiom tested and confirmed by you experts to do this easily for my own stuff to that end do you think it would be of value to include in the library something like the class below? one possibility would be to add the tooperator static method to the observable class``` javaimport rxobservableimport rxobservableoperatorimport rxsubscriberimport rxfunctionsfunc1import rxsubjectspublishsubject/** * converts an operation (a function converting one observable into another) * into an {@link operator} *  * @param <r> *            to type * @param <t> *            from type */public class operatorfromoperation<r t> implements operator<r t> {    public static <r t> operator<r t> tooperator(func1<observable<t> observable<r>> operation) {        return new operatorfromoperation<r t>(operation)    }    /**     * the operation to convert     */    private final func1<observable<t> observable<r>> operation    /**     * constructor     *      * @param operation     *            to be converted into {@link operator}     */    public operatorfromoperation(func1<observable<t> observable<r>> operation) {        thisoperation  operation    }    @override    public subscriber<? super t> call(subscriber<? super r> subscriber) {        final publishsubject<t> subject  publishsubjectcreate()        subscriber<t> result  createsubscriber(subject)        subscriberadd(result)        operationcall(subject)subscribe(subscriber)        return result    }    /**     * creates a subscriber that passes all events on to the subject     *      * @param subject     *            receives all events     * @return     */    private static <t> subscriber<t> createsubscriber(final publishsubject<t> subject) {        return new subscriber<t>() {            @override            public void oncompleted() {                subjectoncompleted()            }            @override            public void onerror(throwable e) {                subjectonerror(e)            }            @override            public void onnext(t t) {                subjectonnext(t)            }        }    }}``` || what could you do with operation that couldnt be done with `map(func1<t r>)` or `flatmap(func1<t observable<r>>)`? || an operation acts upon the observable as a whole not on the individualitems like map and flatmap do  for example map and flatmap themselvescould be considered as operations/operatorson 9 mar 2014 04:41 """"george campbell"""" notifications@githubcom wrote:> what could you do with operation that couldnt be done with map(func1<t> r>) or flatmap(func1<t observable<r>>)?> > ## > > reply to this email directly or view it on github  || i dont understand what use cases are trying to be solved by that code can you provide some examples please? || so for instance if i want to use suminteger in the middle of a chain ofmethod calls i need to use lift so i need an operator form of it i make an operator form of it by implementing a call to suminteger in afunc1<observable<integer>observable<integer>> and then calltooperator(func) as described in my example to give me an operator  iwould prefer if there were operator forms of all the static observablemethods i suppose but it least this conversion was part of the codebasethat would make life easieri should mention that method chained calls are important to me because thefunctional attractiveness of rxjava is weakened significantly every time ihave to break the chain with some wrapper call in communicating theelegance of rxjava to my colleagues my case is weakened by those breaks inthe chain im a big fan of lift for this reasonim still new to rxjava so let me know if im missing something obviousherecheersdaveon 11 march 2014 03:26 ben christensen notifications@githubcom wrote:> i dont understand what use cases are trying to be solved by that code> can you provide some examples please?> > ## > > reply to this email directly or view it on github  || to add an explicit example ive found the method rxutiltooperator asdescribed above useful when i want to use an operation like suminteger inan operator form with lift()  to use it i write: private final operator<integerinteger> sum_integer     rxutiltooperator(new func1<observable<integer>observable<integer>>() {@overridepublic observable<integer> call(observable<integer> source) {return mathobservablesuminteger(source)}})then i can write:observablefrom(aslist(123))lift(sum_integer)on 11 march 2014 08:07 dave moten davidmoten@gmailcom wrote:> so for instance if i want to use suminteger in the middle of a chain of> method calls i need to use lift so i need an operator form of it> >  i make an operator form of it by implementing a call to suminteger in a> func1<observable<integer>observable<integer>> and then call> tooperator(func) as described in my example to give me an operator  i> would prefer if there were operator forms of all the static observable> methods i suppose but it least this conversion was part of the codebase> that would make life easier> > i should mention that method chained calls are important to me because the> functional attractiveness of rxjava is weakened significantly every time i> have to break the chain with some wrapper call in communicating the> elegance of rxjava to my colleagues my case is weakened by those breaks in> the chain im a big fan of lift for this reason> > im still new to rxjava so let me know if im missing something obvious> here> cheers> dave> > on 11 march 2014 03:26 ben christensen notifications@githubcom wrote:> > > i dont understand what use cases are trying to be solved by that code> > can you provide some examples please?> > > > ## > > > > reply to this email directly or view it on github >  || i think perhaps i should simplify my original question suppose i have astatic function likepublic static <rt> observable<t> something(observable<r> source) {    //anything here of course    return sourcemap(sometransform)retry()take(100)}what is the simplest way to make an operator out of it so that i can use itwith lift()? if the answer is longer than the tooperator method usage thatim proposing then id be interested in having tooperator in the libraryon 12 march 2014 11:35 dave moten davidmoten@gmailcom wrote:> to add an explicit example ive found the method rxutiltooperator as> described above useful when i want to use an operation like suminteger in> an operator form with lift()  to use it i write:> >  private final operator<integerinteger> sum_integer >     rxutiltooperator(new> func1<observable<integer>observable<integer>>() {>  @override> public observable<integer> call(observable<integer> source) {>  return mathobservablesuminteger(source)> }})> then i can write:> > observablefrom(aslist(123))lift(sum_integer)> > on 11 march 2014 08:07 dave moten davidmoten@gmailcom wrote:> > > so for instance if i want to use suminteger in the middle of a chain of> > method calls i need to use lift so i need an operator form of it> > > >  i make an operator form of it by implementing a call to suminteger in a> > func1<observable<integer>observable<integer>> and then call> > tooperator(func) as described in my example to give me an operator  i> > would prefer if there were operator forms of all the static observable> > methods i suppose but it least this conversion was part of the codebase> > that would make life easier> > > > i should mention that method chained calls are important to me because> > the functional attractiveness of rxjava is weakened significantly every> > time i have to break the chain with some wrapper call in communicating the> > elegance of rxjava to my colleagues my case is weakened by those breaks in> > the chain im a big fan of lift for this reason> > > > im still new to rxjava so let me know if im missing something obvious> > here> > cheers> > dave> > > > on 11 march 2014 03:26 ben christensen notifications@githubcom wrote:> > > > > i dont understand what use cases are trying to be solved by that code> > > can you provide some examples please?> > > > > > ## > > > > > > reply to this email directly or view it on github > >  || we should add an overload for lift that takes an observable > observable function very much like  this is on the todo list or you can try to build it yourself and submit a pull request note it should allow subscribing more than once in the lambda hence """"publish"""" in net || > we should add an overload for lift that takes an observable > observable function +1 || ill make a pull request with the lift method overload as suggesteddaveon 13 march 2014 13:41 shixiong zhu notifications@githubcom wrote:> we should add an overload for lift that takes an observable > observable> function> > +1> > ## > > reply to this email directly or view it on github  || i think we already have that publish() method: [observablejava:5428]( which relies on operationmulticast if you could reimplement it to operatormulticast we would gain a lot of operators || im a bit lost about the reference to publish() method that started with headintheboxs comment i am not talking about adding a publish method i am talking about adding a tooperator method or overload on lift method that does the same thingdave || @benjchristensen what do you think about the addition of an overload for lift that takes a func1<observable<t>observable<r>>? should i go ahead with a pull request? || "";;;;1;1;math-modulemoving the average/sum/min/max functionality to the mathobservable similar to stringobservable;"
"944;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operationretry -> operatorretry;updated to use  lift  and subscriber. fixes  observable.retry() does not unsubscribe from source;;0;operationretry -> operatorretry;""updated to use """"lift"""" and subscriberfixes  observableretry() does not unsubscribe from source"";;;;;1;1;""operationretry -> operatorretryupdated to use """"lift"""" and subscriberfixes  observableretry() does not unsubscribe from source"";"
945;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;manual merge 940;fixes  via manual merge.;;0;manual merge 940;fixes  via manual merge;#880;;;;1;1;merge branch clean-up-hook-args of githubcom:abersnaze/rxjava into merge-940conflicts:	rxjava-core/src/main/java/rx/observablejava;
948;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operationall to operatorall;replaced the  operationall  to an  operatorall .  caveat: i am a newbie here  hoping to learn  so please do not spare me. i saw a remark on performancetests  but noticed they were not applied everywhere  so i left them out. i saw no issue yet asking for this work  this is on invitation from erik meijer at qcon yesterday. if you want me to i can tackle some other operations as well.;;0;operationall to operatorall;replaced the `operationall` to an `operatorall`caveat: i am a newbie here hoping to learn so please do not spare mei saw a remark on performancetests but noticed they were not applied everywhere so i left them outi saw no issue yet asking for this work this is on invitation from erik meijer at qcon yesterdayif you want me to i can tackle some other operations as well;#882 ;;;;1;1;operationall to operatorall;
955;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;fixed replaysubject leak;fix for issue #939.;;939.0; replaysubject leak;fix for issue #939;#889  i can confirm this 939 for me thanks @akarnokd !this might in fact be the final nail in the coffin for any workarounds we used on android to prevent activities from leaking this is great || @benjchristensen do you think we could get this in for 0171 that would be fantastic it would simplify reasoning about requirements for android operators a lot since the use of `cache` and `replay` is quite common on android and some design decisions for `operatorobservefromandroidcomponent` were made purely due to the existence of this bug (no one actually thought to question the correctness of the underlying operator back then hah) ||;replaysubject leaks subscribers even after unsubscribing?;on android a common use case is to `cache` or `replay` an observable to ui components that might get temporarily destroyed due to eg screen rotationsthe biggest challenge on android when using rxjava is therefore to make sure that no resource leaks occur since subscribers however might be inner classes of an android activity or fragment (if youre unfamiliar: think screen object) those will leak if strong references held within an operator are not released when unsubscribing from the sequencei just noticed that when using eg `cache` on a long running sequence and subscribing and unsubscribing multiple times the observer i subscribe to the sequence never seems to get finalized androids strictmode indeed reports that the observer (and hence the entire screen) is being leaked:```e/strictmode( 2791): class comnetflixrxjavaandroidsamplesretainedcachefragmentactivity instances2 limit1e/strictmode( 2791): androidosstrictmode$instancecountviolation: class comnetflixrxjavaandroidsamplesretainedcachefragmentactivity instances2 limit1e/strictmode( 2791): class comnetflixrxjavaandroidsamplesretainedcachefragmentactivity instances3 limit1e/strictmode( 2791): androidosstrictmode$instancecountviolation: class comnetflixrxjavaandroidsamplesretainedcachefragmentactivity instances3 limit1e/strictmode( 2791): class comnetflixrxjavaandroidsamplesretainedcachefragmentactivity instances4 limit1e/strictmode( 2791): androidosstrictmode$instancecountviolation: class comnetflixrxjavaandroidsamplesretainedcachefragmentactivity instances4 limit1e/strictmode( 2791): class comnetflixrxjavaandroidsamplesretainedcachefragmentactivity instances5 limit1e/strictmode( 2791): androidosstrictmode$instancecountviolation: class comnetflixrxjavaandroidsamplesretainedcachefragmentactivity instances5 limit1e/strictmode( 2791): class comnetflixrxjavaandroidsamplesretainedcachefragmentactivity instances6 limit1e/strictmode( 2791): androidosstrictmode$instancecountviolation: class comnetflixrxjavaandroidsamplesretainedcachefragmentactivity instances6 limit1```i quickly glanced over the `replaysubject` subscription handling code and it looks as if on unsubscribe it removes the observer from the internal map maybe thats broken however?;were observing the leakage on replaying as well (using version 0170-rc7) it seems that `replaysubject` uses some `replaystate` map within its `replaystate` that keeps references to the subscriberswe currently work around the issue by avoiding (non-static) inner classes as subscribers and voiding references to activity/fragment-bound variables explicitly in `oncomplete` this of course only minimizes the impact of the leakageany better suggestions of how to handle that? || i think this issue and some related problems with replaysubject are now  could you confirm & close this issue? || i can confirm this is fixed for us || thanks @mttkay for the confirmation ||;1;0; replaysubject leak;
958;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatorskipwhile;reimplemented operatorskipwhile (the operationskipwhile has a state-sharing bug with  skipping  and  index ).  +1 test for many subscribers.;;0;operatorskipwhile;reimplemented operatorskipwhile (the operationskipwhile has a state-sharing bug with `skipping` and `index`)+1 test for many subscribers;#893 ;;;;1;1;operatorskipwhile;
"962;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;migrate from synchronizedobserver to serializedobserver;this pull request replaces use of  synchronizedobserver  with  serializedobserver .  ### why? #### 1) deadlocks  holding a lock while emitting notifications ( onnext    oncompleted    onerror ) allows for deadlocks if the event results in a cycle back to the parent.   while testing rxjava 0.17.0 in netflix production we ran into one of these. the vulnerability has existed all along but we finally hit it.  this issue has also been reported before such as:  #### 2) blocking threads  the use of  synchronized  can block threads. if it s used in areas such as modifying a data structure this can be okay. when emitting a notification however it is a problem as the result of an  onnext  can take a non-deterministically long time to complete. this means any other thread trying to emit will be blocked.  if the source threads are event loops (such as vert.x or netty) this will block the event loops.   for example  if two network calls off two netty event loops are being merged (such as via  flatmap ) and one of them does further slow processing that causes  onnext  to be slow  it will block the other  onnext  which blocks the event loop and prevents any further io on that thread. this is a significant problem for system scale and breaks the promise of rx being a non-blocking  reactive library. ### solution  the  synchronize    synchronizedobserver  and  synchronizedsubscriber  operator and classes have been deprecated. they are replaced by  serialize    serializedobserver  and  serializedsubscriber .  the  serializedobserver  still ensures only a single thread can emit  onnext    oncompleted   or  onerror  at a time but does not hold a lock while doing so. instead of blocking threads it will accept the incoming events into a buffer. thus  it becomes an asynchronous operator.  the  merge  operator (which impacts  flatmap ) now uses  serializedobserver   along with any other place in rxjava that needed synchronization. ### implementation  3 implementatations were written and tested: - [queue and counter]( - [queue and lock]( - [atomic state machine](  performance testing [revealed](      java     /**      * 1 streams emitting in a tight loop. testing for single-threaded overhead.      *       * -> blocking synchronization (synchronizedobserver)      *       * run: 10 - 58 186 310 ops/sec      * run: 11 - 60 592 037 ops/sec      * run: 12 - 58 099 263 ops/sec      * run: 13 - 59 034 765 ops/sec      * run: 14 - 58 231 548 ops/sec      *       * -> state machine technique (serializedobserverviastatemachine)      *       * run: 10 - 34 668 810 ops/sec      * run: 11 - 32 874 312 ops/sec      * run: 12 - 33 389 339 ops/sec      * run: 13 - 35 269 946 ops/sec      * run: 14 - 34 165 013 ops/sec      *       * -> using queue and counter technique (serializedobserverviaqueueandcounter)      *       * run: 10 - 19 548 387 ops/sec      * run: 11 - 19 471 069 ops/sec      * run: 12 - 19 480 112 ops/sec      * run: 13 - 18 720 550 ops/sec      * run: 14 - 19 070 383 ops/sec      *       * -> using queue and lock technique (serializedobserverviaqueueandlock)      *       * run: 10 - 51 295 152 ops/sec      * run: 11 - 50 317 937 ops/sec      * run: 12 - 51 126 331 ops/sec      * run: 13 - 52 418 291 ops/sec      * run: 14 - 51 694 710 ops/sec      */      /**      * 2 streams emitting in tight loops so very high contention.      *       * -> blocking synchronization (synchronizedobserver)      *       * run: 10 - 8 361 252 ops/sec      * run: 11 - 7 184 728 ops/sec      * run: 12 - 8 249 685 ops/sec      * run: 13 - 6 831 595 ops/sec      * run: 14 - 8 003 358 ops/sec      *       * (faster because it allows each thread to be  single threaded  while blocking the other)      *       * -> state machine technique (serializedobserverviastatemachine)      *       * run: 10 - 4 060 062 ops/sec      * run: 11 - 3 561 131 ops/sec      * run: 12 - 3 721 387 ops/sec      * run: 13 - 3 693 909 ops/sec      * run: 14 - 3 516 324 ops/sec      *       * -> using queue and counter technique (serializedobserverviaqueueandcounter)      *       * run: 10 - 4 300 229 ops/sec      * run: 11 - 4 395 995 ops/sec      * run: 12 - 4 551 550 ops/sec      * run: 13 - 4 443 235 ops/sec      * run: 14 - 4 158 475 ops/sec      *       * -> using queue and lock technique (serializedobserverviaqueueandlock)      *       * run: 10 - 6 369 781 ops/sec      * run: 11 - 6 933 872 ops/sec      * run: 12 - 5 652 535 ops/sec      * run: 13 - 5 503 716 ops/sec      * run: 14 - 6 219 264 ops/sec      */      /**      * 2 streams emitting once a millisecond. slow emission so little to no contention.      *       * -> blocking synchronization (synchronizedobserver)      *       * run: 10 - 1 996 ops/sec      * run: 11 - 1 996 ops/sec      * run: 12 - 1 995 ops/sec      * run: 13 - 1 997 ops/sec      * run: 14 - 1 996 ops/sec      *       * -> state machine technique (serializedobserverviastatemachine)      *       * run: 10 - 1 996 ops/sec      * run: 11 - 1 996 ops/sec      * run: 12 - 1 996 ops/sec      * run: 13 - 1 996 ops/sec      * run: 14 - 1 996 ops/sec      *       * -> using queue and counter technique (serializedobserverviaqueueandcounter)      *       * run: 10 - 1 996 ops/sec      * run: 11 - 1 996 ops/sec      * run: 12 - 1 996 ops/sec      * run: 13 - 1 996 ops/sec      * run: 14 - 1 995 ops/sec      *       * -> using queue and lock technique (serializedobserverviaqueueandlock)      *       * run: 10 - 1 996 ops/sec      * run: 11 - 1 996 ops/sec      * run: 12 - 1 997 ops/sec      * run: 13 - 1 996 ops/sec      * run: 14 - 1 995 ops/sec      */      the state machine solution was tested in production but caused performance problems  most likely due to the immense object allocation it needs to do.   the elegant  queue and counter  solution does not perform well enough in the non-contended case.  the  queue and lock  model performs well in the non-contended case and under contention  despite not being a very elegant solution and requiring the use of mutex locks for the state changes (but it does not hold the locks during notification). ### considerations  this does allow unbounded buffer growth  the same as  observeon  and  zip  instead of blocking the producer threads.  ### conclusion  the implementation in this pull request can and likely will be improved over time. the other implementations are purposefully being shown to allow others to provide further insight on how to do this better.   this change is important to ensure rxjava is non-blocking and our canary testing of this change in the netflix production environment suggests this change is both performant and functional.;;0;migrate from synchronizedobserver to serializedobserver;""this pull request replaces use of `synchronizedobserver` with `serializedobserver` ### why?#### 1) deadlocksholding a lock while emitting notifications (`onnext` `oncompleted` `onerror`) allows for deadlocks if the event results in a cycle back to the parent while testing rxjava 0170 in netflix production we ran into one of these the vulnerability has existed all along but we finally hit itthis issue has also been reported before such as:  2) blocking threadsthe use of `synchronized` can block threads if its used in areas such as modifying a data structure this can be okay when emitting a notification however it is a problem as the result of an `onnext` can take a non-deterministically long time to complete this means any other thread trying to emit will be blockedif the source threads are event loops (such as vertx or netty) this will block the event loops for example if two network calls off two netty event loops are being merged (such as via `flatmap`) and one of them does further slow processing that causes `onnext` to be slow it will block the other `onnext` which blocks the event loop and prevents any further io on that thread this is a significant problem for system scale and breaks the promise of rx being a non-blocking reactive library### solutionthe `synchronize` `synchronizedobserver` and `synchronizedsubscriber` operator and classes have been deprecated they are replaced  serialize` `serializedobserver` and `serializedsubscriber`the `serializedobserver` still ensures only a single thread can emit `onnext` `oncompleted` or `onerror` at a time but does not hold a lock while doing so instead of blocking threads it will accept the incoming events into a buffer thus it becomes an asynchronous operatorthe `merge` operator (which impacts `flatmap`) now uses `serializedobserver` along with any other place in rxjava that needed synchronization### implementation3 implementatations were written and tested:- [queue and counter]( [queue and lock]( [atomic state machine]( testing [revealed]( java    /**     * 1 streams emitting in a tight loop testing for single-threaded overhead     *      * -> blocking synchronization (synchronizedobserver)     *      * run: 10 - 58186310 ops/sec     * run: 11 - 60592037 ops/sec     * run: 12 - 58099263 ops/sec     * run: 13 - 59034765 ops/sec     * run: 14 - 58231548 ops/sec     *      * -> state machine technique (serializedobserverviastatemachine)     *      * run: 10 - 34668810 ops/sec     * run: 11 - 32874312 ops/sec     * run: 12 - 33389339 ops/sec     * run: 13 - 35269946 ops/sec     * run: 14 - 34165013 ops/sec     *      * -> using queue and counter technique (serializedobserverviaqueueandcounter)     *      * run: 10 - 19548387 ops/sec     * run: 11 - 19471069 ops/sec     * run: 12 - 19480112 ops/sec     * run: 13 - 18720550 ops/sec     * run: 14 - 19070383 ops/sec     *      * -> using queue and lock technique (serializedobserverviaqueueandlock)     *      * run: 10 - 51295152 ops/sec     * run: 11 - 50317937 ops/sec     * run: 12 - 51126331 ops/sec     * run: 13 - 52418291 ops/sec     * run: 14 - 51694710 ops/sec     */    /**     * 2 streams emitting in tight loops so very high contention     *      * -> blocking synchronization (synchronizedobserver)     *      * run: 10 - 8361252 ops/sec     * run: 11 - 7184728 ops/sec     * run: 12 - 8249685 ops/sec     * run: 13 - 6831595 ops/sec     * run: 14 - 8003358 ops/sec     *      * (faster because it allows each thread to be """"single threaded"""" while blocking the other)     *      * -> state machine technique (serializedobserverviastatemachine)     *      * run: 10 - 4060062 ops/sec     * run: 11 - 3561131 ops/sec     * run: 12 - 3721387 ops/sec     * run: 13 - 3693909 ops/sec     * run: 14 - 3516324 ops/sec     *      * -> using queue and counter technique (serializedobserverviaqueueandcounter)     *      * run: 10 - 4300229 ops/sec     * run: 11 - 4395995 ops/sec     * run: 12 - 4551550 ops/sec     * run: 13 - 4443235 ops/sec     * run: 14 - 4158475 ops/sec     *      * -> using queue and lock technique (serializedobserverviaqueueandlock)     *      * run: 10 - 6369781 ops/sec     * run: 11 - 6933872 ops/sec     * run: 12 - 5652535 ops/sec     * run: 13 - 5503716 ops/sec     * run: 14 - 6219264 ops/sec     */    /**     * 2 streams emitting once a millisecond slow emission so little to no contention     *      * -> blocking synchronization (synchronizedobserver)     *      * run: 10 - 1996 ops/sec     * run: 11 - 1996 ops/sec     * run: 12 - 1995 ops/sec     * run: 13 - 1997 ops/sec     * run: 14 - 1996 ops/sec     *      * -> state machine technique (serializedobserverviastatemachine)     *      * run: 10 - 1996 ops/sec     * run: 11 - 1996 ops/sec     * run: 12 - 1996 ops/sec     * run: 13 - 1996 ops/sec     * run: 14 - 1996 ops/sec     *      * -> using queue and counter technique (serializedobserverviaqueueandcounter)     *      * run: 10 - 1996 ops/sec     * run: 11 - 1996 ops/sec     * run: 12 - 1996 ops/sec     * run: 13 - 1996 ops/sec     * run: 14 - 1995 ops/sec     *      * -> using queue and lock technique (serializedobserverviaqueueandlock)     *      * run: 10 - 1996 ops/sec     * run: 11 - 1996 ops/sec     * run: 12 - 1997 ops/sec     * run: 13 - 1996 ops/sec     * run: 14 - 1995 ops/sec     */```the state machine solution was tested in production but caused performance problems most likely due to the immense object allocation it needs to do the elegant """"queue and counter"""" solution does not perform well enough in the non-contended casethe """"queue and lock"""" model performs well in the non-contended case and under contention despite not being a very elegant solution and requiring the use of mutex locks for the state changes (but it does not hold the locks during notification)### considerationsthis does allow unbounded buffer growth the same as `observeon` and `zip` instead of blocking the producer threads ### conclusionthe implementation in this pull request can and likely will be improved over time the other implementations are purposefully being shown to allow others to provide further insight on how to do this better this change is important to ensure rxjava is non-blocking and our canary testing of this change in the netflix production environment suggests this change is both performant and functional"";""#902  how about the enqueue/drain approach with synchronized counter increment and queue replacement as drain similar to your code? (no concurrentlinkedqueue) || possibly but it exposes a different problem: starvation one thread could end up constantly looping and draining the queue and never get a chance to return and emit data that it needs to emit i considered setting a max number of loops but when it finishes those loops then the other issue would still occur possibly leaving items in the queue waiting for some period of time until another eventthe queue/drain model works far better when there is a single thread dedicated to draining like in `observeon` stealing threads like this im not sure how to avoid having one of the two problems and im debating which one is worse (obviously ive decided starvation is worse for now and termination events always end up causing the queue to be drained) || but streams are not guaranteed to terminate they can be silent forever like observablenever || > they can be silent forever like observableneverin which case it would never emit anything and never queue anything> but streams are not guaranteed to terminateof course in which case its the next `onnext` that would drain the queuethe most concerning type of use case in the current implementation is one where 2 events are emitted one is delivered the other is queued then a long time passes before any further events occur in this use case the second `onnext` is just sitting in a queue waiting to be deliveredthe only model i can think of that solves this requires injecting extra concurrency - using a `scheduler` (defaulting to the `computation` one) to drain the queue but optimizing for using the providing thread in the non-contended case only using the `scheduler` to drain the queue when there is contention im not a fan of requiring that though for `merge` since that means `flatmap` could result in additional concurrency - but perhaps its an okay tradeoff to sometimes end up delivering the events via a different `scheduler` (think """"event loop"""") to ensure these two bad cases cant happen it would be a significant departure to start allowing additional scheduling and concurrency on `merge` though || could a fast producer see that its starving another thread and proactivelysteal the canemit to take over draining for a biton thu mar 13 2014 at 5:48 pm ben christensennotifications@githubcomwrote:> they can be silent forever like observablenever> > in which case it would never emit anything and never queue anything> > but streams are not guaranteed to terminate> > of course in which case its the next onnext that would drain the queue> > the most concerning type of use case in the current implementation is one> where 2 events are emitted one is delivered the other is queued then a> long time passes before any further events occur in this use case the> second onnext is just sitting in a queue waiting to be delivered> > the only model i can think of that solves this requires injecting extra> concurrency - using a scheduler (defaulting to the computation one) to> drain the queue but optimizing for using the providing thread in the> non-contended case only using the scheduler to drain the queue when> there is contention im not a fan of requiring that though for mergesince that means> flatmap could result in additional concurrency - but perhaps its an okay> tradeoff to sometimes end up delivering the events via a different> scheduler (think """"event loop"""") to ensure these two bad cases cant> happen it would be a significant departure to start allowing additional> scheduling and concurrency on merge though> > > reply to this email directly or view it on github  || > could a fast producer see that its starving another thread and proactively> steal the canemit to take over draining for a bithow would you do that by keeping track of the number of `onnext` received by each thread id?and how would it steal the `canemit` without blocking? || i dont know if this issue will remain in a few weeks if we end up implementing the continuation back-pressure solution as the inner queue would be bounded to a relatively small size (128? 512? 1024?) and the origin threads would end up parking themselves if they fill their buffers this would naturally cause a form of rescheduling and no single thread would starve out another as all would be required to limit the amount they emit || glad to see people taking notice of the deadlock issuehere are some tweaks that might help the queue-and-counter case:- optimistically start operations by compareswapping 1 for 0 into the counter if it succeeds do your work without queueing it (then try to drain the queue and decrement out of that responsibility as usual) this saves two atomic queue operations when things dont overlap but costs a cas when they do- wrap the observable instead of the observer this reduces the number of atomic operations when there are multiple subscriptions but makes each serialized operation take longer (so will cause more overlap)- since draining the queue can potentially live-lock a thread keep a non-synchronized count of how much work you have drained when it exceeds 10 or 100 or whatever spin off a new thread pool task to do the work so the caller gets control back (handing off to another producer is _hard_)- improve the concurrent queue using the knowledge that our case is many-producer-single-consumer for example a long time ago i tried an idea where [producers did a single atomic exchange]( the consumer had no atomic operations but there were issues with when queued operations became visible and that problem complicated draining and ultimately made it slower || hi @strilanc thanks for getting involved> queue-and-counter caseare you able to get it to perform as well as the queue-and-lock implementation? > wrap the observable instead of the observerwhat do you mean by this? here is the use case that needs to be solved:  since draining the queue can potentially live-lock a threadwe have chosen the other tradeoff of possibly delayed delivery right now so this doesnt happen we discuss this tradeoff in the comments above your proposed solution is one of the possibilities discussed but involves adding additional concurrency which has traditionally been unwanted (for cases like `merge`/`flatmap`) i think this issue goes away if we end up implementation the back pressure design were considering that would eliminate the unbounded buffers and thus naturally eliminate the live-lock/thread-starvation issue (example origin supporting continuation and parking itself:  improve the concurrent queue definitely as part of the continuation implementation for back pressure i expect us to end up using optimized ring buffers since we will have  size buffers we may be able to use a multi-producer-single-consumer ring buffer in some places but in this case where were stealing producer threads its not a traditional producer/consumer use case so likely will still need multi-producer-multi-consumer || hey @benjchristensen > are you able to get it to perform as well as the queue-and-lock implementation? i used the optimistic-cas trick as part of fixing a performance problem in an objective-c app that used reactivecocoa however that was essentially a single threaded case and i cant test on anything even approaching the scale netflix can> what do you mean by this? here is the use case that needs to be solved:  right that it doesnt apply to that case i was thinking of subscribing to a behaviorsubject where it would be wasteful to do the serialization once per observer instead of once inside the subject> we have chosen the other tradeoff of possibly delayed delivery right now so this doesnt happen we discuss this tradeoff in the comments above i think those comments are all about passing the draining to another producer the suggestion im giving is to transfer the work to the thread pool this avoids issues where the queue stops until another producer comes along and the corresponding tricky synchronization involved in that> but in this case where were stealing producer threads its not a traditional producer/consumer use case so likely will still need multi-producer-multi-consumeryes it is a bit of a unique case the consumer is only ever in one place but that place keeps teleporting around || > i cant test on anything even approaching the scale netflix cani dont think the netflix scale impacts this very much as many application use cases regardless of horizontal or vertical scale apply there are 3 primary use cases that occur when serializing:1) no contentionthis needs to be optimized for as its very common and the jvm does a great job with locks of recognizing there is no contention and performing well2) highly contendedthis happens when tight for/while loops are emitting and being merged its somewhat of a bad use case but it happens locks perform rather well per-thread since they block the other threads3) intermittent contentionthis case is easy with locks queues or cas and all perform about the same>  i was thinking of subscribing to a behaviorsubject where it would be wasteful to do the serialization once per observer instead of once inside the subjectthat makes sense>  the suggestion im giving is to transfer the work to the thread pool this avoids issues where the queue stops until another producer comes along and the corresponding tricky synchronization involved in thatagreed it will be far easier in this case and much more similar to how the queue-drain model works in `observeon` weve been trying to eliminate adding concurrency to `serialize` though as the last thing anyone expects `flatmap`/`merge` to do is inject a new thread to consume the work in rx its fairly normal for the producer to move across threads (as long as the emissions are serialized) since merging of streams happens all the time or other things like `onerrorresumenext` and `timeout` moving consumption to a new thread though only happens when explicitly asked for via `observeon` that said if the back-pressure work does not solve the trade-offs (thread-starvation or notification delay) we will likely end up pursuing the fallback solution of moving work to a `scheduler` when the live-lock counter threshold is hit || > optimistically start operations by compareswapping 1 for 0 into the counter if it succeeds do your work without queueing iti had done this optimization on the state machine one but hadnt on the queue and counter implementation as im not quite sure the race condition is safe it seems it should be good as it drains after emitting since this only occurs when count is 0 but i get multiple unit test failures when i attempt this optimization i havent spent the time to figure out why code updated to not queue on non-contended case here:  this optimization here are the before and after on performance:```     * -> using queue and counter technique (serializedobserverviaqueueandcounter)     *      * run: 10 - 19548387 ops/sec     * run: 11 - 19471069 ops/sec     * run: 12 - 19480112 ops/sec     * run: 13 - 18720550 ops/sec     * run: 14 - 19070383 ops/sec     *      *  after optimizations     *      * run: 10 - 40202262 ops/sec     * run: 11 - 40628288 ops/sec     * run: 12 - 41878527 ops/sec     * run: 13 - 43400405 ops/sec     * run: 14 - 40002117 ops/sec```however the queue-and-lock implementation is still faster:```     * run: 10 - 51295152 ops/sec     * run: 11 - 50317937 ops/sec     * run: 12 - 51126331 ops/sec     * run: 13 - 52418291 ops/sec     * run: 14 - 51694710 ops/sec``` and this optimization makes the contended cases slower:``` java     * run: 10 - 4300229 ops/sec     * run: 11 - 4395995 ops/sec     * run: 12 - 4551550 ops/sec     * run: 13 - 4443235 ops/sec     * run: 14 - 4158475 ops/sec     *      *  after """"optimizations""""     *      * run: 10 - 2857008 ops/sec     * run: 11 - 3093778 ops/sec     * run: 12 - 4009758 ops/sec     * run: 13 - 3094435 ops/sec     * run: 14 - 3166119 ops/sec```even if the performance changes made it better than queue-and-lock i am not certain this is thread-safe and there are 6 unit tests across the codebase now failing whereas queue-and-lock still performs better and all tests passi will explore this more as we finish experimenting with back pressure as that will define how `merge` and the primary use case for serialization/synchronization can be  @benjchristensen its important to use cas instead of incrementing the reason the code is failing is because you are incrementing before the enqueue even if something is draining the queue this can desync the count from the queue size for example:- thread d is draining the queue- the queue is currently empty but d has not yet called decrementandget to move the count from 1 to 0- thread p is about to enqueue an item- p calls getandincrement gets 1- d calls decrementandget gets 1- d calls queuepoll but gets null because the queue is empty (this should never happen)- p calls queueadd- the count is now off-by-one wrt the size of the queuethe optimization i am suggesting is this:```// --- queue ---// optimistically try to acquire draining responsibilities without enqueueingif (countcompareandset(0 1)) {    emitnotification(t)} else {    // enqueue then try to acquire draining responsibilities    queueadd(t)    if (countgetandincrement() > 0) return    // reduce to same case as other branch needing to decrement count    emitnotification(queuepoll())}// --- drain ---while (countdecrementandget() > 0) {        emitnotification(queuepoll())}```the reason the cas is safe despite violating the """"queue before incrementing"""" rule is that there is nothing draining the queue when the count was 0 its the only time its safe to increment without enqueueing there cant be an out-of-order dequeue because we just gained responsibility for any dequeueing thats about to happen || your suggested approach in this case by using cas(0 1) on every attempt is elegant in allowing the queue-before-increment in the else-branch case i like the pattern it does mean we are attempting a cas that could fail a lot of the time and that may be whats causing a further slow down in the contended performance metrics (see below) ive updated the code to your recommended solution:  with this change there are still unit test failures  so something else is wrong  ill have to debug further to understand whymore to the point though this implementation is still slower than queue-and-lock (and became even slower in the contended case):``` java/*** 1 streams emitting in a tight loop testing for single-threaded overhead*/// -> using queue and counter technique (serializedobserverviaqueueandcounter)run: 10 - 34238641 ops/sec run: 11 - 40711892 ops/sec run: 12 - 40732451 ops/sec run: 13 - 40819662 ops/sec run: 14 - 40870576 ops/sec -> using queue and lock technique (serializedobserverviaqueueandlock) run: 10 - 51295152 ops/secrun: 11 - 50317937 ops/secrun: 12 - 51126331 ops/secrun: 13 - 52418291 ops/secrun: 14 - 51694710 ops/sec/** * 2 streams emitting in tight loops so very high contention*/// -> using queue and counter technique (serializedobserverviaqueueandcounter)run: 10 - 2153329 ops/sec run: 11 - 5139837 ops/sec run: 12 - 2295464 ops/sec run: 13 - 2327337 ops/sec run: 14 - 2220375 ops/sec // -> using queue and lock technique (serializedobserverviaqueueandlock)run: 10 - 5120561 ops/sec run: 11 - 5509731 ops/sec run: 12 - 5214265 ops/sec run: 13 - 5133194 ops/sec run: 14 - 5309957 ops/sec ```---as a side note `countgetandincrement()  0` is equivalent to `countcompareandset(0 1)` unless wanting to hold off on incrementing in the failure case (as youre nicely doing in your example) as `getandincrement` does `compareandset` under the covers and will only return 0 if it wins incrementing from 0 to 1 this is the jdk code:``` java    public final int getandincrement() {        for () {            int current  get()            int next  current + 1            if (compareandset(current next))                return current        }    }```this usage works very well in several other places in rxjava such as `observeon` that increments/decrements concurrently to drain a queue from a single thread (code at  you for your involvement in this i appreciate the insights and help || @benjchristensen my guess for the test failure now is that i did not wrap null into nullsentinel in the cas case and so it is ignored in emitnotificationthat ignore-on-null check is problematic in the other case as well because polling the queue returning a null should never happen in the current code it should be asserted as not null as opposed to ignored when nullim interested in what could possibly be making lock+queue faster consider what happens in the uncontended case of queue+counter:- a cas from 0 to 1- (forwarding the notification)- a decrementwe have an atomic operation to acquire and an atomic operation to release how is locking doing better?is it the fact that the decrement is actually a read and a cas? maybe optimistically assuming the value is still 1 on the first attempt to decrement would save some time by avoiding the read?is the runtime using something a bit more flexible than atomics to implement its locking? relaxed atomics or something like that? some kind of lock elision? a jit optimization that recognizes single-thread visibility? || i did some profiling to find out where the time is going interesting things happeni profiled synchronize by itself outside of the use case like so:```    atomicinteger r  new atomicinteger(0)    final int n  10000000    while (true) {        final object obj  new object()        long n1  systemnanotime()        for (int i  0 i < n i++) {            synchronized(obj) {            }        }        long n2  systemnanotime()        double s  (n2-n1)/mathpow(10 9)        double mhz  n/s / mathpow(10 6)        systemoutprintln(new decimalformat(""""#00"""")format(mhz) + """" mhz"""")    }```and the cas profiling just replaced the synchronized block with this:```            rcompareandset(0 1)            rcompareandset(1 0)```the synchronized results are interesting for about 10 seconds the results hover around 30mhz then they jump to hovering around 350mhz i assume the jit kicked in and did some magicfor atomicinteger the two cas operations benchmark at about 50mhzgiven that i dont understand what exactly is happening to increase the lock performance by an order of magnitude after ten seconds i cant say which will be faster in our use case if that optimization is applicable and applied locks win by a lot if not cas wins by a bit (in the uncontended case) || @benjchristensen ive come to the conclusion that im not going to beat javas synchronize blocks without some serious effort im not sure its even possible in the single-threaded case where synchronizes biased locking elides the atomic operations but relies on messing with other threads stacks || thanks for continuing on this im not surprised we cant beat the compiler :-) im curious why the cas operations arent similarly optimized this exploration isnt done yet and ill come back to it in coming weeks we dont necessarily need to be faster than locks to end up using cas there are other benefits to cas over locks  || im seeing a nasty bug related to this i believe where the use of merge + serializedsubscriber has the result of oncompleted being called before onnext has finished i thought id mention it now while i dig around trying to get a unit test in case it rings bells for those of you that a familiar with the changed code  my use case worked as expected in 0170 t"
"en not in 0171 at all unfortunately the code is too complex to present here without adding stupid amounts of noise so i will try to distill a unit test || @benjchristensen @davidmoten i think the problem has to do with the queue not being drained properly theres a copy-away-to-avoid-locking thing happening but `drainqueue` only drains the copy it doesnt go back and check if theres more to drain which can leave the queue with items hangingactually im kind of surprised any concurrent completions are working if terminated is set while the queue is being concurrently drained i dont think anything forwards the completion ever!theres also a race on `emitting` being cleared vs another producer taking up drainingi think your particular bug is because of this:```    if (canemit) {        // we won the right to emit        try {            drainqueue(list)            actualonnext(t)```theres a race with an `oncomplete` firing before that call to `drainqueue` runs then `onnext` ruins everything  except that `list ! queue` so i dunnostill the hand-off process between producers is wrong in the current queue+lock implementation its rotten enough to consider starting from scratch to avoid contamination from the same subtle mistakes there definitely need to be tests that detect these || thanks for that ill stop chasing a unit test ill leave it to the rxjavaexperts to run withon 20 march 2014 11:22 craig gidney notifications@githubcom wrote:> i think the problem has to do with the queue not being drained properly> theres a copy-away-to-avoid-locking thing happening but drainqueue only> drains the copy it doesnt go back and check if theres more to drain> which can leave the queue with items hanging> > actually im kind of surprised any concurrent completions are working if> terminated is set while the queue is being concurrently drained i dont> think anything forwards the completion ever!> > theres also a race on emitting being cleared vs another producer taking> up draining> > your particular bug is because of this:> > ```> if (canemit) {>     // we won the right to emit>     try {>         drainqueue(list)>         actualonnext(t)> ```> > theres a race with an oncomplete firing before that call to drainqueueruns then> onnext ruins everything> > basically the entire hand-off process between producers is wrong in the> current queue+lock implementation> > ## > > reply to this email directly or view it on github  || > if terminated is set while the queue is being concurrently drained i dont think anything forwards the completion ever!it happens right here:  || can one of you please provide me a test case? the only way i can cause a problem so far is if the source observable breaks the rx contracthere are examples where threads are racing each other:``` java    @test    public void testconcurrency() {        observable<integer> o  observablecreate(new onsubscribe<integer>() {            @override            public void call(final subscriber<? super integer> s) {                schedulersnewthread()schedule(new action1<inner>() {                    @override                    public void call(inner inner) {                        for (int i  0 i < 10000 i++) {                            sonnext(1)                        }                        soncompleted()                    }                })            }        })        for (int i  0 i < 1000 i++) {            observable<integer> merge  observablemerge(o o o)            testsubscriber<integer> ts  new testsubscriber<integer>()            mergesubscribe(ts)            tsawaitterminalevent()            assertequals(1 tsgetoncompletedevents()size())            assertequals(30000 tsgetonnextevents()size())            list<integer> onnextevents  tsgetonnextevents()            systemoutprintln(""""onnext: """" + onnexteventssize() + """" oncompleted: """" + tsgetoncompletedevents()size())        }    }```another variant this time with sleeps to cause random concurrent behavior:``` java    @test    public void testconcurrencywithsleeping() {        observable<integer> o  observablecreate(new onsubscribe<integer>() {            @override            public void call(final subscriber<? super integer> s) {                schedulersnewthread()schedule(new action1<inner>() {                    @override                    public void call(inner inner) {                        for (int i  0 i < 100 i++) {                            sonnext(1)                            try {                                threadsleep(1)                            } catch (interruptedexception e) {                                eprintstacktrace()                            }                        }                        soncompleted()                    }                })            }        })        for (int i  0 i < 100 i++) {            observable<integer> merge  observablemerge(o o o)            testsubscriber<integer> ts  new testsubscriber<integer>()            mergesubscribe(ts)            tsawaitterminalevent()            assertequals(1 tsgetoncompletedevents()size())            assertequals(300 tsgetonnextevents()size())            list<integer> onnextevents  tsgetonnextevents()            systemoutprintln(""""onnext: """" + onnexteventssize() + """" oncompleted: """" + tsgetoncompletedevents()size())        }    }```both of those work correctlyi am however able to get it to behave poorly when the rx contract is broken:``` java    @test    public void testconcurrencywithbrokencontract() {        observable<integer> o  observablecreate(new onsubscribe<integer>() {            @override            public void call(final subscriber<? super integer> s) {                schedulersnewthread()schedule(new action1<inner>() {                    @override                    public void call(inner inner) {                        for (int i  0 i < 10000 i++) {                            sonnext(1)                        }                        soncompleted()                        for (int i  0 i < 100 i++) {                            sonnext(1)                        }                        soncompleted()                        for (int i  0 i < 100 i++) {                            sonnext(1)                        }                    }                })            }        })        for (int i  0 i < 1000 i++) {            observable<integer> merge  observablemerge(o o o)            testsubscriber<integer> ts  new testsubscriber<integer>()            mergesubscribe(ts)            tsawaitterminalevent()            assertequals(1 tsgetoncompletedevents()size())            assertequals(30000 tsgetonnextevents()size())            list<integer> onnextevents  tsgetonnextevents()            systemoutprintln(""""onnext: """" + onnexteventssize() + """" oncompleted: """" + tsgetoncompletedevents()size())        }    }```this emits: `javalangassertionerror: expected:<30000> but was:<29377>`the fix for this is to not decrement the count if `oncomplete` is received more than once:```             final class innerobserver extends subscriber<t> {+                private boolean innercompleted  false+                 public innerobserver() {                 }                 @override                 public void oncompleted() {-                    if (runningcountdecrementandget()  0 && completed) {-                        ooncompleted()+                    if (!innercompleted) {+                        // we check if already completed otherwise a misbehaving observable that emits oncomplete more than once+                        // will cause the runningcount to decrement multiple times+                        innercompleted  true+                        if (runningcountdecrementandget()  0 && completed) {+                            ooncompleted()+                        }+                        cleanup()                     }-                    cleanup()                 }``` || just merged the fix for an observable that emits multiple `oncomplete`  || ben this serialized subscriber complicates my world for this reason:i am merging asynchronous observables each observable has a resource that must remain open till all onnext calls have finished for that observable the onsubscribe for the observable get a fresh resource calls onnext repeatedly then closes the resource and calls oncomplete because the serializedsubscriber has buffered stuff asynchronously i am encountering the situation where the resource has been closed before the onnext have finished and i get errorsunless im mistaken this is a most undesirable effect that will complicate the hell out of writing  observables || @benjchristensen my guess was that if a subject sent a re-entrant oncompleted in its serialized onnext callback that the oncomplete would not forward something like:```subject<object> s  new subject<>()observable<object> r  sserialized()bool a  new bool[1]roncompleted(() -> a[0]  true)ronnext((x) -> ssendcompleted())ssendnext(null)assert(a[0])```(i apologize if i got some of the method names wrong) || @davidmoten it sounds like the problem is that the resource is being closed by the producer instead of the consumer when its the consumer that relies upon it would it also break if `delay` was applied to it?i dont know the conventions of rxjava well enough to suggest what _should_ be done my guess would be that the consumer should be responsible for disposing the subscription even if it completes and so youd cleanup-on-dispose rather than cleanup-on-complete-sent || @strilanc good description not sure about delay ill look it upcleanup on completion i suspect is achieved with the `observableusing()` method so ill try that but cleanup on dispose is also a possibility i wrote a quick test and unsubscribe is called even after oncompleted is called so that could work im a bit concerned in the synchronous case that if i use unsubscribe to close resources then the subsequent observable (say in a flatmap) might commence and be blocked waiting for a resource from a singleton resource pool || @davidmoten i dont know the specifics of the situation so this might be a ridiculous suggestion in context but what about releasing producing rights after on-complete is sent but only release the actual resource based on a subscribed reference count?so consumer1 subscribes and the resource is allocated the notifications get sent and the resource is now no longer """"busy"""" but does still have to exist consumer2 subscribes and does not wait because the resource is not """"busy"""" (despite already being allocated) consumer2 unsubscribes and the resource goes back to """"allocated but not busy"""" consumer1 unsubscribes and the resource gets released || > each observable has a resource that must remain open till all onnext calls have finished for that observable @davidmoten once an `observable` has emitted all of its `onnext` it has no further control over the events anything downstream can be async (such as `zip` and `observeon`) and `oncompleted` and cleanup will have been performed by the source `observable` while the events are still being processed downstream that is the nature of async push> my guess was that if a subject sent a re-entrant oncompleted in its serialized onnext callback that the oncomplete would not forward @strilanc the rx contract is clear that once an `oncompleted` or `onerror` is received no further events are to be sent those are terminal events thus your example breaks the contract by sending `oncomplete` to `observable` """"s"""" and then expecting to send more events to it> my guess would be that the consumer should be responsible for disposing the subscription even if it completes and so youd cleanup-on-dispose rather than cleanup-on-complete-sentthe `unsubscribe` always gets called at the end (after `oncomplete` or `onerror`) but events can not rely upon the source `observable` not having been cleaned up because any number of compositions can cause the source `observable` to be long gone by the time the events are processed some examples include: `zip` `observeon` `cache` `replay` `delay` `window` `buffer` and now `merge`the `unsubscribe` event also can occur well before the final `subscriber` receives the events for example the `merge` operator eagerly invokes `unsubscribe` as soon as `oncomplete` is received otherwise memory leaks can occur on long-lived streaming use cases since the final `subscriber` may never actually completefrom what i can tell the difference in behavior youre seeing is coincidental before the `synchronized` solution would allow a broken contract to flow through such as: `onnext` `oncompleted` `onnext` this would flow through until some operator or the final `safesubscriber` filtered out the last `onnext` that broke the contract the new `serialized` solution is maintaining the contract and filtering out everything after a terminal event (according to the rx contract) it doesnt need to be done on `serialized` but is an optimization to allow it to finish draining the queue i could go either way on this one  but no operator or observable should depend on events propagating after `oncompleted` `onerror` or `unsubscribe`@davidmoten what is the use case you have where emitted events depend on their original `observable` not having been cleaned up? that is not going to be reliable when it gets composed || @benjchristensen   thanks for yourdetailed response ive refactored my observable to internalize usage ofthe resource to the observable and it now only emits items that do notdepend on the resource i did this on my first iteration of the code amonth ago but found nothing was pushing me to do this in particular(clearly hadnt used zip cache etc in my use cases and was deliberatelyavoiding observeon)the use case was resource  jdbc connection and item  resultset the firstaction from the observable was always a map to somethiing not dependent onthe resultset/connection which was frequently flatmapped butserializedsubscriber threw a spanner in the works and quite rightly so irealize ive internalized that map now so that a resultset is not emittedand all my unit tests pass with 0171 at least now ill be able to throwasync operators at it with impunity now fyi the project is at again for your time and to @strilanc twas all me and was easilyfixeddaveon 22 march 2014 01:17 ben christensen notifications@githubcom wrote:> each observable has a resource that must remain open till all onnext calls> have finished for that observable> > @davidmoten  once an observable has> emitted all of its onnext it has no further control over the events> anything downstream can be async (such as zip and observeon) and> oncompleted and cleanup will have been performed by the source observablewhile the events are still being processed downstream that is the nature> of async push> > my guess was that if a subject sent a re-entrant oncompleted in its> serialized onnext callback that the oncomplete would not forward> > @strilanc  the rx contract is clear that> once an oncompleted or onerror is received no further events are to be> sent those are terminal events thus your example breaks the contract by> sending oncomplete to observable """"s"""" and then expecting to send more> events to it> > my guess would be that the consumer should be responsible for disposing> the subscription even if it completes and so youd cleanup-on-dispose> rather than cleanup-on-complete-sent> > the unsubscribe always gets called at the end (after oncomplete or onerror)> but events can not rely upon the source observable not having been> cleaned up because any number of compositions can cause the source> observable to be long gone by the time the events are processed some> examples include: zip observeon cache replay delay window buffer> and now merge> > the unsubscribe event also can occur well before the final subscriberreceives the events for example the> merge operator eagerly invokes unsubscribe as soon as oncomplete is> received otherwise memory leaks can occur on long-lived streaming use cases> since the final subscriber may never actually complete> > from what i can tell the difference in behavior youre seeing is> coincidental before the synchronized solution would allow a broken> contract to flow through such as: onnext oncompleted onnext this> would flow through until some operator or the final safesubscriberfiltered out the last> onnext that broke the contract the new serialized solution is> maintaining the contract and filtering out everything after a terminal> event (according to the rx contract) it doesnt need to be done on> serialized but is an optimization to allow it to finish draining the> queue i could go either way on this one  but no operator or observable> should depend on events propagating after oncompleted onerror or> unsubscribe> > @davidmoten  what is the use case you have> where emitted events depend on their original observable not having been> cleaned up? that is not going to be reliable when it gets composed> > ## > > reply to this email directly or view it on github  || always keep a copy of  next to your keyboard (which reminds me we should do a refresh of this and for every language) || @davidmoten glad it was easy to resolve || @benjchristensen  with reference to this problem:the most concerning type of use case in the current implementation is one where 2 events are emitted one is delivered the other is queued then a long time passes before any further events occur in this use case the second onnext is just sitting in a queue waiting to be deliveredim encountering this problem now using merge my use case is described [here ]( my assumption at this point is that the problem is here to stay and im looking for the least objectionable way of handling it do we need to be able to parameterize the use of a serializedsubscriber so that we can avoid the behaviour if we choose to? in serializedsubscriber once winning the right to emit we currently drain the queue before the onnext is called is there any scope for draining the queue some limited/configurable number of times after the onnext is called as well? i certainly see problems with this as well because the last  drain of the queue still offers the chance of delaying  an incoming onnext for certain use cases however this could reduce the likelihood of the delay happening perhaps some probabilistic diminishment is the best we can hope for || @davidmoten if an event sits in the queue until the next event instead of eventually being forwarded even if another event doesnt come along its a bugare you actually experiencing this bug? || @strilanc yeah im experiencing it as described [here]( my first para above quotes ben on this one and is known issue i realize on reviewing the conversation above that my rambly ideas seem to have been talked about already i thought id push it along a little seeing as im bumping into the issue now (though not without a somewhat ugly workaround) it strikes me as a serious side-effect of work that is trying to ameliorate deadlocks and blocking || i have created  for us to continue this discussion and determine how to move forward || "";;;;1;1;synchronize -> serialize- migrate all usage to serialized instead of synchronized- remove implementations of serializedobserver that lost the competition (performance and testing in production);"
"964;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;subjectsubscriptionmanager fix.;fix for #961  if an already unsubscribed subscriber is added  the subscription function ends up in an infinite loop as the inner unsubscription logic changes the state to another object before the outer state machine continues. - the outer state machine loop now exits if unsubscription happened and doesn t attempt to modify the state. - the removeobserver method is changed so that if the subscription to be removed is not in the array  it returns this instead of an unnecessary copy. in addition  copyof calls have been replaced by arraycopy to avoid reflective array creation.;;961.0;subjectsubscriptionmanager fix;fix for #961if an already unsubscribed subscriber is added the subscription function ends up in an infinite loop as the inner unsubscription logic changes the state to another object before the outer state machine continues- the outer state machine loop now exits if unsubscription happened and doesnt attempt to modify the state- the removeobserver method is changed so that if the subscription to be removed is not in the array it returns this instead of an unnecessary copy in addition copyof calls have been replaced by arraycopy to avoid reflective array creation;#904 interesting bug thanks for the fix!as for the test failure looks like `testnumberofthreadsonscheduledmerge` has become non-deterministic as a result of recent changes (not your commit) ||;subject - subscribeon not persisted? [0170];""this might be intentional change from 016 -> 017 but i have noticed a change in how subjects `onsubscribe` reacti had the following setup ``` javampaymentcodesubject  behaviorsubjectcreate((string) null)       mpaymentcodesubjectsubscribeon(schedulersio())```then i would refresh via this means:``` javampaymentcodesubject                first()                flatmap(new rxfunctionsfunc1<string observable<paymentcode>>() {                    @override                    public observable<paymentcode> call(final string currentpaymentcode) {                        lgw(""""thread: %s"""" threadcurrentthread()getname())                        return mcoderequestergetpaymentcode(currentpaymentcode)                    }                })                subscribe(                        new rxfunctionsaction1<paymentcode>() {                            @override                            public void call(final paymentcode paymentcode) {                                lgw(""""thread: %s"""" threadcurrentthread()getname())                                updatepaymentcode(paymentcodegetcode())                            }                        }                )```so what i expect to happen is that all subsequent subscriptions are on the `io` pool but `first()` and all operators after are executed on the thread that called this method in this case on android the `main` threadso when `first()` does not return anything it blocks and waits (locking up the main thread)i  it with the following change:``` javampaymentcodesubject                subscribeon(schedulersio()) //explicitly define scheduler                first()                flatmap(new rxfunctionsfunc1<string observable<paymentcode>>() {                //```not sure if its the `subject` implementation or `first()` which has changed im going to roll back to dig around a bit more_edit_it appears `first()``take()` etc are the cause here rolled back to 016 and first() is called on the main thread without locking updoing the following also fixes the problem:``` javampaymentcodesubject                //first()                flatmap(new rxfunctionsfunc1<string observable<paymentcode>>() {                //```hoping someone could shed some light?"";mpaymentcodesubject  behaviorsubjectcreate((string) null)       mpaymentcodesubjectsubscribeon(schedulersio())```what this does and always did (unless im missing something about subjects) is create the subject in line one then invoke a method which returns a _new_ subject (scheduled on the io scheduler) just to then discard it all operators (and subscribeon() simply applies an operator) do not mutate the sequence but transform it into a new onewhat you want is:```mpaymentcodesubject  behaviorsubjectcreate((string) null)       mpaymentcodesubject  mpaymentcodesubjectsubscribeon(schedulersio())```that said im surprised this ever worked since it shouldnt have ever even executed on that scheduler to begin with ^^ cant say if this is really causing the problem youre seeing just something i noticed || @mttkay yeah your right rolled back to 016 the scheduler was never applied seems that some implementation of `first()` has changed as removing that resolves the problemi updated the op || the `first` operator would have been impacted  take` changing in 0170 i have not yet spent the time to understand this code || > so when first() does not return anything it blocks and waits (locking up the main thread)that is exactly what is expected for `take`/`first` in your full code example are you trying to then call `mpaymentcodesubjectonnext(something)` on the same thread as the subscription is occurring on? || @benjchristensen yeah i would expect that too for `take`/`first` but if i roll back to 016 it still blocks but other `observables` that call `observeon(mainthread)` still return even tho that call is blocked`mpaymentcodesubjectonnext()` would eventually get called inside the subscription but thats not the issue i saw a whole different observable called later in execution eg:``` javamsessionproviderisloggedinandpinset(true)                subscribeon(schedulersio)                observeon(androidschedulersmainthread())                subscribe(new observer<void>() {                    @override                    public void oncompleted() {                        mnavigationcontroller                                next(homeactivitycreateintent(startactivitythis))                                finish()                    }                    @override                    public void onerror(throwable e) {                        //no login token                        lgw(""""no user session/pin"""")                        mnavigationcontroller                                next(onboardingactivitycreateintent(startactivitythis))                                finish()                    }                    @override                    public void onnext(void token) {                    }                })```this will never make it back to the subscriber i can only think that the changes to the `subscribers` somewhere along the line have affected other observables using the same thread i may just however be a coincidence that this hasnt broken before and actually as 017 simplifies `subscribers` it may not have been working correctly before || hi could you do a thread dump to see where it blocks?i dont see any operators that would block the current thread previously operations such as `from` and `range` combined with `take` would not properly return until all elements were producedwhat kind of observable does `mcoderequestergetpaymentcode()` return? || traceview file android specific hopefully will help || @akarnokd also at first look of the trace it seems to be going around in circles as it doesnt just block it recursively calls very odd things going on || thanksthis code demonstrates the issue on normal java:``` javabehaviorsubject<string> src  behaviorsubjectcreate((string)null)for (int i  0 i < 10 i++) {    srconnext("""""""" + i)    systemoutprintf(""""turn: %d%n"""" i)    srcfirst()            flatmap(new func1<string observable<string>>() {        @override        public observable<string> call(string t1) {            return observablefrom(t1 + """" """" + t1)        }    })    subscribe(new observer<string>() {        @override        public void onnext(string t) {            systemoutprintln(t)        }        @override        public void onerror(throwable e) {            eprintstacktrace()        }        @override        public void oncompleted() {        }    })}```it seems the code above ends up in an infinite loop within the subjectsubscriptionmanager l60-l99 l89 fights against l99 all the time ill post a pr to fix this || cool nice find glad the trace helpedon 13 mar 2014 21:31 """"akarnokd"""" notifications@githubcom wrote:> thanks> > this code demonstrates the issue on normal java:> > behaviorsubject<string> src  behaviorsubjectcreate((string)null)> for (int i  0 i < 10 i++) {>     srconnext("""""""" + i)>     systemoutprintf(""""turn: %d%n"""" i)>     srcfirst()>             flatmap(new func1<string observable<string>>() {> > ```>     @override>     public observable<string> call(string t1) {>         return observablefrom(t1 + """" """" + t1)>     }> })> subscribe(new observer<string>() {>     @override>     public void onnext(string t) {>         systemoutprintln(t)>     }> >     @override>     public void onerror(throwable e) {>         eprintstacktrace()>     }> >     @override>     public void oncompleted() {>     }> })}> ```> > it seems the code above ends up in an infinite loop within the> subjectsubscriptionmanager l60-l99 l89 fights against l99 all the time> ill post a pr to fix this> > ## > > reply to this email directly or view it on github  || i think this issue has been resolved and can be closed || yes your right || "";1;0;subjectsubscriptionmanager fix;"
"965;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;bugfix: chain subscription in timeoutsubscriber and serializedsubscriber;this pr chains subscription in timeoutsubscriber  and serializedsubscriber. found by @rbramw #951. thanks for your unit tests  @rbramw;;951.0;bugfix: chain subscription in timeoutsubscriber and serializedsubscriber;this pr chains subscription in timeoutsubscriber  and serializedsubscriber found by @rbramw #951 thanks for your unit tests @rbramw;#905 i have no idea why `rxoperatorsoperationparallelmergetesttestnumberofthreadsonscheduledmerge` failed in my local machine it fails sometimes is it nondeterministic? || rebased || #915  thank you ||;operatortimeoutbase unsubscribe from source;if no other observable is supplied to the operatortimeout:public final observable<t> timeout(long timeout javautilconcurrenttimeunit timeunit)then it does not unsubscribe from the source in the event of a timeout;""#886 @rbramw can you please provide a unit test to demonstrate the issue this is fixing? || here are 3 tests which can be added to operatortimeouttestsjava demonstrating the issue i see when using the timeout method as @zsxwing pointed out i dont think my fix is providing anything extra so please ignore it```@testpublic void shouldunsubscribefromunderlyingsubscriptionontimeout() {    final subscription s  mock(subscriptionclass)    // an observable which never emits anything    observable<string> never  observablecreate(new onsubscribe<string>() {        public void call(subscriber<? super string> subscriber) {            systemoutprintln(""""never observable subscribed to """")            subscriberadd(s)        }    })    // when wrapped in a timeout observable     observable<string> observablewithtimeout  nevertimeout(1 timeunitmilliseconds)    try {        observablewithtimeouttoblockingobservable()foreach(new action1<string>() {            public void call(string t1) {                fail(""""never observable should not have emited an item - """"+t1)            }        })        fail(""""never observable should not have completed"""")    }    catch(throwable ex) {        systemoutprintln(""""observablewithtimeout emitted error - """"+exgetmessage())        // should unsubscribe        verify(s times(1))unsubscribe()    }}@testpublic void shouldunsubscribefromunderlyingsubscriptiononimmediatelycomplete() {    final subscription s  mock(subscriptionclass)    observable<string> immediatelycomplete  observablecreate(new onsubscribe<string>() {        public void call(subscriber<? super string> subscriber) {            systemoutprintln(""""immediatelycomplete observable subscribed to """")            subscriberadd(s)            subscriberoncompleted()        }    })    observable<string> observablewithtimeout  immediatelycompletetimeout(1 timeunitseconds)    try {        observablewithtimeouttoblockingobservable()foreach(new action1<string>() {            public void call(string t1) {                fail(""""immediatelycomplete observable should not have emited an item - """"+t1)            }        })        systemoutprintln(""""immediatelycomplete completed"""")        verify(s times(1))unsubscribe()    }    catch(throwable ex) {        fail(""""immediatelycomplete observable should not emited an error - """"+exgetmessage())    }}@testpublic void shouldunsubscribefromunderlyingsubscriptiononimmediatelyerrored() {    final subscription s  mock(subscriptionclass)    observable<string> immediatelyerror  observablecreate(new onsubscribe<string>() {        public void call(subscriber<? super string> subscriber) {            systemoutprintln(""""immediatelyerrored observable subscribed to """")            subscriberadd(s)            subscriberonerror(new runtimeexception(""""error""""))        }    })    observable<string> observablewithtimeout  immediatelyerrortimeout(1 timeunitseconds)    try {        observablewithtimeouttoblockingobservable()foreach(new action1<string>() {            public void call(string t1) {                fail(""""immediatelyerrored observable should not have emited an item - """"+t1)            }        })        fail(""""immediatelyerrored observable should not have completed"""")    }    catch(throwable ex) {        systemoutprintln(""""observablewithtimeout emitted error - """"+exgetmessage())        verify(s times(1))unsubscribe()    }}``` || i sent a pr #965 to fix the issue thanks for your unit tests @rbramw  || "";1;0;chain subscription in timeoutsubscriber and serializedsubscriber;"
966;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;reimplement the elementat operator and add it to rxjava-scala;;;0;reimplement the elementat operator and add it to rxjava-scala;;#906 #907 rebased || #916 ;;;;1;1;implement elementat as operator;
970;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;notifications for the allocation averse.;i ve seen and used the sentinel pattern in a couple of places in the implementation of operators.  i figured i d formalize the hacks into one place where bugs can coalesce.  as a bonus the code that uses it looks a bit cleaner now.;;0;notifications for the allocation averse;ive seen and used the sentinel pattern in a couple of places in the implementation of operators  i figured id formalize the hacks into one place where bugs can coalesce  as a bonus the code that uses it looks a bit cleaner now;#911  nice abstraction ||;;;;1;1;notifications for the allocation adverse;
"972;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fixed deadlock in subjects + operatorcache.;fix for issue #971. - i had to rewrite operatorcache to allow testing for deadlocks in all subject types. - the terminationlatch was unnecessarily waiting for existing subscribers to deliver their termination events  which caused deadlock with repeat(). - treating subjects as internal implementations was not necessary to fix the problem.;;971.0; deadlock in subjects + operatorcache;fix for issue #971- i had to rewrite operatorcache to allow testing for deadlocks in all subject types- the terminationlatch was unnecessarily waiting for existing subscribers to deliver their termination events which caused deadlock with repeat()- treating subjects as internal implementations was not necessary to fix the problem;#912  i dont understand these changes yet but on first review they are very awkward as the `subjectsubscriptionmanager` methods now both invoke a function and return a collection || true the rewritten subjects dont require an action1 they are fine with action0 the changes had to be made since the countdonwlatch logic acted as a synchronization block and emitting events while holding locks is prone to deadlocks as the associated issue demonstrates || ah holding the lock is the issue we should find a way of doing that without the latches at all as it is blocking  || the latch has its use because once the state has been swapped to terminal state we still need to perform some tasks on any related state within the particular subject before client notifications can resume: usually it is to set the last event which then will be available to newcomers || i havent merged this yet as i need to spend time better understanding this and the impact on design || since this has conflicts and i did some cleanup based on our discussion above ive opened  for merging this  ||;subjects are not recognized as internal observer implementations;""based on an [issue report]( the following program prints the sequence twice instead of continuously:``` javapublic class repeatcachetest {    public static void main(string args) throws exception {        observablefrom(1 2 3)                subscribeon(schedulersio())                flatmap(i -> observabletimer(i * 100                       timeunitmilliseconds)map(j -> i))                cache()                repeat()                zip(observabletimer(0 300                        timeunitmilliseconds schedulersnewthread())                        (a b) -> a)                subscribe(        systemout::println throwable::printstacktrace                 () -> systemoutprintln(""""done""""))        threadsleep(100000)    }}```the problem seems to be in `observableisinternalimplementation()` (l8661) not recognizing the replaysubject of the `cache()` operator wrapped by a anonymous subscriber under observable - a logic is required on l7002 to preserve the safeness of the wrapped observer somehow (private indicator interface?)- can we consider rxsubjects\* classes as safe?alternatively cache() could wrap the subject in a subscriber so it will count as internal implementation but this has to be repeated for multicast and other placesthoughts?edit:i did some experimenting and found out the above changes are half solving the problem the second issue is with the subjectsubscriptionmanager which deadlocks on the terminationlatchawait (l69) because after the second iteration the terminationlatchcountdown (l140) is never called the onterminate call triggers a new subscription through the repeat operator which reenters the call on l50 and deadlock"";would this be simplified if we eliminate the `isinternalimplementation` check (that i dont like) and use `unsafesubscribe()` as discussed here:  ? || sureto be clear the real problem was something else i discovered soon after i posted this issue || closing as not relevant anymore ||;1;0; deadlock in subjects + operatorcache;"
974;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;testsubject  testobserver and testscheduler improvements;;;0;testsubject testobserver and testscheduler improvements;;;;;;1;1;testsubject testobserver and testscheduler improvements;
982;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;pivot operator;;;0;pivot operator;;#921 ;;;;1;1;pivot operator;
984;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;tests and javadoc for pivot;;;0;tests and javadoc for pivot;;;;;;1;1;add javadoc to pivot;
988;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;onerrorfailedexception;re-throw when onerror throws an exception. this fixes https://github.com/netflix/rxjava/issues/969;;0;onerrorfailedexception;re-throw when onerror throws an exceptionthis fixes https://githubcom/netflix/rxjava/issues/969;#923 ;;;;1;1;onerrorfailedexceptionre-throw when onerror throws an exceptionthis fixes https://githubcom/netflix/rxjava/issues/969;
999;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;new implementation of serializedobserver;rewrite of  serializedobserver  by @akarnokd discussed at   from this gist:  #### jmh benchmarks  0.17.3      benchmark                                                          (size)   mode   samples         mean   mean error    units r.operators.operatorserializeperf.noserializationsinglethreaded      1024   avgt         5       45.504        1.710    ns/op r.operators.operatorserializeperf.noserializationsinglethreaded   1048576   avgt         5       58.600        5.647    ns/op r.operators.operatorserializeperf.serializedsinglestream             1024   avgt         5       68.610        4.596    ns/op r.operators.operatorserializeperf.serializedsinglestream          1048576   avgt         5       71.313        2.318    ns/op r.operators.operatorserializeperf.synchronizedsinglestream           1024   avgt         5       73.322        3.666    ns/op r.operators.operatorserializeperf.synchronizedsinglestream        1048576   avgt         5       76.518        1.355    ns/op      0.17.2      benchmark                                                          (size)   mode   samples         mean   mean error    units r.operators.operatorserializeperf.noserializationsinglethreaded      1024   avgt         5       45.790        1.184    ns/op r.operators.operatorserializeperf.noserializationsinglethreaded   1048576   avgt         5       58.518        3.788    ns/op r.operators.operatorserializeperf.serializedsinglestream             1024   avgt         5       72.665        7.851    ns/op r.operators.operatorserializeperf.serializedsinglestream          1048576   avgt         5       74.788        2.946    ns/op r.operators.operatorserializeperf.synchronizedsinglestream           1024   avgt         5       73.661        3.499    ns/op r.operators.operatorserializeperf.synchronizedsinglestream        1048576   avgt         5       78.386        5.036    ns/op     #### manual benchmarks      java /**  * 0.17.3:  *  * run: 10 - 9 746 505 ops/sec  * run: 11 - 9 956 019 ops/sec  * run: 12 - 10 053 770 ops/sec  * run: 13 - 10 076 958 ops/sec  * run: 14 - 9 983 319 ops/sec  *  * 0.17.2:  *  * run: 10 - 9 851 999 ops/sec  * run: 11 - 9 726 975 ops/sec  * run: 12 - 9 719 762 ops/sec  * run: 13 - 9 668 141 ops/sec  * run: 14 - 9 799 700 ops/sec  *  * @param input  */ public void serializedsinglestream(input input) {     for (int i = 0  i < reps  i++) {         input.observable.serialize().subscribe(input.subscriber)      } };;0;new implementation of serializedobserver;rewrite of `serializedobserver` by @akarnokd discussed at   from this gist:  jmh benchmarks0173```benchmark                                                          (size)   mode   samples         mean   mean error    unitsroperatorsoperatorserializeperfnoserializationsinglethreaded      1024   avgt         5       45504        1710    ns/oproperatorsoperatorserializeperfnoserializationsinglethreaded   1048576   avgt         5       58600        5647    ns/oproperatorsoperatorserializeperfserializedsinglestream             1024   avgt         5       68610        4596    ns/oproperatorsoperatorserializeperfserializedsinglestream          1048576   avgt         5       71313        2318    ns/oproperatorsoperatorserializeperfsynchronizedsinglestream           1024   avgt         5       73322        3666    ns/oproperatorsoperatorserializeperfsynchronizedsinglestream        1048576   avgt         5       76518        1355    ns/op```0172```benchmark                                                          (size)   mode   samples         mean   mean error    unitsroperatorsoperatorserializeperfnoserializationsinglethreaded      1024   avgt         5       45790        1184    ns/oproperatorsoperatorserializeperfnoserializationsinglethreaded   1048576   avgt         5       58518        3788    ns/oproperatorsoperatorserializeperfserializedsinglestream             1024   avgt         5       72665        7851    ns/oproperatorsoperatorserializeperfserializedsinglestream          1048576   avgt         5       74788        2946    ns/oproperatorsoperatorserializeperfsynchronizedsinglestream           1024   avgt         5       73661        3499    ns/oproperatorsoperatorserializeperfsynchronizedsinglestream        1048576   avgt         5       78386        5036    ns/op```#### manual benchmarks``` java/** * 0173: * * run: 10 - 9746505 ops/sec * run: 11 - 9956019 ops/sec * run: 12 - 10053770 ops/sec * run: 13 - 10076958 ops/sec * run: 14 - 9983319 ops/sec * * 0172: * * run: 10 - 9851999 ops/sec * run: 11 - 9726975 ops/sec * run: 12 - 9719762 ops/sec * run: 13 - 9668141 ops/sec * run: 14 - 9799700 ops/sec * * @param input */public void serializedsinglestream(input input) {    for (int i  0 i < reps i++) {        inputobservableserialize()subscribe(inputsubscriber)    }}```;#932 #936;;;;1;1;fix unit test determinism;
1010;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;unsafesubscribe;migrate from reflection to unsafesubscribe as per discussion at   all operators are migrated to using  unsafesubscribe  instead of relying on their package to avoid  safesubscriber  wrapping.;;0;unsafesubscribe;migrate from reflection to unsafesubscribe as per discussion at  operators are migrated to using `unsafesubscribe` instead of relying on their package to avoid `safesubscriber` wrapping;with these changes im seeing non-deterministic failure of `operatorgroupbytestteststaggeredcompletion` its not yet clear why || #937 problem appears to be related to the `delay` operator:  || #938 the unit tests passed that were failing previously  build is timing out on quasar tests for some reason (though they work on our other build servers and locally) || #940];;;;1;1;fix blockingoperator subscribe behaviorthe blocking operators need to use subscribe not unsafesubscribe since they need the safesubscriber behavior in the final subscribe step they performrenamed operators to blockingoperator* for clarity and to match the operation->operator naming change;
1012;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;removed window between the two synchronized blocks.;in the original version  there was a window between finding a null queue and setting emitting false due to being in different synchronized block. if another thread came in this window  it created a new queue with its event which was not emitted until another onxxx method was called  causing unnecessary event delivery delay.  while running the tests  the  serializedobservertest.testnotificationdelay  failed from time to time due to thread timing. i haven t fixed this test.;;0;removed window between the two synchronized blocks;in the original version there was a window between finding a null queue and setting emitting false due to being in different synchronized block if another thread came in this window it created a new queue with its event which was not emitted until another onxxx method was called causing unnecessary event delivery delaywhile running the tests the `serializedobservertesttestnotificationdelay` failed from time to time due to thread timing i havent  this test;#939] strange contrib-quasar tests pass in timely manner on my local machine || thanks for this  benchmarks suggest no meaningful change  which is good as this should have been a change for a case not covered in these tests```benchmark                                                  (size)   mode   samples         mean   mean error    unitsrooperatorserializeperfnoserializationsinglethreaded      1024   avgt         5       45329        1851    ns/oprooperatorserializeperfnoserializationsinglethreaded   1048576   avgt         5       57587        3061    ns/oprooperatorserializeperfserializedsinglestream             1024   avgt         5       67744        2928    ns/oprooperatorserializeperfserializedsinglestream          1048576   avgt         5       73889        2139    ns/oprooperatorserializeperfsynchronizedsinglestream           1024   avgt         5       72970        3083    ns/oprooperatorserializeperfsynchronizedsinglestream        1048576   avgt         5       76640        1677    ns/op```compared with 0173```benchmark                                                          (size)   mode   samples         mean   mean error    unitsroperatorsoperatorserializeperfnoserializationsinglethreaded      1024   avgt         5       45504        1710    ns/oproperatorsoperatorserializeperfnoserializationsinglethreaded   1048576   avgt         5       58600        5647    ns/oproperatorsoperatorserializeperfserializedsinglestream             1024   avgt         5       68610        4596    ns/oproperatorsoperatorserializeperfserializedsinglestream          1048576   avgt         5       71313        2318    ns/oproperatorsoperatorserializeperfsynchronizedsinglestream           1024   avgt         5       73322        3666    ns/oproperatorsoperatorserializeperfsynchronizedsinglestream        1048576   avgt         5       76518        1355    ns/op``` ||;;;;1;1;removed window between the two synchronized blocks;
1015;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove redundant protectivelywrap method;;;0;remove redundant protectivelywrap method;;;;;;1;1;remove redundant protectivelywrap method;
1040;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;merge and cleanup of #972;@akarnokd i have manually merged your changes ( and migrated from  action1  to  action0  as we discussed.   can you review what i did on top of your changes to make sure it s correct. it seems correct to me but there is some nuanced concurrency here (obviously  hence your fixes) and i would appreciate your validation.;;0;merge and cleanup of #972;@akarnokd i have manually merged your changes ( and migrated from `action1` to `action0` as we discussed can you review what i did on top of your changes to make sure its correct it seems correct to me but there is some nuanced concurrency here (obviously hence your fixes) and i would appreciate your validation;#956  the changes look fine || great thanks for the review going to merge and releasei really appreciate your involvement on this one thank you ||;;;;1;1;remove redundant action1 observer collection argumentsince the collection is being returned we dont want to also inject it as an argument so i migrated to action0 from action1 as per discussion at https://githubcom/netflix/rxjava/pull/972#issuecomment-38189145;
1047;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;scheduler simplification;api redesign (simplification) as per discussion at   the  scheduler  api in this pull request is:      java class scheduler {     public abstract inner inner()       public int degreeofparallelism()      public long now()       public abstract static class inner implements subscription {         public abstract subscription schedule(action0 action  long delaytime  timeunit unit)          public abstract subscription schedule(action0 action)          public final void scheduleperiodically(action0 action  long initialdelay  long period  timeunit unit)          public long now()      } }      while migrating to this i found a 4th use case in addition to the previously discussed 3 that required the  schedule  methods inside  inner  to also return  subscription  for canceling the individual tasks as opposed to the entire  inner .  here are the use cases: #### 1) single action      java final inner is = scheduler.inner()  is.schedule(new action0() {      @override     public void call() {         // do work here     } })  is.unsubscribe()      with lambda      java final inner is = scheduler.inner)  is.schedule(() -> {         // do work here })  is.unsubscribe()     #### 2) inner recursion      java final inner is = scheduler.inner()  is.schedule(new action0() {      @override     public void call() {         // do work here then recursively reschedule     is.schedule(this)  // this will not work with lambdas  only anonymous inner classes     } })  is.unsubscribe()     #### 3) outer recursion      java final inner is = scheduler.inner()   public void onnext(t t) {     is.schedule(new action0() {          @override         public void call() {             // do work here         }     }) }  is.unsubscribe()     #### 4) outer recursion with task cancellation  this is used for things like  debounce  and  throttlelast  where tasks are being scheduled and cancelled as  onnext  notifications are received.      java final inner is = scheduler.inner()  serialsubscription serial = new serialsubscription()   public void onnext(t t) {     // schedule a new task and cancel previous if not yet executed     serial.set(is.schedule(new action0() {          @override         public void call() {             // do work here         }     }))  }  is.unsubscribe();;0;scheduler simplification;api redesign (simplification) as per discussion at  `scheduler` api in this pull request is:``` javaclass scheduler {    public abstract inner inner()     public int degreeofparallelism()    public long now()    public abstract static class inner implements subscription {        public abstract subscription schedule(action0 action long delaytime timeunit unit)        public abstract subscription schedule(action0 action)        public final void scheduleperiodically(action0 action long initialdelay long period timeunit unit)        public long now()    }}```while migrating to this i found a 4th use case in addition to the previously discussed 3 that required the `schedule` methods inside `inner` to also return `subscription` for canceling the individual tasks as opposed to the entire `inner`here are the use cases:#### 1) single action``` javafinal inner is  schedulerinner()isschedule(new action0() {    @override    public void call() {        // do work here    }})isunsubscribe()```with lambda``` javafinal inner is  schedulerinner)isschedule(() -> {        // do work here})isunsubscribe()```#### 2) inner recursion``` javafinal inner is  schedulerinner()isschedule(new action0() {    @override    public void call() {        // do work here then recursively reschedule    isschedule(this) // this will not work with lambdas only anonymous inner classes    }})isunsubscribe()```#### 3) outer recursion``` javafinal inner is  schedulerinner()public void onnext(t t) {    isschedule(new action0() {        @override        public void call() {            // do work here        }    })}isunsubscribe()```#### 4) outer recursion with task cancellationthis is used for things like `debounce` and `throttlelast` where tasks are being scheduled and cancelled as `onnext` notifications are received``` javafinal inner is  schedulerinner()serialsubscription serial  new serialsubscription()public void onnext(t t) {    // schedule a new task and cancel previous if not yet executed    serialset(isschedule(new action0() {        @override        public void call() {            // do work here        }    }))}isunsubscribe()```;#962  in executorscheduler the innersubscription is replaced if schedule is called multiple times for example with different delay values unsubscribing the inner cancels only the latest schedule is this intentional? || no its not intentional thanks for seeing that the `executorscheduler` really needs to be completely deleted though it breaks the contract by allowing concurrent execution i know of no good way to make it work without building event loops on top of the thread pools which defeats the purposeim leaning heavily towards deleting `executorscheduler` completely see  and  will replace the `computation()` scheduler with a pool of event loops || merging this  dont want to conflate this pr with the one where i eliminate executorscheduler ||;;;;1;1;degreeofparallelism() -> parallelism()https://githubcom/netflix/rxjava/issues/997#issuecomment-40819656;
1048;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;remove executorscheduler - new computationscheduler;removing  executorscheduler  as it does not comply with the contract of sequential execution. a scheduler needs to guarantee sequential execution  but putting work on a multi-threaded thread pool allows concurrent execution.   see  and https://github.com/netflix/rxjava/issues/713;;0;remove executorscheduler - new computationscheduler;removing `executorscheduler` as it does not comply with the contract of sequential execution a scheduler needs to guarantee sequential execution but putting work on a multi-threaded thread pool allows concurrent execution see  and https://githubcom/netflix/rxjava/issues/713;#964 ;;;;1;1;remove executorscheduler - new computationscheduler- see  and https://githubcom/netflix/rxjava/issues/713;
1049;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;move rx.joins to rxjava-joins module;migrating rx.joins into a separate contrib module as part of roadmap to 1.0:  this is being done until the rx.joins api has further time to mature as it is likely to change and we can t make breaking changes any further once we hit 1.0.;;0;move rxjoins to rxjava-joins module;migrating rxjoins into a separate contrib module as part of roadmap to 10:  is being done until the rxjoins api has further time to mature as it is likely to change and we cant make breaking changes any further once we hit 10;#965]( failurelooks like theres a problem with this pull request---non-deterministic test: rxoperatorsoperatorpivottesttestconcurrencyandserialization ||;;;;1;1;move rxjoins to rxjava-joins modulemigrating rxjoins into a separate contrib module as part of roadmap to 10:  is being done until the rxjoins api has further time to mature as it is likely to change and we cant make breaking changes any further once we hit 10;
1051;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;manual merge #967;manually merge #967;;0;manual merge #967;manually merge #967;;;;;1;1;merge branch single of git://githubcom/zsxwing/rxjava into merge-967conflicts:	rxjava-core/src/main/java/rx/observablejava	rxjava-core/src/main/java/rx/operators/operationsinglejava	rxjava-core/src/test/java/rx/operators/operatorlasttestjava;
1052;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;scheduler cleanup;computationscheduler -> eventloopsscheduler restoring parallel() to using schedulers.computation();;0;scheduler cleanup;computationscheduler -> eventloopsschedulerrestoring parallel() to using schedulerscomputation();;;;;1;1;restoring parallel() to using schedulerscomputation()see  for background on this;
1053;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;deprecation cleanup;the time has come to delete the deprecated methods/classes.  a few still remain to be done before 1.0 but can t be done until all operators are migrated: -  observable.onsubscribefunc  -  observable.create(onsubscribefunc)  -  safeobservablesubscription  -  safeobserver;;0;deprecation cleanup;the time has come to delete the deprecated methods/classesa few still remain to be done before 10 but cant be done until all operators are migrated:- `observableonsubscribefunc`- `observablecreate(onsubscribefunc)`- `safeobservablesubscription`- `safeobserver`;note that i removed the deprecation marker on the `from` and `merge` methods and left them as is based on  || #970 ;;;;1;1;remove deprecated methods/classes from rxjava-corecleanup on path to 10: https://githubcom/netflix/rxjava/issues/1001#issuecomment-40888251;
"1056;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add drop(skip) and dropright(skiplast) to rxscala;;;0;add drop(skip) and dropright(skiplast) to rxscala;;""#972  please no dropright! this api is so incompatible with reactive model that id relay it to the user to subscribe and aggregate what he wants rather than promoting this api to observable just my 2c though || @vigdorchik what is your reason for this? rx has had this operator for a very long time (called `skiplast`) it is indeed not useful for infinite streams but there are several operators like that including `concat` and `reduce` that are useful when they fit the use case but useless when its an infinite stream not all operators are meant for all use cases even the `zip` operator can be very problematic if misused (combining slow and fast streams for example) || ah ok my usecase was indeed infinite streams and i wasnt prepared for finite caseif i were designing the api now i would suggest future instead of observable for finite case delegating to map on lists but its again just me :) || >  future instead of observable for finite casethat is not as simple as you think which future to use? and also futures are hot so this can subtely change the order of side effects in other words `xsdosomeoperationthatreturnsasingleelement()` should not start processing unless you subscribe to it or if xs is already hot || this discussion comes up every so often about letting the type communicate things like finite vs infinite and scalar vs vector it was discussed to some degree here:  rxnet they have `task` and `observable` which work well together on the jvm there are many different `future` implementations some great some not the `javautilconcurrentfuture` is not usable so we would either have to create yet another future-like type that works with `observable` (can combine them etc) or choose an implementation and make rxjava dependent on it (not desirable)beyond this comes the more nuanced arguments of whether a scalar response (which ultimately encompasses - or could encompass - finite streams that are aggregated down to a single response) should be typed differently you can read the link above to see more on that and the compositional challenges it causes (types get lost quickly when composing) || @headinthebox i see futures dont capture subscription so its not future but is it a full-blown observable?@benjchristensen yes we could extract something make it composable and not call it future :)ill read the discussion to see what complications it causessorry guys for bringing up the old topic i should have read the discussions first || not a problem for bringing it up  its an interesting one and one that doesnt have a clear answer if you want to discuss it further either revive the mailing list thread or start a new github issue || +1 || is it true that skiplast() will cache """"all items"""" until oncompleted (as thenew addition to the javadoc comments states)?it seems that it shouldnt have to do such extensive cacheing  forskiplast(n) it should only need to cache n items for skiplast(t) onlythose items that have arrived during that time windowon mon apr 21 2014 at 10:25 am headinthebox notifications@githubcomwrote:> +1> > > reply to this email directly or view it on github ## david m grossplp consulting || ive been thinking about the timed skiplast and it could emit old enough elements in onnext and thus freeing up the internal buffer || @akarnokd yes i think we only need to cache the items in the specified time window || please help review the new implementation #1065 || "";;;;1;1;add drop and dropright to rxscala;"
1061;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatorall;reimplemented  all .  issue #1060;;0;operatorall;reimplemented `all`issue #1060;#977 ;;;;1;1;operatorall;
1062;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatorany;reimplemented  any   aka  isempty  and  exists .  issue #1060;;0;operatorany;reimplemented `any` aka `isempty` and `exists`issue #1060;#978 ;;;;1;1;operatorany;
1065;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;optimize operatorskiplasttimed;changed operatorskiplasttimed to only cache the latest items in the specified time window.;;0;optimize operatorskiplasttimed;changed operatorskiplasttimed to only cache the latest items in the specified time window;#981 ;;;;1;1;only cache the latest items in the time window;
1066;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;compositesubscription fix;a bug in the remove() method caused arrayindexoutofboundsexception if the composite is not empty and trying to remove a subscription that is not in the composite at all.;;0;compositesubscription fix;a bug in the remove() method caused arrayindexoutofboundsexception if the composite is not empty and trying to remove a subscription that is not in the composite at all;#982 ;;;;1;1;compositesubscription fix;
1071;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;manual merge of asobservable;;;0;manual merge of asobservable;;#985 ;;;;1;1;merge branch operatorasobservable of githubcom:akarnokd/rxjava into merge-asobservableconflicts:	rxjava-core/src/main/java/rx/observablejava;
1072;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;scheduler.inner -> scheduler.worker;as per decision at https://github.com/netflix/rxjava/issues/997#issuecomment-40998613;;0;schedulerinner -> schedulerworker;as per decision at https://githubcom/netflix/rxjava/issues/997#issuecomment-40998613;;;;;1;1;schedulerinner -> schedulerworkeras per decision at https://githubcom/netflix/rxjava/issues/997#issuecomment-40998613;
"1073;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatorbuffer;operator buffer  split into 4 variants.  issue #1060.  there are some important behavioral changes compared to the original versions: - when an onerror event appears from anywhere  the currently accumulated chunk(s) are _not_ emitted before the error is propagated. this conforms with rx design guideline 6.6. - the observable returned by the func0 inside the  buffer(func0<observable<b>>)  now is used as long as possible and whenever it fires an event  a new buffer chunk is started. the func0 is called only once per subscriber. the original called it and subscribed to it all the time  causing all-increasing resubscriptions.;;1060.0;operatorbuffer;operator buffer split into 4 variantsissue #1060there are some important behavioral changes compared to the original versions:- when an onerror event appears from anywhere the currently accumulated chunk(s) are _not_ emitted before the error is propagated this conforms with rx design guideline 66- the observable returned by the func0 inside the `buffer(func0<observable<b>>)` now is used as long as possible and whenever it fires an event a new buffer chunk is started the func0 is called only once per subscriber the original called it and subscribed to it all the time causing all-increasing resubscriptions;#986 ;operations to rewrite;core:-  `all` (w/ lift) pr #1061 - _merged_-  `any` (w/ lift) pr #1062 - _merged_  - `exist` and `isempty` are built upon `any`-  `asobservable` (w/ ~~onsubscribe~~ lift) pr #1064 - _merged_-  `buffer` (w/ lift) pr #1073 - _merged_  - size time window skip observable boundary observable start-end-  `combinelatest` (w/ onsubscribe) pr #1079 - _merged_-  `concat` (w/ ~~onsubscribe~~ lift) pr #1074 - _merged_-  `debounce` (w/ lift) pr #1094  - time window another observable-  `defaultifempty` (w/ lift) pr #1080 - _merged_-  `defer` (w/ onsubscribe) pr #1081 - _merged_-  `delay` (w/ ~~lift~~ keep as is) ~~pr #1093~~ pr #1144  - `delaysubscribe` (w/ onsubscribe)  - `delayviaobservable` (w/ onsubscribe)- [x] `dematerialize` (w/ lift) pr #1083 - _merged_- [x] `distinct` (w/ lift) pr #1084 - _merged_  - regular ~~custom equality comparator~~- [x] `distinctuntilchanged` (w/ lift) pr #1085 - _merged_- [x] `finallydo` (w/ lift) pr #1086 - _merged_- [x] `flatmap` (w/ lift) -> rename to `mergemap` pr #1087 - _merged_  - ~~regular~~ with iterator as sub-collection (`mergemapiterable`)- [x] `groupbyuntil` (w/ lift) pr #1095- [x] `groupjoin` (w/ onsubscribe) pr #1096- [x] `interval` replace with `timer` pr #1098- [x] `join` (w/ onsubscribe) pr #1103- [x] `mergedelayerror` (w/ lift) pr #1104- [x] `mergemaxconcurrent`(w/ lift) pr #1106- [x] `multicast` (w/ onsubscribe) pr #1108  - regular factory+selector- [x] `onerrorresumenextviaobservable` (w/ lift) pr #1109- [x] `onerrorreturn`(w/ lift) pr #1110- [x] `onexceptionresumenextviaobservable` (w/ lift) pr #1117- [x] `parallelmerge` -> just rename pr #1118- [x] `refcount` (w/ onsubscribe) pr #1119- [x] `replay` (w/ onsubscribe) pr #1108- [x] `sample` (w/ lift)  pr #1098  - time (state-sharing bug!) another observable- [x] `sequenceequals` -> just rename pr #1120- [x] `skip` (w/ lift) into `operatorskiptimed` pr #1121- [x] `skipuntil` (w/ lift) pr #1122- [x] `switch` (w/ lift) pr #1130- [x] `take` (w/ lift) pr #1131  - count: already present time- [x] `takelast` (w/ lift) pr #1134  - count time- [x] `takeuntil` (w/ lift) pr #1135- [x] `takewhile` (w/ lift) remove indexed variant? pr #1115- [x] `throttlefirst` (w/ lift) pr #1112- [x] `timeinterval` (w/ lift) pr #1111- [x] `timer` (w/ onsubscribe)  pr #1098- [x] `tomap` (w/ onsubscribe) pr #1099- [x] `tomultimap` (w/ onsubscribe) pr #1097- [x] `toobservablefuture` (w/ onsubscribe) pr #1088 - _merged_- [x] `using` (w/ onsubscribe) pr #1100- [x] `window` (w/ lift) pr ~~#1123~~ pr #1138  - size time window skip observable boundary observable start-endcontrib-string- [x] optionally: refactor operators into separate classes no changescontrib-async-util pr #1101- [x] `startfuture` -> just rename- [x] `operationfromfunctionalsinvokeasync` (w/ onsubscribe)- [x] `foreachfuture` -> just rename- [x] `deferfuture` -> just renamecontrib-math pr #1125- [x] `average` (w/ lift) ~~may keep current op-composition~~  - int long float double w/ extractor function- [x] `min` `minby` `max` `maxby` ~~(w/ lift)~~ may keep current op-composition- [x] `sum` ~~(w/ lift)~~ may keep current op-compositioncontrib-computation-expressions pr #1129- [x] `ifthen` (w/ onsubscribe)- [x] `switchcase` (w/ onsubscribe)- [x] `dowhile` `whiledo` (w/ onsubscribe)contrib-joins- [x] `when` (w/ onsubscribe) pr #1126;""im working on buffer but still have to hunt down some test failures || do we expect any of the following proposed operators to be revived?- chunkify- defercancellablefuture (rxjava-async)- dowhile- foreachfuture (blockingobservable)- foriterable- fromcancellablefuture (rxjava-async)- fromfuture- generate- generateabsolutetime- ifthen- startcancellablefuture (rxjava-async)- switchcase- whiledoon tue apr 22 2014 at 7:50 am akarnokd notifications@githubcom wrote:> im working on buffer but still have to hunt down some test failures> > > reply to this email directly or view it on github ## david m grossplp consulting || ifthen switchcase dowhile whiledo are in contrib-computation-expressionsim not sure about the cancelablefuture variants as they conceptionally didnt really work in java (ie attempt to mirror c# cancellation tokens)chunkify generate generateabsolutetime foriterable - probably notwhile we are at it i have some trouble with `buffer(func0<observable>)` variant i would expect the returned observable to supply multiple """"absolute"""" boundary events but the current implementation calls for a new observable whenever a previous one fired an event causing an exponential explosion [chunkedoperation l515]( the reason seems to be to produce a relative windowing in the associated [test method]( || before we proceed please review what i wrote at  and lets agree upon the coding principles || > do we expect any of the following proposed operators to be revived?i doubt it lets get the current operators (as of 018) polished for 10 new operators or matured ones from the contrib modules can come over in 1x releases if found to be commonly neededthe only one not on the list i can think of needing to re-add is the `groupby` overload that takes a selector it was unceremoniously dropped a few releases ago when i did refactoring || i skipped `combinelatest` as there was pr #1043 not long ago i wonder if @vigdorchik still wants to implement it || @akarnokd sorry im out of context here || @zsxwing ill do window || all done and  "";1;0;operatorbuffer;"
"1079;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatorcombinelatest;operator combinelatest  issue #1060  remarks: - added an overload to observable which accepts any number of sources. not sure why it wasn t exposed before? perhaps removed? - relying on just the so s onnext is not enough as leaving the synchronized block allows reordering of onnext calls. therefore  the combinator uses the trick from serializedobserver to make sure the combination order is consistent with whe winning of the synchronization  race .;;1060.0;operatorcombinelatest;""operator combinelatestissue #1060remarks:- added an overload to observable which accepts any number of sources not sure why it wasnt exposed before? perhaps removed?- relying on just the sos onnext is not enough as leaving the synchronized block allows reordering of onnext calls therefore the combinator uses the trick from serializedobserver to make sure the combination order is consistent with whe winning of the synchronization """"race"""" "";#990 ;operations to rewrite;core:-  `all` (w/ lift) pr #1061 - _merged_-  `any` (w/ lift) pr #1062 - _merged_  - `exist` and `isempty` are built upon `any`-  `asobservable` (w/ ~~onsubscribe~~ lift) pr #1064 - _merged_-  `buffer` (w/ lift) pr #1073 - _merged_  - size time window skip observable boundary observable start-end-  `combinelatest` (w/ onsubscribe) pr #1079 - _merged_-  `concat` (w/ ~~onsubscribe~~ lift) pr #1074 - _merged_-  `debounce` (w/ lift) pr #1094  - time window another observable-  `defaultifempty` (w/ lift) pr #1080 - _merged_-  `defer` (w/ onsubscribe) pr #1081 - _merged_-  `delay` (w/ ~~lift~~ keep as is) ~~pr #1093~~ pr #1144  - `delaysubscribe` (w/ onsubscribe)  - `delayviaobservable` (w/ onsubscribe)- [x] `dematerialize` (w/ lift) pr #1083 - _merged_- [x] `distinct` (w/ lift) pr #1084 - _merged_  - regular ~~custom equality comparator~~- [x] `distinctuntilchanged` (w/ lift) pr #1085 - _merged_- [x] `finallydo` (w/ lift) pr #1086 - _merged_- [x] `flatmap` (w/ lift) -> rename to `mergemap` pr #1087 - _merged_  - ~~regular~~ with iterator as sub-collection (`mergemapiterable`)- [x] `groupbyuntil` (w/ lift) pr #1095- [x] `groupjoin` (w/ onsubscribe) pr #1096- [x] `interval` replace with `timer` pr #1098- [x] `join` (w/ onsubscribe) pr #1103- [x] `mergedelayerror` (w/ lift) pr #1104- [x] `mergemaxconcurrent`(w/ lift) pr #1106- [x] `multicast` (w/ onsubscribe) pr #1108  - regular factory+selector- [x] `onerrorresumenextviaobservable` (w/ lift) pr #1109- [x] `onerrorreturn`(w/ lift) pr #1110- [x] `onexceptionresumenextviaobservable` (w/ lift) pr #1117- [x] `parallelmerge` -> just rename pr #1118- [x] `refcount` (w/ onsubscribe) pr #1119- [x] `replay` (w/ onsubscribe) pr #1108- [x] `sample` (w/ lift)  pr #1098  - time (state-sharing bug!) another observable- [x] `sequenceequals` -> just rename pr #1120- [x] `skip` (w/ lift) into `operatorskiptimed` pr #1121- [x] `skipuntil` (w/ lift) pr #1122- [x] `switch` (w/ lift) pr #1130- [x] `take` (w/ lift) pr #1131  - count: already present time- [x] `takelast` (w/ lift) pr #1134  - count time- [x] `takeuntil` (w/ lift) pr #1135- [x] `takewhile` (w/ lift) remove indexed variant? pr #1115- [x] `throttlefirst` (w/ lift) pr #1112- [x] `timeinterval` (w/ lift) pr #1111- [x] `timer` (w/ onsubscribe)  pr #1098- [x] `tomap` (w/ onsubscribe) pr #1099- [x] `tomultimap` (w/ onsubscribe) pr #1097- [x] `toobservablefuture` (w/ onsubscribe) pr #1088 - _merged_- [x] `using` (w/ onsubscribe) pr #1100- [x] `window` (w/ lift) pr ~~#1123~~ pr #1138  - size time window skip observable boundary observable start-endcontrib-string- [x] optionally: refactor operators into separate classes no changescontrib-async-util pr #1101- [x] `startfuture` -> just rename- [x] `operationfromfunctionalsinvokeasync` (w/ onsubscribe)- [x] `foreachfuture` -> just rename- [x] `deferfuture` -> just renamecontrib-math pr #1125- [x] `average` (w/ lift) ~~may keep current op-composition~~  - int long float double w/ extractor function- [x] `min` `minby` `max` `maxby` ~~(w/ lift)~~ may keep current op-composition- [x] `sum` ~~(w/ lift)~~ may keep current op-compositioncontrib-computation-expressions pr #1129- [x] `ifthen` (w/ onsubscribe)- [x] `switchcase` (w/ onsubscribe)- [x] `dowhile` `whiledo` (w/ onsubscribe)contrib-joins- [x] `when` (w/ onsubscribe) pr #1126;""im working on buffer but still have to hunt down some test failures || do we expect any of the following proposed operators to be revived?- chunkify- defercancellablefuture (rxjava-async)- dowhile- foreachfuture (blockingobservable)- foriterable- fromcancellablefuture (rxjava-async)- fromfuture- generate- generateabsolutetime- ifthen- startcancellablefuture (rxjava-async)- switchcase- whiledoon tue apr 22 2014 at 7:50 am akarnokd notifications@githubcom wrote:> im working on buffer but still have to hunt down some test failures> > > reply to this email directly or view it on github ## david m grossplp consulting || ifthen switchcase dowhile whiledo are in contrib-computation-expressionsim not sure about the cancelablefuture variants as they conceptionally didnt really work in java (ie attempt to mirror c# cancellation tokens)chunkify generate generateabsolutetime foriterable - probably notwhile we are at it i have some trouble with `buffer(func0<observable>)` variant i would expect the returned observable to supply multiple """"absolute"""" boundary events but the current implementation calls for a new observable whenever a previous one fired an event causing an exponential explosion [chunkedoperation l515]( the reason seems to be to produce a relative windowing in the associated [test method]( || before we proceed please review what i wrote at  and lets agree upon the coding principles || > do we expect any of the following proposed operators to be revived?i doubt it lets get the current operators (as of 018) polished for 10 new operators or matured ones from the contrib modules can come over in 1x releases if found to be commonly neededthe only one not on the list i can think of needing to re-add is the `groupby` overload that takes a selector it was unceremoniously dropped a few releases ago when i did refactoring || i skipped `combinelatest` as there was pr #1043 not long ago i wonder if @vigdorchik still wants to implement it || @akarnokd sorry im out of context here || @zsxwing ill do window || all done and  "";1;0;operatorcombinelatest;"
1080;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatordefaultifempty;operator defaultifempty  issue #1060;;0;operatordefaultifempty;operator defaultifemptyissue #1060;#991 the failures are unrelated i think but havent commented on it here or the other cases ||;;;;1;1;operatordefaultifempty;
1081;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatordefer;operator defer  issue #1060;;0;operatordefer;operator deferissue #1060;#992 ;;;;1;1;operatordefer;
"1083;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatordematerialize;operator dematerialize  issue #1060  two notes: - since the dematerialize() is an instance method  there is no correct type parametrization for the operator. therefore  i just used a raw version in the call. - the original dematerialize could send out two oncompleted or an onerror followed by an oncompleted because the materialize() always adds an oncompleted after the raw events. this affected operators due to unsafesubscribe. this new version ensures this doesn t happen.;;1060.0;operatordematerialize;operator dematerializeissue #1060two notes:- since the dematerialize() is an instance method there is no correct type parametrization for the operator therefore i just used a raw version in the call- the original dematerialize could send out two oncompleted or an onerror followed by an oncompleted because the materialize() always adds an oncompleted after the raw events this affected operators due to unsafesubscribe this new version ensures this doesnt happen;#994 ;operations to rewrite;core:-  `all` (w/ lift) pr #1061 - _merged_-  `any` (w/ lift) pr #1062 - _merged_  - `exist` and `isempty` are built upon `any`-  `asobservable` (w/ ~~onsubscribe~~ lift) pr #1064 - _merged_-  `buffer` (w/ lift) pr #1073 - _merged_  - size time window skip observable boundary observable start-end-  `combinelatest` (w/ onsubscribe) pr #1079 - _merged_-  `concat` (w/ ~~onsubscribe~~ lift) pr #1074 - _merged_-  `debounce` (w/ lift) pr #1094  - time window another observable-  `defaultifempty` (w/ lift) pr #1080 - _merged_-  `defer` (w/ onsubscribe) pr #1081 - _merged_-  `delay` (w/ ~~lift~~ keep as is) ~~pr #1093~~ pr #1144  - `delaysubscribe` (w/ onsubscribe)  - `delayviaobservable` (w/ onsubscribe)- [x] `dematerialize` (w/ lift) pr #1083 - _merged_- [x] `distinct` (w/ lift) pr #1084 - _merged_  - regular ~~custom equality comparator~~- [x] `distinctuntilchanged` (w/ lift) pr #1085 - _merged_- [x] `finallydo` (w/ lift) pr #1086 - _merged_- [x] `flatmap` (w/ lift) -> rename to `mergemap` pr #1087 - _merged_  - ~~regular~~ with iterator as sub-collection (`mergemapiterable`)- [x] `groupbyuntil` (w/ lift) pr #1095- [x] `groupjoin` (w/ onsubscribe) pr #1096- [x] `interval` replace with `timer` pr #1098- [x] `join` (w/ onsubscribe) pr #1103- [x] `mergedelayerror` (w/ lift) pr #1104- [x] `mergemaxconcurrent`(w/ lift) pr #1106- [x] `multicast` (w/ onsubscribe) pr #1108  - regular factory+selector- [x] `onerrorresumenextviaobservable` (w/ lift) pr #1109- [x] `onerrorreturn`(w/ lift) pr #1110- [x] `onexceptionresumenextviaobservable` (w/ lift) pr #1117- [x] `parallelmerge` -> just rename pr #1118- [x] `refcount` (w/ onsubscribe) pr #1119- [x] `replay` (w/ onsubscribe) pr #1108- [x] `sample` (w/ lift)  pr #1098  - time (state-sharing bug!) another observable- [x] `sequenceequals` -> just rename pr #1120- [x] `skip` (w/ lift) into `operatorskiptimed` pr #1121- [x] `skipuntil` (w/ lift) pr #1122- [x] `switch` (w/ lift) pr #1130- [x] `take` (w/ lift) pr #1131  - count: already present time- [x] `takelast` (w/ lift) pr #1134  - count time- [x] `takeuntil` (w/ lift) pr #1135- [x] `takewhile` (w/ lift) remove indexed variant? pr #1115- [x] `throttlefirst` (w/ lift) pr #1112- [x] `timeinterval` (w/ lift) pr #1111- [x] `timer` (w/ onsubscribe)  pr #1098- [x] `tomap` (w/ onsubscribe) pr #1099- [x] `tomultimap` (w/ onsubscribe) pr #1097- [x] `toobservablefuture` (w/ onsubscribe) pr #1088 - _merged_- [x] `using` (w/ onsubscribe) pr #1100- [x] `window` (w/ lift) pr ~~#1123~~ pr #1138  - size time window skip observable boundary observable start-endcontrib-string- [x] optionally: refactor operators into separate classes no changescontrib-async-util pr #1101- [x] `startfuture` -> just rename- [x] `operationfromfunctionalsinvokeasync` (w/ onsubscribe)- [x] `foreachfuture` -> just rename- [x] `deferfuture` -> just renamecontrib-math pr #1125- [x] `average` (w/ lift) ~~may keep current op-composition~~  - int long float double w/ extractor function- [x] `min` `minby` `max` `maxby` ~~(w/ lift)~~ may keep current op-composition- [x] `sum` ~~(w/ lift)~~ may keep current op-compositioncontrib-computation-expressions pr #1129- [x] `ifthen` (w/ onsubscribe)- [x] `switchcase` (w/ onsubscribe)- [x] `dowhile` `whiledo` (w/ onsubscribe)contrib-joins- [x] `when` (w/ onsubscribe) pr #1126;""im working on buffer but still have to hunt down some test failures || do we expect any of the following proposed operators to be revived?- chunkify- defercancellablefuture (rxjava-async)- dowhile- foreachfuture (blockingobservable)- foriterable- fromcancellablefuture (rxjava-async)- fromfuture- generate- generateabsolutetime- ifthen- startcancellablefuture (rxjava-async)- switchcase- whiledoon tue apr 22 2014 at 7:50 am akarnokd notifications@githubcom wrote:> im working on buffer but still have to hunt down some test failures> > > reply to this email directly or view it on github ## david m grossplp consulting || ifthen switchcase dowhile whiledo are in contrib-computation-expressionsim not sure about the cancelablefuture variants as they conceptionally didnt really work in java (ie attempt to mirror c# cancellation tokens)chunkify generate generateabsolutetime foriterable - probably notwhile we are at it i have some trouble with `buffer(func0<observable>)` variant i would expect the returned observable to supply multiple """"absolute"""" boundary events but the current implementation calls for a new observable whenever a previous one fired an event causing an exponential explosion [chunkedoperation l515]( the reason seems to be to produce a relative windowing in the associated [test method]( || before we proceed please review what i wrote at  and lets agree upon the coding principles || > do we expect any of the following proposed operators to be revived?i doubt it lets get the current operators (as of 018) polished for 10 new operators or matured ones from the contrib modules can come over in 1x releases if found to be commonly neededthe only one not on the list i can think of needing to re-add is the `groupby` overload that takes a selector it was unceremoniously dropped a few releases ago when i did refactoring || i skipped `combinelatest` as there was pr #1043 not long ago i wonder if @vigdorchik still wants to implement it || @akarnokd sorry im out of context here || @zsxwing ill do window || all done and  "";1;0;operatordematerialize;"
"1084;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatordistinct;operator distinct  issue #1060  i didn t port the variant with the custom key comparator because it has been decided to rely on  object.equals  and there were not exposed anyway.;;1060.0;operatordistinct;operator distinctissue #1060i didnt port the variant with the custom key comparator because it has been decided to rely on `objectequals` and there were not exposed anyway;#995 ;operations to rewrite;core:-  `all` (w/ lift) pr #1061 - _merged_-  `any` (w/ lift) pr #1062 - _merged_  - `exist` and `isempty` are built upon `any`-  `asobservable` (w/ ~~onsubscribe~~ lift) pr #1064 - _merged_-  `buffer` (w/ lift) pr #1073 - _merged_  - size time window skip observable boundary observable start-end-  `combinelatest` (w/ onsubscribe) pr #1079 - _merged_-  `concat` (w/ ~~onsubscribe~~ lift) pr #1074 - _merged_-  `debounce` (w/ lift) pr #1094  - time window another observable-  `defaultifempty` (w/ lift) pr #1080 - _merged_-  `defer` (w/ onsubscribe) pr #1081 - _merged_-  `delay` (w/ ~~lift~~ keep as is) ~~pr #1093~~ pr #1144  - `delaysubscribe` (w/ onsubscribe)  - `delayviaobservable` (w/ onsubscribe)- [x] `dematerialize` (w/ lift) pr #1083 - _merged_- [x] `distinct` (w/ lift) pr #1084 - _merged_  - regular ~~custom equality comparator~~- [x] `distinctuntilchanged` (w/ lift) pr #1085 - _merged_- [x] `finallydo` (w/ lift) pr #1086 - _merged_- [x] `flatmap` (w/ lift) -> rename to `mergemap` pr #1087 - _merged_  - ~~regular~~ with iterator as sub-collection (`mergemapiterable`)- [x] `groupbyuntil` (w/ lift) pr #1095- [x] `groupjoin` (w/ onsubscribe) pr #1096- [x] `interval` replace with `timer` pr #1098- [x] `join` (w/ onsubscribe) pr #1103- [x] `mergedelayerror` (w/ lift) pr #1104- [x] `mergemaxconcurrent`(w/ lift) pr #1106- [x] `multicast` (w/ onsubscribe) pr #1108  - regular factory+selector- [x] `onerrorresumenextviaobservable` (w/ lift) pr #1109- [x] `onerrorreturn`(w/ lift) pr #1110- [x] `onexceptionresumenextviaobservable` (w/ lift) pr #1117- [x] `parallelmerge` -> just rename pr #1118- [x] `refcount` (w/ onsubscribe) pr #1119- [x] `replay` (w/ onsubscribe) pr #1108- [x] `sample` (w/ lift)  pr #1098  - time (state-sharing bug!) another observable- [x] `sequenceequals` -> just rename pr #1120- [x] `skip` (w/ lift) into `operatorskiptimed` pr #1121- [x] `skipuntil` (w/ lift) pr #1122- [x] `switch` (w/ lift) pr #1130- [x] `take` (w/ lift) pr #1131  - count: already present time- [x] `takelast` (w/ lift) pr #1134  - count time- [x] `takeuntil` (w/ lift) pr #1135- [x] `takewhile` (w/ lift) remove indexed variant? pr #1115- [x] `throttlefirst` (w/ lift) pr #1112- [x] `timeinterval` (w/ lift) pr #1111- [x] `timer` (w/ onsubscribe)  pr #1098- [x] `tomap` (w/ onsubscribe) pr #1099- [x] `tomultimap` (w/ onsubscribe) pr #1097- [x] `toobservablefuture` (w/ onsubscribe) pr #1088 - _merged_- [x] `using` (w/ onsubscribe) pr #1100- [x] `window` (w/ lift) pr ~~#1123~~ pr #1138  - size time window skip observable boundary observable start-endcontrib-string- [x] optionally: refactor operators into separate classes no changescontrib-async-util pr #1101- [x] `startfuture` -> just rename- [x] `operationfromfunctionalsinvokeasync` (w/ onsubscribe)- [x] `foreachfuture` -> just rename- [x] `deferfuture` -> just renamecontrib-math pr #1125- [x] `average` (w/ lift) ~~may keep current op-composition~~  - int long float double w/ extractor function- [x] `min` `minby` `max` `maxby` ~~(w/ lift)~~ may keep current op-composition- [x] `sum` ~~(w/ lift)~~ may keep current op-compositioncontrib-computation-expressions pr #1129- [x] `ifthen` (w/ onsubscribe)- [x] `switchcase` (w/ onsubscribe)- [x] `dowhile` `whiledo` (w/ onsubscribe)contrib-joins- [x] `when` (w/ onsubscribe) pr #1126;""im working on buffer but still have to hunt down some test failures || do we expect any of the following proposed operators to be revived?- chunkify- defercancellablefuture (rxjava-async)- dowhile- foreachfuture (blockingobservable)- foriterable- fromcancellablefuture (rxjava-async)- fromfuture- generate- generateabsolutetime- ifthen- startcancellablefuture (rxjava-async)- switchcase- whiledoon tue apr 22 2014 at 7:50 am akarnokd notifications@githubcom wrote:> im working on buffer but still have to hunt down some test failures> > > reply to this email directly or view it on github ## david m grossplp consulting || ifthen switchcase dowhile whiledo are in contrib-computation-expressionsim not sure about the cancelablefuture variants as they conceptionally didnt really work in java (ie attempt to mirror c# cancellation tokens)chunkify generate generateabsolutetime foriterable - probably notwhile we are at it i have some trouble with `buffer(func0<observable>)` variant i would expect the returned observable to supply multiple """"absolute"""" boundary events but the current implementation calls for a new observable whenever a previous one fired an event causing an exponential explosion [chunkedoperation l515]( the reason seems to be to produce a relative windowing in the associated [test method]( || before we proceed please review what i wrote at  and lets agree upon the coding principles || > do we expect any of the following proposed operators to be revived?i doubt it lets get the current operators (as of 018) polished for 10 new operators or matured ones from the contrib modules can come over in 1x releases if found to be commonly neededthe only one not on the list i can think of needing to re-add is the `groupby` overload that takes a selector it was unceremoniously dropped a few releases ago when i did refactoring || i skipped `combinelatest` as there was pr #1043 not long ago i wonder if @vigdorchik still wants to implement it || @akarnokd sorry im out of context here || @zsxwing ill do window || all done and  "";1;0;operatordistinct;"
"1085;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatordistinctuntilchanged;operator distinctuntilchanged  issue #1060  again  i haven t ported the custom comparator version.;;1060.0;operatordistinctuntilchanged;operator distinctuntilchangedissue #1060again i havent ported the custom comparator version;#996;operations to rewrite;core:-  `all` (w/ lift) pr #1061 - _merged_-  `any` (w/ lift) pr #1062 - _merged_  - `exist` and `isempty` are built upon `any`-  `asobservable` (w/ ~~onsubscribe~~ lift) pr #1064 - _merged_-  `buffer` (w/ lift) pr #1073 - _merged_  - size time window skip observable boundary observable start-end-  `combinelatest` (w/ onsubscribe) pr #1079 - _merged_-  `concat` (w/ ~~onsubscribe~~ lift) pr #1074 - _merged_-  `debounce` (w/ lift) pr #1094  - time window another observable-  `defaultifempty` (w/ lift) pr #1080 - _merged_-  `defer` (w/ onsubscribe) pr #1081 - _merged_-  `delay` (w/ ~~lift~~ keep as is) ~~pr #1093~~ pr #1144  - `delaysubscribe` (w/ onsubscribe)  - `delayviaobservable` (w/ onsubscribe)- [x] `dematerialize` (w/ lift) pr #1083 - _merged_- [x] `distinct` (w/ lift) pr #1084 - _merged_  - regular ~~custom equality comparator~~- [x] `distinctuntilchanged` (w/ lift) pr #1085 - _merged_- [x] `finallydo` (w/ lift) pr #1086 - _merged_- [x] `flatmap` (w/ lift) -> rename to `mergemap` pr #1087 - _merged_  - ~~regular~~ with iterator as sub-collection (`mergemapiterable`)- [x] `groupbyuntil` (w/ lift) pr #1095- [x] `groupjoin` (w/ onsubscribe) pr #1096- [x] `interval` replace with `timer` pr #1098- [x] `join` (w/ onsubscribe) pr #1103- [x] `mergedelayerror` (w/ lift) pr #1104- [x] `mergemaxconcurrent`(w/ lift) pr #1106- [x] `multicast` (w/ onsubscribe) pr #1108  - regular factory+selector- [x] `onerrorresumenextviaobservable` (w/ lift) pr #1109- [x] `onerrorreturn`(w/ lift) pr #1110- [x] `onexceptionresumenextviaobservable` (w/ lift) pr #1117- [x] `parallelmerge` -> just rename pr #1118- [x] `refcount` (w/ onsubscribe) pr #1119- [x] `replay` (w/ onsubscribe) pr #1108- [x] `sample` (w/ lift)  pr #1098  - time (state-sharing bug!) another observable- [x] `sequenceequals` -> just rename pr #1120- [x] `skip` (w/ lift) into `operatorskiptimed` pr #1121- [x] `skipuntil` (w/ lift) pr #1122- [x] `switch` (w/ lift) pr #1130- [x] `take` (w/ lift) pr #1131  - count: already present time- [x] `takelast` (w/ lift) pr #1134  - count time- [x] `takeuntil` (w/ lift) pr #1135- [x] `takewhile` (w/ lift) remove indexed variant? pr #1115- [x] `throttlefirst` (w/ lift) pr #1112- [x] `timeinterval` (w/ lift) pr #1111- [x] `timer` (w/ onsubscribe)  pr #1098- [x] `tomap` (w/ onsubscribe) pr #1099- [x] `tomultimap` (w/ onsubscribe) pr #1097- [x] `toobservablefuture` (w/ onsubscribe) pr #1088 - _merged_- [x] `using` (w/ onsubscribe) pr #1100- [x] `window` (w/ lift) pr ~~#1123~~ pr #1138  - size time window skip observable boundary observable start-endcontrib-string- [x] optionally: refactor operators into separate classes no changescontrib-async-util pr #1101- [x] `startfuture` -> just rename- [x] `operationfromfunctionalsinvokeasync` (w/ onsubscribe)- [x] `foreachfuture` -> just rename- [x] `deferfuture` -> just renamecontrib-math pr #1125- [x] `average` (w/ lift) ~~may keep current op-composition~~  - int long float double w/ extractor function- [x] `min` `minby` `max` `maxby` ~~(w/ lift)~~ may keep current op-composition- [x] `sum` ~~(w/ lift)~~ may keep current op-compositioncontrib-computation-expressions pr #1129- [x] `ifthen` (w/ onsubscribe)- [x] `switchcase` (w/ onsubscribe)- [x] `dowhile` `whiledo` (w/ onsubscribe)contrib-joins- [x] `when` (w/ onsubscribe) pr #1126;""im working on buffer but still have to hunt down some test failures || do we expect any of the following proposed operators to be revived?- chunkify- defercancellablefuture (rxjava-async)- dowhile- foreachfuture (blockingobservable)- foriterable- fromcancellablefuture (rxjava-async)- fromfuture- generate- generateabsolutetime- ifthen- startcancellablefuture (rxjava-async)- switchcase- whiledoon tue apr 22 2014 at 7:50 am akarnokd notifications@githubcom wrote:> im working on buffer but still have to hunt down some test failures> > > reply to this email directly or view it on github ## david m grossplp consulting || ifthen switchcase dowhile whiledo are in contrib-computation-expressionsim not sure about the cancelablefuture variants as they conceptionally didnt really work in java (ie attempt to mirror c# cancellation tokens)chunkify generate generateabsolutetime foriterable - probably notwhile we are at it i have some trouble with `buffer(func0<observable>)` variant i would expect the returned observable to supply multiple """"absolute"""" boundary events but the current implementation calls for a new observable whenever a previous one fired an event causing an exponential explosion [chunkedoperation l515]( the reason seems to be to produce a relative windowing in the associated [test method]( || before we proceed please review what i wrote at  and lets agree upon the coding principles || > do we expect any of the following proposed operators to be revived?i doubt it lets get the current operators (as of 018) polished for 10 new operators or matured ones from the contrib modules can come over in 1x releases if found to be commonly neededthe only one not on the list i can think of needing to re-add is the `groupby` overload that takes a selector it was unceremoniously dropped a few releases ago when i did refactoring || i skipped `combinelatest` as there was pr #1043 not long ago i wonder if @vigdorchik still wants to implement it || @akarnokd sorry im out of context here || @zsxwing ill do window || all done and  "";1;0;operatordistinctuntilchanged;"
1086;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatorfinallydo;operator finallydo  issue #1060;;0;operatorfinallydo;operator finallydoissue #1060;#997 ;;;;1;1;operatorfinallydo;
1087;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatormergemap;operator mergemap  namely the paired and the one which turns all event kinds into observables to merge.  issue #1060;;0;operatormergemap;operator mergemap namely the paired and the one which turns all event kinds into observables to mergeissue #1060;#998 ;;;;1;1;operatormergemap;
1088;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatortoobservablefuture;also make the observable be able to unsubscribe.  issue #1060;;0;operatortoobservablefuture;also make the observable be able to unsubscribeissue #1060;#999;;;;1;1;operatortoobservablefuture;
1089;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;manual merge of several prs;this was a manual merge since each of these was conflicting due to the changing import statements at the top. i really wish github allowed easily handling these ;;0;manual merge of several prs;this was a manual merge since each of these was conflicting due to the changing import statements at the top i really wish github allowed easily handling these;#1000 i was afraid of these conflicts to happen ||;;;;1;1;method signature cleanup;
1091;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;handle thrown errors with unsafesubscribe; oxymoronic commit here ... adding some safety to unsafesubscribe. ... fixes https://github.com/netflix/rxjava/issues/1090;;0;handle thrown errors with unsafesubscribe;oxymoronic commit here  adding some safety to unsafesubscribe fixes https://githubcom/netflix/rxjava/issues/1090;;;;;1;1;handle thrown errors with unsafesubscribe oxymoronic commit here  adding some safety to unsafesubscribe fixes https://githubcom/netflix/rxjava/issues/1090;
1092;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;restore observableexecutionhook.oncreate;;;0;restore observableexecutionhookoncreate;;#1002;;;;1;1;reconnecting observableexecutionhookoncreatesomehow this got lost in the refactorings over the past few weeks;
"1095;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatorgroupbyuntil;operator groupbyuntil  for issue #1060  while rewriting  i ve noticed a common pitfall with the observation of the duration: many other operators react to onnext or oncompleted  but one should only  expire  once. i ll review my recent operators and post a separate pr if any.;;1060.0;operatorgroupbyuntil;""operator groupbyuntilfor issue #1060while rewriting ive noticed a common pitfall with the observation of the duration: many other operators react to onnext or oncompleted but one should only """"expire"""" once ill review my recent operators and post a separate pr if any"";#1005;operations to rewrite;core:-  `all` (w/ lift) pr #1061 - _merged_-  `any` (w/ lift) pr #1062 - _merged_  - `exist` and `isempty` are built upon `any`-  `asobservable` (w/ ~~onsubscribe~~ lift) pr #1064 - _merged_-  `buffer` (w/ lift) pr #1073 - _merged_  - size time window skip observable boundary observable start-end-  `combinelatest` (w/ onsubscribe) pr #1079 - _merged_-  `concat` (w/ ~~onsubscribe~~ lift) pr #1074 - _merged_-  `debounce` (w/ lift) pr #1094  - time window another observable-  `defaultifempty` (w/ lift) pr #1080 - _merged_-  `defer` (w/ onsubscribe) pr #1081 - _merged_-  `delay` (w/ ~~lift~~ keep as is) ~~pr #1093~~ pr #1144  - `delaysubscribe` (w/ onsubscribe)  - `delayviaobservable` (w/ onsubscribe)- [x] `dematerialize` (w/ lift) pr #1083 - _merged_- [x] `distinct` (w/ lift) pr #1084 - _merged_  - regular ~~custom equality comparator~~- [x] `distinctuntilchanged` (w/ lift) pr #1085 - _merged_- [x] `finallydo` (w/ lift) pr #1086 - _merged_- [x] `flatmap` (w/ lift) -> rename to `mergemap` pr #1087 - _merged_  - ~~regular~~ with iterator as sub-collection (`mergemapiterable`)- [x] `groupbyuntil` (w/ lift) pr #1095- [x] `groupjoin` (w/ onsubscribe) pr #1096- [x] `interval` replace with `timer` pr #1098- [x] `join` (w/ onsubscribe) pr #1103- [x] `mergedelayerror` (w/ lift) pr #1104- [x] `mergemaxconcurrent`(w/ lift) pr #1106- [x] `multicast` (w/ onsubscribe) pr #1108  - regular factory+selector- [x] `onerrorresumenextviaobservable` (w/ lift) pr #1109- [x] `onerrorreturn`(w/ lift) pr #1110- [x] `onexceptionresumenextviaobservable` (w/ lift) pr #1117- [x] `parallelmerge` -> just rename pr #1118- [x] `refcount` (w/ onsubscribe) pr #1119- [x] `replay` (w/ onsubscribe) pr #1108- [x] `sample` (w/ lift)  pr #1098  - time (state-sharing bug!) another observable- [x] `sequenceequals` -> just rename pr #1120- [x] `skip` (w/ lift) into `operatorskiptimed` pr #1121- [x] `skipuntil` (w/ lift) pr #1122- [x] `switch` (w/ lift) pr #1130- [x] `take` (w/ lift) pr #1131  - count: already present time- [x] `takelast` (w/ lift) pr #1134  - count time- [x] `takeuntil` (w/ lift) pr #1135- [x] `takewhile` (w/ lift) remove indexed variant? pr #1115- [x] `throttlefirst` (w/ lift) pr #1112- [x] `timeinterval` (w/ lift) pr #1111- [x] `timer` (w/ onsubscribe)  pr #1098- [x] `tomap` (w/ onsubscribe) pr #1099- [x] `tomultimap` (w/ onsubscribe) pr #1097- [x] `toobservablefuture` (w/ onsubscribe) pr #1088 - _merged_- [x] `using` (w/ onsubscribe) pr #1100- [x] `window` (w/ lift) pr ~~#1123~~ pr #1138  - size time window skip observable boundary observable start-endcontrib-string- [x] optionally: refactor operators into separate classes no changescontrib-async-util pr #1101- [x] `startfuture` -> just rename- [x] `operationfromfunctionalsinvokeasync` (w/ onsubscribe)- [x] `foreachfuture` -> just rename- [x] `deferfuture` -> just renamecontrib-math pr #1125- [x] `average` (w/ lift) ~~may keep current op-composition~~  - int long float double w/ extractor function- [x] `min` `minby` `max` `maxby` ~~(w/ lift)~~ may keep current op-composition- [x] `sum` ~~(w/ lift)~~ may keep current op-compositioncontrib-computation-expressions pr #1129- [x] `ifthen` (w/ onsubscribe)- [x] `switchcase` (w/ onsubscribe)- [x] `dowhile` `whiledo` (w/ onsubscribe)contrib-joins- [x] `when` (w/ onsubscribe) pr #1126;""im working on buffer but still have to hunt down some test failures || do we expect any of the following proposed operators to be revived?- chunkify- defercancellablefuture (rxjava-async)- dowhile- foreachfuture (blockingobservable)- foriterable- fromcancellablefuture (rxjava-async)- fromfuture- generate- generateabsolutetime- ifthen- startcancellablefuture (rxjava-async)- switchcase- whiledoon tue apr 22 2014 at 7:50 am akarnokd notifications@githubcom wrote:> im working on buffer but still have to hunt down some test failures> > > reply to this email directly or view it on github ## david m grossplp consulting || ifthen switchcase dowhile whiledo are in contrib-computation-expressionsim not sure about the cancelablefuture variants as they conceptionally didnt really work in java (ie attempt to mirror c# cancellation tokens)chunkify generate generateabsolutetime foriterable - probably notwhile we are at it i have some trouble with `buffer(func0<observable>)` variant i would expect the returned observable to supply multiple """"absolute"""" boundary events but the current implementation calls for a new observable whenever a previous one fired an event causing an exponential explosion [chunkedoperation l515]( the reason seems to be to produce a relative windowing in the associated [test method]( || before we proceed please review what i wrote at  and lets agree upon the coding principles || > do we expect any of the following proposed operators to be revived?i doubt it lets get the current operators (as of 018) polished for 10 new operators or matured ones from the contrib modules can come over in 1x releases if found to be commonly neededthe only one not on the list i can think of needing to re-add is the `groupby` overload that takes a selector it was unceremoniously dropped a few releases ago when i did refactoring || i skipped `combinelatest` as there was pr #1043 not long ago i wonder if @vigdorchik still wants to implement it || @akarnokd sorry im out of context here || @zsxwing ill do window || all done and  "";1;0;operatorgroupbyuntil;"
"1096;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatorgroupjoin;operator groupjoin  for issue #1060  maybe this could be moved to the new joins.;;1060.0;operatorgroupjoin;operator groupjoinfor issue #1060maybe this could be moved to the new joins;#1006 is this better associated with rxjava-joins? ||;operations to rewrite;core:-  `all` (w/ lift) pr #1061 - _merged_-  `any` (w/ lift) pr #1062 - _merged_  - `exist` and `isempty` are built upon `any`-  `asobservable` (w/ ~~onsubscribe~~ lift) pr #1064 - _merged_-  `buffer` (w/ lift) pr #1073 - _merged_  - size time window skip observable boundary observable start-end-  `combinelatest` (w/ onsubscribe) pr #1079 - _merged_-  `concat` (w/ ~~onsubscribe~~ lift) pr #1074 - _merged_-  `debounce` (w/ lift) pr #1094  - time window another observable-  `defaultifempty` (w/ lift) pr #1080 - _merged_-  `defer` (w/ onsubscribe) pr #1081 - _merged_-  `delay` (w/ ~~lift~~ keep as is) ~~pr #1093~~ pr #1144  - `delaysubscribe` (w/ onsubscribe)  - `delayviaobservable` (w/ onsubscribe)- [x] `dematerialize` (w/ lift) pr #1083 - _merged_- [x] `distinct` (w/ lift) pr #1084 - _merged_  - regular ~~custom equality comparator~~- [x] `distinctuntilchanged` (w/ lift) pr #1085 - _merged_- [x] `finallydo` (w/ lift) pr #1086 - _merged_- [x] `flatmap` (w/ lift) -> rename to `mergemap` pr #1087 - _merged_  - ~~regular~~ with iterator as sub-collection (`mergemapiterable`)- [x] `groupbyuntil` (w/ lift) pr #1095- [x] `groupjoin` (w/ onsubscribe) pr #1096- [x] `interval` replace with `timer` pr #1098- [x] `join` (w/ onsubscribe) pr #1103- [x] `mergedelayerror` (w/ lift) pr #1104- [x] `mergemaxconcurrent`(w/ lift) pr #1106- [x] `multicast` (w/ onsubscribe) pr #1108  - regular factory+selector- [x] `onerrorresumenextviaobservable` (w/ lift) pr #1109- [x] `onerrorreturn`(w/ lift) pr #1110- [x] `onexceptionresumenextviaobservable` (w/ lift) pr #1117- [x] `parallelmerge` -> just rename pr #1118- [x] `refcount` (w/ onsubscribe) pr #1119- [x] `replay` (w/ onsubscribe) pr #1108- [x] `sample` (w/ lift)  pr #1098  - time (state-sharing bug!) another observable- [x] `sequenceequals` -> just rename pr #1120- [x] `skip` (w/ lift) into `operatorskiptimed` pr #1121- [x] `skipuntil` (w/ lift) pr #1122- [x] `switch` (w/ lift) pr #1130- [x] `take` (w/ lift) pr #1131  - count: already present time- [x] `takelast` (w/ lift) pr #1134  - count time- [x] `takeuntil` (w/ lift) pr #1135- [x] `takewhile` (w/ lift) remove indexed variant? pr #1115- [x] `throttlefirst` (w/ lift) pr #1112- [x] `timeinterval` (w/ lift) pr #1111- [x] `timer` (w/ onsubscribe)  pr #1098- [x] `tomap` (w/ onsubscribe) pr #1099- [x] `tomultimap` (w/ onsubscribe) pr #1097- [x] `toobservablefuture` (w/ onsubscribe) pr #1088 - _merged_- [x] `using` (w/ onsubscribe) pr #1100- [x] `window` (w/ lift) pr ~~#1123~~ pr #1138  - size time window skip observable boundary observable start-endcontrib-string- [x] optionally: refactor operators into separate classes no changescontrib-async-util pr #1101- [x] `startfuture` -> just rename- [x] `operationfromfunctionalsinvokeasync` (w/ onsubscribe)- [x] `foreachfuture` -> just rename- [x] `deferfuture` -> just renamecontrib-math pr #1125- [x] `average` (w/ lift) ~~may keep current op-composition~~  - int long float double w/ extractor function- [x] `min` `minby` `max` `maxby` ~~(w/ lift)~~ may keep current op-composition- [x] `sum` ~~(w/ lift)~~ may keep current op-compositioncontrib-computation-expressions pr #1129- [x] `ifthen` (w/ onsubscribe)- [x] `switchcase` (w/ onsubscribe)- [x] `dowhile` `whiledo` (w/ onsubscribe)contrib-joins- [x] `when` (w/ onsubscribe) pr #1126;""im working on buffer but still have to hunt down some test failures || do we expect any of the following proposed operators to be revived?- chunkify- defercancellablefuture (rxjava-async)- dowhile- foreachfuture (blockingobservable)- foriterable- fromcancellablefuture (rxjava-async)- fromfuture- generate- generateabsolutetime- ifthen- startcancellablefuture (rxjava-async)- switchcase- whiledoon tue apr 22 2014 at 7:50 am akarnokd notifications@githubcom wrote:> im working on buffer but still have to hunt down some test failures> > > reply to this email directly or view it on github ## david m grossplp consulting || ifthen switchcase dowhile whiledo are in contrib-computation-expressionsim not sure about the cancelablefuture variants as they conceptionally didnt really work in java (ie attempt to mirror c# cancellation tokens)chunkify generate generateabsolutetime foriterable - probably notwhile we are at it i have some trouble with `buffer(func0<observable>)` variant i would expect the returned observable to supply multiple """"absolute"""" boundary events but the current implementation calls for a new observable whenever a previous one fired an event causing an exponential explosion [chunkedoperation l515]( the reason seems to be to produce a relative windowing in the associated [test method]( || before we proceed please review what i wrote at  and lets agree upon the coding principles || > do we expect any of the following proposed operators to be revived?i doubt it lets get the current operators (as of 018) polished for 10 new operators or matured ones from the contrib modules can come over in 1x releases if found to be commonly neededthe only one not on the list i can think of needing to re-add is the `groupby` overload that takes a selector it was unceremoniously dropped a few releases ago when i did refactoring || i skipped `combinelatest` as there was pr #1043 not long ago i wonder if @vigdorchik still wants to implement it || @akarnokd sorry im out of context here || @zsxwing ill do window || all done and  "";1;0;operatorgroupjoin;"
1097;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatortomultimap;operator  tomultimap   issue #1060;;0;operatortomultimap;operator `tomultimap`issue #1060;#1007  #1009;;;;1;1;operatortomultimap;
1098;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatortimerandsample;operator timer and sample  because there was a dependency in sample towards the now removed interval  i had to reimplement sample in this pr as well.  note that the new  operatorsamplewithtime  schedules its first sample call before any upstream code is executed. given the testscheduler  a sample with 1sec and a timer with 1sec as well won t sample any value. the reason is that in the internal queue of testscheduler  the sampler s action to take the sample is followed by the action to emit the timer s value.;;0;operatortimerandsample;operator timer and samplebecause there was a dependency in sample towards the now removed interval i had to reimplement sample in this pr as wellnote that the new `operatorsamplewithtime` schedules its first sample call before any upstream code is executed given the testscheduler a sample with 1sec and a timer with 1sec as well wont sample any value the reason is that in the internal queue of testscheduler the samplers action to take the sample is followed by the action to emit the timers value;#1008 ;;;;1;1;operatortimerandsample;
1099;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatortomap;operator  tomap   issue #1060;;0;operatortomap;operator `tomap`issue #1060;#1010;;;;1;1;operatortomap;
1100;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatorusing;operator  using   issue #1060;;0;operatorusing;operator `using`issue #1060;#1011  #1021;;;;1;1;operatorusing;
"1103;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatorjoin;operator join  issue #1060  remark: now that the client.onnext is called outside the synchronization block  joint results may appear in arbitrary order in case both left and right observables emit values concurrently. i suppose the strict ordering is not really expected here  but someone who uses this operator can tell (@duncani perhaps?) .;;1060.0;operatorjoin;operator joinissue #1060remark: now that the clientonnext is called outside the synchronization block joint results may appear in arbitrary order in case both left and right observables emit values concurrently i suppose the strict ordering is not really expected here but someone who uses this operator can tell (@duncani perhaps?);#1014 rxoperatorsoperatorpivottesttestconcurrencyandserialization needs some fixing || > rxoperatorsoperatorpivottesttestconcurrencyandserialization needs some fixing yes it does ||;operations to rewrite;core:-  `all` (w/ lift) pr #1061 - _merged_-  `any` (w/ lift) pr #1062 - _merged_  - `exist` and `isempty` are built upon `any`-  `asobservable` (w/ ~~onsubscribe~~ lift) pr #1064 - _merged_-  `buffer` (w/ lift) pr #1073 - _merged_  - size time window skip observable boundary observable start-end-  `combinelatest` (w/ onsubscribe) pr #1079 - _merged_-  `concat` (w/ ~~onsubscribe~~ lift) pr #1074 - _merged_-  `debounce` (w/ lift) pr #1094  - time window another observable-  `defaultifempty` (w/ lift) pr #1080 - _merged_-  `defer` (w/ onsubscribe) pr #1081 - _merged_-  `delay` (w/ ~~lift~~ keep as is) ~~pr #1093~~ pr #1144  - `delaysubscribe` (w/ onsubscribe)  - `delayviaobservable` (w/ onsubscribe)- [x] `dematerialize` (w/ lift) pr #1083 - _merged_- [x] `distinct` (w/ lift) pr #1084 - _merged_  - regular ~~custom equality comparator~~- [x] `distinctuntilchanged` (w/ lift) pr #1085 - _merged_- [x] `finallydo` (w/ lift) pr #1086 - _merged_- [x] `flatmap` (w/ lift) -> rename to `mergemap` pr #1087 - _merged_  - ~~regular~~ with iterator as sub-collection (`mergemapiterable`)- [x] `groupbyuntil` (w/ lift) pr #1095- [x] `groupjoin` (w/ onsubscribe) pr #1096- [x] `interval` replace with `timer` pr #1098- [x] `join` (w/ onsubscribe) pr #1103- [x] `mergedelayerror` (w/ lift) pr #1104- [x] `mergemaxconcurrent`(w/ lift) pr #1106- [x] `multicast` (w/ onsubscribe) pr #1108  - regular factory+selector- [x] `onerrorresumenextviaobservable` (w/ lift) pr #1109- [x] `onerrorreturn`(w/ lift) pr #1110- [x] `onexceptionresumenextviaobservable` (w/ lift) pr #1117- [x] `parallelmerge` -> just rename pr #1118- [x] `refcount` (w/ onsubscribe) pr #1119- [x] `replay` (w/ onsubscribe) pr #1108- [x] `sample` (w/ lift)  pr #1098  - time (state-sharing bug!) another observable- [x] `sequenceequals` -> just rename pr #1120- [x] `skip` (w/ lift) into `operatorskiptimed` pr #1121- [x] `skipuntil` (w/ lift) pr #1122- [x] `switch` (w/ lift) pr #1130- [x] `take` (w/ lift) pr #1131  - count: already present time- [x] `takelast` (w/ lift) pr #1134  - count time- [x] `takeuntil` (w/ lift) pr #1135- [x] `takewhile` (w/ lift) remove indexed variant? pr #1115- [x] `throttlefirst` (w/ lift) pr #1112- [x] `timeinterval` (w/ lift) pr #1111- [x] `timer` (w/ onsubscribe)  pr #1098- [x] `tomap` (w/ onsubscribe) pr #1099- [x] `tomultimap` (w/ onsubscribe) pr #1097- [x] `toobservablefuture` (w/ onsubscribe) pr #1088 - _merged_- [x] `using` (w/ onsubscribe) pr #1100- [x] `window` (w/ lift) pr ~~#1123~~ pr #1138  - size time window skip observable boundary observable start-endcontrib-string- [x] optionally: refactor operators into separate classes no changescontrib-async-util pr #1101- [x] `startfuture` -> just rename- [x] `operationfromfunctionalsinvokeasync` (w/ onsubscribe)- [x] `foreachfuture` -> just rename- [x] `deferfuture` -> just renamecontrib-math pr #1125- [x] `average` (w/ lift) ~~may keep current op-composition~~  - int long float double w/ extractor function- [x] `min` `minby` `max` `maxby` ~~(w/ lift)~~ may keep current op-composition- [x] `sum` ~~(w/ lift)~~ may keep current op-compositioncontrib-computation-expressions pr #1129- [x] `ifthen` (w/ onsubscribe)- [x] `switchcase` (w/ onsubscribe)- [x] `dowhile` `whiledo` (w/ onsubscribe)contrib-joins- [x] `when` (w/ onsubscribe) pr #1126;""im working on buffer but still have to hunt down some test failures || do we expect any of the following proposed operators to be revived?- chunkify- defercancellablefuture (rxjava-async)- dowhile- foreachfuture (blockingobservable)- foriterable- fromcancellablefuture (rxjava-async)- fromfuture- generate- generateabsolutetime- ifthen- startcancellablefuture (rxjava-async)- switchcase- whiledoon tue apr 22 2014 at 7:50 am akarnokd notifications@githubcom wrote:> im working on buffer but still have to hunt down some test failures> > > reply to this email directly or view it on github ## david m grossplp consulting || ifthen switchcase dowhile whiledo are in contrib-computation-expressionsim not sure about the cancelablefuture variants as they conceptionally didnt really work in java (ie attempt to mirror c# cancellation tokens)chunkify generate generateabsolutetime foriterable - probably notwhile we are at it i have some trouble with `buffer(func0<observable>)` variant i would expect the returned observable to supply multiple """"absolute"""" boundary events but the current implementation calls for a new observable whenever a previous one fired an event causing an exponential explosion [chunkedoperation l515]( the reason seems to be to produce a relative windowing in the associated [test method]( || before we proceed please review what i wrote at  and lets agree upon the coding principles || > do we expect any of the following proposed operators to be revived?i doubt it lets get the current operators (as of 018) polished for 10 new operators or matured ones from the contrib modules can come over in 1x releases if found to be commonly neededthe only one not on the list i can think of needing to re-add is the `groupby` overload that takes a selector it was unceremoniously dropped a few releases ago when i did refactoring || i skipped `combinelatest` as there was pr #1043 not long ago i wonder if @vigdorchik still wants to implement it || @akarnokd sorry im out of context here || @zsxwing ill do window || all done and  "";1;0;operatorjoin;"
1106;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatormergemaxconcurrent;operator mergemaxconcurrent  issue #1060;;0;operatormergemaxconcurrent;operator mergemaxconcurrentissue #1060;#1016 ;;;;1;1;operatormergemaxconcurrent;
1107;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;fix replaysubject s double termination problem.;fix for issue #1105;;0;fix replaysubjects double termination problem;fix for issue #1105;#1017;;;;1;1;fix replaysubjects double termination problem;
1108;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatormulticastandreplay;operator multicast and replay  because replay is effectively a multicasted subject.  issue #1060;;0;operatormulticastandreplay;operator multicast and replay because replay is effectively a multicasted subjectissue #1060;#1018 ;;;;1;1;operatormulticastandreplay;
1109;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatoronerrorresumenextviaobservable;operator onerrorresumenextviaobservable  issue #1060;;0;operatoronerrorresumenextviaobservable;operator onerrorresumenextviaobservableissue #1060;#1019 ;;;;1;1;operatoronerrorresumenextviaobservable;
1110;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatoronerrorreturn;operator onerrorreturn  issue #1060;;0;operatoronerrorreturn;operator onerrorreturnissue #1060;#1020 ;;;;1;1;operatoronerrorreturn;
1111;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatortimeinterval;operator  timeinterval   issue #1060;;0;operatortimeinterval;operator `timeinterval`issue #1060;#1022 #1023  #1024;;;;1;1;operatortimeinterval;
1112;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatorthrottlefirst;operator  throttlefirst  and moved tests in  throttlefirsttests  to  operatorthrottlefirsttest .  issue #1060;;0;operatorthrottlefirst;operator `throttlefirst` and moved tests in `throttlefirsttests` to `operatorthrottlefirsttest`issue #1060;#1025 ;;;;1;1;operatorthrottlefirst;
1117;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator onexceptionresumenextviaobservable;operator onexceptionresumenextviaobservable  issue #1060;;0;operator onexceptionresumenextviaobservable;operator onexceptionresumenextviaobservableissue #1060;#1029;;;;1;1;operator onexceptionresumenextviaobservable;
1118;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator parallelmerge;operator parallelmerge  just renamed  issue #1060;;0;operator parallelmerge;operator parallelmerge just renamedissue #1060;#1030 ;;;;1;1;operator parallelmerge;
1119;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatorrefcount;operator refcount #1060;;0;operatorrefcount;operator refcount#1060;#1031;;;;1;1;operatorrefcount;
"1120;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatorsequenceequal;operator sequenceequal #1060  lightened the operator  but note that notificationlite escaping an operator may cause undesired effects in other operators relying on notificationlite as well.;;1060.0;operatorsequenceequal;operator sequenceequal#1060lightened the operator but note that notificationlite escaping an operator may cause undesired effects in other operators relying on notificationlite as well;#1032 ;operations to rewrite;core:-  `all` (w/ lift) pr #1061 - _merged_-  `any` (w/ lift) pr #1062 - _merged_  - `exist` and `isempty` are built upon `any`-  `asobservable` (w/ ~~onsubscribe~~ lift) pr #1064 - _merged_-  `buffer` (w/ lift) pr #1073 - _merged_  - size time window skip observable boundary observable start-end-  `combinelatest` (w/ onsubscribe) pr #1079 - _merged_-  `concat` (w/ ~~onsubscribe~~ lift) pr #1074 - _merged_-  `debounce` (w/ lift) pr #1094  - time window another observable-  `defaultifempty` (w/ lift) pr #1080 - _merged_-  `defer` (w/ onsubscribe) pr #1081 - _merged_-  `delay` (w/ ~~lift~~ keep as is) ~~pr #1093~~ pr #1144  - `delaysubscribe` (w/ onsubscribe)  - `delayviaobservable` (w/ onsubscribe)- [x] `dematerialize` (w/ lift) pr #1083 - _merged_- [x] `distinct` (w/ lift) pr #1084 - _merged_  - regular ~~custom equality comparator~~- [x] `distinctuntilchanged` (w/ lift) pr #1085 - _merged_- [x] `finallydo` (w/ lift) pr #1086 - _merged_- [x] `flatmap` (w/ lift) -> rename to `mergemap` pr #1087 - _merged_  - ~~regular~~ with iterator as sub-collection (`mergemapiterable`)- [x] `groupbyuntil` (w/ lift) pr #1095- [x] `groupjoin` (w/ onsubscribe) pr #1096- [x] `interval` replace with `timer` pr #1098- [x] `join` (w/ onsubscribe) pr #1103- [x] `mergedelayerror` (w/ lift) pr #1104- [x] `mergemaxconcurrent`(w/ lift) pr #1106- [x] `multicast` (w/ onsubscribe) pr #1108  - regular factory+selector- [x] `onerrorresumenextviaobservable` (w/ lift) pr #1109- [x] `onerrorreturn`(w/ lift) pr #1110- [x] `onexceptionresumenextviaobservable` (w/ lift) pr #1117- [x] `parallelmerge` -> just rename pr #1118- [x] `refcount` (w/ onsubscribe) pr #1119- [x] `replay` (w/ onsubscribe) pr #1108- [x] `sample` (w/ lift)  pr #1098  - time (state-sharing bug!) another observable- [x] `sequenceequals` -> just rename pr #1120- [x] `skip` (w/ lift) into `operatorskiptimed` pr #1121- [x] `skipuntil` (w/ lift) pr #1122- [x] `switch` (w/ lift) pr #1130- [x] `take` (w/ lift) pr #1131  - count: already present time- [x] `takelast` (w/ lift) pr #1134  - count time- [x] `takeuntil` (w/ lift) pr #1135- [x] `takewhile` (w/ lift) remove indexed variant? pr #1115- [x] `throttlefirst` (w/ lift) pr #1112- [x] `timeinterval` (w/ lift) pr #1111- [x] `timer` (w/ onsubscribe)  pr #1098- [x] `tomap` (w/ onsubscribe) pr #1099- [x] `tomultimap` (w/ onsubscribe) pr #1097- [x] `toobservablefuture` (w/ onsubscribe) pr #1088 - _merged_- [x] `using` (w/ onsubscribe) pr #1100- [x] `window` (w/ lift) pr ~~#1123~~ pr #1138  - size time window skip observable boundary observable start-endcontrib-string- [x] optionally: refactor operators into separate classes no changescontrib-async-util pr #1101- [x] `startfuture` -> just rename- [x] `operationfromfunctionalsinvokeasync` (w/ onsubscribe)- [x] `foreachfuture` -> just rename- [x] `deferfuture` -> just renamecontrib-math pr #1125- [x] `average` (w/ lift) ~~may keep current op-composition~~  - int long float double w/ extractor function- [x] `min` `minby` `max` `maxby` ~~(w/ lift)~~ may keep current op-composition- [x] `sum` ~~(w/ lift)~~ may keep current op-compositioncontrib-computation-expressions pr #1129- [x] `ifthen` (w/ onsubscribe)- [x] `switchcase` (w/ onsubscribe)- [x] `dowhile` `whiledo` (w/ onsubscribe)contrib-joins- [x] `when` (w/ onsubscribe) pr #1126;""im working on buffer but still have to hunt down some test failures || do we expect any of the following proposed operators to be revived?- chunkify- defercancellablefuture (rxjava-async)- dowhile- foreachfuture (blockingobservable)- foriterable- fromcancellablefuture (rxjava-async)- fromfuture- generate- generateabsolutetime- ifthen- startcancellablefuture (rxjava-async)- switchcase- whiledoon tue apr 22 2014 at 7:50 am akarnokd notifications@githubcom wrote:> im working on buffer but still have to hunt down some test failures> > > reply to this email directly or view it on github ## david m grossplp consulting || ifthen switchcase dowhile whiledo are in contrib-computation-expressionsim not sure about the cancelablefuture variants as they conceptionally didnt really work in java (ie attempt to mirror c# cancellation tokens)chunkify generate generateabsolutetime foriterable - probably notwhile we are at it i have some trouble with `buffer(func0<observable>)` variant i would expect the returned observable to supply multiple """"absolute"""" boundary events but the current implementation calls for a new observable whenever a previous one fired an event causing an exponential explosion [chunkedoperation l515]( the reason seems to be to produce a relative windowing in the associated [test method]( || before we proceed please review what i wrote at  and lets agree upon the coding principles || > do we expect any of the following proposed operators to be revived?i doubt it lets get the current operators (as of 018) polished for 10 new operators or matured ones from the contrib modules can come over in 1x releases if found to be commonly neededthe only one not on the list i can think of needing to re-add is the `groupby` overload that takes a selector it was unceremoniously dropped a few releases ago when i did refactoring || i skipped `combinelatest` as there was pr #1043 not long ago i wonder if @vigdorchik still wants to implement it || @akarnokd sorry im out of context here || @zsxwing ill do window || all done and  "";1;0;operatorsequenceequal;"
"1121;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatorskiptimed;operator skiptimed #1060  there was an unexpected dependency in  operationtaketimedtest  and is surely to cause conflict when  taketimed  is rewritten. once all operators have been merged  i suggest we create a primary  testexception  and rewrite tests to use it instead of all those custom exception classes everywhere.;;1060.0;operatorskiptimed;operator skiptimed#1060there was an unexpected dependency in `operationtaketimedtest` and is surely to cause conflict when `taketimed` is rewritten once all operators have been merged i suggest we create a primary `testexception` and rewrite tests to use it instead of all those custom exception classes everywhere;#1033;operations to rewrite;core:-  `all` (w/ lift) pr #1061 - _merged_-  `any` (w/ lift) pr #1062 - _merged_  - `exist` and `isempty` are built upon `any`-  `asobservable` (w/ ~~onsubscribe~~ lift) pr #1064 - _merged_-  `buffer` (w/ lift) pr #1073 - _merged_  - size time window skip observable boundary observable start-end-  `combinelatest` (w/ onsubscribe) pr #1079 - _merged_-  `concat` (w/ ~~onsubscribe~~ lift) pr #1074 - _merged_-  `debounce` (w/ lift) pr #1094  - time window another observable-  `defaultifempty` (w/ lift) pr #1080 - _merged_-  `defer` (w/ onsubscribe) pr #1081 - _merged_-  `delay` (w/ ~~lift~~ keep as is) ~~pr #1093~~ pr #1144  - `delaysubscribe` (w/ onsubscribe)  - `delayviaobservable` (w/ onsubscribe)- [x] `dematerialize` (w/ lift) pr #1083 - _merged_- [x] `distinct` (w/ lift) pr #1084 - _merged_  - regular ~~custom equality comparator~~- [x] `distinctuntilchanged` (w/ lift) pr #1085 - _merged_- [x] `finallydo` (w/ lift) pr #1086 - _merged_- [x] `flatmap` (w/ lift) -> rename to `mergemap` pr #1087 - _merged_  - ~~regular~~ with iterator as sub-collection (`mergemapiterable`)- [x] `groupbyuntil` (w/ lift) pr #1095- [x] `groupjoin` (w/ onsubscribe) pr #1096- [x] `interval` replace with `timer` pr #1098- [x] `join` (w/ onsubscribe) pr #1103- [x] `mergedelayerror` (w/ lift) pr #1104- [x] `mergemaxconcurrent`(w/ lift) pr #1106- [x] `multicast` (w/ onsubscribe) pr #1108  - regular factory+selector- [x] `onerrorresumenextviaobservable` (w/ lift) pr #1109- [x] `onerrorreturn`(w/ lift) pr #1110- [x] `onexceptionresumenextviaobservable` (w/ lift) pr #1117- [x] `parallelmerge` -> just rename pr #1118- [x] `refcount` (w/ onsubscribe) pr #1119- [x] `replay` (w/ onsubscribe) pr #1108- [x] `sample` (w/ lift)  pr #1098  - time (state-sharing bug!) another observable- [x] `sequenceequals` -> just rename pr #1120- [x] `skip` (w/ lift) into `operatorskiptimed` pr #1121- [x] `skipuntil` (w/ lift) pr #1122- [x] `switch` (w/ lift) pr #1130- [x] `take` (w/ lift) pr #1131  - count: already present time- [x] `takelast` (w/ lift) pr #1134  - count time- [x] `takeuntil` (w/ lift) pr #1135- [x] `takewhile` (w/ lift) remove indexed variant? pr #1115- [x] `throttlefirst` (w/ lift) pr #1112- [x] `timeinterval` (w/ lift) pr #1111- [x] `timer` (w/ onsubscribe)  pr #1098- [x] `tomap` (w/ onsubscribe) pr #1099- [x] `tomultimap` (w/ onsubscribe) pr #1097- [x] `toobservablefuture` (w/ onsubscribe) pr #1088 - _merged_- [x] `using` (w/ onsubscribe) pr #1100- [x] `window` (w/ lift) pr ~~#1123~~ pr #1138  - size time window skip observable boundary observable start-endcontrib-string- [x] optionally: refactor operators into separate classes no changescontrib-async-util pr #1101- [x] `startfuture` -> just rename- [x] `operationfromfunctionalsinvokeasync` (w/ onsubscribe)- [x] `foreachfuture` -> just rename- [x] `deferfuture` -> just renamecontrib-math pr #1125- [x] `average` (w/ lift) ~~may keep current op-composition~~  - int long float double w/ extractor function- [x] `min` `minby` `max` `maxby` ~~(w/ lift)~~ may keep current op-composition- [x] `sum` ~~(w/ lift)~~ may keep current op-compositioncontrib-computation-expressions pr #1129- [x] `ifthen` (w/ onsubscribe)- [x] `switchcase` (w/ onsubscribe)- [x] `dowhile` `whiledo` (w/ onsubscribe)contrib-joins- [x] `when` (w/ onsubscribe) pr #1126;""im working on buffer but still have to hunt down some test failures || do we expect any of the following proposed operators to be revived?- chunkify- defercancellablefuture (rxjava-async)- dowhile- foreachfuture (blockingobservable)- foriterable- fromcancellablefuture (rxjava-async)- fromfuture- generate- generateabsolutetime- ifthen- startcancellablefuture (rxjava-async)- switchcase- whiledoon tue apr 22 2014 at 7:50 am akarnokd notifications@githubcom wrote:> im working on buffer but still have to hunt down some test failures> > > reply to this email directly or view it on github ## david m grossplp consulting || ifthen switchcase dowhile whiledo are in contrib-computation-expressionsim not sure about the cancelablefuture variants as they conceptionally didnt really work in java (ie attempt to mirror c# cancellation tokens)chunkify generate generateabsolutetime foriterable - probably notwhile we are at it i have some trouble with `buffer(func0<observable>)` variant i would expect the returned observable to supply multiple """"absolute"""" boundary events but the current implementation calls for a new observable whenever a previous one fired an event causing an exponential explosion [chunkedoperation l515]( the reason seems to be to produce a relative windowing in the associated [test method]( || before we proceed please review what i wrote at  and lets agree upon the coding principles || > do we expect any of the following proposed operators to be revived?i doubt it lets get the current operators (as of 018) polished for 10 new operators or matured ones from the contrib modules can come over in 1x releases if found to be commonly neededthe only one not on the list i can think of needing to re-add is the `groupby` overload that takes a selector it was unceremoniously dropped a few releases ago when i did refactoring || i skipped `combinelatest` as there was pr #1043 not long ago i wonder if @vigdorchik still wants to implement it || @akarnokd sorry im out of context here || @zsxwing ill do window || all done and  "";1;0;operatorskiptimed;"
1122;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatorskipuntil;operator skipuntil #1060;;0;operatorskipuntil;operator skipuntil#1060;#1034 ;;;;1;1;operatorskipuntil;
1128;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;fix for serializedobservertest;fixed the serializedobservertest s problematic assertions: -  testmultithreadedwithnpeinmiddle  might schedule all non-null values before the exception might reach the serialized observer. in addition  waiting after the serialization doesn t help because the cheap value emissions get queued up before that  again  possibly before the exception. the new code adds some delays to the non-null elements allowing the exception to get into the queue. i ve looped it 10.000 times without failure  but there is still a non-zero chance the  new nullpointerexception()  thread is significantly delayed and ends up as the last event. -  testnotificationdelay  might fail due to thread scheduling of the two  onnextthread  delayed too much in respect to each other before the main thread allows the pass-through. the fix is to let bot instances  thread reach the run method and then let the main thread pass through them. again  a loop of 10.000 succeeded locally. - both tests are run 10 times to be more sure.;;0;fix for serializedobservertest; the serializedobservertests problematic assertions:- `testmultithreadedwithnpeinmiddle` might schedule all non-null values before the exception might reach the serialized observer in addition waiting after the serialization doesnt help because the cheap value emissions get queued up before that again possibly before the exception the new code adds some delays to the non-null elements allowing the exception to get into the queue ive looped it 10000 times without failure but there is still a non-zero chance the `new nullpointerexception()` thread is significantly delayed and ends up as the last event- `testnotificationdelay` might fail due to thread scheduling of the two `onnextthread` delayed too much in respect to each other before the main thread allows the pass-through the fix is to let bot instances thread reach the run method and then let the main thread pass through them again a loop of 10000 succeeded locally- both tests are run 10 times to be more sure;#1041 ;;;;1;1;fix for serializedobservertest;
1130;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator switch;operator switch  issue #1060;;0;operator switch;operator switchissue #1060;;;;;1;1;operator switch;
1131;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator taketimed;operator take with time  issue #1060;;0;operator taketimed;operator take with timeissue #1060;#1043 ;;;;1;1;operator taketimed;
"1132;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;manual merge of several prs;merging many prs that were conflicting.  heroic work by @akarnokd and @zsxwing on #1060   all unit tests are passing on my machine. going to let this bake a while before a release. other prs on still on their way ;;1060.0;manual merge of several prs;merging many prs that were conflictingheroic work by @akarnokd and @zsxwing on #1060 all unit tests are passing on my machine going to let this bake a while before a release other prs on still on their way;;operations to rewrite;core:-  `all` (w/ lift) pr #1061 - _merged_-  `any` (w/ lift) pr #1062 - _merged_  - `exist` and `isempty` are built upon `any`-  `asobservable` (w/ ~~onsubscribe~~ lift) pr #1064 - _merged_-  `buffer` (w/ lift) pr #1073 - _merged_  - size time window skip observable boundary observable start-end-  `combinelatest` (w/ onsubscribe) pr #1079 - _merged_-  `concat` (w/ ~~onsubscribe~~ lift) pr #1074 - _merged_-  `debounce` (w/ lift) pr #1094  - time window another observable-  `defaultifempty` (w/ lift) pr #1080 - _merged_-  `defer` (w/ onsubscribe) pr #1081 - _merged_-  `delay` (w/ ~~lift~~ keep as is) ~~pr #1093~~ pr #1144  - `delaysubscribe` (w/ onsubscribe)  - `delayviaobservable` (w/ onsubscribe)- [x] `dematerialize` (w/ lift) pr #1083 - _merged_- [x] `distinct` (w/ lift) pr #1084 - _merged_  - regular ~~custom equality comparator~~- [x] `distinctuntilchanged` (w/ lift) pr #1085 - _merged_- [x] `finallydo` (w/ lift) pr #1086 - _merged_- [x] `flatmap` (w/ lift) -> rename to `mergemap` pr #1087 - _merged_  - ~~regular~~ with iterator as sub-collection (`mergemapiterable`)- [x] `groupbyuntil` (w/ lift) pr #1095- [x] `groupjoin` (w/ onsubscribe) pr #1096- [x] `interval` replace with `timer` pr #1098- [x] `join` (w/ onsubscribe) pr #1103- [x] `mergedelayerror` (w/ lift) pr #1104- [x] `mergemaxconcurrent`(w/ lift) pr #1106- [x] `multicast` (w/ onsubscribe) pr #1108  - regular factory+selector- [x] `onerrorresumenextviaobservable` (w/ lift) pr #1109- [x] `onerrorreturn`(w/ lift) pr #1110- [x] `onexceptionresumenextviaobservable` (w/ lift) pr #1117- [x] `parallelmerge` -> just rename pr #1118- [x] `refcount` (w/ onsubscribe) pr #1119- [x] `replay` (w/ onsubscribe) pr #1108- [x] `sample` (w/ lift)  pr #1098  - time (state-sharing bug!) another observable- [x] `sequenceequals` -> just rename pr #1120- [x] `skip` (w/ lift) into `operatorskiptimed` pr #1121- [x] `skipuntil` (w/ lift) pr #1122- [x] `switch` (w/ lift) pr #1130- [x] `take` (w/ lift) pr #1131  - count: already present time- [x] `takelast` (w/ lift) pr #1134  - count time- [x] `takeuntil` (w/ lift) pr #1135- [x] `takewhile` (w/ lift) remove indexed variant? pr #1115- [x] `throttlefirst` (w/ lift) pr #1112- [x] `timeinterval` (w/ lift) pr #1111- [x] `timer` (w/ onsubscribe)  pr #1098- [x] `tomap` (w/ onsubscribe) pr #1099- [x] `tomultimap` (w/ onsubscribe) pr #1097- [x] `toobservablefuture` (w/ onsubscribe) pr #1088 - _merged_- [x] `using` (w/ onsubscribe) pr #1100- [x] `window` (w/ lift) pr ~~#1123~~ pr #1138  - size time window skip observable boundary observable start-endcontrib-string- [x] optionally: refactor operators into separate classes no changescontrib-async-util pr #1101- [x] `startfuture` -> just rename- [x] `operationfromfunctionalsinvokeasync` (w/ onsubscribe)- [x] `foreachfuture` -> just rename- [x] `deferfuture` -> just renamecontrib-math pr #1125- [x] `average` (w/ lift) ~~may keep current op-composition~~  - int long float double w/ extractor function- [x] `min` `minby` `max` `maxby` ~~(w/ lift)~~ may keep current op-composition- [x] `sum` ~~(w/ lift)~~ may keep current op-compositioncontrib-computation-expressions pr #1129- [x] `ifthen` (w/ onsubscribe)- [x] `switchcase` (w/ onsubscribe)- [x] `dowhile` `whiledo` (w/ onsubscribe)contrib-joins- [x] `when` (w/ onsubscribe) pr #1126;""im working on buffer but still have to hunt down some test failures || do we expect any of the following proposed operators to be revived?- chunkify- defercancellablefuture (rxjava-async)- dowhile- foreachfuture (blockingobservable)- foriterable- fromcancellablefuture (rxjava-async)- fromfuture- generate- generateabsolutetime- ifthen- startcancellablefuture (rxjava-async)- switchcase- whiledoon tue apr 22 2014 at 7:50 am akarnokd notifications@githubcom wrote:> im working on buffer but still have to hunt down some test failures> > > reply to this email directly or view it on github ## david m grossplp consulting || ifthen switchcase dowhile whiledo are in contrib-computation-expressionsim not sure about the cancelablefuture variants as they conceptionally didnt really work in java (ie attempt to mirror c# cancellation tokens)chunkify generate generateabsolutetime foriterable - probably notwhile we are at it i have some trouble with `buffer(func0<observable>)` variant i would expect the returned observable to supply multiple """"absolute"""" boundary events but the current implementation calls for a new observable whenever a previous one fired an event causing an exponential explosion [chunkedoperation l515]( the reason seems to be to produce a relative windowing in the associated [test method]( || before we proceed please review what i wrote at  and lets agree upon the coding principles || > do we expect any of the following proposed operators to be revived?i doubt it lets get the current operators (as of 018) polished for 10 new operators or matured ones from the contrib modules can come over in 1x releases if found to be commonly neededthe only one not on the list i can think of needing to re-add is the `groupby` overload that takes a selector it was unceremoniously dropped a few releases ago when i did refactoring || i skipped `combinelatest` as there was pr #1043 not long ago i wonder if @vigdorchik still wants to implement it || @akarnokd sorry im out of context here || @zsxwing ill do window || all done and  "";1;0;merge branch operatortaketimed429 of githubcom:akarnokd/rxjava into merge-prsconflicts:	rxjava-core/src/main/java/rx/observablejava;"
1133;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;collapse imports;attempt to reduce merge conflicts as it s always the import statements that are conflicting;;0;collapse imports;attempt to reduce merge conflicts as its always the import statements that are conflicting;#1045  a note should be posted somewhere that dont call organize imports or equivalent on `observablejava` so the ide wont expand these imports back to individual instances ||;;;;1;1;collapse importsattempt to reduce merge conflicts as its always the import statements that are conflicting;
1134;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operatortakelast;operator  takelast .  there are two changes comparing with the original implementations: - throw indexoutofboundsexception at once when calling  takelast  with  count < 0 . - replace illegalargumentexception with indexoutofboundsexception  when  count < 0  in  takelastwithtimed .  issue #1060;;0;operatortakelast;operator `takelast`there are two changes comparing with the original implementations:- throw indexoutofboundsexception at once when calling `takelast` with `count < 0`- replace illegalargumentexception with indexoutofboundsexception  when `count < 0` in `takelastwithtimed`issue #1060;#1046  #1048;;;;1;1;operatortakelast;
"1142;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;update  contains  signature to  contains(object);the original  contains  signature can not support the following codes:      java     public void test() {         arraylist<string> l = new arraylist<string>()          l.add( test )          observable<arraylist<string>> o = observable.<arraylist<string>>from(l)          o.contains(arrays.aslist( test ))      }      this pr changes the signature from  contains(t)  to  contains(object) . it s also consistent with  equals(object) .  this change should not break the old codes.;;0;update contains signature to contains(object);""the original `contains` signature can not support the following codes:``` java    public void test() {        arraylist<string> l  new arraylist<string>()        ladd(""""test"""")        observable<arraylist<string>> o  observable<arraylist<string>>from(l)        ocontains(arraysaslist(""""test""""))    }```this pr changes the signature from `contains(t)` to `contains(object)` its also consistent with `equals(object)`this change should not break the old codes"";#1055;;;;1;1;update contains signature to contains(object);"
1144;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator delay rebase & fixes;operator delay  issue #1060;;0;operator delay rebase & fixes;operator delayissue #1060;#1065 ;;;;1;1;operator delay rebase & fixes;
1148;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;manual merge of delay pr;;;0;manual merge of delay pr;;;;;;1;1;merge branch operatordelay505 of githubcom:akarnokd/rxjava into merge-delayconflicts:	rxjava-core/src/main/java/rx/observablejava;
1150;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;fix replaysubject terminal state race condition;fixes  with change from @akarnokd;;0;fix replaysubject terminal state race condition;fixes  with change from @akarnokd;unit test to assert this is:``` java    @test    public void testraceforterminalstate() {        final list<integer> expected  arraysaslist(1)        for (int i  0 i < 1000000 i++) {            testsubscriber<integer> ts  new testsubscriber<integer>()            observablejust(1)subscribeon(schedulerscomputation())cache()subscribe(ts)            tsawaitterminalevent()            tsassertreceivedonnext(expected)            tsassertterminalevent()        }    }```i am including that test with a smaller loop size if this bug were to return that test should non-deterministically fail even with the smaller loop || #1068  #1069;;;;1;1;replaysubject testraceforterminalstate();
1158;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;scheduler correctness improvements.;second round on the scheduler correctness issue.  sure it looks more heavy as  scheduledaction  now has its own inner  compositesubscription  and a shared reference to the parent  innersubscription .  i ve tried to benchmark it with  schedulerperformancetests  but that test is flawed: - multiple threads pound on the same long sum value  so naturally additions get lost. - the longobserver gets unsubscribed after the first loop so  from  will not actually call  onnext  but  isunsubscribed  a lot. - does not wait for the computations to finish and basically measures how fast 5m tasks can be added to the newthreadscheduler s innersubscription.  the flawed test gives ~ 11m ops/sec on my machine. if i fix the test and run against the master  5m takes extremely long to finish due to the inherent slowness of add/remove in compositesubscription if large. on my 4 core hyperthread enabled machine  i get 50k-150k ops/second for baseline with a 100k loop.  the proposed changes run with the flawed test gives ~10.8m ops/sec. with the test fixed and with the proposed changes  i get ~1.2m ops/sec.;;0;scheduler correctness improvements;second round on the scheduler correctness issuesure it looks more heavy as `scheduledaction` now has its own inner `compositesubscription` and a shared reference to the parent `innersubscription`ive tried to benchmark it with `schedulerperformancetests` but that test is flawed:- multiple threads pound on the same long sum value so naturally additions get lost- the longobserver gets unsubscribed after the first loop so `from` will not actually call `onnext` but `isunsubscribed` a lot- does not wait for the computations to finish and basically measures how fast 5m tasks can be added to the newthreadschedulers innersubscriptionthe flawed test gives ~ 11m ops/sec on my machine if i fix the test and run against the master 5m takes extremely long to finish due to the inherent slowness of add/remove in compositesubscription if large on my 4 core hyperthread enabled machine i get 50k-150k ops/second for baseline with a 100k loopthe proposed changes run with the flawed test gives ~108m ops/sec with the test  and with the proposed changes i get ~12m ops/sec;#1070 @akarnokd do you need help porting it over to jmh? i can assist with that || that would be great but i dont know how to run a jhm benchmark from netbeans || @akarnokd ideally you run it from the command line as a encapsulated package once you write the benchmark you package it up as a fat jar and then you can execute your test only ala: /gradlew benchmarks -pjmh-f 1 -tu ns -bm avgt -wi 5 -i 5 -r 1 _operatorserializeperf_but just replace the name of the benchmark with yours otherwise it will run this one or all if you leave it outnote that with some fiddling around i did this for netty you can fake it from your ide by either writing a custom junit runner or just doing it like this:  || looks like `onactioncomplete` is no longer used and could be removed? || true im working on something else right now so i come back later to remove it || #1074  > i dont know how to run a jhm benchmark from netbeansi always run them from command line see comments on how to run here:  || > you package it up as a fat jarthis option also exists with the `shadow` task that needs to be renamed to something like `benchmarkjar`:  || here is the benchmark code:  results:  implementation:  || i added performance tests for `observeon` and `subscribeon` using `schedulerscomputation()`:  pull request is far faster on startup (when subscribing to an observable of 1 item) and somewhat faster on long-running observables```/gradlew benchmarks -pjmh-f 1 -tu ns -bm avgt -wi 5 -i 5 -r 1 *computationschedulerperf*```#### new code```result : 235340831 (999%) 490947687 ns/op  statistics: (min avg max)  (90922636 235340831 420715962) stdev  127497555  confidence interval (999%): [-255606856 726288517]benchmark                                   (size)   mode   samples         mean   mean error    unitsrscomputationschedulerperfobserveon           1   avgt         5     2180371      207253    ns/oprscomputationschedulerperfobserveon        1024   avgt         5   128238555    17976667    ns/oprscomputationschedulerperfobserveon     1048576   avgt         5 149856485714 19627546003    ns/oprscomputationschedulerperfsubscribeon         1   avgt         5     2197782      267688    ns/oprscomputationschedulerperfsubscribeon      1024   avgt         5   414051806  1536527849    ns/oprscomputationschedulerperfsubscribeon   1048576   avgt         5   235340831   490947687    ns/op``````result : 1509019668 (999%) 4443411014 ns/op  statistics: (min avg max)  (300644144 1509019668 2913322987) stdev  1153939730  confidence interval (999%): [-2934391346 5952430682]benchmark                                   (size)   mode   samples         mean   mean error    unitsrscomputationschedulerperfobserveon           1   avgt         5     2056254      554314    ns/oprscomputationschedulerperfobserveon        1024   avgt         5   101872671    12964522    ns/oprscomputationschedulerperfobserveon     1048576   avgt         5 147002257143  9201133563    ns/oprscomputationschedulerperfsubscribeon         1   avgt         5     2235005      336381    ns/oprscomputationschedulerperfsubscribeon      1024   avgt         5   550600029   482135695    ns/oprscomputationschedulerperfsubscribeon   1048576   avgt         5  1509019668  4443411014    ns/op```#### master```result : 63507629 (999%) 131757785 ns/op  statistics: (min avg max)  (38513407 63507629 123730129) stdev  34217078  confidence interval (999%): [-68250156 195265414]benchmark                                   (size)   mode   samples         mean   mean error    unitsrscomputationschedulerperfobserveon           1   avgt         5    51867073    77712741    ns/oprscomputationschedulerperfobserveon        1024   avgt         5   118883112    14487931    ns/oprscomputationschedulerperfobserveon     1048576   avgt         5 154828171429 20611654844    ns/oprscomputationschedulerperfsubscribeon         1   avgt         5    68898012   200669541    ns/oprscomputationschedulerperfsubscribeon      1024   avgt         5    71403833   209712445    ns/oprscomputationschedulerperfsubscribeon   1048576   avgt         5    63507629   131757785    ns/op``````result : 183126150 (999%) 1168534854 ns/op  statistics: (min avg max)  (37927424 183126150 725869905) stdev  303464791  confidence interval (999%): [-985408704 1351661004]benchmark                                   (size)   mode   samples         mean   mean error    unitsrscomputationschedulerperfobserveon           1   avgt         5    50085795    64485544    ns/oprscomputationschedulerperfobserveon        1024   avgt         5   123673009     3130488    ns/oprscomputationschedulerperfobserveon     1048576   avgt         5 151220000000 20063502154    ns/oprscomputationschedulerperfsubscribeon         1   avgt         5    73814774   202116247    ns/oprscomputationschedulerperfsubscribeon      1024   avgt         5    72216122   186483284    ns/oprscomputationschedulerperfsubscribeon   1048576   avgt         5   183126150  1168534854    ns/op``` || one thing i dont like about how this is currently working is that we have to create the `scheduledaction` each time and that feels wasteful when we immediately are putting it inside a queue inside `poolworker` it feels like we should be able to unsubscribe the queue and not need to maintain the `compositesubscription` of `scheduledaction` instancesthis may fit with what @spodila is working on as i believe it will maintain a queue per `worker` and the underlying threads will pull off the queues in other words by eliminating the use of `executor` we get better control of the thread and can get rid of a layer of abstractiongoing to merge this however as it is better than the current implementation and well continue improving this in #1149 || ooops i forgot to mention there might be some unwanted task executions after `newthreadscheduler` is unsubscribed because `executorshutdown()` does not remove pending tasks `executorshutdownnow()` does it || `eventloopscheduler` is not affected because its worker keeps track of the tasks and cancels them ||;;;;1;1;removed unused interface;
1160;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add  replay  and  multicast  variants to rxscala;this pr has some breaking changes: - change  def multicast[r >: t](subject: rx.lang.scala.subject[r]): (() => subscription  observable[r])  to  def multicast[r >: t](subject: rx.lang.scala.subject[r]): connectableobservable[r]  - change  def replay: (() => subscription  observable[t])  to  def replay: connectableobservable[t]  - remove  observable.apply(int)   so it s better to merge it at the next major release. #1152  #1153.  /cc @headinthebox @samuelgruetter;;1152.0;add `replay` and `multicast` variants to rxscala;this pr has some breaking changes:- change `def multicast[r >: t](subject: rxlangscalasubject[r]): (() > subscription observable[r])` to `def multicast[r >: t](subject: rxlangscalasubject[r]): connectableobservable[r]`- change `def replay: (() > subscription observable[t])` to `def replay: connectableobservable[t]`- remove `observableapply(int)`so its better to merge it at the next major release#1152 #1153/cc @headinthebox @samuelgruetter;#1072  id like someone with better scala skills that me to review this please || ill code review it later today but in principle these are simple fixes to bring the other variants of publish in sync with returning connectable observable || #1081 #1087 looks good || is this reviewed and ready to go? it is conflicting against master so can you please rebase? || this is also conflicting against #1178 i would like to rebase it after #1178 is merged to master || waiting until #1210 is  already merged || [rxjava-pull-requests #1129]( successthis pull request looks good || should this wait until were ready to do 019? || i think this one can be merged since #1188 has already broken the api @headinthebox @samuelgruetter  do you mind it? || go for it ||;rxscala subjects;several of the scala bindings for subjects still return ()>subscription instead of a connectableobservable;ill take it || like! ||;1;0;merge branch master into replay-multicastconflicts:	language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/rxscalademoscala	language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/observablescala	language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/completenesstestscala;
1160;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add  replay  and  multicast  variants to rxscala;this pr has some breaking changes: - change  def multicast[r >: t](subject: rx.lang.scala.subject[r]): (() => subscription  observable[r])  to  def multicast[r >: t](subject: rx.lang.scala.subject[r]): connectableobservable[r]  - change  def replay: (() => subscription  observable[t])  to  def replay: connectableobservable[t]  - remove  observable.apply(int)   so it s better to merge it at the next major release. #1152  #1153.  /cc @headinthebox @samuelgruetter;;1153.0;add `replay` and `multicast` variants to rxscala;this pr has some breaking changes:- change `def multicast[r >: t](subject: rxlangscalasubject[r]): (() > subscription observable[r])` to `def multicast[r >: t](subject: rxlangscalasubject[r]): connectableobservable[r]`- change `def replay: (() > subscription observable[t])` to `def replay: connectableobservable[t]`- remove `observableapply(int)`so its better to merge it at the next major release#1152 #1153/cc @headinthebox @samuelgruetter;#1072  id like someone with better scala skills that me to review this please || ill code review it later today but in principle these are simple fixes to bring the other variants of publish in sync with returning connectable observable || #1081 #1087 looks good || is this reviewed and ready to go? it is conflicting against master so can you please rebase? || this is also conflicting against #1178 i would like to rebase it after #1178 is merged to master || waiting until #1210 is  already merged || [rxjava-pull-requests #1129]( successthis pull request looks good || should this wait until were ready to do 019? || i think this one can be merged since #1188 has already broken the api @headinthebox @samuelgruetter  do you mind it? || go for it ||;rxscala: publish overload;overloads for  `public final <r> observable<r> publish(func1<? super observable<t> ? extends observable<r>> selector)` and `public final <tintermediate tresult> observable<tresult> multicast(            final func0<? extends subject<? super t ? extends tintermediate>> subjectfactory            final func1<? super observable<tintermediate> ? extends observable<tresult>> selector)` are missing;ill take it || like! ||;1;0;merge branch master into replay-multicastconflicts:	language-adaptors/rxjava-scala/src/examples/scala/rx/lang/scala/examples/rxscalademoscala	language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/observablescala	language-adaptors/rxjava-scala/src/test/scala/rx/lang/scala/completenesstestscala;
1161;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;removed use of deprecated api from tests & operators  fixed year in head;ers  added and removed suppressions  fixed line endings  replaced tabs with spaces  i haven t deleted  onsubscribefunc  because i was not sure when the general cleanup of deprecated stuff will happen  i just made sure java tests don t use it anymore.;;0;removed use of deprecated api from tests & operators  year in head;ers added and removed suppressions  line endings replaced tabs with spacesi havent deleted `onsubscribefunc` because i was not sure when the general cleanup of deprecated stuff will happen i just made sure java tests dont use it anymore;#1073 this is some seriously heroic cleanup! thank you very much im so glad to see `safeobservablesubscription` gone! || ditto || reviewing this again while doing release notes  thank you again @akarnokd for this you took care of messy tedious things here that had been piling up for a while and was constantly on the todo list ||;;;;1;1;removed use of deprecated api from tests & operators  year in headers added and removed suppressions fixed line endings replaced tabs with spaces;
"1162;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix to remove drift from scheduleperiodic;when implementing the  worker  scheduler pattern in rxcpp i implemented scheduleperiodic differently because i predicted that the rxjava version would drift. once the changes were working  i verified my prediction in rxcpp.   i decided to test the same in rxjava and contribute my approach.  this was my test:      java import java.util.concurrent.timeunit   import rx.scheduler  import rx.schedulers.schedulers  import rx.functions.action0   public class periodic {      public static void main(string args) {          final scheduler scheduler = schedulers.immediate()          final scheduler.worker w = scheduler.createworker()           final long initial = timeunit.seconds.tomillis(2)          final long period = timeunit.seconds.tomillis(1)          final long start = scheduler.now() + initial           w.scheduleperiodically(new action0() {             long count = 0              @override             public void call() {                 long tick = scheduler.now()                  system.out.println(string.format( expected -> %dms  actual -> %dms  drift -> %dms   count*period  tick - start  tick - (start + (count*period))))                  ++count              }         }  initial  period  timeunit.milliseconds)      }  }      the existing impl causes this output:      $ java -cp rxjava-core/build/libs/rxjava-core-0.18.3-snapshot.jar:./ periodic expected -> 0ms  actual -> 1ms  drift -> 1ms expected -> 1000ms  actual -> 1002ms  drift -> 2ms expected -> 2000ms  actual -> 2003ms  drift -> 3ms expected -> 3000ms  actual -> 3004ms  drift -> 4ms expected -> 4000ms  actual -> 4005ms  drift -> 5ms expected -> 5000ms  actual -> 5006ms  drift -> 6ms expected -> 6000ms  actual -> 6007ms  drift -> 7ms expected -> 7000ms  actual -> 7008ms  drift -> 8ms expected -> 8000ms  actual -> 8009ms  drift -> 9ms expected -> 9000ms  actual -> 9010ms  drift -> 10ms expected -> 10000ms  actual -> 10011ms  drift -> 11ms expected -> 11000ms  actual -> 11012ms  drift -> 12ms expected -> 12000ms  actual -> 12013ms  drift -> 13ms expected -> 13000ms  actual -> 13014ms  drift -> 14ms expected -> 14000ms  actual -> 14016ms  drift -> 16ms expected -> 15000ms  actual -> 15017ms  drift -> 17ms expected -> 16000ms  actual -> 16018ms  drift -> 18ms expected -> 17000ms  actual -> 17019ms  drift -> 19ms expected -> 18000ms  actual -> 18020ms  drift -> 20ms expected -> 19000ms  actual -> 19021ms  drift -> 21ms expected -> 20000ms  actual -> 20022ms  drift -> 22ms expected -> 21000ms  actual -> 21023ms  drift -> 23ms expected -> 22000ms  actual -> 22023ms  drift -> 23ms expected -> 23000ms  actual -> 23024ms  drift -> 24ms      with this commit the test outputs:      $ java -cp ./:./rxjava-core/build/libs/rxjava-core-0.18.3-snapshot.jar periodic expected -> 0ms  actual -> 3ms  drift -> 3ms expected -> 1000ms  actual -> 1001ms  drift -> 1ms expected -> 2000ms  actual -> 2001ms  drift -> 1ms expected -> 3000ms  actual -> 3000ms  drift -> 0ms expected -> 4000ms  actual -> 4001ms  drift -> 1ms expected -> 5000ms  actual -> 5000ms  drift -> 0ms expected -> 6000ms  actual -> 6000ms  drift -> 0ms expected -> 7000ms  actual -> 7000ms  drift -> 0ms expected -> 8000ms  actual -> 8001ms  drift -> 1ms expected -> 9000ms  actual -> 9001ms  drift -> 1ms expected -> 10000ms  actual -> 10001ms  drift -> 1ms expected -> 11000ms  actual -> 11001ms  drift -> 1ms expected -> 12000ms  actual -> 12001ms  drift -> 1ms expected -> 13000ms  actual -> 13001ms  drift -> 1ms expected -> 14000ms  actual -> 14001ms  drift -> 1ms expected -> 15000ms  actual -> 15001ms  drift -> 1ms expected -> 16000ms  actual -> 16001ms  drift -> 1ms expected -> 17000ms  actual -> 17000ms  drift -> 0ms expected -> 18000ms  actual -> 18000ms  drift -> 0ms expected -> 19000ms  actual -> 19000ms  drift -> 0ms expected -> 20000ms  actual -> 20000ms  drift -> 0ms expected -> 21000ms  actual -> 21002ms  drift -> 2ms expected -> 22000ms  actual -> 22000ms  drift -> 0ms expected -> 23000ms  actual -> 23001ms  drift -> 1ms expected -> 24000ms  actual -> 24001ms  drift -> 1ms;;0;fix to remove drift from scheduleperiodic;""when implementing the worker scheduler pattern in rxcpp i implemented scheduleperiodic differently because i predicted that the rxjava version would drift once the changes were working i verified my prediction in rxcpp i decided to test the same in rxjava and contribute my approachthis was my test:``` javaimport javautilconcurrenttimeunitimport rxschedulerimport rxschedulersschedulersimport rxfunctionsaction0public class periodic {    public static void main(string args) {        final scheduler scheduler  schedulersimmediate()        final schedulerworker w  schedulercreateworker()        final long initial  timeunitsecondstomillis(2)        final long period  timeunitsecondstomillis(1)        final long start  schedulernow() + initial        wscheduleperiodically(new action0() {            long count  0            @override            public void call() {                long tick  schedulernow()                systemoutprintln(stringformat(""""expected -> %dms actual -> %dms drift -> %dms"""" count*period tick - start tick - (start + (count*period))))                ++count            }        } initial period timeunitmilliseconds)    }}```the existing impl causes this output:```$ java -cp rxjava-core/build/libs/rxjava-core-0183-snapshotjar:/ periodicexpected -> 0ms actual -> 1ms drift -> 1msexpected -> 1000ms actual -> 1002ms drift -> 2msexpected -> 2000ms actual -> 2003ms drift -> 3msexpected -> 3000ms actual -> 3004ms drift -> 4msexpected -> 4000ms actual -> 4005ms drift -> 5msexpected -> 5000ms actual -> 5006ms drift -> 6msexpected -> 6000ms actual -> 6007ms drift -> 7msexpected -> 7000ms actual -> 7008ms drift -> 8msexpected -> 8000ms actual -> 8009ms drift -> 9msexpected -> 9000ms actual -> 9010ms drift -> 10msexpected -> 10000ms actual -> 10011ms drift -> 11msexpected -> 11000ms actual -> 11012ms drift -> 12msexpected -> 12000ms actual -> 12013ms drift -> 13msexpected -> 13000ms actual -> 13014ms drift -> 14msexpected -> 14000ms actual -> 14016ms drift -> 16msexpected -> 15000ms actual -> 15017ms drift -> 17msexpected -> 16000ms actual -> 16018ms drift -> 18msexpected -> 17000ms actual -> 17019ms drift -> 19msexpected -> 18000ms actual -> 18020ms drift -> 20msexpected -> 19000ms actual -> 19021ms drift -> 21msexpected -> 20000ms actual -> 20022ms drift -> 22msexpected -> 21000ms actual -> 21023ms drift -> 23msexpected -> 22000ms actual -> 22023ms drift -> 23msexpected -> 23000ms actual -> 23024ms drift -> 24ms```with this commit the test outputs:```$ java -cp /:/rxjava-core/build/libs/rxjava-core-0183-snapshotjar periodicexpected -> 0ms actual -> 3ms drift -> 3msexpected -> 1000ms actual -> 1001ms drift -> 1msexpected -> 2000ms actual -> 2001ms drift -> 1msexpected -> 3000ms actual -> 3000ms drift -> 0msexpected -> 4000ms actual -> 4001ms drift -> 1msexpected -> 5000ms actual -> 5000ms drift -> 0msexpected -> 6000ms actual -> 6000ms drift -> 0msexpected -> 7000ms actual -> 7000ms drift -> 0msexpected -> 8000ms actual -> 8001ms drift -> 1msexpected -> 9000ms actual -> 9001ms drift -> 1msexpected -> 10000ms actual -> 10001ms drift -> 1msexpected -> 11000ms actual -> 11001ms drift -> 1msexpected -> 12000ms actual -> 12001ms drift -> 1msexpected -> 13000ms actual -> 13001ms drift -> 1msexpected -> 14000ms actual -> 14001ms drift -> 1msexpected -> 15000ms actual -> 15001ms drift -> 1msexpected -> 16000ms actual -> 16001ms drift -> 1msexpected -> 17000ms actual -> 17000ms drift -> 0msexpected -> 18000ms actual -> 18000ms drift -> 0msexpected -> 19000ms actual -> 19000ms drift -> 0msexpected -> 20000ms actual -> 20000ms drift -> 0msexpected -> 21000ms actual -> 21002ms drift -> 2msexpected -> 22000ms actual -> 22000ms drift -> 0msexpected -> 23000ms actual -> 23001ms drift -> 1msexpected -> 24000ms actual -> 24001ms drift -> 1ms```"";""#1077 very nice thanks @kirkshoopwhile considering this i though of something but i havent played with this enough to know exactly how it will behave but if someone chooses an interval of 1ms and the work being done each time takes longer than 1ms what is the expected behavior? we should never have concurrent execution if i understand correctly it will result in a negative delay and result in scheduling it immediately but obviously have drift  || from what i can tell it does the right thing and just delays rather than allow concurrent execution``` javapublic class periodic {    public static void main(string args) {        final scheduler scheduler  schedulersimmediate()        final schedulerworker w  schedulercreateworker()        final long initial  100        final long period  100        final long start  schedulernow() + initial        wscheduleperiodically(new action0() {            long count  0            @override            public void call() {                try {                    threadsleep(1500)                } catch (interruptedexception e) {                }                long tick  schedulernow()                systemoutprintln(stringformat(""""expected -> %dms actual -> %dms drift -> %dms"""" count*period tick - start tick - (start + (count*period))))                ++count            }        } initial period timeunitmilliseconds)    }}``````expected -> 0ms actual -> 1503ms drift -> 1503msexpected -> 100ms actual -> 3009ms drift -> 2909msexpected -> 200ms actual -> 4511ms drift -> 4311msexpected -> 300ms actual -> 6012ms drift -> 5712msexpected -> 400ms actual -> 7513ms drift -> 7113msexpected -> 500ms actual -> 9015ms drift -> 8515ms```based on this im merging this as it is safe in the degraded case while being better in the normal case (work being less time than the interval) || yes that was the behavior before and i kept it there were only two options and skipping a period seemed like the wrong policy to me the user supplies both the function and the period and so they own the behavior (they can return immediately to skip and get back on track or just ensure that the period was sufficient to begin withon may 6 2014 at 9:11 am """"ben christensen"""" <notifications@githubcom<mailto:notifications@githubcom>> wrote:very nice thanks @kirkshoop considering this i though of something but i havent played with this enough to know exactly how it will behave but if someone chooses an interval of 1ms and the work being done each time takes longer than 1ms what is the expected behavior?we should never have concurrent execution if i understand correctly it will result in a negative delay and result in scheduling it immediately but obviously have drift## reply to this email directly or view it on github || this is an excellent improvement im working on something that does microsecond level scheduling and this change makes it work very accurately:```########################################################################################step: 10  interval: 111micros  rate: 9000/s########################################################################################total > success: 315237 error: 0   last 10s > success: 9001/s error: 0/s    latency > 50th: 0  90th: 0  99th: 0  100th: 0total > success: 360280 error: 0   last 10s > success: 9000/s error: 0/s    latency > 50th: 0  90th: 0  99th: 0  100th: 0total > success: 405334 error: 0   last 10s > success: 9001/s error: 0/s    latency > 50th: 0  90th: 0  99th: 0  100th: 0total > success: 450373 error: 0   last 10s > success: 9001/s error: 0/s    latency > 50th: 0  90th: 0  99th: 0  100th: 0```without this change it isnt even close:```########################################################################################step: 10  interval: 111micros  rate: 9000/s########################################################################################total > success: 239363 error: 0   last 10s > success: 6835/s error: 0/s    latency > 50th: 0  90th: 0  99th: 0  100th: 0total > success: 273742 error: 0   last 10s > success: 6869/s error: 0/s    latency > 50th: 0  90th: 0  99th: 0  100th: 0total > success: 308053 error: 0   last 10s > success: 6863/s error: 0/s    latency > 50th: 0  90th: 0  99th: 0  100th: 0total > success: 342820 error: 0   last 10s > success: 6901/s error: 0/s    latency > 50th: 0  90th: 0  99th: 0  100th: 0``` || "";;;;1;1;fix to remove drift from scheduleperiodic;"
1163;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix defer for java 8 type-inference;fixes https://github.com/netflix/rxjava/issues/1157;;0;fix defer for java 8 type-inference;fixes https://githubcom/netflix/rxjava/issues/1157;;;;;1;1;fix defer for java 8 type-inferencefixes https://githubcom/netflix/rxjava/issues/1157;
1164;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;jmh perf tests for schedulers.computation;;;0;jmh perf tests for schedulerscomputation;;;;;;1;1;jmh perf tests for schedulerscomputation;
1175;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fixed synchronous connectableobservable.connect problem;connectableobservable.connect returns a subscription and thus cannot be unsubscribed synchronously  similar how take didn t work before the subscriber changes. this pr modifies the  connectableobservable  and its current implementation  operatormulticast  to extract the connection subscription token before it is connected to the source. cancelling this extracted token makes sure the synchronous connection is unsubscribed.  (the rx.net version of the test case seemingly doesn t exhibit the problem. i suspect it is the interplay of  idisposable s.);;0; synchronous connectableobservableconnect problem;connectableobservableconnect returns a subscription and thus cannot be unsubscribed synchronously similar how take didnt work before the subscriber changes this pr modifies the `connectableobservable` and its current implementation `operatormulticast` to extract the connection subscription token before it is connected to the source cancelling this extracted token makes sure the synchronous connection is unsubscribed(the rxnet version of the test case seemingly doesnt exhibit the problem i suspect it is the interplay of `idisposable`s);#1089 ;;;;1;1; synchronous connectableobservableconnect problem;
1183;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;notificationlite.accept performance improvements;this is a proposal for speeding up the  accept()  method (i.e.  reducing its latency).  benchmark comparison:  direct onnext: 488 mops/s master accept: 378 mops/s this accept: 477 mops/s  (i7 4770k  jdk 1.8u5 x64);;0;notificationliteaccept performance improvements;this is a proposal for speeding up the `accept()` method (ie reducing its latency)benchmark comparison:direct onnext: 488 mops/smaster accept: 378 mops/sthis accept: 477 mops/s(i7 4770k jdk 18u5 x64);#1094 ;;;;1;1;switch to direct accept and no instanceof;
1185;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;behavior subject time gap fix 2;based on discussions in #1181  i ve unified the behavior among the subjects.  behaviorsubject doesn t seem to exhibit issue #658 and #1184.  a second pair of eyes would be great to confirm the correctness and check if the removal of the countdownlatch was the correct approach.;;1181.0;behavior subject time gap fix 2;based on discussions in #1181 ive unified the behavior among the subjectsbehaviorsubject doesnt seem to exhibit issue #658 and #1184a second pair of eyes would be great to confirm the correctness and check if the removal of the countdownlatch was the correct approach;#1095 wow this is quite the change :-) i need fresher eyes on this one so will come back to it thank you very much for tackling this! || this is non-trivial code so i may have missed something but this looks like excellent forward progress on what we had to add the functionality needed for `behaviorsubject` and sharing the logic across all of the `subject` implsvery nice work ||;behavior subject time gap fix;this fix should make sure subscribing between two event emissions wont create a gap in the received events i had to implement my own subscription management to ensure the required coordination behavior performance comparison for simple pass-through behavior:publishsubject (master) ~86 mops/sbehaviorsubject (master) ~47 mops/sbehaviorsubject (this) ~46 mops/sthe relative slowness compared to ps is due the volatile write on each element and the additional ~1mops/s is due to the subscription coordination;#1092  > i had to implement my own subscription management to ensure the required coordination behaviorcan this really not be done with `subjectsubscriptionmanager`? having it be different makes an already complicated set of logic now be implemented in two different wayswhy would the others not benefit from the same improvements? || its more like an augmentation than an improvement over the existing subject subscription management at first glance id need to add 1-2 callback points to an already complicated ssm i cant say for sure until i try to reimplement the other subjects and see what are the common points || id rather not proceed with this change until we know the implications across all of them its hard enough working with subjects without 2 slightly different implementations of the same thing || closing this as outdated see #1185 for the new proposal ||;1;0;unified the subject management;
"1185;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;behavior subject time gap fix 2;based on discussions in #1181  i ve unified the behavior among the subjects.  behaviorsubject doesn t seem to exhibit issue #658 and #1184.  a second pair of eyes would be great to confirm the correctness and check if the removal of the countdownlatch was the correct approach.;;1184.0;behavior subject time gap fix 2;based on discussions in #1181 ive unified the behavior among the subjectsbehaviorsubject doesnt seem to exhibit issue #658 and #1184a second pair of eyes would be great to confirm the correctness and check if the removal of the countdownlatch was the correct approach;#1095 wow this is quite the change :-) i need fresher eyes on this one so will come back to it thank you very much for tackling this! || this is non-trivial code so i may have missed something but this looks like excellent forward progress on what we had to add the functionality needed for `behaviorsubject` and sharing the logic across all of the `subject` implsvery nice work ||;behaviorsubject concurrent subscription and sending is broken;behaviorsubject should ensure that the last notification always reaches the subscriber when the subscription and sending happens concurrently there is a high probability that this property gets brokentest has been prepared that easily reproduces the error test involves two threads: 1) trying to subscribe 2) trying to send next these are carefully coordinated to allow real concurrent execution the test is that the subscriber must receive the sent value the issue almost certainly happens in a few hundred retriesnote that with a [`threadsleep(1)`]( the issue goes awaynote that the test is something i distilled from what i saw in my production code there may be little issues with it but the concurrency problem certainly exists as it is reproducibly just by stepping through the code;""thanks for the test case im currently improving the behaviorsubject and the new code passes this test || @andrask  this has been merged to master if you can validate against that prior to release? || the tests in  are passing for me closing this out as it looks   please re-open if its not and can be demonstrated id still appreciate confirmation if you can || @benjchristensen thank you for the notice i wanted to try today but got overwhelmed by other stuff i cloned the repo and started installing with `gradlew install` but the process stopped at a lib it couldnt download and i didnt have more time to debug the reason ill try again tomorrow with different network settings im sure the issue is with my setup fortunately removing the current workaround from the code is quite easy so it will be simple to see whether this workedsadly i use hystrix as well which makes it hard to apply the new rxjava version even if it comes out some time in the near future || thanks @andrask hystrix 1316+ and hystrix 14+ should both be fully compatible with the current set of changes as both of those support rxjava 018+ since i work on both projects im keeping hystrix moving forwardis there anything specific about hystrix + rx that isnt working well that i can solve? || i confirm that the new version worksthe combo works well ill check again why i wasnt able to upgrade the last time i think i only upgraded rx and this is why it failed || thanks for confirming yes hystrix had to be upgraded to work it is no longer using any deprecated rx code so should be safe as were nearing the end of changes and almost to 10 || im still seeing some concurrency issue between the subscription and the emission of the first objectwhen those 2 things happen at the very same time the subscriber doesnt observe the initial emissionis there any remaining known issue? || this is expected behaviorif you you write to the subject from multiple threads and need consistency of `on*()` events -> you can convert your subject to `serializedsubject` via `subjecttoserialized()`javadoc of `subjecttoserialized()`:``` java/** * wraps a {@link subject} so that it is safe to call its various {@code on} methods from different threads * <p> * when you use an ordinary {@link subject} as a {@link subscriber} you must take care not to call its  * {@link subscriber#onnext} method (or its other {@code on} methods) from multiple threads as this could  * lead to non-serialized calls which violates * <a href"""" observable contract</a> and creates an * ambiguity in the resulting subject * <p> * to protect a {@code subject} from this danger you can convert it into a {@code serializedsubject} with * code like the following: * <p><pre>{@code * mysafesubject  myunsafesubjecttoserialized() * }</pre> *  * @return serializedsubject wrapping the current subject */``` || subscription is not an on\* method and therefore this is not expectedon tue may 24 2016 at 7:38 pm artem zinnatullin notifications@githubcomwrote:> this is expected behavior> > if you you write to the subject from multiple threads and need consistency> of on*() events -> you can convert your subject to serializedsubject via> subjecttoserialized()> > javadoc of subjecttoserialized():> > /*\* \* wraps a {@link subject} so that it is safe to call its various {@code on} methods from different threads \* <p> \* when you use an ordinary {@link subject} as a {@link subscriber} you must take care not to call its  \* {@link subscriber#onnext} method (or its other {@code on} methods) from multiple threads as this could  \* lead to non-serialized calls which violates \* <a href"""" observable contract</a> and creates an \* ambiguity in the resulting subject \* <p> \* to protect a {@code subject} from this danger you can convert it into a {@code serializedsubject} with \* code like the following: \* <p><pre>{@code \* mysafesubject  myunsafesubjecttoserialized() \* }</pre> \*  \* @return serializedsubject wrapping the current subject */> > > you are receiving this because you are subscribed to this thread> reply to this email directly or view it on github>  || well its hard to divide `subscribe()` and setting of initial value (which is `~onnext`) for mewhat i see at the moment:1 current implementation of `behaviorsubjectcreate(defaultvalue)` sets default value to `volatile object latest` field of `subjectsubscriptionmanager`2 when you call `onnext()` it also sets new value to that `volatile` field without any synchronization 3 when you `subscribe()` it wont start with `defaultvalue` that youve passed as initial but it will emit that `volatile latest` state instead -> that leads to the effect that @sregg seesand now im not sure that `toserialized()` will help with initial value because even though it synchronizes `onnext` emission of the default value goes trough different lock object and still may happen concurrently with `onnext`@sregg as temporary solution you can try to create `behaviorsubject` **without** default value convert it `toserialized()` and set default value via `onnext` before giving reference to the subject to other threads this should give you threading consistency you want to achieveprobably we need to define this behavior better either in javadoc or even change current impementation to emit `default` initial value first and only then emit `volatile latest`@akarnokd will be great to get your comment here! || im sorry when i said """"initial"""" value i wanted to say """"first"""" value (first `onnext`) not the default value you pass in `create()` || oh thats better then `toserialized()` should be enough for you!but the problem still remains: we need to define serialized behavior for initial value passed to `subjectcreate()` @akarnokd /other contributors: maybe create separate issue for that if you think it worth it? || also im using `asobservable` on my `behaviorsubject` not sure if that changes anything (and im not sure why im using `asobservable` either) || but i thought `toserialized` was fixing concurrency issues between 2 `onnext/onerror/oncomplete` from 2 different threads it doesnt say anything about concurrency issues between subscription and onnext || that doesnt change anything significant it simply _hides_ actual type of the `observable` for consumers so they wont be able to simply cast your `observable` to `behaviorsubject`/etc || > im still seeing some concurrency issue between the subscription and the emission of the first object> when those 2 things happen at the very same time the subscriber doesnt observe the initial emission> is there any remaining known issue?can you demonstrate this with an unit test?currently there is a bug with `behaviorsubject` that when started out empty a concurrent subscription with an `onnext` may result in receiving the same value twice - but this doesnt sound like your case``` javaint n  100000schedulerworker w  schedulerscomputation()createworker()try {    for (int i  0 i < n i++) {        if ((i % 100)  0) {            systemoutprintln(""""round """" + i)        }        atomicinteger cdl  new atomicinteger(2)        atomicboolean done  new atomicboolean()        behaviorsubject<integer> bs  behaviorsubjectcreate()        testsubscriber<integer> ts  new testsubscriber<>()        wschedule(() -> {            cdldecrementandget()            while (cdlget() ! 0)             bsonnext(1)            doneset(true)        })        cdldecrementandget()        while (cdlget() ! 0)         bssubscribe(ts)        while (!doneget())         int c  tsgetonnextevents()size()        if (c  0) {            assertfail(""""the testsubscriber didnt receive any values"""")        }    }} finally {    wunsubscribe()}```note that if a `behaviorsubject` is completed the cached value if any wont be available anymore so you may end up with no values but a terminal event in the subscriber || right thats probably whats happening im calling `oncomplete()` right after `onnext()`heres my setup:i wrapped a class that does asynchronous stuff with rx javathat class needs a callback listener in its constructor and has a method to trigger an action if that method is called it will do the action in a different thread and send the result back to me via the callback listeneri wrapped this asynchronous behavior using a `behaviorsubject` heres the pseudo code:```public class wrapper implements wrappedlistener {  private wrapped wrapped  private behaviorsubject<result> behaviorsubject  public wrapper() {    wrapped  new wrapped(this)    behaviorsubject  behaviorsubjectcreate()  }  public observable<result> getwrappedobservable() {    wrappeddoaction()    return behaviorsubjectasobservable()  }  @override  public void callback(result result) {    behaviorsubjectonnext(result)    behaviorsubjectoncompleted()  }}```the problem is that the async action can be so quick to execute it will call the callback right away and some times before or during the subscription of the observablei managed to fix this by delaying the call of the `doaction()` call in `doonsubscribe()`:```  public observable<result> getwrappedobservable() {    return behaviorsubjectasobservable()        doonsubscribe(() -> {            wrappeddoaction()        })  }```is there a better way to do so? || if you have only one value to relay use `asyncsubject` || good to know but would that fix my concurrency issue? || seems that my idea of delaying the action in `doonsubscribe` still doesnt fix the issuenow im thinking theres something wrong between `onnext` and `oncomplete` sometimes only `oncomplete` is received || "";1;0;unified the subject management;"
1185;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;behavior subject time gap fix 2;based on discussions in #1181  i ve unified the behavior among the subjects.  behaviorsubject doesn t seem to exhibit issue #658 and #1184.  a second pair of eyes would be great to confirm the correctness and check if the removal of the countdownlatch was the correct approach.;;658.0;behavior subject time gap fix 2;based on discussions in #1181 ive unified the behavior among the subjectsbehaviorsubject doesnt seem to exhibit issue #658 and #1184a second pair of eyes would be great to confirm the correctness and check if the removal of the countdownlatch was the correct approach;#1095 wow this is quite the change :-) i need fresher eyes on this one so will come back to it thank you very much for tackling this! || this is non-trivial code so i may have missed something but this looks like excellent forward progress on what we had to add the functionality needed for `behaviorsubject` and sharing the logic across all of the `subject` implsvery nice work ||;behaviorsubject race condition;need to investigate the `behaviorsubject` as it likely has the same problem as rxnet as reported here:  that `subjects` were just re-implemented but kept the same behavior and for the `behaviorsubject` the race between returning the current value and subscribing for subsequent values appears to be wronguse case:```onnext: 1 2 3 4 5 6 7 8 9observer: subscribe between 3 & 4  should receive 3 4 5 6 7 8 9```the likely bug is that in a race it could receive `3 6 7 8 9`;there are a few missing suggestions that i didnt have in my pr which also involves behaviorsubject ill take a look at this as welledit: yes this can happen if an observer subscribes it immediately gets the current value then it is eventually added to the state object via `addobserver` which add could be delayed and values lostedit 2: how to avoid it:- one would need to block onnext while a subscription is happening which would negate the improvements - include the lastnotification in the state so a new observed value triggers a state replace similar to when an observer subscribes however one would need 2 states: active and modifying: this avoids using a lock similar to how `abstractatomicsubscription` allows complex operations in the mutating statei thought about the queue/drain suggestion in the article but i cant see it solving the value skip problem (it surely acts against reordering if there happen to be concurrent onnext calls - but we dont allow / ignore those by contract) || the queue/drain approach can be adapted to also ensure you dont miss notifications all you have to do is _queue the subscription as well_ (queue/drain is a fully general synchronization mechanism akin to using an actor)note that if you do this the initial value may not arrive immediately if the behavior subject is being touched on another thread but it can be  by introducing a second queue specific to the subscription that was initialized with the latest value while atomically subscribingso a no-deadlock no-reorder no-thread-hopping-for-initial-value subscription would look like:```initialvaluesent  falsemisseddraincount  0create drain queue q for subscriptionsync(this) {    add observer to {        enqueue new value onto q        sync(q) {            // other threads must not push initial value            if (!initialvaluesent) {                misseddraincount++            }        }        trydrain q    }    enqueue current value onto q}// forward value to caller before returning (and perhaps some later values too)trydrain q// --- allow other threads to forward future values ---sync(q) {    initialvaluesent  true}// in case observers were enqueueing while we set the flag// (pretty sure reading misseddraincount is safe to touch without locking now)// (this can be done without the loop but requires modifying the q to drain n)while (misseddraincount-- > 0) {    trydrain q}```i think thats right just off the top of my head though || if youre willing to allow the initial value to thread-hop its a lot simpler of course:```subscribe:    enqueue {        add observer    }    trydrainsend:    enqueue {        send to all observers    }    trydrain```(assuming youre using the queue as your only synchronization mechanism if youre also using locks you probably need to lock around the enqueues)_edit_ fixed enqueueing inside add observer instead of inside send || i think this is still an unsolved problem do we still want to put effort into this? || i was thinking about trying to solve it similar to the `groupby` solution but havent spent the time to determine if it can be made to work || ive implemented a potential fix [here]( but cant create a pr right now due to a github 500 error  a simple publish benchmark for publishsubject is 83 mops/s behaviorsubject (new) ~47mops/s behaviorsubject (master) is ~48 mops/sec || fix just ;1;0;unified the subject management;
"1195;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;swingscheduler: allow negative schedule;fix for issue #1193   the new  scheduleperiodic  may calculate negative delay times if the next task was already due. this change will allow negative timing on the swing scheduler indicating an immediate schedule.;;1193.0;swingscheduler: allow negative schedule;fix for issue #1193 the new `scheduleperiodic` may calculate negative delay times if the next task was already due this change will allow negative timing on the swing scheduler indicating an immediate schedule;""#1106 i suggest adding some comments in the `schedulerschedule` and `schedulescheduleperiodically` about negative timing eg """"negative delay time should be regarded as 0"""" it would be helpful for anyone who wants to implement special `scheduler` || ive added extra comments || #1109 "";illegalargexception when using swingscheduler;""i occasionally get this exception when using rx for swing tasks im not specifically using the swingscheduler so i assume its being used automatically? not sure if its relevant but i currently have one observable using a delay of 20msexception in thread """"awt-eventqueue-0"""" javalangillegalargumentexception: the swing timer only accepts non-negative delays up to 2147483647 milliseconds    at rxschedulersswingschedulerassertthatthedelayisvalidfortheswingtimer(swingschedulerjava:139)    at rxschedulersswingscheduleraccess$100(swingschedulerjava:36)    at rxschedulersswingscheduler$innerswingschedulerschedule(swingschedulerjava:68)    at rxscheduler$worker$1call(schedulerjava:110)    at rxschedulersswingscheduler$innerswingscheduler$1executeonceactionactionperformed(swingschedulerjava:83)    at javaxswingtimerfireactionperformed(timerjava:313)    at javaxswingtimer$doposteventrun(timerjava:245)    at javaawteventinvocationeventdispatch(invocationeventjava:311)    at javaawteventqueuedispatcheventimpl(eventqueuejava:744)    at javaawteventqueueaccess$400(eventqueuejava:97)    at javaawteventqueue$3run(eventqueuejava:697)    at javaawteventqueue$3run(eventqueuejava:691)    at javasecurityaccesscontrollerdoprivileged(native method)    at javasecurityprotectiondomain$1dointersectionprivilege(protectiondomainjava:75)    at javaawteventqueuedispatchevent(eventqueuejava:714)    at javaawteventdispatchthreadpumponeeventforfilters(eventdispatchthreadjava:201)    at javaawteventdispatchthreadpumpeventsforfilter(eventdispatchthreadjava:116)    at javaawteventdispatchthreadpumpeventsforhierarchy(eventdispatchthreadjava:105)    at javaawteventdispatchthreadpumpevents(eventdispatchthreadjava:101)    at javaawteventdispatchthreadpumpevents(eventdispatchthreadjava:93)    at javaawteventdispatchthreadrun(eventdispatchthreadjava:82)"";""do you have any periodic tasks ie using `scheduleperiodic` somewhere? || i had a """"delay"""" in there but no periodic tasks || i believe #1195  this please re-open if it is still an issue || "";1;0;comment explaining non-positive delay values;"
1223;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;replaysubject enhancement with time and/or size bounds;reapplied the enhancements to bring size and/or time bound  replaysubject  capabilities while exposing a single subject class (i.e.  no separate boundedreplaysubject or customreplaysubject). it now uses the renewed  subjectsubscriptionmanager .  in addition  i ve moved a confusing behavior from subjectobserver into asyncsubject where it belongs.;;0;replaysubject enhancement with time and/or size bounds;reapplied the enhancements to bring size and/or time bound `replaysubject` capabilities while exposing a single subject class (ie no separate boundedreplaysubject or customreplaysubject) it now uses the renewed `subjectsubscriptionmanager`in addition ive moved a confusing behavior from subjectobserver into asyncsubject where it belongs;#1130  thank you for this refactor  it looks like it was tedious!just a simple question above and then will merge ||;;;;1;1;replaysubject enhancement with time and/or size bounds;
1224;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implement shorter toblocking as shorter alias for toblockingobservable.;1220;;0;implement shorter toblocking as shorter alias for toblockingobservable;1220;#1131  i s this really causing you pain? autocomplete will type the few extra characters for you when reading code toblockingobservable should stand out like a sore thumb danger || @headinthebox actually not for me but for our users 99% of them are on blocking-type applications and will need to call that often even in unit tests it is very long and doesnt help with readabilityso im all in for a shorter version  || i think `toblocking()` still sufficiently signals what is going on we dont need the `observable` name everywhere people already know its an `observable` also this is more similar to how we will likely someday implement `toparallel()` which would return a `parallelobservable` || i wont block this -) just want to make sure people understand that blocking defeats the purpose of rx || yes it certainly does  but what ive found is that enabling an api with rx is made far easier when we can give people who arent ready to adopt async an easy way out an api can always go from async to sync but not sync to async so anything that removes roadblocks to getting async apis in place is helpful  || i kind of wish we didnt have `toblockingobservable` after this change but thats a massive breaking changes for a lot of codebases so i think well just live with the alias || should we deprecate `toblockingobservable` and delete in a release or two or keep them both forever? || i guess so too many aliases indicate indecisiveness of the api designers -) || exactly  || done in  ||;;;;1;1;implement shorter toblocking as shorter alias for toblockingobservable1220;
1228;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;git reformats this file;;;0;git reformats this file;;;;;;1;1;git reformats this file;
1229;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;remove ambiguous subscribe overloads with scheduler;- fixes  - these should never have been added  the subscribeon operator already provides this functionality;;0;remove ambiguous subscribe overloads with scheduler;- fixes  these should never have been added the subscribeon operator already provides this functionality;;;;;1;1;remove ambiguous subscribe overloads with scheduler- fixes  these should never have been added the subscribeon operator already provides this functionality;
1231;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator alias: share;as per discussion in #682;;0;operator alias: share;as per discussion in #682;#1133;;;;1;1;operator alias: share;
1232;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;adopt limit and foreach java 8 naming conventions;as per discussion at   code now can look like this:      java observable.from(1  2  3).limit(2).foreach(system.out::println)       as an alias to this:      java observable.from(1  2  3).take(2).subscribe(system.out::println);;0;adopt limit and foreach java 8 naming conventions;as per discussion at  now can look like this:``` javaobservablefrom(1 2 3)limit(2)foreach(systemout::println)```as an alias to this:``` javaobservablefrom(1 2 3)take(2)subscribe(systemout::println)```;#1134 ;;;;1;1;foreach aliases to subscribe to match java 8 conventionas per discussion at  like this is now supported:```javaobservablefrom(1 2 3)foreach(systemout::println)observablefrom(1 2 3)toblocking()foreach(systemout::println)```;
1233;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;deprecate toblockingobservable in favor of toblocking;as per discussion at   this will better match  toparallel  and is shorter to use while still being clear as to what is happening.;;0;deprecate toblockingobservable in favor of toblocking;as per discussion at  will better match `toparallel` and is shorter to use while still being clear as to what is happening;#1135 ;;;;1;1;deprecate toblockingobservable in favor of toblockingas per discussion at https://githubcom/netflix/rxjava/pull/1224#issuecomment-43658284;
"1235;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;lock-free  mpsc-queue based  fast-path serializing observer.;i ve rewritten the  serializedobserver  to improve performance. it is now lock-free  uses a multiple-producer-single-consumer queue based on netty s implementation and employs a fast-path logic for single-threaded write-through.  benchmarked by measuring how fast 500k integers can get through it  if running 1-8 producers at the same time. for a single threaded case  master gives about 18 mops/s  this implementation gives ~36 mops/s (would be ~16 mops/s on the slow path). for producers > 2  master gives ~5.5 mops/s and this gives ~11.5 mops/s. for 2 producers  aka 1 producer - 1 consumer  master gives ~4.5 mops and this gives ~8.5 mops/s.  the two new class   paddedatomicinteger  and  mpscpaddedqueue  will come in handy with other lock-free structures such as schedulers  etc. we may consider adding back the  rx.util  or some other sub-package to store these helper classes: they don t need to be part of the public api but can be left  public  to enable cross-package access internally.  things i learned during the implementation: - it is worth padding the wip counter to fit a cache line so the constant cache thrashing won t affect the parent class  other fields  most likely. - using fieldupdaters saves space but  sun.misc.unsafe  can add 8-10% more throughput. to avoid platform issues  i stayed with the fieldupdaters. - using  getandincrement  and  decrementandget  are intrinsified in java 8 and are compiled to a single x86 instruction  which generally outperforms any cas loop. same is true for the  getandset . - padding out the  tail  in the  mpscpaddedqueue  again helps separate producers trashing on the tail and a consumer reading the head. without it  the throughput would decrease by about ~1.5 mops/s - by adding the fast-path logic  the single-threaded throughput increases by a factor of 2 since it avoids an unnecessary enqueue and dequeue and all associated volatile writes. however  if taking the fast-path fails  it incurs extra cost on the slow path for everyone else because of the +1 failed cas at the start. to fix this case  i ve introduced a flag that enables and disables fast-path. to disable the fast path  the active fast path checks if it was able to change wip to zero. if not  it means there was concurrent access and continues on the emission loop path  but disables the fast-path then on. it is basically a detector for concurrent use. since such concurrent use may be transient  the loop counts how many elements it had to emit  an if it was only 1 or 2  it reenables the fast-path. this limit is the result of trying several values with the benchmark above. - the fast-path logic has its weak spot in 2 producer case compared to a plain mpsc queue running in spsc mode  the latter gives about ~11 mops/s which is better than this implementation s ~8.5 mops/s. in contrast  the single-treaded use for the plain mpsc is only ~16 mops/s. both implementations perform the same if producers > 2. therefore  i decided it is more worth having an implementation that is weak for 2 producers but otherwise is as good or outperforms the alternatives. note that if one knows the number of producers up front  one can create a more specialized implementation  but this is not the case with rxjava operators. this may affect  merge  and co which serialize multiple sources. note however  that if the source speed isn t that high as in the benchmark  this implementation still provide less latency than the alternatives because the fast-path would be most likely open if the source emission is interleaved.;;0;lock-free mpsc-queue based fast-path serializing observer;ive rewritten the `serializedobserver` to improve performance it is now lock-free uses a multiple-producer-single-consumer queue based on nettys implementation and employs a fast-path logic for single-threaded write-throughbenchmarked by measuring how fast 500k integers can get through it if running 1-8 producers at the same time for a single threaded case master gives about 18 mops/s this implementation gives ~36 mops/s (would be ~16 mops/s on the slow path) for producers > 2 master gives ~55 mops/s and this gives ~115 mops/s for 2 producers aka 1 producer - 1 consumer master gives ~45 mops and this gives ~85 mops/sthe two new class `paddedatomicinteger` and `mpscpaddedqueue` will come in handy with other lock-free structures such as schedulers etc we may consider adding back the `rxutil` or some other sub-package to store these helper classes: they dont need to be part of the public api but can be left `public` to enable cross-package access internallythings i learned during the implementation:- it is worth padding the wip counter to fit a cache line so the constant cache thrashing wont affect the parent class other fields most likely- using fieldupdaters saves space but `sunmiscunsafe` can add 8-10% more throughput to avoid platform issues i stayed with the fieldupdaters- using `getandincrement` and `decrementandget` are intrinsified in java 8 and are compiled to a single x86 instruction which generally outperforms any cas loop same is true for the `getandset`- padding out the `tail` in the `mpscpaddedqueue` again helps separate producers trashing on the tail and a consumer reading the head without it the throughput would decrease by about ~15 mops/s- by adding the fast-path logic the single-threaded throughput increases by a factor of 2 since it avoids an unnecessary enqueue and dequeue and all associated volatile writes however if taking the fast-path fails it incurs extra cost on the slow path for everyone else because of the +1 failed cas at the start to fix this case ive introduced a flag that enables and disables fast-path to disable the fast path the active fast path checks if it was able to change wip to zero if not it means there was concurrent access and continues on the emission loop path but disables the fast-path then on it is basically a detector for concurrent use since such concurrent use may be transient the loop counts how many elements it had to emit an if it was only 1 or 2 it reenables the fast-path this limit is the result of trying several values with the benchmark above- the fast-path logic has its weak spot in 2 producer case compared to a plain mpsc queue running in spsc mode the latter gives about ~11 mops/s which is better than this implementations ~85 mops/s in contrast the single-treaded use for the plain mpsc is only ~16 mops/s both implementations perform the same if producers > 2 therefore i decided it is more worth having an implementation that is weak for 2 producers but otherwise is as good or outperforms the alternatives note that if one knows the number of producers up front one can create a more specialized implementation but this is not the case with rxjava operators this may affect `merge` and co which serialize multiple sources note however that if the source speed isnt that high as in the benchmark this implementation still provide less latency than the alternatives because the fast-path would be most likely open if the source emission is interleaved;""#1136  one additional node it is possible the jvm will eliminate the `serialized` part in the masters `serializedobserver` and thus giving the througput of 40-100 mops/s i usually get this effect if i run the test with 2m values the 500k above was chosen to avoid this optimization unfortunately one cant win against or replicate this behavior from within java || your research on this is awesome i look forward to playing with this queue implementation and seeing its performance compared to alternativeshowever this slows down the normal non-contended use cases:with mpsc```ruperftransformsflatmaptransformsusingfrom        1  thrpt         5  4093463403   158457270    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5    11767693      252340    ops/s```master branch```ruperftransformsflatmaptransformsusingfrom        1  thrpt         5  4729230173    99504604    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5    12648153      105077    ops/s```test using:```/gradlew benchmarks -pjmh-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 5 -prof gc *perftransformsflatmaptransformsusingfrom*```i dont think `serializedobserver` is the right candidate for non-blocking/lock-free due to the reasons we discussed a couple months ago in  and  particularly this conclusion:> the """"queue and lock"""" model performs well in the non-contended case and under contention despite not being a very elegant solution and requiring the use of mutex locks for the state changes (but it does not hold the locks during notification)this applies in this case because we are not exchanging events between threads we are actively trying to not do thata high-performance queue (particularly of the lock-free kind) will make great sense however in places such as `observeon` and/or `scheduler` implementations where it has a producer thread and a consumer thread such as discussed in     suggest we get this queue and counter into `rxinternalutil` and start performance testing them as replacements everywhere were using a queue i would for now leave `serializedobserver` alone as we spent a lot of time on that before with at least 3 different implementations and came to the conclusion that the jvm can do a better job for that use case than we can || here is my branch where i merged this pr and moved the code into `rxinternalutil` along with a readme file:  || by the way ill spend more time testing the contended cases dont close this pr im not done reviewing it all  || the jvm can remove a synchronized block if it detects a single-threaded use i cant compete with that by using atomics this is a tradeoff scenario: get very fast synchronous behavior or get double throughput in contended case if we value the fast synchronous behavior more then there is no need to go atomic just make sure we dont use wait/notify || i know that we determined that in #1190 if were going to change the decision on what tradeoff to make then we need to go back and revisit why we made the decision we didthe expected common case is when there is not contention because of how `flatmap` is done everywherei think we need a broader set of use cases to determine which direction the tradeoff should be made || this was automatically closed as i merged the queue implementation we still need to finish discussing the serializedobserver part  || i have my doubts now some simple benchmarks show improvements other jmh benchmarks dont without industrial use cases i think synchronized constructs are enough because if either low contention or single thread use in the latter jvm optimizations will always win for example i tried double checked locking with composite and barely got 10mops/s the current version gives 13gops/s if run within a 100k loop long enough || i think if in doubt lets just not outsmart the jvm :) || here is an adhoc conversation on twitter with some experts in this:  like to improve our perf testing and have cases for uncontended normal occasional contention and highly contended and test it in a few places ill do the upgrade of jmh today so we have the latest code once i have those in place ill put it out there for review and guidance || for what it is worth i find the statemachine approach leads to hard to read code so if there is no obvious win id go for simple || "";;;;1;1;lock-free mpsc-queue based fast-path serializing observer;"
"1236;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;compositesubscription with atomic field updater;this pr is aimed at #1204 to reduce unnecessary memory overhead in frequently used classes. this change in  compositesubscription  saves about 24 bytes per instance.  in addition  the field updaters may be faster by about 8-15% for small adds and removals. i ve changed the implementation of unsubscribe to use getandset which leverages platform intrinsics and is usually compiled to a single instruction: this makes unsubscribing a tiny bit faster and thus reducing latency in benchmarks that only pass on single element around.;;1204.0;compositesubscription with atomic field updater;this pr is aimed at #1204 to reduce unnecessary memory overhead in frequently used classes this change in `compositesubscription` saves about 24 bytes per instancein addition the field updaters may be faster by about 8-15% for small adds and removals ive changed the implementation of unsubscribe to use getandset which leverages platform intrinsics and is usually compiled to a single instruction: this makes unsubscribing a tiny bit faster and thus reducing latency in benchmarks that only pass on single element around;#1137 ;profiling memory usage and object creation;we need to spend time profiling memory and object allocation and finding places where we can improve i would really appreciate help diving into this and finding problem areas even if you dont fix them but just identity use cases operators etc that would be very valuablethis is partly a result of the fact that in netflix production we have seen an increase in younggen gcs since 017xthe areas to start should probably be:- observablecreate- observablelift- subscriber- compositesubscription- map- flatmapif you can or want to get involved in this please comment here so we all can collaborate together;""the most likely source of garbage is the `compositesubscription`: whenever a task is scheduled or a new merge-source appears the state transition creates a new state object and copies the subscription array pr #1145 reduces the amount of garbage by switching to hashset on a larger composite since flatmap->mergemap->merge needs to track the active inner subscriptions it uses a composite as well and would gain the same benefits || the `hashset` change shouldnt kick in though because these arent generally large lists (handful at most not hundreds) i expect its just far too many of them being created || ill also like to help out here since its crucial for our uses as well  || thanks @daschl id appreciate your help profiling and identifying hot spots is what we need most right now || i did some gc profiling of my test workloads and id also like to nominate:- blockingobservable (it seems that especially in the single() case its not optimized)- observablesubscribe (for both observer and subscriber) - in my gc logs they take up 40% of the overall gc pressurethe bad news is that i had to fall back out of observables to plain execution on the hot code path (aside from the overall wrapping observable) because also using it in the path produces way too much garbage (moving away from rx in the hot code path got my throughput from 20% to 80% according to the gc logs) and it correlates with my findings since i could not sustain constant io throughput because of full gcs happening way too frequently || > observablesubscribe (for both observer and subscriber)not surprised on this were you able to identify what the garbage is?  || i did some changes in my code and will re-profile and post the results here so we get better measurements here is a slightly older profile run which might give you a hint or two![screen shot 2014-05-20 at 10 13 10]( shot 2014-05-20 at 10 13 00]( || we can definitely improve on the `atomicreference` by using atomicfieldupdater the others will require more effort to analyze along with sample code to see whats triggering them || i think that many `atomicreference` come from mostly the `compositesubscription` instances || i went back in history to 0161 to compare performance of the basic `map`/`flatmap` behavior and found that current master is faster this fits what i had expected of the work of the past couple months which means its not an obvious glaring issue (unless my test is completely flawed)here is the code for the test:- branch 016 >  master >  results#### 016```benchmark                                       (size)   mode   samples         mean   mean error    unitsruperftransformsflatmaptransformsusingfrom        1  thrpt         5  2421210583    68845966    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5     1017787       73597    ops/sruperftransformsflatmaptransformsusingjust        1  thrpt         5  2398541067    90703197    ops/sruperftransformsflatmaptransformsusingjust     1024  thrpt         5      990623      100735    ops/sruperftransformsmaptransformation                 1  thrpt         5  4020548060   262841500    ops/sruperftransformsmaptransformation              1024  thrpt         5    16205747      352618    ops/s```#### master```benchmark                                       (size)   mode   samples         mean   mean error    unitsruperftransformsflatmaptransformsusingfrom        1  thrpt         5  3184873133   172320420    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5     9079937      343905    ops/sruperftransformsflatmaptransformsusingjust        1  thrpt         5  3411785677    73767161    ops/sruperftransformsflatmaptransformsusingjust     1024  thrpt         5    10860963      294309    ops/sruperftransformsmaptransformation                 1  thrpt         5  7208334997   703327745    ops/sruperftransformsmaptransformation              1024  thrpt         5    18720797      278529    ops/s```### gcon the master branch test im seeing gc results like this:```iteration   5: 3189218350 ops/s          gc | wall time  5001 secs  gc time  0047 secs gc%  094% gc count  +98iteration   5: 9198700 ops/s          gc | wall time  5002 secs  gc time  0048 secs gc%  096% gc count  +98```versus 016```iteration   5: 2420099017 ops/s          gc | wall time  5000 secs  gc time  0046 secs gc%  092% gc count  +96iteration   5: 993867 ops/s          gc | wall time  5001 secs  gc time  0100 secs gc%  200% gc count  +212```### summaryunless im mistaken current code is better:- similar gc behavior on `observable` with 1 item better gc behavior with 1024 items- higher ops/second on all of the map/flatmap testsill start profiling this and improve  but this does not reveal the source of the problems seen possibly its related to schedulers or its a specific operator i exercised `map` `flatmap` (and thus `merge`) `observable` and `subscribe` here to get the most fundamental ones || the `observeon` test shows the cost of scheduling  particularly `observable`s of a single item``` java    @generatemicrobenchmark    public void observeon(usecaseinput input) throws interruptedexception {        inputobservableobserveon(schedulerscomputation())subscribe(inputobserver)        inputawaitcompletion()    }``````ruperfobserveonobserveon        1  thrpt         5   457830180     9943221    ops/sruperfobserveonobserveon     1024  thrpt         5    14496430      518463    ops/s```thus with an `observable` of 1 item we can do 457k onnext/second with an `observable` of 1024 items we can do 148million onnext/second (145k \* 1024) || by the way all testing is just being done on my mac laptop  so these numbers are all relative and not representative of proper server hardware || converting from `atomicreference` to `atomicreferencefieldupdater` improved performance from this:```benchmark                                       (size)   mode   samples         mean   mean error    unitsruperftransformsflatmaptransformsusingfrom        1  thrpt         5  3184873133   172320420    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5     9079937      343905    ops/sruperftransformsflatmaptransformsusingjust        1  thrpt         5  3411785677    73767161    ops/sruperftransformsflatmaptransformsusingjust     1024  thrpt         5    10860963      294309    ops/sruperftransformsmaptransformation                 1  thrpt         5  7208334997   703327745    ops/sruperftransformsmaptransformation              1024  thrpt         5    18720797      278529    ops/s```to this:```benchmark                                       (size)   mode   samples         mean   mean error    unitsruperftransformsflatmaptransformsusingfrom        1  thrpt         5  3459205110   124790906    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5     9225037      604720    ops/sruperftransformsflatmaptransformsusingjust        1  thrpt         5  3639603060   225599038    ops/sruperftransformsflatmaptransformsusingjust     1024  thrpt         5    11135613      337022    ops/sruperftransformsmaptransformation                 1  thrpt         5  7264202633   214787109    ops/sruperftransformsmaptransformation              1024  thrpt         5    18795790      713668    ops/s``` || @benjchristensen i suppose the `atomicreferencefieldupdater` mostly comes from less gc pressure is that why the raw throughput increases in your tests? how did the gc wall time change? || if you want me to run a specific workload/type of test let me know so we can compare results || ive been experimenting with fieldupdaters and unsafe for the `serializedobserver` it seems that by using unsafe directly and thus avoiding security checks and an indirection i can get about 8-10% more throughput the downsides are that it is scheduled to be removed/standardized in future java versions and platform dependence in terms of availability should i pursue the unsafe path? || @akarnokd since rxjava also runs on android im not sure how good/standard the support is therei know that the netty folks are having the same issues and they are wrapping those unsafe calles in a platformdependent util class || > wrapping those unsafe calles in a platformdependent util classthis sounds like a valid approach for us as we mature rx well want to squeeze as much performance out of it as we can while still remaining portable || testing with:```/gradlew benchmarks -pjmh-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 5 -prof gc *perftransforms*```##### may 21st                                        (size)   mode   samples         mean   mean error    unitsruperftransformsflatmaptransformsusingfrom        1  thrpt         5  4597237797   227193650    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5    12334190      214479    ops/sruperftransformsflatmaptransformsusingjust        1  thrpt         5  4522036147   216489787    ops/sruperftransformsflatmaptransformsusingjust     1024  thrpt         5    12293223      321573    ops/sruperftransformsmaptransformation                 1  thrpt         5  9133316230   303274438    ops/sruperftransformsmaptransformation              1024  thrpt         5    19698323      150313    ops/s```##### may 26th                                        (size)   mode   samples         mean   mean error    unitsruperftransformsflatmaptransformsusingfrom        1  thrpt         5  4367166623   145506857    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5    11382233      425976    ops/sruperftransformsflatmaptransformsusingjust        1  thrpt         5  4468497400    83649115    ops/sruperftransformsflatmaptransformsusingjust     1024  thrpt         5    11374780      780039    ops/sruperftransformsmaptransformation                 1  thrpt         5  8851147610   303583393    ops/sruperftransformsmaptransformation              1024  thrpt         5    19649227     1134279    ops/s```according to these results we got slower (though within mean error it appears so if not slower then no better) || which java version is this? java 6 intrinsics isnt as good as the newer versions maybe the `wip` field in the merge operator causes more false sharing and needs padding || /library/java/javavirtualmachines/jdk170_45jdk || master branch with /library/java/javavirtualmachines/jdk180_05jdk```benchmark                                       (size)   mode   samples         mean   mean error    unitsruperftransformsflatmaptransformsusingfrom        1  thrpt         5  4378589533   109056155    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5    10702953      447216    ops/sruperftransformsflatmaptransformsusingjust        1  thrpt         5  4341206933   184228619    ops/sruperftransformsflatmaptransformsusingjust     1024  thrpt         5    10961550      545574    ops/sruperftransformsmaptransformation                 1  thrpt         5  8996983320   226242030    ops/sruperftransformsmaptransformation              1024  thrpt         5    19423813      779759    ops/s``` || here is a [simple test]( without jmh (but using same coding pattern) that shows significant increases in throughput from 016 -> 017 -> 018 -> current master branch for this code:``` java    public void maptransformation(usecaseinput input) throws interruptedexception {        inputobservablemap(i -> {            return stringvalueof(i)        })map(i -> {            return integerparseint(i)        })subscribe(inputobserver)        inputawaitcompletion()    }```##### master```run: 10 - 10333567 ops/sec run: 11 - 10235100 ops/sec run: 12 - 10269259 ops/sec run: 13 - 10170560 ops/sec run: 14 - 10072319 ops/sec ```##### version 0183```run: 10 - 7973782 ops/sec run: 11 - 8695425 ops/sec run: 12 - 8283768 ops/sec run: 13 - 8283562 ops/sec run: 14 - 8270888 ops/sec ```##### version 0176 (using `onsubscribe`)```run: 10 - 7812927 ops/sec run: 11 - 7632713 ops/sec run: 12 - 7488673 ops/sec run: 13 - 7975944 ops/sec run: 14 - 7882146 ops/sec ```##### version 0176 (using `onsubscribefunc`)```run: 10 - 7049700 ops/sec run: 11 - 7175042 ops/sec run: 12 - 7173240 ops/sec run: 13 - 7069685 ops/sec run: 14 - 7248320 ops/sec ```##### version 0161```run: 10 - 4765899 ops/sec run: 11 - 4792623 ops/sec run: 12 - 4709982 ops/sec run: 13 - 4761451 ops/sec run: 14 - 4769627 ops/sec ``` || very good progress! ill get back to profiling from master next week || i run some benchmarks with `atomicinteger` and `volatile int` inside merge and it appears that jmh benchmark gives 10% more throughput with `atomicinteger` || well thats odd and doesnt help much when two different ways of measuring are giving contradictory results :-( || we captured some profiling from a production instance and found evidence that suggests our atomic state machines are going to have to be changed or replaced---the biggest allocation hotspot is creating `rxsubscription` from `rxsubscriptionscompositesubscription$stateremove(subscription)` and `rxsubscriptionscompositesubscription$stateadd(subscription)`this accounts for approximately 104gb of total allocations within the profile (~30% of total allocation)theres also ~15gb allocated for rxsubjectssubjectsubscriptionmanager$state split pretty evenly from these 3 methods:```- rxsubjectssubjectsubscriptionmanager$statecreatenewwith(subjectsubscriptionmanager$subjectobserver)- rxsubjectssubjectsubscriptionmanager$stateterminate()  - rxsubjectssubjectsubscriptionmanager<init>()```another ~12gb of allocations for `rxsubjectssubjectsubscriptionmanager$subjectobserver` from 4 sources:```- rxsubjectssubjectsubscriptionmanager$state<init>(boolean countdownlatch subjectsubscriptionmanager$subjectobserver)- rxsubjectssubjectsubscriptionmanager$state<init>()- javautilarrayscopyof(object int) called by rxsubjectssubjectsubscriptionmanager$stateaddobserver(subjectsubscriptionmanager$subjectobserver)- rxsubjectssubjectsubscriptionmanager$stateremoveobserver(subjectsubscriptionmanager$subjectobserver)```heres a list of top allocated rx\* objects that exceed 100mb(numbers are in bytes):```rxsubscription                                           97870643480rxsubjectssubjectsubscriptionmanager$state                1624120080rxsubjectssubjectsubscriptionmanager$subjectobserver    1315680480rxsubscriptionssubscriptions$1                            849212800rxsubscriptionscompositesubscription$state                837518872rxsubscriptionscompositesubscription                      641083960rxobserverssafesubscriber                                 637599560rxsubjectssubjectsubscriptionmanager$subjectobserver      618721656rxobservable$30                                            585739968rxoperatorssafeobservablesubscription                     568522112rxsubjectssubjectsubscriptionmanager$1                    545755280rxsubjectsreplaysubject$history                           528269104rxsubjectsreplaysubject                                   443043720rxobservable                                               395292296rxoperatorsoperatormerge$1$innerobserver                  370883064rxsubjectsreplaysubject$replaystate                       340267192rxobservable$29                                            288726208rxoperatorsblockingoperatortofuture$2                     288463944rxsubjectssubjectsubscriptionmanager                      281230064rxsubjectsreplaysubject$3                                 266953480rxsubjectsreplaysubject$2                                 260071464rxoperatorsblockingoperatortofuture$1                     256919568rxsubjectssubjectsubscriptionmanager$1$1                  245468584rxsubjectsreplaysubject$1                                 238637944rxoperatorsoperatorcache                                  147967240rxobserverssubscribers$1                                  132742032rxsubscriptionsbooleansubscription                        107733248rxobservable$2                                             105170440``` || @benjchristensen asked me to contribute a bit to this issue weve been noticing some issues with rxjava 018x through our use of hystrixlet me setup our use case first to give you an idea of our usage pattern for this particular service we have a pretty standard public api (think microservice single-purpose) that does about 200/s incoming calls and fans that out into ~500-1000 command executions/s this can burst to over 800/s incoming calls without warningthe service is on a pretty modest deployment of c1mediums but its also sitting at about 20% cpu normally since deploying hystrix 1316 w/ rxjava 0182 our heaps that were previously steady sawtooths around 50-70mb have risen to over 150mb additionally our cpu percentages really start to rise after a few days this appears to be linked to our latencytotal_mean times deviating far from our latencyexecute_mean as you can see below the command is decreasing in ops/s but the hystrix overhead is rising this rise continues for about 5 days to where its taking anywhere from 20-30ms of hystrix overhead and the boxes are running near 80-90% cpu![command execution]( took a heap dump of one of the production servers i can provide it on request but shown below is a piece i found interesting:![subscription objects]( 800k subscriptions were present in the heap dump at the time which really smells off to me even when i forced gcs they were sticking around see the below our heap usage was increasing over time:![heap usage]( started looking at the compositesubscription used by hystrix and really drilling into it ran across this:![compositesubscription array]( subscription array on this has grown to 400k perhaps this is an edge case but i believe that once it falls behind it really struggles to keep up this would explain the non-linear jump in hystrix overhead observed in the graph of the command execution time``` java        state add(subscription s) {            int idx  subscriptionslength            subscription newsubscriptions  new subscription[idx + 1]            systemarraycopy(subscriptions 0 newsubscriptions 0 idx)            newsubscriptions[idx]  s            return new state(isunsubscribed newsubscriptions)        }```for every addition its creating a brand new array and copying the new subscriptions into them? is there a reason behind that? removals then iterate the entire array and alloc a new array (usually  twice?):``` java        state remove(subscription s) {            if ((subscriptionslength  1 && subscriptions[0]equals(s)) || subscriptionslength  0) {                return clear()            }            subscription newsubscriptions  new subscription[subscriptionslength - 1]            int idx  0            for (subscription _s : subscriptions) {                if (!_sequals(s)) {                    // was not in this composite                    if (idx  newsubscriptionslength) {                        return this                    }                    newsubscriptions[idx]  _s                    idx++                }            }            if (idx  0) {                return clear()            }            // subscription appeared more than once            if (idx < newsubscriptionslength) {                subscription newsub2  new subscription[idx]                systemarraycopy(newsubscriptions 0 newsub2 0 idx)                return new state(isunsubscribed newsub2)            }            return new state(isunsubscribed newsubscriptions)        }```i dont have a misbehaving instance at the moment but id wonder if profiling would show lots of cpu time spent in `remove()`unless im missing a key factor here id think hashset would be much more performant in this context for o(1) lookups & removals i cant imagine that the overhead of the set entries would be more than memory copies at the very least an arraylist would cut down on allocs & copieslet me know if im off base here im very interested in helping resolve this issue || thanks for the details compositesubscription becomes very slow when it grows over the size of the cache line in the cpu and constant add/remove is happening (see #1145)subscriptions$2 is perhaps the wrapper for future which keeps a final reference to the future object which generally shouldnt be a problem if its parent container is removing/clearing itwhat is worrying is that there is an unsubscribed `compositesubscription` with a non-empty array when unsubscribed `compositesubscription` should drop the entire array and dont accept any new additions could you tell where that `compositesubscription` is embedded? || got itin our use case were doing a `hystrixcommand#observe()` and passing the observable to ``` java    public static <t> listenablefuture<t> tolistenablefuture(observable<t> observable) {        final settablefuture<t> listenablefuture  settablefuturecreate()        final atomicreference<subscription> s  new atomicreference<subscription>()        sset(observablesubscribe(new observer<t>() {                                 @override                                 public void oncompleted() {                                 }                                 @override                                 public void onerror(throwable e) {                                    listenablefuturesetexception(e)                                 }                                 @override                                 public void onnext(t args) {                                    if (listenablefutureisdone()) {                                        listenablefuturesetexception(new illegalstateexception(""""observable should only have a single value""""))                                    } else {                                        listenablefutureset(args)                                    }                                 }                             }))        return listenablefuture    }```this only happens ~50 times a second per server `compositesubscription` is being used  hystrixcontextscheduler#threadpoolworker` but from my investigation of the code it looks like these are recreated for each command invokation @benjchristensen am i right about this?in my heap dump these 400000-long arrays of subscriptions seem to be actively being recycled and used so somehow those compositesubscription instances are sticking around i cant seem to identify where the threadpoolworker instance might be getting reused though || @xorlev thanks for the detailed post very helpful to have another set of clues beyond what weve been seeing> id think hashset would be much more performant in this context for o(1) lookups & removals i cant imagine that the overhead of the set entries would be more than memory copies at the very least an arraylist would cut down on allocs & copiesfor the use cases we appear to be triggering definitely yes this is partially what @akarnokd was seeking to solve in  when we designed the current implementation of `compositesubscription` we used an atomic state machine as the expectation was that there should never be more than a handful of `subscription`s added to it and we were trying to avoid mutable state needing to be protected by locks and that the extra object allocations to allow use of compareandset was okay performance testing weve done has shown this to be a win (in the cases weve been testing) but obviously there are cases where this is breaking badlyso we can pivot to using a mutable data structure protected by locks to avoid the object allocation (such [as this]( but right now im still trying to identify the use cases that are causing this> what is worrying is that there is an unsubscribed compositesubscription with a non-empty array when unsubscribed compositesubscription should drop the entire array and dont accept any new additions could you tell where that compositesubscription is embedded?this is an open question we see the same symptom in our production environment though not sure if its an actual leak or just such high pressure that the gc cant keep up so it looks like they are leakingresearching further today   || > `hystrixcontextscheduler#threadpoolworker`yes that is just a thin wrapper around a real `scheduler` used by hystrix to copy state across threads it is allocated for each command>  these 400000-long arrays of subscriptions seem to be actively being recycled and used so somehow those compositesubscription instances are sticking aroundthat is the key problem im trying to find today im going to focus on the hystrix use cases since its the one that triggers it seems it is either a bug in how hystrix is using rx or its triggering a bug or unexpected use case in rx that we need to handle || if its helpful i also found this interesting which lead me down the path of investigating `compositesubscription$state`![stack]( can put the heap dump on dropbox and email you a link if itd be helpful ben || that is helpful it points to looking at the `eventloopscheduler` || this is creating lots of `arraylist` instances unnecessarily:  shot 2014-05-29 at 10 35 48 am]( shot 2014-05-29 at 10 37 45 am]( || ![replaystate-arraylist-object]( || ![hystrix rx-with-0 18 2]( || those were from 0182  now with master plus a [modified]( `compositesubscription` we get this:![hystrix rx-with-master new-compositesubscription]( || here is evidence for need of work on `replaysubject`:![replaysubject-1]( || ![0 18 2-map observeon]( observeon]( || the `subscription[]` issue is definitely being caused by the use of a `scheduler` here is some evidence:![subscription-array-when-using-scheduler]( the master branch with `compositesubscription` change:![screen shot 2014-05-29 at 10 58 09 am]( issue is definitely the `compositesubscription` as the following shows where it is master as it currently stands without my changes to `compositesubscription`:![master-without-changing-compositesubscription]( || ive added some logging to our production instances and discovered that the cause of large subscription arrays we see in practice is caused by a prefetching operation which generates many (> 500) `hystrixcommand`s calls `observe` on them puts them in an arraylist and finally calls `observablemerge` on this list to have a single place to listen for overall completionthis seems like a valid case to support and any work which improves performance for large subscription arrays would be a meaningful improvement || i have submitted a pull request for this:  are testing the code in our environment shortly || for anyone wanting to dig into this java flight recorder has been very helpful and far better than the other profiling tools ive used and tried for this || backporting to 018x in  || superb work guys ive held off on 18x on android as i noticed an increase in gc really glad you guys take this seriously! || thanks @chrisjenx  it looks like the most glaring issues are resolved and low hanging fruit taken care of there are a few other things for us to improve on but i think well release 019 early next week i would appreciate your feedback on whether you see an improvementi have also opened  to document our attempts on blocking vs non-blocking implementations and to seek input from anyone who can provide better solutions || @akarnokd is there anything else that stands out to you that we should fix before closing this issue? ill continue doing some profiling but it seems the obvious ones well continue working on performance going forward and those can have their own issues and pull requests so if nothing else obvious stands out lets close this issue and not leave it open-ended || the history list in replaysubject since arraylist uses more memory then actual items it might be worth compacting it on a terminal state (one time but might be costly and run out of memory) alternatively it could use  increment expansion strategy third option is to have a cache() overload that passes in a capacity hint to reduce reallocation and wasted space || i think that the object allocation penalty of resizing after a terminal event would be worsea cache() overload that takes a capacity hint may be valuable particularly in the single item case where it could just a single volatile ref instead of an array   || i have opened a new issue for the cache() overload:  || im closing this issue out as i believe we have handled the most glaring problems and dont want this to be a never-ending issue we will of course continue seeking to improve performance but lets use individual issues for each improvement/problem we findthanks everyone for your involvement on this one as it was rather significant and important@xorlev and @daschl i would appreciate feedback once youve had a chance to try the changes in the master branch (or the portion that was backported to 0184) to know if you see the improvements or still have issues @xorlev in particular id like to know if the issue you had was only the gc pressure or if you still see signs of a memory leak (which i have not seen yet) || @benjchristensen hystrix 1316 w/ rxjava 0184 has been in prod for about a day now im happy to report a decrease in garbage (and cpu usage in general) i believe the pressure & the suboptimal subscription removal was causing the leak-like behavior @mattrjacobss use case matches a few of our own (fan out commands wait on all) which is likely the source of the large numbers of subscriptionsill keep an eye out for any similar issues that might crop upthanks a lot for all the help and dedication to improving rxjava || excellent thank you @xorlev for the confirmation ill release hystrix 1317 in a few days hopefully with rxjava 019 as a dependency and at least one performance optimization i found i can do in hystrix directly || "";1;0;switch to atomicreferencefieldupdater;"
"1237;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;safesubscriber memory reduction;for #1204. this saves 24 bytes per instance.;;1204.0;safesubscriber memory reduction;for #1204 this saves 24 bytes per instance;#1138  thanks i think we probably should do this all over i havent merged my change to `compositesubscription` yet so that needs to be done as well || oh you already have a pr for `compositesubscription` as well :-) || @akarnokd @benjchristensen why was there a change from boolean to int? || there is no atomicbooleanfieldupdater and the nearest thing is an atomicintegerfieldupdater since classes are padded to 4-8 byte boundaries anyway moving from 1 byte boolean to 4 byte integer is no extra overhead || oh i just checked you are right that explains a lot but i have no clue why they didnt add that ||;profiling memory usage and object creation;we need to spend time profiling memory and object allocation and finding places where we can improve i would really appreciate help diving into this and finding problem areas even if you dont fix them but just identity use cases operators etc that would be very valuablethis is partly a result of the fact that in netflix production we have seen an increase in younggen gcs since 017xthe areas to start should probably be:- observablecreate- observablelift- subscriber- compositesubscription- map- flatmapif you can or want to get involved in this please comment here so we all can collaborate together;""the most likely source of garbage is the `compositesubscription`: whenever a task is scheduled or a new merge-source appears the state transition creates a new state object and copies the subscription array pr #1145 reduces the amount of garbage by switching to hashset on a larger composite since flatmap->mergemap->merge needs to track the active inner subscriptions it uses a composite as well and would gain the same benefits || the `hashset` change shouldnt kick in though because these arent generally large lists (handful at most not hundreds) i expect its just far too many of them being created || ill also like to help out here since its crucial for our uses as well  || thanks @daschl id appreciate your help profiling and identifying hot spots is what we need most right now || i did some gc profiling of my test workloads and id also like to nominate:- blockingobservable (it seems that especially in the single() case its not optimized)- observablesubscribe (for both observer and subscriber) - in my gc logs they take up 40% of the overall gc pressurethe bad news is that i had to fall back out of observables to plain execution on the hot code path (aside from the overall wrapping observable) because also using it in the path produces way too much garbage (moving away from rx in the hot code path got my throughput from 20% to 80% according to the gc logs) and it correlates with my findings since i could not sustain constant io throughput because of full gcs happening way too frequently || > observablesubscribe (for both observer and subscriber)not surprised on this were you able to identify what the garbage is?  || i did some changes in my code and will re-profile and post the results here so we get better measurements here is a slightly older profile run which might give you a hint or two![screen shot 2014-05-20 at 10 13 10]( shot 2014-05-20 at 10 13 00]( || we can definitely improve on the `atomicreference` by using atomicfieldupdater the others will require more effort to analyze along with sample code to see whats triggering them || i think that many `atomicreference` come from mostly the `compositesubscription` instances || i went back in history to 0161 to compare performance of the basic `map`/`flatmap` behavior and found that current master is faster this fits what i had expected of the work of the past couple months which means its not an obvious glaring issue (unless my test is completely flawed)here is the code for the test:- branch 016 >  master >  results#### 016```benchmark                                       (size)   mode   samples         mean   mean error    unitsruperftransformsflatmaptransformsusingfrom        1  thrpt         5  2421210583    68845966    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5     1017787       73597    ops/sruperftransformsflatmaptransformsusingjust        1  thrpt         5  2398541067    90703197    ops/sruperftransformsflatmaptransformsusingjust     1024  thrpt         5      990623      100735    ops/sruperftransformsmaptransformation                 1  thrpt         5  4020548060   262841500    ops/sruperftransformsmaptransformation              1024  thrpt         5    16205747      352618    ops/s```#### master```benchmark                                       (size)   mode   samples         mean   mean error    unitsruperftransformsflatmaptransformsusingfrom        1  thrpt         5  3184873133   172320420    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5     9079937      343905    ops/sruperftransformsflatmaptransformsusingjust        1  thrpt         5  3411785677    73767161    ops/sruperftransformsflatmaptransformsusingjust     1024  thrpt         5    10860963      294309    ops/sruperftransformsmaptransformation                 1  thrpt         5  7208334997   703327745    ops/sruperftransformsmaptransformation              1024  thrpt         5    18720797      278529    ops/s```### gcon the master branch test im seeing gc results like this:```iteration   5: 3189218350 ops/s          gc | wall time  5001 secs  gc time  0047 secs gc%  094% gc count  +98iteration   5: 9198700 ops/s          gc | wall time  5002 secs  gc time  0048 secs gc%  096% gc count  +98```versus 016```iteration   5: 2420099017 ops/s          gc | wall time  5000 secs  gc time  0046 secs gc%  092% gc count  +96iteration   5: 993867 ops/s          gc | wall time  5001 secs  gc time  0100 secs gc%  200% gc count  +212```### summaryunless im mistaken current code is better:- similar gc behavior on `observable` with 1 item better gc behavior with 1024 items- higher ops/second on all of the map/flatmap testsill start profiling this and improve  but this does not reveal the source of the problems seen possibly its related to schedulers or its a specific operator i exercised `map` `flatmap` (and thus `merge`) `observable` and `subscribe` here to get the most fundamental ones || the `observeon` test shows the cost of scheduling  particularly `observable`s of a single item``` java    @generatemicrobenchmark    public void observeon(usecaseinput input) throws interruptedexception {        inputobservableobserveon(schedulerscomputation())subscribe(inputobserver)        inputawaitcompletion()    }``````ruperfobserveonobserveon        1  thrpt         5   457830180     9943221    ops/sruperfobserveonobserveon     1024  thrpt         5    14496430      518463    ops/s```thus with an `observable` of 1 item we can do 457k onnext/second with an `observable` of 1024 items we can do 148million onnext/second (145k \* 1024) || by the way all testing is just being done on my mac laptop  so these numbers are all relative and not representative of proper server hardware || converting from `atomicreference` to `atomicreferencefieldupdater` improved performance from this:```benchmark                                       (size)   mode   samples         mean   mean error    unitsruperftransformsflatmaptransformsusingfrom        1  thrpt         5  3184873133   172320420    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5     9079937      343905    ops/sruperftransformsflatmaptransformsusingjust        1  thrpt         5  3411785677    73767161    ops/sruperftransformsflatmaptransformsusingjust     1024  thrpt         5    10860963      294309    ops/sruperftransformsmaptransformation                 1  thrpt         5  7208334997   703327745    ops/sruperftransformsmaptransformation              1024  thrpt         5    18720797      278529    ops/s```to this:```benchmark                                       (size)   mode   samples         mean   mean error    unitsruperftransformsflatmaptransformsusingfrom        1  thrpt         5  3459205110   124790906    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5     9225037      604720    ops/sruperftransformsflatmaptransformsusingjust        1  thrpt         5  3639603060   225599038    ops/sruperftransformsflatmaptransformsusingjust     1024  thrpt         5    11135613      337022    ops/sruperftransformsmaptransformation                 1  thrpt         5  7264202633   214787109    ops/sruperftransformsmaptransformation              1024  thrpt         5    18795790      713668    ops/s``` || @benjchristensen i suppose the `atomicreferencefieldupdater` mostly comes from less gc pressure is that why the raw throughput increases in your tests? how did the gc wall time change? || if you want me to run a specific workload/type of test let me know so we can compare results || ive been experimenting with fieldupdaters and unsafe for the `serializedobserver` it seems that by using unsafe directly and thus avoiding security checks and an indirection i can get about 8-10% more throughput the downsides are that it is scheduled to be removed/standardized in future java versions and platform dependence in terms of availability should i pursue the unsafe path? || @akarnokd since rxjava also runs on android im not sure how good/standard the support is therei know that the netty folks are having the same issues and they are wrapping those unsafe calles in a platformdependent util class || > wrapping those unsafe calles in a platformdependent util classthis sounds like a valid approach for us as we mature rx well want to squeeze as much performance out of it as we can while still remaining portable || testing with:```/gradlew benchmarks -pjmh-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 5 -prof gc *perftransforms*```##### may 21st                                        (size)   mode   samples         mean   mean error    unitsruperftransformsflatmaptransformsusingfrom        1  thrpt         5  4597237797   227193650    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5    12334190      214479    ops/sruperftransformsflatmaptransformsusingjust        1  thrpt         5  4522036147   216489787    ops/sruperftransformsflatmaptransformsusingjust     1024  thrpt         5    12293223      321573    ops/sruperftransformsmaptransformation                 1  thrpt         5  9133316230   303274438    ops/sruperftransformsmaptransformation              1024  thrpt         5    19698323      150313    ops/s```##### may 26th                                        (size)   mode   samples         mean   mean error    unitsruperftransformsflatmaptransformsusingfrom        1  thrpt         5  4367166623   145506857    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5    11382233      425976    ops/sruperftransformsflatmaptransformsusingjust        1  thrpt         5  4468497400    83649115    ops/sruperftransformsflatmaptransformsusingjust     1024  thrpt         5    11374780      780039    ops/sruperftransformsmaptransformation                 1  thrpt         5  8851147610   303583393    ops/sruperftransformsmaptransformation              1024  thrpt         5    19649227     1134279    ops/s```according to these results we got slower (though within mean error it appears so if not slower then no better) || which java version is this? java 6 intrinsics isnt as good as the newer versions maybe the `wip` field in the merge operator causes more false sharing and needs padding || /library/java/javavirtualmachines/jdk170_45jdk || master branch with /library/java/javavirtualmachines/jdk180_05jdk```benchmark                                       (size)   mode   samples         mean   mean error    unitsruperftransformsflatmaptransformsusingfrom        1  thrpt         5  4378589533   109056155    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5    10702953      447216    ops/sruperftransformsflatmaptransformsusingjust        1  thrpt         5  4341206933   184228619    ops/sruperftransformsflatmaptransformsusingjust     1024  thrpt         5    10961550      545574    ops/sruperftransformsmaptransformation                 1  thrpt         5  8996983320   226242030    ops/sruperftransformsmaptransformation              1024  thrpt         5    19423813      779759    ops/s``` || here is a [simple test]( without jmh (but using same coding pattern) that shows significant increases in throughput from 016 -> 017 -> 018 -> current master branch for this code:``` java    public void maptransformation(usecaseinput input) throws interruptedexception {        inputobservablemap(i -> {            return stringvalueof(i)        })map(i -> {            return integerparseint(i)        })subscribe(inputobserver)        inputawaitcompletion()    }```##### master```run: 10 - 10333567 ops/sec run: 11 - 10235100 ops/sec run: 12 - 10269259 ops/sec run: 13 - 10170560 ops/sec run: 14 - 10072319 ops/sec ```##### version 0183```run: 10 - 7973782 ops/sec run: 11 - 8695425 ops/sec run: 12 - 8283768 ops/sec run: 13 - 8283562 ops/sec run: 14 - 8270888 ops/sec ```##### version 0176 (using `onsubscribe`)```run: 10 - 7812927 ops/sec run: 11 - 7632713 ops/sec run: 12 - 7488673 ops/sec run: 13 - 7975944 ops/sec run: 14 - 7882146 ops/sec ```##### version 0176 (using `onsubscribefunc`)```run: 10 - 7049700 ops/sec run: 11 - 7175042 ops/sec run: 12 - 7173240 ops/sec run: 13 - 7069685 ops/sec run: 14 - 7248320 ops/sec ```##### version 0161```run: 10 - 4765899 ops/sec run: 11 - 4792623 ops/sec run: 12 - 4709982 ops/sec run: 13 - 4761451 ops/sec run: 14 - 4769627 ops/sec ``` || very good progress! ill get back to profiling from master next week || i run some benchmarks with `atomicinteger` and `volatile int` inside merge and it appears that jmh benchmark gives 10% more throughput with `atomicinteger` || well thats odd and doesnt help much when two different ways of measuring are giving contradictory results :-( || we captured some profiling from a production instance and found evidence that suggests our atomic state machines are going to have to be changed or replaced---the biggest allocation hotspot is creating `rxsubscription` from `rxsubscriptionscompositesubscription$stateremove(subscription)` and `rxsubscriptionscompositesubscription$stateadd(subscription)`this accounts for approximately 104gb of total allocations within the profile (~30% of total allocation)theres also ~15gb allocated for rxsubjectssubjectsubscriptionmanager$state split pretty evenly from these 3 methods:```- rxsubjectssubjectsubscriptionmanager$statecreatenewwith(subjectsubscriptionmanager$subjectobserver)- rxsubjectssubjectsubscriptionmanager$stateterminate()  - rxsubjectssubjectsubscriptionmanager<init>()```another ~12gb of allocations for `rxsubjectssubjectsubscriptionmanager$subjectobserver` from 4 sources:```- rxsubjectssubjectsubscriptionmanager$state<init>(boolean countdownlatch subjectsubscriptionmanager$subjectobserver)- rxsubjectssubjectsubscriptionmanager$state<init>()- javautilarrayscopyof(object int) called by rxsubjectssubjectsubscriptionmanager$stateaddobserver(subjectsubscriptionmanager$subjectobserver)- rxsubjectssubjectsubscriptionmanager$stateremoveobserver(subjectsubscriptionmanager$subjectobserver)```heres a list of top allocated rx\* objects that exceed 100mb(numbers are in bytes):```rxsubscription                                           97870643480rxsubjectssubjectsubscriptionmanager$state                1624120080rxsubjectssubjectsubscriptionmanager$subjectobserver    1315680480rxsubscriptionssubscriptions$1                            849212800rxsubscriptionscompositesubscription$state                837518872rxsubscriptionscompositesubscription                      641083960rxobserverssafesubscriber                                 637599560rxsubjectssubjectsubscriptionmanager$subjectobserver      618721656rxobservable$30                                            585739968rxoperatorssafeobservablesubscription                     568522112rxsubjectssubjectsubscriptionmanager$1                    545755280rxsubjectsreplaysubject$history                           528269104rxsubjectsreplaysubject                                   443043720rxobservable                                               395292296rxoperatorsoperatormerge$1$innerobserver                  370883064rxsubjectsreplaysubject$replaystate                       340267192rxobservable$29                                            288726208rxoperatorsblockingoperatortofuture$2                     288463944rxsubjectssubjectsubscriptionmanager                      281230064rxsubjectsreplaysubject$3                                 266953480rxsubjectsreplaysubject$2                                 260071464rxoperatorsblockingoperatortofuture$1                     256919568rxsubjectssubjectsubscriptionmanager$1$1                  245468584rxsubjectsreplaysubject$1                                 238637944rxoperatorsoperatorcache                                  147967240rxobserverssubscribers$1                                  132742032rxsubscriptionsbooleansubscription                        107733248rxobservable$2                                             105170440``` || @benjchristensen asked me to contribute a bit to this issue weve been noticing some issues with rxjava 018x through our use of hystrixlet me setup our use case first to give you an idea of our usage pattern for this particular service we have a pretty standard public api (think microservice single-purpose) that does about 200/s incoming calls and fans that out into ~500-1000 command executions/s this can burst to over 800/s incoming calls without warningthe service is on a pretty modest deployment of c1mediums but its also sitting at about 20% cpu normally since deploying hystrix 1316 w/ rxjava 0182 our heaps that were previously steady sawtooths around 50-70mb have risen to over 150mb additionally our cpu percentages really start to rise after a few days this appears to be linked to our latencytotal_mean times deviating far from our latencyexecute_mean as you can see below the command is decreasing in ops/s but the hystrix overhead is rising this rise continues for about 5 days to where its taking anywhere from 20-30ms of hystrix overhead and the boxes are running near 80-90% cpu![command execution]( took a heap dump of one of the production servers i can provide it on request but shown below is a piece i found interesting:![subscription objects]( 800k subscriptions were present in the heap dump at the time which really smells off to me even when i forced gcs they were sticking around see the below our heap usage was increasing over time:![heap usage]( started looking at the compositesubscription used by hystrix and really drilling into it ran across this:![compositesubscription array]( subscription array on this has grown to 400k perhaps this is an edge case but i believe that once it falls behind it really struggles to keep up this would explain the non-linear jump in hystrix overhead observed in the graph of the command execution time``` java        state add(subscription s) {            int idx  subscriptionslength            subscription newsubscriptions  new subscription[idx + 1]            systemarraycopy(subscriptions 0 newsubscriptions 0 idx)            newsubscriptions[idx]  s            return new state(isunsubscribed newsubscriptions)        }```for every addition its creating a brand new array and copying the new subscriptions into them? is there a reason behind that? removals then iterate the entire array and alloc a new array (usually  twice?):``` java        state remove(subscription s) {            if ((subscriptionslength  1 && subscriptions[0]equals(s)) || subscriptionslength  0) {                return clear()            }            subscription newsubscriptions  new subscription[subscriptionslength - 1]            int idx  0            for (subscription _s : subscriptions) {                if (!_sequals(s)) {                    // was not in this composite                    if (idx  newsubscriptionslength) {                        return this                    }                    newsubscriptions[idx]  _s                    idx++                }            }            if (idx  0) {                return clear()            }            // subscription appeared more than once            if (idx < newsubscriptionslength) {                subscription newsub2  new subscription[idx]                systemarraycopy(newsubscriptions 0 newsub2 0 idx)                return new state(isunsubscribed newsub2)            }            return new state(isunsubscribed newsubscriptions)        }```i dont have a misbehaving instance at the moment but id wonder if profiling would show lots of cpu time spent in `remove()`unless im missing a key factor here id think hashset would be much more performant in this context for o(1) lookups & removals i cant imagine that the overhead of the set entries would be more than memory copies at the very least an arraylist would cut down on allocs & copieslet me know if im off base here im very interested in helping resolve this issue || thanks for the details compositesubscription becomes very slow when it grows over the size of the cache line in the cpu and constant add/remove is happening (see #1145)subscriptions$2 is perhaps the wrapper for future which keeps a final reference to the future object which generally shouldnt be a problem if its parent container is removing/clearing itwhat is worrying is that there is an unsubscribed `compositesubscription` with a non-empty array when unsubscribed `compositesubscription` should drop the entire array and dont accept any new additions could you tell where that `compositesubscription` is embedded? || got itin our use case were doing a `hystrixcommand#observe()` and passing the observable to ``` java    public static <t> listenablefuture<t> tolistenablefuture(observable<t> observable) {        final settablefuture<t> listenablefuture  settablefuturecreate()        final atomicreference<subscription> s  new atomicreference<subscription>()        sset(observablesubscribe(new observer<t>() {                                 @override                                 public void oncompleted() {                                 }                                 @override                                 public void onerror(throwable e) {                                    listenablefuturesetexception(e)                                 }                                 @override                                 public void onnext(t args) {                                    if (listenablefutureisdone()) {                                        listenablefuturesetexception(new illegalstateexception(""""observable should only have a single value""""))                                    } else {                                        listenablefutureset(args)                                    }                                 }                             }))        return listenablefuture    }```this only happens ~50 times a second per server `compositesubscription` is being used  hystrixcontextscheduler#threadpoolworker` but from my investigation of the code it looks like these are recreated for each command invokation @benjchristensen am i right about this?in my heap dump these 400000-long arrays of subscriptions seem to be actively being recycled and used so somehow those compositesubscription instances are sticking around i cant seem to identify where the threadpoolworker instance might be getting reused though || @xorlev thanks for the detailed post very helpful to have another set of clues beyond what weve been seeing> id think hashset would be much more performant in this context for o(1) lookups & removals i cant imagine that the overhead of the set entries would be more than memory copies at the very least an arraylist would cut down on allocs & copiesfor the use cases we appear to be triggering definitely yes this is partially what @akarnokd was seeking to solve in  when we designed the current implementation of `compositesubscription` we used an atomic state machine as the expectation was that there should never be more than a handful of `subscription`s added to it and we were trying to avoid mutable state needing to be protected by locks and that the extra object allocations to allow use of compareandset was okay performance testing weve done has shown this to be a win (in the cases weve been testing) but obviously there are cases where this is breaking badlyso we can pivot to using a mutable data structure protected by locks to avoid the object allocation (such [as this]( but right now im still trying to identify the use cases that are causing this> what is worrying is that there is an unsubscribed compositesubscription with a non-empty array when unsubscribed compositesubscription should drop the entire array and dont accept any new additions could you tell where that compositesubscription is embedded?this is an open question we see the same symptom in our production environment though not sure if its an actual leak or just such high pressure that the gc cant keep up so it looks like they are leakingresearching further today   || > `hystrixcontextscheduler#threadpoolworker`yes that is just a thin wrapper around a real `scheduler` used by hystrix to copy state across threads it is allocated for each command>  these 400000-long arrays of subscriptions seem to be actively being recycled and used so somehow those compositesubscription instances are sticking aroundthat is the key problem im trying to find today im going to focus on the hystrix use cases since its the one that triggers it seems it is either a bug in how hystrix is using rx or its triggering a bug or unexpected use case in rx that we need to handle || if its helpful i also found this interesting which lead me down the path of investigating `compositesubscription$state`![stack]( can put the heap dump on dropbox and email you a link if itd be helpful ben || that is helpful it points to looking at the `eventloopscheduler` || this is creating lots of `arraylist` instances unnecessarily:  shot 2014-05-29 at 10 35 48 am]( shot 2014-05-29 at 10 37 45 am]( || ![replaystate-arraylist-object]( || ![hystrix rx-with-0 18 2]( || those were from 0182  now with master plus a [modified]( `compositesubscription` we get this:![hystrix rx-with-master new-compositesubscription]( || here is evidence for need of work on `replaysubject`:![replaysubject-1]( || ![0 18 2-map observeon]( observeon]( || the `subscription[]` issue is definitely being caused by the use of a `scheduler` here is some evidence:![subscription-array-when-using-scheduler]( the master branch with `compositesubscription` change:![screen shot 2014-05-29 at 10 58 09 am]( issue is definitely the `compositesubscription` as the following shows where it is master as it currently stands without my changes to `compositesubscription`:![master-without-changing-compositesubscription]( || ive added some logging to our production instances and discovered that the cause of large subscription arrays we see in practice is caused by a prefetching operation which generates many (> 500) `hystrixcommand`s calls `observe` on them puts them in an arraylist and finally calls `observablemerge` on this list to have a single place to listen for overall completionthis seems like a valid case to support and any work which improves performance for large subscription arrays would be a meaningful improvement || i have submitted a pull request for this:  are testing the code in our environment shortly || for anyone wanting to dig into this java flight recorder has been very helpful and far better than the other profiling tools ive used and tried for this || backporting to 018x in  || superb work guys ive held off on 18x on android as i noticed an increase in gc really glad you guys take this seriously! || thanks @chrisjenx  it looks like the most glaring issues are resolved and low hanging fruit taken care of there are a few other things for us to improve on but i think well release 019 early next week i would appreciate your feedback on whether you see an improvementi have also opened  to document our attempts on blocking vs non-blocking implementations and to seek input from anyone who can provide better solutions || @akarnokd is there anything else that stands out to you that we should fix before closing this issue? ill continue doing some profiling but it seems the obvious ones well continue working on performance going forward and those can have their own issues and pull requests so if nothing else obvious stands out lets close this issue and not leave it open-ended || the history list in replaysubject since arraylist uses more memory then actual items it might be worth compacting it on a terminal state (one time but might be costly and run out of memory) alternatively it could use  increment expansion strategy third option is to have a cache() overload that passes in a capacity hint to reduce reallocation and wasted space || i think that the object allocation penalty of resizing after a terminal event would be worsea cache() overload that takes a capacity hint may be valuable particularly in the single item case where it could just a single volatile ref instead of an array   || i have opened a new issue for the cache() overload:  || im closing this issue out as i believe we have handled the most glaring problems and dont want this to be a never-ending issue we will of course continue seeking to improve performance but lets use individual issues for each improvement/problem we findthanks everyone for your involvement on this one as it was rather significant and important@xorlev and @daschl i would appreciate feedback once youve had a chance to try the changes in the master branch (or the portion that was backported to 0184) to know if you see the improvements or still have issues @xorlev in particular id like to know if the issue you had was only the gc pressure or if you still see signs of a memory leak (which i have not seen yet) || @benjchristensen hystrix 1316 w/ rxjava 0184 has been in prod for about a day now im happy to report a decrease in garbage (and cpu usage in general) i believe the pressure & the suboptimal subscription removal was causing the leak-like behavior @mattrjacobss use case matches a few of our own (fan out commands wait on all) which is likely the source of the large numbers of subscriptionsill keep an eye out for any similar issues that might crop upthanks a lot for all the help and dedication to improving rxjava || excellent thank you @xorlev for the confirmation ill release hystrix 1317 in a few days hopefully with rxjava 019 as a dependency and at least one performance optimization i found i can do in hystrix directly || "";1;0;changed to field updater;"
1243;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove subscription wrapper from observable.subscribe;remove subscription wrapper from observable.subscribe  performance increase from 7.7m to 8.8m ops/second  before:      benchmark (size) mode samples mean mean error units r.u.perftransforms.maptransformation 1 thrpt 5 7714453.187 362218.633 ops/s r.u.perftransforms.maptransformation 1 thrpt 5 7527144.767 497816.471 ops/s      after:      benchmark (size) mode samples mean mean error units r.u.perftransforms.maptransformation 1 thrpt 5 8853534.333 183494.242 ops/s r.u.perftransforms.maptransformation 1 thrpt 5 8806958.403 452595.219 ops/s      test can be run  using:      ../gradlew benchmarks  -pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 5 -prof gc .*perftransforms.maptransformation*;;0;remove subscription wrapper from observablesubscribe;remove subscription wrapper from observablesubscribeperformance increase from 77m to 88m ops/secondbefore:```benchmark (size) mode samples mean mean error unitsruperftransformsmaptransformation 1 thrpt 5 7714453187 362218633 ops/sruperftransformsmaptransformation 1 thrpt 5 7527144767 497816471 ops/s```after:```benchmark (size) mode samples mean mean error unitsruperftransformsmaptransformation 1 thrpt 5 8853534333 183494242 ops/sruperftransformsmaptransformation 1 thrpt 5 8806958403 452595219 ops/s```test can be run  using:```/gradlew benchmarks -pjmh-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 5 -prof gc *perftransformsmaptransformation*```;;;;;1;1;remove subscription wrapper from observablesubscribeperformance increase from 77m to 88m ops/secondbefore:benchmark                              (size)   mode   samples         mean   mean error    unitsruperftransformsmaptransformation        1  thrpt         5  7714453187   362218633    ops/sruperftransformsmaptransformation        1  thrpt         5  7527144767   497816471    ops/safter:benchmark                              (size)   mode   samples         mean   mean error    unitsruperftransformsmaptransformation        1  thrpt         5  8853534333   183494242    ops/sruperftransformsmaptransformation        1  thrpt         5  8806958403   452595219    ops/s;
1244;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;observable.from(t) using observable.just(t);for code like  observable.from(1)  improve performance from ~3.9m to 4.5+m ops/second  before       r.u.perftransforms.flatmaptransformsusingfrom        1  thrpt         5  3923845.687    46657.660    ops/s r.u.perftransforms.flatmaptransformsusingfrom     1024  thrpt         5     8924.953     1983.161    ops/s  r.u.perftransforms.flatmaptransformsusingfrom        1  thrpt         5  3623228.857   490894.492    ops/s r.u.perftransforms.flatmaptransformsusingfrom     1024  thrpt         5     9176.330      923.929    ops/s      after:      benchmark                                       (size)   mode   samples         mean   mean error    units r.u.perftransforms.flatmaptransformsusingfrom        1  thrpt         5  4052364.587   100971.234    ops/s r.u.perftransforms.flatmaptransformsusingfrom     1024  thrpt         5    11682.783      496.656    ops/s  benchmark                                       (size)   mode   samples         mean   mean error    units r.u.perftransforms.flatmaptransformsusingfrom        1  thrpt         5  4700583.987    77742.037    ops/s r.u.perftransforms.flatmaptransformsusingfrom     1024  thrpt         5    12588.803       58.935    ops/s      using this test:      ../gradlew benchmarks  -pjmh=-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 5 -prof gc .*perftransforms.flatmaptransformsusingfrom*;;0;observablefrom(t) using observablejust(t);for code like `observablefrom(1)` improve performance from ~39m to 45+m ops/secondbefore```ruperftransformsflatmaptransformsusingfrom        1  thrpt         5  3923845687    46657660    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5     8924953     1983161    ops/sruperftransformsflatmaptransformsusingfrom        1  thrpt         5  3623228857   490894492    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5     9176330      923929    ops/s```after:```benchmark                                       (size)   mode   samples         mean   mean error    unitsruperftransformsflatmaptransformsusingfrom        1  thrpt         5  4052364587   100971234    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5    11682783      496656    ops/sbenchmark                                       (size)   mode   samples         mean   mean error    unitsruperftransformsflatmaptransformsusingfrom        1  thrpt         5  4700583987    77742037    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5    12588803       58935    ops/s```using this test:```/gradlew benchmarks -pjmh-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 5 -prof gc *perftransformsflatmaptransformsusingfrom*```;#1144 ;;;;1;1;observablefrom(t) using observablejust(t)for code like `observablefrom(1)` improve performance from ~39m to 45+m ops/secondbefore```ruperftransformsflatmaptransformsusingfrom        1  thrpt         5  3923845687    46657660    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5     8924953     1983161    ops/sruperftransformsflatmaptransformsusingfrom        1  thrpt         5  3623228857   490894492    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5     9176330      923929    ops/s```after:```benchmark                                       (size)   mode   samples         mean   mean error    unitsruperftransformsflatmaptransformsusingfrom        1  thrpt         5  4052364587   100971234    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5    11682783      496656    ops/sbenchmark                                       (size)   mode   samples         mean   mean error    unitsruperftransformsflatmaptransformsusingfrom        1  thrpt         5  4700583987    77742037    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5    12588803       58935    ops/s```using this test:```/gradlew benchmarks -pjmh-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 5 -prof gc *perftransformsflatmaptransformsusingfrom*```;
1248;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;fixed testconcurrentonnextfailsvalidation;the two instructions need to be swapped to make sure woken-up awaiters see the error reliably.;;0; testconcurrentonnextfailsvalidation;the two instructions need to be swapped to make sure woken-up awaiters see the error reliably;#1148 ;;;;1;1; testconcurrentonnextfailsvalidation;
1269;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix the bug that int overflow can bypass the range check;fix the bug mentioned in #1266;;126.0;fix the bug that int overflow can bypass the range check;fix the bug mentioned in #1266;#1164 #1165 #1166 ;how to checkpoint a observable returned in mapmany?;i have the following use case:for each file in a ftp directory  read file line by line  filter comments  parse line into a java object  serialize that obj  send each obj in batches to another componenti also want to make sure i dont process the same files over and over so i first filter all files based off a checkpoint mechanism and after all the contents of a file have been sent add that file to the checkpointi have tried to replicate the logic in rxjava the following way:``` javaobservablefrom(clientlist(basepath true)) // recursively get all files under the path          filter(new func1<ftpclientfilestats boolean>() {            @override            public boolean call(final ftpclientfilestats filestats) {              return filestats  null || filestatsgetsize() < 0 || !checkpointerhasprocessed(filestatsgetpath())            }          })          mapmany(new func1<ftpclientfilestats observable<? extends byte>>() {            @override            public observable<? extends byte> call(final ftpclientfilestats path) {              final string location  pathgetpath()              final observable<byte> obs  observablefrom(clientgetiterable(location)) // opens the file and returns iterable<string>                  filter(comment_filter) // remove comment line                  map(parse_line) // convert from string to event                  map(serialize_event) // convert from event to byte              obssubscribe(new checkpointobserver(checkpointer location)) // when done processing checkpoint file              return obs            }          })          subscribe(new eventsender(cp))```the above code causes the following error to be passed to onerror:```javalangillegalstateexception: can not set subscription more than once    at rxutilatomicobservablesubscriptionwrap(atomicobservablesubscriptionjava:58) ~[rxjava-core-050jar:na]    at rxoperatorsoperationfilter$filtercall(operationfilterjava:48) [rxjava-core-050jar:na]    at rxoperatorsoperationfilter$filtercall(operationfilterjava:36) [rxjava-core-050jar:na]```but this works:``` javaobservablefrom(clientlist(basepath true))          filter(new func1<ftpclientfilestats boolean>() {            @override            public boolean call(final ftpclientfilestats filestats) {              return filestats  null || filestatsgetsize() < 0 || !checkpointerhasprocessed(filestatsgetpath())            }          })          mapmany(new func1<ftpclientfilestats observable<? extends byte>>() {            @override            public observable<? extends byte> call(final ftpclientfilestats path) {              final string location  pathgetpath()              final observable<byte> obs  observablefrom(clientgetiterable(location))                  filter(comment_filter) // remove comment line                  map(parse_line) // convert from string to event                  map(serialize_event) // convert from event to byte              obssubscribe(new eventsender(cp))              obssubscribe(new checkpointobserver(checkpointer location)) // when done processing checkpoint file              return obs            }          })          subscribe(new observer<byte>() {            @override            public void oncompleted() {              // no-op just trigger execution            }            @override            public void onerror(final exception e) {              // no-op just trigger execution            }            @override            public void onnext(final byte args) {              // no-op just trigger execution            }          })```two things: is this a bug in rx? and whats the better way to handle this?  ( seems like it would really help to replace the eventsender since it really just buffers events before sending them);hi ill review this and get back to you (probably tomorrow not tonight) || i think you are trying to use checkpointobserver and the filter before it to implement the distinct operator that sound about right? || looking at  and  i can see how i can filter files that have been seen before but i am unclear how distinct would aid in doing the checkpoint itself  could you explain a little bit more? || closing out as this is very old  reopen if you want to discuss again ||;1;0;fix the bug that int overflow can bypass the range check;
"1271;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator retry with predicate;operator retry with predicate + 1 overload for issue #1214.  the func1 version is simply named  retry   the func2 version is named  retryif  due to lack of ideas and because to avoid overload resolution issues. i also had to open up the operatorretrytest classes a bit.;;1214.0;operator retry with predicate;operator retry with predicate + 1 overload for issue #1214the func1 version is simply named `retry` the func2 version is named `retryif` due to lack of ideas and because to avoid overload resolution issues i also had to open up the operatorretrytest classes a bit;#1169  thanks for implementing this should we just keep one of those two instead of both so we dont have to deal with the naming/overload issue? || i dont know which one to keep? || probably the one that includes attempts? this is the advanced use case for retry so it should probably provide both attempts and error it just feels awkward to need to come up with a new name just so we can have one with `attempts` and one without@headinthebox do you have an opinion on this? || agree with @benjchristensen if you are using this one you (should) know what you are doing || #1176 thanks @akarnokd and @headinthebox for the review ||;retry with predicate;several people have expressed need for conditional retry behavior i suggest a new `retry` overload that simply takes a predicate that receives the `throwable```` javapublic final observable<t> retry(func1<throwable boolean> predicate)```this would allow deciding whether to retry based on the `throwable` and/or count which can be maintained by the `func1`or we could use a `func2` and pass in the count:``` javapublic final observable<t> retry(func2<integer throwable boolean> predicate)```;""here is the type of thing that has to be done for conditional retries without this overload:``` javaimport javautilconcurrentatomicatomicintegerimport rxobservableimport rxsubscriberpublic class conditionalretry {    public static void main(string args) {        final atomicinteger c  new atomicinteger()        observable<string> owithruntimeexception  observablecreate((subscriber<? super string> s) -> {            systemoutprintln(""""execution: """" + cget())            if (cincrementandget() < 3) {                sonerror(new runtimeexception(""""retryable""""))            } else {                sonnext(""""hello"""")                soncompleted()            }        })        final atomicinteger c2  new atomicinteger()        observable<string> owithillegalstateexception  observablecreate((subscriber<? super string> s) -> {            systemoutprintln(""""execution: """" + c2get())            if (c2incrementandget() < 3) {                sonerror(new runtimeexception(""""retryable""""))            } else {                sonerror(new illegalstateexception())            }        })        subscribe(owithruntimeexception)        subscribe(owithillegalstateexception)    }    public static void subscribe(observable<string> o) {        o  omaterialize()flatmap(n -> {            if (nisonerror()) {                if (ngetthrowable() instanceof illegalstateexception) {                    return observablejust(n)                } else {                    return observableerror(ngetthrowable())                }            } else {                return observablejust(n)            }        })retry()dematerialize()        osubscribe(systemout::println t -> tprintstacktrace())    }}``` || completed || "";1;0;removed the func1 retry variant;"
1272;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;executorscheduler to wrap an executor;for issue #1219 (and #1206)  this implementation should conform with the scheduler contract except it is not possible to avoid thread-hopping (don t worry  the tasks execute serially  but maybe not on the same physical thread).  few open improvement possibilities: - usage of  mpsclinkedqueue  once available. - a better performing subscription container for this kind of queue-drain task tracking instead of  compositesubscription . - ability to remove a  subscription  from a  compositesubscription  without it calling unsubscribe on the removed subscription   la  multipleassignmentsubscription.set() .;;1206.0;executorscheduler to wrap an executor;for issue #1219 (and #1206)this implementation should conform with the scheduler contract except it is not possible to avoid thread-hopping (dont worry the tasks execute serially but maybe not on the same physical thread)few open improvement possibilities:- usage of `mpsclinkedqueue` once available- a better performing subscription container for this kind of queue-drain task tracking instead of `compositesubscription`- ability to remove a `subscription` from a `compositesubscription` without it calling unsubscribe on the removed subscription  la `multipleassignmentsubscriptionset()`;#1170  thanks @akarnokd for this looks good for a first cut the trade-offs (thread hopping) are expected and why we wont use this as a default for anything and agreed on possible improvements but those can come later ||;what should i use for thread pool execution in new api?;what should i use for thread pool execution in new api?for example all  request in android recommended to be executed on cached thread pool;take a look at  and  item of interest is  || @lexer please try out the implemented just merged in @1272 and let us know if it gives you what you needwe are also still going to proceed with an improved io scheduler as per  || the `schedulersio()` scheduler will now cache threads again due to the work in #1140 there is also a new `executorscheduler`  that you can access using `schedulersfrom(executor)` ||;1;0;executorscheduler to wrap an executor;
"1272;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;executorscheduler to wrap an executor;for issue #1219 (and #1206)  this implementation should conform with the scheduler contract except it is not possible to avoid thread-hopping (don t worry  the tasks execute serially  but maybe not on the same physical thread).  few open improvement possibilities: - usage of  mpsclinkedqueue  once available. - a better performing subscription container for this kind of queue-drain task tracking instead of  compositesubscription . - ability to remove a  subscription  from a  compositesubscription  without it calling unsubscribe on the removed subscription   la  multipleassignmentsubscription.set() .;;1219.0;executorscheduler to wrap an executor;for issue #1219 (and #1206)this implementation should conform with the scheduler contract except it is not possible to avoid thread-hopping (dont worry the tasks execute serially but maybe not on the same physical thread)few open improvement possibilities:- usage of `mpsclinkedqueue` once available- a better performing subscription container for this kind of queue-drain task tracking instead of `compositesubscription`- ability to remove a `subscription` from a `compositesubscription` without it calling unsubscribe on the removed subscription  la `multipleassignmentsubscriptionset()`;#1170  thanks @akarnokd for this looks good for a first cut the trade-offs (thread hopping) are expected and why we wont use this as a default for anything and agreed on possible improvements but those can come later ||;new executorscheduler implementation;it turns out a lot of people used `executorscheduler` despite its problems (#711 & #713) we need to bring it back but in a way that is compliant with the contractthis will mean that each `worker` from the `executorscheduler` will need to maintain its own queue outside of the `executor` (similar to `observeon`) and then recurse on the `executor` only a single task per `worker` can be scheduled/enqueued on an `executor` and when it completes then it should recurse pulling items from the `worker` queue when the queue is empty it can stop processing when a new task is enqueued on the `worker` then it can schedule against for execution on the `executor`we will be working against the default behavior of the `executor` but need to do that to maintain the single-threaded contract of a `schedulerworker`;""@benjchristensen youve probably already investigated but does any of the quasar work help or the backported `forkjoin` for jre6? || my understanding of `forkjoin` is that it would still have the same need for us to manage a queue externally otherwise it will process the items on multiple threads concurrently if we put them into the `forkjoin` queue || @benjchristensen your rightso idea i have at present is you spawn a new `serialexecutor` for each worker - pass in a executor into the scheduler- create `worker()` this creates a `serialexecutor` that _sits on_ a thread from the passed in executor- process through all the actions blocking until the `worker()` completes- complete and return the thread back to the poolnot sure if that would actually solve the problem but from my understanding is that we always need to serially execute queued up actions on any one worker || that all sounds right except the """"blocking until the worker() completes"""" part that would okay in quasar but not with native threads it will need to behave like `observeon` where it releases the thread (think of it as an event loop) and then reschedules back on a thread the next time it receives an `onnext`see observeon here:  || @benjchristensen yeah ok that makes sensei still think it should be noted that people should try to avoid `executors` where possible it should be a """"when you really have too"""" || i guess we need to make sure executing a tasks by the same worker shouldnt hop threads right? i see a few problems:- generally threads can die from executing non rxjava tasks and get replaced by fresh threads so thread """"hopping"""" is more likely to occur than with the standard schedulers- since most executors use a single work queue work might be dequeued by any of the threads even if a work item can tell where it should run one would need some mechanism to toss the work over to the target thread at which point task reordering can happen   - maybe a write-cursor and read-cursor pairs may help plus each worker thread needs dedicated queue with every instance of schedulerworker assigned to it these queues may then be processed round-robin  - even if this worker thread affinity is established one would need constantly running tasks that poll these queues or blocking ones that get unblocked by yet another queue since we dont know how many threads there are in the executor it becomes difficult to schedule such processing routines if necessary and even so they will block out other tasks submitted from elsewhere to the same executorbottom line is in my opinion that there arent any good ways to ensure worker affinity on an executor whose internal threads and queueing we cant control || as far as i am concerned the needs i have is:- i have to serialize all my bluetooth low energy communications on android and requests can come from multiple threads id like my observables to be scheduled one after the other- in [cgeo]( i do not want more than 5 (or 10) concurrent  download connections from android as i download large images and the memory pressure will be too high if i download more of them at the same timeis there a way to achieve those two goals easily without an executor? || @samueltardieu this high jacks the issue somewhat but the `computation` scheduler only runs as many concurrent threads as there are cores on the device (2-4) for most android devicesthe whole point of the new schedulers is that they execute in order which executors are not guaranteed to doi would use either an io or trampoline scheduler for your btle comms (also remember to bind the `observable` if youre passing it off to the ui thread @mattias provided that one) as for  either use computation scheduler or your own scheduler we solved the problem in retrofit by using the executor in the `onsubscribe()` method see [rxsupport]( || there have been a few prs proposing a scheduler with  thread count and another with thread-caching support the latter can be extended to put an upper limit on the active thread count if necessary but unfortunately these efforts are blocked on the enhancement quest to add load-balancing to the base computation scheduler and the usual concerns about api size and features to expose ive been fiddling with an idea for some time to ask for a contrib-experimental module where all these """"outcasts"""" and other stuff may be put || @akarnokd i quite like that idea keep the main lib lean im sure a _contrib-concurrency_ would not be overkilli mean i always use proguard so bloat isnt so much of an issue for me but its great you guys are thinking about it || all interested in this please try out the new implementation via `schedulersnewexecutor` as implemented by @akarnokd in   || should we rename `schedulersnewexecutor` to something else? reason im asking is that it doesnt actually create a new `executor` like `newthread` does it is a new `scheduler` around a given `executor` perhaps it is instead `schedulersfromexecutor(executor e)` or just `schedulersexecutor(executor e)`? || i like `schedulersfrom(executor e)` || @headinthebox +1 very consistent! || i believe this is done so closing out  || -keep class rxinternalutil*\* { * } add it in proguard to resolve few problems || "";1;0;executorscheduler to wrap an executor;"
1275;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;fix encoding/formatting;the encoding on these files is not liked by git and it is forcing them to be updated.  /cc @akarnokd as you may want to look at your setup  this happens somewhat often on commits from you.  i believe it is related to these  .gitattribute  settings:      # set default behaviour  in case users don t have core.autocrlf set. * text=auto  # explicitly declare text files we want to always be normalized and converted  # to native line endings on checkout. *.java text *.groovy text *.scala text *.clj text *.txt text *.md text  # denote all files that are truly binary and should not be modified. *.png binary *.jpg binary;;0;fix encoding/formatting;the encoding on these files is not liked by git and it is forcing them to be updated/cc @akarnokd as you may want to look at your setup  this happens somewhat often on commits from youi believe it is related to these `gitattribute` settings:```# set default behaviour in case users dont have coreautocrlf set* textauto# explicitly declare text files we want to always be normalized and converted # to native line endings on checkout*java text*groovy text*scala text*clj text*txt text*md text# denote all files that are truly binary and should not be modified*png binary*jpg binary```;im sorry i sometimes forget to set the file encoding to lf on my windows machine netbeans doesnt allow this to be set as default ||;;;;1;1;fix encoding/formattingthe encoding on these files is not liked by git and it is forcing them to be updated;
1281;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;reduce subscription object allocation;### changes - rewrite of  compositesubscription  and added  chainedsubscription  - significant reduction in object allocations - details on research available at  ##### atomic state machine -> mutation & locks  the  compositesubscription  implementation was changed from using an atomic state machine to using locks. the state machine requires immutable  state  that is swapped using cas. this means an object allocation is needed each time.  it now uses locks to protect mutable state so very few objects are created. ##### chainedsubscription  the  compositesubscription  requires support of randomly removing a  subscription  via the  remove  method. the  subscriber  type does not expose this so can be optimized. there is now a  chainedsubscription  that is used by  subscriber  instead. this allows using a  linkedlist  or  arraylist  rather than  hashset  as random access is never needed. this provides a slight performance boost and reduces memory usage (1 minute test shows 16.5gb allocation for  composite  versus 14.4gc for  chained ). ### allocation comparison  this shows java flight recorder output from master without these changes:  ![master-without-changing-compositesubscription](  this shows object allocation after changing  compositesubscription :  ![master-with-new-compositesubscription ong]( ### throughput comparison  testing this code:      java     public void maptransformation(usecaseinput input) throws interruptedexception {         input.observable.map(i -> {             return string.valueof(i)           }).map(i -> {             return integer.parseint(i)          }).subscribe(input.observer)          input.awaitcompletion()      }     ##### rx 0.16.1      run: 10 - 2 879 355 ops/sec  run: 11 - 3 236 245 ops/sec  run: 12 - 4 468 275 ops/sec  run: 13 - 3 237 293 ops/sec  run: 14 - 4 683 840 ops/sec      ##### rx 0.17.6 - using onsubscribefunc      run: 10 - 3 621 876 ops/sec  run: 11 - 6 702 412 ops/sec  run: 12 - 7 401 924 ops/sec  run: 13 - 6 653 359 ops/sec  run: 14 - 5 834 305 ops/sec      ##### rx 0.17.6 - using onsubscribe      run: 10 - 3 320 053 ops/sec  run: 11 - 4 520 795 ops/sec  run: 12 - 7 107 320 ops/sec  run: 13 - 5 089 058 ops/sec  run: 14 - 5 534 034 ops/sec   run: 10 - 4 930 966 ops/sec  run: 11 - 6 119 951 ops/sec  run: 12 - 7 062 146 ops/sec  run: 13 - 6 514 657 ops/sec  run: 14 - 6 369 426 ops/sec      ##### rx 0.18.3 - using onsubscribe      run: 10 - 4 178 854 ops/sec  run: 11 - 4 446 420 ops/sec  run: 12 - 5 458 515 ops/sec  run: 13 - 8 006 405 ops/sec  run: 14 - 7 849 293 ops/sec   run: 10 - 4 145 936 ops/sec  run: 11 - 6 553 079 ops/sec  run: 12 - 7 645 259 ops/sec  run: 13 - 7 385 524 ops/sec  run: 14 - 7 830 853 ops/sec      ##### rx 0.19 master - compositesubscription state machine      run: 10 - 10 576 302 ops/sec  run: 11 - 10 518 786 ops/sec  run: 12 - 10 554 646 ops/sec  run: 13 - 10 314 063 ops/sec  run: 14 - 10 666 439 ops/sec      ##### rx 0.19 master - compositesubscription with synchronized hashset      run: 10 - 9 949 060 ops/sec  run: 11 - 10 122 379 ops/sec  run: 12 - 10 018 032 ops/sec  run: 13 - 10 072 522 ops/sec  run: 14 - 10 132 636 ops/sec      ##### rx 0.19 master - chainedsubscription with synchronized arraylist      run: 10 - 11 086 351 ops/sec  run: 11 - 10 932 426 ops/sec  run: 12 - 11 002 431 ops/sec  run: 13 - 10 888 620 ops/sec  run: 14 - 11 157 227 ops/sec   run: 10 - 9 371 192 ops/sec  run: 11 - 9 829 169 ops/sec  run: 12 - 10 139 005 ops/sec  run: 13 - 10 099 785 ops/sec  run: 14 - 10 017 631 ops/sec      ##### rx 0.19 master - chainedsubscription with synchronized linkedlist      run: 10 - 10 619 431 ops/sec  run: 11 - 11 063 293 ops/sec  run: 12 - 11 001 463 ops/sec  run: 13 - 11 054 243 ops/sec  run: 14 - 10 898 826 ops/sec   run: 10 - 10 075 465 ops/sec  run: 11 - 9 780 716 ops/sec  run: 12 - 9 885 134 ops/sec  run: 13 - 9 584 143 ops/sec  run: 14 - 10 000 700 ops/sec;;0;reduce subscription object allocation;### changes- rewrite of `compositesubscription` and added `chainedsubscription`- significant reduction in object allocations- details on research available at  atomic state machine -> mutation & locksthe `compositesubscription` implementation was changed from using an atomic state machine to using locks the state machine requires immutable `state` that is swapped using cas this means an object allocation is needed each timeit now uses locks to protect mutable state so very few objects are created##### chainedsubscriptionthe `compositesubscription` requires support of randomly removing a `subscription` via the `remove` method the `subscriber` type does not expose this so can be optimized there is now a `chainedsubscription` that is used  subscriber` instead this allows using a `linkedlist` or `arraylist` rather than `hashset` as random access is never needed this provides a slight performance boost and reduces memory usage (1 minute test shows 165gb allocation for `composite` versus 144gc for `chained`)### allocation comparisonthis shows java flight recorder output from master without these changes:![master-without-changing-compositesubscription]( shows object allocation after changing `compositesubscription`:![master-with-new-compositesubscription ong]( throughput comparisontesting this code:``` java    public void maptransformation(usecaseinput input) throws interruptedexception {        inputobservablemap(i -> {            return stringvalueof(i)        })map(i -> {            return integerparseint(i)        })subscribe(inputobserver)        inputawaitcompletion()    }```##### rx 0161```run: 10 - 2879355 ops/sec run: 11 - 3236245 ops/sec run: 12 - 4468275 ops/sec run: 13 - 3237293 ops/sec run: 14 - 4683840 ops/sec ```##### rx 0176 - using onsubscribefunc```run: 10 - 3621876 ops/sec run: 11 - 6702412 ops/sec run: 12 - 7401924 ops/sec run: 13 - 6653359 ops/sec run: 14 - 5834305 ops/sec ```##### rx 0176 - using onsubscribe```run: 10 - 3320053 ops/sec run: 11 - 4520795 ops/sec run: 12 - 7107320 ops/sec run: 13 - 5089058 ops/sec run: 14 - 5534034 ops/sec run: 10 - 4930966 ops/sec run: 11 - 6119951 ops/sec run: 12 - 7062146 ops/sec run: 13 - 6514657 ops/sec run: 14 - 6369426 ops/sec ```##### rx 0183 - using onsubscribe```run: 10 - 4178854 ops/sec run: 11 - 4446420 ops/sec run: 12 - 5458515 ops/sec run: 13 - 8006405 ops/sec run: 14 - 7849293 ops/sec run: 10 - 4145936 ops/sec run: 11 - 6553079 ops/sec run: 12 - 7645259 ops/sec run: 13 - 7385524 ops/sec run: 14 - 7830853 ops/sec ```##### rx 019 master - compositesubscription state machine```run: 10 - 10576302 ops/sec run: 11 - 10518786 ops/sec run: 12 - 10554646 ops/sec run: 13 - 10314063 ops/sec run: 14 - 10666439 ops/sec ```##### rx 019 master - compositesubscription with synchronized hashset```run: 10 - 9949060 ops/sec run: 11 - 10122379 ops/sec run: 12 - 10018032 ops/sec run: 13 - 10072522 ops/sec run: 14 - 10132636 ops/sec ```##### rx 019 master - chainedsubscription with synchronized arraylist```run: 10 - 11086351 ops/sec run: 11 - 10932426 ops/sec run: 12 - 11002431 ops/sec run: 13 - 10888620 ops/sec run: 14 - 11157227 ops/sec run: 10 - 9371192 ops/sec run: 11 - 9829169 ops/sec run: 12 - 10139005 ops/sec run: 13 - 10099785 ops/sec run: 14 - 10017631 ops/sec ```##### rx 019 master - chainedsubscription with synchronized linkedlist```run: 10 - 10619431 ops/sec run: 11 - 11063293 ops/sec run: 12 - 11001463 ops/sec run: 13 - 11054243 ops/sec run: 14 - 10898826 ops/sec run: 10 - 10075465 ops/sec run: 11 - 9780716 ops/sec run: 12 - 9885134 ops/sec run: 13 - 9584143 ops/sec run: 14 - 10000700 ops/sec ```;grrr some unit tests are failing   ||  the failing unit tests  silly mistake thanks @akarnokd for getting involved in thisi agree we can further optimize this for example i think we should look at the data structure from  || anyone have a better name than `chainedsubscription` before this gets released and is permanent forever? || `subscriptionlist` and `subscriptionset` perhaps || i like `subscriptionset` || do you have a different take on how to solve #1204 based on the findings ive posted there? || what the difference with `compositesubscription`? || for immediate results using plain set and list based composites is okay we need to recheck the operators and use the appropriate one for the schedulers an mpsc-based queue still creates a lot of garbage my subscriptionqueue based on a ringbuffer avoids this issue at the expense of synchronization instead of atomics for even less allocation on the new composites we would need to implement a more light-weight hashset (eg a linear probing hashset although we would lose the benefits from the java 8 hashmap enhancements) || #1179  aside from the extra dependency disruptor seems like it would be a pretty decent model for the subscriptionqueue it would be interesting to see if itd perform well non-contending cases vs the mpsc queue || disruptors ringbuffer is bounded so youd need to either set it to a decent size or parametrize the schedulers in addition it is prone to deadlock because the reader may put new tasks into the queue in case of a recursive schedule || > for even less allocation on the new composites we would need to implement a more light-weight hashset agreed if we can come up with one that is better >  for the schedulers an mpsc-based queue still creates a lot of garbage my subscriptionqueue based on a ringbuffer avoids this issue at the expense of synchronization instead of atomicsyes i want to get those changes pulled in before we release> for immediate results using plain set and list based composites is okaywe can evaluate the mpsc queue to replace these before releasing> we need to recheck the operators and use the appropriate oneyes i only migrated the ones that directly injected a `compositesubscription` into `subscriber` || talking with @headinthebox he was wondering if we should remove the `remove`/`clear` methods from `compositesubcription` and leave that the default and have a more specific implementation for the few places needing `remove` functionality im averse to a breaking change of that kind even though were pre-10 as were so late in the game that breaking changes are really painfulwhat do you think? anyone else have an opinion on this?the two signatures are:``` javasubscriptiona { public synchronized boolean isunsubscribed() public void add(final subscription s) public void remove(final subscription s) public void clear() public void unsubscribe()}`````` javasubscriptionb { public synchronized boolean isunsubscribed() public void add(final subscription s) public void unsubscribe()}```the `subscriptionb` signature is the one most people probably need when they think of `compositesubscription` || #1180 #1181 looks good || i never used `clear` and cant see a need for it what i usually need is a `remove` variant that doesnt unsubscribe the subscription removed usually this comes into play when a scheduled action is finished and needs to remove itself from the tracking composite or a multi-stage scheduling happens || wouldnt the only use case subscriptionb be for an entirely linear observable chain (does not use merge zip groupby )? || > wouldnt the only use case subscriptionb be for which is almost all the time the `merge` operator for example will `add` a `subscriptiona` to the `subscriptionb` this way the right data structure is used in the right places || should we deprecate `remove()` and `clear()` on `compositesubscription` in 018x and leave something else to have the `remove` capability? || merging  then we can bike shed over naming before releasing 019 || @akarnokd there are several things as discussed above that we can improve here lets pick them up in separate pull requests and coordinate them with  ||;;;;1;1;reduce subscription object allocation- significant reduction in object allocations- details on research available at https://githubcom/netflix/rxjava/issues/1204;
1283;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;reduce subscription object allocation;- significant reduction in object allocations - details on research available at https://github.com/netflix/rxjava/issues/1204;;0;reduce subscription object allocation;- significant reduction in object allocations- details on research available at https://githubcom/netflix/rxjava/issues/1204;backporting from the 019 work on master for 018x as this is a major performance fix that we and others need || fantastic enhancement @benjchristensen brought my run time processing 112 million records from over an hour down to 5 minutes  ||;;;;1;1;reduce subscription object allocation- significant reduction in object allocations- details on research available at https://githubcom/netflix/rxjava/issues/1204;
1284;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;manual merge of lock-free  mpsc-queue based;pulling in the mpsc queue from  leaving out the serializedobserver change until further analysis. getting this data structure in as we likely want to use it in other places.  moved it into rx.internal.util and added a readme so it is very clear this is an internal package and not part of the public api.;;0;manual merge of lock-free mpsc-queue based;pulling in the mpsc queue from  leaving out the serializedobserver change until further analysis getting this data structure in as we likely want to use it in other placesmoved it into rxinternalutil and added a readme so it is very clear this is an internal package and not part of the public api;#1184  #1185;;;;1;1;move mpsc queue to rxinternalutil;
"1286;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;rename some operator* classes to onsubscribe* as per #1270;see discussion in issue #1270.   numerous classes in the  rx.operator  package are not implementations of  operator  but are actually implementations of  onsubscribe . the classes have been renamed in this pull request.  excuse me not squashing commits  looked complicated after doing a pull from upstream in the middle.;;1270.0;rename some operator* classes to onsubscribe* as per #1270;see discussion in issue #1270 numerous classes in the `rxoperator` package are not implementations of `operator` but are actually implementations of `onsubscribe` the classes have been renamed in this pull requestexcuse me not squashing commits looked complicated after doing a pull from upstream in the middle;#1187 ;rename operatormulticast and operatormulticastselector?;was looking at the source of [operatormulticast]( and  [operatormulticastselector]( and neither implements `operator` is a rename in order here or are they going to be made into `operator`s soonish?;""they cant be operators because they need to be `connectableobservable`s i think the naming is just stuck so they dont stand out of the other operatorxyz classes btw there are a bunch of operatorxyz which implement onsubscribe only yet they are called operator || yep youre quite right of the 93 operator\* classes in the `operator` package roughly 22 do not implement `operator` this is a lot of hiding though perhaps some are candidates to implement `operator` in the near future why not rename everything that is not an `operator` (and not a candidate for conversion to `operator`)?  might prompt a new package or two to contain these beasts  in the case of the classes above id prefer to see them as `connectableobservablemulticast` and `connectableobservablemulticastselector` || heres a quick list might have missed some:```operatorambjava:public final class operatoramb<t> implements onsubscribe<t>{operatorcachejava:public final class operatorcache<t> implements onsubscribe<t> {operatorcombinelatestjava:public final class operatorcombinelatest<t r> implements onsubscribe<r> {operatordeferjava:public final class operatordefer<t> implements onsubscribe<t> {operatordelayjava:public final class operatordelay<t> implements onsubscribe<t> {operatordelayjava:    public static final class emitter<t> implements onsubscribe<t> action0 {operatordelaysubscriptionjava:public final class operatordelaysubscription<t> implements onsubscribe<t> {operatordelaywithselectorjava:public final class operatordelaywithselector<t u v> implements onsubscribe<t> {operatorgroupjoinjava:public final class operatorgroupjoin<t1 t2 d1 d2 r> implements onsubscribe<r> {operatorjoinjava:public final class operatorjoin<tleft tright tleftduration trightduration r> implements onsubscribe<r> {operatormulticastjava:public final class operatormulticast<t r> extends connectableobservable<r> {operatormulticastselectorjava:public final class operatormulticastselector<tinput tintermediate tresult> implements onsubscribe<tresult> {operatorparallelmergejava:public final class operatorparallelmerge {operatorrefcountjava:public final class operatorrefcount<t> implements onsubscribe<t> {operatorreplayjava:public final class operatorreplay {operatorsequenceequaljava:public final class operatorsequenceequal {operatorskipjava:public final class operatorskip<t> implements observableoperator<t t> {operatortakeuntiljava:public final class operatortakeuntil {operatortimeroncejava:public final class operatortimeronce implements onsubscribe<long> {operatortimerperiodicallyjava:public final class operatortimerperiodically implements onsubscribe<long> {operatortomapjava:    public static final class defaulttomapfactory<k v> implements func0<map<k v>> {operatortomultimapjava:    public static final class defaulttomultimapfactory<k v> implements func0<map<k collection<v>>> {operatortomultimapjava:    public static final class defaultmultimapcollectionfactory<k v>operatortoobservablefuturejava:public class operatortoobservablefuture {operatorusingjava:public final class operatorusing<t resource extends subscription> implements onsubscribe<t> {``` || these operators are considered internal implementation and unless you are a hard-core rxjava-core developer you dont need to worry about what is in `rxoperators` many of these operators dont implement operator because the behavior they need to perform can only be done while in onsubscribecall() there is no one to pass a subscriber further up since they behave basically as sources || the ones that implement `onsubscribe` could be renamed from `operator*` to `onsubscribe*`more importantly though these should never be relied upon publicly they are not part of the public api and can change at any time even once we hit 10 || so i dont have hard core understanding of the rxjava code base but im using it on a a lot of projects at work and to develop with rxjava i very frequently dig small holes into the source code to understand what im using and i use the source as a cookbook i cant imagine developing with the library without the source code given that id like to see those spades called spades to minimize a bit of possible confusion (eg why is `observablecreate` being called with an `operator` what overload is that?) happy to knock up a pull request if this has support || im okay with a change that makes the `onsubscribe` implementations start with `onsubscribe`so that this is clean please do not mix any other changes with it just renaming those ~20 files that should start with `onsubscribe` instead of `operator`example `operatoramb` -> `onsubscribeamb`@akarnokd do you have an issue with this? it seems to be clearer and matches the intent of of classes such as `onsubscriberange` and `onsubscribefromiterable` already there ||  for me using operator as prefix is simpler so no need to remember the base interface for each operator id even drop the prefix but i guess that would just complicate auto-complete in ides || these classes are internal and referenced from a single place `observable` so im fine either way i think we should either give them a completely generic prefix (i cant think of one right now) or make the `onsubscribe*` and `operator*` prefix consistent as suggested in this issue || the generic prefix idea is not attractive to me because i lose visibility at a glance of what types the classes are i end up in the same place as i am now dropping the prefix would do the job if we moved non-operators out of the operator package to an onsubscribe package my preference at the moment is operator -> onsubscribe || im fine with you changing the prefixes if you want to contribute that || sounds good || now that we have `rxinternal` should we move `rxoperators` to `rxinternaloperators` alongside `rxinternalutil`? this way it is very clear that these are internal and not part of the public api? || fine with me || sounds good || sounds goodon 31 may 2014 03:33 """"headinthebox"""" notifications@githubcom wrote:> sounds good> > > reply to this email directly or view it on github>  || ill make this change || "";1;0;fix groupby and groupbyuntil which are actually operators;"
"1287;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;replaysubject remove replaystate chm and related subjectobserver changes;for issue #1204  this change should help avoid chm garbage (although boxed integers will still fly around). in addition  i moved the notificationlite around to make room for the index. i ve also removed the callback onadd in publishsubject because it was unnecessary.;;1204.0;replaysubject remove replaystate chm and related subjectobserver changes;for issue #1204this change should help avoid chm garbage (although boxed integers will still fly around) in addition i moved the notificationlite around to make room for the index ive also removed the callback onadd in publishsubject because it was unnecessary;#1188  awesome ill try this against the tests i was doing || this looks like it does improve performance and object allocation when using my hystrix tests i get this:new```run: 10 - 208720 ops/sec run: 11 - 209834 ops/sec run: 12 - 209217 ops/sec run: 13 - 208026 ops/sec run: 14 - 211303 ops/sec ```old```run: 10 - 153523 ops/sec run: 11 - 162289 ops/sec run: 12 - 162347 ops/sec run: 13 - 159153 ops/sec run: 14 - 160194 ops/sec ```new```run: 10 - 572909 ops/sec run: 11 - 568987 ops/sec run: 12 - 572521 ops/sec run: 13 - 571594 ops/sec run: 14 - 572979 ops/sec ```old```run: 10 - 487791 ops/sec run: 11 - 491292 ops/sec run: 12 - 480598 ops/sec run: 13 - 484517 ops/sec run: 14 - 489212 ops/sec ```old:![old]( i need to go give hystrix some love too as there are some obvious things to go solve therethanks @akarnokd for getting to this so quickly ||;profiling memory usage and object creation;we need to spend time profiling memory and object allocation and finding places where we can improve i would really appreciate help diving into this and finding problem areas even if you dont fix them but just identity use cases operators etc that would be very valuablethis is partly a result of the fact that in netflix production we have seen an increase in younggen gcs since 017xthe areas to start should probably be:- observablecreate- observablelift- subscriber- compositesubscription- map- flatmapif you can or want to get involved in this please comment here so we all can collaborate together;""the most likely source of garbage is the `compositesubscription`: whenever a task is scheduled or a new merge-source appears the state transition creates a new state object and copies the subscription array pr #1145 reduces the amount of garbage by switching to hashset on a larger composite since flatmap->mergemap->merge needs to track the active inner subscriptions it uses a composite as well and would gain the same benefits || the `hashset` change shouldnt kick in though because these arent generally large lists (handful at most not hundreds) i expect its just far too many of them being created || ill also like to help out here since its crucial for our uses as well  || thanks @daschl id appreciate your help profiling and identifying hot spots is what we need most right now || i did some gc profiling of my test workloads and id also like to nominate:- blockingobservable (it seems that especially in the single() case its not optimized)- observablesubscribe (for both observer and subscriber) - in my gc logs they take up 40% of the overall gc pressurethe bad news is that i had to fall back out of observables to plain execution on the hot code path (aside from the overall wrapping observable) because also using it in the path produces way too much garbage (moving away from rx in the hot code path got my throughput from 20% to 80% according to the gc logs) and it correlates with my findings since i could not sustain constant io throughput because of full gcs happening way too frequently || > observablesubscribe (for both observer and subscriber)not surprised on this were you able to identify what the garbage is?  || i did some changes in my code and will re-profile and post the results here so we get better measurements here is a slightly older profile run which might give you a hint or two![screen shot 2014-05-20 at 10 13 10]( shot 2014-05-20 at 10 13 00]( || we can definitely improve on the `atomicreference` by using atomicfieldupdater the others will require more effort to analyze along with sample code to see whats triggering them || i think that many `atomicreference` come from mostly the `compositesubscription` instances || i went back in history to 0161 to compare performance of the basic `map`/`flatmap` behavior and found that current master is faster this fits what i had expected of the work of the past couple months which means its not an obvious glaring issue (unless my test is completely flawed)here is the code for the test:- branch 016 >  master >  results#### 016```benchmark                                       (size)   mode   samples         mean   mean error    unitsruperftransformsflatmaptransformsusingfrom        1  thrpt         5  2421210583    68845966    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5     1017787       73597    ops/sruperftransformsflatmaptransformsusingjust        1  thrpt         5  2398541067    90703197    ops/sruperftransformsflatmaptransformsusingjust     1024  thrpt         5      990623      100735    ops/sruperftransformsmaptransformation                 1  thrpt         5  4020548060   262841500    ops/sruperftransformsmaptransformation              1024  thrpt         5    16205747      352618    ops/s```#### master```benchmark                                       (size)   mode   samples         mean   mean error    unitsruperftransformsflatmaptransformsusingfrom        1  thrpt         5  3184873133   172320420    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5     9079937      343905    ops/sruperftransformsflatmaptransformsusingjust        1  thrpt         5  3411785677    73767161    ops/sruperftransformsflatmaptransformsusingjust     1024  thrpt         5    10860963      294309    ops/sruperftransformsmaptransformation                 1  thrpt         5  7208334997   703327745    ops/sruperftransformsmaptransformation              1024  thrpt         5    18720797      278529    ops/s```### gcon the master branch test im seeing gc results like this:```iteration   5: 3189218350 ops/s          gc | wall time  5001 secs  gc time  0047 secs gc%  094% gc count  +98iteration   5: 9198700 ops/s          gc | wall time  5002 secs  gc time  0048 secs gc%  096% gc count  +98```versus 016```iteration   5: 2420099017 ops/s          gc | wall time  5000 secs  gc time  0046 secs gc%  092% gc count  +96iteration   5: 993867 ops/s          gc | wall time  5001 secs  gc time  0100 secs gc%  200% gc count  +212```### summaryunless im mistaken current code is better:- similar gc behavior on `observable` with 1 item better gc behavior with 1024 items- higher ops/second on all of the map/flatmap testsill start profiling this and improve  but this does not reveal the source of the problems seen possibly its related to schedulers or its a specific operator i exercised `map` `flatmap` (and thus `merge`) `observable` and `subscribe` here to get the most fundamental ones || the `observeon` test shows the cost of scheduling  particularly `observable`s of a single item``` java    @generatemicrobenchmark    public void observeon(usecaseinput input) throws interruptedexception {        inputobservableobserveon(schedulerscomputation())subscribe(inputobserver)        inputawaitcompletion()    }``````ruperfobserveonobserveon        1  thrpt         5   457830180     9943221    ops/sruperfobserveonobserveon     1024  thrpt         5    14496430      518463    ops/s```thus with an `observable` of 1 item we can do 457k onnext/second with an `observable` of 1024 items we can do 148million onnext/second (145k \* 1024) || by the way all testing is just being done on my mac laptop  so these numbers are all relative and not representative of proper server hardware || converting from `atomicreference` to `atomicreferencefieldupdater` improved performance from this:```benchmark                                       (size)   mode   samples         mean   mean error    unitsruperftransformsflatmaptransformsusingfrom        1  thrpt         5  3184873133   172320420    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5     9079937      343905    ops/sruperftransformsflatmaptransformsusingjust        1  thrpt         5  3411785677    73767161    ops/sruperftransformsflatmaptransformsusingjust     1024  thrpt         5    10860963      294309    ops/sruperftransformsmaptransformation                 1  thrpt         5  7208334997   703327745    ops/sruperftransformsmaptransformation              1024  thrpt         5    18720797      278529    ops/s```to this:```benchmark                                       (size)   mode   samples         mean   mean error    unitsruperftransformsflatmaptransformsusingfrom        1  thrpt         5  3459205110   124790906    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5     9225037      604720    ops/sruperftransformsflatmaptransformsusingjust        1  thrpt         5  3639603060   225599038    ops/sruperftransformsflatmaptransformsusingjust     1024  thrpt         5    11135613      337022    ops/sruperftransformsmaptransformation                 1  thrpt         5  7264202633   214787109    ops/sruperftransformsmaptransformation              1024  thrpt         5    18795790      713668    ops/s``` || @benjchristensen i suppose the `atomicreferencefieldupdater` mostly comes from less gc pressure is that why the raw throughput increases in your tests? how did the gc wall time change? || if you want me to run a specific workload/type of test let me know so we can compare results || ive been experimenting with fieldupdaters and unsafe for the `serializedobserver` it seems that by using unsafe directly and thus avoiding security checks and an indirection i can get about 8-10% more throughput the downsides are that it is scheduled to be removed/standardized in future java versions and platform dependence in terms of availability should i pursue the unsafe path? || @akarnokd since rxjava also runs on android im not sure how good/standard the support is therei know that the netty folks are having the same issues and they are wrapping those unsafe calles in a platformdependent util class || > wrapping those unsafe calles in a platformdependent util classthis sounds like a valid approach for us as we mature rx well want to squeeze as much performance out of it as we can while still remaining portable || testing with:```/gradlew benchmarks -pjmh-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 5 -prof gc *perftransforms*```##### may 21st                                        (size)   mode   samples         mean   mean error    unitsruperftransformsflatmaptransformsusingfrom        1  thrpt         5  4597237797   227193650    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5    12334190      214479    ops/sruperftransformsflatmaptransformsusingjust        1  thrpt         5  4522036147   216489787    ops/sruperftransformsflatmaptransformsusingjust     1024  thrpt         5    12293223      321573    ops/sruperftransformsmaptransformation                 1  thrpt         5  9133316230   303274438    ops/sruperftransformsmaptransformation              1024  thrpt         5    19698323      150313    ops/s```##### may 26th                                        (size)   mode   samples         mean   mean error    unitsruperftransformsflatmaptransformsusingfrom        1  thrpt         5  4367166623   145506857    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5    11382233      425976    ops/sruperftransformsflatmaptransformsusingjust        1  thrpt         5  4468497400    83649115    ops/sruperftransformsflatmaptransformsusingjust     1024  thrpt         5    11374780      780039    ops/sruperftransformsmaptransformation                 1  thrpt         5  8851147610   303583393    ops/sruperftransformsmaptransformation              1024  thrpt         5    19649227     1134279    ops/s```according to these results we got slower (though within mean error it appears so if not slower then no better) || which java version is this? java 6 intrinsics isnt as good as the newer versions maybe the `wip` field in the merge operator causes more false sharing and needs padding || /library/java/javavirtualmachines/jdk170_45jdk || master branch with /library/java/javavirtualmachines/jdk180_05jdk```benchmark                                       (size)   mode   samples         mean   mean error    unitsruperftransformsflatmaptransformsusingfrom        1  thrpt         5  4378589533   109056155    ops/sruperftransformsflatmaptransformsusingfrom     1024  thrpt         5    10702953      447216    ops/sruperftransformsflatmaptransformsusingjust        1  thrpt         5  4341206933   184228619    ops/sruperftransformsflatmaptransformsusingjust     1024  thrpt         5    10961550      545574    ops/sruperftransformsmaptransformation                 1  thrpt         5  8996983320   226242030    ops/sruperftransformsmaptransformation              1024  thrpt         5    19423813      779759    ops/s``` || here is a [simple test]( without jmh (but using same coding pattern) that shows significant increases in throughput from 016 -> 017 -> 018 -> current master branch for this code:``` java    public void maptransformation(usecaseinput input) throws interruptedexception {        inputobservablemap(i -> {            return stringvalueof(i)        })map(i -> {            return integerparseint(i)        })subscribe(inputobserver)        inputawaitcompletion()    }```##### master```run: 10 - 10333567 ops/sec run: 11 - 10235100 ops/sec run: 12 - 10269259 ops/sec run: 13 - 10170560 ops/sec run: 14 - 10072319 ops/sec ```##### version 0183```run: 10 - 7973782 ops/sec run: 11 - 8695425 ops/sec run: 12 - 8283768 ops/sec run: 13 - 8283562 ops/sec run: 14 - 8270888 ops/sec ```##### version 0176 (using `onsubscribe`)```run: 10 - 7812927 ops/sec run: 11 - 7632713 ops/sec run: 12 - 7488673 ops/sec run: 13 - 7975944 ops/sec run: 14 - 7882146 ops/sec ```##### version 0176 (using `onsubscribefunc`)```run: 10 - 7049700 ops/sec run: 11 - 7175042 ops/sec run: 12 - 7173240 ops/sec run: 13 - 7069685 ops/sec run: 14 - 7248320 ops/sec ```##### version 0161```run: 10 - 4765899 ops/sec run: 11 - 4792623 ops/sec run: 12 - 4709982 ops/sec run: 13 - 4761451 ops/sec run: 14 - 4769627 ops/sec ``` || very good progress! ill get back to profiling from master next week || i run some benchmarks with `atomicinteger` and `volatile int` inside merge and it appears that jmh benchmark gives 10% more throughput with `atomicinteger` || well thats odd and doesnt help much when two different ways of measuring are giving contradictory results :-( || we captured some profiling from a production instance and found evidence that suggests our atomic state machines are going to have to be changed or replaced---the biggest allocation hotspot is creating `rxsubscription` from `rxsubscriptionscompositesubscription$stateremove(subscription)` and `rxsubscriptionscompositesubscription$stateadd(subscription)`this accounts for approximately 104gb of total allocations within the profile (~30% of total allocation)theres also ~15gb allocated for rxsubjectssubjectsubscriptionmanager$state split pretty evenly from these 3 methods:```- rxsubjectssubjectsubscriptionmanager$statecreatenewwith(subjectsubscriptionmanager$subjectobserver)- rxsubjectssubjectsubscriptionmanager$stateterminate()  - rxsubjectssubjectsubscriptionmanager<init>()```another ~12gb of allocations for `rxsubjectssubjectsubscriptionmanager$subjectobserver` from 4 sources:```- rxsubjectssubjectsubscriptionmanager$state<init>(boolean countdownlatch subjectsubscriptionmanager$subjectobserver)- rxsubjectssubjectsubscriptionmanager$state<init>()- javautilarrayscopyof(object int) called by rxsubjectssubjectsubscriptionmanager$stateaddobserver(subjectsubscriptionmanager$subjectobserver)- rxsubjectssubjectsubscriptionmanager$stateremoveobserver(subjectsubscriptionmanager$subjectobserver)```heres a list of top allocated rx\* objects that exceed 100mb(numbers are in bytes):```rxsubscription                                           97870643480rxsubjectssubjectsubscriptionmanager$state                1624120080rxsubjectssubjectsubscriptionmanager$subjectobserver    1315680480rxsubscriptionssubscriptions$1                            849212800rxsubscriptionscompositesubscription$state                837518872rxsubscriptionscompositesubscription                      641083960rxobserverssafesubscriber                                 637599560rxsubjectssubjectsubscriptionmanager$subjectobserver      618721656rxobservable$30                                            585739968rxoperatorssafeobservablesubscription                     568522112rxsubjectssubjectsubscriptionmanager$1                    545755280rxsubjectsreplaysubject$history                           528269104rxsubjectsreplaysubject                                   443043720rxobservable                                               395292296rxoperatorsoperatormerge$1$innerobserver                  370883064rxsubjectsreplaysubject$replaystate                       340267192rxobservable$29                                            288726208rxoperatorsblockingoperatortofuture$2                     288463944rxsubjectssubjectsubscriptionmanager                      281230064rxsubjectsreplaysubject$3                                 266953480rxsubjectsreplaysubject$2                                 260071464rxoperatorsblockingoperatortofuture$1                     256919568rxsubjectssubjectsubscriptionmanager$1$1                  245468584rxsubjectsreplaysubject$1                                 238637944rxoperatorsoperatorcache                                  147967240rxobserverssubscribers$1                                  132742032rxsubscriptionsbooleansubscription                        107733248rxobservable$2                                             105170440``` || @benjchristensen asked me to contribute a bit to this issue weve been noticing some issues with rxjava 018x through our use of hystrixlet me setup our use case first to give you an idea of our usage pattern for this particular service we have a pretty standard public api (think microservice single-purpose) that does about 200/s incoming calls and fans that out into ~500-1000 command executions/s this can burst to over 800/s incoming calls without warningthe service is on a pretty modest deployment of c1mediums but its also sitting at about 20% cpu normally since deploying hystrix 1316 w/ rxjava 0182 our heaps that were previously steady sawtooths around 50-70mb have risen to over 150mb additionally our cpu percentages really start to rise after a few days this appears to be linked to our latencytotal_mean times deviating far from our latencyexecute_mean as you can see below the command is decreasing in ops/s but the hystrix overhead is rising this rise continues for about 5 days to where its taking anywhere from 20-30ms of hystrix overhead and the boxes are running near 80-90% cpu![command execution]( took a heap dump of one of the production servers i can provide it on request but shown below is a piece i found interesting:![subscription objects]( 800k subscriptions were present in the heap dump at the time which really smells off to me even when i forced gcs they were sticking around see the below our heap usage was increasing over time:![heap usage]( started looking at the compositesubscription used by hystrix and really drilling into it ran across this:![compositesubscription array]( subscription array on this has grown to 400k perhaps this is an edge case but i believe that once it falls behind it really struggles to keep up this would explain the non-linear jump in hystrix overhead observed in the graph of the command execution time``` java        state add(subscription s) {            int idx  subscriptionslength            subscription newsubscriptions  new subscription[idx + 1]            systemarraycopy(subscriptions 0 newsubscriptions 0 idx)            newsubscriptions[idx]  s            return new state(isunsubscribed newsubscriptions)        }```for every addition its creating a brand new array and copying the new subscriptions into them? is there a reason behind that? removals then iterate the entire array and alloc a new array (usually  twice?):``` java        state remove(subscription s) {            if ((subscriptionslength  1 && subscriptions[0]equals(s)) || subscriptionslength  0) {                return clear()            }            subscription newsubscriptions  new subscription[subscriptionslength - 1]            int idx  0            for (subscription _s : subscriptions) {                if (!_sequals(s)) {                    // was not in this composite                    if (idx  newsubscriptionslength) {                        return this                    }                    newsubscriptions[idx]  _s                    idx++                }            }            if (idx  0) {                return clear()            }            // subscription appeared more than once            if (idx < newsubscriptionslength) {                subscription newsub2  new subscription[idx]                systemarraycopy(newsubscriptions 0 newsub2 0 idx)                return new state(isunsubscribed newsub2)            }            return new state(isunsubscribed newsubscriptions)        }```i dont have a misbehaving instance at the moment but id wonder if profiling would show lots of cpu time spent in `remove()`unless im missing a key factor here id think hashset would be much more performant in this context for o(1) lookups & removals i cant imagine that the overhead of the set entries would be more than memory copies at the very least an arraylist would cut down on allocs & copieslet me know if im off base here im very interested in helping resolve this issue || thanks for the details compositesubscription becomes very slow when it grows over the size of the cache line in the cpu and constant add/remove is happening (see #1145)subscriptions$2 is perhaps the wrapper for future which keeps a final reference to the future object which generally shouldnt be a problem if its parent container is removing/clearing itwhat is worrying is that there is an unsubscribed `compositesubscription` with a non-empty array when unsubscribed `compositesubscription` should drop the entire array and dont accept any new additions could you tell where that `compositesubscription` is embedded? || got itin our use case were doing a `hystrixcommand#observe()` and passing the observable to ``` java    public static <t> listenablefuture<t> tolistenablefuture(observable<t> observable) {        final settablefuture<t> listenablefuture  settablefuturecreate()        final atomicreference<subscription> s  new atomicreference<subscription>()        sset(observablesubscribe(new observer<t>() {                                 @override                                 public void oncompleted() {                                 }                                 @override                                 public void onerror(throwable e) {                                    listenablefuturesetexception(e)                                 }                                 @override                                 public void onnext(t args) {                                    if (listenablefutureisdone()) {                                        listenablefuturesetexception(new illegalstateexception(""""observable should only have a single value""""))                                    } else {                                        listenablefutureset(args)                                    }                                 }                             }))        return listenablefuture    }```this only happens ~50 times a second per server `compositesubscription` is being used  hystrixcontextscheduler#threadpoolworker` but from my investigation of the code it looks like these are recreated for each command invokation @benjchristensen am i right about this?in my heap dump these 400000-long arrays of subscriptions seem to be actively being recycled and used so somehow those compositesubscription instances are sticking around i cant seem to identify where the threadpoolworker instance might be getting reused though || @xorlev thanks for the detailed post very helpful to have another set of clues beyond what weve been seeing> id think hashset would be much more performant in this context for o(1) lookups & removals i cant imagine that the overhead of the set entries would be more than memory copies at the very least an arraylist would cut down on allocs & copiesfor the use cases we appear to be triggering definitely yes this is partially what @akarnokd was seeking to solve in  when we designed the current implementation of `compositesubscription` we used an atomic state machine as the expectation was that there should never be more than a handful of `subscription`s added to it and we were trying to avoid mutable state needing to be protected by locks and that the extra object allocations to allow use of compareandset was okay performance testing weve done has shown this to be a win (in the cases weve been testing) but obviously there are cases where this is breaking badlyso we can pivot to using a mutable data structure protected by locks to avoid the object allocation (such [as this]( but right now im still trying to identify the use cases that are causing this> what is worrying is that there is an unsubscribed compositesubscription with a non-empty array when unsubscribed compositesubscription should drop the entire array and dont accept any new additions could you tell where that compositesubscription is embedded?this is an open question we see the same symptom in our production environment though not sure if its an actual leak or just such high pressure that the gc cant keep up so it looks like they are leakingresearching further today   || > `hystrixcontextscheduler#threadpoolworker`yes that is just a thin wrapper around a real `scheduler` used by hystrix to copy state across threads it is allocated for each command>  these 400000-long arrays of subscriptions seem to be actively being recycled and used so somehow those compositesubscription instances are sticking aroundthat is the key problem im trying to find today im going to focus on the hystrix use cases since its the one that triggers it seems it is either a bug in how hystrix is using rx or its triggering a bug or unexpected use case in rx that we need to handle || if its helpful i also found this interesting which lead me down the path of investigating `compositesubscription$state`![stack]( can put the heap dump on dropbox and email you a link if itd be helpful ben || that is helpful it points to looking at the `eventloopscheduler` || this is creating lots of `arraylist` instances unnecessarily:  shot 2014-05-29 at 10 35 48 am]( shot 2014-05-29 at 10 37 45 am]( || ![replaystate-arraylist-object]( || ![hystrix rx-with-0 18 2]( || those were from 0182  now with master plus a [modified]( `compositesubscription` we get this:![hystrix rx-with-master new-compositesubscription]( || here is evidence for need of work on `replaysubject`:![replaysubject-1]( || ![0 18 2-map observeon]( observeon]( || the `subscription[]` issue is definitely being caused by the use of a `scheduler` here is some evidence:![subscription-array-when-using-scheduler]( the master branch with `compositesubscription` change:![screen shot 2014-05-29 at 10 58 09 am]( issue is definitely the `compositesubscription` as the following shows where it is master as it currently stands without my changes to `compositesubscription`:![master-without-changing-compositesubscription]( || ive added some logging to our production instances and discovered that the cause of large subscription arrays we see in practice is caused by a prefetching operation which generates many (> 500) `hystrixcommand`s calls `observe` on them puts them in an arraylist and finally calls `observablemerge` on this list to have a single place to listen for overall completionthis seems like a valid case to support and any work which improves performance for large subscription arrays would be a meaningful improvement || i have submitted a pull request for this:  are testing the code in our environment shortly || for anyone wanting to dig into this java flight recorder has been very helpful and far better than the other profiling tools ive used and tried for this || backporting to 018x in  || superb work guys ive held off on 18x on android as i noticed an increase in gc really glad you guys take this seriously! || thanks @chrisjenx  it looks like the most glaring issues are resolved and low hanging fruit taken care of there are a few other things for us to improve on but i think well release 019 early next week i would appreciate your feedback on whether you see an improvementi have also opened  to document our attempts on blocking vs non-blocking implementations and to seek input from anyone who can provide better solutions || @akarnokd is there anything else that stands out to you that we should fix before closing this issue? ill continue doing some profiling but it seems the obvious ones well continue working on performance going forward and those can have their own issues and pull requests so if nothing else obvious stands out lets close this issue and not leave it open-ended || the history list in replaysubject since arraylist uses more memory then actual items it might be worth compacting it on a terminal state (one time but might be costly and run out of memory) alternatively it could use  increment expansion strategy third option is to have a cache() overload that passes in a capacity hint to reduce reallocation and wasted space || i think that the object allocation penalty of resizing after a terminal event would be worsea cache() overload that takes a capacity hint may be valuable particularly in the single item case where it could just a single volatile ref instead of an array   || i have opened a new issue for the cache() overload:  || im closing this issue out as i believe we have handled the most glaring problems and dont want this to be a never-ending issue we will of course continue seeking to improve performance but lets use individual issues for each improvement/problem we findthanks everyone for your involvement on this one as it was rather significant and important@xorlev and @daschl i would appreciate feedback once youve had a chance to try the changes in the master branch (or the portion that was backported to 0184) to know if you see the improvements or still have issues @xorlev in particular id like to know if the issue you had was only the gc pressure or if you still see signs of a memory leak (which i have not seen yet) || @benjchristensen hystrix 1316 w/ rxjava 0184 has been in prod for about a day now im happy to report a decrease in garbage (and cpu usage in general) i believe the pressure & the suboptimal subscription removal was causing the leak-like behavior @mattrjacobss use case matches a few of our own (fan out commands wait on all) which is likely the source of the large numbers of subscriptionsill keep an eye out for any similar issues that might crop upthanks a lot for all the help and dedication to improving rxjava || excellent thank you @xorlev for the confirmation ill release hystrix 1317 in a few days hopefully with rxjava 019 as a dependency and at least one performance optimization i found i can do in hystrix directly || "";1;0;remove duplicate notificationlite;"
1289;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;schedulers.from(executor);as per decision at https://github.com/netflix/rxjava/issues/1219#issuecomment-44454729;;0;schedulersfrom(executor);as per decision at https://githubcom/netflix/rxjava/issues/1219#issuecomment-44454729;;;;;1;1;schedulersfrom(executor)as per decision at https://githubcom/netflix/rxjava/issues/1219#issuecomment-44454729;
1290;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;upgrade to jmh 0.7.3;as per https://github.com/netflix/rxjava/issues/1205;;0;upgrade to jmh 073;as per https://githubcom/netflix/rxjava/issues/1205;;;;;1;1;upgrade to jmh 073;
1293;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix and update jmh perf tests;- the tests were wrong and re-using a single subscriber instance which meant they weren t really testing much. - same with the countdownlatch which meant they weren t waiting if async. - added several serializeperf and perftransform tests;;0;fix and update jmh perf tests;- the tests were wrong and re-using a single subscriber instance which meant they werent really testing much- same with the countdownlatch which meant they werent waiting if async- added several serializeperf and perftransform tests;;;;;1;1;fix and update jmh perf tests- the tests were wrong and re-using a single subscriber instance which meant they werent really testing much- same with the countdownlatch which meant they werent waiting if async- added several serializeperf and perftransform tests;
1294;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;rx.operators -> rx.internal.operators;move  rx.operators  to  rx.internal.operators  for clarity that these can change at any time and are not part of the public api.  discussed at https://github.com/netflix/rxjava/issues/1270#issuecomment-44668606;;0;rxoperators -> rxinternaloperators;move `rxoperators` to `rxinternaloperators` for clarity that these can change at any time and are not part of the public apidiscussed at https://githubcom/netflix/rxjava/issues/1270#issuecomment-44668606;would it make sense to create a similar rxinternalschedulers package and move out some of the re-used code from `scheduler` inner classes? like newthreadschedulerrxthreadfactory or newthreadschedulernewthreadworker @akarnokd do you have an opinion on this? || im assuming that the meaning of internal for rxjava users will be that - may suffer breaking changes in any version- not recommended for direct useim not using them directly myself but it strikes me that one of the advantages of the `operator` interface will be lost to users and that is composability do we want to take this away from users? || > im assuming that the meaning of internal for rxjava users will be that those 2 bullet points are correct the `operator` itself though is not internal its `rxobservableoperator` so is completely available to them what type of composability are you concerned with? i cant think of any reason why users would need to use the `operator*` classes directly> would it make sense to create a similar rxinternalschedulers package and move out some of the re-used code from scheduler inner classesim open to that seems to make sense || internal scheduler package is okay with me we may move the subjectsubscriptionmanager as well and make static inner classes normal classesin addition i would consider moving schedulers static methods directly into scheduler subscribers static methods into subscriber perhaps even subjectnewasync() company this should match the way java 8 added streamof() instead of streams or streamutils unfortunately without static interface methods observer and subscription cant be unified this way  || ok ill make a pull request request that creates the rxinternalschedulers package and move what i feel is appropriate there thinking of moving rxthreadfactory to rxinternalutil though since its not really scheduler specific || my issue is that if i want to create my own `operator` that is the composition of other operators then in the implementation of the `operator` interface i can write for instance``` javapublic class myoperator<t> implements operator<t> {   @override  public subscriber<? super t> call(final subscriber<? super t> subscriber) {      return operator1call(operator2call(operator3call(subscriber)))  }}```if the `operator*` classes are marked as internal then this implies that i should not instantiate my `operator1``operator2``operator3` classes from the internal packagethe ability to be able to easily construct `operators` from others is also discussed in #983 ||;;;;1;1;rxoperators -> rxinternaloperators;
1295;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;change  void accept  to  boolean accept;as per a change @akarnokd did elsewhere with  accept2  method.;;0;change `void accept` to `boolean accept`;as per a change @akarnokd did elsewhere with `accept2` method;#1193;;;;1;1;change `void accept` to `boolean accept`as per a change @akarnokd did elsewhere with `accept2` method;
1296;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;move re-used internal scheduler classes to their own package;as discussed in #1294;;0;move re-used internal scheduler classes to their own package;as discussed in #1294;#1194  ;;;;1;1;move newthreadworker out from newthreadscheduler- break out scheduledaction from newthreadworker;
1307;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;testnotificationdelay - attempt at determinism;trying to make this deterministic  i think it was possible for scheduling in the executor to cause different threads to be used  even when queueing happened. this forces the same thread to be used as it is different executors.;;0;testnotificationdelay - attempt at determinism;trying to make this deterministic  i think it was possible for scheduling in the executor to cause different threads to be used even when queueing happened this forces the same thread to be used as it is different executors;;;;;1;1;testnotificationdelay - attempt at determinism;
1309;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;hide chainedsubscription/subscriptionlist from public api;instead of adding this type to the public api  it hides it as an internal implementation detail and does not expose it via the  subscriber  constructor.  if we want to expose it later we can figure out a proper name and do so.  this also changes operator implementations to not inject a  subscriptionlist  but instead just create the  subscriber  and use it directly.;;0;hide chainedsubscription/subscriptionlist from public api;instead of adding this type to the public api it hides it as an internal implementation detail and does not expose it via the `subscriber` constructorif we want to expose it later we can figure out a proper name and do sothis also changes operator implementations to not inject a `subscriptionlist` but instead just create the `subscriber` and use it directly;#1209  like || i agree with this variant || great thanks for the review || #1210;;;;1;1;hide chainedsubscription;
"1311;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;tiny integration test change;it s a tiny change.  i ve been following this project for a while as a hobby  also want to contribute to it.   currently i am going through test cases to learn. found some tiny problems as we are testing  concat   we should care not only the total number of elements  but also the sequences.  creating this request mainly want to make sure i am writing/commiting code to the correct place.  let me know if there is any problem.  best regards  mingtao;;0;tiny integration test change;""its a tiny changeive been following this project for a while as a hobby also want to contribute to it currently i am going through test cases to learn found some tiny problems as we are testing """"concat"""" we should care not only the total number of elements but also the sequencescreating this request mainly want to make sure i am writing/commiting code to the correct placelet me know if there is any problembest regardsmingtao"";#1211  thanks for getting involved and improving these tests ||;;;;1;1;attempt to fix one integration test class;"
1324;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;trampolinescheduler & unsubscribe;unsubscribing should prevent new additions to a worker  but not prevent already scheduled work  and definitely not affect other workers using the same thread (by modifying the threadlocal as it was doing).  see the unit test for details of how unsubscribing 1 worker could prevent work from being done on a completely separate worker.;;0;trampolinescheduler & unsubscribe;unsubscribing should prevent new additions to a worker but not prevent already scheduled work and definitely not affect other workers using the same thread (by modifying the threadlocal as it was doing)see the unit test for details of how unsubscribing 1 worker could prevent work from being done on a completely separate worker;;;;;1;1;trampolinescheduler & unsubscribeunsubscribing should prevent new additions to a worker but not prevent already scheduled work and definitely not affect other workers using the same thread (by modifying the threadlocal as it was doing)see the unit test for details of how unsubscribing 1 worker could prevent work from being done on a completely separate worker;
"1347;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;allow use of the returned subscription to cancel periodic scheduling;the documentation for scheduleperiodically indicates that the returned subscription can be used to unsubscribe from the periodic action  or to unschedule it if it has not been scheduled yet. that was the case only before the first action took place  and it was then impossible to unsubscribe using the given subscription  although unsubscribing the worker did work.  this 1344.;;1344.0;allow use of the returned subscription to cancel periodic scheduling;the documentation for scheduleperiodically indicates that the returnedsubscription can be used to unsubscribe from the periodic action or tounschedule it if it has not been scheduled yet that was the case onlybefore the first action took place and it was then impossible tounsubscribe using the given subscription although unsubscribing theworker did workthis 1344;#1257  this new version contains a  fix by @akarnokd || #1258 thank you ||;scheduleperiodically cannot be unsubscribed from;""the subscription returned  scheduleperiodically()` is automatically marked as unsubscribed when the first run terminates after queuing the next event as a result the periodic event cannot be unsubscribed from once the first `call()` happens as `unsubscribe()` will now be a no-op (as `isunsubscribed` is true)example in the scala repl (with the java bindings for rxjava 019):``` scalaimport rx_import rxfunctions_import rxschedulersschedulersimport javautilconcurrenttimeunitval s  schedulersio()createworkerscheduleperiodically(new action0 { override def call  println(""""in call"""") } 1 1 timeunitseconds)sisunsubscribed```here `sisunsubscribed()` returns `false` however if you wait one second it will return `true` and `sunsubscribe()` will not do anything and the constant display will continue every second"";;1;0;allow use of the returned subscription to cancel periodic schedulingthe documentation for scheduleperiodically indicates that the returnedsubscription can be used to unsubscribe from the periodic action or tounschedule it if it has not been scheduled yet that was the case onlybefore the first action took place and it was then impossible tounsubscribe using the given subscription although unsubscribing theworker did work;"
1357;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;mergewith  concatwith  ambwith;single-arity instance versions of merge  concat and amb. since we can t use the  merge / concat / amb  names on both static and instance methods  these have the  with  suffix  which actually reads quite well.      java o.mergewith(o2).subscribe(ts)  o.concatwith(o2).subscribe(ts)  o.ambwith(o2).subscribe(ts)       if we feel the need for more arities fine  but i wanted to start simple.  this originated from discussions with @headinthebox and over a year of wanting instance methods for  merge .;;0;mergewith concatwith ambwith;single-arity instance versions of merge concat and ambsince we cant use the `merge`/`concat`/`amb` names on both static and instance methods these have the `with` suffix which actually reads quite well``` javaomergewith(o2)subscribe(ts)oconcatwith(o2)subscribe(ts)oambwith(o2)subscribe(ts)```if we feel the need for more arities fine but i wanted to start simplethis originated from discussions with @headinthebox and over a year of wanting instance methods for `merge`;#1276  like! ||;;;;1;1;mergewith concatwith ambwithsingle-arity instance versions of merge concat and ambsince we cant use the `merge`/`concat`/`amb` names on both static and instance methods these have the `with` suffix which actually reads quite well```javaomergewith(o2)subscribe(ts)oconcatwith(o2)subscribe(ts)oambwith(o2)subscribe(ts)```if we feel the need for more arities fine but i wanted to start simplethis originated from discussions with @headinthebox and over a year of wanting instance methods for `merge`;
"1367;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix the bug that  flatmap  swallows onerrornotimplementedexception;fixed #1365 not sure if any other place will swallow  onerrornotimplementedexception  or the fatal errors.;;1365.0;fix the bug that flatmap swallows onerrornotimplementedexception; #1365not sure if any other place will swallow `onerrornotimplementedexception` or the fatal errors;""#1292  #1293 hi allim new here so i may be missing something but im afraid that this issue should not be closed just yetindeed it looks like there is still a problem if there is more than one flatmap in the chainhere is a unit test to reproduce the bug (i used the previous unit test that was added as part of this bugfix and simply added an additional flatmap stage) :```    @test(expected  onerrornotimplementedexceptionclass)    public void testsubscribewithoutonerror() {        observablejust(""""a"""" """"b"""")        flatmap(s -> observablejust(s + """"1"""" s + """"2""""))        flatmap(s -> observableerror(new exception(""""test"""")))        foreach(systemout::println)    }```the output i get is nothing and no error eithershould i submit a new issue or can you reopen this one? think the issue still exists there needs to be clear functionality by which exception can be cleanly trapped and rethrown if needed(user preference) to upper layers "";exception in the inner observable of flatmap not rethrown;""hi allim trying to figure out how errors are handled in rxjava (0191) basically id expect the fundamental rule to be something like: _any exception thrown within an operator is either handed to the onerror handler of subscribe if one is provided or rethrown if none is provided_this works for the map operator: ``` scaladef throwonb2(prefix: string)  observablefrom(list(1 2 3))  map(x  prefix + xtostring)  map(s  if (s  """"b2"""") throw new exception(""""bang!"""") else s)throwonb2(""""b"""")subscribe(next  println(next))```throws a `rxexceptionsonerrornotimplementedexception: bang!` as expected``` scalathrowonb2(""""b"""")subscribe(  next  println(next)  err  println(s""""error: ${err}"""")  ()  println(""""completed""""))```prints `error: javalangexception: bang!` as expectedfor nested observables joined using `flatmap```` scaladef nested  observable  from(list(""""a"""" """"b"""" """"c""""))  flatmap(prefix  throwonb2(prefix))nested  subscribe(    next  println(next)    err  println(s""""error: ${err}"""")    ()  println(""""completed"""")  )```prints `error: javalangexception: bang!` as expected**but:**``` scalanestedsubscribe(next  println(next))```prints```a1a2a3b1```and finishes without throwing any exception is this the intended behavior? for me it is quite unfortunate since bugs in my code can easily slip away unnoticed but perhaps there is something i dont seethank you best regards"";@dvtomas good catch ||;1;0;fix the bug that flatmap swallows onerrornotimplementedexception;"
1376;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;revision of jmh tests;this updates all perf testing to use only jmh. i tried to get all of them to follow a common pattern  and to comply with examples at  by @nitsanw. (@nitsanw if you re willing to take a look at this and confirm or correct them  i d appreciate that).  i am doing this in 0.19 so that work on 0.20 has a common set of perf tests to use for comparison.;;0;revision of jmh tests;this updates all perf testing to use only jmh i tried to get all of them to follow a common pattern and to comply with examples at  by @nitsanw (@nitsanw if youre willing to take a look at this and confirm or correct them id appreciate that)i am doing this in 019 so that work on 020 has a common set of perf tests to use for comparison;#1315  sorry not sure when ill be able to review these changesin the next few days/weeks perhaps || @nitsanw no problem i know youre very busy if you ever have the chance and interest it would be good to know were following your examples right in the meantime though im pushing forward based on my current understandings of how to use jmh i appreciate your responses and involvement in our project! || my examples are very dated by now you should look at the latest samples on the jmh project> on 25 jun 2014 at 18:34 ben christensen notifications@githubcom wrote:> > @nitsanw no problem i know youre very busy if you ever have the chance and interest it would be good to know were following your examples right in the meantime though im pushing forward based on my current understandings of how to use jmh i appreciate your responses and involvement in our project!> > > reply to this email directly or view it on github || i ended up finding those after looking at yours and went through them as well i assume youre referring to these?  || yes :)> on 25 jun 2014 at 21:22 ben christensen notifications@githubcom wrote:> > i ended up finding those after looking at yours and went through them as well i assume youre referring to these?  > > reply to this email directly or view it on github || hi there :) not sure if thats intentional or not but poking around a few benchmarks there it seems you can make them even cleaner: instead of using the explicit `input` nested class you might as well use the enclosing class holding the `@benchmark` methods as `@state` class you seem to be having `@state(thread)` already on the enclosing classes only to delegate everything to nested class afterwardsthat is this sample works: ||;;;;1;1;revision of jmh tests- removal of all non-jmh perf tests;
"1380;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;variety of fixes; found while working on backpressure.;;0;variety of fixes;found while working on backpressure;#1318  nice catches ||;;;;1;1;""trampolinescheduler cleanupremove the null check and lazy creation build the queue in the threadlocal fix bugs about """"work in progress"""""";"
1387;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;upgrade to jmh 0.9;;;0;upgrade to jmh 09;;;;;;1;1;upgrade to jmh 09;
1388;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;compositeexception stops mutating nested exceptions;instead  it aggregates them at print-time. since nothing is being mutated  there s no chance of accidentally creating a cycle in the exception chain.  we ran into this in production very intermittently and had to add handling any time we were touching the exception chain.;;0;compositeexception stops mutating nested exceptions;instead it aggregates them at print-time since nothing is being mutated theres no chance of accidentally creating a cycle in the exception chain  we ran into this in production very intermittently and had to add handling any time we were touching the exception chain;#1329 #1330 ;;;;1;1; up safeobservertest wrt compositeexception changes;
"1393;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add cache(int capacity) to observable;proposed patch for #1303;;130.0;add cache(int capacity) to observable;proposed patch for #1303;#1335 ;compatibility test suite via port of rxnet unit tests;""to get to 10 and claim equivalence to rxnet it would be very beneficial to have an automated way of converting the rxnet code from c# to java (if realistic) and running them as a compatibility test suite - for functionality but also for feature completion is not intended to attempt automated conversion of c# code for the actual code - that has been looked at and isnt realistic the unit tests may be possible (scripting search/replace from c# to java/groovy or something similar)some of the tricks will be:- naming idioms will be different for some things- we will need to do it in such a way that compilation errors are handled as """"test failures"""" rather than preventing the entire suite from running (perhaps a dynamic language would be easier for this?)- we need the ability to update the test suite whenever needed in a fully automated way so that as rxnet code changes we can easily update the rxjava compatibility test suite- schedulers will be based on java executorservice and javautilconcurrent so this may affect unit tests from netthese tests are also not intended to replace unit tests written manually in java/groovy/clojure etc as already doing as part of the core code - these are intended to supplement and be used primarily to track completeness and demonstrate compatibility (if it can even be done)"";not going to happen  may reincarnate as part of  but not going to keep it open here ||;1;0;add cache(int capacity) to observable;"
1397;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;adding the hooks unsafesubscribe;by making the execution and error handling exactly same as safe version without the safety checks.;;0;adding the hooks unsafesubscribe;by making the execution and error handling exactly same as safe version without the safety checks;#1340 ;;;;1;1;adding the hooks unsafesubscribe by making the execution same as safe version without the safety checks;
1399;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;update perf tests;matching with work being done for 0.20 to allow comparisons;;0;update perf tests;matching with work being done for 020 to allow comparisons;#1347 ;;;;1;1;update perf testsmatching with work being done for 020 to allow comparisons;
1400;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;internal data structures;various data structures to allow performance improvements. i am committing these separately from the code that uses it to keep the pull requests simpler. nothing in rxjava depends on these classes in this commit.;;0;internal data structures;various data structures to allow performance improvementsi am committing these separately from the code that uses it to keep the pull requests simplernothing in rxjava depends on these classes in this commit;#1348 ;;;;1;1;internal data structuresvarious data structures to allow performance improvementsi am committing these separately from the code that uses it to keep the pull requests simplernothing in rxjava depends on these classes in this commit;
1412;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;backpressure & 0.20.0-rc1;this is a functioning implementation of backpressure. of the major unbounded queue operators in 0.19  this implements  observeon  and  merge  but not yet  zip .  ### new signatures      java public interface producer {     public void request(int n)  }          java public abstract class subscriber<t> implements observer<t>  subscription {      /**      * optionally called from  observable.onsubscribe .      */     public final void setproducer(producer producer)       /**      * allow implementing classes to capture  decorate or override the  producer  without affecting the  subscriber  logic.      */     protected producer onsetproducer(producer producer)       public final void request(int n)  };;0;backpressure & 0200-rc1;this is a functioning implementation of backpressure of the major unbounded queue operators in 019 this implements `observeon` and `merge` but not yet `zip` ### new signatures``` javapublic interface producer {    public void request(int n)}`````` javapublic abstract class subscriber<t> implements observer<t> subscription {    /**     * optionally called from `observableonsubscribe`     */    public final void setproducer(producer producer)    /**     * allow implementing classes to capture decorate or override the `producer` without affecting the `subscriber` logic     */    protected producer onsetproducer(producer producer)    public final void request(int n)}```;#1368  as per discussion in  i am merging this and master is now going to be used for 020 release candidates || #1369 until im back with more time could you compose a document about developing with the new backpressure what to look out etc? the thing i dont see is what calls request(n) first and over again and when in a chain of operators? ||;;;;1;1;backpressure & 0200-rc1;
1414;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;merge fixes;a handful of fixes  particularly one that could cause non-deterministic missing data.;;0;merge fixes;a handful of fixes particularly one that could cause non-deterministic missing data;;;;;1;1;test timingadjust timing for slower machines (such as cloudbees);
1417;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;proposal: subscriber.onstart;this is a proposal derived from conversations with @headinthebox to use  subscriber.onstart  rather than constructor overloads as the mechanism for allowing  request(n)  to be called to operationally start backpressure (or do anything else at the start of a stream).  the idea is that it is at the start the same as  onerror  or  oncompleted  are terminal events. it will always be called.  usage for subscribing is like this:      java         observable.from(1  2  3  4).take(2).subscribe(new subscriber<integer>() {              @override             public void onstart() {                 request(1)              }              @override             public void oncompleted() {              }              @override             public void onerror(throwable e) {              }              @override             public void onnext(integer t) {                 system.out.println(t)                  request(1)              }          })       or when writing an  operator  via  lift :      java         observable.from(1  2  3  4).lift(new operator<integer  integer>() {              @override             public subscriber<? super integer> call(final subscriber<? super integer> child) {                 return new subscriber<integer>() {                      @override                     public void onstart() {                         request(1)                      }                      @override                     public void oncompleted() {                         child.oncompleted()                      }                      @override                     public void onerror(throwable e) {                         child.onerror(e)                      }                      @override                     public void onnext(integer t) {                         system.out.println(t)                          child.onnext(t)                          request(1)                      }                  }              }          }).subscribe()       both of these examples are requesting 1 item at a time.;;0;proposal: subscriberonstart;this is a proposal derived from conversations with @headinthebox to use `subscriberonstart` rather than constructor overloads as the mechanism for allowing `request(n)` to be called to operationally start backpressure (or do anything else at the start of a stream)the idea is that it is at the start the same as `onerror` or `oncompleted` are terminal events it will always be calledusage for subscribing is like this:``` java        observablefrom(1 2 3 4)take(2)subscribe(new subscriber<integer>() {            @override            public void onstart() {                request(1)            }            @override            public void oncompleted() {            }            @override            public void onerror(throwable e) {            }            @override            public void onnext(integer t) {                systemoutprintln(t)                request(1)            }        })```or when writing an `operator` via `lift`:``` java        observablefrom(1 2 3 4)lift(new operator<integer integer>() {            @override            public subscriber<? super integer> call(final subscriber<? super integer> child) {                return new subscriber<integer>() {                    @override                    public void onstart() {                        request(1)                    }                    @override                    public void oncompleted() {                        childoncompleted()                    }                    @override                    public void onerror(throwable e) {                        childonerror(e)                    }                    @override                    public void onnext(integer t) {                        systemoutprintln(t)                        childonnext(t)                        request(1)                    }                }            }        })subscribe()```both of these examples are requesting 1 item at a time;have you considered the single onsubscribe from the reactive manifesto? ie a single callback with an injected object to request and cancel the producer instead of buffing up the subscriber? || yes i have ive been involved in that design the problem is that rxjava already has a contract about how the `subscription` is handled and we must support `observable`/`subscriber` without backpressurealso the rxjava `rxsubscription` can not be the same as `rxproducer` due to how `rxsubscription` is used || the `subscribersetproducer(producer p)` is the equivalent of the reactive streams `onsubscribe(subscription s)` in reactive streams it must always emit this and nothing will flow unless `request(n)` is invoked that is not the case in rx  || like! || #1375];;;;1;1;ignoring non-deterministic test until someone can figure it outthis code is far less important now since it is no longer used by merge;
"1422;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;concurrency fixes for rxringbuffer & merge;possible fix for #1420  i was unable to exactly reproduce the issue  but was able to create a possibly related one. this fixes it. it also simplifies the logic and code somewhat  at a possible small performance cost for these:      r.o.operatormergeperf.merge1syncstreamofn            1000  thrpt         5    59407.716     2073.945    ops/s r.o.operatormergeperf.merge1syncstreamofn         1000000  thrpt         5       66.557        2.693    ops/s r.o.operatormergeperf.mergensyncstreamsofn           1000  thrpt         5       59.293        5.046    ops/s;;1420.0;concurrency fixes for rxringbuffer & merge;possible fix for #1420i was unable to exactly reproduce the issue but was able to create a possibly related one this fixes itit also simplifies the logic and code somewhat at a possible small performance cost for these:```rooperatormergeperfmerge1syncstreamofn            1000  thrpt         5    59407716     2073945    ops/srooperatormergeperfmerge1syncstreamofn         1000000  thrpt         5       66557        2693    ops/srooperatormergeperfmergensyncstreamsofn           1000  thrpt         5       59293        5046    ops/s```;;merge missing emission bug - causes hangs;doing a canary test of the current 020 code in master branch with real workloads it runs fine for several hours and then non-deterministically fails over a couple hoursthreads end up in this state:```204 waiting    at sunmiscunsafepark(native method)    at javautilconcurrentlockslocksupportpark(locksupportjava:186)    at javautilconcurrentlocksabstractqueuedsynchronizer$conditionobjectawait(abstractqueuedsynchronizerjava:2043)    at javautilconcurrentlinkedblockingqueuetake(linkedblockingqueuejava:442)    at rxinternaloperatorsblockingoperatortoiterator$2take(blockingoperatortoiteratorjava:92)```here is a screenshot showing 3 instances over 9 hours how they perform well until something triggers the bug at different times on each box:![screen shot 2014-07-09 at 9 42 09 am](https://cloudentcom/assets/813492/3527738/0968e970-0788-11e4-9de8-2d43aff51c8epng);""@benjchristensen would you be able to provide some information regarding what does the source observable and the chain of operators look like? i guess can can say the after materialize() the complete notification never made it though the internal subscriber in blockingoperatortoiterator? || does it use backpressure? || > what does the source observable and the chain of operators look likeit is a list of observables that each return a single item being merged together```   javalangthreadstate: waiting (parking)    at sunmiscunsafepark(native method)    - parking to wait for  <0x00007f69fe0c6798> (a javautilconcurrentlocksabstractqueuedsynchronizer$conditionobject)    at javautilconcurrentlockslocksupportpark(locksupportjava:186)    at javautilconcurrentlocksabstractqueuedsynchronizer$conditionobjectawait(abstractqueuedsynchronizerjava:2043)    at javautilconcurrentlinkedblockingqueuetake(linkedblockingqueuejava:442)    at rxinternaloperatorsblockingoperatortoiterator$2take(blockingoperatortoiteratorjava:92)    at rxinternaloperatorsblockingoperatortoiterator$2hasnext(blockingoperatortoiteratorjava:72)    at rxinternaloperatorsblockingoperatortoiterator$2next(blockingoperatortoiteratorjava:82)    at rxobservablesblockingobservablesingle(blockingobservablejava:348)    at comnetflixapiservice    at rxobservable$2call(observablejava:163)    at rxobservable$2call(observablejava:156)    at rxobservableunsafesubscribe(observablejava:6846)    at rxinternaloperatorsoperatormerge$mergesubscriberhandlenewsource(operatormergejava:127)    at rxinternaloperatorsoperatormerge$mergesubscriberonnext(operatormergejava:110)    at rxinternaloperatorsoperatormerge$mergesubscriberonnext(operatormergejava:49)    at rxinternaloperatorsoperatormap$1onnext(operatormapjava:54)```> does it use backpressure?nothing is explicitly using backpressure except for changes in rxjava itself the codebase is currently running rxjvaa 0192 and im dropping in 0200-snapshotdebugging as i have time   || pretty certain this is yet another concurrency bug in `merge` || see my zip pr for a candidate if i have time ill look at merge || i had some time but the current merge is so complicated i cant make anything out of it || i really dont like the `merge` code but everything i try to simplify it (such as simple """"add to queue then drain"""") kills the performance significantly || the changes in #1422 did not solve this i ran a new canary and have the same issue digging  || that is a scary stack trace does the simplification kill perf for the non-backpressure case as well?  || no the simplification in #1422 didnt kill perfthe stack trace itself is pretty normal (`merge` does `unsafesubscribe`) except for the ugliness of how `toblocking` is being used by the observables being merged :-(thus far i still have no idea what causes this to fail i cant replicate it anywhere except for production and thats making it very hard to track down || i confirmed over the weekend with a production canary that the issue is related to `merge` i took the code in master branch and reverted `operatormerge` to 019x code but left everything else as is the issue did not occur continuing to dig  i have an idea as to where the issue might be || code changes ive committed seem to have  this issue ive had the code running in production for 12 hours and the score is good and thread dumps look clean  || @benjchristensen great news! || looks like this isnt completely solved as im seeing it still just far less oftenim going to commit a change that i know solves it but it uses synchronization in a bad way i dont yet understand the actual issue just the symptoms and the hammer that removes the symptoms || could you help me understand how `merge(observable<observable<t>>)` works? if the downstream requests 10 elements how is that translated to requests to the outer and inner observables? even if any requests are transformed into one-by-one requests that cant be held in a fixed buffer because either one requests 1 from n observables which might not deliver or requests 1 from all observables where there could be a buffer overrun if all produce? || the outer is unbounded (except in the optimized case with `scalarsynchronousobservable`) the `merge(observable<observable<t>>)` case is an odd one and basically the user is asking for unbounded horizontal bufferingwe can achieve backpressure vertically (how many items queued per observable) but not horizontally (number of observables being merged) the reasoning is:- a user cant control how many onnext per observable flow but they can generally control the number of observables they are merging- we cant restrict how many observables are merged unless the user asks for it (such as `merge(observable o int maxconcurrent)` because it may only be the very last observable that emits so if we sit waiting on the first ones we may never receive any values and never move on to the final observable that has the datathis is different in the `scalarsynchronousobservable` case as we treat those as `onnext` and dont even subscribe to them this is why the `request(1)` behavior occurs in the current `merge` implementation at these two locations:- every observable we receive we automatically request more:  on `scalarsynchronousobservable`s we only request more once we have been able to emit their values:  || ive solved this for now with synchronization so am closing ill work more on this over time for performance and efficiency reasons but as of 0200-rc3 the issue is not showing itself and i have successfully passed a 20-hour production canary test in netflix api production || "";1;0;concurrency fixes for rxringbuffer & merge;"
1423;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;changed producer interface to work with long instead of int;changing  int  to  long  in  producer  implementations.;;0;changed producer interface to work with long instead of int;changing `int` to `long` in `producer` implementations;#1380 ;;;;1;1;changed producer interface to work with long instead of int;
"1431;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;compositeexception fix for android;1405 - revert changes from f4ae92aa - remove duplicated causes in stack trace chain;;1405.0;compositeexception fix for android;1405- revert changes from f4ae92aa- remove duplicated causes in stack trace chain;""#1385 this will take a while to review as those changes were done for good reason || maybe i should provide some explanation about what was wrong with the previous implementationheres how most of java programmers will rethrow an exception if not handled:```        observablecreate((subscriber<? super object> subscriber) ->                subscriberonerror(new runtimeexception(""""ex1"""")))                observeon(androidschedulersmainthread())                subscribeon(schedulersio())subscribe(                object -> {                    //                 } error -> {                    // handle some exceptions                                        // rethrow unhandled                    throw new runtimeexception(""""ex2"""" error)                }        )```now we have `compositeexception` with two nested exceptions:- `ex1`- `ex2` which cause is `ex1`the previous implementation will create a loop in this situation:```onerrorfailedexception   compositeexception      ex1         ex2             ex1                 ex2                     ``` ive provided test for this scenario and additional method to remove throwables which are causes of another throwable it means `ex1` will not be attached as a cause of the `compositeexception` because it is a cause of `ex2` so it will be automatically attached with `ex2` and printed in the stack trace output ```onerrorfailedexception   compositeexception         ex2             ex1``` || /cc @mattrjacobs matt can you get involved here (now that youre back) since you have the most recent history and context in this code discussion at  || given the new constraint that android does something unexpected (to me anyway) with the set of printstacktrace methods its probably preferable to modify the structure of compositeexception so that any arbitrary output of a compositeexception is correct  relying on the implementation details of precisely how android does the printstacktrace doesnt protect us from any other edge cases  so i generally think the sort of change proposed by @tomrozb is good - im validating what the output looks like in our prod env now  thanks @tomrozb for the pr || im merging this now thanks for the clear explanation and fix with a test @tomrozb || thanks @mattrjacobs and @tomrozb  || "";compositeexception issue;im using rxjava on android and ive encountered issues with compositeexception because it collects throwables as `collection<throwable> errors` the exceptions are not logged to the logcat output if there is an unhandled exception in onerror callback here is a sample output:```2739:e/androidruntime(14639): fatal exception: main2740:e/androidruntime(14639): rxexceptionsonerrorfailedexception: error occurred when trying to propagate error to observeronerror2741:e/androidruntime(14639):   at rxobserverssafesubscriber_onerror(safesubscriberjava:182)2742:e/androidruntime(14639):   at rxobserverssafesubscriberonerror(safesubscriberjava:103)2743:e/androidruntime(14639):   at rxinternaloperatorsnotificationliteaccept(notificationlitejava:144)2744:e/androidruntime(14639):   at rxinternaloperatorsoperatorobserveon$observeonsubscriberpollqueue(operatorobserveonjava:139)2745:e/androidruntime(14639):   at rxinternaloperatorsoperatorobserveon$observeonsubscriberaccess$000(operatorobserveonjava:61)2746:e/androidruntime(14639):   at rxinternaloperatorsoperatorobserveon$observeonsubscriber$1call(operatorobserveonjava:121)2747:e/androidruntime(14639):   at rxinternalschedulersscheduledactionrun(scheduledactionjava:43)2748:e/androidruntime(14639):   at androidoshandlerhandlecallback(handlerjava:730)2749:e/androidruntime(14639):   at androidoshandlerdispatchmessage(handlerjava:92)2750:e/androidruntime(14639):   at androidoslooperloop(looperjava:137)2751:e/androidruntime(14639):   at androidappactivitythreadmain(activitythreadjava:5103)2752:e/androidruntime(14639):   at javalangreflectmethodinvokenative(native method)2753:e/androidruntime(14639):   at javalangreflectmethodinvoke(methodjava:525)2754:e/androidruntime(14639):   at comandroidinternaloszygoteinit$methodandargscallerrun(zygoteinitjava:737)2755:e/androidruntime(14639):   at comandroidinternaloszygoteinitmain(zygoteinitjava:553)2756:e/androidruntime(14639):   at dalviksystemnativestartmain(native method)2757:e/androidruntime(14639): caused by: rxexceptionscompositeexception: 2 exceptions occurred see them in causal chain below2758:e/androidruntime(14639):    16 more```thats it no logs about real cause i can wrap my onerror code in try catch block and log the real cause but i think this can be handled better by rxjava what do you guys think?;""how do you recommend doing it differently?  || what about using `initcause` (api 1) or im sure `addsuppressed` is dedicated for this case but as far as i remember it was introduced in java 7 so its available in kitkat (api 19) || we print them out when `printstacktrace()` is called but we no longer add them as part of the actual causal chain as it could end up causing circular loops under odd edge-cases this was just barely changed in the last release:  is the code:  how it will print all causes:  version of rxjava are you running to get that stack trace?in the example you give it looks like the chain is being cropped when it had more to display (2 causes)im wondering if android does something different than normal java and doesnt actually invoke the `printstacktrace()` method and thus wont see the causal chain? || im using 0192 ive also encountered problems with the previous version when unhandled exception in onerror ended up in circular loop and crash of a stringbuilder but current implementation doesnt provide any useful information for debugging if you are using error logging service like bugsense or crashlytics the only information you see is the stacktrace ive pasted above - its uselesssolution with `initcause` works perfect for me what do you think about it? || as i said above we used to use `initcause` but because this is a composite of many exceptions we are creating an artificial causal chain and it could result in infinite loops hence it being removed in 0192i cant speak to bugsense or crashlytics but if something printing a stack trace calls `printstacktrace` then it would work and print out the full list of causesfor historical information here is the version that used `initcause`:  and the current one without it:  need a solution that either does not use `initcause` due to the circular-reference problem or solves the circular-reference problem the change done in  was based on the assumption that anything printing a stack trace would do it correctly via the `printstacktrace()` method and thus we can override the printing of the causes so the causal chain is shown but not actually mutate the chain by using `initcause` which is what causes the issues || ok ive dive deeper into the implementation and it turns out that none of the `printstacktrace` methods are called when an `onerrorfailedexception` is thrown only `getmessage` and `getcause` methods are called so the real cause is not printed to the output here is my simple test with logged methods of the `compositeexception` class```        androidruntime  d  shutting down vm              dalvikvm  w  threadid1: thread exiting with uncaught exception (group0x4195e700) gt_compositeexception  i  compositeexceptiongetmessage                        i  compositeexceptiongetcause              dalvikvm  d  gc_for_alloc freed 453k 5% free 11287k/11776k paused 29ms total 30ms gt_compositeexception  i  compositeexceptiongetcause                        i  compositeexceptiongetmessage                        i  compositeexceptiongetcause        androidruntime  e  fatal exception: main                        e  rxexceptionsonerrorfailedexception: a                        e   at testmainactivityrefreshtaskslists(mainactivityjava:267)                        e   at testmainactivityoncreateoptionsmenu(mainactivityjava:156)                        e   at androidappactivityoncreatepanelmenu(activityjava:2504)                        e   at comandroidinternalpolicyimplphonewindowpreparepanel(phonewindowjava:413)                        e   at comandroidinternalpolicyimplphonewindowdoinvalidatepanelmenu(phonewindowjava:775)                        e   at comandroidinternalpolicyimplphonewindow$1run(phonewindowjava:198)                        e   at androidviewchoreographer$callbackrecordrun(choreographerjava:749)                        e   at androidviewchoreographerdocallbacks(choreographerjava:562)                        e   at androidviewchoreographerdoframe(choreographerjava:531)                        e   at androidviewchoreographer$framedisplayeventreceiverrun(choreographerjava:735)                        e   at androidoshandlerhandlecallback(handlerjava:730)                        e   at androidoshandlerdispatchmessage(handlerjava:92)                        e   at androidoslooperloop(looperjava:137)                        e   at androidappactivitythreadmain(activitythreadjava:5103)                        e   at javalangreflectmethodinvokenative(native method)                        e   at javalangreflectmethodinvoke(methodjava:525)                        e   at comandroidinternaloszygoteinit$methodandargscallerrun(zygoteinitjava:737)                        e   at comandroidinternaloszygoteinitmain(zygoteinitjava:553)                        e   at dalviksystemnativestartmain(native method)                        e  caused by: testcompositeexception: 2 exceptions occurred see them in causal chain below                        e    19 more gt_compositeexception  i  compositeexceptiongetmessage                        i  compositeexceptiongetcause                        i  compositeexceptiongetmessage                        i  compositeexceptiongetcause                           process 28215 ended```it turns out android has its own implementation of a `throwable` with uses `private void private void printstacktrace(appendable err string indent stacktraceelement parentstack)` to print the stacktrace if the `cause` is `null` nothing is printed to the outputi dont see any solution for this issue for kitkat and above the `addsuppressed` is an easy fix but what about older versions? || what about appending the stack trace to the message of a `compositeexception`? this is some kind of a dirty hack but it will work on any platform regardless of `printstacktrace` implementation || appending the stacktrace to the message is bad practice and would be despised in non-android environmentsits very annoying that android does the wrong thing for this if we do anything it would need to special-case behavior just for android (such as appending the whole stack trace as a message) || i think any working solution would be appreciated by the android developers society i ended up wrapping the whole implementation of `onerror` in try-catch block so im able to log the cause so far this is a simple workaround but better error logging by the rxjava should be really addressed in the future release || @mttkay what do you suggest be done for android and `compositeexception` since it doesnt behave correctly with `throwableprintstacktrace()`?@tomrozb according to the code i see for android this should work if the logger is calling `printstacktrace()` as it looks exactly like the java one:  are the logs being generated? is this default android logging that bypasses `printstacktrace()` or a 3rd party logging library? || thanks for flagging this were still on 0191 so havent had this problem yet ill have a look as well  || @benjchristensen im not using any 3rd party logging library the logs ive attached are from the standard logging tool called logcat logs are generated by android system the second posted log is slightly different because im using tool to present it in a user-friendly way but the log is still being generated by android oscrash reporting tools like crashlytics or bugsense utilize the `threaduncaughtexceptionhandler` to obtain the stack trace and send it to the server as i wrote above stack traces obtained this way are exactly the same as printed by the systemthe `throwable` implementation is different for android and plain java if they are using the private `printstacktrace` method with 3 arguments to print the stack trace other public `printstacktrace` methods which are overridden by rxjava will not be called when a crash occurredi can confirm this bug on:galaxy nexus 43 (stock android)g900f 442gt-i9506 442gt-i9195 442gt-n7100 442sm-t335 442sm-t320 442ive not tested this on non-samsung devices but im sure this apply to all android devices || it is very easy to understand what is going under the hood even without writing a line of codethe simplest test case:```throw new runtimeexception(new compositeexception(arraysaslist(new runtimeexception(""""the real cause""""))))```no matter which one of the `printstacktrace` methods is called in the first place it end up calling the  `printstacktrace(err """""""" null)` on a first `runtimeexception` now take a look at the throwable implementation (android 422)```    private void printstacktrace(appendable err string indent stacktraceelement parentstack)            throws ioexception {        errappend(tostring())        errappend(""""\n"""")        stacktraceelement stack  getinternalstacktrace()        if (stack ! null) {            int duplicates  parentstack ! null ? countduplicates(stack parentstack) : 0            for (int i  0 i < stacklength - duplicates i++) {                errappend(indent)                errappend(""""\tat """")                errappend(stack[i]tostring())                errappend(""""\n"""")            }            if (duplicates > 0) {                errappend(indent)                errappend(""""\t """")                errappend(integertostring(duplicates))                errappend("""" more\n"""")            }        }        // print suppressed exceptions indented one level deeper        if (suppressedexceptions ! null) {            for (throwable throwable : suppressedexceptions) {                errappend(indent)                errappend(""""\tsuppressed: """")                throwableprintstacktrace(err indent + """"\t"""" stack)            }        }        throwable cause  getcause()        if (cause ! null) {            errappend(indent)            errappend(""""caused by: """")            causeprintstacktrace(err indent stack)        }    }```what is important the only method used on a `cause` is `printstacktrace` with 3 arguments our cause is the `compositeexception` which doesnt have a cause and there is no way to override private `printstacktrace` method so thats why it doesnt work this way || just wondering if the problem is that androids `throwable` refuses to print the stack trace when the cause is null why not simply return `this` from `compositeexceptiongetcause`? that way we still dont have to `initcause` on the wrapped exceptions and make android forward to `compositeexception`s custom printstacktrace implthis is just by reading the discussion mind you so sorry if im not making any sense i still havent had time to bump rxjava to a newer version in our app  || we see more threads getting stuck in infinite loops in `removeduplicatedcauses`  re-opening as we will need to re-fix this || so should we revert to what it was when we  it last time and special case android? or does someone have a legit fix for this?im planning on reverting to what was a known fix for non-android and then following up with a special case for android || closing out again as i believe this is solved in  per comment  this passed the netflix production canary over night there are no threads spinning on circular references> > this pull request should work for both android and oracle jvms as it supports both `printstacktrace` and `getcause` mechanisms the `printstacktrace` approach is better but the `getcause` one should work normally and then bail if it sees a circular reference || there are still issues with stack trace printing on android with rxjava 0203 for example when `unknownhostexception`  is thrown from `onsubscribe` implementation nothing is printed to the logcat output ive tested it on s5 442 s4 442 galaxy nexus 43simple example to reproduce:```        observablecreate(new onsubscribe<object>() {            @override            public void call(subscriber<? super object> subscriber) {                subscriberonerror(new unknownhostexception())            }        })subscribeon(schedulersio())                observeon(androidschedulersmainthread())                subscribe(new action1<object>() {                    @override                    public void call(object o) {                        // does nothing intentionally                    }                } new action1<throwable>() {                    @override                    public void call(throwable e) {                        throw new runtimeexception(e)                    }                })```logcat output:```        androidruntime  d  shutting down vm              dalvikvm  w  threadid1: thread exiting with uncaught exception (group0x417a7da0)        androidruntime  e  fatal exception: main                        e  process: plexampletest pid: 25099```change `unknownhostexception` to `ioexception` now logcat output looks like below:```        androidruntime  d  shutting down vm              dalvikvm  w  threadid1: thread exiting with uncaught exception (group0x417a7da0)        androidruntime  e  fatal exception: main                        e  process: plexampletest pid: 9153                        e  rxexceptionsonerrorfailedexception: error occurred when trying to propagate error to observeronerror                        e      at rxobserverssafesubscriber_onerror(safesubscriberjava:175)                        e      at rxobserverssafesubscriberonerror(safesubscriberjava:97)                        e      at rxinternaloperatorsnotificationliteaccept(notificationlitejava:144)                        e      at rxinternaloperatorsoperatorobserveon$observeonsubscriberpollqueue(operatorobserveonjava:169)                        e      at rxinternaloperatorsoperatorobserveon$observeonsubscriberaccess$000(operatorobserveonjava:66)                        e      at rxinternaloperatorsoperatorobserveon$observeonsubscriber$2call(operatorobserveonjava:151)                        e      at rxinternalschedulersscheduledactionrun(scheduledactionjava:43)                        e      at androidoshandlerhandlecallback(handlerjava:733)                        e      at androidoshandlerdispatchmessage(handlerjava:95)                        e      at androidoslooperloop(looperjava:136)                        e      at androidappactivitythreadmain(activitythreadjava:5586)                        e      at javalangreflectmethodinvokenative(native method)                        e      at javalangreflectmethodinvoke(methodjava:515)                        e      at comandroidinternaloszygoteinit$methodandargscallerrun(zygoteinitjava:1268)                        e      at comandroidinternaloszygoteinitmain(zygoteinitjava:1084)                        e      at dalviksystemnativestartmain(native method)                        e  caused by: rxexceptionscompositeexception: 2 exceptions occurred                        e       16 more                        e  caused by: rxexceptionscompositeexception$compositeexceptioncausalchain: chain of causes for compositeexception in order received >                        e      at androidutilloggetstacktracestring(logjava:421)                        e      at androidutilsloge(slogjava:151)                        e      at comandroidinternalosruntimeinit$uncaughthandleruncaughtexception(runtimeinitjava:109)                        e      at javalangthreadgroupuncaughtexception(threadgroupjava:693)                        e      at javalangthreadgroupuncaughtexception(threadgroupjava:690)                        e       1 more                        e  caused by: javaioioexception                        e      at plexampletestmyactivity$3call(myactivityjava:48)ioexception                        e      at plexampletestmyactivity$3call(myactivityjava:45)                        e      at rxobservableunsafesubscribe(observablejava:8587)                        e      at rxinternaloperatorsoperatorsubscribeon$1$1call(operatorsubscribeonjava:62)                        e      at rxinternalschedulersscheduledactionrun(scheduledactionjava:43)                        e      at javautilconcurrentexecutors$runnableadaptercall(executorsjava:422)                        e      at javautilconcurrentfuturetaskrun(futuretaskjava:237)                        e      at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskaccess$201(scheduledthreadpoolexecutorjava:152)                        e      at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:265)                        e      at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1112)                        e      at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:587)                        e      at javalangthreadrun(threadjava:841)                        e  caused by: javalangruntimeexception: duplicate found in causal chain so cropping to prevent loop                         e      at androidutilloggetstacktracestring(logjava:421)                        e      at androidutilsloge(slogjava:151)                        e      at comandroidinternalosruntimeinit$uncaughthandleruncaughtexception(runtimeinitjava:109)                        e      at javalangthreadgroupuncaughtexception(threadgroupjava:693)                        e      at javalangthreadgroupuncaughtexception(threadgroupjava:690)                        e      at dalviksystemnativestartmain(native method)```can anyone confirm this issue with the code ive attached? || i cant help to test this as i dont do android development or have an environment to test withthe current implementation uses `getcause()` to provide the causes so as long as android calls `getcause()` then it should work if however it even bypasses that (as it bypasses `printstacktrace`) and reaches into the internal super field then it wont work as we dont wire up the causal chain unless `getcause()` is invoked (instead of construction time as non-android platforms dont need or want that) if android is doing that  then apparently it doesnt obey any apisif android is completely ignoring even `getcause()` then the only way i can think of fixing this is having two different implementations and an android specific check that delegates to a different solution /cc @mttkay  || maybe theres something wrong with my code ive put the code above in onresume of a totally empty activity to nail down wheres the issue if somebody can test this on other devices it would be very helpful i dont have any non-samsung devices at the moment || ill put some time aside either tomorrow or thursday to work through a backlog of rx specific things i can try to reproduce theni havent personally seen this issue yet (were on 0203) but ill double check the crash logs || just a quick heads up that i can confirm this issuenot sure yet _why_ its happening but swapping out the exception type does appear to fix it which is odd since `unknownhostexception` _is_ an `ioexception`? i also looked at `exceptionsthrowiffatal` if it had to do with rethrowing exceptions or not but it does not mention either type || `unknownhostexception` is not the only one that is not logged im sure ive found at least 3 different exceptions that do not produce any output to the logcat ill post these exceptions here once i figure out which one causing problems good to hear that this issue is confirmed and easy to reproduce || its really hard to debug unfortunately i was able to pour your example in an automated test and run it on a genymotion 43 instance -- thats the easy part what im not able to do is debug into androids stack trace methods (parts of it are native code too but the problem might exist on the java layer) this might be an issue with the new project setup im usually able to debug platform classesill poke around some more || sorry im still fighting the tools :-/ i might have to pick this up again another day || moving android specific discussion to  || "";1;0;remove cycles in compositeexception;"
1443;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;infinite request with long.max_value instead of -1;migrating to this after discussions at https://github.com/reactive-streams/reactive-streams/issues/62;;0;infinite request with longmax_value instead of -1;migrating to this after discussions at https://githubcom/reactive-streams/reactive-streams/issues/62;;;;;1;1;infinite request with longmax_value instead of -1migrating to this after discussions at https://githubcom/reactive-streams/reactive-streams/issues/62;
1456;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;removing onsetproducer from the api;;;0;removing onsetproducer from the api;;#1408 this simplification looks good id be interested to see the discussion behind this i take it occurred offline but can you give a summary or copy it through? || it started because i lobbed this #1452 at @benjchristensen yesterday im not 100% sold on keeping `onstart()` because anything in there could be done on the `subscriber` before it is returned by the `operatorcall()`  ben convinced me that it is more in line with reactive-stream `onsubscribe(subscription)`  he did like the removal `onsetproducer()` while we were at it we made `request(long n)` protected || - the `onsetproducer` method always felt ugly and wrong but was added to solve a problem and i left it there but never liked it - the `onstart` was added to be more explicit rather than requiring either (1) an overloaded constructor (which is what i first did) or (2) requiring users to define the `subscriber` and then call `request` on it which prevent inline declarations@abersnaze pushed me to clean these up and we spent time discussing them and came to the following conclusions:- the `onsetproducer` can be removed but at the risk of a very nuanced behavior (the problem i mentioned above) if someone then calls `subscriberrequest` since it will no longer do anything if `setproducer` is over-written - to prevent this non-obvious behavior `subscriberrequest` was made protected so it can only be called by the class implementing the `setproducer` so they can make the right decision and because `request` doesnt really make sense any longer on a `subscriber` that is decoupling the `setproducer` chain- we kept `onstart` because making `request` protected effectively forces us to have a hook inside the class for invoking `request` (it can no longer be done externally even if we wanted to go that route) and we still dont like the constructorif i wasnt trying to make these changes additive (and was willing to do massive breaking changes) i would likely do some things differently but the constraint we have is to not fundamentally break rxjava 0x while getting to 10 || as `subscriberrequest` is now protected does this mean users of rxjava should _only_ use the `request()` method as outlined the [backpressure wiki doc]( ie only from the `onstart()` and `onnext()` methods within `subscriber`?what if there is some other external event that means i would like to request items from the producer?_(my case is an android scrolling view where i would only like items calculated on an `observablefrom(expensiveiterable)` **if** the user has scrolled near to the bottom of the list of so-far calculated data)_ || > (my case is an android scrolling view where i would only like items calculated on an observablefrom(expensiveiterable) if the user has scrolled near to the bottom of the list of so-far calculated data)if i understand correctly its triggered by a ui event which is hot it cannot work well with `request` as description in wiki:> cold observables are ideal subjects for the reactive pull model of backpressure described below hot observables are typically not designed to cope well with a reactive pull model and are better candidates for some of the other flow control strategies discussed on this page such as the use of the onbackpressurebuffer or onbackpressuredrop operators throttling buffers or windows || if you want to call `request` externally you can choose to expose a method to do so with another method than then calls `request(n)` for example:  was made protected because it is generally intended for inner use only  || > what if there is some other external event that means i would like to request items from the producer?i generally try to compose all events via combinatorial operators such as `zip` and  `combinelatest` so the `subscriber` receives an `onnext` and can make the decision to request more based on composed events  ||;;;;1;1;removing onsetproducer from the api;
1457;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;mergedelayerror & onerrorflatmap w/ merge;;;0;mergedelayerror & onerrorflatmap w/ merge;;#1409;;;;1;1;mergedelayerror & onerrorflatmap w/ merge;
1458;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove pivot operator;as per https://github.com/netflix/rxjava/issues/1402;;0;remove pivot operator;as per https://githubcom/netflix/rxjava/issues/1402;#1410 too many modules || but pivot _must_ die! || its death is imminent :-) || #1411 ;;;;1;1;remove pivot operatoras per https://githubcom/netflix/rxjava/issues/1402;
1467;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;javadocs for cache operator;;;0;javadocs for cache operator;;#1415 ;;;;1;1;javadocs for cache operator;
1489;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;backpressure fixes and docs;docs for operators that don t support backpressure  particularly all the temporal operators.  fixes for several that needed to request(1) or request(long.max_value).;;0;backpressure fixes and docs;docs for operators that dont support backpressure particularly all the temporal operatorsfixes for several that needed to request(1) or request(longmax_value);;;;;1;1;backpressure fixes and docsdocs for operators that dont support backpressure particularly all the temporal operatorsfixes for several that needed to request(1) or request(longmax_value);
1493;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;manual merge of retrywhen/repeatwhen;manual merge and rebase of https://github.com/netflix/rxjava/pull/1470;;0;manual merge of retrywhen/repeatwhen;manual merge and rebase of https://githubcom/netflix/rxjava/pull/1470;#1425 ;;;;1;1;add retrywhen example to javadoc;
1494;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;zipwith;match the naming convention of  mergewith    concatwith    ambwith  etc.;;0;zipwith;match the naming convention of `mergewith` `concatwith` `ambwith` etc;#1426 ;;;;1;1;zipwith;
1498;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;non-deterministic testusersubscriberusingrequestasync;fix non-deterministic failures of backpressuretests.testusersubscriberusingrequestasync  i was able to replicate the occasional failure by putting it in a tight loop. with these changes it no longer fails.;;0;non-deterministic testusersubscriberusingrequestasync;fix non-deterministic failures of backpressureteststestusersubscriberusingrequestasynci was able to replicate the occasional failure by putting it in a tight loop with these changes it no longer fails;;;;;1;1;non-deterministic testusersubscriberusingrequestasyncfix non-deterministic failures of backpressureteststestusersubscriberusingrequestasynci was able to replicate the occasional failure by putting it in a tight loop with these changes it no longer fails;
"1515;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;support subject factory with multicast;this is a proposed change to allow using a  subject  factory with  multicast  and for methods such as  publish()  and  replay()  to use the factory so that each time  connectableobservable.connect()  is invoked  a new  subject  is created and used. otherwise  an  observable  sequence can not be reused. #### use case      java         final atomicinteger count = new atomicinteger()          observable<integer> subject1 = observable.just(10)          observable<integer> subject2 = observable.just(20)          observable<integer> combined = observable.combinelatest(subject1  subject2  (fst  snd) -> {             int i = count.incrementandget()              system.out.println((fst + i) +   +   + (snd + i))              return fst + snd          }).publish().refcount()           combined.subscribe(                 system.out::println                  t -> t.printstacktrace()                  () -> system.out.println( completed ))           combined.subscribe(                 system.out::println                  t -> t.printstacktrace()                  () -> system.out.println( completed ))       output without these changes:      11 + 21 30 completed completed      output with changes:      11 + 21 30 completed 12 + 22 30 completed     #### test case      java     @test     public void testconnectdisconnectconnectandsubjectstate() {         observable<integer> o1 = observable.just(10)          observable<integer> o2 = observable.just(20)          observable<integer> combined = observable.combinelatest(o1  o2  new func2<integer  integer  integer>() {              @override             public integer call(integer t1  integer t2) {                 return t1 + t2              }          }).publish().refcount()           testsubscriber<integer> ts1 = new testsubscriber<integer>()          testsubscriber<integer> ts2 = new testsubscriber<integer>()           combined.subscribe(ts1)          combined.subscribe(ts2)           ts1.assertterminalevent()          ts1.assertnoerrors()          ts1.assertreceivedonnext(arrays.aslist(30))           ts2.assertterminalevent()          ts2.assertnoerrors()          ts2.assertreceivedonnext(arrays.aslist(30))      };;0;support subject factory with multicast;""this is a proposed change to allow using a `subject` factory with `multicast` and for methods such as `publish()` and `replay()` to use the factory so that each time `connectableobservableconnect()` is invoked a new `subject` is created and used otherwise an `observable` sequence can not be reused#### use case``` java        final atomicinteger count  new atomicinteger()        observable<integer> subject1  observablejust(10)        observable<integer> subject2  observablejust(20)        observable<integer> combined  observablecombinelatest(subject1 subject2 (fst snd) -> {            int i  countincrementandget()            systemoutprintln((fst + i) + """" + """" + (snd + i))            return fst + snd        })publish()refcount()        combinedsubscribe(                systemout::println                t -> tprintstacktrace()                () -> systemoutprintln(""""completed""""))        combinedsubscribe(                systemout::println                t -> tprintstacktrace()                () -> systemoutprintln(""""completed""""))```output without these changes:```11 + 2130completedcompleted```output with changes:```11 + 2130completed12 + 2230completed```#### test case``` java    @test    public void testconnectdisconnectconnectandsubjectstate() {        observable<integer> o1  observablejust(10)        observable<integer> o2  observablejust(20)        observable<integer> combined  observablecombinelatest(o1 o2 new func2<integer integer integer>() {            @override            public integer call(integer t1 integer t2) {                return t1 + t2            }        })publish()refcount()        testsubscriber<integer> ts1  new testsubscriber<integer>()        testsubscriber<integer> ts2  new testsubscriber<integer>()        combinedsubscribe(ts1)        combinedsubscribe(ts2)        ts1assertterminalevent()        ts1assertnoerrors()        ts1assertreceivedonnext(arraysaslist(30))        ts2assertterminalevent()        ts2assertnoerrors()        ts2assertreceivedonnext(arraysaslist(30))    }```"";""/cc @headinthebox and @mattpodwysocki this is based on our email conversation and is a proposed change to make `publish()refcount()` and other similar `multicast` use cases behave as a user would expect || #1436  here is another example to demonstrate why this change is probably a good thingoutput without this pull request:```[0 1 2 3 4][0 1 2 3 4][0 1 2 3][0 1 2 3 4][0]start again ```with this pull request (what a user would expect):```[0 1 2 3 4 5 6 7][0 1 2 3 4 5 6 7 8][0][0 1]start again [0 1 2 3 4 5 6 7][0 1 2 3 4 5][0 1 2][0 1 2]```example code:``` javaimport javautillistimport javautilconcurrenttimeunitimport rxobservableimport rxsubscriberimport rxschedulersschedulerspublic class debouncebuffer {    public static void main(string args) {        /* the following will emit a buffered list as it is debounced */        // first we multicast the stream  using refcount so it handles the subscribe/unsubscribe        observable<integer> burststream  intermittentbursts()take(20)publish()refcount()        // then we get the debounced version        observable<integer> debounced  burststreamdebounce(10 timeunitmilliseconds)        // then the buffered one that uses the debounced stream to demark window start/stop        observable<list<integer>> buffered  burststreambuffer(debounced)        // then we subscribe to the buffered stream so it does what we want        bufferedtoblocking()foreach(systemout::println)        systemoutprintln(""""start again """")        bufferedtoblocking()foreach(systemout::println)    }    public static observable<integer> intermittentbursts() {        return observablecreate((subscriber<? super integer> s) -> {            while (!sisunsubscribed()) {                // burst some number of items                for (int i  0 i < mathrandom() * 20 i++) {                    sonnext(i)                }                try {                    // sleep for a random amount of time                    threadsleep((long) (mathrandom() * 1000))                } catch (exception e) {                    // do nothing                }            }        })subscribeon(schedulersnewthread()) // use newthread since we are using sleep to block    }}``` || +1 here for the change it proves subjects are nasty things and that anything that has side-effects should be ()>i will loose some quizzes in my rx course because it is fun to show what happens when you reconnect to an infinite vs a finite sequence || > i will loose some quizzes in my rx course because it is fun to show what happens when you reconnect to an infinite vs a finite sequence:-)thanks for the review merging this || "";;;;1;1;support subject factory with multicast;"
"1518;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix typos in javadoc comments.;recieve  ->  receive;;0;fix typos in javadoc comments;""""""recieve"""" -> """"receive"""""";#1438  thanks :-) ||;;;;1;1;fix typos in javadoc comments;"
1558;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;mergemap generics;fixes issue #1550;;0;mergemap generics;fixes issue #1550;this also migrated it to use the correct `merge` implementation needed as of 020 || #1472 ;;;;1;1;mergemap genericsfixes issue #1550;
1559;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;more consistent hooks for scheduler plugins.  this is a rework of #1514.;- deprecated rxjavadefaultschedulers and rxjavadefaultschedulersdefault (i think these names are confusing) - added rxjavaschedulershook - ability to override entire schedulers from scratch - ability to decorate action0 before submission to scheduler  the main change from #1514 is the decoration of action0 instead of runnable.  action0 is an improvement as all schedulers must handle these  whereas not all schedulers handle runnables.;;1514.0;more consistent hooks for scheduler plugins  this is a rework of #1514;- deprecated rxjavadefaultschedulers and rxjavadefaultschedulersdefault (i think these names are confusing)- added rxjavaschedulershook- ability to override entire schedulers from scratch- ability to decorate action0 before submission to schedulerthe main change from #1514 is the decoration of action0 instead of runnable  action0 is an improvement as all schedulers must handle these whereas not all schedulers handle runnables;#1473  reviewed with @benjchristensen and merging ||;provide a facility for decorating a runnable before submission to executorservice via scheduler;for issue #1279this provides another method of hooking into the scheduler process  rather than forcing the plugin writer to write all 3 schedulers (computation/io/newthread) from scratch it allows the plugin writer to have access to the runnable before it gets submitted to the executorservicein my implementation which needs to decorate runnables this reduced the effort from a copy-n-paste of the entire scheduler codebase to a 1-linerhappy to debate names or any other aspect of this proposal;#1435  replaced by  ||;1;0;more consistent hooks for scheduler plugins  this is a rework of #1514* deprecated rxjavadefaultschedulers and rxjavadefaultschedulersdefault (i think these names are confusing)* added rxjavaschedulershook** ability to override entire schedulers from scratch** ability to decorate action0 before submission to scheduler;
1560;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;flatmap overloads;- migrate mappair to use actual merge instead of reimplementing it - deprecate mergemap  done during api review with @headinthebox;;0;flatmap overloads;- migrate mappair to use actual merge instead of reimplementing it- deprecate mergemapdone during api review with @headinthebox;;;;;1;1;flatmap overloads- migrate mappair to use actual merge instead of reimplementing it- deprecate mergemap;
1561;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove variance on defer;see  for painful background.;;0;remove variance on defer;see  for painful background;#1474];;;;1;1;remove variance on defersee  for painful background;
1567;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;groupby with element selector;fixes https://github.com/netflix/rxjava/issues/1554;;0;groupby with element selector;fixes https://githubcom/netflix/rxjava/issues/1554;#1479 ;;;;1;1;groupby with element selectorfixes https://githubcom/netflix/rxjava/issues/1554;
1568;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;compose/transformer;see  for discussion that led to this.  this does not have co/contra-variance which needs to be figured out.;;0;compose/transformer;see  for discussion that led to thisthis does not have co/contra-variance which needs to be figured out;#1480 ;;;;1;1;compose/transformersee  for discussion that led to thisthis does not have co/contra-variance which needs to be figured out;
1569;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;compose/transform covariance;failing test while exploring generic variance for   code like this makes these generics work:      java     @test     public void testcovarianceofcompose() {         observable<horrormovie> movie = observable.<horrormovie> from(new horrormovie())          movie.compose(new transformer<movie  movie>() {              @override             public observable<? extends movie> call(observable<? super movie> t1) {                 return observable.from(new movie())              }          })      }      @test     public void testcovarianceofcompose2() {         observable<movie> movie = observable.<movie> from(new horrormovie())          movie.compose(new transformer<movie  movie>() {              @override             public observable<? extends movie> call(observable<? super movie> t1) {                 return observable.from(new horrormovie())              }          })      }      however  i couldn t get the  compose / transformer  types to correctly work.  anyone else want to help figure out generics for this?  see https://github.com/netflix/rxjava/blob/master/rxjava-core/src/main/java/rx/observable.java#l195;;0;compose/transform covariance;failing test while exploring generic variance for  like this makes these generics work:``` java    @test    public void testcovarianceofcompose() {        observable<horrormovie> movie  observable<horrormovie> from(new horrormovie())        moviecompose(new transformer<movie movie>() {            @override            public observable<? extends movie> call(observable<? super movie> t1) {                return observablefrom(new movie())            }        })    }    @test    public void testcovarianceofcompose2() {        observable<movie> movie  observable<movie> from(new horrormovie())        moviecompose(new transformer<movie movie>() {            @override            public observable<? extends movie> call(observable<? super movie> t1) {                return observablefrom(new horrormovie())            }        })    }```however i couldnt get the `compose`/`transformer` types to correctly workanyone else want to help figure out generics for this?see https://githubcom/netflix/rxjava/blob/master/rxjava-core/src/main/java/rx/observablejava#l195;#1481 @abersnaze thank you for fixing this  i think i tried every permutation of super/extends except the right one that you came up with! || #1486  returning `observable<? extends r>` is not a good idea the following codes wont be compiled:```    @test    public void testcovarianceofcompose() {        observable<horrormovie> movie  observable<horrormovie> from(new horrormovie())        observable<movie> movie2                 moviecompose(new transformer<movie movie>() {            @override            public observable<? extends movie> call(observable<? extends movie> t1) {                return observablefrom(new movie())            }        })    }    @test    public void testcovarianceofcompose2() {        observable<movie> movie  observable<movie> from(new horrormovie())        observable<horrormovie> movie2                 moviecompose(new transformer<movie horrormovie>() {            @override            public observable<? extends horrormovie> call(observable<? extends movie> t1) {                return observablefrom(new horrormovie())            }        })    }```i propose  just like other methods that avoids to return `observable<? extends r>` || can you submit that as a pr?why in this use case must r not extend ? whereas the lift case does? || please take a look at  #1577 ||;;;;1;1;black magic applied;
1576;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;from(t) -> just(t);deprecate the from(t) methods in favor of items(t)  as per discussion in https://github.com/netflix/rxjava/issues/1563.;;0;from(t) -> just(t);deprecate the from(t) methods in favor of items(t)as per discussion in https://githubcom/netflix/rxjava/issues/1563;#1492  as per voting in #1563 this changes the signatures to:``` javafrom(future<? extends t>)from(future<? extends t> long timeunit)from(future<? extends t> scheduler)from(iterable<? extends t>)from(t)just(t)just(t t)just(t t t)just(t t t t)just(t t t t t)just(t t t t t t)just(t t t t t t t)just(t t t t t t t t)just(t t t t t t t t t)just(t t t t t t t t t t)``` ||;;;;1;1;from(t) -> just(t)see  for discussion;
1581;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;zip(iterable) -> zipwith(iterable);as per https://github.com/netflix/rxjava/issues/1578;;0;zip(iterable) -> zipwith(iterable);as per https://githubcom/netflix/rxjava/issues/1578;#1493 ;;;;1;1;zip(iterable) -> zipwith(iterable)as per https://githubcom/netflix/rxjava/issues/1578;
1582;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;deprecate groupedobservable.from;it was a bad solution. use observable.groupby with element selector instead  see https://github.com/netflix/rxjava/issues/1579;;0;deprecate groupedobservablefrom;it was a bad solution use observablegroupby with element selector insteadsee https://githubcom/netflix/rxjava/issues/1579;;;;;1;1;deprecate groupedobservablefromit was a bad solution use observablegroupby with element selector insteadsee https://githubcom/netflix/rxjava/issues/1579;
1589;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;added doonsubscribe() to observable;we often need to be notified when an observable is unsubscribed  for cleaning up internal states  logging  metrics gathering  and etc. with this added method  users can save the effort of writing the similar boilerplate to register a listener for un-subscription events.;;0;added doonsubscribe() to observable;we often need to be notified when an observable is unsubscribed for cleaning up internal states logging metrics gathering and etc with this added method users can save the effort of writing the similar boilerplate to register a listener for un-subscription events;#1499  thanks danny ||;;;;1;1;added doonsubscribe() to observable;
1592;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;decouple dispose function for using;as per discussion at https://github.com/netflix/rxjava/issues/1466;;0;decouple dispose function for using;as per discussion at https://githubcom/netflix/rxjava/issues/1466;#1501   @davidmoten can you please confirm this meets the requirements of #1466? id like to merge today || @benjchristensen @zsxwing lgtm but i think the existing `using` method should be deprecated as  it couples aspects that should not be coupled || i just updated the pr to deprecate the original thanks for the review || #1518;;;;1;1;deprecate old using method;
1593;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;doonsubscribe;;;0;doonsubscribe;; thanks @dpsm for the review ||;;;;1;1;doonsubscribe;
1599;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;reuse existing methods;this is a little cleanup of methods in observable.java that could be reusing existing methods.;;0;reuse existing methods;this is a little cleanup of methods in observablejava that could be reusing existing methods;#1505 ;;;;1;1;reuse existing methods;
1602;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;make retrywhen the same with the scheduler as the retrywhen without the scheduler;came up in #1580;;158.0;make retrywhen the same with the scheduler as the retrywhen without the scheduler;came up in #1580;#1510  #1511;travis ci configuration;the project would benefit by having continuous integration configuredive configured travis-ci for my fork it could be found at https://travis-ciorg/mairbek/rxjava;i definitely agree that a ci build system is beneficial - in fact we (at netflix) have been working on a solution for all of the netflixoss projects and are very close to having it upwe are going to be using cloudbees ( and ive been working with @garethbowles the past few days to get it working it should be up shortly and allow for builds and unit tests triggered on commits and pull requests || awesome cloudbees seems to be more powerful than travis cilets close this one ||;1;0;removed the unnecessary ` extends notification<?>` from repeatwhen too;
1608;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add missing window with time overload;observable.window  is missing an overload  the one overload to rule them all (couldn t resist).   the missing overload is below and corresponds to the ability to customize every parameter associated with the window with time functionality.   public final observable<observable<t>> window(long timespan  long timeshift  timeunit unit  int count  scheduler scheduler);;0;add missing window with time overload;`observablewindow` is missing an overload the one overload to rule them all (couldnt resist) the missing overload is below and corresponds to the ability to customize every parameter associated with the window with time functionality`public final observable<observable<t>> window(long timespan long timeshift timeunit unit int count scheduler scheduler)`;#1514  :-) ||;;;;1;1;add missing window with time overload the one that has control over every parameter;
1610;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;deprecate multicast without factory;this method is nuanced and generally causes broken behavior if the observable is subscribed to more than once.;;0;deprecate multicast without factory;this method is nuanced and generally causes broken behavior if the observable is subscribed to more than once;#1517 ;;;;1;1;deprecate multicast without factory;
1611;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;deprecate superfluous methods with scheduler overload;these should just use subscribeon if scheduling is wanted.  as per https://github.com/netflix/rxjava/issues/1580;;0;deprecate superfluous methods with scheduler overload;these should just use subscribeon if scheduling is wantedas per https://githubcom/netflix/rxjava/issues/1580;;;;;1;1;deprecate superfluous methods with scheduler overloadthese should just use subscribeon if scheduling is wanted;
"1613;1;0;0;0;0;1;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;moving netflix to reactivex;i fixed the readme by hand and then did a replace search for netflix/rxjava to reactivex/rxjava to replace github wiki and issue occurences.  i did a eyeball sanity check so i hope things are good. my gut feeling says there are many more com.netflix occurences somewhere else  but it s a start to get it all back to  normal .;;0;moving netflix to reactivex;""i  the readme by hand and then did a replace search for netflix/rxjava to reactivex/rxjava to replace github wiki and issue occurencesi did a eyeball sanity check so i hope things are good my gut feeling says there are many more comnetflix occurences somewhere else but its a start to get it all back to """"normal"""""";#1521  pinging @benjchristensen because i see youre doing some cleanup too i want to avoid you double work ) || thank you for this ||;;;;1;1;replacing netflix/rxjava with reactivex/rxjava;"
1632;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;composite exception - circular reference handling;the printstacktrace and getcause implementations have different approaches to handling circular references. if on a jvm where printstacktrace is called directly  the full causal chain will always be printed. if on one such as dalvik where getcause is invoked directly then it will cut the causal chain if it sees a duplicate.  see https://github.com/reactivex/rxjava/issues/1405;;0;composite exception - circular reference handling;the printstacktrace and getcause implementations have different approaches to handling circular referencesif on a jvm where printstacktrace is called directly the full causal chain will always be printed if on one such as dalvik where getcause is invoked directly then it will cut the causal chain if it sees a duplicatesee https://githubcom/reactivex/rxjava/issues/1405;#1534  this passed the netflix production canary over night there are no threads spinning on circular referencesthis pull request should work for both android and oracle jvms as it supports both `printstacktrace` and `getcause` mechanisms the `printstacktrace` approach is better but the `getcause` one should work normally and then bail if it sees a circular reference ||;;;;1;1;printstacktrace and getcause implementationthe printstacktrace and getcause implementations have different approaches to handling circular referencesif on a jvm where printstacktrace is called directly the full causal chain will always be printed if on one such as dalvikwhere getcause is invoked directly then it will cut the causal chain if it sees a duplicate;
1638;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;composite exception - circular reference handling;same change as  against 0.20 for 1.x;;0;composite exception - circular reference handling;same change as  against 020 for 1x;#1539 ;;;;1;1;composite exception - circular reference handlingsame change as  against 020 for 1x;
1645;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove parallelmerge;removing confusing operator before locked in stone with 1.0.0 final;;0;remove parallelmerge;removing confusing operator before locked in stone with 100 final;[reactivex  rxjava  rxjava-pull-requests #3 ;;;;1;1;remove parallelmergeremoving confusing operator before locked in stone with 100 final;
1646;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;deprecate parallelmerge;removing in 1.0 as it is confusing and rarely useful.;;0;deprecate parallelmerge;removing in 10 as it is confusing and rarely useful;[reactivex  rxjava  rxjava-pull-requests #4;;;;1;1;deprecate parallelmergeremoving in 10 as it is confusing and rarely useful;
1687;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;don t allocate an empty arraylist for each observable.empty call;;;0;dont allocate an empty arraylist for each observableempty call;;as discussed in #1653 ||;;;;1;1;dont allocate an empty arraylist for each observableempty call;
"1705;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;issue #1642 fix null-emitting combinelatest;@benjchristensen;;1642.0;issue #1642 fix null-emitting combinelatest;@benjchristensen; thanks for fixing this stupid bug on my partit should have been:``` javabuffergetvalue(o)// orbufferaccept(o child)```your fix does the same thing || @benjchristensen just saw that this didnt make it into 0205  do i need to do something to make sure it gets into 0206?  cant tell how you guys are managing the various release branches || this was merged into 1x and is in the 10 releases (it was in 100-rc4  you want it also in the 020x releases go ahead and submit another pr against that branch1x is where most of the focus is as we work towards the 10 final release scheduled for november 18th || ah  i tried switching us over to 100-rc4 but one of our dependencies uses the comnetflix packaging and android wont let us include both in our apk (dex complains about duplicate classes)   || > one of our dependencies uses the comnetflix packagingyes its going to be a painful one-time migration to get onto 10 once we hit 10 final ill encourage everyone to do so ||;onsubscribecombinelatest not unwrapping on_next_null_sentinel;""i am using a combinelatest method which when outputting a null value the combiner func causes a on_next_null_sentinel to be passed into the subscriptions onnext which is causing a class cast exception``` java        registrationobservable  observablecombinelatest(registrationobservable connectionstateobservable                new func2<registration boolean registration>() {                    @override                    public registration call(registration registration boolean connected) {                         if (connected) {                            return registration                        }                        return null //passing null here                    }                })                filter(functionsnotnull)````notnull` is defined as:``` java    public static final func1<? super objectboolean> notnull  new func1<object boolean>() {        @override        public boolean call(object o) {            return o ! null        }    }```if that is relevanti have determined that it is due to the rxringbuffer used by onsubscribecombinelatests onnext method:``` javapublic void onnext(object o) throws missingbackpressureexception {        if (queue  null) {            throw new illegalstateexception(""""this instance has been unsubscribed and the queue is no longer usable"""")        }        if (!queueoffer(onnext(o))) { //if o is null here this will add the on_next_null_sentinel to the queue            throw new missingbackpressureexception()        }    }```but `tick` does not """"unwrap"""" the notificationlite when passing it along``` java                        object o  bufferpoll()                        if (o ! null) {                            if (bufferiscompleted(o)) {                                childoncompleted()                            } else {                                childonnext((r) o) //passing notificationlite sentinel in here should this unwrap it?                                emitted++                                requesteddecrementandget()                            }                        }```it seems like either `bufferpoll()` should return the unwrapped null or tick should be checking for the null sentinel and passing null instead of that into onnext (after checking `o ! null`)eg``` java                        object o  bufferpoll()                        if (o ! null) {                            if (bufferiscompleted(o)) {                                childoncompleted()                            } else {                                if(o  on_next_null_sentinel) {                                      o  null                                }                                childonnext((r) o) //passing notificationlite sentinel in here should this unwrap it?                                emitted++                                requesteddecrementandget()                            }                        }```i dont understand why casting the on_next_null_sentinel to an r is not causing the classcastexception (it happens later on in the subscribers onnext call) "";""i have also encountered this issue with rxjava 0204 here is a minimal test method that exhibits the issue:``` java@testpublic void combinelatestnullcombinerfailuretest() {    // create source subjects types dont matter integer arbitrarily chosen    publishsubject<integer> subject0  publishsubjectcreate()    publishsubject<integer> subject1  publishsubjectcreate()    // create a function that ignores inputs and always returns a null integer    func2<integer integer integer> nullintegerreturningcombiner  new func2<integer integer integer>() {        @override        public integer call(integer i0 integer i1) {            return null        }    }    // create the combine-latest observable    observable<integer> combinelatestobservable  observablecombinelatest(            subject0 subject1 nullintegerreturningcombiner)    // create an observer that simply asserts that any emission is null on any emission    observer<integer> combinelatestobserver  observerscreate(new action1<integer>() {        @override        public void call(integer shouldbenull) {            assertassertnull(shouldbenull)        }    })    // subscribe the observer to the combine-latest observable    combinelatestobservablesubscribe(combinelatestobserver)    // produce a single emission from each subject emission values dont matter arbitrarily chosen    subject0onnext(0)    subject1onnext(1)    // the second emission above results in a classcastexception with the following (abbreviated) stack trace    // as of rxjava 0204:    //    // rxexceptionsonerrornotimplementedexception: rxinternaloperatorsnotificationlite$2 cannot be cast to javalanginteger    //     at rxobservable$36onerror(observablejava:8416)    //     at rxobserverssafesubscriber_onerror(safesubscriberjava:128)    //     at rxobserverssafesubscriberonerror(safesubscriberjava:97)    //         // caused by: javalangclasscastexception: rxinternaloperatorsnotificationlite$2 cannot be cast to javalanginteger    //     at rxjavacombinelatesttest$2call(rxjavacombinelatesttestjava:28)    //     at rxobservable$36onnext(observablejava:8421)    //     at rxobserverssafesubscriberonnext(safesubscriberjava:105)    //     }```i agree with @dylansale that there may be a problem in the onsubscribecombinelatest tick() operation but my proposed fix is slightly differentnotificationliteon_next_null_sentinel is private and should not be publicly exposed however notificationlite includes a getvalue(object n) operation which does the check for the on_next_null_sentinel instance and returns properly typed null if it is encounteredmy suggestion is to replace:``` javachildonnext((r) o)```with:``` javachildonnext(notificationlite<r> instance()getvalue(o))```in the tick() operation || i have a proposed workaround while we await review of this issue change the return type of the combiner func2 to object to avoid the classcastexception and introduce a mapping function that uses the notificationlite getvalue() method to handle the null sentinel value if encounteredin my test case above the changed blocks would be:``` javafunc2<integer integer object> nullintegerreturningcombiner  new func2<integer integer object>() {    @override    public object call(integer i0 integer i1) {        return null    }}combinelatestobservable    map(new func1<object integer>() {        @override        public integer call(object o) {            return notificationlite<integer> instance()getvalue(o)        }    })    subscribe(combinelatestobserver)```i have created a generic function to encapsulate the mapping part of this workaround as follows:``` javapublic static <t> func1<object t> combinelatestworkaround() {    return new func1<object t>() {        @override        public t call(object o) {            return notificationlite<t> instance()getvalue(o)        }    }}```wherever i have a combinelatest observable with a combiner function that may (validly) emit null values i have applied this workaround for the time being || i put together a pr that fixes this issue with @gfees suggested fix and adds a test to confirm the breakage/fix:  || thank you!on 30 sep 2014 03:31 """"edenman"""" notifications@githubcom wrote:> i put together a pr that fixes this issue with @gfee>  suggested fix and adds a test to confirm the> breakage/fix:> #1705  > > reply to this email directly or view it on github>  || my thanks @edenman for taking the time to create a pull request heres hoping it makes it into the rxjava 100 release || @benjchristensen thanks for merging the pr! can probably close this issue now || "";1;0;issue #1642 fix null-emitting combinelatest;"
1715;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;deprecate parallel;see https://github.com/reactivex/rxjava/issues/1673;;0;deprecate parallel;see https://githubcom/reactivex/rxjava/issues/1673;;;;;1;1;deprecate parallelsee https://githubcom/reactivex/rxjava/issues/1673;
1716;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove observable.parallel;see https://github.com/reactivex/rxjava/issues/1673;;0;remove observableparallel;see https://githubcom/reactivex/rxjava/issues/1673;;;;;1;1;remove observableparallelsee https://githubcom/reactivex/rxjava/issues/1673;
"1727;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;groupby/groupbyuntil changes;this is a proposed change to  groupby  and  groupbyuntil  that does the following:  1) eliminate  groupbyuntil  and rolls that functionality into  groupby  2) adds support for reactive pull backpressure to  groupby  3) child  groupedobservable s can now be unsubscribed and they will be cleaned up and then new instances for the same key can be emitted  like  groupbyuntil  worked  except that now instead of passing in a special durationselector function  the child can be composed using  take / takeuntil /etc to cause an unsubscribe.  if the previous non-obvious groupby behavior is wanted  then instead of unsubscribing  it can be filtered to ignore all further data  which is what the old groupby used to do when a child was unsubscribed.  the reason for these changes are: - adding backpressure to  groupbyuntil  was very difficult with its existing signature as the duration selector function effectively required a  groupedobservable  being a  publishsubject  which meant multicasting. in this specific case it may have been possible to do backpressure with the multicasting  but it would be difficult and non-obvious as generally multicasting means the stream is  hot  and reactive pull backpressure can t be applied. - the existing  groupby  almost always confused people as to what would happen when they unsubscribed a child using  take  or  takeuntil . it always surprised people that it meant all further data would be dropped but the key and group would not be garbage collected. almost always on an infinite stream people determined they needed  groupbyuntil   but only after stumbling around. after speaking with @headinthebox about this briefly we had enough agreement to submit this proposal and discuss further.  now  groupby  can behave by default as people expect with  unsubscribe  and support infinite streams  garbage collection  etc as well as backpressure.  i will provide usage examples below.;;0;groupby/groupbyuntil changes;""this is a proposed change to `groupby` and `groupbyuntil` that does the following:1) eliminate `groupbyuntil` and rolls that functionality into `groupby`2) adds support for reactive pull backpressure to `groupby`3) child `groupedobservable`s can now be unsubscribed and they will be cleaned up and then new instances for the same key can be emitted like `groupbyuntil` worked except that now instead of passing in a special durationselector function the child can be composed using `take`/`takeuntil`/etc to cause an unsubscribeif the previous non-obvious groupby behavior is wanted then instead of unsubscribing it can be filtered to ignore all further data which is what the old groupby used to do when a child was unsubscribedthe reason for these changes are:- adding backpressure to `groupbyuntil` was very difficult with its existing signature as the duration selector function effectively required a `groupedobservable` being a `publishsubject` which meant multicasting in this specific case it may have been possible to do backpressure with the multicasting but it would be difficult and non-obvious as generally multicasting means the stream is """"hot"""" and reactive pull backpressure cant be applied- the existing `groupby` almost always confused people as to what would happen when they unsubscribed a child using `take` or `takeuntil` it always surprised people that it meant all further data would be dropped but the key and group would not be garbage collected almost always on an infinite stream people determined they needed `groupbyuntil` but only after stumbling around after speaking with @headinthebox about this briefly we had enough agreement to submit this proposal and discuss furthernow `groupby` can behave by default as people expect with `unsubscribe` and support infinite streams garbage collection etc as well as backpressurei will provide usage examples below""; java// odd/even into 2 listsobservablerange(1 100)        groupby(n -> n % 2  0)        flatmap(g -> {            return gtolist()        })foreach(systemout::println)``````[1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99][2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98 100]``` || this one unsubscribes each group after 10 but then emits a new group with the same odd/even keys as new values come in:``` java// odd/even into lists of 10observablerange(1 100)        groupby(n -> n % 2  0)        flatmap(g -> {            return gtake(10)tolist()        })foreach(systemout::println)``````[1 3 5 7 9 11 13 15 17 19][2 4 6 8 10 12 14 16 18 20][21 23 25 27 29 31 33 35 37 39][22 24 26 28 30 32 34 36 38 40][41 43 45 47 49 51 53 55 57 59][42 44 46 48 50 52 54 56 58 60][61 63 65 67 69 71 73 75 77 79][62 64 66 68 70 72 74 76 78 80][81 83 85 87 89 91 93 95 97 99][82 84 86 88 90 92 94 96 98 100]``` || ``` java//odd/even into lists of 20 but only take the first 2 groupsobservablerange(1 100)     groupby(n -> n % 2  0)     flatmap(g -> {         return gtake(20)tolist()     })take(2)foreach(systemout::println)``````[1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39][2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40]``` || ``` java//odd/even into 2 lists with numbers less than 30observablerange(1 100)   groupby(n -> n % 2  0)   flatmap(g -> {       return gtakewhile(i -> i < 30)tolist()   })filter(l -> !lisempty())foreach(systemout::println)``````[2 4 6 8 10 12 14 16 18 20 22 24 26 28][1 3 5 7 9 11 13 15 17 19 21 23 25 27 29]``` || ``` javaobservablefrom(arraysaslist(""""a"""" """"b"""" """"c"""" """"a"""" """"b"""" """"c"""" """"a"""" """"b"""" """"c"""" """"a"""" """"b"""" """"c"""" """"a"""" """"b"""" """"c"""" """"a"""" """"b"""" """"c""""))groupby(n -> n)flatmap(g -> {    return gtake(3)reduce((s s2) -> s + s2)})foreach(systemout::println)``````aaabbbcccaaabbbccc``` || looks good to me the semantics are more clearer now  || thanks neeraj for the review i also confirmed the signature and semantic changes with @headinthebox so am proceeding with this  || "";;;;1;1;groupbyuntil -> groupbythis collapses groupbyuntil and groupby into a single groupby operator the new implementation has 2 major changes:1) it supports reactive pull backpressure2) child groupedobservables can be unsubscribed and they will be cleaned up and then new instances for the same key can be emitted like groupbyuntil except that now instead of passing in a special durationselector function the child can be composed using take/takeuntil/etc to cause an unsubscribeif the previous non-obvious groupby behavior is wanted then instead of unsubscribing it can be filtered to ignore all further data which is what the old groupby used to do when a child was unsubscribed;"
1733;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;move to proper location;was accidentally committed in old rxjava-core src folder.;;0;move to proper location;was accidentally committed in old rxjava-core src folder;;;;;1;1;move to proper locationwas accidentally committed in old rxjava-core src folder;
1736;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix trampolinescheduler nullpointerexception;i tried for about 30 minutes to replicate the npe reported in  but couldn t. it makes sense reading the code that an unsubscribe could trigger an npe though so i m fixing it as per recommendation of @dylansale even though i can t replicate. i confirmed that the items are being put in the queue before the wip variable is incremented  so that concurrency seems okay.;;0;fix trampolinescheduler nullpointerexception;i tried for about 30 minutes to replicate the npe reported in  but couldntit makes sense reading the code that an unsubscribe could trigger an npe though so im fixing it as per recommendation of @dylansale even though i cant replicatei confirmed that the items are being put in the queue before the wip variable is incremented so that concurrency seems okay;i found it always odd to have a threadlocal queue and a per-scheduler wip counter i cant test this now but i think the npe may happen if two tasks are scheduled from different threads on the same worker which makes wip  2 but the thread that is consuming the tasks only sees its threadlocal queue with 1 item || it is indeed very odd an artifact of early rxjava trying to match how rxnet did unsubscribes and scheduling as of 017 when `lift` was added that all went away but `trampolinescheduler` has not caught up || just added another commit that removes the use of threadlocal || instead of removing it i would have made `wip` threadlocal as well that way the trampolinescheduler worked like a current-thread scheduler for everyone and not sharing a queue and hopping threads  || it doesnt need to act like a threadlocal it had a separate queue per worker just like all schedulerworker impls ben christensen3107825511@benjchristensen> on oct 10 2014 at 12:44 am david karnok notifications@githubcom wrote:> > instead of removing it i would have made wip threadlocal as well that way the trampolinescheduler worked like a current-thread scheduler for everyone and not sharing a queue and hopping threads> > > reply to this email directly or view it on github || i thought about it a bit and i was mistaken the worker needs to keep the tasks in order so threadlocal wip is not good ||;;;;1;1;remove use of threadlocalthis was an awkward leftover from early version of rxjava (pre v017);
1738;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;delay operator with reactive pull backpressure;updated the implementations to support reactive pull backpressure. fixes https://github.com/reactivex/rxjava/issues/1724;;0;delay operator with reactive pull backpressure;updated the implementations to support reactive pull backpressurefixes https://githubcom/reactivex/rxjava/issues/1724;;;;;1;1;delay operator with reactive pull backpressureupdated the implementations to support reactive pull backpressurefixes https://githubcom/reactivex/rxjava/issues/1724;
1740;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;longcount -> countlong;fixes https://github.com/reactivex/rxjava/issues/1684;;0;longcount -> countlong;fixes https://githubcom/reactivex/rxjava/issues/1684;;;;;1;1;longcount -> countlongfixes https://githubcom/reactivex/rxjava/issues/1684;
"1742;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;emptyobserver and testobserver;- remove  emptyobserver  as it was confusing compared to  observers.empty()  (1741) - make  testobserver  not throw  onerrornotimplemented  if a delegate is not provided (fixes #1571);;1571.0;emptyobserver and testobserver;- remove `emptyobserver` as it was confusing compared to `observersempty()` (1741)- make `testobserver` not throw `onerrornotimplemented` if a delegate is not provided (fixes #1571);;testobserver always delegates to empty throws exception;i noticed that testobserver was changed to always delegate calls by default to the `empty` observerhowever the empty observer does not define `onerror` so any attempt to use testobserver with an observable thats supposed to fail in a unit test crashes the test with a `onerrornotimplementedexception`i wonder why this change was done? it adds complexity and surprise to something that should be void of behavior (mocks should record things not perform logic imho);""i had a problem with this to when using the `testobserver` to test errorsim using mockito so i worked this around creating my testobservers like this:```    @suppresswarnings(""""unchecked"""")    public static <t> testobserver<t> createtestobserver()    {        observer<t> delegate  mock(observerclass)        return new testobserver<t>(delegate)    }``` || opening discussion about confusion between `emptyobserver` and `observersempty()`:  || it will no longer throw an exception when a delegate is not provided that was a mistake ||  "";1;0;swallow errors in testobserverif a delegate is not provided then do nothingfixes https://githubcom/reactivex/rxjava/issues/1571;"
1742;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;emptyobserver and testobserver;- remove  emptyobserver  as it was confusing compared to  observers.empty()  (1741) - make  testobserver  not throw  onerrornotimplemented  if a delegate is not provided (fixes #1571);;1741.0;emptyobserver and testobserver;- remove `emptyobserver` as it was confusing compared to `observersempty()` (1741)- make `testobserver` not throw `onerrornotimplemented` if a delegate is not provided (fixes #1571);;observerempty() vs emptyobserver;the behavior between observerempty() and `emptyobserver` is different this seems confusing`emptyobserver` swallows errors whereas `observerempty()` will throw `onerrornotimplementedexception` if `onerror` is invokedthoughts on what we should do?;i think deleting `emptyobserver` is the best approach it serves no value || i deleted `emptyobserver` and updated the `observersempty()` javadocs to be clear that it throws `onerrornotimplementedexception` if someone wants to swallow errors they need to actively code for that rxjava will not swallow errors itself || like! ||;1;0;swallow errors in testobserverif a delegate is not provided then do nothingfixes https://githubcom/reactivex/rxjava/issues/1571;
1743;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;subject error handling;fixes  by delaying errors that are caught until after all subscribers have a chance to receive the event.  note that this has a lot of code duplication to handle this across the subject implementations. it may be worth abstracting this logic  but right now i m just doing what makes sense to fix this as the subject abstractions are non-trivial.;;0;subject error handling;fixes  by delaying errors that are caught until after all subscribers have a chance to receive the eventnote that this has a lot of code duplication to handle this across the subject implementations it may be worth abstracting this logic  but right now im just doing what makes sense to fix this as the subject abstractions are non-trivial;i dont see any option to avoid the repetition without lambda bodies as each subject delivers the onerror in a different way: directly in sequence and after replaying || agreed thanks for confirming my initial impression and reviewing the changes ||;;;;1;1;subject error handlingfixes  by delaying errors that are caught until after all subscribers have a chance to receive the eventnote that this has a lot of code duplication to handle this across the subject implementations it may be worth abstracting this logic  but right now im just doing what makes sense to fix this as the subject abstractions are non-trivial;
1745;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;serializedsubject;proposal for a  serializedsubject  type to simplify solution for multi-threaded emissions to a  subject .  see https://github.com/reactivex/rxjava/issues/1744;;0;serializedsubject;proposal for a `serializedsubject` type to simplify solution for multi-threaded emissions to a `subject`see https://githubcom/reactivex/rxjava/issues/1744;/cc @davidmgross as this has no javadoc whatsoever right now || im fuzzy on the purpose of this sort of subject is it meant to be abridge between multiple observables operating on multiple threads and theobservers of the subject?on thu oct 9 2014 at 10:51 pm ben christensen notifications@githubcomwrote:> /cc @davidmgross  as this has no javadoc> whatsoever right now> > > reply to this email directly or view it on github>  david m grossplp consulting || its just a wrapper around other subjects to make it thread-safe for multiples threads to call the `on*` methods on it ||;;;;1;1;serializedsubjectsee https://githubcom/reactivex/rxjava/issues/1744;
1747;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;cleanup: final and utility classes;- added  final  to utility classes. - added private constructor to utility classes.;;0;cleanup: final and utility classes;- added `final` to utility classes- added private constructor to utility classes;much easier to review and merge! thank you ||;;;;1;1;added final keyword and private constructor to private/utility classes;
1751;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;removed unused imports and variables.;;;0;removed unused imports and variables;;;;;;1;1;removed unused import and variables;
1752;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;added missing headers  removed unnecessary casts;;;0;added missing headers removed unnecessary casts;;;;;;1;1;added missing headers removed unnecessary casts;
1757;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;cleanup: added missing annotations  removed unnecesary annotations;plus fixed a few unnecessary casts i missed last time.;;0;cleanup: added missing annotations removed unnecesary annotations;plus  a few unnecessary casts i missed last time;;;;;1;1;cleanup: added missing annotations removed unnecesary annotations;
"1761;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;issue #1642 fix null-emitting combinelatest;same as  but for the 0.20.\* folks;;1642.0;issue #1642 fix null-emitting combinelatest;same as  but for the 020\* folks;;onsubscribecombinelatest not unwrapping on_next_null_sentinel;""i am using a combinelatest method which when outputting a null value the combiner func causes a on_next_null_sentinel to be passed into the subscriptions onnext which is causing a class cast exception``` java        registrationobservable  observablecombinelatest(registrationobservable connectionstateobservable                new func2<registration boolean registration>() {                    @override                    public registration call(registration registration boolean connected) {                         if (connected) {                            return registration                        }                        return null //passing null here                    }                })                filter(functionsnotnull)````notnull` is defined as:``` java    public static final func1<? super objectboolean> notnull  new func1<object boolean>() {        @override        public boolean call(object o) {            return o ! null        }    }```if that is relevanti have determined that it is due to the rxringbuffer used by onsubscribecombinelatests onnext method:``` javapublic void onnext(object o) throws missingbackpressureexception {        if (queue  null) {            throw new illegalstateexception(""""this instance has been unsubscribed and the queue is no longer usable"""")        }        if (!queueoffer(onnext(o))) { //if o is null here this will add the on_next_null_sentinel to the queue            throw new missingbackpressureexception()        }    }```but `tick` does not """"unwrap"""" the notificationlite when passing it along``` java                        object o  bufferpoll()                        if (o ! null) {                            if (bufferiscompleted(o)) {                                childoncompleted()                            } else {                                childonnext((r) o) //passing notificationlite sentinel in here should this unwrap it?                                emitted++                                requesteddecrementandget()                            }                        }```it seems like either `bufferpoll()` should return the unwrapped null or tick should be checking for the null sentinel and passing null instead of that into onnext (after checking `o ! null`)eg``` java                        object o  bufferpoll()                        if (o ! null) {                            if (bufferiscompleted(o)) {                                childoncompleted()                            } else {                                if(o  on_next_null_sentinel) {                                      o  null                                }                                childonnext((r) o) //passing notificationlite sentinel in here should this unwrap it?                                emitted++                                requesteddecrementandget()                            }                        }```i dont understand why casting the on_next_null_sentinel to an r is not causing the classcastexception (it happens later on in the subscribers onnext call) "";""i have also encountered this issue with rxjava 0204 here is a minimal test method that exhibits the issue:``` java@testpublic void combinelatestnullcombinerfailuretest() {    // create source subjects types dont matter integer arbitrarily chosen    publishsubject<integer> subject0  publishsubjectcreate()    publishsubject<integer> subject1  publishsubjectcreate()    // create a function that ignores inputs and always returns a null integer    func2<integer integer integer> nullintegerreturningcombiner  new func2<integer integer integer>() {        @override        public integer call(integer i0 integer i1) {            return null        }    }    // create the combine-latest observable    observable<integer> combinelatestobservable  observablecombinelatest(            subject0 subject1 nullintegerreturningcombiner)    // create an observer that simply asserts that any emission is null on any emission    observer<integer> combinelatestobserver  observerscreate(new action1<integer>() {        @override        public void call(integer shouldbenull) {            assertassertnull(shouldbenull)        }    })    // subscribe the observer to the combine-latest observable    combinelatestobservablesubscribe(combinelatestobserver)    // produce a single emission from each subject emission values dont matter arbitrarily chosen    subject0onnext(0)    subject1onnext(1)    // the second emission above results in a classcastexception with the following (abbreviated) stack trace    // as of rxjava 0204:    //    // rxexceptionsonerrornotimplementedexception: rxinternaloperatorsnotificationlite$2 cannot be cast to javalanginteger    //     at rxobservable$36onerror(observablejava:8416)    //     at rxobserverssafesubscriber_onerror(safesubscriberjava:128)    //     at rxobserverssafesubscriberonerror(safesubscriberjava:97)    //         // caused by: javalangclasscastexception: rxinternaloperatorsnotificationlite$2 cannot be cast to javalanginteger    //     at rxjavacombinelatesttest$2call(rxjavacombinelatesttestjava:28)    //     at rxobservable$36onnext(observablejava:8421)    //     at rxobserverssafesubscriberonnext(safesubscriberjava:105)    //     }```i agree with @dylansale that there may be a problem in the onsubscribecombinelatest tick() operation but my proposed fix is slightly differentnotificationliteon_next_null_sentinel is private and should not be publicly exposed however notificationlite includes a getvalue(object n) operation which does the check for the on_next_null_sentinel instance and returns properly typed null if it is encounteredmy suggestion is to replace:``` javachildonnext((r) o)```with:``` javachildonnext(notificationlite<r> instance()getvalue(o))```in the tick() operation || i have a proposed workaround while we await review of this issue change the return type of the combiner func2 to object to avoid the classcastexception and introduce a mapping function that uses the notificationlite getvalue() method to handle the null sentinel value if encounteredin my test case above the changed blocks would be:``` javafunc2<integer integer object> nullintegerreturningcombiner  new func2<integer integer object>() {    @override    public object call(integer i0 integer i1) {        return null    }}combinelatestobservable    map(new func1<object integer>() {        @override        public integer call(object o) {            return notificationlite<integer> instance()getvalue(o)        }    })    subscribe(combinelatestobserver)```i have created a generic function to encapsulate the mapping part of this workaround as follows:``` javapublic static <t> func1<object t> combinelatestworkaround() {    return new func1<object t>() {        @override        public t call(object o) {            return notificationlite<t> instance()getvalue(o)        }    }}```wherever i have a combinelatest observable with a combiner function that may (validly) emit null values i have applied this workaround for the time being || i put together a pr that fixes this issue with @gfees suggested fix and adds a test to confirm the breakage/fix:  || thank you!on 30 sep 2014 03:31 """"edenman"""" notifications@githubcom wrote:> i put together a pr that fixes this issue with @gfee>  suggested fix and adds a test to confirm the> breakage/fix:> #1705  > > reply to this email directly or view it on github>  || my thanks @edenman for taking the time to create a pull request heres hoping it makes it into the rxjava 100 release || @benjchristensen thanks for merging the pr! can probably close this issue now || "";1;0;issue #1642 fix null-emitting combinelatest;"
1762;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;compose generics;;;0;compose generics;;this seems to make my examples all work while still passing the covariance unit tests we have (and with easier to read generics) @davidmoten @akarnokd @zsxwing can you please review this as well?the java 8 code i tried is at  and that code does not compile with current code || lgtm except my comment || manually merged in  ||;;;;1;1;compose generics;
"1766;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;unhandled errors go to uncaughtexceptionhandler;rather than swallowing/logging errors  scheduledaction now delivers them to the uncaughtexceptionhandler for the executing thread. this gives client applications control over the handling of errors that occur off of the calling thread.;;0;unhandled errors go to uncaughtexceptionhandler;rather than swallowing/logging errors scheduledaction now delivers themto the uncaughtexceptionhandler for the executing thread this givesclient applications control over the handling of errors that occur offof the calling thread;""thank you @loganj  || oops forgot to reference the original issue: reactivex/rxjava#1682 || i havent had a chance to test yet but without `printstacktrace` will this silently fail unless someone has registered a default handler or does the jvm have a default one? || pretty sure threadgroup [has us covered]( if this thread group has a parent thread group the uncaughtexception method of that parent is called with the same two arguments> > otherwise this method checks to see if there is a default uncaught exception handler installed and if so its uncaughtexception method is called with the same two arguments> > otherwise this method determines if the throwable argument is an instance of threaddeath if so nothing special is done otherwise **a message containing the threads name as returned from the threads getname method and a stack backtrace using the throwables printstacktrace method is printed to the standard error stream** || ah nice thats exactly what id want it to do ill play to confirmthanks @loganj for helping out with this || confirmed it works perfectly``` java    public static void main(string args) throws exception {        observableinterval(100 timeunitmilliseconds)map(i -> {            throw new runtimeexception(""""fail!"""")        })subscribe()        threadsleep(100000)    }```outputs to terminal```exception in thread """"rxcomputationthreadpool-1"""" javalangillegalstateexception: exception thrown on schedulerworker thread add `onerror` handling    at rxinternalschedulersscheduledactionrun(scheduledactionjava:50)    at javautilconcurrentexecutors$runnableadaptercall(executorsjava:511)    at javautilconcurrentfuturetaskrun(futuretaskjava:266)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskaccess$201(scheduledthreadpoolexecutorjava:180)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:293)    at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1142)    at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:617)    at javalangthreadrun(threadjava:745)caused by: rxexceptionsonerrornotimplementedexception: fail!    at rxobservable$36onerror(observablejava:7390)    at rxobserverssafesubscriber_onerror(safesubscriberjava:127)    at rxobserverssafesubscriberonerror(safesubscriberjava:96)    at rxinternaloperatorsoperatormap$1onerror(operatormapjava:48)    at rxinternaloperatorsoperatormap$1onnext(operatormapjava:56)    at rxinternaloperatorsonsubscribetimerperiodically$1call(onsubscribetimerperiodicallyjava:51)    at rxscheduler$worker$1call(schedulerjava:118)    at rxinternalschedulersscheduledactionrun(scheduledactionjava:45)     7 morecaused by: javalangruntimeexception: fail!    at errorstestlambda$0(errorstestjava:10)    at errorstest$$lambda$1/1406718218call(unknown source)    at rxinternaloperatorsoperatormap$1onnext(operatormapjava:54)     10 morecaused by: rxexceptionsonerrorthrowable$onnextvalue: onerror while emitting onnext value: longclass    at rxexceptionsonerrorthrowableaddvalueaslastcause(onerrorthrowablejava:98)    at rxinternaloperatorsoperatormap$1onnext(operatormapjava:56)     10 more``` || "";;;;1;1;unhandled errors go to uncaughtexceptionhandlerrather than swallowing/logging errors scheduledaction now delivers themto the uncaughtexceptionhandler for the executing thread this givesclient applications control over the handling of errors that occur offof the calling thread;"
"1767;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;executorscheduler delivers uncaught exceptions;instead of swallowing unhandled errors  executorscheduler delivers them to the executing thread s uncaughtexceptionhandler.  this addresses the same issue as reactivex/rxjava#1682  but for executorscheduler which does not used scheduledaction.;;1682.0;executorscheduler delivers uncaught exceptions;instead of swallowing unhandled errors executorscheduler delivers themto the executing threads uncaughtexceptionhandlerthis addresses the same issue as reactivex/rxjava#1682 but forexecutorscheduler which does not used scheduledaction;;scheduledaction swallows errors;scheduledaction (used  observeon` and other things doing scheduling) swallows errors because `futuretaskrun()` swallows errors inside a `future`this means something like `onerrornotimplemented` on the `subscriber` side of an `observeon` will throw and be swallowed and everything will fail silentlythe following code fails silently:``` javaobservableerror(new runtimeexception())observeon(schedulerscomputation())subscribe()```;""ive been researching this and there isnt a whole lot of choice in what to do when an exception is thrown on a random `schedulerworker` thread beyond catching and printing the error using `systemerr`i cant throw the exception anywhere else as the whole issue here is an unhandled exception being thrownthus im going to catch the exceptions in `scheduledaction` and `eprintstacktrace()` them with a warning about exceptions being thrownthis is an edge case that an app should not allow  and the reason why observables propagate errors as events  to avoid this very case so seeing these types of messages in log output signals a """"bad thing"""" that should be resolved this would not be good for system performance to allow these types of errors to be logged but i feel this is far better to yell and scream about bad code rather than silently swallowing errors as it does now || an error such as this will be printed:```javalangillegalstateexception: exception thrown on schedulerworker thread add `onerror` handling    at rxinternalschedulersscheduledactionrun(scheduledactionjava:46)    at javautilconcurrentexecutors$runnableadaptercall(executorsjava:511)    at javautilconcurrentfuturetaskrun(futuretaskjava:266)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskaccess$201(scheduledthreadpoolexecutorjava:180)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:293)    at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1142)    at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:617)    at javalangthreadrun(threadjava:745)caused by: rxexceptionsonerrornotimplementedexception    at rxobservable$36onerror(observablejava:7387)    at rxobserverssafesubscriber_onerror(safesubscriberjava:128)    at rxobserverssafesubscriberonerror(safesubscriberjava:97)    at rxinternaloperatorsnotificationliteaccept(notificationlitejava:144)    at rxinternaloperatorsoperatorobserveon$observeonsubscriberpollqueue(operatorobserveonjava:177)    at rxinternaloperatorsoperatorobserveon$observeonsubscriberaccess$0(operatorobserveonjava:161)    at rxinternaloperatorsoperatorobserveon$observeonsubscriber$2call(operatorobserveonjava:153)    at rxinternalschedulersscheduledactionrun(scheduledactionjava:43)     7 morecaused by: javalangruntimeexception    at rxexceptionserrorsoverasyncboundariestestsubscriberonerrorfails(errorsoverasyncboundariesjava:43)``` || i have merged the change if anyone can suggest a better approach that would be great please let me know here || best of the worst || the added logging is nice but why not continue throwing the error if its fatal (like `onerrornotimplemented`)? minus `observeon` your program would crash because you arent handling the exception - it wouldnt just log the exception || @dlew how would you solve this differently? the error is occurring on a separate thread so the most violent death that can occur is killing that thread inside the threadpoolexecutor the error can not propagate to the `main` thread and thus does not kill the jvmthe `throwable` gets caught inside `javautilconcurrentfuturetask`:``` java    public void run() {        if (state ! new ||            !unsafecompareandswapobject(this runneroffset                                         null threadcurrentthread()))            return        try {            callable<v> c  callable            if (c ! null && state  new) {                v result                boolean ran                try {                    result  ccall()                    ran  true                } catch (throwable ex) {                    result  null                    ran  false                    setexception(ex) //  <------------- this is where the exception goes                }                if (ran)                    set(result)            }        } finally {            // runner must be non-null until state is settled to            // prevent concurrent calls to run()            runner  null            // state must be re-read after nulling runner to prevent            // leaked interrupts            int s  state            if (s > interrupting)                handlepossiblecancellationinterrupt(s)        }    }```one can use `threadpoolexecutorafterexecute` to extract the caught error but rethrowing only causes the `threadpoolexecutor` to kill the thread not the jvm since it cant propagate to the `main` thread (the nature of async):  only alternative i can think of is to reverse schedule events up the observable chain like having an `onerror` on the `observableonsubscribe` and having a `scheduler` on the producing side not just the consuming side that however is a crazy amount of overhead and infrastructure for a degenerate case if you can submit a pull request that offers a better solution id appreciate that || thanks i understand the problem a lot better now ill have to think on it not sure there is a good solution || i know this isnt possible for even 10 but could `subscription schedule(action0 action)` be changed to`observable<void> schedule(action0 action)` that way the caller can get both the ability to subscribe to get the subscription and notification of completion or failure || a calling thread could not get a reference as `void onnext` is the signature the caller invokes it is on the wrong side of the thread where the exception is caught scheduled from inside the `onnext` the calling (parent) thread has already left by the time the child thread throws the exception there is no issue catching the exception on the child thread its what to do with it that is the question  || there is a related discussion here:  havent checked in a while but iirc part of the issue was that some operators like observeon werent forwarding errors? || observeon propagates errors downstream we just cant send them upstream across thread boundaries  || it would be great if we could add another plugin that gets called in place of the `printstacktrace`  similar to `rxjavaerrorhandler` but only for otherwise unhandled errors || would you prefer that over this:> threadgetdefaultuncaughtexceptionhandler()uncaughtexception(threadcurrentthread() e)ive never that so have no idea how it behaves especially with thread pools  || no youre right we can just use the built-in handler mechanism directlywe go directly `threadgetdefaultuncaughtexceptionhandler()` today but thats probably wrong  that handler is the global last-resort handler for all threads  it looks like what we really want is `threadcurrentthread()getuncaughtexceptionhandler()`ill get a pr together || that sounds good since then we are free to add listeners at any of the 3 levels but just registering the default global listener (most likely) will still work and it will propagate to it when a thread is about to terminate due to an uncaught exception the java virtual machine will query the thread for its uncaughtexceptionhandler using threadgetuncaughtexceptionhandler() and will invoke the handlers uncaughtexception method passing the thread and the exception as arguments if a thread has not had its uncaughtexceptionhandler explicitly set then its threadgroup object acts as its uncaughtexceptionhandler if the threadgroup object has no special requirements for dealing with the exception it can forward the invocation to the default uncaught exception handlerthanks for bringing this to my attention @loganj i honestly wasnt even aware of this capability in the jvm and my use cases dont generally result in uncaught exceptions so i hadnt ever gone looking for it || no problem were really good at making exceptions happenim basically done but not sure if i should i apply the same handling to schedulers that dont use scheduledaction  executorscheduler _seems_ to need it  what about immediatescheduler and trampolinescheduler?  do people rely on their current throwing behavior?  is that behavior contractual? || i have not tried this issue on trampolinescheduler but that may be okay as its all on the same thread executorscheduler probably does need this but lets get it solved for `scheduledaction` first and then we can go fix that one in a separate pr || i have confirmed this fix is working nicely after the changes by @loganj in #1766  || "";1;0;executorscheduler delivers uncaught exceptionsinstead of swallowing unhandled errors executorscheduler delivers themto the executing threads uncaughtexceptionhandlerthis addresses the same issue as reactivex/rxjava#1682 but forexecutorscheduler which does not used scheduledaction;"
1776;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;observable.compose generics;manual merge of  with an extra unit test added.;;0;observablecompose generics;manual merge of  with an extra unit test added;after the discussion in  i am merging this from @vadims as it seems this is the best approach to achieving simplicity while using and support for co/contra-variance ||;;;;1;1;covariance test with groupedobservablecompose;
1777;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;excluding things from the javadoc;for one of the sub issues in #1502.  exclude rx.internal. exclude rxjavaerrorhandlerdefault by deleting it.;;1502.0;excluding things from the javadoc;for one of the sub issues in #1502exclude rxinternalexclude rxjavaerrorhandlerdefault by deleting it;;javadocs: disable or make work;the generation of javadocs from the gradle config is mostly broken and unusable- formatting is default/bad- it doesnt exclude internal packages- it breaks on different versions of the jvmright now i generate the hosted docs ( using a bash script on my local machinei want this automated  but correctly to at least match what is hosted at  and so it works regardless of java 7 or 8 being used;+1 ill buy a beer for the person who fixes this || @abersnaze want to help with this? || @abersnaze we have a bounty on this one || > - formatting is default/bad> - it breaks on different versions of the jvmthe example link was broken so i wasnt sure what you wanted it to look likei tried in java home set to 18 but didnt see an issue || this is kind of outdated i have only a brief look at the javadocs from a browser but didnt notice anything broken (just missing package descriptions) is there still a problem with this? || im closing this issue due to inactivity if you have further input on the issue dont hesitate to reopen this issue or post a new one ||;1;0;exclude rxinternalexclude rxjavaerrorhandlerdefault by deleting it;
1778;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;change transformer to func1<observable<t>  observable<r>>;less variance is better. i cannot find any bad case for this pr. can someone help test it in java 8 and groovy?;;0;change transformer to func1<observable<t> observable<r>>;less variance is better i cannot find any bad case for this pr can someone help test it in java 8 and groovy?; works in java 8  || good improvement thank you ||;;;;1;1;change transformer to func1<observable<t> observable<r>>;
"1784;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;publish with backpressure;implementation of  publish  with backpressure:   this moves away from using the  multicast  operator and  publishsubject  as per discussion in #1732 and #1779;;1732.0;publish with backpressure;implementation of `publish` with backpressure:  moves away from using the `multicast` operator and `publishsubject` as per discussion in #1732 and #1779;;backpressure: publish;""is it possible in limited cases to support reactive pull backpressure on multicast use cases such as `publish()`?in the general case of a `connectableobservable` it wouldnt be as those are """"hot"""" im interested in exploring if there are cases when it will work such as when using `refcount` to address use cases such as discussed in  per the example from @headinthebox ``` scalaimport rxlangscala_object mainscala {  def main(args: array[string]): unit  {  val xs  observableitems(0 1 2 3 4)  val zs  xspublish[int]((xs: observable[int]) > xstakeuntil(xsdropwhile(x > x < 3)tail))  zssubscribe(z > println(z)) // 0123  readline()}```"";""+1i have especially good hopes for `xspublish(_xs->ys)zs` since the sharing of `xs` is all encapsulated || i dont think this should try to generically solve for use of subjects but for use of the `multicast` operator in that case i propose we adopt a similar strategy as `groupby` employs which is that the flow goes at the rate of the slowest subscriber it is the most obvious and expected result and if someone needs to speed things up then users opt in to sampling/throttling/etc whereas right now it very non-obviously breaks composition of backpressure and will cause backpressure exceptions and require buffering or dropping data || the main difficulty i see is how to manage the dynamic combining of request(n) calls of client subscribers as they may come and go at will for example given a multicast source a subscriber s1 enters and calls request(10) soon after a different subscriber s2 enters and calls request(5) since the first request started to execute the s2 shouldnt receive more than 5 and the multicast somehow needs to buffer the remaining 5 until the subscriber s2 asks for more or s1 doesnt receive more elements until s2 asks for more in addition if s2 unsubscribes s1 may now receive its remaining requested elements || i agree that its a challenge i wonder though if we can solve this in a similar way as `groupby` works as its a similar challenge `groupby` is effectively multicasting a single source into `n` sources where each can come and go and request different sizes at different rates it maintains a single buffer where it puts notifications if it cant emit and ensures it never requests more upstream than its buffer the nuance of this is that `publish` will have some `replay` type behavior when it has slow consumers but i think thats correct considering the expected behavior of composing reactive pull backpressure if someone wants truly unbounded emission they can opt into that by using terminal operators or `onbackpressure*` strategies this approach has worked well for `groupby` this past week in our stream processing system were doing the `publish`/`share` use case is i believe the last blocker we have || after reviewing this with @neerajrj it seems to not make sense and try and make `multicast` support backpressure as it allows passing any `subject` into it a `subject` is by definition """"hot"""" and not appropriate for trying to compose backpressure the `publish` (and `cache`/`share`) operator however has no specific reliance on the use of a `subject` even though it currently leverages `multicast` and the `subject` implementations (`publishsubject` and `replaysubject`)we can achieve the multicast behavior of `publish()` without a `publishsubject` and then be able to compose the backpressure from all subscribers very similar to how `groupby` works without needing to modify how subjects work || implemented and merged in #1784  || is there a non-trivial or non-contrived use case for this code to help me understand its applicability? im having a hard time conceptualizing what it would be used for when the example can be rewritten as `takewhile(predicatesnot(x > x > 3))` (or of course simply `takewhile(x > x < 3)`) || "";1;0;publish with backpressure;"
1786;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove multicast;the implementation is still there as  replay  is still using it  but the public api is removed.  see  for discussion.;;0;remove multicast;the implementation is still there as `replay` is still using it but the public api is removedsee  for discussion;;;;;1;1;remove multicastthe implementation is still there as `replay` is still using it but the public api is removed;
1787;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove *withindex operators;see  -> remove takewhilewithindex & skipwhilewithindex;;0;remove *withindex operators;see  -> remove takewhilewithindex & skipwhilewithindex;;;;;1;1;remove *withindex operatorssee  -> remove takewhilewithindex & skipwhilewithindex;
1788;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove publishlast/initialvalue;see https://github.com/reactivex/rxjava/issues/1785;;0;remove publishlast/initialvalue;see https://githubcom/reactivex/rxjava/issues/1785;reviewed with @headinthebox  ||;;;;1;1;remove publishlast/initialvaluesee https://githubcom/reactivex/rxjava/issues/1785;
1789;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;groupedobservable.from/create;see https://github.com/reactivex/rxjava/issues/1668;;0;groupedobservablefrom/create;see https://githubcom/reactivex/rxjava/issues/1668;;;;;1;1;groupedobservablefrom/createsee https://githubcom/reactivex/rxjava/issues/1668;
1802;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;add hasobservers method to subjects (#1772);as per   serializedsubject now keeps track of the actual subject. bufferuntilsubscriber synchronizes on the state guard.;;1772.0;add hasobservers method to subjects (#1772);as per  now keeps track of the actual subjectbufferuntilsubscriber synchronizes on the state guard;looks good thanks @simonbasle  ||;add hasobservers to subject;other implementations of rx have a hasobservers method on subject it would be nice to have this in rxjavarxjs //githubcom/reactive-extensions/rxjs/blob/master/doc/api/subjects/subjectmd#rxsubjectprototypehasobserversrxnethttps://rxcodeplexcom/sourcecontrol/latest#rxnet/source/systemreactivelinq/reactive/subjects/subjectcs;im open to that want to submit a pull request? || went ahead and implemented the method (see pull request) || ;1;0;add hasobservers method to subjects (#1772)as per  now keeps track of the actual subjectbufferuntilsubscriber synchronizes on the state guard;
1806;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove unnecessary utilities;remove utility methods and classes as per  and https://github.com/reactivex/rxjava/issues/1798;;0;remove unnecessary utilities;remove utility methods and classes as per  and https://githubcom/reactivex/rxjava/issues/1798;;;;;1;1;remove `not` classas per https://githubcom/reactivex/rxjava/issues/1798;
1809;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove utility functions from public api;fixes https://github.com/reactivex/rxjava/issues/1797;;0;remove utility functions from public api;fixes https://githubcom/reactivex/rxjava/issues/1797;;;;;1;1;remove utility functions from public apifixes https://githubcom/reactivex/rxjava/issues/1797;
1817;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix synchronous onsubscribe exception skips operators;fixes https://github.com/reactivex/rxjava/issues/1816;;0;fix synchronous onsubscribe exception skips operators;fixes https://githubcom/reactivex/rxjava/issues/1816;;;;;1;1;fix synchronous onsubscribe exception skips operatorsfixes https://githubcom/reactivex/rxjava/issues/1816;
"1834;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;subject.toserialized;adds toserialized as discussed in https://github.com/reactivex/rxjava/issues/1748;;0;subjecttoserialized;adds toserialized as discussed in https://githubcom/reactivex/rxjava/issues/1748;""could you change `serializedsubject` to an interface and change current `serializedsubject` class to a `defaultserializedsubject` like @samuelgruetter said in  so that a custom serializedsubject does not need to extend the default implementation i think it will be friendlier to extend || why would we want a custom serializedsubject? the point of serializedsubject is the implementation || also this is matching the pattern of `serializedobserver` and `serializedsubscriber` each of these are """"serialized"""" implementations of the interface they implement || i think the question is the following: is there only one possible reasonable implementation of `serializedsubject`? if yes theres no need for an interface if no an interface might be a good ideai dont have enough experience to answer this question || there are really only 3 ways to approach this that im aware of:- using blocking synchronization we are trying to avoid that we used to have `synchronizedobserver` and replaced it with `serializedobserver` - using queues and thread-stealing to push through this is the model `serializedobserver` and `serializedsubject` use- using an mpsc queue with a separate thread to drain (standard producer/consumer) we dont want to add extra concurrency so are avoiding that if an extra thread is wanted then `observeon` is the answerthus there is really only one approach we want for this and that is the `serializedobserver` approach hence `serializedsubject` which is an implementation of `subject` that adds the `serialized` capability || "";;;;1;1;subjecttoserializedadds toserialized as discussed in https://githubcom/reactivex/rxjava/issues/1748;"
1835;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;scan/reduce with seed factory;adds overload with seed factory as per https://github.com/reactivex/rxjava/issues/1831;;0;scan/reduce with seed factory;adds overload with seed factory as per https://githubcom/reactivex/rxjava/issues/1831;cc @headinthebox for review || merging for another release candidate to get actual testing during this next week || for the mutable case i think it is better to pass a special object such that we can hide the state and all methods can access it without passing it as a parameter think something along the lines of  || a special object means we cant use lambdas the point of `scan`/`reduce` for most use cases i see is for accumulating state in a mutable object so not supporting use of lambdas for the mutable case effectively says `scan` would require using an anonymous inner class that seems unnecessary when i can write code like this:``` java        observablerange(0 1000)reduce(() -> new arraylist<integer>() (list i) -> {            listadd(i)            return list        })foreach(systemout::println)``` || yup it would require an anonymous inner class but it is also what java 8 does   || im okay if thats an extra overload but i wouldnt want it to be the only way its very awkward using an anonymous inner class when nothing else requires that also wed have to figure out for the first time where to put a new type like this that is custom to a specific operator  || 100% agree but i think it makes sense to adopt the java8 overload || we cant as we compile to java 6 || we had to revert this because of ambiguity see #1884 for the change ||;;;;1;1;scan/reduce with seed factoryadds overload with seed factory as per https://githubcom/reactivex/rxjava/issues/1831;
"1866;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix memory leak in bounded replaysubject due to retaining the node index;indefinitely once the subscriber caught up.  for issue #1865.;;1865.0;fix memory leak in bounded replaysubject due to retaining the node index;indefinitely once the subscriber caught upfor issue #1865;""this test failed both times:```rxinternaloperatorsoperatormergedelayerrortest > testerrorinparentobservabledelayed failed    orgmockitoexceptionsverificationtoolittleactualinvocations:     stringobserveronnext(""""hello"""")    wanted 2 times:    -> at rxinternaloperatorsoperatormergedelayerrortesttesterrorinparentobservabledelayed(operatormergedelayerrortestjava:516)    but was 1 time:    -> at rxobserverstestobserveronnext(testobserverjava:78)        at rxinternaloperatorsoperatormergedelayerrortesttesterrorinparentobservabledelayed(operatormergedelayerrortestjava:516)```no idea why or if its related but id like to understand before merging this || i dont think mergedelayerror uses replaysubject i dont fully understand the operatormerge but it contains a lot of mutable variables and synchronized blocks and im not sure but i found some anomalies in: synchronizes on the mergeproducers this but reads the mergesubscribers `wip` field which generally is accessed through the mergesubscribers this same seems to be true for the `scalarvaluequeue` || ive tested things locally and its working for me  || i opened an issue to track the issue you brought up regarding `merge`:  || "";replaysubject memory leak;this little baby will grind to a halt do due never letting go of the events:``` javaimport rxsubjectsreplaysubjectpublic class application {  public static void main(string args) {    replaysubject<integer> subject  replaysubjectcreatewithsize(10)    subjectsubscribe(x -> {})    int ii  0    while(true) {      subjectonnext(ii)      ii++    }  }}```;tested on 100-rc10 || i merged the fix ||;1;0;fix memory leak in bounded replaysubject due to retaining the node indexindefinitely once the subscriber caught up;"
1882;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove unused scheduler.parallelism;before hitting 1.0 removing this api as it is not used.;;0;remove unused schedulerparallelism;before hitting 10 removing this api as it is not used;cc @headinthebox  || like! ||;;;;1;1;remove unused schedulerparallelismbefore hitting 10 removing this api as it is not used;
"1884;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix scan/reduce/collect factory ambiguity;this puts the seed factory on  collect  and removes it from  scan  and  reduce  due to ambiguity. see  and   the  collect  api was already very close so this fixes it to use a seed factory so the signature is now:      java public final <r> observable<r> collect(func0<r> statefactory  final action2<r  ? super t> collector) {      i remove the factory overloads for  scan  and  reduce  due to the issue in #1881 related to generics  type erasure and lambdas causing ambiguity and compilation failures.  we may want to add at least a  scan  impl in the future with a seed factory  but it will need a different name if we do such as  scanto . i don t want to do that now for 1.0 so we ll need to revisit that for 1.1 with more time to think about it.;;1881.0;fix scan/reduce/collect factory ambiguity;this puts the seed factory on `collect` and removes it from `scan` and `reduce` due to ambiguitysee  and  `collect` api was already very close so this fixes it to use a seed factory so the signature is now:``` javapublic final <r> observable<r> collect(func0<r> statefactory final action2<r ? super t> collector) {```i remove the factory overloads for `scan` and `reduce` due to the issue in #1881 related to generics type erasure and lambdas causing ambiguity and compilation failureswe may want to add at least a `scan` impl in the future with a seed factory but it will need a different name if we do such as `scanto` i dont want to do that now for 10 so well need to revisit that for 11 with more time to think about it;this code is now possible:``` java        observablerange(0 10)collect(() -> new arraylist<integer>() (list i) -> {            listadd(i)        })foreach(systemout::println)```this will no longer compile:``` java        observablerange(0 10)scan(() -> new arraylist<integer>() (list i) -> {            listadd(i)            return list        })foreach(systemout::println)     ``` ||;scan/reduce overloads & type erasure;""i think the recent additions to `scan`/`reduce` may cause issues``` javascan(r func2<r ? super t r>)scan(func0<r> func2<r ? super t r>)```the `func0` passed in looks like it can be treated like an `object` and considered ambiguous and match with `r` instead of `func0`here is a compilation error:```[error] failed to execute goal orgapachemavenplugins:maven-compiler-plugin compile (default-compile) on project learnrxjava: compilation failure: compilation failure:[error] /users/benjchristensen/development/github/learnrxjava/src/main/java/learnrxjava/examples/scanvsreduceexamplejava:[1032] reference to reduce is ambiguous[error] both method <r>reduce(rrxfunctionsfunc2<r? super tr>) in rxobservable and method <r>reduce(rxfunctionsfunc0<r>rxfunctionsfunc2<r? super tr>) in rxobservable match[error] /users/benjchristensen/development/github/learnrxjava/src/main/java/learnrxjava/examples/scanvsreduceexamplejava:[1039] incompatible types: cannot infer type-variable(s) r[error] (argument mismatch javalangobject is not a functional interface)[error] /users/benjchristensen/development/github/learnrxjava/src/main/java/learnrxjava/examples/scanvsreduceexamplejava:[1732] reference to scan is ambiguous[error] both method <r>scan(rrxfunctionsfunc2<r? super tr>) in rxobservable and method <r>scan(rxfunctionsfunc0<r>rxfunctionsfunc2<r? super tr>) in rxobservable match[error] /users/benjchristensen/development/github/learnrxjava/src/main/java/learnrxjava/examples/scanvsreduceexamplejava:[1737] incompatible types: cannot infer type-variable(s) r[error] (argument mismatch javalangobject is not a functional interface)[error] -> [help 1]```here is example code:  javapackage learnrxjavaexamplesimport javautilarraylistimport rxobservablepublic class scanvsreduceexample {    public static void main(string args) {        observablerange(0 10)reduce(() -> new arraylist<integer>() (list i) -> {            listadd(i)            return list        })foreach(systemout::println)        systemoutprintln("""" vs """")        observablerange(0 10)scan(() -> new arraylist<integer>() (list i) -> {            listadd(i)            return list        })foreach(systemout::println)    }}```it looks like we need to do one of 3 things:1) remove one of several things:``` javascan(r func2<r ? super t r>)scan(func0<r> func2<r ? super t r>)```2) rename one of them3) add an extra argument so arity solves iti actually think the most correct thing to do is remove `scan(r func2<r ? super t r>)` since an initial value is most often intended for mutable state in `scan`/`reduce` cc @headinthebox as this is a last minute api fix we need prior to monday for 10"";id be happy with `func<0>` as the only way but then we have to do the same for `reduce` and anything else that takes a seed || btw if we do this then we should consider generalizing to returning `s` since we are side-effecting `r` so it does not matter to return return the mutable state variable since that is passed in by the implementation`scan(func0<r> func2<r ? super t s>)` || i have submitted #1883 to fix the ambiguity that happens with lambdas i have changed `scan` `reduce` and `collect` i dont see anywhere else that needs to change || im going to pull the factory overload until 11 so we make sure we get this right  ||  in #1884 by deleting the ambiguous new factory overloads for `scan` and `reduce` and modifying `collect` to support the mutable case with a seed factory and side-affection action ||;1;0;fix scan/reduce/collect factory ambiguitythis puts the seed factory on `collect` and removes it from `scan` and `reduce` due to ambiguitysee  and https://githubcom/reactivex/rxjava/issues/1881;"
1903;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;fix testscheduler handling of immediate vs virtual time;manual merge of  by @ylecaillez;;0;fix testscheduler handling of immediate vs virtual time;manual merge of  by @ylecaillez;;;;;1;1;fix testscheduler handling of immediate vs virtual time;
1907;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;experimental: onbackpressureblock;an experimental implementation of  onbackpressureblock .  an open question is whether this should be allowed to block if running on a known eventloop such as  schedulers.computation()  or should instead emit an error in that situation.;;0;experimental: onbackpressureblock;an experimental implementation of `onbackpressureblock`an open question is whether this should be allowed to block if running on a known eventloop such as `schedulerscomputation()` or should instead emit an error in that situation;;;;;1;1;marking onbackpressureblock as @experimentali chose experimental instead of beta since we may still change how it behaves based on what scheduler is being used;
"1918;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;revert  experimental onbackpressurebufferwithcapacity;reverts reactivex/rxjava#1916  this breaks unit tests all over for some reason. i completely missed it before merging as the unit tests related to  onbackpressurebuffer  themselves pass. it s elsewhere that things break.   from what i can tell it is because  onbackpressurebuffer  is used in unit tests and those fail (often with timeouts or what appears to be infinite loops  since my cpu pegs itself).;;0;""revert """"experimental onbackpressurebufferwithcapacity"""""";reverts reactivex/rxjava#1916this breaks unit tests all over for some reason i completely missed it before merging as the unit tests related to `onbackpressurebuffer` themselves pass its elsewhere that things break from what i can tell it is because `onbackpressurebuffer` is used in unit tests and those fail (often with timeouts or what appears to be infinite loops  since my cpu pegs itself);;;;;1;1;""revert """"experimental onbackpressurebufferwithcapacity"""""";"
"1922;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;set removeoncancelpolicy on the threadpool if supported;this should solve the task retention problem of unused timeout tasks mentioned in #1919.  i know java 7+ scheduledthreadpoolexecutor has the  setremoveoncancelpolicy  and i remember seeing it in android although i can t tell from which api version.  in java 6  this can t be solved without rewriting the entire scheduler or using a backported executor.;;1919.0;set removeoncancelpolicy on the threadpool if supported;this should solve the task retention problem of unused timeout tasks mentioned in #1919i know java 7+ scheduledthreadpoolexecutor has the `setremoveoncancelpolicy` and i remember seeing it in android although i cant tell from which api versionin java 6 this cant be solved without rewriting the entire scheduler or using a backported executor;""@akarnokd cool thanks for whipping this up so quickly since rxjava supports java 6 we need to fix that too right? || i looked at the packages of jsr166_ but couldnt find one that ports this flag back to java 6 || @benjchristensen are there plans to """"fix"""" this for java 6 too? since we technically support it or do we mark it as a limitation and people that are hit by this need to go to java 7? im asking because we have lots of users on java 6 and some of the requests have 75s timeouts  || im open to a fix that works for java 6 if someone can suggest what to do and/or submit a pr i personally dont have the time to tackle this anytime soon but would accept the change if it solves the problem without breaking anything else (including performance) for java 7/8  || @benjchristensen okay thanks for the info ill tackle it if customers start to """"complain"""" for now i also think its not as high priority - since technically jdk 6 is eol anyway :) || yes :-) the strongest reason actually that rxjava supports java 6 rather than 7 as the minimum is for android support if it becomes an issue for your customers and you want to tackle this ill happily review discuss and merge  || youd need to backport the java 7 scheduledthreadpoolexecutor and a bunch of helper classes i looked for a backport on doug leas site but no luck || how about calling `scheduledthreadpoolexecutorremove(runnable task)` in `unsubscribe` for java 6? although its a o(n) action while its o(log n) in java 7+ its better than oom || that doesnt work on `submit()` tasks because they are wrapped maybe a better option is to have `purge()` be called periodically || > that doesnt work on submit() tasks because they are wrappedthe returned `scheduledfuture` is exactly the object in the workqueue || "";(updated): timeout() operator leaking scheduledfuturetasks on scheduler;hi folks(update see below looks like its the timeout operator) im raising a ticket earlier than later because i suspect we have a leak somewhere in the scheduler logic it could by in my code too but from the characteristics it looks more like something rx internalive been able to generate some oom scenarios where gc takes all the time to clean things up and its not able to which pointed me to a leak a heap dump showed the leak suspect is the scheduledfuturetask as part of the computation scheduler:![screen shot 2014-12-02 at 10 40 28]( can see a full gc kicking in without actually making old gen smaller:![screen shot 2014-12-02 at 10 42 50]( code path uses both observeon() once to move it onto a scheduler and also blocks single() at the very end so ill start looking in those places but maybe @akarnokd or @benjchristensen you have an idea where i can start debugging?;""one thing that is suspicious is that my rx computation pools should be very silent because im using observeon my own scheduler (a spinoff of the computation one because it does not allow thread naming manually)so while they are quiet (see threads) they have lots in their work queue![screen shot 2014-12-02 at 10 51 47]( shot 2014-12-02 at 10 53 38]( || @akarnokd any idea what a scheduledaction """"null"""" is?![screen shot 2014-12-02 at 11 01 45]( like its carrying a timeout operation which makes sense to be done on the rx one because i forgot to move it to our computation scheduler probably the leak is in the timeout operator?quick update: yup that looks like to be the cause when i remove the timeout operator and do a manual full gc it goes back to steady nothing leaking there || scheduledaction extends atomicreference<thread> so unless it has run already it contains a null value i did this for the free atomic operator(s)in addition there is a shortcoming in java 6 scheduledthreadpool where cancelled far-future tasks remain in the pools queue until their time has actually passed at when they get just evicted java 7 introduced a `setremoveoncancelpolicy()` method to get rid of them asap (defaults to false for compatibility reasons) (historical note: in my rxjava predecessor i had this method called reflectively when a scheduled pool was instantiated) || @akarnokd see my last update it seems to be in timeout()  when i remove it no leak || here is with the timeout operator removed:![screen shot 2014-12-02 at 11 16 36]( || is the use case able to be represented in a simple unit test so we can reproduce and fix?if not then is it a high volume of timeouts (that dont trigger) causing it? || im trying to get it into something testable although since im not familiar with the low level internals i dont know how we can prove that it is not leaking ill try to get something that at least shows it in a profiler when running itbtw note the code that triggers it is very simple:  it also be interplay between `timeout()` and the blocking observable conversion that is not doing something that the timeout operator expects? || okay with something simple like``` javawhile(true) {   observable        timer(5 timeunitmicroseconds)        timeout(1 timeunitseconds)        toblocking()        single()}```or chaining in a different scheduler before the timeout its not reproducible no leaks there one difference as well is that the code is observing a `asyncsubject` i dont know if that makes a difference in this case though || @akarnokd  @benjchristensen wow actually **it is** reproducible with that code it shows up when you increase the timeout a lot could it be that with the current code the task only vanishes once the timeout is over and the actual oncomplete does not cancel it?``` javawhile(true) {   observable        timer(5 timeunitmicroseconds)        timeout(1 timeunitseconds)        toblocking()        single()}```![screen shot 2014-12-02 at 13 18 07]( javawhile(true) {   observable        timer(5 timeunitmicroseconds)        timeout(100 timeunitseconds)        toblocking()        single()}```![screen shot 2014-12-02 at 13 19 04]( || weve  the task retention problem for jdk 6 in 105 does the problem still happen for you? || @akarnokd oh you did? which changeset was that? :) || @daschl with #2465 i must add it only works with `scheduledthreadpoolexecutor` that the jdk is using because the `scheduledexecutorservice` interface doesnt have a `purge` method || im closing this due to inactivity if you have further problems please dont hesitate to reopen this issue or post a new one || "";1;0; wrong java 8 reflection api call;"
1928;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add onbackpressurebuffer with capacity;the operator takes an optional capacity for the buffer and a callback that will be invoked if the buffer fills up  along with a missingbackpressureexception in the observable s onerror.;;0;add onbackpressurebuffer with capacity;the operator takes an optional capacity for the buffer and a callbackthat will be invoked if the buffer fills up along with amissingbackpressureexception in the observables onerror;@benjchristensen this should fix the bug (it was in the test actually which i was overcomplicating) it passes the full suite locally i squashed the improvements you added earlier on the same commit let me know if you prefer me to separate them  thank you! (and this time all tests are passing so looks like its all happy now) ||;;;;1;1;add onbackpressurebuffer with capacitythe operator takes an optional capacity for the buffer and a callbackthat will be invoked if the buffer fills up along with amissingbackpressureexception in the observables onerror;
1937;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;scheduler.worker to be finally unsubscribed to avoid interference; and leaks.;;0;schedulerworker to be finally unsubscribed to avoid interference;and leaks;all unit test changes  looks good  ||;;;;1;1;schedulerworker to be finally unsubscribed to avoid interference;
1947;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;fixed first emission racing with pre and post subscription.;there was a subtle race between the subscription and emission which delayed the delivery of the first emission if it happened between the pre- and post-subscription of a subscriber. the fix is the same logic used by the behaviorsubject to avoid the same problem.;;0; first emission racing with pre and post subscription;there was a subtle race between the subscription and emission which delayed the delivery of the first emission if it happened between the pre- and post-subscription of a subscriber the fix is the same logic used by the behaviorsubject to avoid the same problem;;;;;1;1; first emission racing with pre and post subscription;
1960;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;doonrequest;similar to doonsubscribe  doonnext  etc;;0;doonrequest;similar to doonsubscribe doonnext etc;;;;;1;1;doonrequestsimilar to doonsubscribe doonnext etc;
1973;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;fixed test issuing non-serialized messages to the subject.;should resolve the test failure of #1972 .  when the main part of the test succeded  an oncompleted was sent out from the main thread which was not serialized in respect to the onnext(1) issued from the worker thread  therefore  two replay was attempted sometimes. at first the caughtup was seen false  the replay was entered but the next instruction cleared the index causing the illegalstateexception.;;1972.0; test issuing non-serialized messages to the subject;should resolve the test failure of #1972 when the main part of the test succeded an oncompleted was sent out from the main thread which was not serialized in respect to the onnext(1) issued from the worker thread therefore two replay was attempted sometimes at first the caughtup was seen false the replay was entered but the next instruction cleared the index causing the illegalstateexception;failed in  > testreplaysubjectemissionsubscriptionrace failed    javalangnullpointerexception        at rxsubjectsreplaysubject$boundedstatereplayobserverfromindex(replaysubjectjava:628)        at rxsubjectsreplaysubject$boundedstatereplayobserver(replaysubjectjava:619)        at rxsubjectsreplaysubjectcaughtup(replaysubjectjava:430)        at rxsubjectsreplaysubjectoncompleted(replaysubjectjava:410)        at rxsubjectsreplaysubjectboundedconcurrencytesttestreplaysubjectemissionsubscriptionrace(replaysubjectboundedconcurrencytestjava:399)``` || thanks! forgot about the other test class ||;non-deterministic test failure: replaysubjectconcurrencytesttestreplaysubjectemissionsubscriptionrace;this test randomly failed on my local machine this was just recently added:  @akarnokd;where did it fail and with what message?edit: never mind found the issue || i failed to capture it sorry i copy/pasted the failure from my ide and then re-ran it and it passed when i pasted it all it had copied was the name of the test not the stacktrace || should be  now ||;1;0; test issuing non-serialized messages to the subject;
2053;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;fixed wrong bounded replaysubject use in test.;same issue as before.;;0; wrong bounded replaysubject use in test;same issue as before;;;;;1;1; wrong subject use in test;
2332;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator retry test fix attempt;maybe the error function was not emitting events properly.;;0;operator retry test fix attempt;maybe the error function was not emitting events properly;;;;;1;1;unbroken testsubscriber;
"2335;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;a set of stateless operators that don t need to be instantiated;for  lift()  all the time.;;0;a set of stateless operators that dont need to be instantiated;for `lift()` all the time;""thats a nice change this should improve gc behavior have you been able to measure it? || theres a javadoc typo that has been copy pasted throughout: an singleton instance || i havent measured the gc gain but i guess your use case that required queue pooling might benefit from another 16 bytes of allocation-reduction || the following program prints 240 bytes/instance on head and 225 on this pr that is ~15 mb of heap saved``` javapublic class mergealloc {    public static void main(string args) {        memorymxbean memorymxbean  managementfactorygetmemorymxbean()        memoryusage memheap  memorymxbeangetheapmemoryusage()        long initial  memheapgetused()        int m  1_000_000        systemoutprintf(""""starting: %3f mb%n"""" initial / 10240 / 10240)        list<observable<integer>> list  new linkedlist<>()        for (int i  0 i < m i++) {            listadd(observablemerge(observablejust(1) observablejust(2)))        }        memheap  memorymxbeangetheapmemoryusage()        long after  memheapgetused()        systemoutprintf(""""starting: %3f mb%n"""" after / 10240 / 10240)        systemoutprintf(""""cost: %d bytes/item"""" (after - initial) / m)    }}``` || triggering re-travis || "";;;;1;1; comment typo added the rest of the operators;"
2447;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fail early if a null subscription is added to a compositesubscription.;otherwise  it ll just fail late when unsubscribing  which is much harder to trace.  i discovered this while writing  a unit test  when i didn t properly mock out a method to return a valid observable. seems like it would be more likely to happen in test code than production  but still could be a stumbling block that s hard to track down if there s a bug in app logic adding a null subscription.;;0;fail early if a null subscription is added to a compositesubscription;otherwise itll just fail late when unsubscribing which is much harder to tracei discovered this while writing  a unit test when i didnt properly mock out a method to return a valid observable seems like it would be more likely to happen in test code than production but still could be a stumbling block thats hard to track down if theres a bug in app logic adding a null subscription;i suggest an alternative to get another effect: adding an already unsubscribed subscription is essentially no-op and just blocks others adding regular subscriptions concurrently how about do an isunsubscribed check in add:``` javapublic void add(subscription s) {    if (sisunsubscribed()) {        return    }}```certainly this will get you npe i read somewhere that jit may completely remove null-checks and simply relying on page faults of address 0 the drawback is that the npe indicates an error in rxjava now instead of the contract violation thoughts? || done good thought one concern though is it possible for an unsubscribed subscription to become subscribed again? i cant think of a case where that happens but if it could would this still be desired behavior? || unsubscribed is a terminal state and cant be revived || thanks merging ||;;;;1;1;use unsubscribed check instead of a null check;
"2465;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;scheduledexecutorservice: call purge periodically on jdk 6 to avoid;cancelled task-retention.  first debated in #1922  see also #1919.  we may want to discuss the naming of system parameters. i chose these so rxjava 2.0 specific properties may be trivially separated:   io.reactivex.rxjava.scheduler.jdk6.purge-frequency-millis  specifies the purge frequency in milliseconds. default is 1000.   io.reactivex.rxjava.scheduler.jdk6.purge-force  forces the use of the purge (if set to true) even if the setremoveoncancelpolicy is supported. the benefit is that removing cancelled tasks now runs on a different thread so the main pool thread doesn t waste time on them. the drawback is the retention window can be still to large.  do we have a wiki page where such parameters are listed?;;1919.0;scheduledexecutorservice: call purge periodically on jdk 6 to avoid;cancelled task-retentionfirst debated in #1922 see also #1919we may want to discuss the naming of system parameters i chose these so rxjava 20 specific properties may be trivially separated:`ioreactivexrxjavaschedulerjdk6purge-frequency-millis`specifies the purge frequency in milliseconds default is 1000`ioreactivexrxjavaschedulerjdk6purge-force`forces the use of the purge (if set to true) even if the setremoveoncancelpolicy is supported the benefit is that removing cancelled tasks now runs on a different thread so the main pool thread doesnt waste time on them the drawback is the retention window can be still to largedo we have a wiki page where such parameters are listed?;i did run the unit test by forcing a jdk 6 runtime and seems to work merging to allow progress on schedulers ||;(updated): timeout() operator leaking scheduledfuturetasks on scheduler;hi folks(update see below looks like its the timeout operator) im raising a ticket earlier than later because i suspect we have a leak somewhere in the scheduler logic it could by in my code too but from the characteristics it looks more like something rx internalive been able to generate some oom scenarios where gc takes all the time to clean things up and its not able to which pointed me to a leak a heap dump showed the leak suspect is the scheduledfuturetask as part of the computation scheduler:![screen shot 2014-12-02 at 10 40 28]( can see a full gc kicking in without actually making old gen smaller:![screen shot 2014-12-02 at 10 42 50]( code path uses both observeon() once to move it onto a scheduler and also blocks single() at the very end so ill start looking in those places but maybe @akarnokd or @benjchristensen you have an idea where i can start debugging?;""one thing that is suspicious is that my rx computation pools should be very silent because im using observeon my own scheduler (a spinoff of the computation one because it does not allow thread naming manually)so while they are quiet (see threads) they have lots in their work queue![screen shot 2014-12-02 at 10 51 47]( shot 2014-12-02 at 10 53 38]( || @akarnokd any idea what a scheduledaction """"null"""" is?![screen shot 2014-12-02 at 11 01 45]( like its carrying a timeout operation which makes sense to be done on the rx one because i forgot to move it to our computation scheduler probably the leak is in the timeout operator?quick update: yup that looks like to be the cause when i remove the timeout operator and do a manual full gc it goes back to steady nothing leaking there || scheduledaction extends atomicreference<thread> so unless it has run already it contains a null value i did this for the free atomic operator(s)in addition there is a shortcoming in java 6 scheduledthreadpool where cancelled far-future tasks remain in the pools queue until their time has actually passed at when they get just evicted java 7 introduced a `setremoveoncancelpolicy()` method to get rid of them asap (defaults to false for compatibility reasons) (historical note: in my rxjava predecessor i had this method called reflectively when a scheduled pool was instantiated) || @akarnokd see my last update it seems to be in timeout()  when i remove it no leak || here is with the timeout operator removed:![screen shot 2014-12-02 at 11 16 36]( || is the use case able to be represented in a simple unit test so we can reproduce and fix?if not then is it a high volume of timeouts (that dont trigger) causing it? || im trying to get it into something testable although since im not familiar with the low level internals i dont know how we can prove that it is not leaking ill try to get something that at least shows it in a profiler when running itbtw note the code that triggers it is very simple:  it also be interplay between `timeout()` and the blocking observable conversion that is not doing something that the timeout operator expects? || okay with something simple like``` javawhile(true) {   observable        timer(5 timeunitmicroseconds)        timeout(1 timeunitseconds)        toblocking()        single()}```or chaining in a different scheduler before the timeout its not reproducible no leaks there one difference as well is that the code is observing a `asyncsubject` i dont know if that makes a difference in this case though || @akarnokd  @benjchristensen wow actually **it is** reproducible with that code it shows up when you increase the timeout a lot could it be that with the current code the task only vanishes once the timeout is over and the actual oncomplete does not cancel it?``` javawhile(true) {   observable        timer(5 timeunitmicroseconds)        timeout(1 timeunitseconds)        toblocking()        single()}```![screen shot 2014-12-02 at 13 18 07]( javawhile(true) {   observable        timer(5 timeunitmicroseconds)        timeout(100 timeunitseconds)        toblocking()        single()}```![screen shot 2014-12-02 at 13 19 04]( || weve  the task retention problem for jdk 6 in 105 does the problem still happen for you? || @akarnokd oh you did? which changeset was that? :) || @daschl with #2465 i must add it only works with `scheduledthreadpoolexecutor` that the jdk is using because the `scheduledexecutorservice` interface doesnt have a `purge` method || im closing this due to inactivity if you have further problems please dont hesitate to reopen this issue or post a new one || "";1;0;scheduledexecutorservice: call purge periodically on jdk 6 to avoidcancelled task-retention;"
2470;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;subject state information methods & bounded replaysubject termination;fix.  this pr aims to support the requests in #2331 and #1897 by adding methods to the (final) subject classes that let developers access in-flight state in a snapshot fashion.   this may be considered safe api change because all subject classes were final already so adding extra methods won t break anyone s code (and we will be careful with our observable in the future). -  notificationlite  is now extended with two missing value checks: isnull and isnext. - each subject has  hascompleted    hasthrowable  and  getthrowable  methods  however  i can t add them to  subject  because that would be an incompatible api change. - where applicable   getvalue  and  getthrowable  return  null  instead of throwing exceptions so users are encouraged to call hasxxx methods beforehand. - there was a chaining bug in the bounded replaysubject: because the terminal value was added after a potential pruning  the node links could get broken and concurrent replays might not have seen the terminal value. - since  replaysubject  can have multiple values  i ve added  size()    hasanyvalue()  (isempty is taken) and  getvalues()  methods to make a snapshot of the current buffer contents whether or not the  replaysubject  has terminated (the usual tolist() would wait until the subject has terminated).  - the unrelated  operatormergetest.testconcurrency  hangs for me for some reason without activity (either a buffer bug or a merge bug is in play there). i ve added a timeout so it doesn t stop the other tests.;;1897.0;subject state information methods & bounded replaysubject termination;fixthis pr aims to support the requests in #2331 and #1897 by adding methods to the (final) subject classes that let developers access in-flight state in a snapshot fashion this may be considered safe api change because all subject classes were final already so adding extra methods wont break anyones code (and we will be careful with our observable in the future)- `notificationlite` is now extended with two missing value checks: isnull and isnext- each subject has `hascompleted` `hasthrowable` and `getthrowable` methods however i cant add them to `subject` because that would be an incompatible api change- where applicable `getvalue` and `getthrowable` return `null` instead of throwing exceptions so users are encouraged to call hasxxx methods beforehand- there was a chaining bug in the bounded replaysubject: because the terminal value was added after a potential pruning the node links could get broken and concurrent replays might not have seen the terminal value- since `replaysubject` can have multiple values ive added `size()` `hasanyvalue()` (isempty is taken) and `getvalues()` methods to make a snapshot of the current buffer contents whether or not the `replaysubject` has terminated (the usual tolist() would wait until the subject has terminated) - the unrelated `operatormergetesttestconcurrency` hangs for me for some reason without activity (either a buffer bug or a merge bug is in play there) ive added a timeout so it doesnt stop the other tests;im merging this: changes are either internal or annotated with experimental on final classes ||;add current value property to behaviorsubject;rx 22 added a current value property that would come in handy see discussion here: https://rxcodeplexcom/workitem/8;hello! a pr is welcome but note the following:- unlike rxnet behaviorsubject doesnt remember the very last onnext value before an oncompleted: completed subject emits only oncompleted to subscribers- the last known value is a notificationlite object which might be null indicating a behaviorsubject without default initial value- what should the method be called? value() getvalue() current() getcurrent() ?- how should it propagate the various states: (empty has value has exception terminated)? perhaps via notification<t>?- if it returns the last value directly what exceptions should indicate empty and terminated states? nosuchelementexception? || please check out #2470 for a set of subject api changes that includes your current value || subjects have been enhanced in 105 with methods that get you their current state ||;1;0;added experimental annotations;
2470;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;subject state information methods & bounded replaysubject termination;fix.  this pr aims to support the requests in #2331 and #1897 by adding methods to the (final) subject classes that let developers access in-flight state in a snapshot fashion.   this may be considered safe api change because all subject classes were final already so adding extra methods won t break anyone s code (and we will be careful with our observable in the future). -  notificationlite  is now extended with two missing value checks: isnull and isnext. - each subject has  hascompleted    hasthrowable  and  getthrowable  methods  however  i can t add them to  subject  because that would be an incompatible api change. - where applicable   getvalue  and  getthrowable  return  null  instead of throwing exceptions so users are encouraged to call hasxxx methods beforehand. - there was a chaining bug in the bounded replaysubject: because the terminal value was added after a potential pruning  the node links could get broken and concurrent replays might not have seen the terminal value. - since  replaysubject  can have multiple values  i ve added  size()    hasanyvalue()  (isempty is taken) and  getvalues()  methods to make a snapshot of the current buffer contents whether or not the  replaysubject  has terminated (the usual tolist() would wait until the subject has terminated).  - the unrelated  operatormergetest.testconcurrency  hangs for me for some reason without activity (either a buffer bug or a merge bug is in play there). i ve added a timeout so it doesn t stop the other tests.;;2331.0;subject state information methods & bounded replaysubject termination;fixthis pr aims to support the requests in #2331 and #1897 by adding methods to the (final) subject classes that let developers access in-flight state in a snapshot fashion this may be considered safe api change because all subject classes were final already so adding extra methods wont break anyones code (and we will be careful with our observable in the future)- `notificationlite` is now extended with two missing value checks: isnull and isnext- each subject has `hascompleted` `hasthrowable` and `getthrowable` methods however i cant add them to `subject` because that would be an incompatible api change- where applicable `getvalue` and `getthrowable` return `null` instead of throwing exceptions so users are encouraged to call hasxxx methods beforehand- there was a chaining bug in the bounded replaysubject: because the terminal value was added after a potential pruning the node links could get broken and concurrent replays might not have seen the terminal value- since `replaysubject` can have multiple values ive added `size()` `hasanyvalue()` (isempty is taken) and `getvalues()` methods to make a snapshot of the current buffer contents whether or not the `replaysubject` has terminated (the usual tolist() would wait until the subject has terminated) - the unrelated `operatormergetesttestconcurrency` hangs for me for some reason without activity (either a buffer bug or a merge bug is in play there) ive added a timeout so it doesnt stop the other tests;im merging this: changes are either internal or annotated with experimental on final classes ||;adds a isinitialised call to check if the behaviorsubject is initialised;since the behaviorsubject can be created without a default value it could be interesting to be able to know if the subject is initialised (if it holds a value)adding this check allows for lazy initialisation of the behaviors value;is there a particular use case you try to solve? || i was looking at the behaviorsubject to represent the value of some remote objects since it caches the last value it is perfect to act as a local cache and if a refresh is triggered any observer would get the updatehaving this check would allow to use the empty construction and trigger the remote fetch only if the subject is uninitialised (first access)  || please check out #2470 for a set of subject api changes that includes your is initialized check by the name hasvalue || closing this since it is addressed in a more complete way in  ||;1;0;added experimental annotations;
2471;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fixes npes reported in reactivex#1702 by synchronizing queue.;also adds a unit test for regression.  it appears there is a potential race condition if something adds to/removes from the pq while it s _inside_ the  poll  operation  which is where the exceptions in #1702 seem to have actually come from. therefore  the initial null check didn t really address the original problem. the test here seems to reliably recreate those conditions.  i considered using a priorityblockingqueue instead of synchronized  but since the isempty and poll calls should not allow something to interleave between them and access the queue  a synchronized block seemed wiser here.;;1702.0;fixes npes reported in reactivex#1702 by synchronizing queue;also adds a unit test for regressionit appears there is a potential race condition if something adds to/removes from the pq while its _inside_ the poll operation which is where the exceptions in #1702 seem to have actually come from therefore the initial null check didnt really address the original problem the test here seems to reliably recreate those conditionsi considered using a priorityblockingqueue instead of synchronized but since the isempty and poll calls should not allow something to interleave between them and access the queue a synchronized block seemed wiser here;almost good two things:- since we only use offer/poll you can use the unbounded priorityblockingqueue now- could you move `counter` and `counter_updater` into the `innercurrentthreadscheduler` class both non-static fields? || we are using atomicfieldupdaters to save on the instance cost of `atomicinteger`s could you change the counter to use `atomiclongfieldupdater`? || done on a related but side-note do you know if these field updaters are proguard-safe for obfuscation? they reflect on field name for sure it might be worth looking into the fix would probably be implementing the abstract setters and getters which would obviously be a bit more boilerplate and kinda less fun but might be worth it if it reduces custom proguard rules required to use rx || thanks for the changes looks good to me i dont know about proguard || looks like per the proguard manual it does indeed recognize fieldupdater declarations so this should be fine || wow i did not expect that how uncharacteristically useful of them! good to know for the future ||  the reflection section (no anchor link) that lists the basic reflection methods it automatically detects ||;trampolinescheduler nullpointerexception;there is an issue in trampolinescheduler on 0204 where it can  throw a nullpointerexception in innercurrentthreadscheduler `enqueue(action0 action long exectime)```` java        private subscription enqueue(action0 action long exectime) {            if (innersubscriptionisunsubscribed()) {                return subscriptionsempty()            }            priorityqueue<timedaction> queue  queueget()            final timedaction timedaction  new timedaction(action exectime counter_updaterincrementandget(trampolineschedulerthis))            queueadd(timedaction)            if (wipgetandincrement()  0) {                do {                    queuepoll()actioncall()                } while (wipdecrementandget() > 0)                return subscriptionsempty()            } else {                // queue wasnt empty a parent is already processing so we just add to the end of the queue                return subscriptionscreate(new action0() {                    @override                    public void call() {                        priorityqueue<timedaction> _q  queueget()                        if (_q ! null) {                            _qremove(timedaction)                        }                    }                })            }        }```the exception happens on `queuepoll()actioncall()`from what i can tell the queue is empty and poll is returning nullthis is happening inside a nested `observableredo()timeout()redo()` chain (the `redo()timeout()` happens earlier in the application it isnt just one after the other like that) if that helps im not in a position to create a simple replication example howevermy current theory is: one of the redos could be unsubscribing calling `_qremove` while the `wip` loop is running (perhaps unsubscribe is happening on another thread?) causing the queue to become empty and the next loop of the `wip` loop returns `null` i think the `queuepoll()` call should check for null;thanks for the report ill take a look ||  (i hope) in #1736  || hi fixed in 1x branch via #2471 can you verify the fix works for your case? ||;1;0;back to a field updater;
2477;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;backpressure tests fix0121;- increased the limits of  testmergeasyncthenobserveon  - fixed  testonbackpressuredrop  because in case there was no drop at all  the last value would be num - 1. - changed  slow_pass_thru  to perform non-trivial work that can t be optimized away by jit.;;0;backpressure tests fix0121;- increased the limits of `testmergeasyncthenobserveon`-  `testonbackpressuredrop` because in case there was no drop at all the last value would be num - 1- changed `slow_pass_thru` to perform non-trivial work that cant be optimized away by jit;merging this so other prs failing due these methods can be re-tested ||;;;;1;1; slow_pass_thru to prevent jit optimizing it away;
"2493;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator takeuntil with predicate;take values and check the condition after the value is emitted.  for enhancement request #1649.;;1649.0;operator takeuntil with predicate;take values and check the condition after the value is emittedfor enhancement request #1649;""thanks for adding this! not convinced on the name though the do prefix is used to represent side-effects everywhere else i think the prefix should still be `take`-something || the question then remains should it stop if predicate turns into false or should it stop if predicate turns into true? because classically `do { } while (true)` and `repeat until false` (pascal) || i like it how its currently implemented  do until trueit fits the """"takeuntil"""" term  """"take until a value  predicate"" java        systemoutprintln(""""------------------------"""")        observablejust(1 2 3 4 5 6 7)                dooneach(systemout::println)                takeuntil(i -> i  3)                foreach(systemout::println)        systemoutprintln(""""------------------------"""")        observablejust(1 2 3 4 5 6 7)                dooneach(systemout::println)                takewhile(i -> i < 3)                foreach(systemout::println)```that code shows the difference with `takewhile` and it works well we emit 1 2 3 and then stop```------------------------[rxnotification@891cd479 onnext 1]1[rxnotification@891cd47a onnext 2]2[rxnotification@891cd47b onnext 3]3------------------------[rxnotification@891cd479 onnext 1]1[rxnotification@891cd47a onnext 2]2[rxnotification@891cd47b onnext 3]3[rxnotification@891cd47c onnext 4]``` || "";need inclusive predicate variant of takeuntil/takewhile;it has been two times ive been missing a `takeuntil(filter)` operator on observables the last time was in cgeo while implementing a low-power mode: i want to receive location updates through an observable and stop as soon as a location arrives with a precision of 20m or less but i want this location to be returned using `takewhile(!filter)` would drop the matching itemof course this can be worked around but i was surprised not to get this operator which is the dual of `takewhile` would you consider a contribution adding it?;""good question id like to find out from @headinthebox what the canonical solution is to this as haskell various rx flavors and others either must have or need this solution as wellthe `takeuntil(filter)` solution seems like it is a reasonable approach my only question is about the semantics as i could interpret """"until"""" either way (inclusive or exclusive)  || /cc @spodila who also needs a solution to this || nice i could use that thank you || we cannot add every possible operator that people need in the library instead we must make sure you can achieve waht you want by composing a set of orthogonal primitive operators in this case the solution is as follows:``` scalaobject mainscala {  def main(args: array[string]): unit  {    val xs  observableitems(01234)    val ys  xstakewhile(x > x < 3)    yssubscribe(y > println(y)) // 012    val zs  xspublish[int]((xs: observable[int]) > xstakeuntil(xsdropwhile(x > x < 3)))    zssubscribe(z > println(z)) // 0123    readline()  }}``` || maybe i am missing somethingi dont see dropwhile() in 0203 is it already being added? that makes it look a bit convoluted but looks like my use case can work with it || @headinthebox is there a guarantee that your example will work in every case? i may be missing something but where in the documentation is it described that the `xsdropwhile()` observable will consider the respective elements of `xs` before or after `xstakeuntil()` one? isnt there a race condition here? is it guaranteed on every scheduler?in your example couldnt `xsdropwhile(x > x < 3)` emit """"4"""" only after `xstakeuntil()` have already let the """"4"""" pass? || > i dont see dropwhile() in 0203 is it already being added?dropwhile is here:  || @headinthebox your example with rxjava 0204 gives to me """"0 1 2 0 1 2"""" not """"0 1 2 0 1 2 3"""" as shown in your comments your code seems to be the strict equivalent to `takewhile` (drop as soon as the negation of the condition is met) which does not do what is requestedthe proposed `takeuntil(_ > 3)` would properly give """"0 1 2 3"""" || im without a proper computer right now but did you run exactly the same snippet using rxscala? || yup i only added the import:``` scalaimport rxlangscala_object mainscala {  def main(args: array[string]): unit  {  val xs  observableitems(0 1 2 3 4)    val ys  xstakewhile(x > x < 3)    yssubscribe(y > println(y)) // 012    val zs  xspublish[int]((xs: observable[int]) > xstakeuntil(xsdropwhile(x > x < 3)))    zssubscribe(z > println(z)) // 0123    readline()  }```buildsbt:```scalaversion : """"2112""""librarydependencies + """"comnetflixrxjava"""" % """"rxjava-scala"""" % """"0204""and run:```% sbt[info] set current project to x (in build file:/tmp/x/)> run[info] updating {file:/tmp/x/}x[info] resolving jline#jline212 [info] done updating[info] running mainscala 012012[success] total time: 34 s completed sep 16 2014 7 26 pm>```but from what i read this is expected as `takeuntil` will stop as soon as the `dropwhile` fires while we want to keep one more element maybe adding a `tail` after `dropwhile` would get the right one but then comes my former question about ordering guarantees and the code becomes convoluted || @headinthebox any news on this one? || was blocked because of broken scala build || yup the `tail` is missing there is no issue with reordering using `publish` and `takeuntil` on yourself is a very common pattern that more people should use for example you can also define `switch` that same way``` scalaimport rxlangscala_object mainscala {  def main(args: array[string]): unit  {  val xs  observableitems(0 1 2 3 4)  val zs  xspublish[int]((xs: observable[int]) > xstakeuntil(xsdropwhile(x > x < 3)tail))  zssubscribe(z > println(z)) // 0123  readline()}``` || ok but `switch` is defined nevertheless because it is _convenient_ not because it is _needed_ as do many other operators `publishlast` comes to mind i still think an inclusive `takeuntil` would be convenient in common situations (such as the one i described originally which is stopping right after you get a matching value) and is quite contrived to define (especially when you are writing java 7 code which is the case for android developers at this time)i can live without it (and do at this time) but i still think rxjava would be better with those inclusive versions || the point of rx is to be composable we cannot anticipate every single operator that people want to use (_) there are already *__way too many_*\* operators in the library so the default answer is """"no"""" until we seen a pattern appearing in a majority of code (and conversely we should deprecate operators that can be defined in terms of other and are seldomly used) || so lets start with a count of 1 for `takeuntil` :)  || one problem with using publish is it does break backpressure as it introduces multicasting it is a fine solution for hot streams but not desirable for cold ones i use it for example on a buffered denounce but backpressure is not relevant in that case take operators on the other hand should be usable without breaking backpressure  || putting on 10x as this is not a blocker for 10 but i want to continue considering and discussing this also opened #1732 related to this || what about `takewhileinclusive` as a name for this?the issue is that `takeuntil(predicate)` is the same signature as `takewhile(predicate)` and the only difference would be inclusive vs exclusive but the names are ambiguous@headinthebox and i are good for adding this as it is a common need but were struggling with namingthe api would look like this:- `takeuntil(observable)`- `takewhile(predicate)`- `takewhileinclusive(predicate)`what better names (starting with `take`) exist for this? || what about `skipafter` or `terminateafter`? this (scala syntax) does not look too strange to me:``` scala    observableterminateafter(_ > 3)subscribe()```does not look that strange to me `terminateafter` carries the notion that the observable will be terminated right after the matching value while `skipafter` would rather mean that we skip the `onnext` events and propagate the `onterminated` and `onerror` || `takewhileinclusive` may be confusing because it would take the first _non-matching_ value being positive about the termination clause might be clearer since it is it that we want to be inclusive || so what are you proposing? takeuntil is also confusing || i am proposing `terminateafter` (see above) || `terminateafter` is non-discoverable since almost everyone will be looking at `take` `takeuntil` and `takewhile` alphabetically next to each other it is preferable to have a name starting with `take*`and the `skipafter` operator implies it does not unsubscribe but just drops the values || `takeuntilinclusive` may be less confusing than `takewhileinclusive` since you really want to _take_ the values _until_ a condition matches _including_ the matching value (or `takeuntilincluding`) || there is no """"exclusive"""" `takeuntil`  i do agree however than """"until"""" is the right word not """"while""""here is usage:``` java[start a b c stop d e]takeuntilxxx(x -> x  stop)// return [start a b c stop][1 2 3 4 5]takeuntilxxx(x -> x  3)// return [1 2 3][1 2 3 4 5]takeuntilxxx(x -> x > 3)// return [1 2 3 4]``` || going back to the `takeuntil(predicate)` signature it could be like this:``` javatakeuntil(observable) // unsubscribe when observable emitstakeuntil(t -> boolean) // unsubscribe when predicate returns true (inclusive)takewhile(t -> boolean) // unsubscribe when predicate returns false (exclusive)```im concerned with the arbitrary difference of inclusive/exclusive and similarity of signatures the """"until"""" suffix feels like it could be either inclusive or exclusive `takewhile` however seems to behave as expected drops and unsubscribes once it becomes `false` || how about `takewithuntil` for `takeuntilxxx`?  im not familiar with rxjava enough to know how much or if the inclusive sense of with conflicts with its other usage here but it seems sensible enough (and short)  the reason for putting with in the middle is to keep the until closer to the condition || note that this operator is not present in any collection library i know of hence we cannot steal an existing name i guess haskell developers would use `takewhileandthenone  (\(xy:_) -> x ++ [y])span p` which does not work for us -) || i hit another use case today where id really like to have this  || an experimental `takeuntil()` is now available in 105 || one way to distinguish the two versions would be `takeuntil` (forwards then checks) versus `untiltake` (checks the forwards) like `do-while` and `while` || i second the idea of needing this operator id argue this is a basic primitive stream operation that ought not to be composed not including it is like java designers arguing that you dont need a < operator on integers because you already have < and  operators || @mxklabs how urgently do you need this operator? || @akarnokd i need it now but can probably work around it i just wanted to agree with the sentiment that it makes sense to have this operator || @akarnokd also take until (from what i understand from [here]( is not exactly whats requested it takes two observables and terminates as soon as the second observable emits an item as opposed to an observable and a condition and keep emitting upto and including the first emit where the condition holds(not sure if i am looking at the right documentation sorry) || "";1;0;changed predicate to stoppredicate: stops on becoming true;"
2547;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;warnings cleanup;more cleanup: - removed unnecessary imports - added missing generic types - added suppresswarning annotations;;0;warnings cleanup;more cleanup:- removed unnecessary imports- added missing generic types- added suppresswarning annotations;thanks for the cleanup ||;;;;1;1;remove unnecessary imports add missing generic types add suppresswarnings(unchecked);
2548;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;subscriber.request should throw exception if negative request made;as per discussion in #1956 and #2545  making a call to  subscriber.request(n)  with negative n should throw an  illegalargumentexception .  includes unit test.;;1956.0;subscriberrequest should throw exception if negative request made;as per discussion in #1956 and #2545 making a call to `subscriberrequest(n)` with negative n should throw an `illegalargumentexception`includes unit test;i think the iae should be mentioned in requests javadoc || javadoc added || great! ||;request(0) is supposed to work?;the docs about `request` doesnt say anything requirement about `n```` javapublic interface producer {    /**     * request a certain maximum number of items from this producer this is a way of requesting backpressure     * to disable backpressure pass {@code longmax_value} to this method     *     * @param n the maximum number of items you want this producer to produce or {@code longmax_value} if you     *          want the producer to produce items at its own pace     */    public void request(long n)}`````` java    /**     * request a certain maximum number of emitted items from the observable this subscriber is subscribed to     * this is a way of requesting backpressure to disable backpressure pass {@code longmax_value} to this     * method     *     * @param n the maximum number of items you want the observable to emit to the subscriber at this time or     *           {@code longmax_value} if you want the observable to emit items at its own pace     */    protected final void request(long n) {```i assume `n` must be greater than 0 but i also notice i may write something like this occasionally:```long getthenextrequestnumber() {  if () {              return x // x>0  } else {               return 0   }}long n  getthenextrequestnumber()request(n)```so `request(0)` is fine? if not i think its better to document it;`request(0)` should do nothing be a no-op || i concur yet some places a request(0) may trigger a loop and decrement the request counter below zero on the exit edge or do some other sideeffects (search for `getandadd(` in the code)- onsubscribecombinelatest: will subscribe to sources and fill the internal buffers but not emit anything- onsubscriberedo: will trigger a reschedule and clears the boundary indicator- operatorconcat: will deliver oncompleted- operatorgroupby: does an atomic increment and atomic decrement- operatorobserveon: does schedule a thread and may decrement request below 0 for a short amount of time- onbackpressureblock: is incorrect anyway but triggers an empty emission loop- onbackpressurebuffer: triggers a drain loop and may decrement request below 0 for a short time || then it looks like we should better document that `request(0)` should do nothing and fix these places in code so they really do nothing do we want to ignore a negative number as well (like 0) or throw an illegalargumentexception? as a data point the reactive streams spec throws an iae  || > do we want to ignore a negative number as well (like 0) or throw an illegalargumentexception? as a data point the reactive streams spec throws an iaeusually a negative number is not intentional usually means a bug in some place so i like iae rather than ignoring them || im okay with iae  || im using request(0) some places/tests to suppress the default behavior of requesting unlimited amount negative i think is rather a bug than a convenience for no-op ||;1;0;subscriberrequest should throw exception if negative request made;
2548;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;subscriber.request should throw exception if negative request made;as per discussion in #1956 and #2545  making a call to  subscriber.request(n)  with negative n should throw an  illegalargumentexception .  includes unit test.;;2545.0;subscriberrequest should throw exception if negative request made;as per discussion in #1956 and #2545 making a call to `subscriberrequest(n)` with negative n should throw an `illegalargumentexception`includes unit test;i think the iae should be mentioned in requests javadoc || javadoc added || great! ||;subscriberrequest add ignore for negative requests;so that negative requests dont need to be checked by every `operator` that supports backpressure why dont we add a check at the start of `subscriberrequest`:``` javaprotected final void request(long n) {        // ignore zero or negative requests        if (n <0) return        producer shouldrequest  null        synchronized (this) {            if (p ! null) {                shouldrequest  p            } else {                requested  n            }        }        // after releasing lock        if (shouldrequest ! null) {            shouldrequestrequest(n)        }    }```happy to submit pr if has support;looks a good place to add it just a bit comment: ignore zero but iae for negative numbers as per #1956 || i did wonder about that and makes sense ill make a pr || looks to me that n  0 should be allowed through because it may override a default of longmax_value sometimes (asking an upstream producer to produce nothing as opposed to whatever a default might be) ill make a pr with the n < 0 check only ||;1;0;subscriberrequest should throw exception if negative request made;
2550;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;subscriber.onstart requests should be additive (and check for overflow);as per discussion in #2544.;;2544.0;subscriberonstart requests should be additive (and check for overflow);as per discussion in #2544;looks good  that looks helpful thanks @davidmoten  ||;subscriberonstart requests should be additive?;for a `subscriber` without a `producer` calling ``` java@overridepublic void onstart() {    request(2)    request(3)}```does not give 5 requests but 3 only shouldnt this be additive? (or at least documented that it is not);it should be additive and check for overflow do you want to submit a new pr or amend #2548?edit: however as [your commented]( an additive request(0) would never override a max long || ill submit a new pr thanksoverride was probably misleading a better term would be probably be _prevents_ `requested` being set to `longmax_value`  i was referring to the code below from `subscriber` where if a `request(0)` does nothing but return (doesnt set `requested` to 0) then `requested` can end up as longmax_value ``` java public void setproducer(producer producer) {        long torequest        boolean setproducer  false        synchronized (this) {            torequest  requested            p  producer            if (op ! null) {                // middle operator  we pass thru unless a request has been made                if (torequest  longmin_value) {                    // we pass-thru to the next producer as nothing has been requested                    setproducer  true                }            }        }        // do after releasing lock        if (setproducer) {            opsetproducer(p)        } else {            // we execute the request with whatever has been requested (or longmax_value)            if (torequest  longmin_value) {                prequest(longmax_value)            } else {                prequest(torequest)            }        }    }``` ||;1;0;onstart requests should be additive (and check for overflow);
"2553;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;rxringbuffer with synchronization;changed rxringbuffer to use synchronized blocks for correctness. we are relying here upon biased locking and lock-elision. it gets pretty close to the baseline  benchmark:      benchmark              (size)        1.x   |    pr#2333  |    this    1syncstreamofn              1  3779678 748 | 3767936 028 | 3775157 195 1syncstreamofn           1000    21250 675 |   18530 542 |   20759 900 1syncstreamofn        1000000       20 406 |      17 712 |      19 768 nasyncstreamsofn            1   115390 116 |  115629 480 |  113859 532 nasyncstreamsofn         1000        2 579 |       2 546 |       2 435 nsyncstreamsof1             1  3543551 254 | 3602242 709 | 3539162 675 nsyncstreamsof1           100   299166 910 |  301703 721 |  302642 458 nsyncstreamsof1          1000    28404 751 |   28420 833 |   28030 881 nsyncstreamsofn             1  4054571 577 | 4003156 953 | 4061124 105 nsyncstreamsofn          1000       24 324 |      20 601 |      23 137 twoasyncstreamsofn          1    85846 727 |   85682 983 |   86691 331 twoasyncstreamsofn       1000     1823 137 |    1889 458 |    1761 977 reamofnthatmergesin1        1  3724179 351 | 3725068 220 | 3715637 985 reamofnthatmergesin1     1000    19051 928 |   19392 595 |   19487 059 reamofnthatmergesin1  1000000       18 265 |      18 069 |      18 102      changes (in respect of 1.x): - using spscarrayqueue  removed look-ahead and null check - using peek to check for emptyness in certain positions - using short-as-possible synchronization blocks;;2333.0;rxringbuffer with synchronization;changed rxringbuffer to use synchronized blocks for correctness we are relying here upon biased locking and lock-elision it gets pretty close to the baselinebenchmark:```benchmark              (size)        1x   |    pr#2333  |    this   1syncstreamofn              1  3779678748 | 3767936028 | 37751571951syncstreamofn           1000    21250675 |   18530542 |   207599001syncstreamofn        1000000       20406 |      17712 |      19768nasyncstreamsofn            1   115390116 |  115629480 |  113859532nasyncstreamsofn         1000        2579 |       2546 |       2435nsyncstreamsof1             1  3543551254 | 3602242709 | 3539162675nsyncstreamsof1           100   299166910 |  301703721 |  302642458nsyncstreamsof1          1000    28404751 |   28420833 |   28030881nsyncstreamsofn             1  4054571577 | 4003156953 | 4061124105nsyncstreamsofn          1000       24324 |      20601 |      23137twoasyncstreamsofn          1    85846727 |   85682983 |   86691331twoasyncstreamsofn       1000     1823137 |    1889458 |    1761977reamofnthatmergesin1        1  3724179351 | 3725068220 | 3715637985reamofnthatmergesin1     1000    19051928 |   19392595 |   19487059reamofnthatmergesin1  1000000       18265 |      18069 |      18102```changes (in respect of 1x):- using spscarrayqueue removed look-ahead and null check- using peek to check for emptyness in certain positions- using short-as-possible synchronization blocks;here is my perf comparison building on what i did at   1x branch as of jan 22ndpr2333  pr #2333 after rebasing onto 1x (jan 22nd)pr2189  pr #2189 after rebasing onto 1x (jan 22nd)pr2553  pr #2553 on 1x as of jan 28benchmark                                          (size)   mode   samples          1x        pr2189        pr2333       pr2553rooperatormergeperfmerge1syncstreamofn               1  thrpt         5  4879535663   4773501735   4807008476  4701375614rooperatormergeperfmerge1syncstreamofn            1000  thrpt         5    43295567     37341214     34950819    41735196rooperatormergeperfmerge1syncstreamofn         1000000  thrpt         5       41255        40202        32236       36977rooperatormergeperfmergenasyncstreamsofn             1  thrpt         5    99885768    101321745     97689264   100134213rooperatormergeperfmergenasyncstreamsofn          1000  thrpt         5        4846         4715         4973        4552rooperatormergeperfmergensyncstreamsof1              1  thrpt         5  4684222432   4747380010   4751592996  4704340700rooperatormergeperfmergensyncstreamsof1            100  thrpt         5   456736726    468609567    467310110   451615231rooperatormergeperfmergensyncstreamsof1           1000  thrpt         5    40504652     41472463     41146594    41767150rooperatormergeperfmergensyncstreamsofn              1  thrpt         5  4993477475   5268523818   5414652857  5166606822rooperatormergeperfmergensyncstreamsofn           1000  thrpt         5       44460        42820        32926       40496rooperatormergeperfmergetwoasyncstreamsofn           1  thrpt         5    79546448     76853391     73846697    76358122rooperatormergeperfmergetwoasyncstreamsofn        1000  thrpt         5     3138932      3140582      2672720     2283587rooperatormergeperfonestreamofnthatmergesin1         1  thrpt         5  5248113569   5136570967   5225289115  4471499594rooperatormergeperfonestreamofnthatmergesin1      1000  thrpt         5    39001895     39254876     39235506    35812513rooperatormergeperfonestreamofnthatmergesin1   1000000  thrpt         5       35039        35282        33375       33375```the degradations of this are incremental and i think worth the correctnesscrazy to me that we cant find a non-blocking approach that performs better than the jvm doing lock-elisioni suggest we move forward with this after cleaning up the comments in the code that are no longer valid || > i suggest we move forward with this after cleaning up the comments in the code that are no longer validokay if you feel ready you can merge it at your will ill take care of #2541 ||;rxringbuffer fixes and improvements;this pr contains the fixes and improvements on the rxringbuffer and its single-consumer-single-producer queue- added `swsrphaser` which is a variant of gil tenes writerreaderphaser that uses cheaper atomic operations because the single reader and single writer use case note that pre java 8 unsafe doesnt support atomic addandgetlong operation the simplified phaser costs only a single atomic increment per use- updated `spscarrayqueue` to match jctools current version: the queue now can be fully utilized to its capacity- the `rxringbuffer` now uses two phasers: one for the offer side and one for the poll/peek side the benefits: reduced interference between readers and writers allows using the simplified phaser because each side is now single threaded (a shared phaser implies up to 2 threads at once)benchmark results:```benchmark              (size)        1x   |      this   1syncstreamofn              1  3779678748 | 3767936028 1syncstreamofn           1000    21250675 |   18530542 1syncstreamofn        1000000       20406 |      17712 nasyncstreamsofn            1   115390116 |  115629480 nasyncstreamsofn         1000        2579 |       2546 nsyncstreamsof1             1  3543551254 | 3602242709 nsyncstreamsof1           100   299166910 |  301703721 nsyncstreamsof1          1000    28404751 |   28420833 nsyncstreamsofn             1  4054571577 | 4003156953 nsyncstreamsofn          1000       24324 |      20601 twoasyncstreamsofn          1    85846727 |   85682983 twoasyncstreamsofn       1000     1823137 |    1889458 reamofnthatmergesin1        1  3724179351 | 3725068220 reamofnthatmergesin1     1000    19051928 |   19392595 reamofnthatmergesin1  1000000       18265 |      18069```;""@akarnokd is that ops/s? why is it slower in some cases too?edit: it seems that its slower in most of the cases? if it is really ops/s || yes ops per second these are the most noticeably slower ones:```1syncstreamofn           1000    21250675 |   185305421syncstreamofn        1000000       20406 |      17712nsyncstreamsofn          1000       24324 |      20601```i havent dig into it but my guess is that the atomic increment-and-get on the peek() and poll() some queue users first call peek() and if it returns something then they do a full poll() this is 2 increments per value instead of none in 1x ive been thinking about the option to remove the phaser from peek() since it doesnt change any queue state (alternatively the two might be merged into a `pollif(predicate consume)` where the callback would tell to remove the value or not)edit: correction the only place peek() is used is in zip tick so it is one atomic increment per poll instead of 0 || @akarnokd you can click """"restart build"""" in travis ci  || @zsxwing thanks i never logged into travis so did not see the button || @akarnokd is this the one you think is ready for merge? if so ill do my tests with flight recorder to appease my concern on memory and gc behavior  || yes it is || here is the outcome of my perf testing on this:``` /gradlew benchmarks -pjmh-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 1 *operatormergeperf*benchmark                                          (size)   mode   samples          1x           prrooperatormergeperfmerge1syncstreamofn               1  thrpt         5  5052690265  4989944158 rooperatormergeperfmerge1syncstreamofn            1000  thrpt         5    43229405    34265533 --rooperatormergeperfmerge1syncstreamofn         1000000  thrpt         5       41317       30750 --rooperatormergeperfmergenasyncstreamsofn             1  thrpt         5   101442051    95688061 rooperatormergeperfmergenasyncstreamsofn          1000  thrpt         5        4776        4768rooperatormergeperfmergensyncstreamsof1              1  thrpt         5  4640498106  4525502795rooperatormergeperfmergensyncstreamsof1            100  thrpt         5   446840647   448934827rooperatormergeperfmergensyncstreamsof1           1000  thrpt         5    39857078    39870866rooperatormergeperfmergensyncstreamsofn              1  thrpt         5  4837426647  5174591967rooperatormergeperfmergensyncstreamsofn           1000  thrpt         5       39182       29531 --rooperatormergeperfmergetwoasyncstreamsofn           1  thrpt         5    76236959    76523262 rooperatormergeperfmergetwoasyncstreamsofn        1000  thrpt         5     3073535     2556523 -rooperatormergeperfonestreamofnthatmergesin1         1  thrpt         5  4984161207  4745798100 rooperatormergeperfonestreamofnthatmergesin1      1000  thrpt         5    37588942    35720766rooperatormergeperfonestreamofnthatmergesin1   1000000  thrpt         5       34425       31146```flight recorder testing against first minute of """"iteration"""" stage of this jmh run:```/gradlew benchmarks -pjmh-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 20 *operatormergeperfmerge1syncstreamofn*```1x baseline overview![baseline-overview]( pr overview![pr-overview]( baseline allocations![baseline-allocations]( pr allocations![pr-allocations]( || the cpu usage appears to be higher on this pr (the average is 19 versus 17) not sure if there are other changes in 1x that could affect this as this pr is 17 days old as per previous comments there are 3 perf tests that take a noticeable performance hit  || i suggest that we merge the jctools spscarrayqueue fixes in via another pr since we want those regardless of what else we do and so comparisons across approaches are equivalent im not yet ready to accept the performance hit this pr gives  || here is comparing #2189 and this pr to 1x i rebased both prs onto the current 1x branch to try and be as accurate as possible:```1x  current 1x branchpr2333  pr #2333 after rebasing onto 1xpr2189  pr #2189 after rebasing onto 1xbenchmark                                          (size)   mode   samples          1x        pr2189        pr2333rooperatormergeperfmerge1syncstreamofn               1  thrpt         5  4879535663   4773501735   4807008476rooperatormergeperfmerge1syncstreamofn            1000  thrpt         5    43295567     37341214     34950819rooperatormergeperfmerge1syncstreamofn         1000000  thrpt         5       41255        40202        32236rooperatormergeperfmergenasyncstreamsofn             1  thrpt         5    99885768    101321745     97689264rooperatormergeperfmergenasyncstreamsofn          1000  thrpt         5        4846         4715         4973rooperatormergeperfmergensyncstreamsof1              1  thrpt         5  4684222432   4747380010   4751592996rooperatormergeperfmergensyncstreamsof1            100  thrpt         5   456736726    468609567    467310110rooperatormergeperfmergensyncstreamsof1           1000  thrpt         5    40504652     41472463     41146594rooperatormergeperfmergensyncstreamsofn              1  thrpt         5  4993477475   5268523818   5414652857rooperatormergeperfmergensyncstreamsofn           1000  thrpt         5       44460        42820        32926rooperatormergeperfmergetwoasyncstreamsofn           1  thrpt         5    79546448     76853391     73846697rooperatormergeperfmergetwoasyncstreamsofn        1000  thrpt         5     3138932      3140582      2672720rooperatormergeperfonestreamofnthatmergesin1         1  thrpt         5  5248113569   5136570967   5225289115rooperatormergeperfonestreamofnthatmergesin1      1000  thrpt         5    39001895     39254876     39235506rooperatormergeperfonestreamofnthatmergesin1   1000000  thrpt         5       35039        35282        33375``` || "";1;0;removed commented-out code;"
"2559;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;onsubscribefromiterable - add request overflow check;a subscriber like so provokes a hang from  onsubscribefromiterable  due to overflow to negative of requested field:      java     @override     public void onstart() {         request(2)      }      @override     public void onnext(integer t) {         request(long.max_value-1)      }      i ve moved the  getandaddrequest  method that does the overflow check to a new  rx.internal.operators.util  class that is also now used by the request overflow check in  operatormerge .  of course there are plenty more of these to be done. i propose to do them bit by bit.;;0;onsubscribefromiterable - add request overflow check;a subscriber like so provokes a hang from `onsubscribefromiterable` due to overflow to negative of requested field:``` java    @override    public void onstart() {        request(2)    }    @override    public void onnext(integer t) {        request(longmax_value-1)    }```ive moved the `getandaddrequest` method that does the overflow check to a new `rxinternaloperatorsutil` class that is also now used by the request overflow check in `operatormerge`of course there are plenty more of these to be done i propose to do them bit by bit;""requested gets reduced as well in this onsubscribe ill ponder this and report what effects will be might make another change || i think backpressureutils would be a better name and an atomiclong overload would be great || rightoon 29 jan 2015 20:02 """"david karnok"""" notifications@githubcom wrote:> i think backpressureutils would be a better name and an atomiclong> overload would be great> > > reply to this email directly or view it on github>  || oops fixing the javadoc || changes made as requested by @akarnokd the bit i was pondering was what behaviour should be expected of an `observable` when additive requests reach `longmax_value` i came up with a policy that i added to the javadoc of `subscriberrequest` and `producerrequest`:> requests are additive but if a sequence of requests totals more than longmax_value then longmax_value requests will be actioned and the extras may be ignored arriving at longmax_value by addition of requests cannot be assumed to disable backpressure for example the code below may result in longmax_value requests being actioned only> > request(100)> request(longmax_value-1) ||  javadoc typo squashed commits || good job! merging || "";;;;1;1;add request overflow check for onsubscribefromiterable;"
2561;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;updating queue code from jctools;rebased onto master.;;0;updating queue code from jctools;rebased onto master;;;;;1;1;updating queue code from jctools;
"2565;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;obstruction detection in tests.;to make sure tests don t hang the computation scheduler.;;0;obstruction detection in tests;to make sure tests dont hang the computation scheduler;""i likeon 29 jan 2015 22:20 """"david karnok"""" notifications@githubcom wrote:> ## to make sure tests dont hang the computation scheduler> > you can view comment on or merge this pull request online at:> >    commit summary> - obstruction detection in tests> > file changes> - _m_ src/test/java/rx/backpressuretestsjava>    (22)> - _a_ src/test/java/rx/test/testobstructiondetectionjava>    (90)> - _a_ src/test/java/rx/test/testobstructiondetectiontestjava>    (74)> > patch links:> -  -  > > reply to this email directly or view it on github>  || im merging this to disable `testflatmapasync` failing +30% of the time on the slightest hiccup || "";;;;1;1;obstruction detection in tests;"
"2572;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;give more time to certain concurrency tests.;on my windows machine  i ve virtualized an ubuntu machine and adjusted some tests according to the time it takes on this  slow machine .;;0;give more time to certain concurrency tests;""on my windows machine ive virtualized an ubuntu machine and adjusted some tests according to the time it takes on this """"slow machine"""""";;;;;1;1;give more time to certain concurrency tests;"
2574;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;sizeeviction test needs to return false;when a replay subject with size and time eviction policy is used then any observer that subscribes after some events are already pushed will not get those older events.  this is because if an observable is not yet terminated then on subscription by any new observer the check for event validity fails on the size eviction policy hence that event is dropped and not pushed to the new subscriber.  relevant call stack:    {{{       timeonadd.call      boundedstate.replayobserverfromindextest         boundedstate.replayobserverfromindextest              pairevictionpolicy.test }}}      test case:  - add test case for this use case  fails if without changes.;;0;sizeeviction test needs to return false;when a replay subject with size and time eviction policy is used then any observer that subscribes after some events are already pushed will not get those older events this is because if an observable is not yet terminated then on subscription by any new observer the check for event validity fails on the size eviction policy hence that event is dropped and not pushed to the new subscriberrelevant call stack:   {{{``` timeonaddcall     boundedstatereplayobserverfromindextest        boundedstatereplayobserverfromindextest             pairevictionpolicytest}}}```test case: - add test case for this use case fails if without changes;good catch ;;;;1;1;sizeeviction test needs to return false when verifying if it needs eviction;
"2585;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator: switchifempty;changes to #2091;;209.0;operator: switchifempty;changes to #2091;thanks @akarnokd for fixing up and merging! ||;implement cache operator;returns an observable that repeats the original observable sequence to all subscribersthe source observable is subscribed to at most oncewhen looking into integrating hystrix and rxjava the need for this operator became apparent it appears to be of general use so should be considered for rxjava core;""#50 how does this relate to publish ( and multicast ( || #51  my understanding is that publish and multicast dont remember or replay events that the source observable generated before a given subscriber subscribed  || i think youre right how about replay ( through your code submission now  || i really like how many unit tests there are  very nicei need to think through the implications of this compared with replay/refcount/publish/multicast etc in other words if rxnet doesnt have this operator for such a common case it seems that it should already be covered by one of the ones we have not yet implemented  || replay could be what this is modulo replays connect() semantics (which i cant quite decipher from the documentation)  || that part is still somewhat confusing to me as well as i havent yet spent the time to fully grok these operators and what it will take to implementperhaps though a `cache` operator would be a good cover method for the """"typical usecase"""" that underneath is using `replay` and takes care of connections etc  perhaps similar to how `refcount` does the connection/disconnect by counting subscriptions?what im trying to accomplish is first achieve the functionality provided by rx and only then add new functionality if its not already accounted for rxnet has years of thought into the api design and functionality and there is value in common knowledge across implementations if we can maintain the same behavior || i can see why one would need a connect() method for publish: one would want to be able to subscribe multiple observers to a publish before having the publish subscribe to its source if the publish subscribed to its source upon the first subscription it got its second subscriber wouldnt get the initial set of notificationsthe connect() method makes a lot less sense for replay as the second and later subscribers would get the initial set of notifications either way the only things i can think of are:- a desire to have the initial set of notification calls interleaved across the initial set of observers but i see nothing in the contract preventing an implementation from sending a batch of notifications to one observer before sending any of them to another- a roundabout way of allowing the replay to be forcibly unsubscribed from its source but this is not nearly as useful as a way to inform the replay that it will have no new subscribers allowing it to unsubscribe from its source when its last current subscriber unsubscribes- some useful semantic around multiple connections the microsoft documentation does not specify what happens if connect() is called a second time either with or without the first connection being disposed || i believe cache is a wrapper around replay that calls the replays connect() upon the first subscription || are you interested in exploring what an implementation of replay would look like (not necessarily all of the overloads that we eventually want but whatever is necessary for this use case) and perhaps submitting that implementation to accomplish `cache` functionality while retaining our goal of complying to the rxnet api? || i think so i would need to know what the behavior of a second call to connect() is supposed to be both with and without the first call being unsubscribed || if you can play with rxnet or rxjs that would be the best way to determine the correct behavior you can also take a look at the rxnet source: replaysubject:   || - connecting without previous disconnect is idempotent- disconnecting is idempotent and generates no events- connecting after a disconnect re-subscribes to the source || is this going away because of  or does this still make sense? || a variant of replay that connects on first subscription could make sense but might not meet the threshold for adding a new operator in any case it wouldnt use the commit in this request || i think i figured out when the connectableobservable would come into play with replay in a cache scenario- source emits 10 values- subscribera subscribes and receives the 10 values- source emits 5 values (and subscribera receives them)- subscribeb subscribes and receives the 15 values- subscribera unsubscribesnow what do we do? we cant unsubscribe from source because subscriberb still expects to receive values- source emits 5 new values and subscriberb receives them- subscriberb unsubscribesdo we unsubscribe from source now? thats how the `refcount` operator works- subscriberc subscribes and receives 20 values- subscriberc unsubscribes- source keeps emitting values that keep getting cached and it never goes awayin other words the `cache` operator were discussing here would only work if the source sequence correctly completed at some point if it was an infinite (or very long running) observable it would keep filling up the replaysubject in the background and likely become a memory leakthus the connectableobservable is a way to unsubscribei still think a `cache` operator is useful but it can be misused easily  but so can `tolist` which has the exact same problem on an infinite sequence || i was thinking about adding a method to the cache operator to notify it when it gets evicted and can rely on having no additional subscribers that way it could unsubscribe from its source when all of the existing subscribers unsubscribedas gravy it could even drop references to events that have been sent to all existing subscribers but thats less important || unsubscribing once all subscribers are unsubscribed is what the `refcount` operator does and i cant see how to make that work for the use cases where `cache` is intended here is an example timeline using `cache`:- origin starts- onnext(1)- a subscribes - receives (1)- onnext(2)- a receives (2)- b subscribes - receives (1 2)- origin oncompleted - a & b receives (oncompleted)- c subscribes - receives (1 2 oncompleted)using a refcount system that unsubscribes from the origin would result in re-executing the origin which is exactly what this operator is there to preventsame problem with dropping references to events that have been sent to all existing subscribers c wouldnt receive anything in that casehere is the same timeline with `refcount` or something else that unsubscribes when all subscribers leave (or the origin completes which is the same):- origin starts- onnext(1)- a subscribes - receives (1)- onnext(2)- a receives (2)- b subscribes - receives (1 2)- origin oncompleted - a & b receives (oncompleted)- c subscribes - origin is subscribed to again- onnext(1)- c receives (1)- onnext(2)- c receives (2)- origin oncompleted - c receives (oncompleted)both of the use cases you suggest seem like they are exactly what `refcount` is intended for and its many overloads for max number of events to store time windows etc `refcount` works great for hot-observables (infinite sequences) or very long running ones from what i can tell but its not very good for a sequence that emits 1 or a handful of responses and completesam i misunderstanding your meaning? || a `cache` would differ from a `refcount` in that it would stay subscribed until after it is explicitly notified by this new method that it has been evicted and there will be no more subscribers so in your example timeline c would get (1 2 completed) as there was no eviction notification callthe use case is that the creator of the cache (eg hystrix) would place the cache observable into some sort of data structure (eg hystrixrequestcache) from which the cache observable can gain new subscribers when the data structure expires or otherwise evicts the cache observable it would use this new method to notify the cache observable that it will receive no more subscribers at that point the cache observable can unsubscribe from its source when its reference count reaches zerothis is only worth doing if subscribers are likely to unsubscribe before the sequence completes or if it is worth discarding early history while existing subscribers remain post-eviction || i think the key line you said is this:> this is only worth doing if subscribers are likely to unsubscribe before the sequence completes or if it is worth discarding early history while existing subscribers remain post-evictionsince hystrix will always complete (onerror or oncompleted) it doesnt really matter (nor is there a reliable hook to know when to cause eviction since even hystrixrequestcontext is not a required thing)thus it seems that an object being dereferenced and then garbage collected is sufficient for the hystrix case since the observable would have terminated and have no resources to clean upof note it was my working on hystrix to support rxjava that drove me to add `cache`how would your proposed changes modify the method signature of `cache` in case we want to add the behavior youre describing? would it need to return a `cachedobservable` with the eviction hook? || > how would your proposed changes modify the method signature of cache in case we want to add the behavior youre describing? would it need to return a cachedobservable with the eviction hook?pretty much also the code maintaining the data structure would have to control subscriptions to the cache so that it would be able to know when there are no more subscribersi had decided this embellishment probably wasnt worth doing but it was relevant to your question about sequences that never complete || im going to stick with `cache` as a simple thing without the eviction support and if needed we can evolve over time (since returning a cachedobservable instead of observable would be a non-breaking change  i think)i also want to better understand how combinations of things like `replay()refcount()` may provide similar functionality to what we were discussing before inventing a new type of observablethanks for the feedback || "";1;0;using @experimental covariance and final class;"
2591;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;changed the naming of the newthreadworker s system parameters;changed the parameter naming as per [discussed](https://github.com/reactivex/rxjava/pull/2465#discussion_r24035981).;;0;changed the naming of the newthreadworkers system parameters;changed the parameter naming as per [discussed](https://githubcom/reactivex/rxjava/pull/2465#discussion_r24035981);;;;;1;1;changed the naming of the newthreadworkers system parameters;
2594;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;revert behavior change in testsubscriber.awaitterminalevent;reverts change made at   see discussion at   the javadoc for this method clearly states that it will wait until completion or timeout. it does not say it will throw an exception on timeout  so we can not start throwing as that is a behavioral change.;;0;revert behavior change in testsubscriberawaitterminalevent;reverts change made at  discussion at  javadoc for this method clearly states that it will wait until completion or timeout it does not say it will throw an exception on timeout so we can not start throwing as that is a behavioral change;;;;;1;1;revert behavior change in testsubscriberawaitterminaleventreverts change made at  discussion at  javadoc for this method clearly states that it will wait until completion or timeout it does not say it will throw an exception on timeout so we can not start throwing as that is a behavioral change;
2601;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;added common exceptions.throwifany to throw a collection of exceptions;tried to be as flexible with the error text as possible.;;0;added common exceptionsthrowifany to throw a collection of exceptions;tried to be as flexible with the error text as possible;this is a nice change  just the comments on using `propagate` that id like to handle || updated the code based on the comments above || that build failure is concerning  it hung and timed out after 10 minutes at this test:> rxexceptionsexceptionstest > teststackoverflowisthrown started || most likely it died of stackoverflow while attempting to report stackoverflow ive removed the custom message and manually inlined the propagate method ||;;;;1;1;reporting stackoverflow caused stackoverflow;
"2622;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;changed observable.empty() into a stateless constant observable.;empty was always stateless so creating a new instance all the time (especially through a  from(iterable) ) is wasteful. besides   oncompleted  events don t have to be backpressured.  should enable identity based optimizations discussed in #1653.;;1653.0;changed observableempty() into a stateless constant observable;empty was always stateless so creating a new instance all the time (especially through a `from(iterable)`) is wasteful besides `oncompleted` events dont have to be backpressuredshould enable identity based optimizations discussed in #1653;;optimisations with observableempty();i notice that calling `observableconcat(observableempty())` invokes back-pressure id find it useful if when i used `observableempty()` that optimisations came into play such as ensuring that `observableconcat(observableempty())` simply returned `observable`to achieve this id make a private constant `empty  from(new arraylist())`  in `observable` so that calling `observableempty()` always returned this object cast into the appropriate generic type then id use a simple object reference equality test to determine if an optimisation could be madedo you think this proposal has legs? if so ill knock up a pr i would seek to optimise more than just the `concat` operator  it would include `merge` and possibly others which i can think about if the time comes;""in this vein might be good to get `from(list)` return empty whenever the list is empty that would enable the optimisations more often || this is inaccurate """"i notice that calling observableconcat(observableempty()) invokes back-pressure"""" it was actually a combination of operators including concat regardless i think the optimisations would be useful || i stumbled upon your report while also looking at `observableempty()` i wonder why it instantiates a new `arraylist` every single time instead of using `collectionsemptylist()`? its the canonical way to represent the list """"null object"""" in java and its more memory efficient too since it doesnt allocate an empty array of capacity 16 that will never end up having items || no idea why we arent using `collectionsemptylist()`  we should be just a simple oversight by my or someone else who has contributed  || thanks @mttkay that looks good @benjchristensen what about more optimisations that would- collapse the call stack- avoid unnecessary invocations of backpressure slow pathfor example `concat` is now:```public final static <t> observable<t> concat(observable<? extends t> t1 observable<? extends t> t2) {    return concat(just(t1 t2))}```but could be:```public final static <t> observable<t> concat(observable<? extends t> t1 observable<? extends t> t2) {    if (t1  empty)         return t2    else if (t2  empty)        return t1    else         return concat(just(t1 t2))}``` || @davidmoten `merge` can benefit from it too || @davidmoten what about adding the empty check here too:         @override        public void onnext(observable<? extends t> t) {            if(tempty) return // check empty            queueadd(nlnext(t))            if (wip_updatergetandincrement(this)  0) {                subscribenext()            }        }``` || there are a lot of operators that can benefit from this i would hazard a guess that most can use this optimisation at the high level within the `observable` class and yes good point @zsxwing we could dig into operators for more optimisations ill proceed with the pr if @benjchristensen gives it the tick || if you want to submit a pr with this work done ill accept it if we can use `collectionsemptylist()` somewhere that we are currently allocating that will always be better || put on 10x as this is not a blocker for 10 but whenever you submit the pr ill do it || im starting work on this pr now and id like to get the ok on some detailid propose adding this to `observable` just after the init of the hook:``` javaprivate static final observable<?> empty  from(collectionsemptylist())````observableempty()` would be changed to:``` java    @suppresswarnings(""""unchecked"""")    public final static <t> observable<t> empty() {        return (observable<t>) empty    }```as an example of how it would be used the static method `observablemerge` would be changed to:``` java    @suppresswarnings(""""unchecked"""")    public final static <t> observable<t> merge(observable<? extends t> t1 observable<? extends t> t2) {        if (t1  empty)             return (observable<t>) t2        else if (t2  empty)            return (observable<t>) t1        else             return merge(from(arraysaslist(t1 t2)))    }```note that ive confirmed in the debugger that this optimisation avoids triggering backpressure if say `omergewith(observableempty())` is called ~~ill get a unit test going for this as well~~a large number of methods will use this optimisation so id like to get my exact approach approved before submittingthe final thing to note is that optimisations outside of the `observable` class would do a reference equality check against `observableempty()` so in the example from `operatorconcat` by @zsxwing above:``` java        @override        public void onnext(observable<? extends t> t) {            if(tobservableempty()) return // check empty            queueadd(nlnext(t))            if (wip_updatergetandincrement(this)  0) {                subscribenext()            }        }```id like to limit the scope of my pr to optimisations in observablejava only optimisations in operators would wait for this base pr to be acceptedhow does that sound? || why do you have so many `empty()` to merge?edit: at least i looked at the implementation and improved it in #2622 || ta for improvement the reason i have `empty()`s to merge is that this is a common pattern for me:``` javaoflatmap(t -> {   if (cond(t))        return someobservable(t)  else        return observableempty()   })```im experimenting now with substituting the special case where the flatmap function returns either 0 or 1 by doing ``` javaomap(tooptional)filter(ispresent)map(tovalue)```id hope it would be faster but not sure || this pr is quite old can you create a reasonable benchmark to see how concatmap and flatmap behaves? in addition i suggest we tackle this after both #2928 and #2960 are  yep ill do benchmarks after those prs have been merged || this may be part of the operator-fusion optimizations in 2x but i dont see this in 1x due to non-technical reasons || for a start: here is the baseline perf: #3754 im going to merge it so subsequent prs can be benchmarked with it || see #3759 for the optimized `concat`s || see #3761 for the optimized `merge`s || optimizations have been added and released with 114 closing the issue if you have more ideas where its worth adding extra checks for empty dont hesitate to open a new issue || "";1;0;changed empty into a stateless constant observable;"
"2627;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;flatmap overloads with maximum concurrency parameter;for issue #2626.  there is no point in adding maxconcurrent to flatmapiterable because each iterable is subscribed to sequentially and run to completion.;;2626.0;flatmap overloads with maximum concurrency parameter;for issue #2626there is no point in adding maxconcurrent to flatmapiterable because each iterable is subscribed to sequentially and run to completion; > there is no point in adding maxconcurrent to flatmapiterable because each iterable is subscribed to sequentially and run to completioni was wrong with this statement depending on the request pattern reordering may still happen and the downstream may be still slower unboundedness of `flatmapiterable` may still cause excessive source iterable generation that fills in the tracking arrays inside `flatmap`having the `maxconcurrency` parameter is valuable and prevents buffer bloat ||;add flatmap variant with maxconcurrent;to allow use of `merge(observables maxconcurrent)` via flatmap we should consider adding a `flatmap(func int maxconcurrent)` overload;""example usage:``` java        observablerange(0 integermax_value)map(i -> """"lineofdata-"""" + i) // simulate the file with many lines                buffer(100) // buffer up chunks of work before processing them                flatmap(chunk -> {                    return observablejust(chunk)subscribeon(schedulersio()) // put each group on a new thread (io scheduler for blocking io)                             doonnext(t -> {                                // do work here                                try {                                    threadsleep(1000)                                } catch (exception e) {                                }                                // write out on blocking io as a side-effect                                systemoutprintln(""""emitting to io: """" + t)                            })                } maxconcurrentvaluehere)toblocking()foreach(systemout::println)``` || the related pr has been merged closing || "";1;0;flatmap overloads with maximum concurrency parameter;"
2630;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;cast back observer to subscriber if passed to subscribe(observer);rebased #2600.;;2600.0;cast back observer to subscriber if passed to subscribe(observer);rebased #2600;;make sure we keep a subscribers subscription when passed as observer;fixes https://githubcom/reactivex/rxjava/issues/2599;thanks once the master build is  im going to merge this ||  redone in #2630 because of merge conflicts ||;1;0;cast back observer to subscriber if passed to subscribe(observer);
2642;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix a potential memory leak in scheduleperiodically;there is a potential memory leak in  scheduleperiodically  that may keep a reference to  action  after  unsubscribe .   because  mas.set  is called after  schedule    it may replace a new subscription (created in  recursiveaction ) with the old one. therefore   unsubscribe  won t be able to unsubscribe the new subscription and will keep the reference to  action  until the period time elapses.  this pr fixed it by calling  mas.set  before  schedule .;;0;fix a potential memory leak in scheduleperiodically;there is a potential memory leak in `scheduleperiodically` that may keep a reference to `action` after `unsubscribe` because `masset` is called after `schedule`  it may replace a new subscription (created in `recursiveaction`) with the old one therefore `unsubscribe` wont be able to unsubscribe the new subscription and will keep the reference to `action` until the period time elapsesthis pr  it by calling `masset` before `schedule`;it is functionally mergeable but you could have used `multipleassignmentsubscription s  ` and saved an import ||;;;;1;1;use multipleassignmentsubscription to save an import;
"2648;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;takewhile: don t unsubscribe downstream.;2647 issue with takewhile.;;2647.0;takewhile: dont unsubscribe downstream;2647 issue with takewhile;;flatmap doesnt propagate oncomplete with unsubscribe of child;""the following code hangs forever as it doesnt emit a terminal event:``` javaimport javautilconcurrenttimeunitimport rxobservablepublic class intervaltakewhileexample {    public static void main(string args) {        observable                interval(1 timeunitmilliseconds)                dooneach(a -> systemoutprintln(""""a > """" + a))                takewhile(along -> along < 1)                dooneach(b -> systemoutprintln(""""b > """" + b))                flatmap(along -> {                    return observable                            timer(30 timeunitmilliseconds)                            doonunsubscribe(() -> systemoutprintln(""""unsubscribed timer?""""))                            dooneach(c -> systemoutprintln(""""c > """" + c))                            map(along1 -> along1 + along)                })                dooneach(d -> systemoutprintln(""""d > """" + d))                toblocking()foreach(systemout::println)    }}```this emits:```a > [rxnotification@f6adcf11 onnext 0]b > [rxnotification@f6adcf11 onnext 0]a > [rxnotification@f6adcf12 onnext 1]b > [rxnotification@5b2cf4de oncompleted]unsubscribed timer?```"";""/cc @abersnaze this may be related to the issue youre hunting || it is not related to `interval` as i can replicate without it:``` javaimport javautilconcurrenttimeunitimport rxobservablepublic class intervaltakewhileexample {    public static void main(string args) {        observable                <integer>create(s -> {                    sonnext(0)                    try {                        threadsleep(5)                    } catch (exception e) {                        eprintstacktrace()                    }                    sonnext(1)                    soncompleted()                })                dooneach(a -> systemoutprintln(""""a > """" + a))                takewhile(along -> along < 1)                dooneach(b -> systemoutprintln(""""b > """" + b))                flatmap(along -> {                    return observable                            timer(30 timeunitmilliseconds)                            doonunsubscribe(() -> systemoutprintln(""""unsubscribed timer?""""))                            dooneach(c -> systemoutprintln(""""c > """" + c))                            map(along1 -> along1 + along)                })                dooneach(d -> systemoutprintln(""""d > """" + d))                toblocking()foreach(systemout::println)    }}```however if i change `takewhile` to `take(1)` it works fine so it may be related to `takewhile` but `merge` is always a candidate for this and my first thought  || its not just takewhile  it also fails if replace:takewhile(along -> along < 1)with:flatmap(along -> (along < 1) ? observablejust(i) : observableempty) || the `takewhile` issue was  in 106 || > flatmap(along -> (along < 1) ? observablejust(i) : observableempty)i dont understand this one in the code example what is variable `i`?this works in 106:``` javaimport javautilconcurrenttimeunitimport rxobservablepublic class intervaltakewhileexample {    public static void main(string args) {        observable                <integer> create(s -> {                    sonnext(0)                    try {                        threadsleep(5)                    } catch (exception e) {                        eprintstacktrace()                    }                    sonnext(1)                    soncompleted()                })                dooneach(a -> systemoutprintln(""""a > """" + a))                //                takewhile(along -> along < 1)                flatmap(along -> (along < 1) ? observablejust(along) : observableempty())                dooneach(b -> systemoutprintln(""""b > """" + b))                flatmap(along -> {                    return observable                            timer(30 timeunitmilliseconds)                            doonunsubscribe(() -> systemoutprintln(""""unsubscribed timer?""""))                            dooneach(c -> systemoutprintln(""""c > """" + c))                            map(along1 -> along1 + along)                })                dooneach(d -> systemoutprintln(""""d > """" + d))                toblocking()foreach(systemout::println)    }}``` || is this issue still outstanding with `flatmap()`? im seeing a similar behavior where i never get a terminal event after a flatmap || @felipecsl could you post a small code example? || ill try to write a small sample to reproduce the issue || never mind cant reproduce anymore was probably doing something stupid :) || "";1;0;takewhile: dont unsubscribe downstream;"
2759;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;observable.using should use unsafesubscribe and enable eager disposal;see #2604 where it was discovered that  observable.using  used  subscribe  instead of  unsafesubscribe  which provoked a race condition leading to an illegalargumentexception from the merge operator.  this pr uses  unsafesubscribe  and adds an overload for  using  to optionally dispose of resources eagerly (just before completion or error). the use case for this is a _synchronous_ observable where a downstream operation wants to reuse a resource (but because the observable is synchronous the resource cannot get disposed till the downstream completes).  unit tests included.;;2604.0;observableusing should use unsafesubscribe and enable eager disposal;see #2604 where it was discovered that `observableusing` used `subscribe` instead of `unsafesubscribe` which provoked a race condition leading to an illegalargumentexception from the merge operatorthis pr uses `unsafesubscribe` and adds an overload for `using` to optionally dispose of resources eagerly (just before completion or error) the use case for this is a _synchronous_ observable where a downstream operation wants to reuse a resource (but because the observable is synchronous the resource cannot get disposed till the downstream completes)unit tests included;thanks @akarnokd ive made the change and squashed commits || replaced tabs with spaces added @experimental annotation to new overload and  typo in javadoc squashed commits || this seems reasonable to me i dont use using so trust the conversation youve had to address the necessary functionality reading through the other pr this does seem necessary and i agree that unsafesubscribe is appropriate for this  ||;operatormerge - rxringbuffer throws illegalstateexception again;with 105 im getting an `illegalstateexception` from `operatormerge` this is repeatable for me but involves a big input data set being processed in chunks using flatmap/onsubscribe so i cant give you a quick test case yet hopefully just this description is enough otherwise ill try and distill a test i think it is happening close to completion```javalangillegalstateexception: this instance has been unsubscribed and the queue is no longer usable        at rxinternalutilrxringbufferonnext(rxringbufferjava:346)        at rxinternaloperatorsoperatormerge$innersubscriberenqueue(operatormergejava:721)        at rxinternaloperatorsoperatormerge$innersubscriberemit(operatormergejava:698)        at rxinternaloperatorsoperatormerge$innersubscriberonnext(operatormergejava:586)        at rxinternaloperatorsoperatorsubscribeon$1$1$1onnext(operatorsubscribeonjava:76)        at rxinternaloperatorsoperatormerge$mergesubscriberhandlescalarsynchronousobservablewithrequestlimits(operatormergejava:280)        at rxinternaloperatorsoperatormerge$mergesubscriberhandlescalarsynchronousobservable(operatormergejava:243)        at rxinternaloperatorsoperatormerge$mergesubscriberonnext(operatormergejava:176)        at rxinternaloperatorsoperatormerge$mergesubscriberonnext(operatormergejava:120)        at rxinternaloperatorsoperatormap$1onnext(operatormapjava:55)        at rxinternaloperatorsoperatormerge$mergesubscriberhandlescalarsynchronousobservablewithrequestlimits(operatormergejava:280)        at rxinternaloperatorsoperatormerge$mergesubscriberhandlescalarsynchronousobservable(operatormergejava:243)        at rxinternaloperatorsoperatormerge$mergesubscriberonnext(operatormergejava:176)        at rxinternaloperatorsoperatormerge$mergesubscriberonnext(operatormergejava:120)        at rxinternaloperatorsoperatormap$1onnext(operatormapjava:55)        at rxinternaloperatorsnotificationliteaccept(notificationlitejava:150)        at rxinternaloperatorsoperatormerge$mergesubscriberdrainscalarvaluequeue(operatormergejava:396)        at rxinternaloperatorsoperatormerge$mergesubscriberdrainqueuesifneeded(operatormergejava:343)        at rxinternaloperatorsoperatormerge$mergesubscriberaccess$500(operatormergejava:120)        at rxinternaloperatorsoperatormerge$mergeproducerrequest(operatormergejava:549)        at rxsubscriberrequest(subscriberjava:130)        at rxinternaloperatorsoperatormerge$mergesubscriberdrainqueuesifneeded(operatormergejava:350)        at rxinternaloperatorsoperatormerge$mergesubscriberaccess$500(operatormergejava:120)        at rxinternaloperatorsoperatormerge$mergeproducerrequest(operatormergejava:549)        at rxsubscriberrequest(subscriberjava:130)        at rxinternaloperatorsoperatormerge$mergesubscriberdrainqueuesifneeded(operatormergejava:350)        at rxinternaloperatorsoperatormerge$mergesubscriberaccess$500(operatormergejava:120)        at rxinternaloperatorsoperatormerge$mergeproducerrequest(operatormergejava:549)        at rxinternaloperatorsoperatorsubscribeon$1$1$1$1$1call(operatorsubscribeonjava:94)        at rxinternalschedulersscheduledactionrun(scheduledactionjava:47)        at javautilconcurrentexecutors$runnableadaptercall(executorsjava:511)        at javautilconcurrentfuturetaskrun(futuretaskjava:266)        at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskaccess$201(scheduledthreadpoolexecutorjava:180)        at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:293)        at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1142)        at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:617)        at javalangthreadrun(threadjava:745)caused by: rxexceptionsonerrorthrowable$onnextvalue: onerror while emitting onnext value: augovamsaaistimestampedclass        at rxexceptionsonerrorthrowableaddvalueaslastcause(onerrorthrowablejava:98)        at rxinternaloperatorsoperatormap$1onnext(operatormapjava:58)         27 more```;did this happen with version 105?  || yes 105 || ive updated this issue no error is occuring in upstream the only error occuring is the illegalstateexception || _sigh_ i had hoped wed  this issue in 105  || not sure what fixes went through for that i see that  #1963 was closed but didnt notice record of the resolution (like a pr number) || in #2584 @akarnokd mentions that there is still a small window where this can happen i imagine hell enlighten us || the only fix would be not to throw but just exit we cant distinguish between an upstream ignoring unsubscription and an upstream pushing just after an unsubscription happened || so in my case i wouldnt expect what you describe because the operators should be consuming all of the input stream none of the observables should be interrupted by unsubscription before completion do you have an alternative theory?  || something is unsubscribing because otherwise the queue wouldnt be null || righto ill have a close look tomorrow || got it i think its an `operatormerge` bug the unsubscribe is originating from upstream due to the use of `using` here is a failing unit test for your debugging pleasure ``` java    @test(timeout  3000)    public void testmergeeagerunsubscribefromupstream() {        func0<object> resourcefactory  new func0<object>() {            @override            public object call() {                return new object()            }        }        func1<object observable<integer>> observablefactory  new func1<object observable<integer>>() {            @override            public observable<integer> call(object o) {                return observablerange(1 1000000)            }        }        action1<object> disposeaction  new action1<object>() {            @override            public void call(object t) {                // do nothing            }        }        observableusing(resourcefactory observablefactory disposeaction)                tolist()                flatmap(new func1<list<integer> observable<integer>>() {                    @override                    public observable<integer> call(list<integer> list) {                        return observablefrom(list)subscribeon(                                schedulerscomputation())                    }                })count()toblocking()single()    }``` || thanks this is a nasty one `using` does `subscribe()` on the source which then wraps the downstream into a `safesubscriber` which then cancels all work stared by merge immediately after tolist sends oncompleted() so either `using` should do `unsafesubscribe` or `tolist()` should break the chaining of subscribers via the subscriber constructorthis may affect other operators that do something async after an onerror and oncompleted``` javareturn new subscriber<t>(child) {  }```should become something like this:``` javaclass innersubscriber<t> extends subscriber<t> {    void requestmore(long n) {        request(n)    }    // }innersubscriber<t> s  new innersubscriber<t>()childsetproducer(s::requestmore)childadd(s)return s``` || `unsafesubscribe` in `using` sounds alright to me any reasons preventing us doing that? || ive rewritten `onsubscribeusing` for my applications use so this problem doesnt happen  i use `unsafesubscribe` and optional dispose on termination event (which i always set to true) in addition to unsubscription dispose though there is protection to ensure that disposal only occurs once this sorts the problem for me  if people are happy with this direction as opposed to handling things downstream instead ill put in a pr (and write the as yet unwritten unit tests)``` javapublic final class onsubscribeusing2<t resource> implements onsubscribe<t> {    private final func0<resource> resourcefactory    private final func1<? super resource ? extends observable<? extends t>> observablefactory    private final action1<? super resource> dispose    private final boolean disposeeagerly    public onsubscribeusing2(            func0<resource> resourcefactory            func1<? super resource ? extends observable<? extends t>> observablefactory            action1<? super resource> dispose boolean disposeeagerly) {        thisresourcefactory  resourcefactory        thisobservablefactory  observablefactory        thisdispose  dispose        thisdisposeeagerly  disposeeagerly    }    @override    public void call(subscriber<? super t> subscriber) {        try {            // create the resource            final resource resource  resourcefactorycall()            // create an action that disposes only once            final action0 disposeonceonly  createonceonlydisposeaction(resource)            // dispose on unsubscription            subscriberadd(subscriptionscreate(disposeonceonly))            // create the observable            final observable<? extends t> source  observablefactory            // create the observable                    call(resource)            final observable<? extends t> observable            // supplement with on termination disposal if requested            if (disposeeagerly)                observable  source                // dispose on completion or error                        doonterminate(disposeonceonly)            else                observable  source            try {                // start                observableunsafesubscribe(subscriber)            } catch (throwable e) {                throwable disposeerror  disposeeagerlyifrequested(disposeonceonly)                if (disposeerror ! null)                    subscriberonerror(new compositeexception(arraysaslist(e                            disposeerror)))                else                    // propagate error                    subscriberonerror(e)            }        } catch (throwable e) {            // then propagate error            subscriberonerror(e)        }    }    private throwable disposeeagerlyifrequested(final action0 disposeonceonly) {        if (disposeeagerly)            try {                disposeonceonlycall()                return null            } catch (throwable e) {                return e            }        else            return null    }    private action0 createonceonlydisposeaction(final resource resource) {        return new action0() {            final atomicboolean disposed  new atomicboolean(false)            @override            public void call() {                // only want dispose called once                if (disposedcompareandset(false true))                    disposecall(resource)            }        }    }}``` || im closing this as the related pr has been merged some days ago ||;1;0;using should use unsafesubscribe allow eager disposal to enable the synchronous case;
2760;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator: withlatestfrom;named after rxjs  for issue #405;;0;operator: withlatestfrom;named after rxjs for issue #405;:+1: thanks for doing this! || thanks @akarnokd  ||;;;;1;1;experimental annotation;
"2762;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;optimized isunsubscribed check;extracted isunsubscribed optimization from #2603.      benchmark                                   (size)   mode   samples          1.x        2603     r.s.computationschedulerperf.observeon           1  thrpt         5   104110.926  104707.286 r.s.computationschedulerperf.observeon          10  thrpt         5   100723.402  105825.148 r.s.computationschedulerperf.observeon         100  thrpt         5    24609.763   65571.461 r.s.computationschedulerperf.observeon        1000  thrpt         5     3212.434   13020.027 r.s.computationschedulerperf.observeon       10000  thrpt         5      955.002    1555.493   r.s.computationschedulerperf.observeon      100000  thrpt         5       96.628     160.218   r.s.computationschedulerperf.observeon     1000000  thrpt         5        9.508      16.559   r.s.computationschedulerperf.subscribeon         1  thrpt         5   114212.000  114485.516   r.s.computationschedulerperf.subscribeon        10  thrpt         5   112376.809  112270.024   r.s.computationschedulerperf.subscribeon       100  thrpt         5    88433.002  104240.739   r.s.computationschedulerperf.subscribeon      1000  thrpt         5    31503.640   64446.984   r.s.computationschedulerperf.subscribeon     10000  thrpt         5     3932.988    8200.048 r.s.computationschedulerperf.subscribeon    100000  thrpt         5      437.626    1439.069 r.s.computationschedulerperf.subscribeon   1000000  thrpt         5       43.104     146.385;;2603.0;optimized isunsubscribed check;extracted isunsubscribed optimization from #2603```benchmark                                   (size)   mode   samples          1x        2603    rscomputationschedulerperfobserveon           1  thrpt         5   104110926  104707286rscomputationschedulerperfobserveon          10  thrpt         5   100723402  105825148rscomputationschedulerperfobserveon         100  thrpt         5    24609763   65571461rscomputationschedulerperfobserveon        1000  thrpt         5     3212434   13020027rscomputationschedulerperfobserveon       10000  thrpt         5      955002    1555493  rscomputationschedulerperfobserveon      100000  thrpt         5       96628     160218  rscomputationschedulerperfobserveon     1000000  thrpt         5        9508      16559  rscomputationschedulerperfsubscribeon         1  thrpt         5   114212000  114485516  rscomputationschedulerperfsubscribeon        10  thrpt         5   112376809  112270024  rscomputationschedulerperfsubscribeon       100  thrpt         5    88433002  104240739  rscomputationschedulerperfsubscribeon      1000  thrpt         5    31503640   64446984  rscomputationschedulerperfsubscribeon     10000  thrpt         5     3932988    8200048rscomputationschedulerperfsubscribeon    100000  thrpt         5      437626    1439069rscomputationschedulerperfsubscribeon   1000000  thrpt         5       43104     146385```;nice improvement  ||;optimized observeon/subscribeon;""doing observeon/subscribeon on these is essentially the same operationbenchmark results: (i7 4770k java 18u31 windows 7 x64)```gradlew benchmarks """"-pjmh-f 1 -tu s -bm thrpt -wi 10 -i 10 -r 5 *computationschedulerperf*""""benchmark                        (size)    1x score  score error   pr  score  score errorcompschedulerperfobserveon           1   182479416    11686648  210536292     9760937  compschedulerperfobserveon          10   174911567    13659846  179245342    12725807  compschedulerperfobserveon         100    30997516      958587   27000106      623127  compschedulerperfobserveon        1000     6701672      314471    8623296      703255  compschedulerperfobserveon       10000      927207       98571     985409       32412  compschedulerperfobserveon      100000      111968        1176     110597        2883  compschedulerperfobserveon     1000000       11790        0195      11512        0146  compschedulerperfsubscribeon         1   202557014    13692298  204616231    11272351  compschedulerperfsubscribeon        10   180090498    14058995  190338591     1822349  compschedulerperfsubscribeon       100   113625737    32012148  114659399    50494246  compschedulerperfsubscribeon      1000    35600359     2975926   36856078     1770347  compschedulerperfsubscribeon     10000     4220548      311551    3942293      368052  compschedulerperfsubscribeon    100000      487187       18150     472594       22474  compschedulerperfsubscribeon   1000000       52191        0349      50250        0510  ```unfortunately the benchmark results were quite hectic even with more warmup and iteration id say the changes give +10% for the size  1 case but running the same code twice (observeon 1 subscribeon 1) gives inconsistent values i suspect the main cause is the gc"";new benchmark results (i7 920 java 18u31 windows 7 x64)```benchmark      (size)    score 1x            v2     v2 error   diff %   diff xobserveon           1    145464015   164994196     3694358    1343     113observeon          10    132737962   137155992     1012799     333     103observeon         100     25681480    45319683      514267    7647     176observeon        1000      3422822    12182024      460586   25591     355observeon       10000       498887     1582275       18479   21716     317observeon      100000        85889      155932        2873    8155     181observeon     1000000         8661       15959        1313    8426     184subscribeon         1    155442402   162559432     1046801     458     104subscribeon        10    144919758   152370842      753133     514     105subscribeon       100    107249189   138655111      836759    2928     129subscribeon      1000     27860564    57548020    11424426   10656     206subscribeon     10000      3481585     9069788      229033   16051     260subscribeon    100000       362142      980154       28928   17065     270subscribeon   1000000        35890       92740        1033   15840     258```there are 2x-3x througput improvements ive verified there arent any exceptions thrown and the last emitted value is always the size - 1 (all values should have been delivered) note that these improvements are due to overhead reduction with `blackholeconsumecpu(5)` the numbers look like this:```benchmark      (size)           1x    1x error           v2     v2 errorobserveon           1    140296417      441165   160466648    18522034observeon          10    133460788     2365310   135523349     1877668observeon         100     25786907     1948696    47624460      925317observeon        1000      3559582       81327    11185990      988573observeon       10000       552615       93469     1370051      321379observeon      100000        79281        2550      141401        4252observeon     1000000         8083        0922       13593        1866subscribeon         1    155594824     1630359   159551161     2583546subscribeon        10    142827468     2120922   146452153     1323202subscribeon       100     93820703    21969555   102171399    51531245subscribeon      1000     23061551     2348392    37658325     3900619subscribeon     10000      2798071      144547     5128935      331227subscribeon    100000       278345       11796      523751       50789subscribeon   1000000        28944        1060       54256        1252```most likely the improvement comes from the change to isunusubscribed reading a volatile field instead of always entering the unbiasable synchronized blocks || @akarnokd great stuff ill try it out early next week and report some numbers :) || now on: i7 4770k java 18u31 windows 7 x64```benchmark      (size)    1x score  score error        score  score errorobserveon           1   182479416    11686648   206216641     4097849  observeon          10   174911567    13659846   183143285     6557560  observeon         100    30997516      958587    71018915     2110252  observeon        1000     6701672      314471    13325539     1940749  observeon       10000      927207       98571     1648631      250874  observeon      100000      111968        1176      200704        7900  observeon     1000000       11790        0195       19285        0630  subscribeon         1   202557014    13692298   205876054     9574248  subscribeon        10   180090498    14058995   194964365     7460966  subscribeon       100   113625737    32012148   149761195   104683280  subscribeon      1000    35600359     2975926    87861668    17543179  subscribeon     10000     4220548      311551    13208973     2794952  subscribeon    100000      487187       18150     1695555      226512  subscribeon   1000000       52191        0349      180335       30122``` || i see these improvements  still reviewing the code:```benchmark                                   (size)   mode   samples          1x        2603    rscomputationschedulerperfobserveon           1  thrpt         5   104110926  115707286rscomputationschedulerperfobserveon          10  thrpt         5   100723402  105825148rscomputationschedulerperfobserveon         100  thrpt         5    24609763   65571461rscomputationschedulerperfobserveon        1000  thrpt         5     3212434   13020027rscomputationschedulerperfobserveon        2000  thrpt         5     2057133    rscomputationschedulerperfobserveon        3000  thrpt         5     1807644    rscomputationschedulerperfobserveon        4000  thrpt         5     2000223    rscomputationschedulerperfobserveon       10000  thrpt         5      955002    1555493  rscomputationschedulerperfobserveon      100000  thrpt         5       96628     160218  rscomputationschedulerperfobserveon     1000000  thrpt         5        9508      16559  rscomputationschedulerperfsubscribeon         1  thrpt         5   114212000  118885516  rscomputationschedulerperfsubscribeon        10  thrpt         5   112376809  112270024  rscomputationschedulerperfsubscribeon       100  thrpt         5    88433002  104240739  rscomputationschedulerperfsubscribeon      1000  thrpt         5    31503640   64446984  rscomputationschedulerperfsubscribeon      2000  thrpt         5    16292135    rscomputationschedulerperfsubscribeon      3000  thrpt         5    11372297    rscomputationschedulerperfsubscribeon      4000  thrpt         5     9927774    rscomputationschedulerperfsubscribeon     10000  thrpt         5     3932988    8200048rscomputationschedulerperfsubscribeon    100000  thrpt         5      437626    1439069rscomputationschedulerperfsubscribeon   1000000  thrpt         5       43104     146385``` || @benjchristensen what is the verdict on this pr? || i think its only the discussion about exposing `eventloopscheduler` publicly which i dont think should happen  || the optimization is built upon the direct access which is not possible if the class is package private i could create a schedulersschedulesingle(scheduler action0) that calls schedule direct and since they are both in the same package no need to expose eventloopscheduler || so why dont you just move it to the rxinternal packages as you suggested before? || can you please rebase this and move that file to rxinternal so it is not made part of the public api? || okay ||;1;0;optimized isunsubscribed check;"
"2767;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;optimized scalar observeon/subscribeon;redone #2603.  run on i7 920  2.6ghz  windows 7 x64  jdk 1.8u31      benchmark      (size)       this   score error       1.x   score error observeon           1  160377 408     3091 205  140913 081     7097 415 observeon          10  132990 049     1477 661  125288 149    14304 259 observeon         100   43701 203     2342 570   43840 921      944 682 observeon        1000   11603 952     2377 205   11400 340     1400 628 observeon        2000    6769 716      220 476    6853 283       71 276 observeon        3000    4753 876      326 497    4741 108      120 612 observeon        4000    3616 782      212 285    3632 433      433 754 observeon       10000    1544 141       28 796    1548 504       61 419 observeon      100000     149 573       14 974     150 924        8 331 observeon     1000000      14 909        2 079      13 658        7 702 subscribeon         1  160639 801    16463 799  156911 862     2463 637 subscribeon        10  148883 172     6885 684  151514 397     9425 348 subscribeon       100  133756 358     3329 421  133327 933     3479 124 subscribeon      1000   56411 785    22525 962   52902 999    19948 305 subscribeon      2000   35471 110    12240 514   34272 374    16515 454 subscribeon      3000   25868 564     2755 244   26291 293     2435 165 subscribeon      4000   20453 512     2996 777   19598 400     4643 195 subscribeon     10000    8817 797      465 195    5389 428      272 784 subscribeon    100000     958 665       22 157     900 036      320 547 subscribeon   1000000      91 606        2 462      91 396        3 407      note that since the tests create a lot of garbage  some perf numbers have quite some error margin: some appear to be faster with this pr while others appear to be slower  even if they are not affected by the changes.;;2603.0;optimized scalar observeon/subscribeon;redone #2603run on i7 920 26ghz windows 7 x64 jdk 18u31```benchmark      (size)       this   score error       1x   score errorobserveon           1  160377408     3091205  140913081     7097415observeon          10  132990049     1477661  125288149    14304259observeon         100   43701203     2342570   43840921      944682observeon        1000   11603952     2377205   11400340     1400628observeon        2000    6769716      220476    6853283       71276observeon        3000    4753876      326497    4741108      120612observeon        4000    3616782      212285    3632433      433754observeon       10000    1544141       28796    1548504       61419observeon      100000     149573       14974     150924        8331observeon     1000000      14909        2079      13658        7702subscribeon         1  160639801    16463799  156911862     2463637subscribeon        10  148883172     6885684  151514397     9425348subscribeon       100  133756358     3329421  133327933     3479124subscribeon      1000   56411785    22525962   52902999    19948305subscribeon      2000   35471110    12240514   34272374    16515454subscribeon      3000   25868564     2755244   26291293     2435165subscribeon      4000   20453512     2996777   19598400     4643195subscribeon     10000    8817797      465195    5389428      272784subscribeon    100000     958665       22157     900036      320547subscribeon   1000000      91606        2462      91396        3407```note that since the tests create a lot of garbage some perf numbers have quite some error margin: some appear to be faster with this pr while others appear to be slower even if they are not affected by the changes;am i reading it correctly that this should really only benefit this case? >```benchmark      (size)       this   score error       1x   score errorobserveon           1  160377408     3091205  140913081     7097415``` || yes it optimizes for the scalar observing of a value i assume this is a common enough case to warrant an optimized code path || this is exactly the case i need :) || code looks good all internal changes thanks @akarnokd  ||;optimized observeon/subscribeon;""doing observeon/subscribeon on these is essentially the same operationbenchmark results: (i7 4770k java 18u31 windows 7 x64)```gradlew benchmarks """"-pjmh-f 1 -tu s -bm thrpt -wi 10 -i 10 -r 5 *computationschedulerperf*""""benchmark                        (size)    1x score  score error   pr  score  score errorcompschedulerperfobserveon           1   182479416    11686648  210536292     9760937  compschedulerperfobserveon          10   174911567    13659846  179245342    12725807  compschedulerperfobserveon         100    30997516      958587   27000106      623127  compschedulerperfobserveon        1000     6701672      314471    8623296      703255  compschedulerperfobserveon       10000      927207       98571     985409       32412  compschedulerperfobserveon      100000      111968        1176     110597        2883  compschedulerperfobserveon     1000000       11790        0195      11512        0146  compschedulerperfsubscribeon         1   202557014    13692298  204616231    11272351  compschedulerperfsubscribeon        10   180090498    14058995  190338591     1822349  compschedulerperfsubscribeon       100   113625737    32012148  114659399    50494246  compschedulerperfsubscribeon      1000    35600359     2975926   36856078     1770347  compschedulerperfsubscribeon     10000     4220548      311551    3942293      368052  compschedulerperfsubscribeon    100000      487187       18150     472594       22474  compschedulerperfsubscribeon   1000000       52191        0349      50250        0510  ```unfortunately the benchmark results were quite hectic even with more warmup and iteration id say the changes give +10% for the size  1 case but running the same code twice (observeon 1 subscribeon 1) gives inconsistent values i suspect the main cause is the gc"";new benchmark results (i7 920 java 18u31 windows 7 x64)```benchmark      (size)    score 1x            v2     v2 error   diff %   diff xobserveon           1    145464015   164994196     3694358    1343     113observeon          10    132737962   137155992     1012799     333     103observeon         100     25681480    45319683      514267    7647     176observeon        1000      3422822    12182024      460586   25591     355observeon       10000       498887     1582275       18479   21716     317observeon      100000        85889      155932        2873    8155     181observeon     1000000         8661       15959        1313    8426     184subscribeon         1    155442402   162559432     1046801     458     104subscribeon        10    144919758   152370842      753133     514     105subscribeon       100    107249189   138655111      836759    2928     129subscribeon      1000     27860564    57548020    11424426   10656     206subscribeon     10000      3481585     9069788      229033   16051     260subscribeon    100000       362142      980154       28928   17065     270subscribeon   1000000        35890       92740        1033   15840     258```there are 2x-3x througput improvements ive verified there arent any exceptions thrown and the last emitted value is always the size - 1 (all values should have been delivered) note that these improvements are due to overhead reduction with `blackholeconsumecpu(5)` the numbers look like this:```benchmark      (size)           1x    1x error           v2     v2 errorobserveon           1    140296417      441165   160466648    18522034observeon          10    133460788     2365310   135523349     1877668observeon         100     25786907     1948696    47624460      925317observeon        1000      3559582       81327    11185990      988573observeon       10000       552615       93469     1370051      321379observeon      100000        79281        2550      141401        4252observeon     1000000         8083        0922       13593        1866subscribeon         1    155594824     1630359   159551161     2583546subscribeon        10    142827468     2120922   146452153     1323202subscribeon       100     93820703    21969555   102171399    51531245subscribeon      1000     23061551     2348392    37658325     3900619subscribeon     10000      2798071      144547     5128935      331227subscribeon    100000       278345       11796      523751       50789subscribeon   1000000        28944        1060       54256        1252```most likely the improvement comes from the change to isunusubscribed reading a volatile field instead of always entering the unbiasable synchronized blocks || @akarnokd great stuff ill try it out early next week and report some numbers :) || now on: i7 4770k java 18u31 windows 7 x64```benchmark      (size)    1x score  score error        score  score errorobserveon           1   182479416    11686648   206216641     4097849  observeon          10   174911567    13659846   183143285     6557560  observeon         100    30997516      958587    71018915     2110252  observeon        1000     6701672      314471    13325539     1940749  observeon       10000      927207       98571     1648631      250874  observeon      100000      111968        1176      200704        7900  observeon     1000000       11790        0195       19285        0630  subscribeon         1   202557014    13692298   205876054     9574248  subscribeon        10   180090498    14058995   194964365     7460966  subscribeon       100   113625737    32012148   149761195   104683280  subscribeon      1000    35600359     2975926    87861668    17543179  subscribeon     10000     4220548      311551    13208973     2794952  subscribeon    100000      487187       18150     1695555      226512  subscribeon   1000000       52191        0349      180335       30122``` || i see these improvements  still reviewing the code:```benchmark                                   (size)   mode   samples          1x        2603    rscomputationschedulerperfobserveon           1  thrpt         5   104110926  115707286rscomputationschedulerperfobserveon          10  thrpt         5   100723402  105825148rscomputationschedulerperfobserveon         100  thrpt         5    24609763   65571461rscomputationschedulerperfobserveon        1000  thrpt         5     3212434   13020027rscomputationschedulerperfobserveon        2000  thrpt         5     2057133    rscomputationschedulerperfobserveon        3000  thrpt         5     1807644    rscomputationschedulerperfobserveon        4000  thrpt         5     2000223    rscomputationschedulerperfobserveon       10000  thrpt         5      955002    1555493  rscomputationschedulerperfobserveon      100000  thrpt         5       96628     160218  rscomputationschedulerperfobserveon     1000000  thrpt         5        9508      16559  rscomputationschedulerperfsubscribeon         1  thrpt         5   114212000  118885516  rscomputationschedulerperfsubscribeon        10  thrpt         5   112376809  112270024  rscomputationschedulerperfsubscribeon       100  thrpt         5    88433002  104240739  rscomputationschedulerperfsubscribeon      1000  thrpt         5    31503640   64446984  rscomputationschedulerperfsubscribeon      2000  thrpt         5    16292135    rscomputationschedulerperfsubscribeon      3000  thrpt         5    11372297    rscomputationschedulerperfsubscribeon      4000  thrpt         5     9927774    rscomputationschedulerperfsubscribeon     10000  thrpt         5     3932988    8200048rscomputationschedulerperfsubscribeon    100000  thrpt         5      437626    1439069rscomputationschedulerperfsubscribeon   1000000  thrpt         5       43104     146385``` || @benjchristensen what is the verdict on this pr? || i think its only the discussion about exposing `eventloopscheduler` publicly which i dont think should happen  || the optimization is built upon the direct access which is not possible if the class is package private i could create a schedulersschedulesingle(scheduler action0) that calls schedule direct and since they are both in the same package no need to expose eventloopscheduler || so why dont you just move it to the rxinternal packages as you suggested before? || can you please rebase this and move that file to rxinternal so it is not made part of the public api? || okay ||;1;0;optimized scalar observeon/subscribeon;"
2776;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;issue-2764: add new operator onbackpressuredrop(action1 ondrop);;;0;issue-2764: add new operator onbackpressuredrop(action1 ondrop);;added super to generic type t || i will manually add experimental to it after merging || thanks @stevenzwu  || thanks looks like i missed a lot of details :) ||;;;;1;1;issue-2764: add new operator onbackpressuredrop(action1 ondrop);
2804;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;observeon throughput enhancements;squashed commits of #2773.  ---  further optimizations to  observeon . - using spscarrayqueue directly in observeon instead of  ringbuffer  to avoid the synchronization block - split tracking structure to serial (subscriptionlist) and timed (compositesubscription) in  eventloopsscheduler  which improves the sequential scheduling performance because a completing task s subscription will be most likely the first item in the underlying linkedlist.  benchmark: (i7 920  window 7 x64  java 1.8u31  5x1s warmup  5x5s iteration)      benchmark      (size)         1.x    1.x error      this pr   this error observeon           1  162326 012     2458 085   166536 559     3154 174 observeon          10  132471 205     1857 434   142517 407     3734 424 ++ observeon         100   43282 527     2145 910   112238 179     2270 103 ++ observeon        1000   11779 482      173 370    25726 564      309 193 ++ observeon        2000    6756 211       89 196    12123 276      276 470 ++ observeon        3000    4736 893      253 796     9342 673      263 667 ++ observeon        4000    3661 874       51 359     7346 015      123 049 ++ observeon       10000    1519 282      108 503     1546 547       21 885 observeon      100000     151 193        2 569      156 160        1 974 observeon     1000000      15 373        1 310       15 660        0 153 subscribeon         1  161290 037     2867 882   164952 259      797 408 subscribeon        10  151842 821     2448 734   147906 491     4373 682 subscribeon       100  136418 065     1773 558   136889 052     2362 203 subscribeon      1000   58389 066     4559 030    59482 225     1372 692 subscribeon      2000   34089 152     9318 205    36581 203     1264 100 subscribeon      3000   26712 331     1265 442    26519 320     1319 293 subscribeon      4000   20118 326     2018 439    20163 395      839 709 subscribeon     10000    8914 213      677 164     9059 934      200 158 subscribeon    100000     958 038       43 349      965 663       60 708 subscribeon   1000000      91 849        2 148       92 706        1 202      notes: - at  size = 1   the throughput varies in a +/- 3000 range on each run  and since the changes don t touch the scalar optimization  there is no real improvement there. - at  size = 10.000  my system reached either the cache capacity or the os scheduler s time resolution so there no improvement there on. - at  size = 100.000  and  size = 1.000.000  the throughput doubles if i introduce some extra delay (i.e.  via sleep(1) or some extra work). - the benchmark generates a lot of garbage due to boxing: switching to a constant emitter increases the throughput  subscribeon(1.000.000)  from 91 to 136.   since it conflicts with #2772 anyway  this is pr is to let others verify the optimizations actually work on other oses  because on my windows  i sometimes get significant variance in the throughput during iterations. increased iteration time may be required as well.;;2772.0;observeon throughput enhancements;squashed commits of #2773---further optimizations to `observeon`- using spscarrayqueue directly in observeon instead of `ringbuffer` to avoid the synchronization block- split tracking structure to serial (subscriptionlist) and timed (compositesubscription) in `eventloopsscheduler` which improves the sequential scheduling performance because a completing tasks subscription will be most likely the first item in the underlying linkedlistbenchmark: (i7 920 window 7 x64 java 18u31 5x1s warmup 5x5s iteration)```benchmark      (size)         1x    1x error      this pr   this errorobserveon           1  162326012     2458085   166536559     3154174observeon          10  132471205     1857434   142517407     3734424 ++observeon         100   43282527     2145910   112238179     2270103 ++observeon        1000   11779482      173370    25726564      309193 ++observeon        2000    6756211       89196    12123276      276470 ++observeon        3000    4736893      253796     9342673      263667 ++observeon        4000    3661874       51359     7346015      123049 ++observeon       10000    1519282      108503     1546547       21885observeon      100000     151193        2569      156160        1974observeon     1000000      15373        1310       15660        0153subscribeon         1  161290037     2867882   164952259      797408subscribeon        10  151842821     2448734   147906491     4373682subscribeon       100  136418065     1773558   136889052     2362203subscribeon      1000   58389066     4559030    59482225     1372692subscribeon      2000   34089152     9318205    36581203     1264100subscribeon      3000   26712331     1265442    26519320     1319293subscribeon      4000   20118326     2018439    20163395      839709subscribeon     10000    8914213      677164     9059934      200158subscribeon    100000     958038       43349      965663       60708subscribeon   1000000      91849        2148       92706        1202```notes:- at `size  1` the throughput varies in a +/- 3000 range on each run and since the changes dont touch the scalar optimization there is no real improvement there- at `size  10000` my system reached either the cache capacity or the os schedulers time resolution so there no improvement there on- at `size  100000` and `size  1000000` the throughput doubles if i introduce some extra delay (ie via sleep(1) or some extra work)- the benchmark generates a lot of garbage due to boxing: switching to a constant emitter increases the throughput `subscribeon(1000000)` from 91 to 136 since it conflicts with #2772 anyway this is pr is to let others verify the optimizations actually work on other oses because on my windows i sometimes get significant variance in the throughput during iterations increased iteration time may be required as well;;helper methods to schedule tasks (non-)interruptibly on an;executorservice replaces #2761by default io() and newthread() schedules interruptible tasks computation() schedules non-interruptible tasks;i think this looks good  but im trying to decouple in my head the api changes versus functional related to interrupt as those are complicated and nuancedbefore we proceed with this id like to have a clear description somewhere about our logic and thinking around interruption additionally lets mark the api additions as experimental || okay || im closing this lets revisit the problem later ||;1;0;observeon throughput enhancements;
2804;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;observeon throughput enhancements;squashed commits of #2773.  ---  further optimizations to  observeon . - using spscarrayqueue directly in observeon instead of  ringbuffer  to avoid the synchronization block - split tracking structure to serial (subscriptionlist) and timed (compositesubscription) in  eventloopsscheduler  which improves the sequential scheduling performance because a completing task s subscription will be most likely the first item in the underlying linkedlist.  benchmark: (i7 920  window 7 x64  java 1.8u31  5x1s warmup  5x5s iteration)      benchmark      (size)         1.x    1.x error      this pr   this error observeon           1  162326 012     2458 085   166536 559     3154 174 observeon          10  132471 205     1857 434   142517 407     3734 424 ++ observeon         100   43282 527     2145 910   112238 179     2270 103 ++ observeon        1000   11779 482      173 370    25726 564      309 193 ++ observeon        2000    6756 211       89 196    12123 276      276 470 ++ observeon        3000    4736 893      253 796     9342 673      263 667 ++ observeon        4000    3661 874       51 359     7346 015      123 049 ++ observeon       10000    1519 282      108 503     1546 547       21 885 observeon      100000     151 193        2 569      156 160        1 974 observeon     1000000      15 373        1 310       15 660        0 153 subscribeon         1  161290 037     2867 882   164952 259      797 408 subscribeon        10  151842 821     2448 734   147906 491     4373 682 subscribeon       100  136418 065     1773 558   136889 052     2362 203 subscribeon      1000   58389 066     4559 030    59482 225     1372 692 subscribeon      2000   34089 152     9318 205    36581 203     1264 100 subscribeon      3000   26712 331     1265 442    26519 320     1319 293 subscribeon      4000   20118 326     2018 439    20163 395      839 709 subscribeon     10000    8914 213      677 164     9059 934      200 158 subscribeon    100000     958 038       43 349      965 663       60 708 subscribeon   1000000      91 849        2 148       92 706        1 202      notes: - at  size = 1   the throughput varies in a +/- 3000 range on each run  and since the changes don t touch the scalar optimization  there is no real improvement there. - at  size = 10.000  my system reached either the cache capacity or the os scheduler s time resolution so there no improvement there on. - at  size = 100.000  and  size = 1.000.000  the throughput doubles if i introduce some extra delay (i.e.  via sleep(1) or some extra work). - the benchmark generates a lot of garbage due to boxing: switching to a constant emitter increases the throughput  subscribeon(1.000.000)  from 91 to 136.   since it conflicts with #2772 anyway  this is pr is to let others verify the optimizations actually work on other oses  because on my windows  i sometimes get significant variance in the throughput during iterations. increased iteration time may be required as well.;;2773.0;observeon throughput enhancements;squashed commits of #2773---further optimizations to `observeon`- using spscarrayqueue directly in observeon instead of `ringbuffer` to avoid the synchronization block- split tracking structure to serial (subscriptionlist) and timed (compositesubscription) in `eventloopsscheduler` which improves the sequential scheduling performance because a completing tasks subscription will be most likely the first item in the underlying linkedlistbenchmark: (i7 920 window 7 x64 java 18u31 5x1s warmup 5x5s iteration)```benchmark      (size)         1x    1x error      this pr   this errorobserveon           1  162326012     2458085   166536559     3154174observeon          10  132471205     1857434   142517407     3734424 ++observeon         100   43282527     2145910   112238179     2270103 ++observeon        1000   11779482      173370    25726564      309193 ++observeon        2000    6756211       89196    12123276      276470 ++observeon        3000    4736893      253796     9342673      263667 ++observeon        4000    3661874       51359     7346015      123049 ++observeon       10000    1519282      108503     1546547       21885observeon      100000     151193        2569      156160        1974observeon     1000000      15373        1310       15660        0153subscribeon         1  161290037     2867882   164952259      797408subscribeon        10  151842821     2448734   147906491     4373682subscribeon       100  136418065     1773558   136889052     2362203subscribeon      1000   58389066     4559030    59482225     1372692subscribeon      2000   34089152     9318205    36581203     1264100subscribeon      3000   26712331     1265442    26519320     1319293subscribeon      4000   20118326     2018439    20163395      839709subscribeon     10000    8914213      677164     9059934      200158subscribeon    100000     958038       43349      965663       60708subscribeon   1000000      91849        2148       92706        1202```notes:- at `size  1` the throughput varies in a +/- 3000 range on each run and since the changes dont touch the scalar optimization there is no real improvement there- at `size  10000` my system reached either the cache capacity or the os schedulers time resolution so there no improvement there on- at `size  100000` and `size  1000000` the throughput doubles if i introduce some extra delay (ie via sleep(1) or some extra work)- the benchmark generates a lot of garbage due to boxing: switching to a constant emitter increases the throughput `subscribeon(1000000)` from 91 to 136 since it conflicts with #2772 anyway this is pr is to let others verify the optimizations actually work on other oses because on my windows i sometimes get significant variance in the throughput during iterations increased iteration time may be required as well;;observeon performance improvements;further optimizations to `observeon`- using spscarrayqueue directly in observeon instead of `ringbuffer` to avoid the synchronization block- split tracking structure to serial (subscriptionlist) and timed (compositesubscription) in `eventloopsscheduler` which improves the sequential scheduling performance because a completing tasks subscription will be most likely the first item in the underlying linkedlistbenchmark: (i7 920 window 7 x64 java 18u31 5x1s warmup 5x5s iteration)```benchmark      (size)         1x    1x error      this pr   this errorobserveon           1  162326012     2458085   166536559     3154174observeon          10  132471205     1857434   142517407     3734424 ++observeon         100   43282527     2145910   112238179     2270103 ++observeon        1000   11779482      173370    25726564      309193 ++observeon        2000    6756211       89196    12123276      276470 ++observeon        3000    4736893      253796     9342673      263667 ++observeon        4000    3661874       51359     7346015      123049 ++observeon       10000    1519282      108503     1546547       21885observeon      100000     151193        2569      156160        1974observeon     1000000      15373        1310       15660        0153subscribeon         1  161290037     2867882   164952259      797408subscribeon        10  151842821     2448734   147906491     4373682subscribeon       100  136418065     1773558   136889052     2362203subscribeon      1000   58389066     4559030    59482225     1372692subscribeon      2000   34089152     9318205    36581203     1264100subscribeon      3000   26712331     1265442    26519320     1319293subscribeon      4000   20118326     2018439    20163395      839709subscribeon     10000    8914213      677164     9059934      200158subscribeon    100000     958038       43349      965663       60708subscribeon   1000000      91849        2148       92706        1202```notes:- at `size  1` the throughput varies in a +/- 3000 range on each run and since the changes dont touch the scalar optimization there is no real improvement there- at `size  10000` my system reached either the cache capacity or the os schedulers time resolution so there no improvement there on- at `size  100000` and `size  1000000` the throughput doubles if i introduce some extra delay (ie via sleep(1) or some extra work)- the benchmark generates a lot of garbage due to boxing: switching to a constant emitter increases the throughput `subscribeon(1000000)` from 91 to 136 since it conflicts with #2772 anyway this is pr is to let others verify the optimizations actually work on other oses because on my windows i sometimes get significant variance in the throughput during iterations increased iteration time may be required as well;benchmark (i7 4770k windows 7 x64 java 18u31) pr up to 366598a```benchmark      (size)         1x      1x error      this pr    this errorobserveon           1    204372986    45147750    207462343     3348429observeon          10    170321219    30519528    180349729     9635029observeon         100     66150820     3911887    151773980     8819016observeon        1000     11387782     3620545     28427477     8108015observeon        2000      7180268      899369     15044075     2107491observeon        3000      4458529     1949745     10050448     1945057observeon        4000      3294942     2865810      4627753      369396observeon       10000      1509448      646732      3331416      302650observeon      100000       184213       21344       385208        4621observeon     1000000        18447        1594        21572        0221subscribeon         1    198566731    26191145    204882731     7505171subscribeon        10    194194868     7907757    193459202     8645835subscribeon       100    160472849    75535431    147738528    61057919subscribeon      1000     69123783    51116790     88955619    25329057subscribeon      2000     41765423    58779642     54281820    25307480subscribeon      3000     42094519    14935575     46571429     3136216subscribeon      4000     28593237    31337648     35484209     5793749subscribeon     10000     11492688     7818150     13295895     5687375subscribeon    100000       911157      311834       973503       33258subscribeon   1000000       169743       37696       176479       22568```strangely adding an innocent isunsubscribed check breaks 4 tests dont know why yet || switching to juclock in subscriptionlist benefits the observeon because its spinning behavior (less likely to park/unpark a thread which may take 3ms on windows) but unfortunately it introduces higher variance on small subscribeon runs```benchmark      (size)         1x      1x error      this pr    this errorobserveon           1    204372986    45147750    202173732    12320313observeon          10    170321219    30519528    182154095    11144205observeon         100     66150820     3911887    153120079    10437195observeon        1000     11387782     3620545     29951053     3853397observeon        2000      7180268      899369     13866119     4136655observeon        3000      4458529     1949745      9109964     2767763observeon        4000      3294942     2865810      7439672      781102observeon       10000      1509448      646732      1893761      165063observeon      100000       184213       21344       221382        7028observeon     1000000        18447        1594        43000        0351subscribeon         1    198566731    26191145    204402609     4919448subscribeon        10    194194868     7907757    183619836    28797890subscribeon       100    160472849    75535431    147244447   101925905subscribeon      1000     69123783    51116790     84392086    55782068subscribeon      2000     41765423    58779642     60341991    17596950subscribeon      3000     42094519    14935575     42439368    11841639subscribeon      4000     28593237    31337648     35660124     5625456subscribeon     10000     11492688     7818150     13021675     1460180subscribeon    100000       911157      311834      1664599      332131subscribeon   1000000       169743       37696       180759       21844``` || these are the results if the range is replaced by a [value repeater](      (size)         1x      1x error    1x no box       error    this no box     errorobserveon           1    204372986    45147750    188819849    15431568    181595983    14377740observeon          10    170321219    30519528    177593605    12877222    175087705    18256765observeon         100     66150820     3911887     68652045     1711296    144814588    20151322observeon        1000     11387782     3620545     14779159      989993     19994914     2982607observeon        2000      7180268      899369      8075593      929669      9877035      560081observeon        3000      4458529     1949745      5235137      463936      6393597      605021observeon        4000      3294942     2865810      4017062      247366      5045878      133408observeon       10000      1509448      646732      1644436      301704      3714585      270400observeon      100000       184213       21344       185625        7409       235961       18194observeon     1000000        18447        1594        20052        1631        24297        0232subscribeon         1    198566731    26191145    190542030    87491106    194069237    13380697subscribeon        10    194194868     7907757    192794548    30258019    183716766    22495251subscribeon       100    160472849    75535431    148739487    47300117    154242613    63197068subscribeon      1000     69123783    51116790     98292952    34497158     90132783    54405704subscribeon      2000     41765423    58779642     72655350     9218318     72559922    14591547subscribeon      3000     42094519    14935575     55371153    11954736     53789237    12727973subscribeon      4000     28593237    31337648     46864543     3127864     45835097     4896779subscribeon     10000     11492688     7818150     19685490     9422445     18831519     7730286subscribeon    100000       911157      311834      2225610      154474      2201344      318462subscribeon   1000000       169743       37696       257446        7753       257803       11236```note that size  1 doesnt run the optimized scalar scheduling code || do you mind rebasing this so we dont have the development path in the log? || i see significant performance testing on my machine:```1xbenchmark                                         (size)   mode   samples        score  score error    unitsrooperatorobserveonperfobserveoncomputation         1  thrpt         5   113223051     9007330    ops/srooperatorobserveonperfobserveoncomputation      1000  thrpt         5    13108671      740532    ops/srooperatorobserveonperfobserveoncomputation   1000000  thrpt         5       15414        0988    ops/srooperatorobserveonperfobserveonimmediate           1  thrpt         5 10813751080   943281316    ops/srooperatorobserveonperfobserveonimmediate        1000  thrpt         5   227083165     9356767    ops/srooperatorobserveonperfobserveonimmediate     1000000  thrpt         5      193273       21516    ops/srooperatorobserveonperfobserveonnewthread           1  thrpt         5    16307144     1100723    ops/srooperatorobserveonperfobserveonnewthread        1000  thrpt         5     8365615      235292    ops/srooperatorobserveonperfobserveonnewthread     1000000  thrpt         5       16573        0892    ops/sthis prbenchmark                                         (size)   mode   samples        score  score error    unitsrooperatorobserveonperfobserveoncomputation         1  thrpt         5   113905358    32165659    ops/srooperatorobserveonperfobserveoncomputation      1000  thrpt         5    28618423      507627    ops/srooperatorobserveonperfobserveoncomputation   1000000  thrpt         5       32166        2736    ops/srooperatorobserveonperfobserveonimmediate           1  thrpt         5  8402487179   456209469    ops/srooperatorobserveonperfobserveonimmediate        1000  thrpt         5   217228990     9486298    ops/srooperatorobserveonperfobserveonimmediate     1000000  thrpt         5      198274       13425    ops/srooperatorobserveonperfobserveonnewthread           1  thrpt         5    16996020     2524557    ops/srooperatorobserveonperfobserveonnewthread        1000  thrpt         5    11612989      487775    ops/srooperatorobserveonperfobserveonnewthread     1000000  thrpt         5       34498        1914    ops/s``` || sure || @akarnokd great work on all those enhancements! ||;1;0;observeon throughput enhancements;
"2807;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;corrected all java interfaces declarations;just little java syntax fix for interfaces  i checked all interfaces in rxjava.  @benjchristensen i can add and configure  checkstyle  gradle plugin for rxjava if you don t mind  mm?;;0;corrected all java interfaces declarations;just little java syntax fix for interfacesi checked all interfaces in rxjava@benjchristensen i can add and configure `checkstyle` gradle plugin for rxjava if you dont mind mm?;""i like the changes however we dont have a style guideline because we dont want to enforce one particular coding style on contributors: the functionality is first the style is secondary || @akarnokd greatabout code style: project is actively developing and code style can be problem in future i think it will be good to have small amount of `checkstyle` rules integrated with build processyou can ping me if youll decide to do it with my help || i agree on the necessity of `checkstyle` but may be its already not the right time to remove `public` from interface methods see:  its pretty distant future but why do additional work that sums up to zero in this future || @colriot as i see they wont break source compatibility and `empty` modifier in interface will be `public abstract` as before if you would like to add implementation to interface youll have to write `default` modifier or `private` also there is 100% no need in declaring `static interface` its like writing `extends object` in each class    || @artem-zinnatullin yeah completely agree on `static` i was talking about `public` only speaking of compatibility what youve said is true but i personally prefer either to hide all the implicits if they are unambigous and ubiquitous or to write them explicitly if there are other """"theoretical"""" options like `private` obviously all that has sense if the library is targeting java 8 or 9  || > i can add and configure checkstyle gradle plugini have a general aversion to `checkstyle` as it is generally just unnecessary purely subjective opinions imposed upon people and causing otherwise fine code to fail a build in the 2+ years of this project taking pull requests style has rarely been a topic of discussion or issue what legit problems that affect behavior or safety will checkstyle solve? as for the changes in these pull request a brief review seems like they are okay but ill spend more time when i have it to review in depth  || +1 for ben || `what legit problems that affect behavior or safety will checkstyle solve?` none of them just code stylei got your point okayps not a fan of airbnb just want to quote their [""""nerds"""" post]( shot 2015-03-07 at 16 48 46]( i cant say that it applicable to rxjava code style is good in most of files  "";;;;1;1;corrected all java interfaces declarations;"
2817;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;fix for non-deterministic: testonbackpressuredropwithaction;it is possible the synchronized block inside rxringbuffer blocks out the firehose thread long enough that there will be enough requests cumulating up and no values have to be dropped. the change increases the taken value count and should decrease the likelihood of such no-drop situation.;;0;fix for non-deterministic: testonbackpressuredropwithaction;it is possible the synchronized block inside rxringbuffer blocks out the firehose thread long enough that there will be enough requests cumulating up and no values have to be dropped the change increases the taken value count and should decrease the likelihood of such no-drop situation;;;;;1;1;added more to take to decrease the likelyhood that nothing is dropped;
2818;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;small fix for the getvalue javadoc in asyncsubject and behaviorsubject;;;0;small fix for the getvalue javadoc in asyncsubject and behaviorsubject;;;;;;1;1;small fix in the sentences of getvalue;
2820;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;backpressure for window(size);changes to the  window(size)  operator to respect the backpressure on its _outer_ observable: asking for 1 window will request  size  values from upstream.   backpressure is ignored on the inner observable for now  partially because the  bufferuntilsubscriber  doesn t support it  partially because coordinating the inner requests with the outer requests needs more thoughts. the problem is that the outer has to request at least 1 element from upstream in order to open the window  but the inner subscriber may not want that single element just yet or would request more than the remaining window size and it would trigger new windows whose value it can t receive but would overflow the next window s observers.   window(size  skip)  is not changed as i need to think about it more.;;0;backpressure for window(size);changes to the `window(size)` operator to respect the backpressure on its _outer_ observable: asking for 1 window will request `size` values from upstream backpressure is ignored on the inner observable for now partially because the `bufferuntilsubscriber` doesnt support it partially because coordinating the inner requests with the outer requests needs more thoughts the problem is that the outer has to request at least 1 element from upstream in order to open the window but the inner subscriber may not want that single element just yet or would request more than the remaining window size and it would trigger new windows whose value it cant receive but would overflow the next windows observers`window(size skip)` is not changed as i need to think about it more;could you change the javadoc for this operator  in observablejava as well:  currently reads:backpressure support:this operator does not support backpressure as it uses count to control data flow || sure || isnt supporting backpressure on the inner effectively the same as onbackpressurebuffer? || yes bufferuntilsubscriber would need to be smartened to do proper backpressure || what has happened recently causing tests to fail? i dont see any recent commits at should do it ideas? || i have no idea i thought it was my commit for testonbackpressuredropwithaction but reverting that didnt fix the master my best guess is that something changed in the travis-ci environment perhaps we dont get 3gb memory anymore (on windows the tests take up to 1gb of memory) || so to confirm merging this would be adding back pressure on the outer but still need us to come back later and fix the inner? || yes ||;;;;1;1;changed javadoc regarding backpressure;
2825;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fixed javadoc for observable.repeat() method;removed wrong link inside of javadoc for observable.repeat() method;;0; javadoc for observablerepeat() method;removed wrong link inside of javadoc for observablerepeat() method;travis failed on this trivial change without giving any hint on why re-running it doesnt seem to help || weve  the main build but this still fails and i dont get why could you rebase this to the current master? || @akarnokd done || ;;;;1;1; javadoc for observablerepeat() method;
2831;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;testonbackpressuredropwithaction restored original test count;not for merge. diagnosing travis build failure.;;0;testonbackpressuredropwithaction restored original test count;not for merge diagnosing travis build failure;;;;;1;1;checking if the test change is the main cause or not;
2837;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;fixed a non-deterministic test and a few scheduler leaks.;;;0; a non-deterministic test and a few scheduler leaks;;;;;;1;1; a non-deterministic test and a few scheduler leaks;
2838;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix typo in onsubscribe interface s javadoc;;;0;fix typo in onsubscribe interfaces javadoc;;merged thank you ||;;;;1;1;fix typo in onsubscribe interfaces javadoc;
2862;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;cleanup warnings in test source;made changes to test source to avoid or suppress these warnings: - raw types  - unused imports - unused variables;;0;cleanup warnings in test source;made changes to test source to avoid or suppress these warnings:- raw types - unused imports- unused variables;looks good ;;;;1;1;warnings cleanup in test source;
2880;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;use singleton reduction functions in count and countlong;every call to observable.count() and countlong() instantiated a new func2 which i have now made a singleton in the interests of minimizing gc pressure.   can anyone in the know confirm for me that there is gc benefit from this one because i assume a sophisticated enough compiler could replace the new func2 call with a singleton during its optimizations.  if this one is worthwhile then there are heaps more of these in  observable.java  and possibly elsewhere.;;0;use singleton reduction functions in count and countlong;every call to observablecount() and countlong() instantiated a new func2 which i have now made a singleton in the interests of minimizing gc pressure can anyone in the know confirm for me that there is gc benefit from this one because i assume a sophisticated enough compiler could replace the new func2 call with a singleton during its optimizationsif this one is worthwhile then there are heaps more of these in `observablejava` and possibly elsewhere;since we are java 6+ we cant assume a bunch of optimizations happen so whats left is manual optimization/inlining || id instead do this directly with a long counting subscriber and for int id map it to min(count integermax_value) at the end saving the duplications || i guess this is an opportunity to decide what overflow behaviour we desire i see three options:1  be consistent with integer/long overflow behaviour2 return integermax_value/longmax_value on overflow3 throw an error on overflowmy preference is 3 || i think both `2` and `3` will be a breaking change so its not acceptable `1` is not a big deal since its consistent with java which all java users should be familiar with it || @davidmoten thoughts? || im happy to maintain the existing overflow behaviour so its not abreaking change given that i think the pr could go in as ison tue 21 apr 2015 18:57 shixiong zhu notifications@githubcom wrote:> @davidmoten  thoughts?> > > reply to this email directly or view it on github>  || ;;;;1;1;use singleton reduction functions in count and countlong;
2883;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;proposal: standardized subject state-peeking methods.;this pr modifies the  subject  class to host the union of the state-peeking methods of the various  subject  implementations and fixes the inconsistent behavior of  replaysubject.getvalues(t) .  the changes enable the  serializedsubject  to relay such state-peeking method calls into the wrapped subject and allows future  subject  wrappers to do the same (#2458).;;2458.0;proposal: standardized subject state-peeking methods;this pr modifies the `subject` class to host the union of the state-peeking methods of the various `subject` implementations and fixes the inconsistent behavior of `replaysubjectgetvalues(t)`the changes enable the `serializedsubject` to relay such state-peeking method calls into the wrapped subject and allows future `subject` wrappers to do the same (#2458);seems to make sense the additions to `subject` all should be non-breaking || due to the experimental marking of these im being a little less stringent in discussing the addition to public apis but it seems to me that the precedent set on the behaviorsubject shows the value of these methods additionally subjects are the stateful side-effecting types and these methods seem to make sense for them ||;lifting into a subject;mildly interesting idea to see if there would be any interest```public class subject<t r> extends observable<r> implements observer<t> {        public <x> subject<x r> lifthead(final operator<? extends t ? super x> op) {  }    public <x> subject<t x> lifttail(final operator<? extends x ? super r> op) {  }    @override    public <x> subject<t x> lift(final operator<? extends x ? super r> op) { return lifttail(op) }}```;what do you want to achieve with this change? || up till now all the apis that want to delegate part of the observable change chain to another piece of code has had to pass in the head as an argument  with these methods the delegate could return a subject the represents the some segment of the chain without any argumentsfor example `retrywhen()` takes a notification handler `func1<observable<exception> observable<?>>`  with this it would have been possible for `retrywhen` to take a notification handler `func0<subject<exception ?>` || if i understand correctly a chain of subject<integer string> -> subject<string date> -> subject<date long> i can hand out each to different parties and observe them at any point? || yes  the `subject` returned could be reused to `subscribe()` different source observables  the `subject` would just be an capsulation of some computation without defining where the data comes from or where it is going to || the encapsulation of computation sounds like the transformer with observablecompose  || do you still want to pursue this? || punting to 20 for bikeshedding || see #3975 || im closing this as the pr implementing the proposed feature was not really endorsed by the op after all if you have further input on the issue dont hesitate to reopen this issue or post a new one ||;1;0;proposal: standardized subject state-peeking methods;
2901;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operators tolist and tosortedlist now support backpressure;added support for backpressure in  tolist  and  tosortedlist : they emit their buffered content only when downstream actually requested it.  few other notes: - added overload to  tosortedlist  taking a  initialcapacity  argument which should help reduce the number of times the buffer needs to be resized. - the func2 parameter of  tosortedlist  is now wrapped once per operator instead of once per subscriber. - using non-final list buffers which are set to null on completion to not hold onto the buffer. -  tosortedlist now returns a modifiable  arraylist : since it is a handoff procedure  there is no value in forcing a non-modification constraint on the emitted list (similar to  tolist  even before this pr).;;0;operators tolist and tosortedlist now support backpressure;added support for backpressure in `tolist` and `tosortedlist`: they emit their buffered content only when downstream actually requested itfew other notes:- added overload to `tosortedlist` taking a `initialcapacity` argument which should help reduce the number of times the buffer needs to be resized- the func2 parameter of `tosortedlist` is now wrapped once per operator instead of once per subscriber- using non-final list buffers which are set to null on completion to not hold onto the buffer- `tosortedlist`now returns a modifiable `arraylist`: since it is a handoff procedure there is no value in forcing a non-modification constraint on the emitted list (similar to `tolist` even before this pr);cool ill be using that `initialcapacity` and `singledelayedproducer` will be useful too || good changes ||;;;;1;1;operators tolist and tosortedlist now support backpressure;
2902;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;prevent exceptionstest from hanging when testing stack overflow;on my i5 laptop  exceptionstest.teststackoverflowisthrow  hangs. this pr changes the test so that it confirms that significant stack depth occurs and in another test ensures that the fatal  stackoverflowerror  is thrown by  subscribe  when it occurs in  onnext .  i also removed some unused code from the original test and some extra subscriptions that didn t seem to serve a particular function.;;0;prevent exceptionstest from hanging when testing stack overflow;on my i5 laptop `exceptionstestteststackoverflowisthrow` hangs this pr changes the test so that it confirms that significant stack depth occurs and in another test ensures that the fatal `stackoverflowerror` is thrown  subscribe` when it occurs in `onnext`i also removed some unused code from the original test and some extra subscriptions that didnt seem to serve a particular function;looks good ;;;;1;1;stack overflow test can hang build simplify the tests and ensure dont hang;
2905;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;use singleton operators where we can;to reduce gc pressure use singleton  operator s for  observable.single    distinct    distinctuntilchanged     onbackpressurebuffer     isempty .;;0;use singleton operators where we can;to reduce gc pressure use singleton `operator`s for `observablesingle` `distinct` `distinctuntilchanged`  `onbackpressurebuffer`  `isempty`;could you please do `never()` as well? || updated javadoc and renamed `create` methods to `instance` added singleton for `never` as well || unrelated ci failure ill open an issue for it || looks good! ||;;;;1;1;reduce gc pressure by using singleton operators for single distinct distinctuntilchanged onbackpressurebuffer isempty;
2907;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;fixed schedule race and task retention with executorscheduler.;fixes a race condition with the timed schedule (first potentially overwriting the result of the untimed schedule in mas) and a scheduled task retention problem due to not tracking those.;;0; schedule race and task retention with executorscheduler;fixes a race condition with the timed schedule (first potentially overwriting the result of the untimed schedule in mas) and a scheduled task retention problem due to not tracking those;ive discovered another retention problem and updated the pr to fix it as well || thanks for the explanation || @akarnokd @benjchristensen  is this ? i still see the following exception on 1014 below is the stack from our services log:error [2015-09-23 20 00640] commycompanymobiledropwizardexceptionabstractexceptionmapper: error handling request: ! javautilconcurrentrejectedexecutionexception: task rxschedulersexecutorscheduler$executorschedulerworker@5e731de2 rejected from javautilconcurrentthreadpoolexecutor@500df7b6[running pool size  25 active threads  5 queued tasks  25 completed tasks  6741988]! at javautilconcurrentthreadpoolexecutor$abortpolicyrejectedexecution(threadpoolexecutorjava:2047) ~[na:180_51]! at javautilconcurrentthreadpoolexecutorreject(threadpoolexecutorjava:823) ~[na:180_51]! at javautilconcurrentthreadpoolexecutorexecute(threadpoolexecutorjava:1369) ~[na:180_51]! at comgooglecommonutilconcurrentmoreexecutors$listeningdecoratorexecute(moreexecutorsjava:550) ~[push-token-server-0099-shadedjar:0099]! at rxschedulersexecutorscheduler$executorschedulerworkerschedule(executorschedulerjava:78) ~[push-token-server-0099-shadedjar:0099]! at rxinternaloperatorsoperatorsubscribeon$1onnext(operatorsubscribeonjava:57) ~[push-token-server-0099-shadedjar:0099]! at rxinternaloperatorsoperatorsubscribeon$1onnext(operatorsubscribeonjava:43) ~[push-token-server-0099-shadedjar:0099]! at rxinternalutilscalarsynchronousobservable$1call(scalarsynchronousobservablejava:46) ~[push-token-server-0099-shadedjar:0099]! at rxinternalutilscalarsynchronousobservable$1call(scalarsynchronousobservablejava:35) ~[push-token-server-0099-shadedjar:0099]! at rxobservable$2call(observablejava:162) ~[push-token-server-0099-shadedjar:0099]! at rxobservable$2call(observablejava:154) ~[push-token-server-0099-shadedjar:0099]! at rxobservable$2call(observablejava:162) ~[push-token-server-0099-shadedjar:0099]! at rxobservable$2call(observablejava:154) ~[push-token-server-0099-shadedjar:0099]! at rxobservable$2call(observablejava:162) ~[push-token-server-0099-shadedjar:0099]! at rxobservable$2call(observablejava:154) ~[push-token-server-0099-shadedjar:0099]! at rxobservable$2call(observablejava:162) ~[push-token-server-0099-shadedjar:0099]! at rxobservable$2call(observablejava:154) ~[push-token-server-0099-shadedjar:0099]! at rxobservablesubscribe(observablejava:7804) ~[push-token-server-0099-shadedjar:0099]! at rxobservablesubscribe(observablejava:7772) ~[push-token-server-0099-shadedjar:0099]! at rxobservablesblockingobservableblockforsingle(blockingobservablejava:432) ~[push-token-server-0099-shadedjar:0099]! at rxobservablesblockingobservablefirst(blockingobservablejava:159) ~[push-token-server-0099-shadedjar:0099]! at commycompanymobilecommonconcurrencyobservableutilaslist(observableutiljava:27) ~[push-token-server-0099-shadedjar:0099]! at commycompanymobiletokenpushdevicetokenresourcegettokenbydevicetoken(pushdevicetokenresourcejava:261) ~[push-token-server-0099-shadedjar:0099]! at sunreflectgeneratedmethodaccessor23invoke(unknown source) ~[na:na]! at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43) ~[na:180_51]! at javalangreflectmethodinvoke(methodjava:497) ~[na:180_51]! at comsunjerseyspicontainerjavamethodinvokerfactory$1invoke(javamethodinvokerfactoryjava:60) ~[push-token-server-0099-shadedjar:0099]! at comsunjerseyserverimplmodelmethoddispatchabstractresourcemethoddispatchprovider$responseoutinvoker_dispatch(abstractresourcemethoddispatchproviderjava:205) ~[push-token-server-0099-shadedjar:0099]! at comsunjerseyserverimplmodelmethoddispatchresourcejavamethoddispatcherdispatch(resourcejavamethoddispatcherjava:75) ~[push-token-server-0099-shadedjar:0099]! at comcodahalemetricsjerseyinstrumentedresourcemethoddispatchprovider$exceptionmeteredrequestdispatcherdispatch(instrumentedresourcemethoddispatchproviderjava:69) ~[push-token-server-0099-shadedjar:0099]! at iodropwizardjerseyguavaoptionalresourcemethoddispatchadapter$optionalrequestdispatcherdispatch(optionalresourcemethoddispatchadapterjava:37) ~[push-token-server-0099-shadedjar:0099]! at comsunjerseyserverimplurirules ~[push-token-server-0099-shadedjar:0099]! at comsunjerseyserverimplurirulesrighthandpathruleaccept(righthandpathrulejava:147) ~[push-token-server-0099-shadedjar:0099]! at comsunjerseyserverimplurirulesresourceobjectruleaccept(resourceobjectrulejava:100) ~[push-token-server-0099-shadedjar:0099]! at comsunjerseyserverimplurirulesrighthandpathruleaccept(righthandpathrulejava:147) ~[push-token-server-0099-shadedjar:0099]! at comsunjerseyserverimplurirulesrootresourceclassesruleaccept(rootresourceclassesrulejava:84) ~[push-token-server-0099-shadedjar:0099]! at comsunjerseyserverimplapplicationwebapplicationimpl_handlerequest(webapplicationimpljava:1542) [push-token-server-0099-shadedjar:0099]! at comsunjerseyserverimplapplicationwebapplicationimpl_handlerequest(webapplicationimpljava:1473) [push-token-server-0099-shadedjar:0099]! at comsunjerseyserverimplapplicationwebapplicationimplhandlerequest(webapplicationimpljava:1419) [push-token-server-0099-shadedjar:0099]! at comsunjerseyserverimplapplicationwebapplicationimplhandlerequest(webapplicationimpljava:1409) [push-token-server-0099-shadedjar:0099]! at comsunjerseyspicontainerservletwebcomponentservice(webcomponentjava:409) [push-token-server-0099-shadedjar:0099]! at comsunjerseyspicontainerservletservletcontainerservice(servletcontainerjava:540) [push-token-server-0099-shadedjar:0099]! at comsunjerseyspicontainerservletservletcontainerservice(servletcontainerjava:715) [push-token-server-0099-shadedjar:0099]! at javaxservlet [push-token-server-0099-shadedjar:0099]! at iodropwizardjettynonblockingservletholderhandle(nonblockingservletholderjava:49) [push-token-server-0099-shadedjar:0099]! at orgeclipsejettyservletservlethandler$cachedchaindofilter(servlethandlerjava:1515) [push-token-server-0099-shadedjar:0099]! at orgeclipsejettyservletsuseragentfilterdofilter(useragentfilterjava:83) [push-token-server-0099-shadedjar:0099]! at orgeclipsejettyservletsgzipfilterdofilter(gzipfilterjava:348) [push-token-server-0099-shadedjar:0099]! at iodropwizardjettybidigzipfilterdofilter(bidigzipfilterjava:127) [push-token-server-0099-shadedjar:0099]! at orgeclipsejettyservletservlethandler$cachedchaindofilter(servlethandlerjava:1486) [push-token-server-0099-shadedjar:0099]! at iodropwizardservletsthreadnamefilterdofilter(threadnamefilterjava:29) [push-token-server-0099-shadedjar:0099]! at orgeclipsejettyservletservlethandler$cachedchaindofilter(servlethandlerjava:1486) [push-token-server-0099-shadedjar:0099]! at iodropwizardjerseyfilterallowedmethodsfilterhandle(allowedmethodsfilterjava:44) [push-token-server-0099-shadedjar:0099]! at iodropwizardjerseyfilterallowedmethodsfilterdofilter(allowedmethodsfilterjava:39) [push-token-server-0099-shadedjar:0099]! at orgeclipsejettyservletservlethandler$cachedchaindofilter(servlethandlerjava:1486) [push-token-server-0099-shadedjar:0099]! at orgeclipsejettyservletservlethandlerdohandle(servlethandlerjava:519) [push-token-server-0099-shadedjar:0099]! at orgeclipsejettyserverhandlercontexthandlerdohandle(contexthandlerjava:1097) [push-token-server-0099-shadedjar:0099]! at orgeclipsejettyservletservlethandlerdoscope(servlethandlerjava:448) [push-token-server-0099-shadedjar:0099]! at orgeclipsejettyserverhandlercontexthandlerdoscope(contexthandlerjava:1031) [push-token-server-0099-shadedjar:0099]! at orgeclipsejettyserverhandlerscopedhandlerhandle(scopedhandlerjava:136) [push-token-server-0099-shadedjar:0099]! at orgeclipsejettyserverhandlerhandlerwrapperhandle(handlerwrapperjava:97) [push-token-server-0099-shadedjar:0099]! at comcodahalemetricsjetty9instrumentedhandlerhandle(instrumentedhandlerjava:175) [push-token-server-0099-shadedjar:0099]! at iodropwizardjettyroutinghandlerhandle(routinghandlerjava:51) [push-token-server-0099-shadedjar:0099]! at orgeclipsejettyserverhandlerhandlerwrapperhandle(handlerwrapperjava:97) [push-token-server-0099-shadedjar:0099]! at orgeclipsejettyserverhandlerrequestloghandlerhandle(requestloghandlerjava:92) [push-token-server-0099-shadedjar:0099]! at orgeclipsejettyserverhandlerhandlerwrapperhandle(handlerwrapperjava:97) [push-token-server-0099-shadedjar:0099]! at orgeclipsejettyserverhandlerstatisticshandlerhandle(statisticshandlerjava:162) [push-token-server-0099-shadedjar:0099]! at orgeclipsejettyserverhandlerhandlerwrapperhandle(handlerwrapperjava:97) [push-token-server-0099-shadedjar:0099]! at orgeclipsejettyserverserverhandle(serverjava:446) [push-token-server-0099-shadedjar:0099]! at orgeclipsejettyserver [push-token-server-0099-shadedjar:0099]! at orgeclipsejettyserver [push-token-server-0099-shadedjar:0099]! at orgeclipsejettyioabstractconnection$readcallbackrun(abstractconnectionjava:358) [push-token-server-0099-shadedjar:0099]! at orgeclipsejettyutilthreadqueuedthreadpoolrunjob(queuedthreadpooljava:601) [push-token-server-0099-shadedjar:0099]! at orgeclipsejettyutilthreadqueuedthreadpool$3run(queuedthreadpooljava:532) [push-token-server-0099-shadedjar:0099]! at javalangthreadrun(threadjava:745) [na:180_51] || @zhiyanshao you seem to have a different problem than what this pr fixes either your pool has been shutdown in the middle or you are running with a bounded internal queue that gets overflown || @akarnokd  thank you for your reply do you know under what circumstances the pool will be shutdown in the middle and how i can tell if i am running with a bounded internal queue? are these two scenarios by design and can be fixed in my code? || it appears you are using some google threadpool-helper classes look where the executor or executorservice is configured in your project ||;;;;1;1; schedule race and task retention with executorscheduler;
2914;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;optimization - use operatortakelastone for takelast(1);this is an optimization for  takelast  when called with parameter 1. using  operatortakelast  carries unnecessary overhead for the  takelast(1)  case and a decent throughput improvement (x2) for streams of 100 elements or more is seen in the benchmarks below.   takelast(1)  is used by the following operators which will also demonstrate a throughput improvement: -  last    lastordefault  -  reduce  -  collect  -  count    countlong   benchmarks comparing using the new  operatortakelastone  and  operatortakelast :      benchmark                                                        mode   samples        score  score error    units r.o.operatortakelastoneperf.takelastoneusingtakelastone_few     thrpt         5  2235516.141   129091.019    ops/s r.o.operatortakelastoneperf.takelastoneusingtakelastone_many    thrpt         5      103.980        9.233    ops/s r.o.operatortakelastoneperf.takelastoneusingtakelastone_some    thrpt         5   984689.481    48560.897    ops/s r.o.operatortakelastoneperf.takelastoneusingtakelast_few        thrpt         5  2187421.223    93550.379    ops/s r.o.operatortakelastoneperf.takelastoneusingtakelast_many       thrpt         5       54.575        2.054    ops/s r.o.operatortakelastoneperf.takelastoneusingtakelast_some       thrpt         5   466892.497     9267.405    ops/s;;0;optimization - use operatortakelastone for takelast(1);this is an optimization for `takelast` when called with parameter 1 using `operatortakelast` carries unnecessary overhead for the `takelast(1)` case and a decent throughput improvement (x2) for streams of 100 elements or more is seen in the benchmarks below`takelast(1)` is used by the following operators which will also demonstrate a throughput improvement:- `last` `lastordefault`- `reduce`- `collect`- `count` `countlong`benchmarks comparing using the new `operatortakelastone` and `operatortakelast`:```benchmark                                                        mode   samples        score  score error    unitsrooperatortakelastoneperftakelastoneusingtakelastone_few     thrpt         5  2235516141   129091019    ops/srooperatortakelastoneperftakelastoneusingtakelastone_many    thrpt         5      103980        9233    ops/srooperatortakelastoneperftakelastoneusingtakelastone_some    thrpt         5   984689481    48560897    ops/srooperatortakelastoneperftakelastoneusingtakelast_few        thrpt         5  2187421223    93550379    ops/srooperatortakelastoneperftakelastoneusingtakelast_many       thrpt         5       54575        2054    ops/srooperatortakelastoneperftakelastoneusingtakelast_some       thrpt         5   466892497     9267405    ops/s```;thanks @akarnokd for the review i appreciate the lessons!ive incorporated the changes except for the `ignoreelements` optimization which ill leave for another pri wrote this up before you submitted the `singledelayedproducer` in #2901 but had spotted its usefulness its very close to being reusable here just have to handle the empty stream case which is allowed  takelast` i submitted this anyway because it helps me learn thanksup to you of course if you want to merge this or wait for #2901 to be merged then get another pr that uses a modified `singledelayedproducer` (might have its name changed if it allows single or none)updated benchmarks (thats a nifty trick using params):```benchmark                                                  (size)   mode   samples        score  score error    unitsrooperatortakelastoneperftakelastoneusingtakelast            5  thrpt         5  2233452067    81630798    ops/srooperatortakelastoneperftakelastoneusingtakelast          100  thrpt         5   444353711   224920714    ops/srooperatortakelastoneperftakelastoneusingtakelast      1000000  thrpt         5       56947        2630    ops/srooperatortakelastoneperftakelastoneusingtakelastone         5  thrpt         5  2372577831    76820729    ops/srooperatortakelastoneperftakelastoneusingtakelastone       100  thrpt         5  1012528600    75674064    ops/srooperatortakelastoneperftakelastoneusingtakelastone   1000000  thrpt         5      108284        4965    ops/s``` || thanks @akarnokd  ive added your suggestions:- shortcut to completion when empty- test for `takelast(0)` ||  ;;;;1;1;add operatortakelastone;
2915;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;observable.ignoreelements - optimize;as suggested by @akarnokd  instead of  filter(alwaysfalse)  use a custom operator and a singleton instance of it.  also snuck in the removal of an unused import from  operatortakelastonetest.java .;;0;observableignoreelements - optimize;as suggested by @akarnokd instead of `filter(alwaysfalse)` use a custom operator and a singleton instance of italso snuck in the removal of an unused import from `operatortakelastonetestjava`;ah thanks now i understand the difference between those two approaches to connecting the subscribers simple really i might add that bit of info to the javadoc on the subscriber constructor i used in another pr i was thinking of adding  bit more doco to subscriber anyway because it gets stepped through a lot when you debug and its a bit terse (confusing variable names and stuff) || changes made including a unit test of the request problem (doesnt hang by the way just terminates early without processing all upstream) || great ;;;;1;1;improve perf of operatorignoreelements;
2923;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;onbackpressurelatest: non-blocking version of the toblocking().latest() operator.;this is essentially the pair of the  onbackpressuredrop . while  onbackpressuredrop  emits the first value requested and then drops the rest   onbackpressurelatest  drops values but the latest and emits that when requested. one can also think of this operator as a sample with backpressure.  one mentionable property is that since it holds onto the very last value  downstream has to request at least one to receive  oncompleted() .;;0;onbackpressurelatest: non-blocking version of the toblocking()latest() operator;this is essentially the pair of the `onbackpressuredrop` while `onbackpressuredrop` emits the first value requested and then drops the rest `onbackpressurelatest` drops values but the latest and emits that when requested one can also think of this operator as a sample with backpressureone mentionable property is that since it holds onto the very last value downstream has to request at least one to receive `oncompleted()`;i like this feature been wanting something like this for a while  ||;;;;1;1;non-blocking version of the toblocking()latest() operator;
"2928;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;merge and mergemaxconcurrent unified and rewritten;i ve rewritten  merge  and  mergemaxconcurrent  together from scratch. - added experimental  maxconcurrent  overloads to the array-merge and the mergedelayerror - fixed  operatormapnotification  beause it disregarded backpressure on its terminal emissions. - while debugging some merge test failures  i ve encountered a bug in operatorpublish with the same underlying logical error (see comment) and fixed it here. - accidentally introduced a few tabs  therefore  i went in and replaced all tabs with spaces. - i ve changed  operatormergetest.shouldnotcompleteiftherearependingscalarsynchronousemissionswhenthelastinnersubscribercompletes  because it is legal to get oncompleted without any request.;;0;merge and mergemaxconcurrent unified and rewritten;ive rewritten `merge` and `mergemaxconcurrent` together from scratch- added experimental `maxconcurrent` overloads to the array-merge and the mergedelayerror-  `operatormapnotification` beause it disregarded backpressure on its terminal emissions- while debugging some merge test failures ive encountered a bug in operatorpublish with the same underlying logical error (see comment) and fixed it here- accidentally introduced a few tabs therefore i went in and replaced all tabs with spaces- ive changed `operatormergetestshouldnotcompleteiftherearependingscalarsynchronousemissionswhenthelastinnersubscribercompletes` because it is legal to get oncompleted without any request;""i havent benchmarked this because my current old laptop where i wrote this pr is prone to overheating || im stoked youve taken this on merge has been a thorn in our side for a while ive only had a cursory look so far looks great but can you break up the `emitloop` method its super long (>200 lines)? || somebody go buy this man a laptop (how about you netflix)!on 1 may 2015 at 06:04 david karnok notifications@githubcom wrote:> i havent benchmarked this because my current old laptop where i wrote> this pr is prone to overheating> > > reply to this email directly or view it on github>  || ive updated this pr and added safeguard against onnext before request() and made sure the queues are released if the stream is unsubscribed before completing normally || here is a benchmark comparison on an intel celeron 1005m @ 19ghz windows 7 x64 java 8u45 (this is not the overheating laptop of mine)![mergeperf]( seems the single-shot overhead is greater in general but note that the baseline merge has bugs especially with scalar sources: such merges may terminate much earlier and not deliver all values```benchmark                    (size)      master     master err           pr     pr errorflatmapintpassthruasync             1  498695426   259249193   412488433   257250017flatmapintpassthruasync        1000       628490      325556      826485     1030174flatmapintpassthruasync     1000000         0372        0144        0845        0266flatmapintpassthrusync            1   2413250773   340583441  1380370980   268957879flatmapintpassthrusync         1000     16731496     5159943    16374699     6581767flatmapintpassthrusync      1000000        17016        4609       15445        4289flatmaptwonestedsync              1   1809099547   314275657  1074829348   214620187flatmaptwonestedsync           1000      8908864     1665210    12105668     4147721flatmaptwonestedsync        1000000         8553        4492       13661        3763merge1syncstreamofn               1   2073223271   624706196  1340920111   321874624merge1syncstreamofn            1000     15583667     5675705    24295187      741011merge1syncstreamofn         1000000        16086        3177       30617       14407mergenasyncstreamsofn             1     53251280     1821052    77537033    63762352mergenasyncstreamsofn          1000         6258        2367        7633        4073mergensyncstreamsof1              1   1814390194   250905669  1221128575   523755940mergensyncstreamsof1            100    221860250    69297969   149696874    13363647mergensyncstreamsof1           1000     20576165     2416898    16998408     2414499mergensyncstreamsofn              1   2076685785   558323104  1382133163   931994488mergensyncstreamsofn           1000        16458        3175       28144       15014mergetwoasyncstreamsofn           1     45570075     8864806    62306327    23355026mergetwoasyncstreamsofn        1000      1086413      260172     3059881      554938onestreamofnthatmergesin1         1   1894495101   373234431  1430870599   883644992onestreamofnthatmergesin1      1000     18433963     6341333    18367707    12874644onestreamofnthatmergesin1   1000000        17750        2938       17197        8896``` || @davidmoten  cant really do because i need to return two values: the remaining request and how many main elements to request || ok no worrieson sat 2 may 2015 23:34 david karnok notifications@githubcom wrote:> @davidmoten  cant really do because i> need to return two values: the remaining request and how many main elements> to request> > > reply to this email directly or view it on github>  || i7 4790 windows 7 x64 java 8u45:( tried my best to close the gap with size  1 cases but couldnt figure out why it is that slower: even if i remove the emitter loop because of the trivial case it is still  and building a snapshot for a few days of final testing before releasei still question the subscribe/unsafesubscribe thing above but can discuss that further || > i still question the subscribe/unsafesubscribe thing above but can discuss that furtherthat was a simple oversight it was already  before you merged this || "";;;;1;1;merge fully rewritten and other related optimizations;"
2948;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;more assertions for testsubscriber;additional asserts for testsubscriber and the option to specify the initial request via a constructor.;;0;more assertions for testsubscriber;additional asserts for testsubscriber and the option to specify the initial request via a constructor;;;;;1;1;more assertions for testsubscriber;
2963;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;set of standard producers and updated queue implementations with some;platform-safe variants.;;0;set of standard producers and updated queue implementations with some;platform-safe variants;this looks like good additions if i understand correctly there are two things happening here:1) abstract producers to simplify building observables/operators2) new impls of queues that use atomics rather than unsafe so they work on android google app engine etc?the only thing i would like changed before merging is to include correct attribution to where the code comes from || sure ill add the link these arent all the android-compatible variants so i plan to do a separate pr on the remaining and updating all platform-checked places || > i plan to do a separate pr on the remaining and updating all platform-checked placesthen should the producers and queues be separated into different prs? || the default constructor of `queuedproducer` uses `spsclinkedqueue` so at least they need to be in the same pr but `mpsclinkedqueue` can be added after if you wish || since these dont change any existing code and are all internal lets merge and move forward || okay ||;;;;1;1;added links to the source of the new queue classes;
2966;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;the usual anally-retentive javadoc edits.;;;0;the usual anally-retentive javadoc edits;;looks good ;;;;1;1;the usual anally-retentive javadoc edits;
2969;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator cache() now supports backpressure;i ve removed the controversial features and made the backing cachedobservable internal.  related issue #1483.;;1483.0;operator cache() now supports backpressure;ive removed the controversial features and made the backing cachedobservable internalrelated issue #1483;does it really need to be returning a new type of observable?  it seems the methods `isconnected()` `hasobservers()` and `cachedeventcount()` are only used by the unit tests || yes otherwise one would need ugly reflection magic to get inside the state of this observable || i checked out the branch and took a shot at making it an onsubscribe function again || cache had originally more functionality ie the ability to terminate it manually like a disconnect but was downwoted i forgot about the `tocached()` methods which are just relics and ill update this protherwise i dont really see why i shouldnt extend observable especially if one day there will be a real need to support disconnection of cache() || ive rebased it and im going to merge this if there has concern about it being implemented as a observable a pr can always be submitted with the suggested changes ||;backpressure: cache;the `cache` operator should support downstream backpressure it should `request(longmax_value)` up but be capable of correctly responding to downstream (similar to `from(iterable)`)this will mean we either have to stop using `replaysubject` or be able to handle it with `replaysubject` in the mixthe idea here is that once data is cached it should behave as an `iterable` therefore the cache really should behave like `onbackpressurebuffer`;see #2969 || cache officially supports backpressure from relelase 1014 ||;1;0;cache now supports backpressure;
"2970;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;deprecated onbackpressureblock;see #2799 for reasons to deprecate.;;2799.0;deprecated onbackpressureblock;see #2799 for reasons to deprecate;;onbackpressureblock() causes hangs;""given this piece of code:```        observablecreate(subscriber -> {            long counter  0            while (counter++ < longmax_value) {                systemoutprintln(""""onnext("""" + counter + """")"""")                if (!subscriberisunsubscribed()) {                    subscriberonnext(counter)                } else {                    break                }                systemoutprintln(""""subscribeonnext("""" + value + """")"""")            }        })        onbackpressureblock(2)        subscribeon(schedulersnewthread())        observeon(schedulerscomputation())        subscribe(systemout::println)```on version 107 above code will hang on producing element on position rxringbuffersize + 2 (maxqueuelength):```afteronnext(127)onnext(128)afteronnext(128)subscribeonnext(128)onnext(129)afteronnext(129)onnext(130)afteronnext(130)onnext(131)```if we switch order of subscribe/observeon (observeon before subscribeon) - it will work as expected :)also it will throw _missingbackpressureexception_ without onbackpressure\* (as expected)"";one of us will take a look did this just start happening in 107? || i have came across this behaviour when onbackpressureblock() was introduced but i was not able to reproduce it nor fully understand under which circumstances  it can be observed now it seems that this minimal use case demonstrates this bug || note: lock happens on arrayblockingqueue in operatoronbackpressureblock ```queueput(nlnext(t))```queue contains maxqueuesize last produced elements just before it hangs || next trail: backpressuredrainmanager was requested for n  rxringbuffersize elements when managerdrain() is called n+1 time requestedcount is equal to 0 in this and subsequent calls no more request() calls were made || the problem is `subscribeon(schedulersnewthread())` because the new thread is blocked the new request ( wont be scheduled to run || if i use any other scheduler i will get exactly same behaviour also i dont understand why order of observeon/subscribeon solves this problem || see #2653 >  you need to move the subscribeon before the onbackpressureblock || `onbackpressureblock` still feels so wrong perhaps it is too easy to break an app with it and is a failed experiment?@zsxwing @akarnokd is there something we can do to make this less likely to break an app or is the addition of `onbackpressureblock` fundamentally a bad idea? || blocking and backpressure-continuations dont play well together: the same issue happened in #2466 with a different kind of blocking implementation the solution is to move the subscribeon before the blocking part (which cant be done if the very first source is the blocking one) we can put an emphasis on this fact in the javadoc of `onbackpressurebuffer` but if one isnt in control of the downstream such downstream can introduce subscribeon and the trouble is back id say lets drop the operator for now || +1 removing it since its too easy to hang an app || added pr #2970 which deprecates this operator plus a javadoc update warning about the issue || we deprecated this method  ||;1;0;deprecated onbackpressureblock;"
"2972;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fixed window(time) to work properly with unsubscription  added;backpressure support to window(size  skip).  see #1880.;;1880.0; window(time) to work properly with unsubscription added;backpressure support to window(size skip)see #1880;;jvm doesnt exit on this window example;""something about this doesnt let the jvm exit``` javapackage learnrxjavaexamplesimport javautilconcurrenttimeunitimport rxobservableimport rxsubscriberimport rxschedulersschedulerspublic class flowcontrolwindowexample {    public static void main(string args) {        // buffer every 500ms (using 999999999 to mark start of output)        hotstream()window(500 timeunitmilliseconds)take(10)flatmap(w -> wstartwith(999999999))toblocking()foreach(systemout::println)        // buffer 10 items at a time (using 999999999 to mark start of output)        hotstream()window(10)take(2)flatmap(w -> wstartwith(999999999))toblocking()foreach(systemout::println)        systemoutprintln(""""done"""")    }    /**     * this is an artificial source to demonstrate an infinite stream that bursts intermittently     */    public static observable<integer> hotstream() {        return observablecreate((subscriber<? super integer> s) -> {            while (!sisunsubscribed()) {                // burst some number of items                for (int i  0 i < mathrandom() * 20 i++) {                    sonnext(i)                }                try {                    // sleep for a random amount of time                    // note: only using threadsleep here as an artificial demo                    threadsleep((long) (mathrandom() * 1000))                } catch (exception e) {                    // do nothing                }            }        })subscribeon(schedulersnewthread()) // use newthread since we are using sleep to block    }}```yet this one does so its not about the use of `scheduler`s:``` javapackage learnrxjavaexamplesimport javautilconcurrenttimeunitimport rxobservableimport rxsubscriberimport rxschedulersschedulerspublic class flowcontrolthrottleexample {    public static void main(string args) {        // first item emitted in each time window        hotstream()throttlefirst(500 timeunitmilliseconds)take(10)toblocking()foreach(systemout::println)        // last item emitted in each time window        hotstream()throttlelast(500 timeunitmilliseconds)take(10)toblocking()foreach(systemout::println)    }    /**     * this is an artificial source to demonstrate an infinite stream that emits randomly     */    public static observable<integer> hotstream() {        return observablecreate((subscriber<? super integer> s) -> {            int i  0            while (!sisunsubscribed()) {                sonnext(i++)                try {                    // sleep for a random amount of time                    // note: only using threadsleep here as an artificial demo                    threadsleep((long) (mathrandom() * 100))                } catch (exception e) {                    // do nothing                }            }        })subscribeon(schedulersnewthread())    }}```"";the hang is caused by the interplay between the source take and flatmap take terminates the window just after receiving the last observable and terminates the source which never emits an oncompleted required by the flatmap to terminate as well adding an soncompleted() after the while loop makes the app terminate properly || if it unsubscribe though it shouldnt need an `oncomplete` this suggests to me there is an issue inside `window`  || flatmap  hangs because there is no one to call oncompleted on the last bufferuntilsubscriber being merged by flatmap so if window is unsubscribed it has to send out oncompleted events to all of the open windows just in case || do we still want to pursue this? || i think i found the problem: window(time) didnt defer the child unsubscription properly see #2972 for the resolution || should be  ||;1;0; window(time) to work properly with unsubscription addedbackpressure support to window(size skip);"
2975;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;deprecate and rename two timer overloads to interval;the existing six methods below didn t make sense and caused some confusion.      timer(delay  timeunit[  scheduler])   --> emits 0 after delay and completes timer(delay  period  timeunit[  scheduler])  --> emits 0 after delay and then i++ after every period forever interval(period  timeunit[  schduler)  --> emits i++ after every period forever      i felt that the middle method acted more like the third method  interval  than first method  timer .  this pr is to make this change.       timer(delay  timeunit[  scheduler])   --> emits 0 after delay and completes +@deprecated  timer(delay  period  timeunit[  scheduler])  --> emits 0 after delay and then i++ after every period forever +interval(delay  period  timeunit[  scheduler])  --> emits 0 after delay and then i++ after every period forever  interval(period  timeunit[  schduler)  --> emits i++ after every period forever      ps: yes  i understand that we can t delete the deprecated timer method. @davgross and if this pr is merged will have to change the images.;;0;deprecate and rename two timer overloads to interval;the existing six methods below didnt make sense and caused some confusion```timer(delay timeunit[ scheduler])  --> emits 0 after delay and completestimer(delay period timeunit[ scheduler]) --> emits 0 after delay and then i++ after every period foreverinterval(period timeunit[ schduler) --> emits i++ after every period forever```i felt that the middle method acted more like the third method `interval` than first method `timer`  this pr is to make this change``` timer(delay timeunit[ scheduler])  --> emits 0 after delay and completes+@deprecated timer(delay period timeunit[ scheduler]) --> emits 0 after delay and then i++ after every period forever+interval(delay period timeunit[ scheduler]) --> emits 0 after delay and then i++ after every period forever interval(period timeunit[ schduler) --> emits i++ after every period forever```ps: yes i understand that we cant delete the deprecated timer method@davgross and if this pr is merged will have to change the images;okay i think im done changing the pr unless there are other comments || im not in favor of these changes || any particular reason? || if it were only a matter of aliasing i wouldnt see any problem but you deprecate a historical method just because the name every use place need to be changed to avoid deprecation warnings in rxjava and outside it || i think it improved clarity of api and is directly related to a bug we had here  this pr already takes care of migrating the rxjava usages of timer to interval || the timer-interval confusion apparently is quite common so im going to merge this thanks for the changes ||;;;;1;1;deprecate and rename the timer methods that take initial delay and period to interval;
2982;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;testsubscriber - add factory methods;since we use this so much i ve added factory methods so we can infer types.   instead of       java testsubscriber<integer> ts = new testsubscriber<integer>()       we can write      java testsubscriber<integer> ts = testsubscriber.create()       i changed the tests in  onsubscriberangetest  to demo the usage.;;0;testsubscriber - add factory methods;since we use this so much ive added factory methods so we can infer types instead of ``` javatestsubscriber<integer> ts  new testsubscriber<integer>()```we can write``` javatestsubscriber<integer> ts  testsubscribercreate()```i changed the tests in `onsubscriberangetest` to demo the usage;looks handy @benjchristensen what do you think? || im going to merge these as they come in handy while rxjava requires java 6 to compile || im okay with these additions ||;;;;1;1;add factory methods to testsubscriber;
2983;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fixed multiple calls to onstart.;started investigating multiple calls to onstart based on #2979 and found a bunch  but since onstart can be overridden  i might have missed cases. in addition  i ve found a single place where a producer is set twice on a subscriber but again  many other places may exist.;;2979.0; multiple calls to onstart;started investigating multiple calls to onstart based on #2979 and found a bunch but since onstart can be overridden i might have missed cases in addition ive found a single place where a producer is set twice on a subscriber but again many other places may exist;(i know that is easy to complain  ) this decorator strategy is not very memory friendly you have this annoying (gwt compatibility perspective) atomicxxxfieldupdater in a lot of places to reduce memory usage and you end up adding this decorators to only disable one method callwhat do you think? thanks to solve the problem anyway   || yikes! theres a lot of stuffed up backpressure  here im hoping we can release soon ||;subscriberonstart is called twice on nested unsafesubscription;this test shows the onstart called twice problem it is a clone of subscribertesttestonstartcalledonceviaunsafesubscribe but adding the defer operator which calls unsafesubscribe resulting in a nested call to unsafesubscribe the one from the test and the second one from onsubscribedefer``` java@testpublic void testonstartcalledoncevianestedunsafesubscribe() {    final atomicinteger c  new atomicinteger()    observabledefer(new func0<observable<integer>>() {        @override public observable<integer> call() {            return observablejust(1 2 3 4)take(2)        }    })unsafesubscribe(new subscriber<integer>() {        @override public void onstart() {            cincrementandget()            request(1)        }        @override public void oncompleted() { }        @override public void onerror(throwable e) { }        @override public void onnext(integer t) {            request(1)        }    })    assertequals(1 cget())}```two proposed solutions (first one looks ugly second one adds more code to subscriber)1 add a parameter to subscription calls to transfer the onstart called state2 modify subscriber so subscribe() unsafesubscribe() calls subscriberstart() which delegates to the  actual onstart() protecting for duplicate calls;thanks for discovering thiswith a little overhead it is possible to suppress the second `onstart` call in defer by wrapping the subscriber with another subscriber that does nothing in its `onstart` would you like to submit a pr? || in fact many other operators suffer from the same issue you can discover them by altering subscriber and running the standard tests:``` javafinal atomicinteger once  new atomicinteger()// public void onstart() {    if (oncegetandincrement() > 0) {        throw new illegalstateexception()    }}``` || closing because has been solved by #2983 ;1;0; multiple calls to onstart;
2990;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;improve subscriber readability;the  subscriber  class is something i encounter frequently when debug stepping through code and is hard to read. this pr improves the names of variables and makes the  request  method more readable in particular by moving some code off into another method.   i ve also put in a  return  straight after the  addtorequested(n)  call so that we don t need to make an unnecessary test of  producertorequestfrom != null . very minor saving i m sure but why not.  javadoc is still missing and i thought to leave that for another pr (because it will require a bit more thought).;;0;improve subscriber readability;the `subscriber` class is something i encounter frequently when debug stepping through code and is hard to read this pr improves the names of variables and makes the `request` method more readable in particular by moving some code off into another method ive also put in a `return` straight after the `addtorequested(n)` call so that we dont need to make an unnecessary test of `producertorequestfrom ! null` very minor saving im sure but why notjavadoc is still missing and i thought to leave that for another pr (because it will require a bit more thought);;;;;1;1;improve subscriber readability and dont perform unnecessary test in request method;
2999;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;fix a wrong assertion in asserterror;;;0;fix a wrong assertion in asserterror;;good catch! ||;;;;1;1;fix a wrong assertion in asserterror;
3000;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;replace the java 7 assertionerror(message  cause) with initcause;assertionerror(message  cause)  is a java 7 api. this pr uses runtimeexception to replace it  just like  assertnoerrors .;;0;replace the java 7 assertionerror(message cause) with initcause;`assertionerror(message cause)` is a java 7 api this pr uses runtimeexception to replace it just like `assertnoerrors`;great ;;;;1;1;use initcause to initialize assertionerror;
"3012;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;rx.single;adds  rx.single  as an  observable future  for representing work with a single return value.  see  rx.future/task/async/single  this provides a type similar to  future  in that it represents a scalar unit of work  but it is lazy like an  observable  and many  single s can be combined into an  observable  stream. note how  single.zip  returns  single<r>  whereas  single.merge  returns  observable<r> .  examples of using this class:      java import rx.observable  import rx.single   public class taskexamples {      public static void main(string args) {         // scalar synchronous value         single<string> t1 = single.create(t -> {             t.onsuccess( hello world! )          })           // scalar synchronous value using helper method         single<integer> t2 = single.just(1)           // synchronous error         single<string> error = single.create(t -> {             t.onerror(new runtimeexception( failed! ))          })           // executing         t1.subscribe(system.out::println)          t2.subscribe(system.out::println)          error.subscribe(system.out::println  e -> system.out.println(e.getmessage()))           // scalar singles for request/response like a future         getdata(1).subscribe(system.out::println)           // combining tasks into another task         single<string> zipped = single.zip(t1  t2  (a  b) -> a +   --   + b)           // combining singles into an observable stream         observable<string> merged = single.merge(t1  t2.map(string::valueof)  getdata(3))          observable<string> mergewith = t1.mergewith(t2.map(string::valueof))           zipped.subscribe(v -> system.out.println( zipped =>   + v))          merged.subscribe(v -> system.out.println( merged =>   + v))          mergewith.subscribe(v -> system.out.println( mergewith =>   + v))      }      /**      * example of an async scalar execution using single.create      * <p>      * this shows the lazy  idiomatic approach for rx exactly like an observable except scalar.      *      * @param arg      * @return      */     public static single<string> getdata(int arg) {         return single.create(s -> {             new thread(() -> {                 try {                     thread.sleep(500)                  } catch (exception e) {                     e.printstacktrace()                  }                 // deliver value                     s.onsuccess( data=  + arg)                  }).start()          })      }  };;0;rxsingle;""adds `rxsingle` as an """"observable future"""" for representing work with a single return valuesee  rxfuture/task/async/singlethis provides a type similar to `future` in that it represents a scalar unit of work but it is lazy like an `observable` and many `single`s can be combined into an `observable` stream note how `singlezip` returns `single<r>` whereas `singlemerge` returns `observable<r>`examples of using this class:``` javaimport rxobservableimport rxsinglepublic class taskexamples {    public static void main(string args) {        // scalar synchronous value        single<string> t1  singlecreate(t -> {            tonsuccess(""""hello world!"""")        })        // scalar synchronous value using helper method        single<integer> t2  singlejust(1)        // synchronous error        single<string> error  singlecreate(t -> {            tonerror(new runtimeexception(""""failed!""""))        })        // executing        t1subscribe(systemout::println)        t2subscribe(systemout::println)        errorsubscribe(systemout::println e -> systemoutprintln(egetmessage()))        // scalar singles for request/response like a future        getdata(1)subscribe(systemout::println)        // combining tasks into another task        single<string> zipped  singlezip(t1 t2 (a b) -> a + """" -- """" + b)        // combining singles into an observable stream        observable<string> merged  singlemerge(t1 t2map(string::valueof) getdata(3))        observable<string> mergewith  t1mergewith(t2map(string::valueof))        zippedsubscribe(v -> systemoutprintln(""""zipped > """" + v))        mergedsubscribe(v -> systemoutprintln(""""merged > """" + v))        mergewithsubscribe(v -> systemoutprintln(""""mergewith > """" + v))    }    /**     * example of an async scalar execution using singlecreate     * <p>     * this shows the lazy idiomatic approach for rx exactly like an observable except scalar     *     * @param arg     * @return     */    public static single<string> getdata(int arg) {        return singlecreate(s -> {            new thread(() -> {                try {                    threadsleep(500)                } catch (exception e) {                    eprintstacktrace()                }                // deliver value                    sonsuccess(""""data"""" + arg)                })start()        })    }}```"";""i dont see any way to cancel a subscription to a `single` || when using `subscribe(subscriber s)` then the `subscriber` can be unsubscribed just like an `observable` this is how `timeout` works to cancel itthe `singleobserver` doesnt expose this similar to `observer` we dont currently have something like `take` or `takeuntil` as i felt it was odd to have something called `take` when only a single response can be emitted i think `takeuntil(single/observable)` is a valid operator for a `single` though the `subscribe` methods have a `void` return type as per the intentions for v2 instead of returning `subscription` like `observablesubscribe` does we could make them return `subscription` though what do you think should be done? || > the singleobserver doesnt expose this similar to observerbut `observablesubscribe()` returns a `subscription` for themthis throws npe:``` javasinglecreate(s -> {    new thread(() -> {        try {            threadsleep(5000)        } catch (exception e) {            eprintstacktrace()        }        // deliver value            sonsuccess(""""data"""" + arg)    })start()})timeout(1 timeunitseconds)subscribe(systemout::println throwable::printstacktrace)threadsleep(2000)exception in thread """"main"""" javalangnullpointerexception    at rxsingletoobservable(singlejava:232)    at rxsingletimeout(singlejava:1817)    at rxsingletimeout(singlejava:1740)    at singletestmain(singletestjava:36)```if i use the other overload of timeout it quits only after 5 seconds instead of 2:``` javapublic static void main(string args) throws exception {    singlecreate(s -> {        new thread(() -> {            try {                threadsleep(5000)            } catch (exception e) {                eprintstacktrace()            }            // deliver value             sonsuccess(""""data"""")        })start()    })timeout(1 timeunitseconds singlejust(""""alt""""))    subscribe(systemout::println throwable::printstacktrace)    threadsleep(2000)}``` || > but observablesubscribe() returns a subscription for themsee what i said about that in the previous comment in 2x we intend on not returning `subscription` so i chose not to do that here instead unsubscription should happen from within the stream such as via a `takeuntil` operator || > this throws npeyup it certainly did :-) unit test added i had a null not being handled  || these tests are passing and not taking 5 seconds:``` java    @test    public void testtimeout() {        testsubscriber<string> ts  new testsubscriber<string>()        single<string> s  singlecreate(new onsubscribe<string>() {            @override            public void call(singleobserver<? super string> s) {                try {                    threadsleep(5000)                } catch (interruptedexception e) {                    // ignore as we expect this for the test                }                sonsuccess(""""success"""")            }        })subscribeon(schedulersio())        stimeout(100 timeunitmilliseconds)subscribe(ts)        tsawaitterminalevent()        tsasserterror(timeoutexceptionclass)    }    @test    public void testtimeoutwithfallback() {        testsubscriber<string> ts  new testsubscriber<string>()        single<string> s  singlecreate(new onsubscribe<string>() {            @override            public void call(singleobserver<? super string> s) {                try {                    threadsleep(5000)                } catch (interruptedexception e) {                    // ignore as we expect this for the test                }                sonsuccess(""""success"""")            }        })subscribeon(schedulersio())        stimeout(100 timeunitmilliseconds singlejust(""""hello""""))subscribe(ts)        tsawaitterminalevent()        tsassertnoerrors()        tsassertvalue(""""hello"""")    }```![screen shot 2015-06-09 at 4 20 40 pm]( || with code in its current shape intended for experimentation and avoiding any controversial public apis shall we proceed with merging it? || ship that puppy || no backpressure? || > subscribeon(schedulersio())saved by the interrupt but what if single isnt subscribed to on one of the standard schedulers or it is subscribed to from a scheduler which doesnt call futurecancel() with true?besides the programming advantage of subscriber is that one can add resources to it which will get unsubscribed automaticallyso instead of singleobserver i suggest the following interface: ``` javainterface singlesubscriber<t> {    void onsubscribe(subscription s)    void onsuccess(t value)    void onerror(throwable ex)}singlecreate(s -> {    thread t  new thread(() -> {        try {            threadsleep(5000)        } catch (exception e) {            eprintstacktrace()        }        // deliver value        sonsuccess(""""data"""")    })    sonsubscribe(subscriptioncreate(() -> tinterrupt())    tstart()})singlecreate(s -> {    subscriptionlist slist  new subscriptionlist()    sonsubscribe(slist)    try (inputstream in  new fileinputstream(""""filedat"""")) {        slistadd(subscriptionscreate(() -> closeablesclosesilently(io)))        byte data  new byte[inavailable()]        inread(data)        sonsuccess(data)    } catch (ioexception ex) {       if (!slistisunsubscribed()) {           sonerror(ex)       }    }})``` || > i suggest the following interfaceinteresting im not thrilled though by the implicit contract this creates unless invoking `onsubscribe` is completely optional but if its optional it would also be awkward if were going this route we should just skip the `singleobserver` and do a `singlesubscriber` just like the normal `subscriber` and always have it injected in the top as a cancellation token so a `single` can register unsubscribe behavior with it that way there isnt an awkward negotiation requirementill make changes to accommodate this and ask for your feedback || > no backpressure?for a single valued emission no i dont think it should care it significantly complicates things and i think its silly to worry about backpressure and flow control on a type that emits a single notification either `onerror` or `onsuccess` dont subscribe to it if a single emission cant be handledwhen it gets composed however then the backpressure semantics of `observable` would kick in such as with `merge` when many `single`s are merged together  || > no backpressure?i guess @davidmoten meant where the single and observable meet for example in toobservable() where you should use `singledelayedproducer` to introduce the correct backpessure interop || > im not thrilled though by the implicit contract this creates unless invoking onsubscribe is completely optional but if its optional it would also be awkwardit follows the reactive-streams concept without it the cancellation wouldnt compose through and youd rely only upon the ability of `subscribeon` to interrupt an rx thread id totally go with the `singleobserver`/`singlesubscriber` pair if `subscribe(singleobserver)` returned `subscription` at least (and `singlesubscriber` could extend `subscription` as well) || > it follows the reactive-streams concepti know but i dont like mixing patterns in v1 it would be odd to have `observable` handle cancellation one way and `single` do it another way take a look at the code now it has a `singlesubscriber` instead of `singleobserver` and composes cancellation that same way as `observable` since `singlesubscriber` implements `subscription`  || > where you should use singledelayedproducer to introduce the correct backpessure interopah okay i can buy into that  so like this:``` java    protected single(final onsubscribe<t> f) {        // bridge between onsubscribe (which all operators and observables use) and onexecute (for single)        thisonsubscribe  new observableonsubscribe<t>() {            @override            public void call(final subscriber<? super t> child) {                final singledelayedproducer<t> producer  new singledelayedproducer<t>(child)                childsetproducer(producer)                singlesubscriber<t> ss  new singlesubscriber<t>() {                    @override                    public void onsuccess(t value) {                        producersetvalue(value)                    }                    @override                    public void onerror(throwable error) {                        childonerror(error)                    }                }                childadd(ss)                fcall(ss)            }        }    }```it still feels like a lot of overhead for something that should never need backpressure :-/ if this shows poor performance i would drop this and just leave it to things like `merge` to always handle receiving 1 value per `single`  || see test for backpressure here:  unsubscribe:  || > it still feels like a lot of overhead for something that should never need backpressurei thought its easier to change `toobservable` and introduce the backpressure logic there instead of at the very root> if this shows poor performance i would drop this and just leave iti havent benchmarked this yet but i believe `single` already maximizes the overhead around delivering values based on the latest merge() benchmark where just(0)flatmap(v -> just(0)) delivers ~6m values a stream of 1000 values in total delivers 45/76m values per second || > maximizes the overhead around delivering valuescomparing with a stream of 1000 is not a valid comparison a `future` or at most an `observable` of a single value is a valid comparison the reason a `single` would be used is because the data source is not represented by a stream of 1000 valuesnote that `single` does not yet have any optimizations done for example we could use similar approaches as `scalarsynchronousobservable` for `singlejust` > i thought its easier to change toobservablebut then the test cases i provided wouldnt work where a `subscriber` is used with `request(0)` so it depends on what youre trying to solve for look at what `toobservable` is doing and youll notice that a `single` is just a different type around the same `observableonsubscribe` internally this is done on purpose to allow reusing `observable` operators if we agree with the public api of `singlesubscriber` then the rest of this design is internal implementation details (i think) so we can move forward and always change it laterlooking at the code as it currently stands is there anything more you want changed before proceeding with it? || > comparing with a stream of 1000 is not a valid comparisonso i guess delivering 1000 items through abstractonsubscribe one at a time isnt really comparable with abstractproducer emitting the same amount when requested all at onceregardless if the use case for `single` will be to create 1000s of them to deliver a single value each then youd better off restructuring the business logic around an (i hoped i could avoid using the e-word) event-bus> the reason a single would be used is because the data source is not represented by a stream of 1000 valuesit really depends on how long the computation takes to become available: if it is in microsecond or millisecond range then the few dozen nanoseconds cas takes inside the `singledelayedproducersetvalue` doesnt really matter> looking at the code as it currently stands is there anything more you want changed before proceeding with it?so im guessing there wont be any unsubscription possibility if one uses the non- subscriber or singlesubscriber-based `subscribe()` methods?> note that single does not yet have any optimizations doneperhaps you could include benchmarks already so the improvements can be measured || > then youd better off restructuring the business logicsure but thats why we have different abstractions types and tools> it really depends on how long the computation takes to become availablethe point of `single` is to represent a single async unit of work typically io if it is microseconds it is most certain being done """"the wrong way"""" similar to putting fine grained work on an executor and receiving a future> so im guessing there wont be any unsubscription possibility if one uses the non- subscriber or singlesubscriber-based subscribe() methods?i guess we can make those return `subscription` since thats how `observable` works ill change that before merging || perf as expected is poor for representing microsecond scale computations but totally fine for io related request/response which this is modeling:```benchmark                                               mode   samples        score  score error    unitsrsingleperfbaselinenewsingleandsubscribereachtime    thrpt         5  8303803489   779599284    ops/srsingleperfbaselinesingleconsumption                 thrpt         5  8409729682   396871179    ops/srsingleperfbaselinesingleconsumptionunsafe           thrpt         5 15629012609  1838899288    ops/s```also note that we are maintaining the same performance hit of `safesubscriber` and punting on solving that until 2x as it is so baked into how `subscriber` and `observable` work || proceeding with merge it is all marked as `@experimental` and i am not releasing 1013 yet || "";;;;1;1;""rxsingleadds `rxsingle` as an """"observable future"""" for representing work with a single return valuesee  rxfuture/task/async/singlethis provides a type similar to `future` in that it represents a scalar unit of work but it is lazy like an `observable` and many `single`s can be combined into an `observable` stream note how `singlezip` returns `single<r>` whereas `singlemerge` returns `observable<r>`examples of using this class:```javaimport rxobservableimport rxsinglepublic class taskexamples {    public static void main(string args) {        // scalar synchronous value        single<string> t1  singlecreate(t -> {            tonsuccess(""""hello world!"""")        })        // scalar synchronous value using helper method        single<integer> t2  singlejust(1)        // synchronous error        single<string> error  singlecreate(t -> {            tonerror(new runtimeexception(""""failed!""""))        })        // executing        t1subscribe(systemout::println)        t2subscribe(systemout::println)        errorsubscribe(systemout::println e -> systemoutprintln(egetmessage()))        // scalar singles for request/response like a future        getdata(1)subscribe(systemout::println)        // combining tasks into another task        single<string> zipped  singlezip(t1 t2 (a b) -> a + """" -- """" + b)        // combining singles into an observable stream        observable<string> merged  singlemerge(t1 t2map(string::valueof) getdata(3))        observable<string> mergewith  t1mergewith(t2map(string::valueof))        zippedsubscribe(v -> systemoutprintln(""""zipped > """" + v))        mergedsubscribe(v -> systemoutprintln(""""merged > """" + v))        mergewithsubscribe(v -> systemoutprintln(""""mergewith > """" + v))    }    /**     * example of an async scalar execution using singlecreate     * <p>     * this shows the lazy idiomatic approach for rx exactly like an observable except scalar     *     * @param arg     * @return     */    public static single<string> getdata(int arg) {        return singlecreate(s -> {            new thread(() -> {                try {                    threadsleep(500)                } catch (exception e) {                    eprintstacktrace()                }                // deliver value                    sonsuccess(""""data"""" + arg)                })start()        })    }}```"";"
3018;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;testsubscriber - fix awaitterminaleventandunsubscribeontimeout;the method  testsubscriber.awaitterminaleventandunsubscribeontimeout  did not unsubscribe on timeout. this pr fixes it.;;0;testsubscriber - fix awaitterminaleventandunsubscribeontimeout;the method `testsubscriberawaitterminaleventandunsubscribeontimeout` did not unsubscribe on timeout this pr fixes it;;;;;1;1;fix awaitterminaleventandunsubscribeontimeout;
3019;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;javadoc improvements for new single class;;;0;javadoc improvements for new single class;;;;;;1;1;a handful more javadoc changes (misnamed @params and such);
3023;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;connectableobservable autoconnect operator;there is a need for auto-connection capability for an arbitrary connectableobservable similar to how it is possible now to use cache() as an auto-connected unbounded replay.  the new  autoconnect()  method let s specify the number of  subscriber s required for the real connection to happen and also offers the ability to receive the connection  subscription .  i ve also updated the parameter name of  cache(int)  to reflect it is a capacity hint and not a bound.;;0;connectableobservable autoconnect operator;there is a need for auto-connection capability for an arbitrary connectableobservable similar to how it is possible now to use cache() as an auto-connected unbounded replaythe new `autoconnect()` method lets specify the number of `subscriber`s required for the real connection to happen and also offers the ability to receive the connection `subscription`ive also updated the parameter name of `cache(int)` to reflect it is a capacity hint and not a bound;`autoconnect` is a nice additional feature like `refcount` except it never disconnects i particularly like the overload where it auto connects when the specific number of subscribers arrive ||;;;;1;1;connectableobservable autoconnect operator;
3029;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;replaced tabs with spaces for good.;somehow  every second rebase i do i get this tab-space conversion which pollutes my prs.;;0;replaced tabs with spaces for good;somehow every second rebase i do i get this tab-space conversion which pollutes my prs;you might check your git config i had an app which automatically changed my git settings from spaces to tabs || yes i had issues at one point and messed with my git config: ||;;;;1;1;replaced tabs with spaces for good;
3031;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix operatorflatmapperf.flatmapintpassthruasync perf test;this test was reported broken in   fixing by adding the use of latchedobserver.  previously broken test results:      r.o.operatorflatmapperf.flatmapintpassthruasync         1  thrpt         5   363615.622   115041.519    ops/s r.o.operatorflatmapperf.flatmapintpassthruasync      1000  thrpt         5      350.204      125.773    ops/s r.o.operatorflatmapperf.flatmapintpassthruasync   1000000  thrpt         5        0.319        0.184    ops/s      fixed results:      r.o.operatorflatmapperf.flatmapintpassthruasync         1  thrpt         5   102109.681     8709.920    ops/s r.o.operatorflatmapperf.flatmapintpassthruasync      1000  thrpt         5      403.071      130.651    ops/s r.o.operatorflatmapperf.flatmapintpassthruasync   1000000  thrpt         5        0.355        0.070    ops/s;;0;fix operatorflatmapperfflatmapintpassthruasync perf test;this test was reported broken in  by adding the use of latchedobserverpreviously broken test results:```rooperatorflatmapperfflatmapintpassthruasync         1  thrpt         5   363615622   115041519    ops/srooperatorflatmapperfflatmapintpassthruasync      1000  thrpt         5      350204      125773    ops/srooperatorflatmapperfflatmapintpassthruasync   1000000  thrpt         5        0319        0184    ops/s``` results:```rooperatorflatmapperfflatmapintpassthruasync         1  thrpt         5   102109681     8709920    ops/srooperatorflatmapperfflatmapintpassthruasync      1000  thrpt         5      403071      130651    ops/srooperatorflatmapperfflatmapintpassthruasync   1000000  thrpt         5        0355        0070    ops/s```;@akarnokd let me know if this fixes the issue you reported || yes thats it ||;;;;1;1;fix operatorflatmapperfflatmapintpassthruasync perf testthis test was reported broken in  by adding the use of latchedobserverpreviously broken test results:```rooperatorflatmapperfflatmapintpassthruasync         1  thrpt         5   363615622   115041519    ops/srooperatorflatmapperfflatmapintpassthruasync      1000  thrpt         5      350204      125773    ops/srooperatorflatmapperfflatmapintpassthruasync   1000000  thrpt         5        0319        0184    ops/s``` results:```rooperatorflatmapperfflatmapintpassthruasync         1  thrpt         5   102109681     8709920    ops/srooperatorflatmapperfflatmapintpassthruasync      1000  thrpt         5      403071      130651    ops/srooperatorflatmapperfflatmapintpassthruasync   1000000  thrpt         5        0355        0070    ops/s```;
3033;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;takelast() javadoc fixes  standardize parameter names (count instead of num);this pr includes these changes: - standardized parameter names for  take    takelast    skip    limit  to use  count  instead of  num  - enhanced the javadoc for  takelast  so it is clear for all overrides that if the observable contains less than  count  items then all will be emitted. - improved the exception message thrown by  operatortakelast  when  count  <0  addresses #3027;;0;takelast() javadoc fixes standardize parameter names (count instead of num);this pr includes these changes:- standardized parameter names for `take` `takelast` `skip` `limit` to use `count` instead of `num`- enhanced the javadoc for `takelast` so it is clear for all overrides that if the observable contains less than `count` items then all will be emitted- improved the exception message thrown  operatortakelast` when `count` <0addresses #3027;;;;;1;1;takelast javadoc fixes standardize on parameter names (count instead of num) improve message in operatortakelast exception;
3034;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;instantiate empty lazily;the singleton  empty  returned by  observable.empty()  can be instantiated lazily because it is not always required.;;0;instantiate empty lazily;the singleton `empty` returned  observableempty()` can be instantiated lazily because it is not always required;;;;;1;1;instantiate empty lazily;
3039;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;window with observable: fixed unsubscription and behavior;fixed unsubscription propagation of two window variants (boundary  start-end).  in addition  there was a discrepancy reported on [stackoverflow]( regarding the factory-boundary version. in rx.net  the factory is called whenever the previous boundary observable has produced a value. i.e.  instead of a series of  onnexts  from the same  observable   it uses a series of  observable s with a single  onnext  emission as a boundary indicator.;;0;window with observable:  unsubscription and behavior; unsubscription propagation of two window variants (boundary start-end)in addition there was a discrepancy reported on [stackoverflow]( regarding the factory-boundary version in rxnet the factory is called whenever the previous boundary observable has produced a value ie instead of a series of `onnexts` from the same `observable` it uses a series of `observable`s with a single `onnext` emission as a boundary indicator;thank you for tackling this ||;;;;1;1;window with boundary observable:  unsubscription and behavior;
3042;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add backpressure support for defaultifempty();when looking at implementing backpressure support for  defaultifempty  the obvious strategy is to reuse  switchifempty  and get rid of  operatordefaultifempty . that s what this pr does.  there is a little bit of overhead with using  observable.from(arrays.aslist(defaultvalue))  as the alternate observable. might be nice to have a version of  observable.just(item)  that supports backpressure to use in its place (you ve mentioned this before @akarnokd).;;0;add backpressure support for defaultifempty();when looking at implementing backpressure support for `defaultifempty` the obvious strategy is to reuse `switchifempty` and get rid of `operatordefaultifempty` thats what this pr doesthere is a little bit of overhead with using `observablefrom(arraysaslist(defaultvalue))` as the alternate observable might be nice to have a version of `observablejust(item)` that supports backpressure to use in its place (youve mentioned this before @akarnokd);you could just create an observable inline:``` javapublic final observable<t> defaultifempty(t defaultvalue) {    //if empty switch to an observable that emits defaultvalue and supports backpressure    return switchifempty(observablecreate(s -> {        ssetproducer(new singleproducer<>(defaultvalue))    }))}``` || great can do  id like to see that as its own method ill put that change in and open another issue so method names/overrides and desirability can be discussed || ;;;;1;1;add backpressure support for defaultifempty();
3043;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;testsubscriber javadoc cleanup;- standardize on  asserts that  and  returns  - fix tenses and wordings;;0;testsubscriber javadoc cleanup;- standardize on `asserts that` and `returns`- fix tenses and wordings;;;;;1;1;testsubscriber javadoc improvements;
3048;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;compositeexception extra npe protection;compositeexception  won t crash if it received null by some means. a  null  collection or  null  collection item is replaced by a  nullpointerexception  instance.  see also: #3046.;;3046.0;compositeexception extra npe protection;`compositeexception` wont crash if it received null by some means a `null` collection or `null` collection item is replaced by a `nullpointerexception` instancesee also: #3046;;nullpointerexception at rxexceptionscompositeexceptiongetlistofcauses(compositeexceptionjava:245);i use rxandroid library in my project and i have next exception :e/androidruntime(27849): error reporting crashe/androidruntime(27849): javalangnullpointerexceptione/androidruntime(27849): at rxexceptionscompositeexceptiongetlistofcauses(compositeexceptionjava:245)e/androidruntime(27849): at rxexceptionscompositeexceptiongetcause(compositeexceptionjava:100)e/androidruntime(27849): at androidutilloggetstacktracestring(logjava:454)e/androidruntime(27849): at androidutilsloge(slogjava:151)e/androidruntime(27849): at comandroidinternalosruntimeinit$uncaughthandleruncaughtexception(runtimeinitjava:109)e/androidruntime(27849): at javalangthreadgroupuncaughtexception(threadgroupjava:693)e/androidruntime(27849): at javalangthreadgroupuncaughtexception(threadgroupjava:690)e/androidruntime(27849): at rxinternalschedulersscheduledactionrun(scheduledactionjava:66)e/androidruntime(27849): at androidoshandlerhandlecallback(handlerjava:733)e/androidruntime(27849): at androidoshandlerdispatchmessage(handlerjava:95)e/androidruntime(27849): at androidoslooperloop(looperjava:146)e/androidruntime(27849): at androidappactivitythreadmain(activitythreadjava:5653)e/androidruntime(27849): at javalangreflectmethodinvokenative(native method)e/androidruntime(27849): at javalangreflectmethodinvoke(methodjava:515)e/androidruntime(27849): at comandroidinternaloszygoteinit$methodandargscallerrun(zygoteinitjava:1291)e/androidruntime(27849): at comandroidinternaloszygoteinitmain(zygoteinitjava:1107)e/androidruntime(27849): at dalviksystemnativestartmain(native method)somebody know how can i fix it ?thank you;it appears you have a `null` exception added to a composite somewhere what operators are you using do you call `onerror(null)` somewhere by accident?  || i try to get throwablegetmessage callback and have this null pointeri already find the reason i make mistake at url and try to connect to non-existent url i changed it and all is finei think you need handle this null pointer in other way because currently i cant normally find the reason of exceptionthank you || fix already delivered thank you for reporting ||;1;0;compositeexception extra npe protection;
"3049;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;single: add tosingle method to observable;- closes reactivex/rxjava#3038 - this method allows an observable which is guaranteed to return exactly one   item to be converted to a single - note: the semantics of this function are very similar to that of single - i.e. errors are passed through  more than one item results in an   illegalargumentexception  completion without emission results in a   nosuchelementexception and exactly one item is passed through the onsuccess   method of singlesubscriber;;3038.0;single: add tosingle method to observable;- closes reactivex/rxjava#3038- this method allows an observable which is guaranteed to return exactly one  item to be converted to a single- note: the semantics of this function are very similar to that of single- ie errors are passed through more than one item results in an  illegalargumentexception completion without emission results in a  nosuchelementexception and exactly one item is passed through the onsuccess  method of singlesubscriber;would appreciate feedback since this is my first contribution to rxjava! :) || yes || looks good can you add the license headers to the files please? the block of code to add is shown here:  || have done so || would you mind rebasing to a single commit? || also done :) || thank you @tilal6991 for the contribution and responsiveness on changes || glad to contributeim planning to look into more tricky issues soon so hopefully this is not the last youll see of me :) ||;variants of first single etc which return single;""now that we have the concept of a """"single"""" i think it would make sense that any operator which returns an observable which is guaranteed to return exactly one item or fail would be a single examples would be operators like single first tolist takefirst takelast etci understand that to maintain source and binary compatibility the existing definitions of these would need to be unchanged so would it be possible to create some sort of conversion mechanism to turn an observable into a single?if this would be acceptable i would be happy to try my hand in writing such a conversion mechanism depending on how complex it would have to be i have been using rx for a while now but as of yet have not actually written something which interacts with low level rx stuff (eg a custom operator)thanks!"";yes we will want something to convert such as `singlefrom(observable o)` or `observabletosingle()`the `tosingle()` method should behave similarly to `single()` except return a `single` awkward but all we can do during 1xit would be great if you want to contribute this and start the design discussion note that public apis contributions can often go through a lot of back and forth as we discuss them since we are stuck with them forever once we let them in ||;1;0;single: add tosingle method to observable* closes reactivex/rxjava#3038* this method allows an observable which is guaranteed to return exactly one  item to be converted to a single* note: the semantics of this function are very similar to that of single* ie errors are passed through more than one item results in an  illegalargumentexception completion without emission results in a  nosuchelementexception and exactly one item is passed through the onsuccess  method of singlesubscriber;"
3052;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;reduce test failure likelihood of testmultithreadedwithnpeinmiddle;factored out the npe before the thread creation as it can take several milliseconds and other values can just slip through.;;0;reduce test failure likelihood of testmultithreadedwithnpeinmiddle;factored out the npe before the thread creation as it can take several milliseconds and other values can just slip through;;;;;1;1;reduce test failure likelihood of testmultithreadedwithnpeinmiddle;
3058;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add and improve javadoc in subscriber;this pr  - adds missing javadoc to the  subscriber(subscriber)  constructor - improves (hopefully!) the javadoc for the constructor  subscriber(subscriber boolean)  - adds missing javadoc for  setproducer;;0;add and improve javadoc in subscriber;this pr - adds missing javadoc to the `subscriber(subscriber)` constructor- improves (hopefully!) the javadoc for the constructor `subscriber(subscriberboolean)`- adds missing javadoc for `setproducer`;;;;;1;1;add and improve javadoc in subscriber;
3069;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;improve tosingle() javadoc (diagram  see also  since-annotation);;;0;improve tosingle() javadoc (diagram see also since-annotation);;;;;;1;1;improve tosingle() javadoc (diagram see also since-annotation);
"3077;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add  since  annotations to javadocs for new experimental/beta methods;;;0;""add """"since"""" annotations to javadocs for new experimental/beta methods"";;probably a good time to regenerate and deploy the javadocs too ||  can the plp branch be deleted? || yeson thu jul 23 2015 at 6:14 am david karnok notifications@githubcomwrote:> can the plp branch be deleted?> > > reply to this email directly or view it on github>  david m grossplp consulting ||;;;;1;1;window() behavior changed so did marble diagram & thus its size;"
3079;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix foreach javadoc;observable.foreach  javadoc suffered from a bit of copy-and-paste and neglected to mention the possible throw of  onerrornotimplementedexception .  also added a couple of unit tests.;;0;fix foreach javadoc;`observableforeach` javadoc suffered from a bit of copy-and-paste and neglected to mention the possible throw of `onerrornotimplementedexception`also added a couple of unit tests;;;;;1;1;fix foreach javadoc;
"3081;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;revert of cache/replay;#3076. i did revert commit of the pr that added back pressure support to the cache operator and ran a canary.  our production systems seem stable now even with the new merge.;;3076.0;revert of cache/replay;#3076 i did revert commit of the pr that added back pressure support to the cache operator and ran a canary  our production systems seem stable now even with the new merge;thats good news not sure what time @akarnokd has for reviewing `cache` backpressure work if we cant fix this short term would be nice too see a fix for #3026 go in 1013 if backpressure doesnt make it quick summary is in 1012 `cache` emits nothing until source has completed  || can you create an unit test based on the usage pattern? it would be also interesting to verify `replay()autoconnect()` since it ought to be functionally equivalent to `cache()` || i have no clue at the moment what the actual code path is causing the lockup itll take awhile for me to instrument code to narrow which usage pattern is causing the problem  || i believe the issue were seeing comes from use of `cache()` in hystrix:  use hystrix at very high volume and `cache()` will be used by a large percentage of those calls this explains why this impacted our canary so significantly || ive reverted both the cache and revert related commits  the tests and the canary seem to do fine so far ||;1013 release candidate;""update: after production canary testing on the netflix api we have gained confidence with `merge` and are now ready to release 1013 we did however choose to rollback changes to `replay()` and `cache()` and will pursue them in the next release the discussion in the comments below shares the details---this is a pretty significant release as it has major changes to `merge` ~~and `replay`~~ along with the new `rxsingle` type the `merge` changes are the most sensitive as they affect almost all applications (either through `merge` directly or the ubiquitous use of `flatmap`) im going to wait a few days before releasing to give people a chance to use the [snapshot]( use the snapshot from a gradle build like this:``` groovyrepositories {    maven { url  }}dependencies {    compile ioreactivex 1013-snapshot}```---this release has quite a few bug fixes and some new functionality items of note are detailed here with the list of changes at the bottom##### mergethe `merge` operator went through a major rewrite to fix some edge case bugs in the previous version this has been sitting for months going through review and performance testing due to the importance and ubiquity of its usage it is believed this rewrite is now production ready and achieves the goal of being more correct (no known edge cases at this time) while retaining comparable performance and memory usage special thanks to @akarnokd for this as `merge` is a challenging one to implement ##### window fix and behavior changeunsubscription bugs were  in `window` along the way it also resulted in a fix to one of the `window` overloads that had a functional discrepancy``` javawindow(func0<? extends observable<? extends tclosing>> closingselector)```this is a small behavior change that corrects it if you use this overload please review the change to ensure your application is not affected by an assumption of the previously buggy behavior:  that this behavior change only affects that particular overload while the broader bug fixes affect all `window` overloads ##### rxsingleafter [much discussion]( it was decided to add a new type to represent an `observable` that emits a single item much bike-shedding led to the name `single` this was chosen because `future` `promise` and `task` are overused and already have nuanced connotations that differ from `rxsingle` and we didnt want long obnoxious names with `observable` as a prefix or suffix read the issue thread if you want to dig into the long debatesif you want to understand the reasoning behind adding this type you can read about it [in this comment]( short request/response semantics are so common that it was decided worth creating a type that composes well with an `observable` but only exposes request/response the difference in behavior and comparability was also deemed worth having an alternative to `future` in particular a `single` is lazy whereas `future` is eager additionally merging of `single`s becomes an `observable` whereas combining `future`s always emits another `future` note that the api is added in an `@experimental` state we are fairly confident this will stick around but are holding final judgement until it is used more broadly we will promote to a stable api in v11 or v12 examples below demonstrate use of `single```` java// hello worldsingle<string> hello  singlejust(""""hello world!"""")hellosubscribe(systemout::println)// async request/responsesingle<string> one  getdata(1)single<string> two  getotherdata(2)// merge request/responses into an observable of multiple values (not possible with futures)observable<string> merged  onemergewith(two)// zip request/responses into another single (similar to combining 2 futures)single<string> zipped  onezipwith(two (a b) -> a + b)// flatmap to a singlesingle<string> flatmapsingle  oneflatmap(v -> {    return getotherdata(5)})// flatmap to an observableobservable<integer> flatmapobservable  oneflatmapobservable(v -> {    return observablejust(1 2 3)})// toobservableobservable<string> toobservable  onetoobservable()// tosinglesingle<integer> tosingle  observablejust(1)tosingle()public static single<string> getdata(int id) {    return single<string> create(s -> {        // do blocking io        sonsuccess(""""data_"""" + id)    })subscribeon(schedulersio())}public static single<string> getotherdata(int id) {    return single<string> create(s -> {        // simulate non-blocking io        new thread(() -> {            try {                sonsuccess(""""other_"""" + id)            } catch (exception e) {                sonerror(e)            }        })start()    })}```##### connectableobservableautoconnecta new feature was added to `connectableobservable` similar in behavior to `refcount()` except that it doesnt disconnect when subscribers are lost this is useful in triggering an """"auto connect"""" once a certain number of subscribers have subscribed the [javadocs]( and [unit tests]( are good places to understand the feature##### deprecated onbackpressureblockthe `onbackpressureblock` operator has been deprecated it will not ever be removed during the 1x lifecycle but it is recommended to not use it it has proven to be a common source of deadlocks and is difficult to debug it is instead recommended to use non-blocking approaches to backpressure rather than callstack blocking approaches to backpressure and flow control are [discussed on the wiki]( changes- [pull 3012]( rxsingle- [pull 2983]( fixed multiple calls to onstart- [pull 2970]( deprecated onbackpressureblock- [pull 2997]( fix retry() race conditions- [pull 3028]( delay: error cut ahead was not properly serialized- [pull 3042]( add backpressure support for defaultifempty()- [pull 3049]( single: add tosingle method to observable- [pull 3055]( tosingle() should use unsafesubscribe- [pull 3023]( connectableobservable autoconnect operator- [pull 2928]( merge and mergemaxconcurrent unified and rewritten- [pull 3039]( window with observable: fixed unsubscription and behavior- [pull 3045]( elementat request management enhanced- [pull 3048]( compositeexception extra npe protection- [pull 3052]( reduce test failure likelihood of testmultithreadedwithnpeinmiddle- [pull 3031]( fix operatorflatmapperfflatmapintpassthruasync perf test- [pull 2975]( deprecate and rename two timer overloads to interval- [pull 2982]( testsubscriber - add factory methods- [pull 2995]( switchonnext - ensure initial requests additive and fix request overflow- [pull 2972]( fixed window(time) to work properly with unsubscription added- [pull 2990]( improve subscriber readability- [pull 3018]( testsubscriber - fix awaitterminaleventandunsubscribeontimeout- [pull 3034]( instantiate empty lazily- [pull 3033]( takelast() javadoc fixes standardize parameter names (count instead of num)- [pull 3043]( testsubscriber javadoc cleanup- [pull 3065]( add subscriberswrap- [pull 3091]( fix autoconnect calling onstart twice- [pull 3092]( singletoobservablei will be adding examples and more comprehensive release notes for `rxsingle`---these were reverted and wont be included in 1013:- [pull 2969]( operator cache() now supports backpressure- [pull 3047]( operator replay() now supports backpressure"";""nice release :) || fwiw i bumped the couchbase sdk to 1013-snapshot and all the unit and integration tests look good looking forward to the 1013 release will be shipping with 220 :) || this snapshot badly failed our production canary testing it seems be causing our application threads to block and grow overtime@abersnaze is currently doing the tedious bisect + canary test process to figure out which commit is causing the issue until we can determine what it is we will not be releasing this version || sorry to hear this can you give more details about the failure?my guesses are:- window with boundary observable factory contains behavior change: at every window end condition now the factory is called- the anomaly @davidmoten encountered with retry is now amplified- you are using custom operators which dont properly honor backpressure and the rewritten operators expose this in some ways || all we know so far is that threadactivecount on the app is now constantly increasing and the only change is the rxjava jar here is the comparison between baseline and canary:![canary]( || really looking forward to this release   btw why isnt the version v110? this version seems to include [significant enhancements]( || > why isnt the version v110so far all new functionality has been added with `@experimental` or `@beta` annotations the intent is for them to stabilize and prove themselves and then at the 110 release promote them to """"final""""/""""stable"""" thus the """"significant enhancements"""" arent considered formally released until we remove the annotations this approach allows us to continue moving quickly without piling up changes for months and avoid increment the minor number every few weeks (which no one wants  since it implies more change than is really happening) the change of `merge` is the only change in this release that really has made me cautious as last time we touched `merge` """"bad things happened"""" :-)we definitely are nearing a 110 release as we have had several `@beta` and `@experimental` items for a few months nowdoes anyone think anything in this release should be removed from a 1013 release and held off until were ready for 110? || @benjchristensen thanks to detailed explanations `single` is what i thought is significant  i agree with you ) || turned out to be `cache()` || thank you @abersnaze for figuring this out  will need to be reverted which is proposed in  this point we dont yet know what the issue is do we proceed with 1013 without `cache()` changes or do we hold up a release until we figure that out? || id hold up the release because if there is indeed a problem with cache() fixing it surely involves less drastic changes than a full revert || do you have time to help figure it out in the coming days? also we dont need to wait a month until 1014 the delay since 1012 is primarily my fault because ive been busy elsewhere we can definitely move fasteranother concern i have is your comment about `replay()autoconnect()`:  do you only suspect the new `autoconnect()` behavior or all the changes on `replay`? || i can spare some time to fix cache() but without the usage pattern i can only guess certainly releasing as is increases a likelihood the problem manifests somewhere else where the devs can create a report with a unit test reproducing the problemboth backpressure-aware `replay()` and `cache()` were built quite similarly (`autoconnect()` is not relevant from this aspect) therefore you could change the `observablecache()` method implementation to use `replay()autoconnect()` and see if the same problem happens or not || > without the usage pattern i can only guesswe are trying to build a unit test i believe the issue were seeing comes from use of `cache()` in hystrix:  use hystrix at very high volume and `cache()` will be used by a large percentage of those calls this explains why this impacted our canary so significantly> releasingshould we revert both `cache()` and `replay()` changes for now release 1013 with the `single` `merge` and other changes then followup with 1014 including `cache()` and `replay()`? || ive looked at cache() again and it was prone to child-thrown exceptions breaking the caching process completely ive  it and replay() in #3088 along with other small changes || i ran two canaries the first was with the #3088 and the second with `cache()` replaced `replay()autoconnect()` both showed signed of request threads locking up  at this point i would like to move forward with a smaller but stable build now  pushing off backpressure on cache/replay to the 1014 wont make the feature any later and will allow people access to the bug fixes in 1013 that we know are okay available sooner( || agreed lets revert these and move forward with 1013 and release 1014 when these are fixed  || ive updated the #3081 to rollback both cache and replay || @benjchristensen could you apply release and undo the """"undo"""" in #3081 so i dont need to start from scratch again? one final test id conduct is to revert `cache()` to its previous form and add `onbackpressurebuffer()` to it if this hangs it is likely there is a backpressure bug in the consumers of `cache()` if it passes my guess is that the downstream doesnt tolerate live synchronous replays (`cache()` used to connect first then accept the child `subscriber`) || one other thing i can think of is the effect of the `onstart` patch some existing code relied on the fact that it will be called twice and is now under-requesting at the beginning || i think the handling of this issue distinguishing between experimental vs stable apis stability vs features philosophy usage of atlas and canary builds would make a nice addition to the netflix tech blog so many good practices demonstrated in one place its exemplary || @akarnokd the test of commit `96786bb` + `onbackpressurebuffer()` also fails the canary what kind of bug should we be looking for? not requesting enough? || id check all places which call `request` but with an odd amount for example `request(rxringbuffersize / 2)` in your code base || `replay` and `cache` changes reverted:  || please consider including 3091 as well into 1013 || merged the current 1x branch is what i intend on releasing shortly || released  and  || "";1;0;""revert """"cache now supports backpressure""""this reverts commit 18ff5afd380625f9157d9e9a3144baf845c09086"";"
3082;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;observable.x(conversionfunc) to allow extensions to observables;;;0;observablex(conversionfunc) to allow extensions to observables;;the travis ci failure is related to an rx backpreasure test```rxbackpressuretests > testmergeasyncthenobserveon failed    javalangruntimeexception: unexpected onerror events: 1        at rxobserverstestsubscriberassertnoerrors(testsubscriberjava:263)        at rxbackpressureteststestmergeasyncthenobserveon(backpressuretestsjava:138)        caused by:        rxexceptionsmissingbackpressureexception```is this known to be buggy? my changes seem unrelated it also failed for #3060 || it didnt fail with `missingbackpressureexception` as far as i know || they both failed with missing backpressure || found the bug in merge() it was my oversight fix posted: #3093 || awesome! thanks @akarnokd  || ive restarted this build and it passes now || ive simplified the problem this is trying to address to just adding the `x(conversionfunc)` method and unit tests to show how we might use this my apologies to the general populace who arent familiar with battlestar galactica who may be confused by the references made to said series in my unit test  || i would have liked to have made the static method``` javaprivate static subscription observablesubscribe(subscriber<? super t> observable<t>)```be agnostic of the `observable` and instead have the signature ``` javapublic static subscription observablesubscribe(subscriber<? super t> onsubscribe<t>)```this would allow us to reuse this `safesubscriber` wrapping and the hooks invocations from other observables (see test) but then the hooks api would break on``` javahookonsubscribestart(observable observableonsubscribe)call(subscriber)```and then it probably wouldnt belong in `observablejava`  || reviewed with @benjchristensen and he agreed to merge this and start testing it out in snapshots  || latest version was rebased onto 1x and has `conversionfunc` replaced with `func1` ||;;;;1;1;implemented observablex(conversionfunc) to allow external extensions to observables;
3085;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;break tests as approach timeout so that don t fail on slow machines;these tests were giving me regular failures on my slow laptop: -  operatormergemaxconcurrenttest.testsimpleonelessasync  -  backpressuretests.testonbackpressuredrop   they both loop repeatedly looking for failure or lockup. if the machine running the tests isn t fast enough then the tests timeout before reaching the desired number of loops. this pr adds a break to the tests when the loop has run for 9 seconds (timeout is 10 seconds).;;0;break tests as approach timeout so that dont fail on slow machines;these tests were giving me regular failures on my slow laptop:- `operatormergemaxconcurrenttesttestsimpleonelessasync`- `backpressureteststestonbackpressuredrop`they both loop repeatedly looking for failure or lockup if the machine running the tests isnt fast enough then the tests timeout before reaching the desired number of loops this pr adds a break to the tests when the loop has run for 9 seconds (timeout is 10 seconds);great! ||;;;;1;1;break tests as approach timeout so that dont fail on slow machines;
3086;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;improve executorschedulertest.testonbackpressuredrop;this test fails for me occasionally on my slow laptop when full test suite run because work is scheduled for only 1ms in the future. i ve decreased the probability of this one failing by changing the schedule to 50ms in the future.;;0;improve executorschedulertesttestonbackpressuredrop;this test fails for me occasionally on my slow laptop when full test suite run because work is scheduled for only 1ms in the future ive decreased the probability of this one failing by changing the schedule to 50ms in the future;;;;;1;1;reduce probability of executorschedulertesttestonbackpressuredrop failing on slow machine;
3092;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;single.toobservable;adding  single.toobservable  as companion to  observable.tosingle .;;0;singletoobservable;adding `singletoobservable` as companion to `observabletosingle`;;;;;1;1;singletoobservable;
3093;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;fix request != 0 checking in the scalar paths of merge();requested amount could reach zero between the first check and entering the synchronized block where it has to be re-read in order to verify the scalar emission can really happen at that point  the new  testmergeasyncthenobserveonloop  test failed with  missingbackpressureexception  after ~20 rounds on my i7 4770k.  this might or might not relate to the canary failure  if combined with retry()  it could have failed over and over  but i m not sure where the worker retention might have happened.;;0;fix request ! 0 checking in the scalar paths of merge();requested amount could reach zero between the first check and entering the synchronized block where it has to be re-read in order to verify the scalar emission can really happen at that point the new `testmergeasyncthenobserveonloop` test failed with `missingbackpressureexception` after ~20 rounds on my i7 4770kthis might or might not relate to the canary failure if combined with retry() it could have failed over and over but im not sure where the worker retention might have happened;is this urgent for release or can it wait? || yes this is severe enough especially if one merges high throughput asynchronous sources before observing them on a scheduler synchronous merges or small amount of values wont trigger the `missingbackpressureexception`there is another possible issue which affected the merge() version before due to the scalar optimization it could reorder values from a source: 1 a value comes in but requested is zero therefore the value is queued2 the requested amount increases but it doesnt enter the emission loop yet3 another value comes in finds the requested to be non-zero successfully enters the emitting state and emits this second value while the first is still in the queue4 the requester also enters/signals the emitter loop and the queue is drainedapparently users of `merge()` so far didnt really mind this occasional reordering in the output ||;;;;1;1;fix request ! 0 checking in the scalar paths of merge();
3109;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;unit tests and cleanup of jctools  queues.;increased test coverage of jctools  queues and unsafe activities. fixed inconsistencies in the queues.;;0;unit tests and cleanup of jctools queues;increased test coverage of jctools queues and unsafe activities  inconsistencies in the queues;;;;;1;1;unit tests and cleanup of jctools queues;
3110;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;test coverage of rx.functions utility methods.;since these are public api methods  their expected behavior needs to be verified.;;0;test coverage of rxfunctions utility methods;since these are public api methods their expected behavior needs to be verified;;;;;1;1;test coverage of rxfunctions utility methods;
3112;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;observers package test coverage and fixes.;this includes a rewrite of  serializedobserver  to have a more cleaner exception semantics.  the  testsubscribertest  can be improved further but i ve run out of time for today.;;0;observers package test coverage and fixes;this includes a rewrite of `serializedobserver` to have a more cleaner exception semanticsthe `testsubscribertest` can be improved further but ive run out of time for today;;;;;1;1;test coverage for the observers package;
3117;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator replay() now supports backpressure (again);and applied the hardenings as well.;;0;operator replay() now supports backpressure (again);and applied the hardenings as well;ive merged this and cache() so people can look at the code and try out the snapshot versions ||;;;;1;1;operator replay() now supports backpressure (again);
"3118;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implementing the synconsubscribe;this is useful for creating an observable that reads from a data source in a synchronous manner. this is a rewrite of the  abstractonsubscribe  experimental class based on the ideas in #3003.;;3003.0;implementing the synconsubscribe;this is useful for creating an observable that reads from a data source in a synchronous manner this is a rewrite of the `abstractonsubscribe` experimental class based on the ideas in #3003;you cant delete `abstractonsubscribe` because it is part of the public api and even though marked as experimental such components can be deleted only at a major release such as 11 || experimental apis can be removed or change at any time as per the readme:> @experimental> > apis marked with the @experimental annotation at the class or method level will almost certainly change they can be modified in any way or even removed at any time you should not use or rely on them in any production code they are purely to allow broad testing and feedback || i would have expected to make such apis @deprecated for a few releases before completely removing it besides this pr just gives an alternative to another @experimental class and could live side-by-side then users could decide/vote which to keep at the next major release || @akarnokd you have a good point that the efficacy of both implementations should be compared however i do not think that we should expose multiple alternatives in the public api this ambiguous api leads to confusion and questions about the unexplained differences between one or the other implementation the pull request should not be the place for debate either (since this should be about issues with this implementation) this comparison and debate was what i was hoping to get out of opening issue #3003 would you like to open a separate issue for comparing the 2 implementations? || the latest commit adds work stealing to manage unsubscribe to avoid concurrent modification of `state` while running `onunsubscribe` concurrently with `next` (and a test to exercise) fixes issues with tabs/spaces and adds javadocs || the latest commit makes a few changes - added the `abstractonsubscribe` back into the code base the `@experimental` annotation states clearly that either of these implementations can be removed at any time so its not necessary for anything to be removed now it is up to the consumer when they chose to use a potentially unstable api - added jmh tests to compare performance against `onsubscribefromiterable` the performance is impacted in astounding ways by the additional complexity of a cleanup function this requires object initialization which the `onsubscribefromiterable` does not require - general optimizations removing a volatile and reorganizing the request loop  || @stealthcode can you give us more detail on the jmh comparison? || sure sorry for leaving that out heres the jmh report output```$ /gradlew clean benchmarks -pjmh-f 1 -tu s -bm thrpt -wi 5 -i 5 -r 1 *synconsubscribeperf*``````benchmark                                            (size)   mode   samples        score  score error    unitsrosynconsubscribeperfbenchabstractonsubscribe          1  thrpt         5 10345304158   167899030    ops/srosynconsubscribeperfbenchabstractonsubscribe2         1  thrpt         5 10315525503   519004209    ops/srosynconsubscribeperfbenchabstractonsubscribe2      1000  thrpt         5 10080651937  1249022786    ops/srosynconsubscribeperfbenchabstractonsubscribe2   1000000  thrpt         5  9676927741   799435391    ops/srosynconsubscribeperfbenchfromiterable                 1  thrpt         5 245301608512 25693364239    ops/srosynconsubscribeperfbenchfromiterable2                1  thrpt         5 261726979345 17122836564    ops/srosynconsubscribeperfbenchfromiterable2             1000  thrpt         5 256818323006 17992719065    ops/srosynconsubscribeperfbenchfromiterable2          1000000  thrpt         5 259483656124 12863102025    ops/srosynconsubscribeperfbenchsynconsubscribe              1  thrpt         5 12770780794   146195400    ops/srosynconsubscribeperfbenchsynconsubscribe2             1  thrpt         5 12306631098  2072808101    ops/srosynconsubscribeperfbenchsynconsubscribe2          1000  thrpt         5 12326658468   682619251    ops/srosynconsubscribeperfbenchsynconsubscribe2       1000000  thrpt         5 12519473508   365884932    ops/s```under flight recorder analysis both the aos and sos suffer from the cost of creating a `subscriptionlist` and allocating memory where as a the `onsubscribefromiterable` does not require adding an unsubscribe action so doesnt need to allocate i plan on testing some changes to get around this bottle neck will submit a pull request soon hopefully this upcoming change will be a private change and not have to wait until 2x || here are the updated benchmarks this paints a very different picture than last time the performance of the `synconsubscribe` is now ~  observables in ways that obviate the need to merge at all are there use cases that i am missing?that said i would rather not corrupt the api with a one-off concept of `stop()` without good reason its important that we get the api correct (even in `@experimental`)  || javadoc is now updated || :+1: reviewed the code ;api for creating safe back pressure observables;""# the problem:creating back-pressure enabled observables that produce data from a non-blocking source is hard and our current apis for creating arbitrary observables do not lend towards creating observables that respect the back pressure rules users have a choice between calling one of the observable static method to generate standard case observables using well known patterns or they can attempt to implement a responsible observable out of an `onsubscribe<t>` i will define a """"responsible observable"""" to be an observable that does the following:- calls `subscriberonnext(t)` only when the `subscribercapacity > 0` where `subscribercapacity` is the sum of the integer arguments for all invocations of `producerrequest(n)` minus the number of calls made to `subscriberonnext(t)`- calls `subscriberoncompleted()` or `subscriberonerror(e)` only once- does not call `subscriberonnext(t)` concurrentlythe onsubscribe lifecycle of a responsible observable should fit within the following lifecycle1 the `onsubscribecall(subscriber<t>)` method is invoked by the `observablesubscribe(subscriber<t>)` method2 the onsubscribe func creates a `producer` via the `subscribersetproducer(producer<t>)` method at some point in the (potentially distant) future the subscriber may call `producerrequest(n)` this signals to the observable that capacity is allocated  in the subscriber   3a values are produced via a call to `subscriberonnext(t)`   3b at some point a terminal event is emitted via `oncompleted` or `onerror`this allows for many different variations of control flow given that onnexts could possibly be scheduled data could be pre-fetched excess data could be batched or dropped etc# proposalwith this ground work in mind i would like to start a discussion about a general framework that correctly models the various use cases particularly with respects to the following requirements:- capable of paginating data across multiple requests- batching requests- hot and cold data sources- async and blocking onnexts## naive implementationuser provides callbacks that the framework will call between each of the steps above that is1 observable calls `onsubscribecall(s)`2 the frameworks onsubscribe calls: `s datastate  onsubscribegeneratorcall()`3 next the onsubscribe calls: `subscribersetproducer(p)` setting a framework producer4 at some point the request is received by our producer `prequest(n)`5 then the framework will call the user provided request callback and store the new resultant `datastate` for future requests `datastate  onrequestcallbackcall(datastate n s)`obvious short comings of this approach: order may not be preserved across multiple requests if the `onrequestcallback` schedules the onnext also onnexts may be concurrent so the subscriber must be wrapped with a serializing subscriber also a case could be made that many observables created should specify the backpressure strategy any thoughts are welcome "";""whats wrong with [abstractonsubscribe]( in addition there is a pr #2813 which features a batching-capable producer-construction also you can read my blog about [advanced rxjava]( which explains the concepts and shows examples about how one can build producers and thus operators and `observables` || @akarnokd the purpose of this issue is to initiate a discussion and refine the concepts in abstractonsubscribe and the abstractproducer both of these facilities are currently annotated `experimental` the goal here is to refine them to something that supports the various use cases in an approachable mannersome items that need some work on the abstractonsubscribe:- does not support batching multiple requests- generating data in a paginated way is difficult with the api since for each request there is an invocation of the user callback i suspect this is where the phases are intended to help- the decoupling of the onnext to the subscriptionstate and the onnext to the subscriber makes stacktraces and errors harder to reason aboutthe [abstractproducer]( is clearly a better approach to me for every `request(n)` call there is a call to the `onrequest` callback this makes it easier to paginate data and also to respond to requests asynchronously however i think that async responses to a request would cause interleaving batches to be processed in the naive implementation @benjchristensen and i have been discussing this problem and believe that the user would have to account for this by appending to a queue and then draining this could probably be made first class for some use cases if thats whats needed for responsible observables from non-blocking sources || @benjchristensen and i worked on the following examples and we would like input on the following apis we have broken apart this issue into what we think are 2 primary use cases firstly there is the case where data is generated asynchronously from a non-blocking source secondly there is an api for writing responsible observables from synchronous sources this looks very similar to the abstractonsubscribe the async case is illustrated in code below we are considering a system which calls your function every time there is a call to `producerrequest(n)` and the users function would return an `observable<t>` the returned observable would then be eagerly subscribed and concatted (to ensure ordering is maintained) ``` java// to illustrate method signature in below exampleclass observableasync {    /**     * has an overload for handling request(longmax_value)     * it is possible to chunk an infinite request and make a requestfinitefunc     * play nicely     *     * note: this assumes serialized request calls per subscriber this means we      * will have to do thread stealing (essentially merge)    */    public static <t> observable<t> createasynchronous(        func0<s> generatorfunc        func2<s long requested observable<t>> requestfinitefunc        func1<s observable<t>> requestinfinitefunc        action1<s> onterminate) {}}// data state class used in the below examplepublic class restclientstate<t> {    private client client  /* your favorite async client */ null    private integer lastindex  0}// async exampleobservable<t>createasynchronous(    () -> { new restclientstate<foo>(url) }    (restclientstate<foo> state long requested) -> {        int i  statelastindex        statelastindex  i + requested        observable<foo> obs  stateclientgetrange(i i+requested)        return obs    }    (restclientstate<foo> state) -> {        observable<foo> allofthem  stateclientgetall()        return allofthem    }    (restclientstate<foo> state) -> {        stateclientfree()    })```the synchronous case (below) is a modification from the existing designs embodied in the `abstractonsubscrbe` the highlight of the changes are as follows - changed the `subscriptionstate` to be agnostic of the data state this results in the handler passing in the datastate and returning a datastate- changed the data generator func to call onnext oncompleted and onerror straight into an object that wraps the subscriber this object would prevent calling onnext more than once per invocation of the users func- generator func no longer has access to the `subscriber```` javaclass observablesync {    public static <t> observable<t> createsynchronous(        func0<s> generatorfunc         func2<s subscriber<t> s> nextfunc         action1<s> onterminate) {/**/}    // functional equivalent overload but no need to return    public static <t> observable<t> createsynchronousstateful(        func0<s> generatorfunc         action2<s subscriber<t>> nextfunc         action1<s> onterminate) {/**/}}list<foo> mylist  null // // sync exampleobservable<foo>createsynchronous(    () -> { mylistiterator() }     (iterator<foo> state subscriber<foo> child) -> {        if (!statehasnext())            childoncompleted()        // cannot onnext more than once from func        childonnext(statenext())        return state    }    (it) -> {itfree()}    )subscribe()``` || > there is a call to producerrequest(n) and the users function would return an `observable<t>`how will you make sure the observable contains exactly n elements? what kind of observable would you create and return?> `func2<s integer requested observable<t>>`requested amounts are longs || @akarnokd the return type would be a plain ole `rxobservable` (kinda like a pojo but without the j) we should be able to eagerly subscribe to all emitted observables then serialize their outputs using buffers i imagine these would be calls using rxnetty rxjdbc wrapped futures etc do we have to ensure that the observable contains exactly n elements? if they write an irresponsible observable then they get a `missingbackpressureexception` its possible to subscribe a take(n) to the observable but then we are getting into the business of enforcing that all observables play nicely when its relatively easy to follow the documentation i have edited the comment to correct the types || i think that an implementation for #3017 should help serialize the output from multiple observables || @akarnokd do you disagree with anything here in principle? if not are you already working on refactoring the synchronous `abstractonsubscribe` or working on the async case? id like to coordinate our efforts to make sure we arent both working on the same piece  || im not working on any of the cases and im not planning it either || i strongly agree that we need to improve how `observablecreate` can be used to generate correct `observable`s with and without backpressure these """"abstract"""" classes are the base but i suggest we need to incorporate them into the observable api such as this:##### non-backpressured push sourcesthis is for pure push sources that dont have backpressure``` javaobservablecreateeventstream( defaultbackpressurestrategy)```for example:``` java// mouse event listener with default backpressure strategy to dropobservablecreateeventstream(o -> {          mouseeventlisteneraddlistener(l -> oonnext(l))} onbackpressuredrop)```##### backpressured synchronous pull sources (batched stream)this is for data sources that can be pulled synchronously such as an `iterable` or other similar data structure``` javaobservablecreatesync()```##### backpressured asynchronous pull sources (batched stream)this is for data sources that can be pulled asynchronously such as network io async file io or retrieving from queues across thread-boundaries etcthis is very common and very hard to do right ``` javaobservablecreateasync()```##### backpressured asynchronous pull sources (single item)this is actually for returning a `single` but im suggesting we have a factory method on the `observable` because that is the common place to start from or we still return an `observable` but it is only a single itemthis is the same behavior as the `createasync` except that it is far easier since it only fetches a single item this is the most common case for async request/response``` javasingle<t> observablecreatefetch()```###### summaryif we can improve how these all work it will greatly simplify creation and use of observableare there use cases or variants im missing? what should we name them? what are the method signatures we should have for each? || we have `synconsubscribe` and `asynconsubscribe` is there anything else? || i think we should come up with factory methods on observable to expose these abilities alongside the default create what do you think the right names are? || `generate` and `generateasync` || how about something starting with create so that people find it alongside the create method in javadocs and ide code-completion? we want to nudge people to using these instead of normal create also i dont want to confuse with the rxnet/rxjs generate as they arent exactly the same (though the sync one is similar)  ||  a quick note that i dont think the names `synconsubscribe` and `asynconsubscribe` are great in that the names do not characterize their functionality to my mind they are not natural duals which is suggested by the naming i also note that `asynconsubscribe` is not practical at the moment without a request batching operator (a downstream `filter` for example may cause async requests for one element at a time at the source) || itd be a good idea if we  these inefficient `producerrequest(1)` cases and batched them more intelligently for instance when observeon request behavior devolves into request 1 patterns initial names that come to mind `createsynchronoussource` and `createasynchronoussource`but considering @davidmoten s input perhaps the existing names are not indicative of their usage `synconsubscribe` is intended for usage generating data from a synchronous data source while the `asynconsubscribe` is intended to consume data from a potentially asynchronous data source the confusion may come from a lack of clarity in their usage that said would you agree with `observablecreatefromhotproducer()` (which would use a `synconsubscribe`) and `observablecreatefromcoldproducer()` (`asynconsubscribe`)? || we have `create(synconsubscribe)` and `create(asynconsubscribe)` in 1x do you want to pursue the remaining generator modes for 1x?- signal  0 or 1 element or an error in push fashion (for observable and single) use case: working with classical callback-based apis- signal 0 to n elements followed by an error or a complete signal in a push fashion use case: callback-based apis and listeners that produce multiple values || im closing this issue due to inactivity if you have further input on the issue dont hesitate to reopen this issue or post a new one || "";1;0;implementing the synconsubscribe;"
"3121;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;improve performance of newthreadworker  disable search for setremoveoncancelpolicy() on android api < 21;3119.  this pr adds methods for detecting android api version and disables  newthreadworker.tryenablecancelpolicy()  on android api < 21 which has significant performance cost on android.  pr also improves performance of  newthreadworker.tryenablecancelpolicy()  via caching reflection.;;3119.0;improve performance of newthreadworker disable search for setremoveoncancelpolicy() on android api < 21;3119this pr adds methods for detecting android api version and disables `newthreadworkertryenablecancelpolicy()` on android api < 21 which has significant performance cost on androidpr also improves performance of `newthreadworkertryenablecancelpolicy()` via caching reflection;checked on jvm (java 8) android 412 (api 16) android 511 (api 22) ||  all comments removed test with reflection added more javadoc and comments tests are now compilable on jdk 6 (didnt check but they should work fine) @akarnokd @jakewharton ptal  || great ;newthreadworkertryenablecancelpolicy doing costly reflection on android;i was  analyzing startup time in the ny times android app and started method profiling on startup using android device monitor  total time from the beginning of the application class to end of oncreate for first activity is roughly  22seconds diving deeper i was able to observe that `newthreadworkertryenablecancelpolicy` was taking 1200ms to execute with the offending line being  `for (method m : execgetclass()getmethods())` (1017ms)diving deeper shows a call to `collectionutilsremoveduplicates (992 ms)`  which will call `collectionsort` (719ms) & `reflectcompare`(259ms)tryenablecancelpolicy has the following comment: ``` /**     * tries to enable the java 7+ setremoveoncancelpolicy     * <p>{@code public} visibility reason: called from other package(s) within rxjava     * if the method returns false the {@link #registerexecutor(scheduledthreadpoolexecutor)} may     * be called to enable the backup option of purging the executors     * @param exec the executor to call setremoveoncaneclpolicy if available     * @return true if the policy was successfully enabled      */ ```i tried creating a scheduler from an executor but still hit the offending code  is there a way to avoid this code or fix the large performance hit that it is causing?;""woah if the signature of the to-be-reflected method is known why is a direct lookup not being done? || @digitalbuddha you can use the system property """"rxschedulerjdk6purge-force"""" set to """"true"""" to avoid the loop the reason for the loop is to avoid nosuchmethodexception being thrown on jdk 6 which is more costly than looping through ~70 methods although i admit evaluating that all the time is unnecessary as executorsnewscheduledexecutor() wont change is ability during runtime || thankfully that property _just_ squeezes under androids 31 character max at 29 chars! || can we use `platformdependentisandroid()` to default this to `true`? || my google search indicates the method `setremoveoncancelpolicy` is supported from api level 22 if there could be a way to discover the api level programmatically and cross-platform safe then sure || the `androidosbuildversion` class has an `sdk_int` int constant which can be read the presence of the class could replace the check for `androidappapplication` || @akarnokd what do you mean by >  cross-platform safe? `androidosbuildversion` is safe to call for all android versions documentation:  || android is one platform || great would you like to submit a pr? || just pushed the pr #3121android [supports `scheduledthreadpoolexecutorsetremoveoncancelpolicy()` since api 21]( || little gist for those who want to fix this in android app with rxjava:  || your gist says """"static initializer block"""" and then proceeds to use an instance initializer block || such a stupid mistakeuh  "";1;0;improve performance of newthreadworkertryenablecancelpolicy()disable search for scheduledexecutorservicesetremoveoncancelpolicy() on android api < 21;"
3129;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix retry with predicate ignoring backpressure.;apparently  we forgot about this operator. the backpressure handling is a trivial case with  producerarbiter . i ve also fixed some apparent code indentation error.  originally reported in #3128 with a test case which i didn t include due to its lengthy nature  however  i did run the test manually and both passed after the fix.;;3128.0;fix retry with predicate ignoring backpressure;apparently we forgot about this operator the backpressure handling is a trivial case with `producerarbiter` ive also  some apparent code indentation errororiginally reported in #3128 with a test case which i didnt include due to its lengthy nature however i did run the test manually and both passed after the fix;;missingbackpressureexception when using retry with predicate;in some production code i noticed that it is possible to create a situation where the retry method that accepts a predicate produces a missingbackpressureexception however other retry methods do not produce such an exceptionive created a small test case here: for this being a non-deterministic test but on my laptop the `testbackpressurepredicateretry` test will reliably fail due to missingbackpressureexception with the trace below however the `testbackpressurenormalretry` test will run for 1 minute without producing this exceptionadmittedly this might be a convoluted setup but it reflects a situation i had in some production code essentially i have a flow where for each event produced by an observable i need to perform some io with retries so ive spread that io work over a scheduler the io work produces many individual events in my test case imagine this inner observable is performing io:``` javaabstractonsubscribecreate((state) ->            stateonnext(2l))```everything in this flow should respond to back-pressure through the use of `abstractonsubscribe` however im running into the issue described here when using retry with a predicate function```rxexceptionsmissingbackpressureexception        at rxinternalutilrxringbufferonnext(rxringbufferjava:349)        at rxinternaloperatorsoperatormerge$mergesubscriberqueuescalar(operatormergejava:345)        at rxinternaloperatorsoperatormerge$mergesubscribertryemit(operatormergejava:328)        at rxinternaloperatorsoperatormerge$innersubscriberonnext(operatormergejava:802)        at rxinternaloperatorsoperatorsubscribeon$1$1$1onnext(operatorsubscribeonjava:76)        at rxinternaloperatorsoperatorretrywithpredicate$sourcesubscriber$1$1onnext(operatorretrywithpredicatejava:113)        at rxobservablesabstractonsubscribe$subscriptionstateaccept(abstractonsubscribejava:535)        at rxobservablesabstractonsubscribe$subscriptionproducerdonext(abstractonsubscribejava:369)        at rxobservablesabstractonsubscribe$subscriptionproducerrequest(abstractonsubscribejava:340)        at rxsubscribersetproducer(subscriberjava:209)        at rxobservablesabstractonsubscribecall(abstractonsubscribejava:192)        at rxobservablesabstractonsubscribe$lambdaonsubscribecall(abstractonsubscribejava:275)        at rxobservableunsafesubscribe(observablejava:7689)        at rxinternaloperatorsoperatorretrywithpredicate$sourcesubscriber$1call(operatorretrywithpredicatejava:120)        at rxschedulerstrampolinescheduler$innercurrentthreadschedulerenqueue(trampolineschedulerjava:80)        at rxschedulerstrampolinescheduler$innercurrentthreadschedulerschedule(trampolineschedulerjava:59)        at rxinternaloperatorsoperatorretrywithpredicate$sourcesubscriberonnext(operatorretrywithpredicatejava:77)        at rxinternaloperatorsoperatorretrywithpredicate$sourcesubscriberonnext(operatorretrywithpredicatejava:45)        at rxinternalutilscalarsynchronousobservable$1call(scalarsynchronousobservablejava:46)        at rxinternalutilscalarsynchronousobservable$1call(scalarsynchronousobservablejava:35)        at rxobservable$1call(observablejava:144)        at rxobservable$1call(observablejava:136)        at rxobservableunsafesubscribe(observablejava:7689)        at rxinternaloperatorsoperatorsubscribeon$1$1call(operatorsubscribeonjava:62)        at rxinternalschedulersscheduledactionrun(scheduledactionjava:55)        at javautilconcurrentexecutors$runnableadaptercall(executorsjava:511)        at javautilconcurrentfuturetaskrun(futuretaskjava:266)        at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskaccess$201(scheduledthreadpoolexecutorjava:180)        at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:293)        at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1142)        at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:617)        at javalangthreadrun(threadjava:745)```;that particular retry overload doesnt support backpressure ill post a pr that fixes it ||  in #3129 it may take some weeks until 1014 is released though || @akarnokd thank you for the quick response and fix i tried your patch with my test and it appears to have fixed the issue  fixed via #3129 and patch delivered in 1014 ||;1;0;fix retry with predicate ignoring backpressure;
3141;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;improved scheduler.worker memory leak detection;the former executor-based check instantiated the wrong worker. in addition  i ve refactored the common parts  added check for periodic task retention (after the first round) and added the checks to computation scheduler test as well.;;0;improved schedulerworker memory leak detection;the former executor-based check instantiated the wrong worker in addition ive refactored the common parts added check for periodic task retention (after the first round) and added the checks to computation scheduler test as well;;;;;1;1;correct scheduler memory leak test for from(executor) and added checkfor periodic tasks retention as well;
3144;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove redundant cast in exceptions;;;0;remove redundant cast in exceptions;;;;;;1;1;remove redundant cast in exceptions;
"3147;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove unnecessary static modifier;p.s.  @benjchristensen @akarnokd sorry for large amount of simple pull requests  i m doing full code review of rxjava sources  and i ll create prs and issues during this review.  i ll try to group changes by themes so it will be easy to review them. looks like this adventure is going to be part of #3145!;;3145.0;remove unnecessary static modifier;ps @benjchristensen @akarnokd sorry for large amount of simple pull requests im doing full code review of rxjava sources  and ill create prs and issues during this reviewill try to group changes by themes so it will be easy to review them looks like this adventure is going to be part of #3145!;""if it were only me id accept cosmetic changes such as this but history tells me not to  || @akarnokd why? sad that `javac` is not strict enough and allows such things we can add `checkstyle` with only java-lang rules and remove all these things from the code but last time i suggested to add `checkstyle` @benjchristensen was not very happyi understand that rxjava is not """"my project"""" and i cant just come and force you to use """"my codestyle"""" (which is actually just standard java codestyle) so if you dont want to accept such changes  its okay ill stop doing such prs and will report only major issues || i like this pr too much im going to merge it ) || > i like this pr too much im going to merge it ):-) || "";expanding community involvement & contribution;""earlier this year we expanded the committers of rxjava to include non-netflix engineers id like to now further explore how we can broaden community involvement and lessen dependence on me the recent [""""rxjava truck factor"""" issue]( was a reminder of this topic and pushed several of us inside netflix to raise the priority on tackling this first a note on how great the community has been thus far! we have had great [contributors]( several having contributed significant time effort and skill and without whom rxjava would not be as good as it is many who are not shown with """"code contributions"""" have helped immensely in answering questions on twitter stackoverflow google groups blogging speaking at meetups and conferences or helping build reactivexio in short the community around rxjava is already greathowever id like to achieve a few things:1) make it possible for others to fulfill the """"release engineer"""" role im still playing2) ensure there are no irreplaceable people on the project 3) improve the reliability for getting code reviews and questions answered in a reasonable time frame4) improve the release cadence so it is more reliable and less dependent on me getting bursts of time 5) make it easier for community to get involved by pointing to where they can help in ways other than writing code6) find a way to recognize people for involvement in the many important areas other than lines of code committed a few ideas on making these happen include:- more engineers from netflix with time formally allocated i will bootstrap them and ensure they have everything needed to do releases without me- more comprehensive contributingmd (rust has a good example:  ask community to help with stackoverflow google groups issue/pr triage twitter (and perhaps recognize people somehow who do these things?)a key thing i want people to understand is that writing code is actually the easiest part of maintaining a project like this the lifecycle is far harder and more time consuming this includes:- code reviews- answering questions- deciding whether a change should be made or not- discussing design decisions and deciding which tradeoffs to make- balancing change with stability- writing documentation- debugging issues - replicating bugs with unit tests- answering more questions- tutorials blogs speaking training etcall who are interested in rxjava what ideas do you have for helping us improve and achieve the above? what else should we pursue and improve?"";""netflix engineers involved in this discussion include: @stevegury @abersnaze @stealthcode @mattrjacobs i am making sure they have all necessary credentials for travis bintray and maven central so that in my absence if there are issues with the automated pipeline they can debug and fix additionally they will get the twitter credentials so they can post to twitter for releases and other such information we are working amongst ourselves to allocate time each week per engineer to help with code reviews (pull requests) github issues and releases || various places of community engagement:google group:       || benjchristensen im not from netflix and would like to contribute to rxjava can you pls direct me  how to contribute to rxjava?tkssudar || @sudaredd  is a start (we could probably add more info to that page) || i like this guys! kudos! rxjava is a huge effort @benjchristensen needs all the help we can give himobviously i expect i will get a cool netflix t-shirt as bug hunter funny conference speaker and books author    || > i expect i will get a cool netflix t-shirt as bug hunter funny conference speaker and books authorwell see what we can do! :-)@sudaredd the link @davidmoten gave is the current starting point im trying to mature that with this discussion and figure out how we can improve community engagementthe best way to get started in the project is to help us answer questions at the many places above help triage and prove bugs (and fixes) and improve documentation || anyone have suggestions on how to execute on my stated goals? || here are my 2 cents:- knowing that netflix is offering more full-time people to the project i think that the _releasing_ task should be still safely handled by netflix- from a _coding_ point of view github should handle the contribution recognition properly: pr comments tech discussions will shows active users- from a _supporting_ point of view stackoverflow offers _tags_ and _top users_    btw congrats @davidmoten! @mrsasha we definitely need to spend more time on so    - we could use the wiki to create a collection of useful teaching contents: videos tutorials example and try to involve those authors- a bit of marketing promoting this new project with android weekly for instance and other equivalent java communitieswhat do you think? || > anyone have suggestions on how to execute on my stated goals?->> 3) improve the reliability for getting code reviews and questions answered in a reasonable time framethere are **21 open pull requests** some of them are really old also there are **166 open issues**and looks like that at the moment the only active (comments code reviews and prs almost every day) person in the project is david karnok @akarnokd and i guess he has other things to deal with so it will be good to **add at least one another active person** to the project  || @artem-zinnatullin that is certainly a motivating factor behind adding netflix engineers to the project and by expanding the community involvement we want to insure that issues and pull requests are responded to in a timely manner  || thanks @hamen for the input> i think that the releasing task should be still safely handled by netflixagreed> from a coding point of view github should handle the contribution recognition properly: pr comments tech discussions will shows active usersagreed though would it be helpful to call out in a """"team"""" doc those who are actively engaged so others know who to reach out to for different aspects of the project? for example those for documentation build tooling release etc?> from a supporting point of view stackoverflow offers tags and top usersgood point though not everything is on stackoverflowthe part im wondering about is whether it makes sense to have individuals called out as being part of """"the team"""" if someone is involved but then drifts away perhaps we have a 3 month expiry so that if we havent seen someone for a while we move them into """"emeritus"""" status so we recognize their involvement from the past but let people know they arent actively involveddoes something like that make sense? || had a working meeting at netflix today to start transferring domain knowledge that resulted in [v1014]( being released without me being the one pushing the buttons going forward the intent is to have the netflix rxjava team as:- @stevegury - @mattrjacobs - @stealthcode - @abersnaze - @benjchristenseni am bringing them up to speed on release and communication roles and they will start involving themselves in pull requests over the next week we are going to triage the backlog of open issuesthis should help address the first 4 goals:> 1) make it possible for others to fulfill the """"release engineer"""" role im still playing> 2) ensure there are no irreplaceable people on the project > 3) improve the reliability for getting code reviews and questions answered in a reasonable time frame> 4) improve the release cadence so it is more reliable and less dependent on me getting bursts of > time still need to figure out the others  || > if someone is involved but then drifts away perhaps we have a 3 month expiry so that if we havent seen someone for a while we move them into """"emeritus"""" status so we recognize their involvement from the past but let people know they arent actively involvedagreed we could schedule """"involved developers"""" list updates every quarter as a """"development task"""" (a github issue could work)> good point though not everything is on stackoverflowi have asked github support guys if they have some kind of statistics for repo wiki we could have users helping on the wiki and it will be fair to recognize them> had a working meeting at netflix today to start transferring domain knowledge that resulted in v1014 being released without me being the one pushing the buttonsvery nice guys! updating `buildgradle` right nowlooking forward || github reply came in: its not possible at the moment we will figure out something else then || from the """"release engineering"""" point of view maybe it would be useful to schedule some kind of release runs where a few people would go through prs and issues and try to solve them before the release and triaging the old ones to see if theyre still applicable or not? like a tentative release every month and a week before that is just for issues and open prs?as for contributing i might have missed it but i didnt see a style guide anywhere is there one? || not sure of the actual entity and library impact but i think @davidmoten helped quite a bit in this last period || id like to revisit this discussion its about 6 months on from the initial discussion and it seems that @akarnokd is still the only _active_ collaborator on the project ive had side discussions with a lot of fellow engineers and some are starting to worry about the future of this project given the passiveness from netflix on this since @benjchristensen left 20 doesnt seem any closer with only three commits since october and the future beyond that seems largely unclear (especially in regards to java 9s flow api)this becomes particularly obvious when you consider that there was an agreement some time ago that :+1:s from two collaborators are enough to get something merged but theres only ~two actively reviewing collaborators period there are **31** open prs and a further **160+** open issuesim not sure what the solution to this is but the current trajectory seems that the project is beginning to stagnate due to a lack of active maintainers and leadership# some stats since august 1st 2015generated from a script i wrote up for this comment:  commits to 1x_whos moving the project forward_```122 akarnokd36  stealthcode23  abersnaze23  artem-zinnatullin13  zsxwing8   davidmoten5   davidmgross5   stevegury3   hyleung3   turbo872   jakewharton2   vqvu2   chaoba2   benjchristensen2   vanniktech```### comments on issues_whos maintaining the repo and engaging the community_```224 akarnokd102 benjchristensen76  davidmoten56  artem-zinnatullin28  stealthcode28  zsxwing26  jakewharton19  abersnaze13  thomasnield10  headinthebox8   srvaroa8   nachosoto8   chaoba7   niteshkant6   eirslett```### comments on prs_whos reviewing code_```27  akarnokd26  artem-zinnatullin10  davidmoten7   thomasnield4   zsxwing3   srvaroa2   jakewharton2   stevegury1   johnwowus1   msavitskiy1   bcorne```### opened prs_whos moving the project forward_```18  akarnokd2   davidmoten2   artem-zinnatullin1   thomasnield1   johnwowus1   msavitskiy1   myarea511   bcorne1   srvaroa1   achinthagunasekara1   chaoba```### total contributions```391 akarnokd107 artem-zinnatullin104 benjchristensen96  davidmoten64  stealthcode45  zsxwing42  abersnaze30  jakewharton21  thomasnield12  srvaroa11  chaoba10  stevegury10  headinthebox9   davidmgross8   nachosoto```(this weighs a pr equal to comments which is a little misleading i dont know what fair weights would be but considering prs are the lifeblood of the repo akarnokds factor would be more through-the-roof than it already is) || chiming in from ny times we were one of the early adopters and would hate to see project stagnate as we are very heavily invested artem was recently hired by my team (framework) wed love to be more involved as contributors/collaborators  to this project  || i read every issue and review every pr but refrain from commenting on 99% of them since my only issues are nitpick or style related which is just annoying (to other contributors) and theres no other value commenting since im not one of the contributors whose votes are requiredas a non-contributor reviewer though its annoying to review every pr only to see them sit for long periods of time || yes 20 is standing still maybe its too big for anyone to review it> 20 doesnt seem any closer with only three commits since octoberand 11 other waiting in line i gave up on it because fixes started to depend on the order the prs have to be merged and i dont want to rebase all the time> as a non-contributor reviewer though its annoying to review every pr only to see them sit for long periods of timeas an active contributor it makes me annoyed having things sitting there as well i lately tend to forget what fix i posted to what project and what version and sometimes find myself unable to move because a fix or the addition of some utility in one pr is required by some other prin addition things have evolved beyond my 20 implementation over in [reactive-streams-commons]( project but i have hard time to imagine how those enhancements will ever get back into rxjava (any version) at the momentthe policy on the review process really slowed things down im on the favor of merge first discuss later since there is the release-gate as the final resort to stop something very wrong but if rxjava went on the release-early release-often path even that wouldnt be an issuecertainly @zsxwing (contributor so his :+1: counts)  has become more active recently but generally @artem-zinnatullin does a good job at review too i suggest accepting @artem-zinnatullin s :+1: also towards merging a pr of course due to timezone differences some non-trivial prs may need to wait 16 - 24 hours so all contributors have a chance to look at iteven though this speeds up merging prs the release right is still in netflix hand (but technically its just pressing a button)the benefit of having neflix banner over the project is that developers tend to chose libraries from big names over unknown eastern european solo guy but the drawback is that the project mostly mirrors the internal expectations and requirements of netflix own use and involves the **risk** that their use breaks due to the community moving into a different direction the other side of the **risk** is that netflix cant cherry-pick fixes to support their own process from a free-running project with intertwined fixes and enhancementsive been thinking a lot about forking rxjava lately which i technically did with the [rxjava 2 backport]( and the [jdk 9 conversion]( (thus im covered) but rxjava is the foundation to many other projects rxnetty rxandroid rx that have to decide to switch as well otherwise any fork without them is practically useless for real world use this affects 1x mostly because reactive-streams is general enough you can have interoperating implementations thus using the rxjava 20 backport rsc project reactor or akka-streams mixed is quite possibleso whats the solution? as microsoft let rxjs go maybe netflix should let rxjava go or at least allow pressing the release button by other contributors || ive been contributing for about two years now to this project and we do seem to be in a slow patch the project is big enough that a full-time investment from netflix wouldnt go astray if they seek to have input in such a potentially fast developing codebase (thanks largely to @akarnokd) ive been very happy with @akarnokds high quality major contributions and oversight hes clearly able to spend a lot of time on the project and id support him having more freedom with merging prs two thumbs up from committers is clearly not working well enough i assume the netflix committers have other tasks on their plate (as do most of us!) a big thank you to @zsxwing for weighing in a lot more recently and to new guy @artem-zinnatullin for throwing himself at stuff toolike @jakewharton i read every issue and pr that comes through and review and comment on the ones that interest me id expect non-trivial prs to be open for a short period to attract input and review but after that period i think @akarnokds judgement generally is too good to prevent him from merging theres nothing stopping somebody saying """"dont merge this for a week or so i want to have a good look at it""""recent history has curbed my contributions i should add the version 20 explosion of commits stopped me in my tracks (so much to review and why contribute to 10 if 20 is just around the corner) as did the introduction of a bunch of new committers (curious about a new dynamic) 10 seems alive and well still so i may contribute more to it@akarnokd has some confidence in 20 leave the merges to him and push out an alpha release? might at least attract more review and experimentation if at that pointid definitely support much more frequent releases and think its time netflix shared the release button or dedicated resources to ensure that this happens || be assured that netflix is committed to making rxjava a success maybe more than any other company most of our infrastructure rely on it and we dont want to see it fail @benjchristensen left a couple of months ago and we needed time to reorganize the teams around rxjava im not opposed to giving more freedom to other external contributors i need to discuss this internally with the managementi think that @akarnokd is right to say that having netflix behind rxjava give more credibility to the project and on the other hand we want to weight in the technical decision made about the project || @stevegury thats reassuring to hear i dont think the release frequency has been much of a problem though there have still been a good few releases in the past 6 months i think that giving collaborators a little more involvement in the release process is good but i think the most significant missing element right now is proper stewardship of the repo aside from @benjchristensens code contributions he was a great shepherd of the project itself all issues were triaged issues and prs were discussed at length others were called upon for their input and the direction of the repo was largely clear in a sense the train was always chugging on i think its safe to say that much of rxjavas flourishing over the past 2-3 years was due to that incubationthe impression i have is that other netflix engineers were supposed to step into that maintainer role after ben left but that doesnt appear to have happened (at least not nearly to the same degree) i dont know who the right person would be for it if not netflix (though there are some obvious potential candidates here) but i would be interested to hear your thoughts on it || **not yet** nearly as the same degree indeedill make sure to dedicate myself more on this task || 2014 was rxjavas year on tweeter (2015 is dockers) and countless developers have seen the greatness of declarative and reactive programmingas a simple noname developer among many i dont care if netflix is behind rxjavaim already using the stuff it kicks asswhat i want is bug fixes more performance great apis some new nice features if possible but not bloat high quality code simple and painless upgrade paths maintainers who care and know what they are doing im really grateful to microsoft to have invented rx and to netflix to have brought it to java but in case the ship was sinking or slowing down to a crawl and there was a healthy fork battle tested going forward and maintained by a few caring and dedicated maintainers (even if one of them is living in some unheard of village in eastern europe) that would just require a package change to join  i would jump ship in an instant just felt like chiming in what other rxjavas users might think please excuse me if im being rude (that was not my intention)  || @stevegury do you think you/netflix would be able to put together some more concrete plans going forward?  || yes! || closing in favor of #4013 || "";1;0;remove unnecessary static modifier;"
3149;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;scheduler shutdown capability;repost of #3022.;;3022.0;scheduler shutdown capability;repost of #3022;we still need to decide on the reset vs shutdown distinction:  is your perspective? do you have a strong opinion one way or another? || with start/shutdown there is a clear intention to stop everybody with reset any running code could respawn the threads and the new threads will resume leaking i prefer start/shutdown || agree it will be great to have ability to stop schedulers and prevent new workers from scheduling for apps that run in servlets and other similar containers which can be stopped externally || im happy with the start/shutdown pair which seems to support my primary use cases:- resource release on webapp shutdown in container- resource release on completion of programs run by a framework that looked for unreleased threads (maven)- on ad-hoc basis ensuring schedulers are not running in the background on entry into a unit test (when running a suite)thanks @akarnokd! || the `start`/`shutdown` semantic looks good to me more explicit best enforcement of shutdown   and good compatibility with items mentioned by @davidmoten (which are pretty much our use cases as well)    || ill following this thread to be notified when its merged thanks @akarnokd  || @benjchristensen do you consider we have consensus on naming? after that itd be showtime     ||   because so many customers from us run into this || @daschl   i would like a bit more context on what the goal is for the scheduler shutdown capability @davidmoten and any others please respond thanks > resource release on webapp shutdown in containerwhat resources exactly need to be freed? shutting down the schedulers would prevent new workers from being scheduled and would free up threads from the executor is this the desired behavior or is there some side effect that you are looking for?> resource release on completion of programs run by a framework that looked for unreleased threads (maven)could anyone name a framework thats impacted? is the concern that open threads keep the framework from properly terminating?> on ad-hoc basis ensuring schedulers are not running in the background on entry into a unit test (when running a suite)would the `testscheduler` solve this problem for you? this doesnt rely on singleton values and can be used to precisely test scheduling behavior  || @stealthcode i can answer the question 2 i hope it help you could anyone name a framework thats impacted? is the concern that open threads keep the framework from properly terminating?- couchbase java sdkcb sdk are not able to finish some of they own threads because it is referring rxcomputationthreadpool threads who cant be finishedyou can see more details about how this issue are affecting this framework here || @stealthcode i can give you the answer to your questions tooid like to use rxjava in the container (eg id like to use jersey rx client on tomcat) unfortunately it is impossible to shutdown _rxcomputationthreadpool-*_ threads and container has memory leaks that causes that rxjava is inapplicable for my purposes :( and in my case - regarding question 1 - yes shutting down all schedulers permanently is a desired behaviour and testscheduler is not a solution so im really looking forward to seeing this pr accepted and released! || @mjakubowski84 :+1:  similar case here || @mjakubowski84 understood regarding the testscheduler - this is meant for use in tests and highly recommended when it comes to a container you would definitely want to use a real scheduler so what i hear is that there is no desire to resume the scheduler once it is shut down my concern is that by offering a `schedulerlifecyclestart()` method we are inviting non-deterministic behavior in the case that someone wants to use this to teardown and then resume (in integration tests for example) would it be acceptable to remove the `start()` method from the public interface and rename `shutdown()` to `teardown()` to more accurately describe the intent? || i dont have strong opinion between shutdown/teardown`teardown` makes the intent clearer but `shutdown` is more idiomatic (in the context of java executor)otherwise the code lgtm  another thing if we want to be more java idiomatic maybe hiding the `start()` is the right thing to doit will also have the benefit of avoiding bug by misusage of the library (calling `start()` after a `shutdown()`) || i can make `schedulersstart()` package private so the tests can use it but i the `scheduler` implementations have to keep their start public || please do i believe that would be better || done || @akarnokd @stevegury folks do you think its possible to get this into 1015? || @akarnokd thanks  || i think this is fine  do you guys have a plan date to merge it? || @akarnokd i think its appropriate that you merge this pr since you are most familiar with this code if you think you are happy with it then feel free  || oh sorry didnt recount the number of likes merging || where can i get the latest build with this fix? maven central is still at 1014 || @chiangh123 you can clone the project and build it from master good luck :) || `rxjava` uses bintray for binaries and also publishes snapshots in jfrogs oss artifactory so you can add the following repository to your `pomxml`:``` xml<repository>  <snapshots />  <id>snapshots</id>  <name>libs-snapshot</name>  <url> that you should be able to depend on rxjava `1015-snapshot` ||;scheduler shutdown capability;this comes back from time to time (#1730): some containers when removing rxjava enabled applications expect it to shut down all its threads but by default computation threads cant be shut down manually and io threads take 1 minute to shut down on their own this pr adds the capability to make them shut down their worker threads more eagerly since such shutdown would be terminal and thus break any subsequent test a restart capability is requiredtherefore ive introduced the optional `schedulerlifecycle` interface which if implemented by a scheduler makes it eligible for the `schedulers` factory to trigger a shutdown or restart for all kinds of schedulersnaturally this implies some extra cost:- the underlying pool of the computation scheduler is no longer constant and involves a volatile get every time a worker is requested i havent benchmarked this but it just adds a cheap load on x86 and shouldnt be a performance hit- since we need to track all threadworkers of the io scheduler this involves a `compositesubscription` and the cost of starting new workers is increased by the synchronization and hashsetadd() operations however since starting a new thread in itself is somewhat expensive again this shouldnt be a performance hit although its hard to benchmark itin addition to support proper task rejection after the scheduler has shut down both scheduler types require a constant shutdown worker these workers are created at class load time and will spin up a thread for a short duration before they shut it down they dont affect performance wise the normal operations but the app startup time might get increased the tradeoff here is to save on a mandatory class cast whenever a worker is requested;it appears ive made a copy-paste error and missed the `rxscheduledexecutorpool` || i think this all looks good @abersnaze id appreciate your review of this as wellmy only real question is whether we should have `shutdown`/`start` or just `shutdown` or `reset` that shuts everything down and resets it to a state where it will automatically start up again if anything is used without needing an explicit `start`everything else seems to be internal changes and not public api || cool i was hoping for this feature!small question: would it make sense for the user to be able to control wether the threads execute in daemon mode when the user controls the lifecycle of the threads ? schedulerscomputation() threads are created in daemon mode by default || holding off as i want to finish discussing the shutdown/start vs reset api decision  || ill submit a new pr since eclipse rebase is [broken]( at the moment || @akarnokd why not to rebase from the terminal? i can help you with that :)had never trusted ides for such git actions ||;1;0;hiding start() moved test to compensate;
"3150;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;window operators now support backpressure in the inner observable.;repost of #3050.;;3050.0;window operators now support backpressure in the inner observable;repost of #3050;do we need to maintain both bufferuntilsubscriber v1 and v2 at the same time? || `bufferuntilsubscriber` does some black backpressure magic inside groupby which i wasnt able to figure out and the v2 doesnt pass unit tests with it || it seems like `bufferuntilsubscriber` is being used as a special case buffer for `operatorgroupby` while `bufferuntilsubscriberv2` is custom for the windowing operators if they cannot be reconciled to work for both cases then could you please move them into the operators as static nested classes?also since groupbys back pressure is being patched maybe itd be a good idea to revisit this pull request with those changes to try to combine the two `bufferuntilsubscriber`s  || these are internal classes and can live in their own files the groupby in #3428 no longer uses it and once merged this `bufferuntilsubscriberv2` can be renamed or better yet promoted to a standard api `unicastsubject`i dont think we should be so eager to combine things such combinations end up in monstrous classes which are then sources of misunderstanding and complexity || `bufferuntilsubscriber` was a proposed as a solution to the time gap problem in group by so because `bufferuntilsubscriberv2` doesnt work to solve this problem for group by leads me to question its naming is it built to handle the same problem or a different problem? are you proposing to rename v2 to `unicastsubject`?  || > i dont think we should be so eager to combine things such combinations end up in monstrous classes which are then sources of misunderstanding and complexityim proposing to hide away internal functionality from the public api  || neither of these are public api since they reside in the internal package hiding them further away seems to be unnecessary in addition `bufferuntilsubscriberv2` is effectively turned into the official `unicastsubject` in 2xhistorically `bufferuntilsubscriber` started out to solve the time-gap problem for the non-backpressured `groupby` and `window` when the backpressure was introduced `groupby` had to support backpressure but `bufferuntilsubscriber` wasnt enhanced instead `bufferuntilsubscriber` is used as a middle man and the subscription process is hijacked to inject a producer that attempts to coordinate requests apparently this didnt cover all request pattern hence the original bug due to this very specific hijacking adding backpressure to `bufferuntilsubscriber` directly didnt work out as it conflicted with the request coordination in a way i couldnt resolve therefore i decided to have a separate class that does backpressure but doesnt have to be involved in request coordination for `window` (which i believe cant be established with a reasonable strategy) || all im asking for is a rename from v2 in 1x || maybe i missed it but whats the name youd like? || ive renamed the class to `unicastsubject` and combined the `state` with the `onsubscribebus` class || im going to sleep now (its midnight here) so if you only have concerns about naming location and visibility i suggest merging this pr then posting a separate pr with your changes (and merge it if you can get somebody else to like it in the meantime) || @akarnokd would you mind rebasing this? || done || ;backpressure support for most bufferuntilsubscriber use places;ive added backpressure support to `bufferuntilsubscriber` however the internal workings of `groupby` were in conflict with my clean approach therefore i kept the original `bufferuntilsubscriber` use in `groupby` and added `bufferuntilsubscriberv2` and made the various `window()` operators use it insteadive also added a two unbounded spsc queue implementations from jctools which can reduce the allocation-rate of these linked-node queuesthe problem with `groupby` seems to be that it sets a producer on the `subscriber` before it is actually subscribed to the `bufferuntilsubscriber` the v2 however sets its on producer to support proper replay and kicks out the original coordinator producer i dont know how to make the two work together yet maybe the `groupby` has to be rewritten from scratch and inline the group backpressure support request coordination and queueing more directly an alternative might be to expose the single child request amount in `bufferuntilsubscriber` through a callback to the group somehow;""holding off on this  its is a non-trivial change and i dont have time to review it right now and yes `groupby` is a very tricky one to solve we have rewritten it a couple times already there are some very tricky edge cases such as """"time gap"""" and head-of-line-blocking  || @akarnokd im about to review this with @stevegury but before we do do you want anything changed on this? it does need to be rebased at a minimum if its still all valid || no changes planned to this i need to manually reapply the changes to a fresh version because my eclipses git is broken maybe it is better to review a mergeable version instead of this || see #3150 || "";1;0;window operator now supports backpressure in the inner observable;"
"3154;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add observable.fromcallable() as a companion for observable.defer();yep  this is a new operator.  motivation?  observable.defer()  requires function that returns  observable<t>  when usually we don t want to create  observable<t>  manually  we just want to defer execution of some function.  like this:      java observable   .fromcallable(() -> somefunc())   .subscribeon()   ...      instead of this:      java observable   .defer(() -> observable.just(somefunc()))   .subscribeon(...)   ...      and more important case with deferring code that throws checked exceptions:      java observable   .fromcallable(() -> {     value value = ...      // some code     return value    })  .subscribeon(...)  ...      instead of this:      java observable   .defer(() -> {     try {       value value = ...         // some code that throws checked exceptions       return observable.just(value)      } catch (exception e) {       return observable.error(e)      }   })  .subscribeon(...)  ...      i d use name  defer  but both methods will have same type erasure ( func0<observable>  and  func0<t> )  so i had to use a different name.  questions: 1. useful or not? for me  deferring some function call is a common task. 2. naming.  if the decision about this operator will be positive  i ll add javadoc to this pr and then create separate pr for  single.fromcallable() .;;0;add observablefromcallable() as a companion for observabledefer();yep this is a new operatormotivation? `observabledefer()` requires function that returns `observable<t>` when usually we dont want to create `observable<t>` manually we just want to defer execution of some functionlike this:``` javaobservable  fromcallable(() -> somefunc())  subscribeon()  ```instead of this:``` javaobservable  defer(() -> observablejust(somefunc()))  subscribeon()  ```and more important case with deferring code that throws checked exceptions:``` javaobservable  fromcallable(() -> {    value value      // some code    return value  }) subscribeon() ```instead of this:``` javaobservable  defer(() -> {    try {      value value         // some code that throws checked exceptions      return observablejust(value)    } catch (exception e) {      return observableerror(e)    }  }) subscribeon() ```id use name `defer` but both methods will have same type erasure (`func0<observable>` and `func0<t>`) so i had to use a different namequestions:1 useful or not? for me  deferring some function call is a common task2 namingif the decision about this operator will be positive  ill add javadoc to this pr and then create separate pr for `singlefromcallable()`;""also i see that for rx newcomers (some of my coworkers for example) is not very clear why they need to return `observable` if they just want to defer some code  || sounds ok to me a name using the `defer` prefix might be nice for discoverability purposes || we can call it `from()` i guess it will be nice to write `observablefrom(() - > somefunc())` and even better with method `observablefrom(this::somefunc())`!  || we cant call it from because of potential conflict in dynamic languages id prefer start or startasync  || > we cant call it from because of potential conflict in dynamic languages id prefer start or startasync `observablestart()` will be confusing because actually it wont start until you subscribe to it`observablestartasync()` is also confusing and it can be non-async if you wont add `subscribeon()`if we can not use `defer()` id prefer `lazy()` mm? cc @benjchristensen  || whatever the name is (`deferjust(func0<t>)`?) i would like the implementation to return a subclass of scalarsynchronousobservable that overrides the `t get()` method with a call to the closure passed in || operator is ready for next review!> sounds ok to me a name using the defer prefix might be nice for discoverability purposesanother naming suggestion: `deferfunc()` it will be obvious for those who used `defer()` but it will be strange a little because `defer` is not `deferobservable` || @abersnaze >  i would like the implementation to return a subclass of scalarsynchronousobservablenot sure about this because i dont know what variant will be better (more efficient maintainable etc) `singledelayedproducer` or `scalarsynchronousobservable` @akarnokd id like to hear your opinion on this if you dont mind || there is special logic in `merge()` [link to code]( to unwrap `scalarsynchronousobservable` by invoking the `get()` method directly and avoiding all the overhead of creating a `subscriber` and `singledelayedproducer` to just get the value  this should make `flatmap` of these very fast || you cant return the scalar observable because the value has to be ready at assembly time and be constant any side effect would only happen once as well || @akarnokd ill try to send in an example of what i mean but i dont see any reason why `t get()` cant call a `func0<t>`  it would still be scalar and synchronous but there isnt anything that says that it has to be constant || instead of modifying scalarsynchronousobservable you could add a new case to the type check in merge || check out #3163 (made it pr so it can be discussed over there) || there are several problems with your proposal- increased likelihood of bimorphic/megamorphic dispatch at the call sites of get()- get() can now throw which is unexpected at the call sites- calling the func might carry side effects and calling it during assembly time is incorrect ||  switched to `callable` (available in jdk since 15 so its okay) now you can defer function that potentially throws checked exception!i hope `observablelazy()` (or whatever name it will have) will be the easiest way to create `observable` that should emit one item only after `subscribe()` (which is pretty common rx task)so i guess its time to select the name for this operator and add javadoc || i would also like to see the observables produced  lazy` take advantage of a path similar to scalarsynchronousobservable (statically allocated and statically available data) i have an idea that id like to explore more and ill open another pull request that enables this for both `observabledefer` and `observablelazy` (assuming this gets merged) || added javadoc and squashedps today i used `observabledefer()` ~20 times and each time i could use `observablelazy()` and save some lines of code would be nice to see it in 1015! || all observables are lazy why cant you just use observablecreate()? || @staltz that would conflict with `create(onsubscribe)` in dynamic languagesmy new name proposals:- `deferjust`- `defersingle`- `deferscalar` || `defersingle` sounds nice to mealso thought of `defervalue` || > all observables are lazyits not true in java (and all jvm langs that i know) argument of a method computed before actual invocation of this methodfor example if you have method `value computevalue() {  }` and you want to make an observable from it you can use `observablejust(computevalue())` but the problem is that `computevalue()` will be computed in the thread that called `observablejust()` and not on the scheduler that you specify via `subscribeon()`so in my opinion `just()` and `from` are not """"lazy""""`deferjust` looks good `defersingle` may conflict with `single` for rxjava users || sorry to be late into the game here but it seems you really want an overload of `just` that has side-effects ie reruns a factory function every time you subscribe to produce the value i think the name should reflect thati am surprised this is a common scenario since it feel super narrow personally i think the longer `defer` code conveys the intent perfectly plus it also works if you want to do generate more than one value``` javaobservable  defer(() -> {    value value0 value1 valuen-1      // some code    return observablejust(value0  valuen-1)  }) subscribeon()```anyway just my 2 cents || renamed operator from `lazy()` to `deferjust()`> i am surprised this is a common scenario since it feel super narrow personally i think the longer defer code conveys the intent perfectlysurprise surprise  nobody likes boilerplate also if you need to defer function that throws checked exception via `defer()` you have to deal with `try/catch` `deferjust()` handles it for youthere is even post from @dlew [deferring observable code until subscription in rxjava]( which i guess makes this problem more visible || you have just solved the boilerplate for one very particular case that does not generalize to the other overloads of `just` and increased the concept count but if it makes you happy it cant be that bad || im not a fan i prefer composability you can easily compose existing operators to recreate `deferjust` theyre in the name || i called this operator `fromcallable` in 2x where the `from` operators are suf by the type to be very specific and to avoid overload resolution problems || nice and understandable name :+1: renamed to `fromcallable()` to make a switch from v1 to v2 easier || @akarnokd @benjchristensen is there anything that blocks this pr?  || im totally in favor of this addition so we can start promoting it instead of `create` with a single result so commonly found we are still waiting for the second approve from another member || > we can start promoting it instead of create with a single result so commonly foundyes!i see some confusion when newbies hear: """"to defer some code and turn it into `observable` you need to use `observablecreate()` (which is pretty tricky and boilerplate) or create `observable` via `just()` or `from()` etc and defer it via `observabledefer()`"""" i literally can read """"wtf""""s in their eyes when they ask  """"so i need to create `observable` to defer an `observable` what?"""" this thing must be easier :) || :-1: this is a less general use case than an `observablejust()` or a `defer` that returns a `just` and it does not benefit from the merge optimizations  || we can always optimize later || i see the compelling usability need (easy to type simple to find) so i see that users would adopt it but it would detract from the optimized path i dont think this will perform well if its adopted in the netflix ecosystem many other users here have raised objections as this use case can be handled with existing operators and that composition would skip the merge ring buffer allocation/draining   || thats not how the merge optimizations work || oh youre right merge cant optimize either path at least not as a scalar it still has to subscribe to de defer my mistake  || my objections were on faulty assumptions i take back my -1 :+1:   || great! || great addition! thanks  > so we can start promoting it instead of create with a single result so> commonly foundthat is generally why `single` exists it still has its place on`observable` but if just single responses are being done such as for rpcthen `single` makes more senseon sun sep 6 2015 at 2:13 am jens driller notifications@githubcomwrote:> great addition! thanks [image: :+1:]> > > reply to this email directly or view it on github>  || "";;;;1;1;add observablefromcallable() as a companion for observabledefer();"
"3155;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;safesubscriber - report oncompleted unsubscribe error to rxjavaplugin;discussed in #2464  when an observable emits  oncompleted  but  unsubscribe  in  safesubscriber  throws then the error should be reported to the  rxjavaplugin  error handler and if that fails a stack trace is written to  system.err .;;2464.0;safesubscriber - report oncompleted unsubscribe error to rxjavaplugin;discussed in #2464 when an observable emits `oncompleted` but `unsubscribe` in `safesubscriber` throws then the error should be reported to the `rxjavaplugin` error handler and if that fails a stack trace is written to `systemerr`;there are a lot of repeated try catch blocks calling the rxjavaplugins error handler so ive made a `rxjavapluginutils` class it will also be called from the `using` fix which i will submit once this pr has been accepted || one of the tests fails || im going to ponder the issue of throwing after reporting to the error handler a bit || ive been looking for a bit of guidance about what to do when `unsubscribe` throws in `safesubscriber` _rx design guidelines_ doesnt really cover it _reactive-streams-jvm_ does touch upon it saying:> 315 calling subscriptioncancel must return normally the only legal way to signal failure to a subscriber is via the onerror methodi think given that the contract has been breached it is fair to throw an exception and i think a new wrapper `unsubscribefailureexception` would be appropriateid also like to address the case when `oncompleted` throws _reactive-streams-jvm_ has this to say:> 213 calling onsubscribe onnext onerror or oncomplete must return normally except when any provided parameter is null in which case it must throw a javalangnullpointerexception to the caller for all other situations the only legal way for a subscriber to signal failure is by cancelling its subscription in the case that this rule is violated any associated subscription to the subscriber must be considered as cancelled and the caller must raise this error condition in a fashion that is adequate for the runtime environmentso in the existing code if in `safesubscriber` an `onerror` call to the downstream subscriber throws then the rxjavaplugin error handler is called _and_ an `onerrorfailedexception` is thrown comments in the method say this is ok because the contract has been broken and this is probably consistent with the advice in 313:> and the caller must raise this error condition in a fashion that is adequate for the runtime environmentin the existing code if in `safesubscriber` an `oncompleted` call to the downstream subscriber throws then the consequent call to `_onerror` tries to signal `onerror` to the downstream subscriber  im worried that calling `onerror` after calling `oncompleted` is a strong enough breach of the contract that the possible side effects could be worse than just a throw shouldnt we throw only (and notify the plugin error handler of course)? || ive submitted code that matches my thinking above it still fails because i havent amended the existing unit tests associated with throwing ill do that after another round of review if accepted || the failing test is a coverage test for a behavior no longer present i suggest removing it and rerunning the jacoco to see if all current code path is covered || @akarnokd yep thats right are you happy that a throwing `oncompleted()` call should not induce an `onerror()` call? if so ill clean up and update the pr || ive  the unit tests and added more so that `safesubscriber` gets 100% coverage || :+1: looks good to mesince this adds public api classes it requires further approval (otherwise it shouldnt affect programs other than those that badly fail therefore the merge policy would allow me to merge it) || lgtm it would be better if you can fix the indent :+1: for unsubscribefailureexception its a pity that we cannot change `onerrorfailedexception`s that should have been `unsubscribefailureexception` now since its a break change || thanks for review @akarnokd  and @zsxwing ive fixed indent in test and squashed commits || great ;`observableusing` sliently ignores exception of dispose action;""code:``` javaimport rxobservableimport rxfunctionsaction0import rxfunctionsaction1import rxfunctionsfunc0import rxfunctionsfunc1class main {    public static void main(string args) {        observableusing(                new func0<string>() {                    @override                    public string call() {                        systemoutprintln(""""calling resourcefactory"""")                        return """"resourcefactory""""                    }                }                new func1<string observable<string>>() {                    @override                    public observable<string> call(string str) {                        systemoutprintln(""""calling observablefactory"""")                        return observablejust(""""observablefactory"""")                    }                }                new action1<string>() {                    @override                    public void call(string s) {                        systemoutprintln(""""calling disposeaction"""")                        throw new runtimeexception(""""disposeaction"""")                    }                }        )subscribe(                new action1<string>() {                    @override                    public void call(string s) {                        systemoutprintln(""""onnext: """" + s)                    }                }                new action1<throwable>() {                    @override                    public void call(throwable e) {                        systemoutprintln(""""onerror: """" + egetmessage())                    }                }                new action0() {                    @override                    public void call() {                        systemoutprintln(""""oncomplete"""")                    }                }        )    }}```output:```calling resourcefactorycalling observablefactoryonnext: observablefactoryoncompletecalling disposeaction```this program finishes without error and the `runtimeexception` thrown in dispose action is silently ignored"";""hi at that point it cant notify the subscriber because it received a termination event before the best thing we can do is to route the exception into the plugin system || can it be made so that `oncompleted` will be called after the dispose action returns successfully? so that if the dispose action throws an error it can be notified with `onerror` this will make its behaviour consistent with the rest of the error notification workflow || @laec according to the [rx design guide]( you should not throw an error in the dispose action:> 618 unsubscription should not throw> as the rxs composition makes that subscriptions are chained so are unsubscriptions because of this  any operator can call an unsubscription at any time because of this just throwing an exception will lead  to the application crashing unexpectedly as the observer instance is already unsubscribed it cannot be  used for receiving the exception either because of this exceptions in unsubscriptions should be  avoided || hi @zsxwing the issue is not whether one should or should not throw the exception sometimes unexpected errors do occur according to your quote i would expect a crash which generates good visibility but currently it sliently ignores the error and moves on which is bad || > can it be made so that oncompleted will be called after the dispose action returns successfully?i think the essential question is:how rxjava handle exceptions from `unsubscribe`? in many places rxjava assumes `unsubscribe` wont throw any exception such as `operatortake` if `unsubscribe` throws some error it may send it to `onerror` (will be swallowed if the subscriber has already received an error) or notify the rxjava plugin or crash the current threadas @akarnokd said the best solution for rxjava may be sending the exception to the rxjava plugin || i dont mind how it gets handled internally as long as the default behaviour is fail fast - crash this gives people a chance to notice the issue and fix it || how about:``` javaclass main {    public static void main(string args) {        final asyncsubject<void> onfree  asyncsubjectcreate()        observableusing(                new func0<string>() {                    @override                    public string call() {                        systemoutprintln(""""calling resourcefactory"""")                        return """"resourcefactory""""                    }                }                new func1<string observable<string>>() {                    @override                    public observable<string> call(string str) {                        systemoutprintln(""""calling observablefactory"""")                        return observablejust(""""observablefactory"""")                    }                }                new action1<string>() {                    @override                    public void call(string s) {                        systemoutprintln(""""calling disposeaction"""")                        try {                            throw new runtimeexception(""""disposeaction"""")                            // onfreeoncompleted()                        } catch (throwable ex) {                           onfreeonerror(ex)                        }                    }                }        )mergewith(onfree)subscribe(                new action1<string>() {                    @override                    public void call(string s) {                        systemoutprintln(""""onnext: """" + s)                    }                }                new action1<throwable>() {                    @override                    public void call(throwable e) {                        systemoutprintln(""""onerror: """" + egetmessage())                    }                }                new action0() {                    @override                    public void call() {                        systemoutprintln(""""oncomplete"""")                    }                }        )    }}``` || i feel thats just a short term workaround for the issue we cant expect users of `observableusing` to do this every time (and we certainly cant expect them to be aware of this issue) its boilerplate and awkward and even more so when you need to chain multiple `observableusing` together || you can always roll your own operator so you can hide the boilerplate in a reusable fashion here is an example:``` javapublic final class myusing<t resource> implements onsubscribe<t> {    private final func0<resource> resourcefactory    private final func1<? super resource ? extends observable<? extends t>> observablefactory    private final action2<? super resource observer<t>> dispose    public myusing(func0<resource> resourcefactory            func1<? super resource ? extends observable<? extends t>> observablefactory            action2<? super resource observer<t>> dispose) {        thisresourcefactory  resourcefactory        thisobservablefactory  observablefactory        thisdispose  dispose    }    @override    public void call(subscriber<? super t> subscriber) {        try {            final resource resource  resourcefactorycall()            final asyncsubject<t> disposeoutcome  asyncsubjectcreate()            subscriberadd(subscriptionscreate(new action0() {                @override                public void call() {                    disposecall(resource disposeoutcome)                }            }))            @suppresswarnings(""""unchecked"""")            observable<t> observable  (observable<t>)observablefactorycall(resource)            observablemergewith(disposeoutcome)subscribe(subscriber)        } catch (throwable e) {            // eagerly call unsubscribe since this operator is specifically about resource management            subscriberunsubscribe()            // then propagate error            subscriberonerror(e)        }    }    public observable<t> toobservable() {        return observablecreate(this)    }}``` || thanks for the suggestion but do you agree that the underlying issue is in rxjava itself that it sliently swallows errors? if you do then i think the fix should be done to rxjava itself instead || note that without addressing the core issue of rxjava silently swallowing errors the eager disposal overload for `using` proposed in #2759 would emit an `onerror` event on disposal failure if `disposeeagerly` is set to true || this issue is a bit aged what is the verdict? || looks to me that we should do these things:- document in `using` javadoc that disposal should not throw- call an rxjava plugin when disposal does throw (im not familiar with this side of things)    i can knock up a pr with these if someone has some rxjava plugin advice for me || looks its a very simple fix to call the rxjava plugin: just replace this line with ```                try {                    unsubscribe()                } catch (throwable e) {                    _onerror(e)                }``` || thanks @zsxwing thats nice and simple @akarnokd happy to proceed with this? || that would call `onerror` after an `oncompleted` (successful and unsuccessful) so even in the current form it violates the protocol || yep youre right so ill just need code like this in the catch on the dispose action in `using`?``` java    try {        rxjavapluginsgetinstance()geterrorhandler()handleerror(e)    } catch (throwable e) {        eprintstacktrace()    }``` || stepping back a bit we probably should put the catch in `safesubscriber`  dont call `_onerror(e)` but rather call the plugin handler like `_onerror` does at the start of its method ie``` javatry {    unsubscribe()} catch (throwable e) {    try {        rxjavapluginsgetinstance()geterrorhandler()handleerror(e)    } catch (throwable pluginexception) {        handlepluginexception(pluginexception)    }}``` || by the way the change to `safesubscriber` would only work for the `using` scenario if unsubscription all the way up the chain is synchronous is this an assumption we make and should it be documented in the observable contract? || if unsubscription is asynchronous and safesubscriber wont swallow it it should be caught by the user or handled by the threads `uncaughtexceptionhandler` right? looks its acceptable || yeah i agree @zsxwing if some operator is introduced into the chain that unsubscribes from upstream asynchronously then it becomes its responsibility to handle exceptions (by for example calling the rxjavaplugin error handler) so i can knock up a pr for this or would you like to do it @zsxwing as it was your fix? || @davidmoten feel free to send a pr :) || ive submitted a fix for `safesubscriber` as described but i realize it only fixes part of the problem being that we are now covered for when `unsubscribe` is called after completion if `unsubscribe` is called before termination we still need `using` to report an error to the `rxjavaplugin` error handler itself ill submit another pr for that one || still thinking about this i suspect post termination unsubscribe failures are the ones that need `rxjavaplugin` error handler notifications and no special handling is required in `using` if the `safesubscriber` fix goes in in the case of pre-termination unsubscribe intermediate or  endpoint `subscriber`s will in general throw from an `onnext` `onerror` or `oncompleted` or catch the exception and push it downstream as an `onerror` signal so that ultimately this failure is not lost || the `using` operator now has an eager flag that will close the resource before emitting the terminal event thus you may get the exception from closing the resource || "";1;0;catch oncompleted unsubscribe error and report to rxjavaplugin error handler;"
"3169;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;merge can now operate in horizontally unbounded mode.;3156   note that since the default merge operation is unbounded  this change could lead to an excessive memory usage when flatmapping fast sources. note that the pre 1.0.13 version did this albeit on a slighty slower path.  the change also affects the scalar optimization as well. pre 1.0.13 implicitly limited the concurrency level to rxringbuffer.size when scalars were received. this version now fills the queue up to the concurrency level.  for 2.0  i suggest having a bounded behavior by default and require the developer to specify integer.max_value to go for the unbounded behavior so he/she knows about the consequences.;;3156.0;merge can now operate in horizontally unbounded mode;3156 note that since the default merge operation is unbounded this change could lead to an excessive memory usage when flatmapping fast sources note that the pre 1013 version did this albeit on a slighty slower paththe change also affects the scalar optimization as well pre 1013 implicitly limited the concurrency level to rxringbuffersize when scalars were received this version now fills the queue up to the concurrency levelfor 20 i suggest having a bounded behavior by default and require the developer to specify integermax_value to go for the unbounded behavior so he/she knows about the consequences;ill have to allocate some time to review this later as it is somewhat detailed thank you for tackling this || > pre 1013 implicitly limited the concurrency level to rxringbuffersize when scalars were receivedthat was done by design since scalars behave as `onnext` and we can limit the number of `observable`s being merged if we have scalars queued up for deliverythe reason we cant limit the number of async `observable`s is because we dont know if they will emit or not and thus risk deadlock ||  ill rebase this || rebased lets get this finally in || ;merge limiting concurrency - can deadlock;""since the `merge` changes in 1013 we now have a bug in `merge` that limits concurrency and can cause an async """"deadlock"""" since not all `observable`s being merged will be subscribed to these unit tests show the issue:``` java    @test    public void testunboundeddefaultconcurrency() {        list<observable<integer>> os  new arraylist<observable<integer>>()        for(int i0 i < 2000 i++) {            osadd(observable<integer>never())        }        osadd(observablerange(0 100))               testsubscriber<integer> ts  testsubscribercreate()        observablemerge(os)take(1)subscribe(ts)        tsawaitterminalevent(5000 timeunitmilliseconds)        tsassertvalue(0)        tsassertcompleted()    }    @test    public void testconcurrencylimit() {        list<observable<integer>> os  new arraylist<observable<integer>>()        for(int i0 i < 2000 i++) {            osadd(observable<integer>never())        }        osadd(observablerange(0 100))               testsubscriber<integer> ts  testsubscribercreate()        observablemerge(os integermax_value)take(1)subscribe(ts)        tsawaitterminalevent(5000 timeunitmilliseconds)        tsassertvalue(0)        tsassertcompleted()    }```surprisingly even when providing the `maxconcurrent` value the issue still happenswe have bounded **vertical** buffers but always must default to unbounded **horizontal** buffers since it is the code that defines how many items are horizontally buffered this affects both `merge` and `groupby` the `maxconcurrent` overload allows a developer to limit the horizontal buffering and a developer controls the `groupby` selector"";this shortcoming is much earlier at least as old as rxringbuffer and a certain scalar optimization in merge || scalar is different  they arent async so arent an issue a scalar always has a value in it thus it will always emit if there is downstream support these unit tests pass if i go back to 1012``` java    @test    public void testunboundeddefaultconcurrency() {        list<observable<integer>> os  new arraylist<observable<integer>>()        for(int i0 i < 2000 i++) {            osadd(observable<integer>never())        }        osadd(observablerange(0 100))               testsubscriber<integer> ts  new testsubscriber<integer>()        observablemerge(os)take(1)subscribe(ts)        tsawaitterminalevent(5000 timeunitmilliseconds)        tsassertvalue(0)        tsassertcompleted()    }    @test    public void testconcurrencylimit() {        list<observable<integer>> os  new arraylist<observable<integer>>()        for(int i0 i < 2000 i++) {            osadd(observable<integer>never())        }        osadd(observablerange(0 100))               testsubscriber<integer> ts  new testsubscriber<integer>()        observablemerge(os 5000)take(1)subscribe(ts) // reduced to 5000 instead of max_value since it causes an oom        tsawaitterminalevent(5000 timeunitmilliseconds)        tsassertvalue(0)        tsassertcompleted()    }``` || in v12 if there were scalars in the input source the subscribing was held off until some scalars were drained (ie in case of an async downstream request): given 1 normal and 128 scalar queued up the next source wasnt requested until some or all scalars were drainedin order for the tests to pass we need an spsc queue instead of the rxringbuffer if the maxconcurrency is lesss than max otherwise we need an unbounded spsc queue jctools spscarrayqueue supports only power of 2 capacity so a backpressure violation wouldnt be detected at item 5000 but only at item 8192 spscunboundedarrayqueue works if its capacity is at least some value due to a bug in its lookahead-grow logic (8 with defaults) v14 merge has the side effect of limiting the tracking array size so the copy-on-write has to work with at most 512 bytes per add/removei happen to have a platform safe spscarrayqueue with explicit capacity insurance (but still power of 2 memory cost) and a platform safe spsclinkedarrayqueue (still sensitive to certain capacity settings) courtesy of my rsi flatmapi cant do pr for a few days but this is a simple change (provided the tradeoff is understood) and most of the community should be able to pull this off ||;1;0;1x: merge can now run in horizontally unbounded mode;"
3172;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;rs dependency  some basic observable/observer methods.;- added compile dependency for reactive-streams. - added some basic methods to observable.  as long as the project defaults to 1.x  the create pr webpage will take a long time to render because it tries to compare a small branch 2.x against the huge 1.x branch with lots of  deleted  content. a separate project would be much simpler to operate.;;0;rs dependency some basic observable/observer methods;- added compile dependency for reactive-streams- added some basic methods to observableas long as the project defaults to 1x the create pr webpage will take a long time to render because it tries to compare a small branch 2x against the huge 1x branch with lots of deleted content a separate project would be much simpler to operate;;;;;1;1;javac workaround;
3175;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;some safe queue implementations;spsc: - power-of-2 array - exact capacity array - linked array  mpsc: - linked;;0;some safe queue implementations;spsc:- power-of-2 array- exact capacity array- linked arraympsc:- linked;;;;;1;1;some safe queue implementations;
3183;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;refactored exception reporting of most operators.;added two convenient methods to  exceptions  which either throws a fatal exception or reports it with our without the causing value to an observer.;;0;refactored exception reporting of most operators;added two convenient methods to `exceptions` which either throws a fatal exception or reports it with our without the causing value to an observer; what if the `exceptionsthroworreport()` took a `subscriber` instead? this way we could check if the downstream subscriber is unsubscribed and then if we are reporting we would instead log to the `rxjavapluginsgetinstance()geterrorhandler()handleerror(e)` this would standardize usage of the error handler plugin thoughts?  || @stealthcode your suggestion can be applied after the merge with another pr if you wish || i agree just suggesting for your input  ||;;;;1;1;refactored exception reporting of most operators;
3185;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;publishsubject  asyncsubject and a few helper classes;we can use  publisher  directly and no need for  onsubscribe .  operator  is still quite a convenience.;;0;publishsubject asyncsubject and a few helper classes;we can use `publisher` directly and no need for `onsubscribe` `operator` is still quite a convenience;;;;;1;1;publishsubject asyncsubject and a few helper classes;
3186;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;disposable interface and a bunch of general resource containers.;mostly internal addition plus the public  disposable  interface.  naming of packages and classes can be changed at any time if one wishes;;0;disposable interface and a bunch of general resource containers;mostly internal addition plus the public `disposable` interfacenaming of packages and classes can be changed at any time if one wishes;;;;;1;1;disposable interface and a bunch of general resource containers;
3188;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;schedulers (a few) + api  slight modifications to other classes;incomplete.  this pr has a few todo questions that require decisions.;;0;schedulers (a few) + api slight modifications to other classes;incompletethis pr has a few todo questions that require decisions;;;;;1;1;schedulers (a few) + api slight modifications to other classesincomplete;
3189;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;added a bunch of basic event sources and helper subscription;implementations.;;0;added a bunch of basic event sources and helper subscription;implementations;;;;;1;1;added a bunch of basic event sources and helper subscriptionimplementations;
3190;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;basic subscribers and plugin class;- safesubscriber - serializedsubscriber - rxjavaplugins (partial);;0;basic subscribers and plugin class;- safesubscriber- serializedsubscriber- rxjavaplugins (partial);;;;;1;1;basic subscribers and rxjavaplugin;
3191;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operators map and flatmap;with all  flatmap    merge  and  mergedelayerror  overloads.;;0;operators map and flatmap;with all `flatmap` `merge` and `mergedelayerror` overloads;;;;;1;1;operators map and flatmap;
3193;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;connectableobservable and autoconnect;refcount  will come later  although its behavior is sometimes surprising to developers: it disconnects and reconnects in certain use pattern. the alternative is to use  autoconnect(n  connectionconsumer)  which lets the developer explicitly disconnect.;;0;connectableobservable and autoconnect;`refcount` will come later although its behavior is sometimes surprising to developers: it disconnects and reconnects in certain use pattern the alternative is to use `autoconnect(n connectionconsumer)` which lets the developer explicitly disconnect;;;;;1;1;connectableobservable and autoconnect;
3194;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operators of take (untimed)  plugin error reporting fix for other;operators;;0;operators of take (untimed) plugin error reporting fix for other;operators;;;;;1;1;operators of take (untimed) plugin error reporting fix for otheroperators;
3196;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;the skips and filter operators added to observable;forgot to add them in the previous pr.;;0;the skips and filter operators added to observable;forgot to add them in the previous pr;;;;;1;1;the skips and filter operators added to observable;
3197;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator tolist and tosortedlist;tosortedlist  is implemented with  tolist().map() .;;0;operator tolist and tosortedlist;`tosortedlist` is implemented with `tolist()map()`;;;;;1;1;operator tolist and tosortedlist;
3198;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operators publish  replay and cache.;i m not 100% certain about the the timing of the onsubscribe() calls inside the operators  i ll have a second run over them once the tests are also added.;;0;operators publish replay and cache;im not 100% certain about the the timing of the onsubscribe() calls inside the operators ill have a second run over them once the tests are also added;;;;;1;1;workaround for another javac 18 bug;
3199;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operators all  any  count  elementat  single;- isempty == any(v -> true);;0;operators all any count elementat single;- isempty  any(v -> true);;;;;1;1;operators all any count elementat single;
3200;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;all standard schedulers ported and cleaned up.;- updated rxjavaplugins and added decorator calls to the schedulers.;;0;all standard schedulers ported and cleaned up;- updated rxjavaplugins and added decorator calls to the schedulers;;;;;1;1;all standard schedulers ported and cleaned up;
3202;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operators observeon  subscribeon and unsubscribeon;few considerations: - added an option to specify if  subscribeon  should also request on the same worker or not. if not  the consumer thread may freely grab the producer and thus reduce the inter-thread communication. - the scheduling of the subscription in  subscribeon  now can t be cancelled because in rs  the indication of  subscription  is to call  onsubscribe  on the proper thread. since the  subscriber  can t call cancel until it receives the subscription through  onsubscribe  the time it receives the subscription there is no point in cancelling the operation. - added two parametrization option to  observeon : the ability to delay the error after all the  onnext  events and the ability to specify the buffer size. since many get surprised by the 1.x behavior  this should help the situation and also makes it possible to avoid wrapping/materializing the sequence. the second ability should help with fine tuning a particular sequence independent to the other sequences. - i ve padded away (since the  @contended  annotation is not standard) the request and wip counters in  observeon . if unpadded  they bash each other constantly and i ve experienced 15-20% throughput loss.;;0;operators observeon subscribeon and unsubscribeon;few considerations:- added an option to specify if `subscribeon` should also request on the same worker or not if not the consumer thread may freely grab the producer and thus reduce the inter-thread communication- the scheduling of the subscription in `subscribeon` now cant be cancelled because in rs the indication of subscription is to call `onsubscribe` on the proper thread since the `subscriber` cant call cancel until it receives the subscription through `onsubscribe` the time it receives the subscription there is no point in cancelling the operation- added two parametrization option to `observeon`: the ability to delay the error after all the `onnext` events and the ability to specify the buffer size since many get surprised by the 1x behavior this should help the situation and also makes it possible to avoid wrapping/materializing the sequence the second ability should help with fine tuning a particular sequence independent to the other sequences- ive padded away (since the `@contended` annotation is not standard) the request and wip counters in `observeon` if unpadded they bash each other constantly and ive experienced 15-20% throughput loss;;;;;1;1;operators observeon subscribeon and unsubscribeon;
3204;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator concatmap and related convenience methods;this includes - concatmap - concat - startwith - endwith - concatwith - mergewith (via merge);;0;operator concatmap and related convenience methods;this includes- concatmap- concat- startwith- endwith- concatwith- mergewith (via merge);;;;;1;1;operator concatmap and related convenience methods;
3205;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;lambda-based subscribe and lifecycle tracking methods;- foreachwhile that allows stopping the stream from within the onnext callback by returning false.  the lambda subscribe()s return a disposable so they can be asynchronously cancelled.;;0;lambda-based subscribe and lifecycle tracking methods;- foreachwhile that allows stopping the stream from within the onnext callback by returning falsethe lambda subscribe()s return a disposable so they can be asynchronously cancelled;;;;;1;1;lambda-based subscription and lifecycle tracking methods;
3206;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;testsubscriber implemented;- internal  emptysubscriber;;0;testsubscriber implemented;- internal `emptysubscriber`;;;;;1;1;testsubscriber implemented;
3207;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;some repeat + retry methods  fix to subscriptionarbiter.;i ll post the  retrywhen  and  repeatwhen  separately.;;0;some repeat + retry methods fix to subscriptionarbiter;ill post the `retrywhen` and `repeatwhen` separately;;;;;1;1;some repeat + retry methods fix to subscriptionarbiter;
3208;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operators interval and intervalrange;intervalrange  helps when one needs a fixed amount of timed values and wants to avoid map+take overhead.;;0;operators interval and intervalrange;`intervalrange` helps when one needs a  amount of timed values and wants to avoid map+take overhead;what is the overhead of take that this saves? i dont see the point especially since interval goes through scheduling for each emission which has to cost more than take || the operator involves less allocation when a sequence is assembled and a  lover memory footprint when active ||;;;;1;1;operators interval and intervalrange;
3209;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operators onbackpressure(drop|buffer|latest);there won t be  onbackpressureblock  although it can work with  subscribeon(scheduler  false)  since that won t schedule the request behind the blocked emission.  operator  onbackpressurebuffer  has now a  delayerror  option  i d like to give the developer the option on this one. naturally  the default is false.;;0;operators onbackpressure(drop|buffer|latest);there wont be `onbackpressureblock` although it can work with `subscribeon(scheduler false)` since that wont schedule the request behind the blocked emissionoperator `onbackpressurebuffer` has now a `delayerror` option id like to give the developer the option on this one naturally the default is false;;;;;1;1;operators onbackpressure(drop|buffer|latest);
3212;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator groupby;this default implementation supports backpressure but doesn t coordinate the group requests with the main requests in any way.   this means  for example  that given a million element source and a constant true key selector will queue up all million elements until a single subscriber consumes them.  the 1.x version had some coordination and all sorts of group management logic which i don t understand. i ll revisit this operator later.;;0;operator groupby;this default implementation supports backpressure but doesnt coordinate the group requests with the main requests in any way this means for example that given a million element source and a constant true key selector will queue up all million elements until a single subscriber consumes themthe 1x version had some coordination and all sorts of group management logic which i dont understand ill revisit this operator later;;;;;1;1;operator groupby;
3214;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;fix to notification equals method.;the notification method was missing a check to hasvalue and hasthrowable. this allowed for a null value onnext notification to equal an object notification. a similar bug for onerror notification events also existed.;;0;fix to notification equals method;the notification method was missing a check to hasvalue and hasthrowable this allowed for a null value onnext notification to equal an object notification a similar bug for onerror notification events also existed;:+1: this seems like a valid contribution with tests  ||  thanks guys hopefully the first of many contributions ||;;;;1;1;fix to notification equals method;
3215;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator zip plus function3..function9.;functionx extends function<object  r> and the default method for it unpacks the array.;;0;operator zip plus function3function9;functionx extends function<object r> and the default method for it unpacks the array;;;;;1;1;operator zip plus function3function9;
3220;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;strenghtening flatmap against misbehaving sources  testsubscriber +;methods.;;0;strenghtening flatmap against misbehaving sources testsubscriber +;methods;;;;;1;1;strenghtening flatmap against misbehaving sources testsubscriber +methods;
3222;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator withlatestfrom  publishlift to help with operator fusing;subscriptionhelper for common validation logic.  the subscriptionhelper s methods are not yet applied to former operators.;;0;operator withlatestfrom publishlift to help with operator fusing;subscriptionhelper for common validation logicthe subscriptionhelpers methods are not yet applied to former operators;;;;;1;1;operator withlatestfrom publishlift to help with operator fusingsubscriptionhelper for common validation logic;
3223;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fixes to classes  convenience operators mostly.;also corrected the naming of one-shot timer and fixed-period interval;;0;fixes to classes convenience operators mostly;also corrected the naming of one-shot timer and -period interval;;;;;1;1;fixes to classes convenience operators mostly;
3224;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator distinct  timeinterval  common timed container.;instead of having  timestamped  and  timeinterval  with the same structure  let s have just a single one:  timed .   distinctuntilchanged  is implemented via special  distinct .;;0;operator distinct timeinterval common timed container;instead of having `timestamped` and `timeinterval` with the same structure lets have just a single one: `timed``distinctuntilchanged` is implemented via special `distinct`;;;;;1;1;operator distinct timeinterval common timed container;
3225;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operations doonx.;the various doonxxx operator overloads + range(scheduler) + repeat(scheduler).;;0;operations doonx;the various doonxxx operator overloads + range(scheduler) + repeat(scheduler);;;;;1;1;operations doonx;
3226;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator collect  tomap and tomultimap based on it.;i know  tolist  can be also implemented this way but its frequent use makes it eligible for a custom operator.;;0;operator collect tomap and tomultimap based on it;i know `tolist` can be also implemented this way but its frequent use makes it eligible for a custom operator;;;;;1;1;operator collect tomap and tomultimap based on it;
3227;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;collect: javac is unable to select the right overload for some reason;javac is unable to select the right overload for some reason;;0;collect: javac is unable to select the right overload for some reason;javac is unable to select the right overload for some reason;;;;;1;1;collect: javac is unable to select the right overload for some reason;
3228;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;conditionalsubscriber to help fusing filter-like operators into;emission/drain loops.  this may help with operators that call request(1) to replenish a dropped value (filter for example).  i ve only implemented this with the array-source and with a lot of code duplication. i ll think about how to reduce this duplication via inheritance or with lambdas (which might negate the benefit).;;0;conditionalsubscriber to help fusing filter-like operators into;emission/drain loopsthis may help with operators that call request(1) to replenish a dropped value (filter for example)ive only implemented this with the array-source and with a lot of code duplication ill think about how to reduce this duplication via inheritance or with lambdas (which might negate the benefit);;;;;1;1;conditionalsubscriber to help fusing filter-like operators intoemission/drain loops;
3229;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator sample with time or with another publisher;i d like to state that i try to use  publisher  as much as possible: this adds the benefit that rxjava can use someone else s publisher without the explicit need to wrap it into an  observable  all the time.;;0;operator sample with time or with another publisher;id like to state that i try to use `publisher` as much as possible: this adds the benefit that rxjava can use someone elses publisher without the explicit need to wrap it into an `observable` all the time;;;;;1;1;operator sample with time or with another publisher;
3230;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operato switchifempty  defaultifempty;;;0;operato switchifempty defaultifempty;;;;;;1;1;operato switchifempty defaultifempty;
3231;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator takelast time + size  skiplast time;- buffersize +delayerror options  as usual by now;;0;operator takelast time + size skiplast time;- buffersize +delayerror options as usual by now;;;;;1;1;operator takelast time + size skiplast time;
3232;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operators first  last  multi-offer for spsclinkedarrayqueue;the multi-offer helps with the timed skiplast. by offering two at once  the drain won t loop until the second value arrives.;;0;operators first last multi-offer for spsclinkedarrayqueue;the multi-offer helps with the timed skiplast by offering two at once the drain wont loop until the second value arrives;;;;;1;1;operators first last multi-offer for spsclinkedarrayqueue;
3234;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator switchmap  switchonnext  added missing merge and concat;overloads  some refactorings;;0;operator switchmap switchonnext added missing merge and concat;overloads some refactorings;;;;;1;1;operator switchmap switchonnext added missing merge and concatoverloads some refactorings;
3235;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator amb  ambwith;very similar to zip in terms of structure.;;0;operator amb ambwith;very similar to zip in terms of structure;;;;;1;1;operator amb ambwith;
3237;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operators onerrorreturn  onerrorresumenext  onexceptionresumenext;- onerrorreturnvalue;;0;operators onerrorreturn onerrorresumenext onexceptionresumenext;- onerrorreturnvalue;;;;;1;1;operators onerrorreturn onerrorresumenext onexceptionresumenext;
3238;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator retrywhen  repeatwhen  notification;- a fix to operatoronerrornext;;0;operator retrywhen repeatwhen notification;- a fix to operatoronerrornext;;;;;1;1;operator retrywhen repeatwhen notification;
3240;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator sequenceequal;inlined (no zipping and wrapping like in 1.x);;0;operator sequenceequal;inlined (no zipping and wrapping like in 1x);;;;;1;1;operator sequenceequal;
3241;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator combinelatest;- some minor internal refactorings in  observable .;;0;operator combinelatest;- some minor internal refactorings in `observable`;;;;;1;1;operator combinelatest;
3242;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator using  some internal refactorings.;emptysubscriber convenience method to reduce boilerplate.;;0;operator using some internal refactorings;emptysubscriber convenience method to reduce boilerplate;;;;;1;1;operator using some inernal refactorings;
3243;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator materialize  dematerialize  minor notification fix.;optional.ofnullable  returns an empty instance  not a null-containing one.;;0;operator materialize dematerialize minor notification fix;`optionalofnullable` returns an empty instance not a null-containing one;;;;;1;1;operator materialize dematerialize minor notification fix;
3244;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operators delay  delaysubscription  share.;the  delaysubscription  is implemented via composition.;;0;operators delay delaysubscription share;the `delaysubscription` is implemented via composition;;;;;1;1;operators delay delaysubscription share;
3245;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;blockingobservable  next  latest  mostrecent  first  last  single;subscribe  stream  foreach  iterator  now it extends both publisher and iterable directly.;;0;blockingobservable next latest mostrecent first last single;subscribe stream foreach iteratornow it extends both publisher and iterable directly;;;;;1;1;blockingobservable next latest mostrecent first last singlesubscribe stream foreach iterator;
3246;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator refcount;converted nicely.;;0;operator refcount;converted nicely;;;;;1;1;operator refcount;
3247;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;unicastsubject  onbackpressurebuffer-like behavior for a single;subscriber only.  should be the official api replacement of bufferuntilsubscriber.;;0;unicastsubject onbackpressurebuffer-like behavior for a single;subscriber onlyshould be the official api replacement of bufferuntilsubscriber;;;;;1;1;unicastsubject onbackpressurebuffer-like behavior for a singlesubscriber only;
3248;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operators buffer: size  time  size + time;the boundary version will come next.;;0;operators buffer: size time size + time;the boundary version will come next;;;;;1;1;operators buffer: size time size + time;
3250;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator buffer with boundary and open-close  fixes to the timed;variants.   added  queuedrain  and  queuedrainsubscriber  for common queue-drain operations. not applied outside the  buffer() s as of now.;;0;operator buffer with boundary and open-close fixes to the timed;variants added `queuedrain` and `queuedrainsubscriber` for common queue-drainoperations not applied outside the `buffer()`s as of now;;;;;1;1;operator buffer with boundary and open-close fixes to the timedvariants added queuedrain and queuedrainsubscriber for common queue-drainoperations not applied outside the buffer()s as of now;
3251;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;window with count  count + skip.;luckily  there is no need to count the emission per subject but just use arithmetic.;;0;window with count count + skip;luckily there is no need to count the emission per subject but just usearithmetic;;;;;1;1;window with count count + skipluckily there is no need to count the emission per subject but just usearithmetic;
3253;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator window timespan  timespan + count  timespan + timeskip;the timed buffer and window operators are quite complicated in terms of concurrency. i m not sure if all corner cases are covered.;;0;operator window timespan timespan + count timespan + timeskip;the timed buffer and window operators are quite complicated in terms ofconcurrency im not sure if all corner cases are covered;;;;;1;1;operator window timespan timespan + count timespan + timeskipthe timed buffer and window operators are quite complicated in terms ofconcurrency im not sure if all corner cases are covered;
3254;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator debounce (time  selector)  throttlewithtimeout (alias);(taking a break from  window()  operators.);;0;operator debounce (time selector) throttlewithtimeout (alias);(taking a break from `window()` operators);;;;;1;1;operator debounce (time selector) throttlewithtimeout (alias);
3255;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator scan  reduce. fixes to testsubscriber async behavior.;testsubscriber now does asynchronous requests and cancellation.;;0;operator scan reduce fixes to testsubscriber async behavior;testsubscriber now does asynchronous requests and cancellation;;;;;1;1;operator scan reduce fixes to testsubscriber async behavior;
3256;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fixed debounce behavior  added throttlefirst  throttlelast alias;i ve implemented the wrong debounce logic in #3254 .;;0; debounce behavior added throttlefirst throttlelast alias;ive implemented the wrong debounce logic in #3254;;;;;1;1; debounce behavior added throttlefirst throttlelast alias;
3257;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator timeout  onbackpressurebuffer(onoverflow)  fixes to parameter;types. - fullarbiter and fullarbitersubscriber to work with total-ordered notifications across sources.  i ve also sorted  observable  members.;;0;operator timeout onbackpressurebuffer(onoverflow) fixes to parameter;types- fullarbiter and fullarbitersubscriber to work with total-ordered notifications across sourcesive also sorted `observable` members;;;;;1;1;operator timeout onbackpressurebuffer(onoverflow) fixes to parametertypes+ fullarbiter and fullarbitersubscriber to work with total-orderednotifications across sources;
3258;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;replaysubject;has full backpressure support (replays as many elements as requested).;;0;replaysubject;has full backpressure support (replays as many elements as requested);@akarnokd do you also plan to provide  backpressure support for `replaysubject` in 1x? (id like it!) || there was an attempt before but didnt get through the problem with 1x is that it has an expected optimization to goes on a fast path once the subscriber has caught up and no further replay/buffering happens for that particular subscriber with backpressure there would be one cas at minimum for every value delivered which has 6x the overhead compared to a write-through ||;;;;1;1;replaysubjecthas full backpressure support (replays as many elements as requested);
3259;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;rxjavaplugins extended with handler registration and reset support;;;0;rxjavaplugins extended with handler registration and reset support;;;;;;1;1;rxjavaplugins extended with handler registration and reset support;
3260;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;behaviorsubject;the continuous delivery guarantee and the no-duplication requirement makes it necessary to read/write an index and object values together. i ve implemented this with another synchronized block. the alternatives are: - use an object of (index  value) and atomically set the reference (requires allocation on every value delivered. - this current nested-synchronized block (no deadlock) - use a reader-writer lock which works better when concurrent subscribers want to do their first emission at the same time.;;0;behaviorsubject;the continuous delivery guarantee and the no-duplication requirement makes it necessary to read/write an index and object values together ive implemented this with another synchronized block the alternatives are:- use an object of (index value) and atomically set the reference (requires allocation on every value delivered- this current nested-synchronized block (no deadlock)- use a reader-writer lock which works better when concurrent subscribers want to do their first emission at the same time;;;;;1;1;behaviorsubject;
"3261;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fixes to replaysubject and behaviorsubject.;replaysubject: time and size bound trimming was incorrectly deleting the terminal notification  behaviorsubject: double emission of the same value. the following loop fails (prints  bad pattern received: [2  2] ) with 1.x:      java for (int i = 0  i < 1_000_000  i++) {     if (i % 1000 == 0) {         system.out.println( -->   + i)      }     behaviorsubject<object> bs = behaviorsubject.create(1)       list<object> list = new arraylist<>()      cyclicbarrier cb = new cyclicbarrier(2)      countdownlatch cdl = new countdownlatch(1)       forkjoinpool.commonpool().submit(() -> {         cb.await()          bs.onnext(2)          cdl.countdown()          return null      })       cb.await()      bs.subscribe(v -> list.add(v))      cdl.await()       if (arrays.aslist(2).equals(list)) {         continue      }     if (arrays.aslist(1  2).equals(list)) {         continue      }     system.out.println( bad pattern received:   + list)          break      } };;0;fixes to replaysubject and behaviorsubject;""replaysubject: time and size bound trimming was incorrectly deleting the terminal notificationbehaviorsubject: double emission of the same value the following loop fails (prints `bad pattern received: [2 2]`) with 1x:``` javafor (int i  0 i < 1_000_000 i++) {    if (i % 1000  0) {        systemoutprintln(""""--> """" + i)    }    behaviorsubject<object> bs  behaviorsubjectcreate(1)    list<object> list  new arraylist<>()    cyclicbarrier cb  new cyclicbarrier(2)    countdownlatch cdl  new countdownlatch(1)    forkjoinpoolcommonpool()submit(() -> {        cbawait()        bsonnext(2)        cdlcountdown()        return null    })    cbawait()    bssubscribe(v -> listadd(v))    cdlawait()    if (arraysaslist(2)equals(list)) {        continue    }    if (arraysaslist(1 2)equals(list)) {        continue    }    systemoutprintln(""""bad pattern received: """" + list)        break    }}```"";;;;;1;1;fixes to replaysubject and behaviorsubject;"
3262;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator window with boundary (exact  selector  exact + supplier).;i m not 100% certain about the state management: when to let the main source keep running and when to stop. i.e.  the in the selector version  if the other completes  it means no new window will be opened but the active should keep receiving values until their closer fires. if all such closers have fired  the main can be stopped.;;0;operator window with boundary (exact selector exact + supplier);im not 100% certain about the state management: when to let the mainsource keep running and when to stop ie the in the selector versionif the other completes it means no new window will be opened but theactive should keep receiving values until their closer fires if allsuch closers have fired the main can be stopped;;;;;1;1;operator window with boundary (exact selector exact + supplier)im not 100% certain about the state management: when to let the mainsource keep running and when to stop ie the in the selector versionif the other completes it means no new window will be opened but theactive should keep receiving values until their closer fires if allsuch closers have fired the main can be stopped;
3263;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;subjects onnext and onerror null safety;subjects are exposed so they may receive nulls that would mess up the internal state.;;0;subjects onnext and onerror null safety;subjects are exposed so they may receive nulls that would mess up the internal state;;;;;1;1;subjects onnext and onerror null safety;
3265;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;rxjavaplugins performance enabling fix & lockdown.;by using null checks and direct returns we can avoid a dynamic dispatch on a volatile variable which always more expensive.  i ve also added the  lockdown()  method to prevent any further changing of the plugin handlers. there is a  unlock  package-private method to allow testing the plugin in the locked state and then return to the unlocked state as other tests may want to install custom plugins.;;0;rxjavaplugins performance enabling fix & lockdown;by using null checks and direct returns we can avoid a dynamic dispatchon a volatile variable which always more expensiveive also added the `lockdown()` method to prevent any further changingof the plugin handlers there is a `unlock` package-private method toallow testing the plugin in the locked state and then return to theunlocked state as other tests may want to install custom plugins;;;;;1;1;rxjavaplugins performance enabling fix & lockdownby using null checks and direct returns we can avoid a dynamic dispatchon a volatile variable which always more expensiveive also added the `lockdown()` method to prevent any further changingof the plugin handlers there is a `unlock` package-private method toallow testing the plugin in the locked state and then return to theunlocked state as other tests may want to install custom plugins;
3267;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;operator generate: create an observable that generates values by calling;a function and handling backpressure/resource cleanup automatically.  the logic is based on @stealthcode  s syncsubscriber proposal from 1.x but using only the lambda-form.;;0;operator generate: create an observable that generates values by calling;a function and handling backpressure/resource cleanup automaticallythe logic is based on @stealthcode s syncsubscriber proposal from 1xbut using only the lambda-form;;;;;1;1;operator generate: create an observable that generates values by calling a function and handling backpressure/resource cleanup automaticallythe logic is based on @stealthcode s syncsubscriber proposal from 1xbut using only the lambda-form;
3268;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;standard disposables  changes to resource containers to support them.;-  disposables  utility class with wrapper methods named  from .;;0;standard disposables changes to resource containers to support them;- `disposables` utility class with wrapper methods named `from`;;;;;1;1;standard disposables changes to resource containers to support them;
3270;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;unicastsubject javadoc  support for oncancelled notification.;the cancellation notification will come in handy with window (and in groupby). it helps with the case when the main source has been cancelled but the individual windows/groups are still being consumed. if those get cancelled by their single subscribers  this notification will reach the source and once all windows/groups get cancelled  the main source can be cancelled.  fix to generator production accounting.;;0;unicastsubject javadoc support for oncancelled notification;the cancellation notification will come in handy with window (and ingroupby) it helps with the case when the main source has been cancelledbut the individual windows/groups are still being consumed if those getcancelled by their single subscribers this notification will reach thesource and once all windows/groups get cancelled the main source can becancelledfix to generator production accounting;;;;;1;1;unicastsubject javadoc support for oncancelled notificationthe cancellation notification will come in handy with window (and ingroupby) it helps with the case when the main source has been cancelledbut the individual windows/groups are still being consumed if those getcancelled by their single subscribers this notification will reach thesource and once all windows/groups get cancelled the main source can becancelledfix to generator production accounting;
3271;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;first unit test and fixes to operators.;fixed mistakes in the operators.;;0;first unit test and fixes to operators; mistakes in the operators;;;;;1;1;first unit test and fixes to operators;
3273;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;fix attempt to the firehose test.;either the test is non-deterministic or i still have a bug.;;0;fix attempt to the firehose test;either the test is non-deterministic or i still have a bug;;;;;1;1;sleeping instead of computational waiting;
3275;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;simplest combinelatest tests and fix to groupby.;forgot to deliver the value inside the groupedunicast drain loop.;;0;simplest combinelatest tests and fix to groupby;forgot to deliver the value inside the groupedunicast drain loop;;;;;1;1;simplest combinelatest tests and fix to groupbyforgot to deliver the value inside the groupedunicast drain loop;
3276;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;simplest concat test from 1.x;i ve also added convenience overloads to concat 2-9 sources because  concat(publisher)  causes overload resolution conflict with  concat(publisher<publisher>) .;;0;simplest concat test from 1x;ive also added convenience overloads to concat 2-9 sources because `concat(publisher)` causes overload resolution conflict with `concat(publisher<publisher>)`;;;;;1;1;simplest concat test from 1xive also added convenience overloads to concat 2-9 sources because`concat(publisher)` causes overload resolution conflict with`concat(publisher<publisher>)`;
3277;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;errorhandlingtests and eventstream;i ve changed them to use  safesubscribe  because plain rs subscribers are not expected to throw.;;0;errorhandlingtests and eventstream;ive changed them to use `safesubscribe` because plain rs subscribersare not expected to throw;;;;;1;1;errorhandlingtests and eventstreamive changed them to use `safesubscribe` because plain rs subscribersare not expected to throw;
3278;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;simplest tests of groupby  merge and notification;we need to talk about  notification s.;;0;simplest tests of groupby merge and notification;we need to talk about `notification`s;;;;;1;1;simplest tests of groupby merge and notification;
3279;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;conversiontest and doontest;forgot to call request  refactored some validation code.;;0;conversiontest and doontest;forgot to call request refactored some validation code;;;;;1;1;conversiontest and dontest;
3280;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;observabletests and bugfixes.;bugfixes in many operators.;;0;observabletests and bugfixes;bugfixes in many operators;;;;;1;1;added missing header and  javadoc link;
3282;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;simpler tests for window reduce  scan  starwith.;i ve refectored the mocksubscriber method out into a helper enum since it will be required almost everywhere.;;0;simpler tests for window reduce scan starwith;ive refectored the mocksubscriber method out into a helper enum since it will be required almost everywhere;;;;;1;1;simpler tests for window reduce scan starwith;
3283;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;subscribertests port from 1.x;they seem to try testing the request mechanism on thin implementations and are somewhat of no use.;;0;subscribertests port from 1x;they seem to try testing the request mechanism on thin implementations and are somewhat of no use;;;;;1;1;subscribertests port from 1x;
3284;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;simpler tests of throttlelast  throttlewithtimeout  zip;tests expect certain operator parameter orders so i d expect a few changes in observable in this regard.  fixed timing bug with  throttlewithtimeout  but i m not 100% certain it works as expected beyond this single test.;;0;simpler tests of throttlelast throttlewithtimeout zip;tests expect certain operator parameter orders so id expect a few changes in observable in this regard timing bug with `throttlewithtimeout` but im not 100% certain it works as expected beyond this single test;;;;;1;1;simpler tests of throttlelast throttlewithtimeout zip;
3286;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: implements blockingsingle;adds blockingsingle (issue #3252)  the blocking version of rx.single.  blockingsingle has the following methods: -  from(single)  -- factory method for creating a  blockingsingle  from a    single  -  value()  -- returns the value emitted from the single -  tofuture()  -- returns a  java.util.concurrent.future   couldn t actually think of any other useful operations to perform on  blockingsingle  - in comparison to  blockingobservable   there s not much to this class (at the moment).;;3252.0;1x: implements blockingsingle;adds blockingsingle (issue #3252) the blocking version of rxsingleblockingsingle has the following methods:- `from(single)` -- factory method for creating a `blockingsingle` from a  `single`- `value()` -- returns the value emitted from the single- `tofuture()` -- returns a `javautilconcurrentfuture`couldnt actually think of any other useful operations to perform on `blockingsingle` - in comparison to `blockingobservable` theres not much to this class (at the moment);~~hmmmgot a test failure that i cant reproduce locally:~~ ( by #3285)```rxobservablessynconsubscribetest > testsubscribeon failed    javalangassertionerror: expected:<4> but was:<3>        at orgjunitassertfail(assertjava:93)        at orgjunitassertfailnotequals(assertjava:647)        at orgjunitassertassertequals(assertjava:128)        at orgjunitassertassertequals(assertjava:472)        at orgjunitassertassertequals(assertjava:456)        at rxobservablessynconsubscribetesttestsubscribeon(synconsubscribetestjava:734``` || this test failure should be resolved now  || @hyleung is this ready to be reviewed/merged? || @abersnaze not quite yet there are a couple of things from @artem-zinnatullins pr (#3416) that i want to pull in (splitting out a separate `blockingutils` class to hold `awaitcomplete` for example) also im going to rebase it against head of 1x since its been about a month || @abersnaze the pr is ready for review btw ill keep the commits separate as i incorporate the feedback and squash it down at the end || maybe move `blockingsingle` from `rxobservables` to `rxsingles`? || @artem-zinnatullin re `rxsingles` - that would be a new package then? ~~dont have a particular option either way tbh - anybody else?~~ ah i see what youre getting atmoved to `rxsingles` which other operators are you thinking of adding to `single` btw? || lgtm just a few nits left  im ready to merge this as long as we can add the necessary `@experimental` annotations and rebase onto 1x || @stealthcode done!  ||  :+1:thanks for contributing ||;add singletoblocking?;now that we have `rxsingle`  would it make sense to add a `toblocking()` method on the`rxsingle` that would return the blocking version of the single similar to `rxobservabletoblocking()`?given that single either returns a single item or fails id imagine it would be pretty minimal i took a stab at it [here]( - just a `get()` to return the value and `tofuture()` at the moment couldnt think of anything else that would be useful on a blocking single;do you want to open a pull request with your change to branch 1x?  || close by #3286 ||;1;0;implements blockingsinglethis commit adds blockingsingle the blocking version of rxsingleblockingsingle has the following methods:i `from(single)` -- factory method for creating a `blockingsingle` from a`single`- `get()` -- returns the value emitted from the single- `get(func1<tboolean> predicate)` -- returns the value if it matches  the provided predicate- `tofuture()` -- returns a `javautilconcurrentfuture`adds singletoblocking;
3292;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;unit test for blocking operators.;;;0;unit test for blocking operators;;;;;;1;1;unit test for blocking operators;
3293;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;test some unicastsubject  cache  notificationlite  amb;- bugfix to cache  skipuntil and takeunit;;0;test some unicastsubject cache notificationlite amb;- bugfix to cache skipuntil and takeunit;;;;;1;1;test some unicastsubject cache notificationlite amb+ bugfix to cache skipuntil and takeunit;
3294;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;more tests and bugfixes to operators.;;;0;more tests and bugfixes to operators;;;;;;1;1;more tests and bugfixes to operators;
3297;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: unit tests and fixes for fromiterable and range;;;0;2x: unit tests and fixes for fromiterable and range;;;;;;1;1;2x: unit tests and fixes for fromiterable and range;
3298;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: tests for refcount and timer  fixes to flatmap  publish and range;;;0;2x: tests for refcount and timer fixes to flatmap publish and range;;;;;;1;1;2x: tests for refcount and timer fixes to flatmap and publish range;
3300;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: test for operators all  any  asobservable  fixes to all and any;bugfix: since they would emit a value on an empty source  they have to hold it until an actual request comes in.;;0;2x: test for operators all any asobservable fixes to all and any;bugfix: since they would emit a value on an empty source they have to hold it until an actual request comes in;;;;;1;1;2x: test for operators all any asobservable fixes to all and any;
3301;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: test for buffer  i m still missing the boundary-supplier version;;;0;2x: test for buffer im still missing the boundary-supplier version;;;;;;1;1;2x: test for buffer im still missing the boundary-supplier version;
3303;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: added missing buffer overload (with boundary selector);- added asyncsubscription that allows setting the actual subscription   later and can hold a resource. it has less overhead than   subscriptionarbiter due to single use.;;0;2x: added missing buffer overload (with boundary selector);- added asyncsubscription that allows setting the actual subscription  later and can hold a resource it has less overhead than  subscriptionarbiter due to single use;;;;;1;1; fromfuture added headers;
3305;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: classes single and nbpobservable;single  is a deferred single-value emitting observable.   nbpobservable  is the non-backpressure observable  named this way until the main observable gets all its tests ported so a refactor can deal with all of them.  i ve implemented the most basic construction and operator methods on them.;;0;2x: classes single and nbpobservable;`single` is a deferred single-value emitting observable`nbpobservable` is the non-backpressure observable named this way untilthe main observable gets all its tests ported so a refactor can dealwith all of themive implemented the most basic construction and operator methods onthem;+1 || im merging this so the independent work on both can be started ||;;;;1;1;2x: classes single and nbpobservable`single` is a deferred single-value emitting observable`nbpobservable` is the non-backpressure observable named this way untilthe main observable gets all its tests ported so a refactor can dealwith all of themive implemented the most basic construction and operator methods onthem;
3306;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: operators cast and concat tests;the concat reuses the same inner subscriber to save on its allocation cost which works only if the inner source conforms with the spec and doesn t emit any event after an oncomplete(). there is a test that explicitly calls oncomplete() twice to test the resilience of concat. the current workaround makes this test pass but any async non-conforming source may still bug out the operator.   this is a tradeoff between safety and performance. if we d expect such non-conforming behavior  the current optimization has to be turned into a regular individually allocated inner subscribers.;;0;2x: operators cast and concat tests;the concat reuses the same inner subscriber to save on its allocationcost which works only if the inner source conforms with the spec anddoesnt emit any event after an oncomplete() there is a test thatexplicitly calls oncomplete() twice to test the resilience of concatthe current workaround makes this test pass but any async non-conformingsource may still bug out the operator this is a tradeoff between safety and performance if wed expect suchnon-conforming behavior the current optimization has to be turned intoa regular individually allocated inner subscribers;;;;;1;1;2x: operators cast and concat teststhe concat reuses the same inner subscriber to save on its allocationcost which works only if the inner source conforms with the spec anddoesnt emit any event after an oncomplete() there is a test thatexplicitly calls oncomplete() twice to test the resilience of concatthe current workaround makes this test pass but any async non-conformingsource may still bug out the operator this is a tradeoff between safety and performance if wed expect suchnon-conforming behavior the current optimization has to be turned intoa regular individually allocated inner subscribers;
3309;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: operator test distinct  distinctuntilchanged and dooneach;note: several tests have been ignored due to non-conformance with rs  added missing distinct and distinctuntilchanged overloads  fixed dooneach not cancelling upstream if the callback crashes on the onnext path.;;0;2x: operator test distinct distinctuntilchanged and dooneach;note: several tests have been ignored due to non-conformance with rsadded missing distinct and distinctuntilchanged overloads  dooneach not cancelling upstream if the callback crashes on the onnext path;;;;;1;1;2x: operator test distinct distinctuntilchanged and dooneachnote: several tests have been ignored due to non-conformance with rs;
3311;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: operator test elementat  filter  finally  first;- fixed exceptions throw by elementat;;0;2x: operator test elementat filter finally first;-  exceptions throw by elementat;;;;;1;1;2x: operator test elementat filter finally first;
3312;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: operator test flatmap  merge  mergedelayerror;- added operator flatmap of notifications  fixed a bug in onbackpressurebuffer  note also the few ignored tests because they either want to test against a null value or try to throw from rs methods.;;0;2x: operator test flatmap merge mergedelayerror;- added operator flatmap of notifications  a bug in onbackpressurebuffernote also the few ignored tests because they either want to test against a null value or try to throw from rs methods;;;;;1;1;2x: operator test flatmap merge mergedelayerror+ added operator flatmap of notifications  a bug inonbackpressurebuffer;
3313;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: operator test for groupby  fix to groupby and type argument swap;for groupedobservable - added booleansubscription to detect cancellation without caring about   requests.  i m still not 100% convinced the groupby request coordination works properly (i.e.  no stall due lack of requests from one of the groups).;;0;2x: operator test for groupby fix to groupby and type argument swap;for groupedobservable- added booleansubscription to detect cancellation without caring about  requestsim still not 100% convinced the groupby request coordination worksproperly (ie no stall due lack of requests from one of the groups);;;;;1;1;2x: operator test for groupby fix to groupby and type argument swapfor groupedobservable+ added booleansubscription to detect cancellation without caring aboutrequestsim still not 100% convinced the groupby request coordination worksproperly (ie no stall due lack of requests from one of the groups);
3315;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: operator test observeon;- fix to observeon to not request if cancelled in onnext delivery - fix combinelatest error emission if the other sources are late or   never emit - fix interval and publishsubject to send missingbackpressureexception;;0;2x: operator test observeon;- fix to observeon to not request if cancelled in onnext delivery- fix combinelatest error emission if the other sources are late or  never emit- fix interval and publishsubject to send missingbackpressureexception;;;;;1;1;2x: operator test observeon and related bugfixes;
3316;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: operator test onbackpressure(buffer|drop|latest) and their bugfix;;;0;2x: operator test onbackpressure(buffer|drop|latest) and their bugfix;;;;;;1;1;2x: operator test onbackpressure(buffer|drop|latest) and their bugfix;
3317;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: operator test onerror and onexception  relevant bugfixes;i had to ignore tests that throw exceptions from a publisher.subscribe or an operator.apply due to their non-conformant behavior.;;0;2x: operator test onerror and onexception relevant bugfixes;i had to ignore tests that throw exceptions from a publishersubscribe or an operatorapply due to their non-conformant behavior;;;;;1;1;2x: operator test onerror and onexception relevant bugfixes;
3318;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: operator tests: publish  reduce  repeat + fixes;- added tosingle and tonbpobservable to observable - fixed bugs in many operators and in the io scheduler s release logic;;0;2x: operator tests: publish reduce repeat + fixes;- added tosingle and tonbpobservable to observable-  bugs in many operators and in the io schedulers release logic;;;;;1;1;2x: operator tests: publish reduce repeat + fixes+ added tosingle and tonbpobservable to observable+  bugs in many operators and in the io schedulers release logic;
3319;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: operator test for replay;note that testissue_2191_schedulerunsubscribe had to change the call count to pass. i don t understand this test and the over-mocking (but recognize the style).;;0;2x: operator test for replay;note that testissue_2191_schedulerunsubscribe had to change the callcount to pass i dont understand this test and the over-mocking (butrecognize the style);;;;;1;1;2x: operator test for replaynote that testissue_2191_schedulerunsubscribe had to change the callcount to pass i dont understand this test and the over-mocking (butrecognize the style);
3320;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: operator test: retry  retrywhen;- retry with bipredicate - fixed map not checking the returned value for null - since rs doesn t allow throwing other than npe  temporarily subscribe   and lift will throw npe with the actual error as cause so we don t miss   an operator bug due to swallowed exceptions.;;0;2x: operator test: retry retrywhen;- retry with bipredicate-  map not checking the returned value for null- since rs doesnt allow throwing other than npe temporarily subscribe  and lift will throw npe with the actual error as cause so we dont miss  an operator bug due to swallowed exceptions;;;;;1;1;2x: operator test: retry retrywhen+ retry with bipredicate+  map not checking the returned value for null+ since rs doesnt allow throwing other than npe temporarily subscribeand lift will throw npe with the actual error as cause so we dont missan operator bug due to swallowed exceptions;
3322;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: operator test: serialize  single + serializedsubscriber fix;;;0;2x: operator test: serialize single + serializedsubscriber fix;;;;;;1;1;2x: operator test: serialize single + serializedsubscriber fix;
3323;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: operator test: skip variants and bugfix;note that since we know have time unit in schedulers  one must be careful with the time unit of the timed skip operators. the timestamps will be calculated via this unit and may not return the expected values.   for example  a skiplast of 1 second will not skip the value 0.5 seconds before completion because its timestamp is rounded down to the start of the second. but if one uses 1000 milliseconds  the value will be skipped.;;0;2x: operator test: skip variants and bugfix;note that since we know have time unit in schedulers one must becareful with the time unit of the timed skip operators the timestampswill be calculated via this unit and may not return the expected values for example a skiplast of 1 second will not skip the value 05 secondsbefore completion because its timestamp is rounded down to the start ofthe second but if one uses 1000 milliseconds the value will beskipped;;;;;1;1;2x: operator test: skip variants and bugfixnote that since we know have time unit in schedulers one must becareful with the time unit of the timed skip operators the timestampswill be calculated via this unit and may not return the expected values for example a skiplast of 1 second will not skip the value 05 secondsbefore completion because its timestamp is rounded down to the start ofthe second but if one uses 1000 milliseconds the value will beskipped;
3325;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: operator tests: take family + fixes;- fixed a deadlock possibility in one of the merge tests;;0;2x: operator tests: take family + fixes;-  a deadlock possibility in one of the merge tests;;;;;1;1;2x: operator tests: take family + fixes;
3327;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: operator tests: timestamp  tomap  tomultimap  tolist  tosortedlist;- signature fix to tomultimap and removed deprecated markers.;;0;2x: operator tests: timestamp tomap tomultimap tolist tosortedlist;- signature fix to tomultimap and removed deprecated markers;;;;;1;1;workaround for javac added missing headers;
3328;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: operator tests unsubscribeon  withlatestfrom  zip (partial);- fixed cancellation behavior of observeon  subscribeon and   unsubscribeon (when and what to call cancel on) - fixed infinite loop in scheduledrunnable - fixed zip not quitting eagerly if one of the sources was shorter - added specific zipiterable because zip-iterable tests expect it to be   not prefetching any of the sources (the plain zip does prefetch) - made the fromiterable more resilient to iterable/iterator crashes and   added null-value checks;;0;2x: operator tests unsubscribeon withlatestfrom zip (partial);-  cancellation behavior of observeon subscribeon and  unsubscribeon (when and what to call cancel on)- fixed infinite loop in scheduledrunnable- fixed zip not quitting eagerly if one of the sources was shorter- added specific zipiterable because zip-iterable tests expect it to be  not prefetching any of the sources (the plain zip does prefetch)- made the fromiterable more resilient to iterable/iterator crashes and  added null-value checks;;;;;1;1;2x: operator tests unsubscribeon withlatestfrom zip (partial)+  cancellation behavior of observeon subscribeon andunsubscribeon (when and what to call cancel on)+ fixed infinite loop in scheduledrunnable+ fixed zip not quitting eagerly if one of the sources was shorter+ added specific zipiterable because zip-iterable tests expect it to benot prefetching any of the sources (the plain zip does prefetch)+ made the fromiterable more resilient to iterable/iterator crashes andadded null-value checks;
3329;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: operator test: window variants;i had to adjust some test slightly due to the a new behavior: if one cancels a source which is windowed  as long as the windows are active  the source has to stay active. however  there are more subtle possibilities that need new tests.;;0;2x: operator test: window variants;i had to adjust some test slightly due to the a new behavior: if onecancels a source which is windowed as long as the windows are activethe source has to stay active however there are more subtlepossibilities that need new tests;;;;;1;1;2x: operator test: window variantsi had to adjust some test slightly due to the a new behavior: if onecancels a source which is windowed as long as the windows are activethe source has to stay active however there are more subtlepossibilities that need new tests;
3330;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: operator test zip and safesubscribertest;;;0;2x: operator test zip and safesubscribertest;;;;;;1;1;2x: operator test zip and safesubscribertest;
3331;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: schedulers test of classic schedulers;;;0;2x: schedulers test of classic schedulers;;;;;;1;1;2x: scheduler tests (no single() yet);
3333;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: subscribers/observers tests;i had to ignore many tests because they either test with null or throw an exception from a subscriber method which are not allowed with rs. - added observers and subscribers to create observers/subscribers with convenience.;;0;2x: subscribers/observers tests;i had to ignore many tests because they either test with null or throwan exception from a subscriber method which are not allowed with rs- added observers and subscribers to create observers/subscribers with convenience;;;;;1;1;2x: subscribers/observers testsi had to ignore many tests because it either tests with null or throwsan exception from a subscriber method which are not allowed with rs;
3334;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: disposable unit tests + fix to refcountdisposable behavior;- sorted  observable  and added  @backpressuresupport  and    schedulersupport  annotations. - created  @beta  and  @experimental  annotations  nothing is marked   with them because i intent everything to be standard at this point.;;0;2x: disposable unit tests + fix to refcountdisposable behavior;- sorted `observable` and added `@backpressuresupport` and  `schedulersupport` annotations- created `@beta` and `@experimental` annotations nothing is marked  with them because i intent everything to be standard at this point;;;;;1;1;2x: disposable unit tests + fix to refcountdisposable behavior+ sorted `observable` and added `@backpressuresupport` and`schedulersupport` annotations+ created `@beta` and `@experimental` annotations nothing is markedwith them because i intent everything to be standard at this point;
3335;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: scalar flatmap optimization enabled;- i wanted to make sure the slow path passes all tests before enabling   the scalar optimization. - fixed headers for internal classes;;0;2x: scalar flatmap optimization enabled;- i wanted to make sure the slow path passes all tests before enabling  the scalar optimization-  headers for internal classes;;;;;1;1;2x: scalar flatmap optimization enabled+ i wanted to make sure the slow path passes all tests before enablingthe scalar optimization+  headers for internal classes;
3340;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;test/subjects: use statically imported never() methods; and remove the unused mockito imports;;0;test/subjects: use statically imported never() methods;and remove the unused mockito imports;see #3291 || @akarnokd are you seriously suggesting that cleaning up code to make it more consistent is a bad thing and shouldnt be done? || cosmetic prs especially on unit test or on internal classes dont really contribute anything to the library || wow || im okay with this type of change it makes the code more consistent and is a simple non-intrusive change || thank you @turbo87 for the contribution! || @benjchristensen cool  @turbo87 i apologize for my harsh and dry comments generally im in favor of cleanups such as yours and would have done it the same way i was under the false impression that the project doesnt want such cleanups im sorry if i offended you || @akarnokd nevermind seems it all worked out in the end ) ||;;;;1;1;behaviorsubjecttest: simplify testunsubscriptioncase() test;
"3352;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: perf checks for flatmap and merge;ported the two perf tests to evaluate 2.x throughput.  (  my primary suspect for the extra overhead are the atomics of queue-drain. the 1.x uses a synchronized-based emitter-loop which is elided by the jit compiler but atomics can t be elided. as i mentioned before  synchronized works better for light-to-none asynchronous use whereas atomics work better for asynchronous use.  also quote from #3157  > exceptions that do not require a :+1: would be: >  > javadoc changes > unit test additions or refactoring > **perf test additions  fixes or refactoring** > grammatical and presentation fixes to readme  contributing  and other such metadata files;;3157.0;2x: perf checks for flatmap and merge;ported the two perf tests to evaluate 2x throughput( primary suspect for the extra overhead are the atomics of queue-drain the 1x uses a synchronized-based emitter-loop which is elided by the jit compiler but atomics cant be elided as i mentioned before synchronized works better for light-to-none asynchronous use whereas atomics work better for asynchronous usealso quote from #3157> exceptions that do not require a :+1: would be:> > javadoc changes> unit test additions or refactoring> **perf test additions fixes or refactoring**> grammatical and presentation fixes to readme contributing and other such metadata files;;committer merge policy;thus far there have been so few committers that we havent had a formal policy mostly just an arrangement between @akarnokd and myself as per  we are seeking to increase the number of people involved in reviewing pull requests and thus will end up with more people merging changesi dont want to over police this but i do think we should formalize to having at least a :+1: from another committer before any pull request is merged that affects code in /src/main exceptions that do not require a :+1: would be:- javadoc changes- unit test additions or refactoring- perf test additions fixes or refactoring- grammatical and presentation fixes to readme contributing and other such metadata filesthings that do require a :+1: would be:- any code changes to /src/main that would affect running applications- unit test changes that affect behavior being tested- changes to readme contributing license etc that affect meaning of the document- changes to build or releasethoughts? agreement? disagreement?/cc @reactivex/rxjava-committers;"":+1: maybe not require a like for additions to the internal package that otherwise doesnt affect existing code or is essentially unused (as of the time) example: addition of a new queue implementation for later use bugfix to this queue when it is still not in usedeleting unused code still requires a likeperhaps it is better to state that prs requiring likes with at least 2 likes can be merged since the merge can be performed by either of the like giver or somebody else || :+1:we can also :+1: but recommend to wait for more (in case of unfamiliar part of the code)eg """":+1: look good to me but wait for david to confirm"""" || :+1: in addition i think the build script changes also require a like such as #3089 || agreed @zsxwing  || added """"changes to build or release"""" to description above || ive been thinking about this and id add a timeout to the second approval how about 3 business days after which if nobody else complains the first and only approver can merge stuff on his own responsibility? || +1 to this i guess youll receive response to the comment in 3 business days :)but id keep """"at least 2 :+1:s"""" rule via requiring :+1: from one or more developers who are not part of the rxjava github team but have at least 1-2 good contributions to the rxjava || @artem-zinnatullin does raise a point of interest to me ive contributed about 4000 lines to the code base   mostly in the last year but as a non-committer would not be expected to put a thumbs-up on issues/prs but rather something like lgtm? || > lgtm:+1: for rxjava team and lgtm for others looks good to me more eyes and feedback  better result :) || i dont see why the distinction is needed or usefulalso why are all of the v2 prs being merged without any review?on thu sep 3 2015 6:13 pm artem zinnatullin notifications@githubcomwrote:> lgtm> > [image: :+1:] for rxjava team and lgtm for others looks good to me more> eyes and feedback  better result :)> > > reply to this email directly or view it on github>  || > i dont see why the distinction is needed or useful~~just a hack to see who is in the team and who is not (github ui does not help with that) but yes its not very important~~just found that github displays """"collaborator"""" and """"owner"""" near to the comments hadnt seen it for yearsnow i totally agree distinction is not needed at all> also why are all of the v2 prs being merged without any review?this and prs without tests in v2 bother me too though the speed of v2 development is fantastic || the speed is too fast to keep up! but thats a good complaint to haveon thu sep 3 2015 7:12 pm artem zinnatullin notifications@githubcomwrote:> i dont see why the distinction is needed or useful> > just a hack to see who is in the team and who is not (github ui does not> help with that) but yes its not very important> > just found that github displays """"collaborator"""" and """"owner"""" near to the> comments hadnt seen it for years> > now i totally agree distinction is not needed at all> > also why are all of the v2 prs being merged without any review?> > this and prs without tests in v2 bother me too though the speed of v2> development is fantastic> > > reply to this email directly or view it on github>  || the process with v2 was to reimplement operators first then port the unit tests from v1 because they depend on multiple operators most of the time besides reviewing hundreds of operators would take months at the current review speed due to the +2 rule || your first sentence explains the how not the why i still dont see whythese changes are exempt from oversight i realize code review becomesslower on our library projects i have to go through only one reviewer andit can be annoying but thats the price you pay for creating more correctcode weve saved hundreds of bugs across libraries with this systemso i dont understand why this merge policy exists if it only applies whenits convenienton thu sep 3 2015 7:39 pm david karnok notifications@githubcom wrote:> the process with v2 was to reimplement operators first then port the unit> tests from v1 because they depend on multiple operators most of the time> > besides reviewing hundreds of operators would take months at the current> review speed due to the +2 rule> > > reply to this email directly or view it on github>  || no point in reviewing till unit tests in and passing and all of this action is on the 2x branch might have to wait till a big chunk goes in then review?can i suggest that all prs associated with v2 have a title pre with v2? that way i can filter them mentally when i look at email notifications from github or the abbreviated github combination issues/pr view i realize that these prs have been assigned as milestone 20 but that is only useful when using the github prs ui || > so i dont understand why this merge policy exists if it only applies when its convenient""""any code changes to /src/main that would affect **running applications**""""i dont think anybody runs v2 yet nor is it released officially> i still dont see why these changes are exempt from oversightthey arent but due to the different approach reactive-streams requires one would need to learn to review the new style of code that requires code to learn from and we are in a deadlock situation> your first sentence explains the how not the whymany v1 tests depend on the existence of multiple operators and the dependency graph is complicated if i implement one operator then port its unit test that pulls in 3 other operators which have unit tests requiring 3 subsequent operators 6 degrees of separation in actionby doing operators first i concentrated on the logic minimized the potential interference from others prs and posted operators in batched prs so they dont get too fragmented but can be commented on more easily@davidmoten sure! || > ive been thinking about this and id add a timeout to the second approval how about 3 business days after which if nobody else complains the first and only approver can merge stuff on his own responsibility?im not okay with this type of change the point of the reviews is quality assurance not speed version 1x is mission critical for many companies just because one person can move faster than the group does not mean we reduce the threshold of review we have chosen to adopt this practice for a reason> also why are all of the v2 prs being merged without any review?i currently consider v2 in a pre-alpha sprint phase and am okay with @akarnokd doing what hes been doing to bootstrap the effort it is effectively a massive refactor/port at this pointonce there is unit test coverage and general functionality comparable with v1 we will then flip into a mode like v1 where we require reviews of all prs going forward we are probably a few weeks from that still the initial review of the ported code base will take several months for people to do but i felt it would be best if there was functioning code that could be run as a snapshot and reviewed as a codebase not via dozens of prs that are mostly all boilerplate refactoring once v2 feels like it is more-or-less working i will do a 200-dp1 release to maven central and we will iterate on dp# releases as long as it takes for us to all agree with the public api performance and quality that entire process will go through prs requiring review || if v2 prs are to be exempt i just want it to be an explicit decision instead of trying to make up reasons about why they magically dont fall under the normal policy in general im still fundamentally opposed to the approach for the record> """"any code changes to /src/main that would affect running applications""""> > i dont think anybody runs v2 yet nor is it released officiallywell this is patently false and the fact that youre trying to argue semantics of policy is truly worrying unless you intend v2 to _never_ be used then every piece of code you write actually does affect applications and if you think it doesnt then _every_ pr falls into that argument and can skip their review under the same logic after all no one is running head and even if they are it doesnt affect their applications until they deploy so theres no reason to review synchronously> due to the different approach reactive-streams requires one would need to learn to review the new style of code that requires code to learn from and we are in a deadlock situationthis is a fallacy not only are prs one of the best places to learn these semantics but a vast majority of code review (including things for v1) are trivial normal things that apply to nearly every project the idea that somehow no one else can understand whats happening is ridiculous || @akarnokd has finished the sprint to port 1x to 2x that branch is now following the pr review model and calm enough for everyone to begin reviewing and playing with im going to take time to start working with it and let it settle for a while before attempting a 200-dp1 release to maven central until then it is available as a snapshot and i suggest people start digging in and filing issues or prs with suggestions issues alternatives etcto be clear virtually all design decisions about 2x is still up for grabs if there are strong objective reasons for change there are still large design decisions to make such as being debates in  || im closing this in favor of #4013 and #4016 let me know if theres something is not addressed (in necessary detail) in those || "";1;0;2x: perf checks for flatmap and merge;"
3353;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: range perf + added missing header.;benchmarks synchronous  asynchronous (where the emission can hop onto the receiver thread) and strictly-pipelined (the emitter and receiver are on different threads). results on i7 4790  windows 7 x64  java 1.8u60:      benchmark                (times)   mode  cnt         score        error  units rangeperf.rangeasync           1  thrpt    5    135410 552 ?  20521 908  ops/s rangeperf.rangeasync        1000  thrpt    5     25634 730 ?    284 526  ops/s rangeperf.rangeasync     1000000  thrpt    5        59 073 ?      1 154  ops/s rangeperf.rangepipeline        1  thrpt    5     98895 846 ?  11398 363  ops/s rangeperf.rangepipeline     1000  thrpt    5     16233 903 ?    741 712  ops/s rangeperf.rangepipeline  1000000  thrpt    5        10 621 ?      2 606  ops/s rangeperf.rangesync            1  thrpt    5  30367277 992 ? 170100 628  ops/s rangeperf.rangesync         1000  thrpt    5    212293 380 ?   3605 320  ops/s rangeperf.rangesync      1000000  thrpt    5       248 135 ?      1 775  ops/s;;0;2x: range perf + added missing header;benchmarks synchronous asynchronous (where the emission can hop onto the receiver thread) and strictly-pipelined (the emitter and receiver are on different threads) results on i7 4790 windows 7 x64 java 18u60:```benchmark                (times)   mode  cnt         score        error  unitsrangeperfrangeasync           1  thrpt    5    135410552 ?  20521908  ops/srangeperfrangeasync        1000  thrpt    5     25634730 ?    284526  ops/srangeperfrangeasync     1000000  thrpt    5        59073 ?      1154  ops/srangeperfrangepipeline        1  thrpt    5     98895846 ?  11398363  ops/srangeperfrangepipeline     1000  thrpt    5     16233903 ?    741712  ops/srangeperfrangepipeline  1000000  thrpt    5        10621 ?      2606  ops/srangeperfrangesync            1  thrpt    5  30367277992 ? 170100628  ops/srangeperfrangesync         1000  thrpt    5    212293380 ?   3605320  ops/srangeperfrangesync      1000000  thrpt    5       248135 ?      1775  ops/s```;;;;;1;1;2x: range perf + added missing header;
3354;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: perf change wait to spin-loop for short async benchmarks;i ve noticed that the  times = 1  async range sometimes produces double the throughput without any change to the underlying structure and i ve figured out it is because how my operation system wakes up the await in the benchmark. i switched the tests to spin-loop and now i get a consistent and higher value than before:  (  there are a few light-greens and a few light-reds which i attribute to other fluctuating factors on my computer.  in addition  i ve experimented with two optimizations: one for observing a scalar value on a different thread and one where the  operatorobserveon  is turned into a  publisherobserveon  to save on the allocation of a  publisherlift . the scalar optimization ended up being slower by 15% for some reason i don t understand and the  publishobserveon  had no impact on the throughput within the error range.;;0;2x: perf change wait to spin-loop for short async benchmarks;ive noticed that the `times  1` async range sometimes produces double the throughput without any change to the underlying structure and ive figured out it is because how my operation system wakes up the await in the benchmark i switched the tests to spin-loop and now i get a consistent and higher value than before:( are a few light-greens and a few light-reds which i attribute to other fluctuating factors on my computerin addition ive experimented with two optimizations: one for observing a scalar value on a different thread and one where the `operatorobserveon` is turned into a `publisherobserveon` to save on the allocation of a `publisherlift` the scalar optimization ended up being slower by 15% for some reason i dont understand and the `publishobserveon` had no impact on the throughput within the error range;;;;;1;1;2x: perf change wait to spin-loop for short async benchmarks;
"3357;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;eager concatmap;related discussion in #3017.;;3017.0;eager concatmap;related discussion in #3017;""thanks a lot for contributing this one @akarnokd ive had one look through and no problems jump out at me but i will review further this will be useful || thanks for the review @davidmoten  usually i use one letter variables because i find it easier to parse the code and instead of long variable names i use newlines to separate logical blocks this way i dont have to type that many letters and i dont have to wait while eclipse returns with the content assist (which is blocking by the way and may take hundreds of milliseconds even on my i7 + ssd)i took the time and renamed variables as you asked for and added some more unit tests that check the code paths that being said i dont plan to do such renames in my contributions very often in the future and encourage anybody to post their prs with their proposed cleanups/renames || thanks for the feedback ive updated the method names to `concatmapeager` and `concateager` added the `@experimental` tags some javadoc and a missing test for a 2-parameter `concateager` overload || updated with a capacity fix for the `spsclinkedarrayqueue` || i reviewed in details in the code and i believe it is correctbut i wonder if subscribing to the sources in a """"unbounded mode"""" is the right thing to doat the expense of complexifying the code i believe it could be possible to split the `request(n)` between the sources maybe requesting `1` to all the `m` sources expect the first one which we request `n - m + 1`  and so onthe devil is in the details and i believe this would significantly complexify the code but i would like to know what you are thinking about this? || @stevegury this operator consumes source observables in order and doesnt make sense to split any request from downstream if the downstream requests n and the first is requested n / count that would hang the sequence because only the first is allowed to emit and it wont emit enough to trigger a new requestit is possible to use a bounded buffer per source so while they are not consumed they dont grow indefinitely however it means that each of them can produce only `rxringbuffersize` elements before stopping and thus the operator wouldnt be eager anymore || @akarnokd sorry i wasnt very clear but what i proposed was roughly what you described (replacing `rxringbuffersize`  1`)my main concern here is the use of unbounded buffer which i think could be avoided || @davidmoten what do you think about the bounded buffering and the fact that such sources would act more like a delayed source? || id be happy to see bounded buffering (`rxringbuffersize` sounds a better default size than 1 to me and would be consistent with the request eagerness of other operators like `merge` for instance) could we add an overload to allow the specification of buffer size as well?if this is significant rework im content to see this unbounded version documented with its buffering characteristics merged and we can defer the bounding work to another pr || done || great thanks @akarnokd ! lightning quick as always || lgtm  the three of you seem happy with it so im merging it || "";eager concatmap;is there already a name for something in the ecosystem that is like an eager concatmap or ordered flatmap?i often see the pattern of people wanting to eagerly kick off several observables but merge them together in order it is absolutely not a good idea for infinite lists but similar to how `concatmap` and `flatmap` can both be dangerous if used wrong an `eagerconcatmap` that eagerly subscribes and caches the inner `observable`s could be useful of course this can be done without adding anything to rxjava its just tedious bad idea? does it already have a name that im unaware of?;""i cant help you with the name and it is non-trivial to change merge() to support it (#2928): fast-path would require unbounded buffers for the later sources the scalar queue wouldnt really work if interleaved with regular sources and potentially one would need to wrap each value into an indexed container anyway in theory after getting rid of the optimizations the [plain merges]( round-robin collector can be modified to stick to the first buffer until it is terminated before moving onto the next(in my plans for the semi-auto-parallelization i thought about the join option to be either ordered or unordered merge) || > non-trivial to change merge() to support it merge does not need to be changed i can implement this today by composition for example i iterate over an array of observables cache()subscribe() them then concat those together  || one use case for a eager concat was a bug that i ran into a while ago with using concat and publish with a closure`sourcepublish((pub) -> observableeagerconcat(pubmap() pubmap()))` || this would also be useful where the `onsubscribe` makes an async call we will need a way to order the responses in the order that the producer generated them from a request this would of course require buffering  || i like the idea out of interest i think `concat(observable<t))` is a little bit eager internally at the moment inasmuch as it requests the next observable before the first has completed it doesnt subscribe to it before the current observable has completed though which is more what you are referring to || i was misunderstanding concat operator as it subscribes each observables eagerly( this figure concat is very very looks eager :p || >  it doesnt subscribe to it before the current observable has completed though which is more what you are referring tothats the point a `request` does not represent subscription work it just means downstream is capable of receiving lets not confuse those points an `iterable` should be used if even `request` cant be handled  || > in this figure concat is very very looks eager :pyes that diagram looks wrong it shows both as subscribing immediately which it definitely does not do/cc @davidmgross  || ah i thought id  that ill go back and make sure the right diagramsget copied over  i cant fix the rxmarbles version though thats out ofmy bailiwick (@andrestaltz)on wed jul 1 2015 at 9:24 am ben christensen notifications@githubcomwrote:> in this figure concat is very very looks eager :p> > yes that diagram looks wrong it shows both as subscribing immediately> which it definitely does not do> > /cc @davidmgross  > > reply to this email directly or view it on github>  david m grossplp consulting || oh i see what happened that particular illustration ( is meantto illustrate what happens when both of the observables passed to concatare """"hot"""" observables in such a case as i understood it an onerrornotification from the second observable may """"jump the queue"""" and interruptthe emissions from the resulting observable even if the first observablesemissions havent finished yet is that not correct?the other illustrations on the page (eg under the rxjava and rxgroovyaccordion-folds) show the more ordinary behavior with cold observables andwithout onerror notifications and these show the subscription to thesecond observable being delayed until the first observable completeson wed jul 1 2015 at 2:42 pm plp consulting (david gross) <davgross@netflixcom> wrote:> ah i thought id fixed that ill go back and make sure the right> diagrams get copied over  i cant fix the rxmarbles version though> thats out of my bailiwick (@andrestaltz)> > on wed jul 1 2015 at 9:24 am ben christensen notifications@githubcom> wrote:> > > in this figure concat is very very looks eager :p> > > > yes that diagram looks wrong it shows both as subscribing immediately> > which it definitely does not do> > > > /cc @davidmgross  > > > > > reply to this email directly or view it on github> >  > ## > > david m gross> plp consulting## david m grossplp consulting || it is very useful to implement observable for data-store backed valueimplementing with concat or startwith will miss update notification from backed store before first fetch request is finished (ie before subscribing to second observable)refer:  know behaviorsubject is enough to implement observable for just a variable :) || oops there is pitfall when implementing get-and-observe with eager concatmapif `observablejust(observableforget observableforobserve)eagerconcatmap(o -> o)` will subscribe observableforget then observableforobserve it will miss updates between subscription of first and second observable1 eagerconcatmap calls observableforgetsubscribe()2 observableforget calls onnext() from another thread3 someone updates backed store from yet another thread4 observableforobserve should call onnext() but it is not subscribed yet!5 eagerconcatmap calls observableforobservesubscribe()it is easier to use merge for this purpose like below:``` javaobservablemerge(observableforobserve observableforget)```this will subscribe observableforobserve at first so no update will be missed || such operator with backpressure has limited use because even if it subscribes to all sources at once they can produce up to `rxringbuffersize` values upfront until each of them gets drained to completion@ypresto if `observableforobserve` is hot `merge` may not see all of its values either || @akarnokd ~~thanks reproduced with snippet like below:~~```observableinterval(100 timeunitmilliseconds)    flatmap(l -> observableforget)    mergewith(observableforget)```~~it calls onnext() only once not per 100msec~~and i found it may deliver outdated data if observableforobserve called onnext() after observableforget stored fetch result in local varthen how do i implement get-and-observe with rxjava?i use shared stream of cache()d observable in another project:``` javaprivate observable<list<item>> msharedrequestqueueobservable  updatenotificationobservable                onbackpressurelatest()                map(avoid -> getobservablecache()) // cache to share result with all subscribers                share()public observable<list<item>> getandobserve() {        return observablemerge(msharedrequestqueueobservable getobservablenest())                flatmap(observable -> observable) // not using any schedulers to execute synchronously                subscribeon(schedulersio())}```(let me know if mailing list is better place to discuss :) || sorry i was using wrong snippet of `observableinterval()` with publish() (not share()) after interval() callit just works well with hot observable (share())```observableinterval(100 timeunitmilliseconds)share()    flatmap(l -> observableforget)    mergewith(observableforget)``` || it looks like this thread may have gone off the rails it seems like there is interest in having an eager concat operator i think i have implemented one in the internal processing of #3203 its a composition of `bufferuntilsubscriber` subjects and `observableconcat()`  || i think the following example does exactly this:``` javaobservable<long> source1  observableintervalrange(0 20 100 100 timeunitmilliseconds)observable<long> source2  observableintervalrange(20 20 100 100 timeunitmilliseconds)observable<long> source3  observableintervalrange(40 20 100 100 timeunitmilliseconds)observable<observable<long>> sources  observablejust(source1 source2 source3)sourcesmap(v -> {    connectableobservable<long> c  vreplay()    csubscribe() // to cache all    cconnect() // starting now    return c})onbackpressurebuffer() // make sure all source startedconcatmap(v -> v)toblocking()foreach(systemout::println)```edit: the following alternative doesnt retain everything:``` javaobservable<long> source1  observableintervalrange(0 20 100 100 timeunitmilliseconds)observable<long> source2  observableintervalrange(20 20 100 100 timeunitmilliseconds)observable<long> source3  observableintervalrange(40 20 100 100 timeunitmilliseconds)observable<observable<long>> sources  observablejust(source1 source2 source3)sourcesmap(v -> {    unicastsubject<long> subject  unicastsubjectcreate()    vsubscribe(subject)    return subject})onbackpressurebuffer() // make sure all source startedconcatmap(v -> v)toblocking()foreach(systemout::println)``` || see #3357 || the new operator has been delivered with 1015 || "";1;0;eager concatmap;"
3358;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: single class more operators + test from 1.x;i ve added the methods from the 1.x single plus a couple more based on observable operators that makes sense to me in respect to single. no plus unit tests and no javadoc.;;0;2x: single class more operators + test from 1x;ive added the methods from the 1x single plus a couple more based on observable operators that makes sense to me in respect to single no plus unit tests and no javadoc;;;;;1;1;2x: single class + operators and test from 1x + extra operators;
3369;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;lint fixes for unnecessary unboxing;believe i m removing some unnecessary unboxing calls  but please correct me if i m wrong.;;0;lint fixes for unnecessary unboxing;believe im removing some unnecessary unboxing calls but please correct me if im wrong;see the comment otherwise  +1 for @akarnokd comment otherwise  @akarnokd @stevegury used ternaries in-place of `longcompareto` for java 6 support   ;;;;1;1;use ternary for comparison in place of longcompareto for java 6 support;
3371;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: non-backpressure nbpobservable all relevant operators + tests.;- non-backpressured subjects.;;0;2x: non-backpressure nbpobservable all relevant operators + tests;- non-backpressured subjects;thanks will merge and review as part of the branch over time  || i have also code for `single` in #3358 ive rebased it and  up nbpobservable with the proper method name (`onerror` instead of `onfailure`) ||;;;;1;1;2x: non-backpressure nbpobservable all relevant operators + tests;
3376;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: perf comparing observable  nbpobservable  stream and parallelstream;this benchmark compares the overhead of backpressured range  non-backpressured range  streamed range and parallel-streamed range. run on i7 4770k  windows 7 x64  java 1.8u60.  (https://cloud.ent.com/assets/1269832/10107747/75d7c094-63bd-11e5-9e6d-fd3afd50b552.png);;0;2x: perf comparing observable nbpobservable stream and parallelstream;this benchmark compares the overhead of backpressured range non-backpressured range streamed range and parallel-streamed range run on i7 4770k windows 7 x64 java 18u60(https://cloudentcom/assets/1269832/10107747/75d7c094-63bd-11e5-9e6d-fd3afd50b552png);;;;;1;1;2x: perf comparing observable nbpobservable stream and parallelstream;
"3382;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix spsclinkedarrayqueue leaves 1 slot null just before growing;discovered while debugging #3381. confirmed with jctools in https://github.com/jctools/jctools/pull/80;;3381.0;2x: fix spsclinkedarrayqueue leaves 1 slot null just before growing;discovered while debugging #3381 confirmed with jctools in https://githubcom/jctools/jctools/pull/80;;2x: unicastsubject fix for the child becoming visible before onsubscribe is called;""discovered while the test `nbpoperatorconcattesttestissue2890nostackoverflow` hung on traviswhat happened is that the reference to the child became visible before the call to its `onsubscribe` method so a concurrent source emitting at the exact same time could already see the """"unstarted"""" child the pr fixes this in both `nbpunicastsubject` and `unicastsubject` by changing the order of calls the rest of the subjects behave correctly (call `onsubscribe` first make child visible second)in addition `unicastsubject` now calls `drain()` because when the `onsubscribe` calls `request` and `drain` the child is not visible and nothing gets replayed once both `onsubscribe` call returns and the child is becomes visible a call to `drain` again will now correctly replay all available contents that were requested"";closing will be included in the complete backport pr ||;1;0;2x: fix spsclinkedarrayqueue leaves 1 slot null just before growing;"
3383;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix typo in a comment inside observable.subscribe;sigificent -> significant alreay -> already;;0;fix typo in a comment inside observablesubscribe;sigificent -> significantalreay -> already;;;;;1;1;fix typo in a comment inside observablesubscribesigificent -> significantalreay -> already;
"3386;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.1.0 - changed javadoc for observable.doonrequest(action1);this is one of the many 1.1.0 promotion related pull requests. there is a split decision on the operator  observable.doonrequest(action1) . a majority of core committers have voted to promote this operator from  @beta  to public. there is currently a minority is support for removing the convenience method on  observable  or demoting it to  @experimental . instead users would lift the underlying operator  obs.lift(new operatordoonrequest<t>(onrequest)) . in this pull request i have taken the more conservative approach and expect that comments will guide our decisions.  ### rationale: - the  doonrequest  use case is to debug back-pressure use cases and as such should not pollute the public operator namespace.  - the existence of this operator may mislead and confuse users. it could be misinterpreted and abused to alter or reset over arching state when the back-pressure mechanics should be more or less self contained (with the exception of  asynconsubscribe ).  if my understanding is incorrect and there is a valid use case aside from debugging then please comment.;;0;110 - changed javadoc for observabledoonrequest(action1);this is one of the many 110 promotion related pull requests there is a split decision on the operator `observabledoonrequest(action1)` a majority of core committers have voted to promote this operator from `@beta` to public there is currently a minority is support for removing the convenience method on `observable` or demoting it to `@experimental` instead users would lift the underlying operator `obslift(new operatordoonrequest<t>(onrequest))` in this pull request i have taken the more conservative approach and expect that comments will guide our decisions ### rationale:- the `doonrequest` use case is to debug back-pressure use cases and as such should not pollute the public operator namespace - the existence of this operator may mislead and confuse users it could be misinterpreted and abused to alter or reset over arching state when the back-pressure mechanics should be more or less self contained (with the exception of `asynconsubscribe`)if my understanding is incorrect and there is a valid use case aside from debugging then please comment;""id like to see this method part of the public api not because of adebugging requirement but rather for unit testing i think thats enoughon wed 30 sep 2015 03:37 aaron tull notifications@githubcom wrote:> this is one of the many 110 promotion related pull requests there is a> split decision on the operator observabledoonrequest(action1) a> majority of core committers have voted to promote this operator from @beta> to public there is currently a minority is support for removing the> convenience method on observable or demoting it to @experimental instead> users would lift the underlying operator obslift(new> operatordoonrequest<t>(onrequest)) in this pull request i have taken the> more conservative approach and expect that comments will guide our> decisions> rationale:> - the doonrequest use case is to debug back-pressure use cases and as>   such should not pollute the public operator namespace> - the existence of this operator may mislead and confuse users it>   could be misinterpreted and abused to alter or reset over arching state>   when the back-pressure mechanics should be more or less self contained>   (with the exception of asynconsubscribe)> > if my understanding is incorrect and there is a valid use case aside from> > ## debugging then please comment> > you can view comment on or merge this pull request online at:> >    commit summary> - changed observabledoonrequest(action1) to @experimental from @beta> > file changes> - _m_ src/main/java/rx/observablejava>    (2)> > patch links:> -  -  > > reply to this email directly or view it on github>  || can we put something like """"operator was created for testing/debugging rxjava itself using it in the production code is not very great idea"""" in the javadoc of this operator? || @davidmoten could this be solved by lifting in the operator? i dont think that we should polute theobservable instance methods for a convenience operator thats intended to be used by unit tests  || this is a useful operator to diagnose operator request behavior and should be part of the public api in my opinion similar to how `testscheduler` and `testsubscriber` isnt useful in production but very useful when testing code pointing the customers to the internal `operatordoonrequest` class for manual lifting isnt a good alternative because of forcing the customers to rely on internal behavior  || id recommend against having public api exposing an `operator` but would use a `transformer` instead i see moving this out of the `observable` class as an unnecessary inconvenience i havent come across anyone doing weird stuff using `doonrequest` have you @stealthcode? can we address this with clearer documentation on the operator?  || > pointing the customers to the internal operatordoonrequest class for manual lifting isnt a good alternative because of forcing the customers to rely on internal behaviorthe point is that `request(n)` should remain an internal only affair and if you need to know about requests that youll probably also need to know how to lift in operators || @davidmoten i dont see how `olift(new operatordoonrequest(systemout::println))` is different than `ocompose(new transformerdoonrequest(systemout::println))` || this operator is a great tool for diagnosing errors in custom operators which we support through lift and operator classes || @abersnaze yeah i should have elaborated either could be usedin general i was thinking of utility from #2865 which doesnt exist in rxjava but could  i can contribute until this utility exists i wouldnt suggest anyone outside of rxjava builds a public api exposing custom operators because they will have trouble migrating safely if they decide to chuck their custom operator and switch to composing existing operators (i had this issue with rxjava-jdbc) this advice really doesnt apply for core rxjava because as soon as the need exists someone with the right skills would create it with oversight so yeah ignore that comment of mine its irrelevant to this discussion! || @akarnokd we agree that its useful and we are not proposing to remove the `operatordoonrequest` but its existence as an instance method on `observable` is questionable it is very useful for rxjava developers but confusing for application developers do you agree with this? || i personally never heard anybody getting confused  doonrequest` so i cant agree or disagree with your statement || so what is your objection? || my objection is that by demoting this to experimental we are essentially scheduling it for deletion despite all of its usefulness || it is not less useful as an operator that can be lifted its only use case is for developers who know how to lift operators  || id like to understand the source of any confusion with this method could you invite someone who is/was confused into this discussion? || > it is not less useful as an operator that can be lifted its only use case is for developers who know how to lift operatorsthats all very well but we lose discoverability for anyone discovering the api no matter how advanced their abilities and intent i think its a bad idea to have this only as an operator to be lifted that only we know about and some corner bit of documentation describes || i prefer keeping it and like using it i use it for debugging but also triggering side-effects onrequest rather than onsubscribe  || thanks @benjchristensen thats the first non-test/debug use case mentioned thus far we currently have 2 for and 2 against (core committer votes)  || i dont have a strong opinion here i think both points of view are valid`doonrequest` can be confusing for a new user and it can be interpreted as `doonnext` by beginners and in general the more methods you add to a class the harder it is to understand iton the other hand having the possibility to hook easily (by just auto-completing `obsdoonrequest(`) a function in the request-n path is pretty handyso the question here is: do we want to make the library marginally more grokkable at the expense of the power-users?maybe the right thing to do would be to leave it as `@beta`? || what do you think of adding the following to the javadocs of the `observabledoonrequest(action1)` something to the effect of```this operator is for tracing the internal operator back-pressure request patterns and generally intended for debugging ```this would give users some clarity and scare off all but the intrepid and curious  || im okay with adding that kind of javadoc  || javadoc additions sound fine to me too || @stealthcode that would be a good compromise || to be clear i am proposing that the only change to this operator (in 110) is only a javadoc change and we keep the annotation as is at `@beta`  || looks like we have a consensus merging this one and closing #3405 || "";;;;1;1;added warning to `observabledoonrequest` javadoc;"
3408;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;dooneach: report both original exception and callback exception.;this came up in a [stackoverflow]( answer. if the  doonerror  s callback or the  dooneach  s  onerror  method throws  any non-fatal exception replaced the original error which got lost. this pr will wrap them both into a  compositeexception .  2.x note: since java 8 supports  addsuppressed  all callbacks in this situation either attach to the original exception or the original exception is attached to the callback s exception.;;0;dooneach: report both original exception and callback exception;this came up in a [stackoverflow]( answer if the `doonerror`s callback or the `dooneach`s `onerror` method throws any non-fatal exception replaced the original error which got lost this pr will wrap them both into a `compositeexception`2x note: since java 8 supports `addsuppressed` all callbacks in this situation either attach to the original exception or the original exception is attached to the callbacks exception; is there a way to avoid this wrapping?i want to throw a specific exception in my `doonerror` which then gets handled in a certain way || no but you can unwrap via onerrorresumenext:``` javasourcedoonerror(e -> { throw new runtimeexception() })onerrorresumenext(e -> {    if (e instanceof compositeexception) {       return observableerror(((compositeexception)e)getexceptions()get(1))    }    return observableerror(e)})``` || @akarnokd -- ah ;;;;1;1;dooneach: report both original exception and callback exceptionthis came up in a[stackoverflow]( if the doonerrors callback or the dooneachs onerror methodthrows any non-fatal exception replaced the original error which gotlost this pr will wrap them both into a compositeexception2x note: since java 8 supports `addsuppressed` all callbacks in thissituation either attach to the original exception or the originalexception is attached to the callbacks exception;
3415;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;deprecate the experimental/beta method that will be deleted until 1.1.x;squashed commits: [c6e43fc] 1.0.15. beta/deprecation of subject state peeking methods.  this should give users one release to prepare for the class structure changes.;;0;deprecate the experimental/beta method that will be deleted until 11x;squashed commits:[c6e43fc] 1015 beta/deprecation of subject state peeking methodsthis should give users one release to prepare for the class structurechanges; to replace #3407 ||;;;;1;1;pull back the experimental/beta of the changes until 11x (+1 squashed commit)squashed commits:[c6e43fc] 1015 beta/deprecation of subject state peeking methodsthis should give users one release to prepare for the class structurechanges;
3417;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;add single.doonsuccess();closes #3385.;;3385.0;add singledoonsuccess();closes #3385; @artem-zinnatullin rebase please || @abersnaze rebased! ||;rxsingle - why no `doonnext()`?;i have a `single<?>` that i would like to call `doonnext()` on why is this omitted? i get why `dooncompleted()` does not exist but i want to call a void action once and there seems to be no simple way to do this with `rxsingle`technically i could call `map()` do my thing and return the same object - but that seems like too much overhead or call `toobservable()doonnext()tosingle()` but i cannot imagine that is too efficient;hi the class received too little attention after it has been added to the library the 1x operators are kind of hanging off the `observable` so currently you cant do better than `map()`if you are interested you can port back operators from the 2x version ( || so i guess `doonsuccess()` is the equivalent in `single` for `doonnext()` of `observable`? || the `doonx` matches the parent reactive types terminology thus `single` has `onsuccess` -> `doonsuccess` same for v2 `maybeonsuccess` ||;1;0;add singledoonsuccess();
3418;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;add single.fromcallable();second part of #3154.  @akarnokd i d like to reuse  observable.fromcallable()  but didn t find apropriate way to do it:  observable.fromcallable().tosingle()  is not best option  if you have some thoughts on this  please share them.;;0;add singlefromcallable();second part of #3154@akarnokd id like to reuse `observablefromcallable()` but didnt find apropriate way to do it: `observablefromcallable()tosingle()` is not best option if you have some thoughts on this  please share them;:+1: im not too keen on reusing but the most complicated operators for `single` || @artem-zinnatullin rebase please || @abersnaze rebased ill rebase one pr at a time since theyre all conflict with each other ||;;;;1;1;add singlefromcallable();
3419;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;add single.doonerror();;;0;add singledoonerror();; ;;;;1;1;add singledoonerror();
3423;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;renaming observable#x to observable#extend;;;0;renaming observable#x to observable#extend;; correct me if im wrong but the merge policy requires two non-author likes right? || i thought it was two committers and if the auth was a committer that opening the pr was an implicit vote  ill post some by laws so we can all agree on what the rules are || that was my understanding as well i thought it was the releases that required more votes  || oh i see checking my prs again ||;;;;1;1;renaming observable#x to observable#extend;
3433;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;add single.defer();;;0;add singledefer();;please add unit test for callback returning null cases || @akarnokd added `defershouldpassnullpointerexceptiontothesubscriberifsinglefactoryisnull` and `defershouldpassnullpointerexceptiontothesubscriberifsinglefactoryreturnsnull`btw ive used `callable` instead of `func0` to save users from dealing with checked exception hope its okay :) || func0 extends callable so its okay :+1: rebase please || im still :+1: but please rebase || rebased! || thanks!  ;;;;1;1;add singledefer();
3434;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;add single.finallydo();@akarnokd i ve found a problem with  null  action  i ll create separate issue about this soon.;;0;add singlefinallydo();@akarnokd ive found a problem with `null` action ill create separate issue about this soon;could you verify what happens ig the callback throws?one should check null in assembly time (ie when calling singlefinallydo || @akarnokd unfortunately very bad thing happens  not only this exception will be swallowed but also `finallyaction` executed twice im investigating this and will create issue soon ||  um i just noticed that we `doonterminate` and `finallydo` on `observable`![the number of methods is too damn high]( we make this look like `doon*()`? || `doonterminate` happens before subscriber notification `finallydo` happens after || rebased || it can be called `doonaftercomplete()` but since `finallydo` is established im not sure this rename can happen for 10x || id rather it were called doaftercomplete finallydo only exists for the observable and it doesnt follow the do\* convention we could choose to have 2 conventions (naming singles variant similarly) or deprecate observable#finallydo and create observable#doaftercomplete i vote for the latter naming them both doaftercomplete || i think it would have to be doaftertermination since it runs on bothcomplete and erroron sat oct 17 2015 2:45 pm aaron tull notifications@githubcom wrote:> id rather it were called doaftercomplete finallydo only exists for the> observable and it doesnt follow the do\* convention we could choose to have> 2 conventions (naming singles variant similarly) or deprecate> observable#finallydo and create observable#doaftercomplete i vote for the> latter naming them both doaftercomplete> > > reply to this email directly or view it on github>  || does anyone have any objection to creating `observabledoaftertermination` as an alias for `finallydo` and deprecating the original `finallydo`? if thats acceptable then this pr should name it `singledoaftertermination`  || :+1: `doaftertermination` || a bit of consistency in tenses would be nice thoughwe have ```dooncompleteddoonterminatedoonsubscribedoonrequest````dooncompleted` is the odd one out but may as well live with that to be consistent call the method in question `doafterterminate` or `doafterterminated`? || i think `doafterterminate` sounds best to me its consistent with theoncomplete of 2xon sat dec 5 2015 01:53 dave moten notifications@githubcom wrote:> a bit of consistency in tenses would be nice though> > we have> > dooncompleted> doonterminate> doonsubscribe> doonrequest> > > dooncompleted is the odd one out but may as well live with that to be> consistent call the method in question doafterterminate or> doafterterminated?> > > reply to this email directly or view it on github>  || renamed to `doafterterminate` & rebased ptal || > does anyone have any objection to creating observabledoaftertermination as an alias for finallydo and deprecating the original finallydo? @artem-zinnatullin would you like to deprecate `finallydo` -> `doafterterminate` in this pr? || id prepare a separate pr after this if you dont mindon mon dec 7 2015 23:13 aaron tull notifications@githubcom wrote:> does anyone have any objection to creating observabledoaftertermination> as an alias for finallydo and deprecating the original finallydo?> > @artem-zinnatullin  would you like> to deprecate finallydo -> doafterterminate in this pr?> > > reply to this email directly or view it on github>  > ## @artem_zin || rebase please so we can merge  || rebased! ||   ;;;;1;1;add singledoafterterminate();
3438;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;better null tolerance in rx.exceptions.*exception classes.;there seems to be a tendency to send  null  values through  onerror  which eventually causes repeated failures. this pr converts these  null  values into  nullpointerexception s so the error origin is can be discovered and prevents the xxxexceptions from throwing npes in their constructors as well.  i ve also added some missing javadoc.;;0;better null tolerance in rxexceptions*exception classes;there seems to be a tendency to send `null` values through `onerror` which eventually causes repeated failures this pr converts these `null` values into `nullpointerexception`s so the error origin is can be discovered and prevents the xxxexceptions from throwing npes in their constructors as wellive also added some missing javadoc; code is :+1: but not sure i like null tolerance for exceptions `subscriberonerror(null)` is like `throw null` || the problem is that npes will crash the streams further and likely end up hanging somewhere || yeah i understand okay i guess ||;;;;1;1;better null tolerance in rxexceptions*exception classes;
3444;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: completable class to support valueless event composition + tests;this is a backport of #3439.;;3439.0;1x: completable class to support valueless event composition + tests;this is a backport of #3439;looks good should we annotate `@experimental` on all the public methods and operators?  || now the class annotation should indicate all methods are experimental if individual methods get promoted we can add direct annotations then || sounds good :+1:on sat dec 5 2015 01:38 david karnok notifications@githubcom wrote:> now the class annotation should indicate all methods are experimental if> individual methods get promoted we can add direct annotations then> > > reply to this email directly or view it on github>  || since this adds to the api surface id like to get another like before merging ||  awesome ;2x: completable class for valueless event composition;i saw this mentioned in [this talk]( from @benjchristensen this pr adds a new class `completable` which allows composing eventsthat never want to fire `onnext` but only `onerror` or `oncomplete` itis built upon the same reactive-streams principles as `single``nbpobservable` and `observable`ive added most methods that made sense and left out the others (such as`map` and `flatmap`) that would require at least a single valuedepending on whether this type is actually required ill add unit test to this pr or in a new pr in case this gets merged;im adding unit tests and some fixes stay tuned || added 240 unit tests and  a few bugs || ive added `amb` `startwith` and `endwith` methods + their unit tests the latter two have convenience overload that help with continuation-style flows (run the `completable` before or after the `observable`/`nbpobservable` delivered its values) || what is the difference between `completable` vs `single<void>`? its possible to add some utility methods to single to terminate using null values so end up almost with the same interface than completable maybe is better to improve single as something similar to a deferred/promise which will handle the 1/0 items situations (been 0 a null item) which is probably the origin of both interfaces even completable might be just a `completable extends future<void>` so end up with `observable<t>` (async multiple items) and `future<void>` (async single item) as main types (as puts here for some time   )hope this helps just ignore me if you think that this is non sense i see that @akarnokd are doing amazing things this days (specially rxjava v2) im not try to say that this pull request is bad or something similar || the difference is that among other things you dont have to drag around a mute type parameter null values are forbidden with 2x and reactive-streams anyway `future` void is not an option because `completable` is a deferred cold computation which runs only if one subscribes to it whereas future is hot and is expected to be running or already completed such as `asyncsubject` || consider making `completable` implement both `publisher` and `iobservable` (an interface for `observable` similar to `publisher` for `flowable`) so that `completable` can be composed directly with either a `flowable` or `observable` without special method overloads  || ive started out with `completable implements publisher<object>` but it didnt work with `subscriber<t>` because `t` is not a supertype of `object` and java doesnt have a bottom type in its type system (its top type is `object` however `void` is not a bottom type so that `void` extends every other type) the same would be true for `iobservable` so whats left is a bunch of `subscribe()` method with call-site variance || well that really sucks that `void` doesnt work properly how about as `publisher<?>`? || you cant have wildcards as the type parameter of the super type || :( oh well  || is there any chance we will get this with rxjava 1x? || the pr for 1x has already been merged and should appear in 111 || see #3444 || closing will be included in the complete backport pr ||;1;0;1x: completable class for valueless event composition + tests;
3447;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: delaysubscription with a plain other observable.;requested in #3445.  this is an efficient implementation as it avoids allocating the lifter object  doesn t require a function wrapper and doesn t use producer arbitration.  (bonus points to those who can recognize the similarities with #3446).;;3445.0;1x: delaysubscription with a plain other observable;requested in #3445this is an efficient implementation as it avoids allocating the lifter object doesnt require a function wrapper and doesnt use producer arbitration(bonus points to those who can recognize the similarities with #3446);any thoughts about this? ||  ;add delaysubscription(observable<u>) overload?;usage of `delaysubscription` has started popping up in our code base and ive noticed that we always have to define a `func0` simply to yield an observable thats either cold (in which case the function provides no value) or hot (in which case the function also provides no value) its not clear to me why the function indirection was added in the first place as its provided no data and `observabledefer` could have served in its placei would like to propose adding an `observable`-taking overload and replacing the `func0` variant to instead wrap its given argument in `observabledefer` before passing to `onsubscribedelaysubscriptionwithselector`being able to sneak this in before 1015 / 110 would also be nice  ;see #3447 i didnt touch the current `func0` variant to avoid introducing unexpected effects to existing code || :+1: thanks @akarnokd!  || fix ;1;0;1x: operator delaysubscription with plain observable;
"3447;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: delaysubscription with a plain other observable.;requested in #3445.  this is an efficient implementation as it avoids allocating the lifter object  doesn t require a function wrapper and doesn t use producer arbitration.  (bonus points to those who can recognize the similarities with #3446).;;3446.0;1x: delaysubscription with a plain other observable;requested in #3445this is an efficient implementation as it avoids allocating the lifter object doesnt require a function wrapper and doesnt use producer arbitration(bonus points to those who can recognize the similarities with #3446);any thoughts about this? ||  ;how can i use operatorconcat<t>?;""im trying to write an operator `then<rt>` which ignores all emissions from the source (except errors) and continues with a second observable when completedsomething like:```// typical caseobservablejust(1 2 3 4 5)   lift(new then<string integer>(observablejust(""""hello"""")))   subscribe(new action1<string>() {      @override      public void call(string s) {         // called once with """"hello""""      })// source errorsobservable<integer>error(new runtimeexception())   lift(new then<string integer>(observablejust(""""hello"""")))  // <-- the second observable should never be subscribed to since the source errord   subscribe(new action1<string>() {      @override      public void call(string s) {         // not called      } new action1<throwable>() {      @override      public void call(throwable e) {        systemoutprintln(""""error: """"+e) // should be called with the runtimeexception from above      }   })```ive come up with an implementation using `ignoreelements` + `map` + `concatwith`:```    public static <r t> observable<? extends r> then(observable<t> source observable<r> other) {        return source                ignoreelements()                map(new func1<t r>() {                    @override                    public r call(t integer) {                        return null                    }                })concatwith(other)    }```im quite new to writing custom operators and i cant quite figure out how to translate that static function into an operator ive written a few operators by composing the provided operator\* types but im having trouble with this oneany help would be greatly appreciated :)"";""this is discussed in #3113 and implemented awaiting merge in #3443 || ok well that eliminates the need for my operator but im still interested in how it could be correctly implemented using lift() im sure ill be writing more operators in the future so id like to have a better understanding of how they work this is what ive come up with:```/** * ignores all emissions from the source observable once the source completes the provided * observable will be subscribed to if the source errors the error will terminate the stream and * the provided observable will not be subscribed to * * @param <t> the type of objects emitted by the source observable * @param <r> the type of objects emitted by the provided `next` observable */public class then<r t> implements observableoperator<r t> {    private final operatorignoreelements<t> mignoreelements    private final operatormap<t r> mmap    private final operatorconcat<r> mconcat    private final observable<r> mnextobservable    public then(observable<r> nextobservable) {        assert( nextobservable ! null )        mnextobservable  nextobservable        mignoreelements  operatorignoreelementsinstance()        mmap  new operatormap<>(new func1<t r>() {            @override            public r call(t t) {                return null            }        })        mconcat  operatorconcatinstance()    }    @override    public subscriber<? super t> call(final subscriber<? super r> subscriber) {        // todo: compose operators    }}``` || this is """"super easy"""" to implement as an `operator`:``` javapublic final class then<t r> implements operator<r t> {    final observable<r> other    public then(observable<r> other) {        thisother  other    }    @override    public subscriber<? super t> call(final subscriber<? super r> t) {        multipleassignmentsubscription mas  new multipleassignmentsubscription()        tadd(mas)        subscriber<t> parent  new subscriber<t>() {            @override            public void onnext(t t) {                // ignored            }            @override            public void onerror(throwable e) {                tonerror(e)            }            @override            public void oncompleted() {                subscriber<r> tr  subscriberswrap(t)                masset(tr)                othersubscribe(tr)            }        }        masset(parent)        return parent    }}``` || awesome thanks! i have a few questions about your solution:1 shouldnt it check if the subscriber has unsubscribed before calling `tonerror(e)`?2 why is the multipleassignmentsubscription needed? im a bit of an rx newbie so its not clear to me why you cant just return the `parent` subscriber directlycheers! || 1) unnecessary2) so the unsubscription from the child can target both the first parent and the second subscriber || "";1;0;1x: operator delaysubscription with plain observable;"
3448;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;single delay;adds the  delay(long delay  timeunit unit  scheduler scheduler)  and  delay(long delay  timeunit unit) operators to  rx.single .  includes (in a separate commit) a refactor of  operatordelay . as far as i can tell  the  source  field isn t used at all - by removing it  i was able to reuse  operatordelay  in  rx.single  to implement the delay operator pretty easily.;;0;single delay;adds the `delay(long delay timeunit unit schedulerscheduler)` and delay(long delay timeunit unit)`operators to`rxsingle`includes (in a separate commit) a refactor of `operatordelay` as far as i can tell the `source` field isnt used at all - by removing it i was able to reuse `operatordelay` in `rxsingle` to implement the delay operator pretty easily; ;;;;1;1;adds delay operator to singlethis commit adds the `delay(long delay timeunit unit schedulerscheduler)` and `delay(long delay timeunit unit)` operators to`rxsingle`;
"3455;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;onerrorfailedexception fix;https://github.com/reactivex/rxjava/issues/2998;;0;onerrorfailedexception fix;https://githubcom/reactivex/rxjava/issues/2998;""looks good to me  could you also fix the similar issues in `observablesubscribe` and `observableunsubscribe`? here are tests to reproduce them:```    @test(expected  onerrorfailedexceptionclass)    public void testonerrorexceptionisthrownfromsubscribe() {        observable<integer>create(s1 ->                        observable<integer>create(s2 -> {                            throw new illegalargumentexception(""""original exception"""")                        })subscribe(s1)        )subscribe(systemout::println e -> {            throw new runtimeexception()        })    }    @test(expected  onerrorfailedexceptionclass)    public void testonerrorexceptionisthrownfromunsafesubscribe() {        observable<integer>create(s1 ->                        observable<integer>create(s2 -> {                            throw new illegalargumentexception(""""original exception"""")                        })unsafesubscribe(s1)        )subscribe(systemout::println e -> {            throw new runtimeexception()        })    }``` || i would replace error handling in both of these methods with simple```    } catch (throwable e) {        exceptionsthrowiffatal(e)        try {            subscriberonerror(hookonsubscribeerror(e))        } catch (throwable e2) {            throw new onerrorfailedexception(e2)        }        return subscriptionsunsubscribed()    }```however i think that the problem should be handled more generally the entire error handling policy should be reviewed and enforcedotherwise we will always see swallowed exceptions here and thereunfortunately i dont have time right now to investigate the issue ive just  what creates troubles for my current project || thanks for digging in to help with this i thought we had squashed all of these swallowing of errors! apparently not :-( || :+1: go ahead with this @akarnokd if youre still good with it  || it is good as it is merging the thing @zsxwing asked for can be done in a separate pr || "";;;;1;1;onerrorfailedexception fix;"
3458;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;clarify contracts of compositesubscription in its javadoc;current state of  compositesubscription  s javadoc  totally misleading :smile:   every time we need to store some subscriptions in it then clear them and leave  compositesubscription  in an operable state we have to read its sources because its actual behavior is not consistent with the javadoc.   compositesubscription.clear()  leaves  compositesubscription  in operable state  when on the other hand  compositesubscription.unsubscribe()  sets  isunsubscribed = true  and  compositesubscription  is not able to manage new subscriptions.;;0;clarify contracts of compositesubscription in its javadoc;current state of `compositesubscription`s javadoc  totally misleading   every time we need to store some subscriptions in it then clear them and leave `compositesubscription` in an operable state we have to read its sources because its actual behavior is not consistent with the javadoc`compositesubscriptionclear()` leaves `compositesubscription` in operable state when on the other hand `compositesubscriptionunsubscribe()` sets `isunsubscribed  true` and `compositesubscription` is not able to manage new subscriptions;  excellent! ||;;;;1;1;clarify contracts of compositesubscription in its javadoc;
3462;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: a minor doc fix for  interval;;;0;1x: a minor doc fix for `interval`;; ;;;;1;1;a minor doc fix for `interval`;
"3467;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: compensation for significant clock drifts in scheduleperiodically;there is a problem  reported in #3461 and #2943  in which if the system clock drifts  the periodic calculation inside scheduler.worker gets off and either taking a longer time for the next invocation of the task or doing  catching-up  with all the lost invocations.  the solution checks the wall clock difference between the last run and the current run and if it went back or forward significantly  it rebases the timer period and schedules the next execution relative to now.  if the clock goes back  the original code scheduled the next invocation way into the future. this pr will schedule it after the period.  if the clock goes forward  the original code scheduled executions for all the missed time between the last run and the new time immediately  yielding a bunch of 0 delays. this pr will simply schedule the next invocation after the period.  the algorithm for both cases is the same: make sure the next invocation is scheduled relative to now and recalculate the start timestamp as if the whole sequence run under the new drifted clock all along. the subsequent invocations will be scheduled at a fixed rate again.  i ve added the system parameter  rx.scheduler.drift-tolerance  (unit: minutes  default: 15 minutes)  which is used to determine if the clock drifted too far between invocations of the periodic task.;;2943.0;1x: compensation for significant clock drifts in scheduleperiodically;""there is a problem reported in #3461 and #2943 in which if the system clock drifts the periodic calculation inside schedulerworker gets off and either taking a longer time for the next invocation of the task or doing """"catching-up"""" with all the lost invocationsthe solution checks the wall clock difference between the last run and the current run and if it went back or forward significantly it rebases the timer period and schedules the next execution relative to nowif the clock goes back the original code scheduled the next invocation way into the future this pr will schedule it after the periodif the clock goes forward the original code scheduled executions for all the missed time between the last run and the new time immediately yielding a bunch of 0 delays this pr will simply schedule the next invocation after the periodthe algorithm for both cases is the same: make sure the next invocation is scheduled relative to now and recalculate the start timestamp as if the whole sequence run under the new drifted clock all along the subsequent invocations will be scheduled at a  rate againive added the system parameter `rxschedulerdrift-tolerance` (unit: minutes default: 15 minutes) which is used to determine if the clock drifted too far between invocations of the periodic task"";""time drift is pretty nasty we spent a lot of time on this in rxnet  || ive updated the code with the suggestion of @stealthcode  || :+1:  do you need additional changes? if not feel free to merge this pr ||  yay! this was important issueso i did test (similar to #3530):``` javaobservable  interval(5 10 seconds)  subscribe(along -> loggerd(""""interval: %d"""" along))```and then changed system clock to +2 hours at runtime of the app**before fix**as expected computation scheduler gone crazy and fired about 700 events during one second<img width""""1160"""" alt""""screen shot 2015-12-15 at 08 44 57"""" src"""" width""""944"""" alt""""screen shot 2015-12-15 at 08 43 54"""" src"""" fix**everything was just fine! no incorrect events no cpu consuming<img width""""1165"""" alt""""screen shot 2015-12-15 at 09 01 06"""" src"""" width""""1006"""" alt""""screen shot 2015-12-15 at 09 00 42"""" src"""" i think #3461 and #3530 can be closed now!thanks @akarnokd! || "";schedulerscheduleperiodically is sensitive to system time changes;schedulerscheduleperiodically can potentially get into busy loop if you set your system time into the future due to using systemcurrenttimemillis() to calculate the next delay;confirmed this causes a busy loop and spikes cpu to 100% because of objectpool || i guess it is due to the way the next delay is calculated from a constant absolute time position and a time set back will result in 0 delay between subsequent executions any tips on fixing it? || if we want to measure elapsed time we should use `systemnanotime` which wont be affected by the users system time  || i wouldnt trust [nanotime that much]( because the weaker guarantees of its monotonity and consistency across cores || this is not an easy thing -)  || @headinthebox  especially if you _are_ platform independent to begin with (ie what is the linux equivalent of `service_control_timechange` callback?)what the solution boils down:1 we need a supervising task scheduled on a small 5-10s period to detect systemcurrenttimemillis() drift or change (ie now - last is: > 5s + tolerance / negative)2 we need to capture tasks scheduled on any scheduler that sets a delay/period > 10s and schedule them according to zenos paradox3 if the supervising task detects a drastic clock change it has to catch all those long-delay tasks and re-schedule them based on the new absolute time information of course atomically to prevent double-executionsthese all add some non-trivial overhead to scheduling and task-memory-sizesmy first thought was the same as in the article:> observabletimer/interval implementation would start its quest to catch up with the new time draining the battery due to the flood of callbacks it triggered the fix was more of a band aid whereby the timer would ignore ticks that occurred in the distant past resetting the next state to be based on the current system timebut thats still a half-solution at best || using nanotime was my temporary solution as well it is not the best but the quickest way to fix this bug and doesnt offer anything worst then the current solution || some systems like android give a way to measure time and dont care about system time changes  do you think about abstraction for `systemcurrenttimemillis()` which can be overriddenrxjava plugin]( `systemcurrenttimemillis()` -> no breaking changes to the apiandroid: `systemclockelapsedrealtime()` -> no breaking changes and guarantees++ for freeothers: users can provide custom implementation for example for linux it can be native c call or in general it can be some implementation of synchronized calls to `systemnanotime()` || ive implemented compensation logic in [2x]( but i havent tested it and unsure if the calculation is actually correct || ive proposed a fix for this issue in #3467 i dont know if and when this can get into a release || fix delivered in 110 ||;1;0;1x: compensate for drastic clock drifts when scheduling periodic tasks;"
"3467;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: compensation for significant clock drifts in scheduleperiodically;there is a problem  reported in #3461 and #2943  in which if the system clock drifts  the periodic calculation inside scheduler.worker gets off and either taking a longer time for the next invocation of the task or doing  catching-up  with all the lost invocations.  the solution checks the wall clock difference between the last run and the current run and if it went back or forward significantly  it rebases the timer period and schedules the next execution relative to now.  if the clock goes back  the original code scheduled the next invocation way into the future. this pr will schedule it after the period.  if the clock goes forward  the original code scheduled executions for all the missed time between the last run and the new time immediately  yielding a bunch of 0 delays. this pr will simply schedule the next invocation after the period.  the algorithm for both cases is the same: make sure the next invocation is scheduled relative to now and recalculate the start timestamp as if the whole sequence run under the new drifted clock all along. the subsequent invocations will be scheduled at a fixed rate again.  i ve added the system parameter  rx.scheduler.drift-tolerance  (unit: minutes  default: 15 minutes)  which is used to determine if the clock drifted too far between invocations of the periodic task.;;3461.0;1x: compensation for significant clock drifts in scheduleperiodically;""there is a problem reported in #3461 and #2943 in which if the system clock drifts the periodic calculation inside schedulerworker gets off and either taking a longer time for the next invocation of the task or doing """"catching-up"""" with all the lost invocationsthe solution checks the wall clock difference between the last run and the current run and if it went back or forward significantly it rebases the timer period and schedules the next execution relative to nowif the clock goes back the original code scheduled the next invocation way into the future this pr will schedule it after the periodif the clock goes forward the original code scheduled executions for all the missed time between the last run and the new time immediately yielding a bunch of 0 delays this pr will simply schedule the next invocation after the periodthe algorithm for both cases is the same: make sure the next invocation is scheduled relative to now and recalculate the start timestamp as if the whole sequence run under the new drifted clock all along the subsequent invocations will be scheduled at a  rate againive added the system parameter `rxschedulerdrift-tolerance` (unit: minutes default: 15 minutes) which is used to determine if the clock drifted too far between invocations of the periodic task"";""time drift is pretty nasty we spent a lot of time on this in rxnet  || ive updated the code with the suggestion of @stealthcode  || :+1:  do you need additional changes? if not feel free to merge this pr ||  yay! this was important issueso i did test (similar to #3530):``` javaobservable  interval(5 10 seconds)  subscribe(along -> loggerd(""""interval: %d"""" along))```and then changed system clock to +2 hours at runtime of the app**before fix**as expected computation scheduler gone crazy and fired about 700 events during one second<img width""""1160"""" alt""""screen shot 2015-12-15 at 08 44 57"""" src"""" width""""944"""" alt""""screen shot 2015-12-15 at 08 43 54"""" src"""" fix**everything was just fine! no incorrect events no cpu consuming<img width""""1165"""" alt""""screen shot 2015-12-15 at 09 01 06"""" src"""" width""""1006"""" alt""""screen shot 2015-12-15 at 09 00 42"""" src"""" i think #3461 and #3530 can be closed now!thanks @akarnokd! || "";high cpu usage after time changed on device;on android using this library if the user changes the system time there is a huge spike in the cpu usage emanating from the rxcomputationthreadpool without any expensive calls being made to the rx library;thanks for reporting it has been already reported in #2943 || thanks for your swift replydo we have a feel of when we might have a fix for this on v1x? || // one of the possible fixes  abstraction for clock #3295 || i also experienced this issue and its quite serious will this be  soon?  || ive proposed a fix for this issue in #3467 i dont know if and when this can get into a release ||;1;0;1x: compensate for drastic clock drifts when scheduling periodic tasks;"
3468;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: fix other places that may swallow onerrorfailedexception;reviewed all usages of  onerrornotimplementedexception  and fixed issues similar to #3455.;;0;1x: fix other places that may swallow onerrorfailedexception;reviewed all usages of `onerrornotimplementedexception` and  issues similar to #3455; ;;;;1;1;fix other places that may swallow onerrorfailedexception;
"3470;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: replay request coordination reduce overhead;reported in #3469.  this change will make sure whenever a new subscriber arrives  the request coordination doesn t scan every other subscriber unnecessary. (they will trigger a managerequests individually anyway).  unfortunately  i can t make the subscription registration constant (via a hashset) because that would slow down the dispatching loop (which is quite expensive to for-each over compared to a plain array).  note also that this will likely conflict with #3454.  i get the following numbers with the program in #3469.      subscribing subscribed so far 10000  took 54ms to subscribe last 10000 at rate: 185185 per sec... subscribed so far 20000  took 110ms to subscribe last 10000 at rate: 90909 per sec... subscribed so far 30000  took 157ms to subscribe last 10000 at rate: 63694 per sec... subscribed so far 40000  took 267ms to subscribe last 10000 at rate: 37453 per sec... subscribed so far 50000  took 211ms to subscribe last 10000 at rate: 47393 per sec... subscribed so far 60000  took 320ms to subscribe last 10000 at rate: 31250 per sec... subscribed so far 70000  took 331ms to subscribe last 10000 at rate: 30211 per sec... subscribed so far 80000  took 369ms to subscribe last 10000 at rate: 27100 per sec... subscribed so far 90000  took 415ms to subscribe last 10000 at rate: 24096 per sec... subscribed so far 100000  took 462ms to subscribe last 10000 at rate: 21645 per sec... subscribed so far 110000  took 516ms to subscribe last 10000 at rate: 19379 per sec... subscribed so far 120000  took 547ms to subscribe last 10000 at rate: 18281 per sec... subscribed so far 130000  took 647ms to subscribe last 10000 at rate: 15455 per sec... subscribed so far 140000  took 720ms to subscribe last 10000 at rate: 13888 per sec... subscribed so far 150000  took 811ms to subscribe last 10000 at rate: 12330 per sec... subscribed so far 160000  took 806ms to subscribe last 10000 at rate: 12406 per sec... subscribed so far 170000  took 873ms to subscribe last 10000 at rate: 11454 per sec... subscribed so far 180000  took 911ms to subscribe last 10000 at rate: 10976 per sec... subscribed so far 190000  took 986ms to subscribe last 10000 at rate: 10141 per sec... subscribed so far 200000  took 1003ms to subscribe last 10000 at rate: 9970 per sec... subscribed so far 210000  took 1168ms to subscribe last 10000 at rate: 8561 per sec... subscribed so far 220000  took 1213ms to subscribe last 10000 at rate: 8244 per sec... subscribed so far 230000  took 1340ms to subscribe last 10000 at rate: 7462 per sec... subscribed so far 240000  took 1314ms to subscribe last 10000 at rate: 7610 per sec... subscribed so far 250000  took 1548ms to subscribe last 10000 at rate: 6459 per sec... subscribed so far 260000  took 1372ms to subscribe last 10000 at rate: 7288 per sec... subscribed so far 270000  took 1835ms to subscribe last 10000 at rate: 5449 per sec... subscribed so far 280000  took 2087ms to subscribe last 10000 at rate: 4791 per sec... subscribed so far 290000  took 1910ms to subscribe last 10000 at rate: 5235 per sec... subscribed so far 300000  took 1966ms to subscribe last 10000 at rate: 5086 per sec... unsubscribing... unsubscribed so far 10000  took 1910ms to unsubscribe last 10000 at rate: 5235 per sec... unsubscribed so far 20000  took 1782ms to unsubscribe last 10000 at rate: 5611 per sec... unsubscribed so far 30000  took 1730ms to unsubscribe last 10000 at rate: 5780 per sec... unsubscribed so far 40000  took 1593ms to unsubscribe last 10000 at rate: 6277 per sec... unsubscribed so far 50000  took 1514ms to unsubscribe last 10000 at rate: 6605 per sec... unsubscribed so far 60000  took 1468ms to unsubscribe last 10000 at rate: 6811 per sec... unsubscribed so far 70000  took 1188ms to unsubscribe last 10000 at rate: 8417 per sec... unsubscribed so far 80000  took 1234ms to unsubscribe last 10000 at rate: 8103 per sec... unsubscribed so far 90000  took 1271ms to unsubscribe last 10000 at rate: 7867 per sec... unsubscribed so far 100000  took 1358ms to unsubscribe last 10000 at rate: 7363 per sec... unsubscribed so far 110000  took 1103ms to unsubscribe last 10000 at rate: 9066 per sec... unsubscribed so far 120000  took 1100ms to unsubscribe last 10000 at rate: 9090 per sec... unsubscribed so far 130000  took 990ms to unsubscribe last 10000 at rate: 10101 per sec... unsubscribed so far 140000  took 953ms to unsubscribe last 10000 at rate: 10493 per sec... unsubscribed so far 150000  took 854ms to unsubscribe last 10000 at rate: 11709 per sec... unsubscribed so far 160000  took 789ms to unsubscribe last 10000 at rate: 12674 per sec... unsubscribed so far 170000  took 779ms to unsubscribe last 10000 at rate: 12836 per sec... unsubscribed so far 180000  took 624ms to unsubscribe last 10000 at rate: 16025 per sec... unsubscribed so far 190000  took 634ms to unsubscribe last 10000 at rate: 15772 per sec... unsubscribed so far 200000  took 514ms to unsubscribe last 10000 at rate: 19455 per sec... unsubscribed so far 210000  took 411ms to unsubscribe last 10000 at rate: 24330 per sec... unsubscribed so far 220000  took 373ms to unsubscribe last 10000 at rate: 26809 per sec... unsubscribed so far 230000  took 337ms to unsubscribe last 10000 at rate: 29673 per sec... unsubscribed so far 240000  took 286ms to unsubscribe last 10000 at rate: 34965 per sec... unsubscribed so far 250000  took 234ms to unsubscribe last 10000 at rate: 42735 per sec... unsubscribed so far 260000  took 222ms to unsubscribe last 10000 at rate: 45045 per sec... unsubscribed so far 270000  took 159ms to unsubscribe last 10000 at rate: 62893 per sec... unsubscribed so far 280000  took 96ms to unsubscribe last 10000 at rate: 104166 per sec... unsubscribed so far 290000  took 63ms to unsubscribe last 10000 at rate: 158730 per sec... unsubscribed so far 300000  took 31ms to unsubscribe last 10000 at rate: 322580 per sec...;;3469.0;1x: replay request coordination reduce overhead;reported in #3469this change will make sure whenever a new subscriber arrives therequest coordination doesnt scan every other subscriber unnecessary(they will trigger a managerequests individually anyway)unfortunately i cant make the subscription registration constant (via a hashset) because that would slow down the dispatching loop (which is quite expensive to for-each over compared to a plain array)note also that this will likely conflict with #3454i get the following numbers with the program in #3469```subscribingsubscribed so far 10000 took 54ms to subscribe last 10000 at rate: 185185 per secsubscribed so far 20000 took 110ms to subscribe last 10000 at rate: 90909 per secsubscribed so far 30000 took 157ms to subscribe last 10000 at rate: 63694 per secsubscribed so far 40000 took 267ms to subscribe last 10000 at rate: 37453 per secsubscribed so far 50000 took 211ms to subscribe last 10000 at rate: 47393 per secsubscribed so far 60000 took 320ms to subscribe last 10000 at rate: 31250 per secsubscribed so far 70000 took 331ms to subscribe last 10000 at rate: 30211 per secsubscribed so far 80000 took 369ms to subscribe last 10000 at rate: 27100 per secsubscribed so far 90000 took 415ms to subscribe last 10000 at rate: 24096 per secsubscribed so far 100000 took 462ms to subscribe last 10000 at rate: 21645 per secsubscribed so far 110000 took 516ms to subscribe last 10000 at rate: 19379 per secsubscribed so far 120000 took 547ms to subscribe last 10000 at rate: 18281 per secsubscribed so far 130000 took 647ms to subscribe last 10000 at rate: 15455 per secsubscribed so far 140000 took 720ms to subscribe last 10000 at rate: 13888 per secsubscribed so far 150000 took 811ms to subscribe last 10000 at rate: 12330 per secsubscribed so far 160000 took 806ms to subscribe last 10000 at rate: 12406 per secsubscribed so far 170000 took 873ms to subscribe last 10000 at rate: 11454 per secsubscribed so far 180000 took 911ms to subscribe last 10000 at rate: 10976 per secsubscribed so far 190000 took 986ms to subscribe last 10000 at rate: 10141 per secsubscribed so far 200000 took 1003ms to subscribe last 10000 at rate: 9970 per secsubscribed so far 210000 took 1168ms to subscribe last 10000 at rate: 8561 per secsubscribed so far 220000 took 1213ms to subscribe last 10000 at rate: 8244 per secsubscribed so far 230000 took 1340ms to subscribe last 10000 at rate: 7462 per secsubscribed so far 240000 took 1314ms to subscribe last 10000 at rate: 7610 per secsubscribed so far 250000 took 1548ms to subscribe last 10000 at rate: 6459 per secsubscribed so far 260000 took 1372ms to subscribe last 10000 at rate: 7288 per secsubscribed so far 270000 took 1835ms to subscribe last 10000 at rate: 5449 per secsubscribed so far 280000 took 2087ms to subscribe last 10000 at rate: 4791 per secsubscribed so far 290000 took 1910ms to subscribe last 10000 at rate: 5235 per secsubscribed so far 300000 took 1966ms to subscribe last 10000 at rate: 5086 per secunsubscribingunsubscribed so far 10000 took 1910ms to unsubscribe last 10000 at rate: 5235 per secunsubscribed so far 20000 took 1782ms to unsubscribe last 10000 at rate: 5611 per secunsubscribed so far 30000 took 1730ms to unsubscribe last 10000 at rate: 5780 per secunsubscribed so far 40000 took 1593ms to unsubscribe last 10000 at rate: 6277 per secunsubscribed so far 50000 took 1514ms to unsubscribe last 10000 at rate: 6605 per secunsubscribed so far 60000 took 1468ms to unsubscribe last 10000 at rate: 6811 per secunsubscribed so far 70000 took 1188ms to unsubscribe last 10000 at rate: 8417 per secunsubscribed so far 80000 took 1234ms to unsubscribe last 10000 at rate: 8103 per secunsubscribed so far 90000 took 1271ms to unsubscribe last 10000 at rate: 7867 per secunsubscribed so far 100000 took 1358ms to unsubscribe last 10000 at rate: 7363 per secunsubscribed so far 110000 took 1103ms to unsubscribe last 10000 at rate: 9066 per secunsubscribed so far 120000 took 1100ms to unsubscribe last 10000 at rate: 9090 per secunsubscribed so far 130000 took 990ms to unsubscribe last 10000 at rate: 10101 per secunsubscribed so far 140000 took 953ms to unsubscribe last 10000 at rate: 10493 per secunsubscribed so far 150000 took 854ms to unsubscribe last 10000 at rate: 11709 per secunsubscribed so far 160000 took 789ms to unsubscribe last 10000 at rate: 12674 per secunsubscribed so far 170000 took 779ms to unsubscribe last 10000 at rate: 12836 per secunsubscribed so far 180000 took 624ms to unsubscribe last 10000 at rate: 16025 per secunsubscribed so far 190000 took 634ms to unsubscribe last 10000 at rate: 15772 per secunsubscribed so far 200000 took 514ms to unsubscribe last 10000 at rate: 19455 per secunsubscribed so far 210000 took 411ms to unsubscribe last 10000 at rate: 24330 per secunsubscribed so far 220000 took 373ms to unsubscribe last 10000 at rate: 26809 per secunsubscribed so far 230000 took 337ms to unsubscribe last 10000 at rate: 29673 per secunsubscribed so far 240000 took 286ms to unsubscribe last 10000 at rate: 34965 per secunsubscribed so far 250000 took 234ms to unsubscribe last 10000 at rate: 42735 per secunsubscribed so far 260000 took 222ms to unsubscribe last 10000 at rate: 45045 per secunsubscribed so far 270000 took 159ms to unsubscribe last 10000 at rate: 62893 per secunsubscribed so far 280000 took 96ms to unsubscribe last 10000 at rate: 104166 per secunsubscribed so far 290000 took 63ms to unsubscribe last 10000 at rate: 158730 per secunsubscribed so far 300000 took 31ms to unsubscribe last 10000 at rate: 322580 per sec```;ive updated the code to have o(1) subscription/unsubscription cost as well the program from #3469 now produces stunning results:```subscribingsubscribed so far 10000 took 32ms to subscribe last 10000 at rate: 312500 per secsubscribed so far 20000 took 12ms to subscribe last 10000 at rate: 833333 per secsubscribed so far 30000 took 14ms to subscribe last 10000 at rate: 714285 per secsubscribed so far 40000 took 6ms to subscribe last 10000 at rate: 1666666 per secsubscribed so far 50000 took 12ms to subscribe last 10000 at rate: 833333 per secsubscribed so far 60000 took 4ms to subscribe last 10000 at rate: 2500000 per secsubscribed so far 70000 took 5ms to subscribe last 10000 at rate: 2000000 per secsubscribed so far 80000 took 5ms to subscribe last 10000 at rate: 2000000 per secsubscribed so far 90000 took 4ms to subscribe last 10000 at rate: 2500000 per secsubscribed so far 100000 took 13ms to subscribe last 10000 at rate: 769230 per secsubscribed so far 110000 took 4ms to subscribe last 10000 at rate: 2500000 per secsubscribed so far 120000 took 5ms to subscribe last 10000 at rate: 2000000 per secsubscribed so far 130000 took 5ms to subscribe last 10000 at rate: 2000000 per secsubscribed so far 140000 took 4ms to subscribe last 10000 at rate: 2500000 per secsubscribed so far 150000 took 5ms to subscribe last 10000 at rate: 2000000 per secsubscribed so far 160000 took 6ms to subscribe last 10000 at rate: 1666666 per secsubscribed so far 170000 took 41ms to subscribe last 10000 at rate: 243902 per secsubscribed so far 180000 took 5ms to subscribe last 10000 at rate: 2000000 per secsubscribed so far 190000 took 5ms to subscribe last 10000 at rate: 2000000 per secsubscribed so far 200000 took 19ms to subscribe last 10000 at rate: 526315 per secsubscribed so far 210000 took 4ms to subscribe last 10000 at rate: 2500000 per secsubscribed so far 220000 took 3ms to subscribe last 10000 at rate: 3333333 per secsubscribed so far 230000 took 4ms to subscribe last 10000 at rate: 2500000 per secsubscribed so far 240000 took 4ms to subscribe last 10000 at rate: 2500000 per secsubscribed so far 250000 took 4ms to subscribe last 10000 at rate: 2500000 per secsubscribed so far 260000 took 4ms to subscribe last 10000 at rate: 2500000 per secsubscribed so far 270000 took 4ms to subscribe last 10000 at rate: 2500000 per secsubscribed so far 280000 took 4ms to subscribe last 10000 at rate: 2500000 per secsubscribed so far 290000 took 4ms to subscribe last 10000 at rate: 2500000 per secsubscribed so far 300000 took 4ms to subscribe last 10000 at rate: 2500000 per secunsubscribingunsubscribed so far 10000 took 13ms to unsubscribe last 10000 at rate: 769230 per secunsubscribed so far 20000 took 8ms to unsubscribe last 10000 at rate: 1250000 per secunsubscribed so far 30000 took 7ms to unsubscribe last 10000 at rate: 1428571 per secunsubscribed so far 40000 took 5ms to unsubscribe last 10000 at rate: 2000000 per secunsubscribed so far 50000 took 5ms to unsubscribe last 10000 at rate: 2000000 per secunsubscribed so far 60000 took 5ms to unsubscribe last 10000 at rate: 2000000 per secunsubscribed so far 70000 took 3ms to unsubscribe last 10000 at rate: 3333333 per secunsubscribed so far 80000 took 3ms to unsubscribe last 10000 at rate: 3333333 per secunsubscribed so far 90000 took 3ms to unsubscribe last 10000 at rate: 3333333 per secunsubscribed so far 100000 took 3ms to unsubscribe last 10000 at rate: 3333333 per secunsubscribed so far 110000 took 3ms to unsubscribe last 10000 at rate: 3333333 per secunsubscribed so far 120000 took 3ms to unsubscribe last 10000 at rate: 3333333 per secunsubscribed so far 130000 took 3ms to unsubscribe last 10000 at rate: 3333333 per secunsubscribed so far 140000 took 2ms to unsubscribe last 10000 at rate: 5000000 per secunsubscribed so far 150000 took 3ms to unsubscribe last 10000 at rate: 3333333 per secunsubscribed so far 160000 took 2ms to unsubscribe last 10000 at rate: 5000000 per secunsubscribed so far 170000 took 3ms to unsubscribe last 10000 at rate: 3333333 per secunsubscribed so far 180000 took 2ms to unsubscribe last 10000 at rate: 5000000 per secunsubscribed so far 190000 took 3ms to unsubscribe last 10000 at rate: 3333333 per secunsubscribed so far 200000 took 2ms to unsubscribe last 10000 at rate: 5000000 per secunsubscribed so far 210000 took 2ms to unsubscribe last 10000 at rate: 5000000 per secunsubscribed so far 220000 took 2ms to unsubscribe last 10000 at rate: 5000000 per secunsubscribed so far 230000 took 2ms to unsubscribe last 10000 at rate: 5000000 per secunsubscribed so far 240000 took 2ms to unsubscribe last 10000 at rate: 5000000 per secunsubscribed so far 250000 took 2ms to unsubscribe last 10000 at rate: 5000000 per secunsubscribed so far 260000 took 2ms to unsubscribe last 10000 at rate: 5000000 per secunsubscribed so far 270000 took 2ms to unsubscribe last 10000 at rate: 5000000 per secunsubscribed so far 280000 took 2ms to unsubscribe last 10000 at rate: 5000000 per secunsubscribed so far 290000 took 2ms to unsubscribe last 10000 at rate: 5000000 per secunsubscribed so far 300000 took 3ms to unsubscribe last 10000 at rate: 3333333 per sec```(the numbers could be actually higher but windows timer resolution is about 3ms at best) || ive updated the code to avoid the synchronized block on each replay attempt in case the cached version of the innerproducers is still the same as the sets version || i havent reviewed the changes in detail yet but i do notice that openhashset doesnt have any dedicated unit tests || ive added a unit test for `openhashset` || strangely the test doesnt crash with java 8 must be some difference between what type for-each extracts || @akarnokd needs rebase on latest `1x` || thanks working on it || rebased || i like this a lot and the results are really impressive code looks good to me cleaner than the previous implementation too  i finally find some time to review this one sorry for the delay;replay/refcount subscribe/unsubscribe exhibit o(n) behavior;""subscribing to replay/refcount chain slows down as o(n) with number of existing subscribers this is reproducible on a simple chain that never emits an item thus data traffic should not be a factor in the performance degradation behavior:``` javaobservable<?> shared  observablenever()replay(1)refcount()```after certain number of subscribers sharing observable becomes unusable and wasting a lot of cpu cycles in turn this draws useless some caching scenarios specifically with big number of subscribershere is the simple test:``` java    final observable<?> shared  observablenever()replay(1)refcount()    final int count  300000    final int page  10000    list<subscription> ss  new arraylist<>()    systemoutprintln(""""subscribing"""")    long prev  systemcurrenttimemillis()    for (int i  0 i < count i++) {      ssadd(sharedsubscribe())      if ((i+1) % page  0) {        long now  systemcurrenttimemillis()        systemoutprintln(""""subscribed so far """" + (i+1) + """" took """" + (now-prev) + """"ms to subscribe last """" + page +             """" at rate: """" + page*1000/(now-prev) + """" per sec"""")        prev  now      }    }    systemoutprintln(""""unsubscribing"""")    prev  systemcurrenttimemillis()    for (int i  0 i < count i++) {      ssget(i)unsubscribe()      if ((i+1) % page  0) {        long now  systemcurrenttimemillis()        systemoutprintln(""""unsubscribed so far """" + (i+1) + """" took """" + (now-prev) + """"ms to unsubscribe last """" + page +             """" at rate: """" + page*1000/(now-prev) + """" per sec"""")        prev  now      }    }```here is the output on a 2015 macbook pro (physmem: 16g jvm launched with -xmx8000m):```subscribingsubscribed so far 10000 took 374ms to subscribe last 10000 at rate: 26737 per secsubscribed so far 20000 took 905ms to subscribe last 10000 at rate: 11049 per secsubscribed so far 30000 took 1646ms to subscribe last 10000 at rate: 6075 per secsubscribed so far 40000 took 2557ms to subscribe last 10000 at rate: 3910 per secsubscribed so far 290000 took 29635ms to subscribe last 10000 at rate: 337 per secsubscribed so far 300000 took 30998ms to subscribe last 10000 at rate: 322 per secunsubscribingunsubscribed so far 10000 took 32352ms to unsubscribe last 10000 at rate: 309 per secunsubscribed so far 20000 took 28413ms to unsubscribe last 10000 at rate: 351 per secunsubscribed so far 30000 took 27722ms to unsubscribe last 10000 at rate: 360 per secunsubscribed so far 260000 took 2979ms to unsubscribe last 10000 at rate: 3356 per secunsubscribed so far 270000 took 2012ms to unsubscribe last 10000 at rate: 4970 per secunsubscribed so far 280000 took 1335ms to unsubscribe last 10000 at rate: 7490 per secunsubscribed so far 290000 took 649ms to unsubscribe last 10000 at rate: 15408 per secunsubscribed so far 300000 took 198ms to unsubscribe last 10000 at rate: 50505 per sec```the main suspect is managerequest() in operatorreplay: where stack traces are pointing to during both subscribe() and unsubscribe() when the rate slows down"";hi and thanks for the feedback ive posted the pr #3470 improving on the performance (up to ~20x improvement) || 20x improvement is great but making it constant or near would be also nice :) at this time we do not have any resources to look at it but if no one else is able to pick this up we might try to investigate and possibly contribute for now we will have to put a concept of caching observables via replay() aside that was pretty elegant way of doing async cache though || ive updated #3470 to have o(1) subscription cost and dont lose too much on the dispatching side by using the internals of an `openhashset` let me know if its fast enough for you || sweet!!! hope this is merged into 1x || closing via #3470 should be available in 116 ||;1;0;1x: replay request coordination reduce overhead;"
3474;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix indentation;;;0;fix indentation;; :+1:// id also add `{}` to the `if`s   ||  great thanks for contributing ||;;;;1;1;add brackets to the ifs;
3477;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: add a source onsubscribe which works from an array directly;this specialized onsubscribe performs ~33% better on longer streams.  benchmark comparison (i7 4770k  windows 7 x64  java 8u66):  (  the  slowpath  requests the available amount + 1 to trigger a slow path   slowpath2  requests in batches of 128 and replenishes only after all were received.;;0;1x: add a source onsubscribe which works from an array directly;this specialized onsubscribe performs ~33% better on longer streamsbenchmark comparison (i7 4770k windows 7 x64 java 8u66):( `slowpath` requests the available amount + 1 to trigger a slow path `slowpath2` requests in batches of 128 and replenishes only after all were received;;;;;1;1;1x: add a source onsubscribe which works from an array directly;
3486;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: remove unused imports;;;0;1x: remove unused imports;;   lets merge this? || thanks for the contribution ||;;;;1;1;remove unused imports;
3487;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: onbackpressurebuffer: drop_latest and drop_oldest;introduce a new interface backpressureoverflowstrategy that allows implementing different handlers for an overflow situation.  this patch adds three implementations  reachable via overflowstrategy:      static class overflowstrategy {     static final backpressureoverflowstrategy default = error.instance      static final error error = error.instance      static final dropoldest drop_oldest = dropoldest.instance      static final droplatest drop_latest = droplatest.instance  }      the behavior for each is the following: - error remains the default as the existing implementation. - drop_latest will drop newly produced items after the buffer fills up. - drop_oldest will drop the oldest elements in the buffer  making room for   newer ones.  in all cases  a drop will result in a notification to the producer by invoking the onoverflow callback.  none of the two new behaviours (drop_*) will unsubscribe from the source nor onerror.;;0;1x: onbackpressurebuffer: drop_latest and drop_oldest;introduce a new interface backpressureoverflowstrategy that allows implementing different handlers for an overflow situation  this patch adds three implementations reachable via overflowstrategy:```static class overflowstrategy {    static final backpressureoverflowstrategy default  errorinstance    static final error error  errorinstance    static final dropoldest drop_oldest  dropoldestinstance    static final droplatest drop_latest  droplatestinstance}```the behavior for each is the following:- error remains the default as the existing implementation- drop_latest will drop newly produced items after the buffer fills up- drop_oldest will drop the oldest elements in the buffer making room for  newer onesin all cases a drop will result in a notification to the producer by invoking the onoverflow callbacknone of the two new behaviours (drop_*) will unsubscribe from the source nor onerror;otherwise it looks okay  thanks for the review @akarnokd || rebased - @akarnokd let me know if there are any fixes pending || excellent :+1: i dont think there are conflicting prs right now || great :+1: just a few nits || thanks @artem-zinnatullin & @akarnokd addressed artems comments ||  @abersnaze can you take a look and verify that it solves the issue raised in #3233? || rebased on 1x || the only concern that @abersnaze and i have had with this is that this uses enums to determine the strategy of operator functionality this pattern hasnt been used much in the public api as of yet @akarnokd @zsxwing do you guys have any opinion? we could just convert the strategies to instance methods (for consistency) or is this an emerging case that should be encouraged? || i wouldnt turn a the whole set of `onbackpressurexxx` into enums of drop|buffer|latest because the pattern doesnt allow parametrizing just the buffer variant in this case however having 3-9 new overload feels unnecessary expansion of the public api im in for the use of enums here but we should store them in a reasonable subpackage || @akarnokd @stealthcode i dont love using enums in this way but i agree with @akarnokd that this can lead to excessive api expansion  but happy to move to methods if you guys prefer  ditto for moving the enums package from rx to rxstrategies or some similar alternative || agree with @akarnokd i prefer to add a new interface `backpressureoverflowstrategy` instead of `enum` || i agree with @zsxwing on the use of an empty interface and impls to compare `instanceof` instead of using an enum eventually they might be usable to generalize the strategies  || sounds good ill update the patch soon any suggestion on the package for the strategy? || rebased || @stealthcode ive been busy these days just returned to this i had the same doubt re buffersubscribe reference @akarnokd mind to clarify where it happens?ive  the visibility of overflowstrategy members (new commit on the way) || thanks for the additioncould you also update the pr description? || @stevegury thanks for the review pr fixed || if im right the only missing thing is the header in `backpressureoverflowstrategyjava`@srvaroa could you add that? wait it has still the problem of exposing internal classes and types into the public api:``` javaboolean triggeron(rxinternalutilbackpressuredrainmanagerbackpressurequeuecallback buffer) throws missingbackpressureexception```in addition for a proper instance of backpressureoverflowstrategy you have to reach into ``` javarxinternaloperatorsoperatoronbackpressurebufferon_overflow_default```for example || thanks @akarnokd @stevegury im submitting a patch that eliminates the internal api leak while doing it im starting to realize that without exposing the buffer or callback the motivation for a strategy vs a plain enum practically dissapears  the point of using a strategy was to give users ability to implement their own strategies this led me to expose the internal buffer (which is bad obviously) however without it were basically doing the same as an enum as the real overflow behaviour is not really in the strategy  it actually feels redundant with the onoverflow callbackto make the strategy worth the extra code wed need to make buffersubscriber implement some public api interface defined by backpressureoverflow through which we allow the user to actually interact with the buffer without leaking the internal api something like:```bpbuffer {  boolean dropoldest()  }```and then:```bpstrategy {  boolean triggeron(bpbuffer buffer)  }```this would become similar to my current patch ( and enable meaningful strategies without leaking apis that said i think that would be overengineering this patchoptions i see:a) revert to enums (problem: were introducing an enum-based public api)b) leave the patch im submitting next (problem: were committing to a public api based on a strategy that doesnt really define any behaviour)c) define bpbuffer and bpstrategy for the sake of introducing a meaningful strategy-based api i ca call triggeron() with a null for now (so it effectively behaves as -b-) and proceed with making buffersubscriber extend bpbuffer in a later patchim leaning for (a) but let me know what you prefer || the current api looks good enough to me only some small visibility and annotation issues || thanks for the reviews i updated the patch ||  thanks @srvaroa for taking the time of writing a good pr! :+1: ;;;;1;1;onbackpressurebuffer: drop_latest and drop_oldestintroduce a new interface backpressureoverflowstrategy that allowsimplementing different handlers for an overflow situation  this patchadds three implementations:- on_overflow_error remains the default as the existing implementation- on_overflow_drop_latest will drop newly produced items after the buffer fills  up- on_overflow_drop_oldest will drop the oldest elements in the buffer making  room for newer onesthe default strategy remains on_overflow_errorin all cases a drop will result in a notification to the producer by invokingthe onoverflow callbacknone of the two new behaviours (on_overflow_drop_*) will unsubscribe from thesource nor onerrorfixes: #3233;
"3488;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x remove all instances of atomic*fieldupdater;replace them all with their respective atomic\* counterparts for example atomiclongfieldupdater -> atomiclong addresses https://github.com/reactivex/rxjava/issues/3459;;0;1x remove all instances of atomic*fieldupdater;replace them all with their respective atomic\* counterpartsfor example atomiclongfieldupdater -> atomiclongaddresses https://githubcom/reactivex/rxjava/issues/3459;""there is a reason for `atomicfieldupdater` + `volatile` value  lower memory consumption (cc @akarnokd) but personally id like to switch to `atomic` fields too to get rid of reflection in such hot code#3459 is samsungs problem even though we see it in our apps (somebody told me that its about 5% of samsung devices of our users) i dont think that such platform specific bugs should be solved on library side || as @artem-zinnatullin mentioned field updaters were introduced to reduce number of allocations and runtime size of the library especially for the android platformalthough field updaters have 1-5% overhead compared to unsafe the same overhead may manifest with atomic instances due to the one level indirection plus usually the surrounding logic forces a re-read of the atomicxxx field all the time if not done with caresee my other comments in the code || ive finished my review || thanks for the quick review || @akarnokd i think i addressed all your feedback || generally looks okay now could you squash your commits into a single commit? || sure thing squashed ||  the changes look okay could you do a comparison benchmark of operatorobserveonperf mainly (and post the comparison image madejmh-compare-gui]( ) ? || i started a run on this branch now using `/gradlew benchmarks -pjmh*operatorobserveonperf*` the eta for that is in over 2 hours does that seem right? || i ran jmh yesterday for this commit and the preceding one the results are on my computer at home and im at work now ill post them when i get back || here is the screenshot the first result is from 51527b7d17652a493e2c73f8724ebc62253a7e4b the second one is from after the changes in this pull request:( im not sure if i used the gui right i cant get it to use something as a baseline i pasted the result from 51527b7d17652a493e2c73f8724ebc62253a7e4b first and then the result from this pull request do i need to do something else? || right click in a cell and you get a popup menu with options || otherwise no performance regression   :+1: few nits looks like @akarnokd wants local copies of `final` references but i dont though im ok with having them  you can just fix `@suppresswarnings(""""unused"""")` @akarnokd can you please give a link or describe how local copy of `final` reference will help? i mean jit will ~100% wont make re-reads of `final` references until it detect change of the reference via reflection or im wrong? || keep the locals as i suggested jit re-reads them unfortunately i read and experienced this myself with jctools queries and range() || thats sad okay then just suppresswarnings need to be netflix team: can we expect 1016 soon? as mentioned in the original issuethis pr would prevent crashes in many appson wed nov 11 2015 11:24 david karnok notifications@githubcom wrote:> keep the locals as i suggested jit re-reads them unfortunately i read> and experienced this myself with jctools queries and range()> > > reply to this email directly or view it on github>  > ## @artem_zin || @artem-zinnatullin i removed the erroneous annotations || :+1:  please squash this again || done || thanks for contributing || "";;;;1;1;1x remove all instances of atomic*fieldupdaterreplace them all with their respective atomic* counterpartsfor example atomiclongfieldupdater -> atomiclongaddresses https://githubcom/reactivex/rxjava/issues/3459;"
"3498;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: rename cache(int) to cachewithinitialcapacity(int);~~the parameter is a capacity hint  but more frequently confused with a buffer size like replay(int) than it is correctly understood. it also offers no guarantees  only the weak hope of optimization.~~  the parameter is a capacity hint  but more frequently confused with a buffer size like replay(int) than it is correctly understood. it also offers no guarantees  only the weak hope of optimization.  this change renames the method  deprecating the old name. it also adds javadoc calling out that the parameter is not a bound and referencing replay(int).autoconnect() as a way to achieve that behavior.;;0;1x: rename cache(int) to cachewithinitialcapacity(int);~~the parameter is a capacity hint but more frequently confused with abuffer size like replay(int) than it is correctly understood it alsooffers no guarantees only the weak hope of optimization~~the parameter is a capacity hint but more frequently confused with a buffer size like replay(int) than it is correctly understood it also offers no guarantees only the weak hope of optimizationthis change renames the method deprecating the old name it also adds javadoc calling out that the parameter is not a bound and referencing replay(int)autoconnect() as a way to achieve that behavior;""hi it is part of the public api and cant be just removed in addition why did you modify the underlying internal class? || how about `@deprecated`?i modified the internal class because the only use of that constructor parameter was in the removed operator  if youd prefer to deprecate of course ill revert that modification || we are kind of set for 11 in terms of api visibility how about updating the javadoc and list alternatives? || ive pointed developers directly at that javadoc and theyve still misunderstood the parameter  and thats best case!  any developer who just looks at the signature which is most of them misunderstands the parameter everyone assumes its a bound on the buffer size and its so obvious that why would you read the javadoc?itd be great to get this resolved in the 1x series || huge +1 to `@deprecated` + simlink like `cachewithinitialbuffersize`/etc `cache(int)` is very very misleading (every member of our team had problems with understanding that `int` is not a size of the caches buffer) || updated with rename deprecation and javadoc ||  you can post a pr against 2x where you can simply rename and no need for deprecation || @stealthcode @abersnaze whats the situation among netflix devs regarding this? || ping netflix team || from what i can tell this is a change to an existing public facing method name and thats a no-no for 1x @abersnaze is committing a change to the contributorsmd that explains what changes are allowed in patch release minor releases and major releases method signatures of non-beta and non-experimental methods are only accepted in major version releases you could mark both as deprecated and add a new method `cachewithcapacityhint(int)` || well thats what @loganj did in his pr :) no breaking changes deprecationand new methodon thu nov 19 2015 00:27 aaron tull notifications@githubcom wrote:> from what i can tell this is a change to an existing public facing method> name and thats a no-no for 1x @abersnaze  is committing a change to the contributorsmd that explains what changes> are allowed in patch release minor releases and major releases method> signatures of non-beta and non-experimental methods are only accepted in> major version releases> > you could mark both as deprecated and add a new method> cachewithcapacityhint(int)> > > reply to this email directly or view it on github>  > ## @artem_zin || oh i see i misread the pull request  || i dont see the source of the confusion `javautilarraylist` follows a similar convention in the constructor `public arraylist(int initialcapacity)` and that is sufficient for me to understand its usage the array backed data type can be reallocated but its better to tune it with an appropriate initial value i suggest that we leave it alone in 1x and rename it to `cacheunbounded(int initialcapacity)` in 2x also we should improve the javadocs to indicate the intended usage since there still seems to be confusion around this  || a list is a data structure designed to grow when you see `cache(4)` you do not think of a list but of a  size cache as most will be bounded by some supplied valueadditionally an initial size is not required to create an array list and its a constructor parameter not only do you have to opt-in to using this non-default constructor overload you would have to look at the documentation for any idea what the value is for this is _very_ different in that the size is required and its a named method which should describe behavior but is misleading because of prior assumptions around the word """"cache"""" || @jakewharton the `cache` operator does not use a fixed size cache i think that you are saying that the operator name should be enough to to convey the semantic meaning of an unbounded growing cache i think that by renaming it to `cacheunbounded(int initialcapacity)` that the usage will be made more clear and it would be discoverable by users who know to look for the `cache` operator if the term """"cache"""" is not sufficient to indicate the contract then we should probably consider changing the name to one that does what would be a better term for an operator that holds an ordered list of all events emitted from an observable to be replayed to all subscribers after the first? || @stealthcode hence the name `cachewithinitialcapacity` introduced in this pr  that name implies its unbounded _and_ describes the integer parameter || to clarify: i dont really care what its called in 2x as long as its reasonably unambiguous (ie not `cache(int)`) || @jakewharton i think @stealthcode was agreeing that a new method name would make it clearer but not that `cachewithinitialcapacity` or that it should be done on the 1x branchim not very interested in spending a lot of energy bike shedding over the name so can we just have a vote for we want to do: (vote for as many options as you want in the order or preference)a) do nothingb) deprecate `cache(int)` and make `cachewithinitialcapacity(int)` in 1xc) deprecate `cache(int)` and make `cacheunbounded(int)` in 1xd) remove `cache(int)` and make `cachewithinitialcapacity(int)` in 2xe) remove `cache(int)` and make `cacheunbounded(int)` in 2xmy vote is a e c d b@loganj @stealthcode @akarnokd @jakewharton @artem-zinnatullin  well [tabulate]( the votes on monday || my vote is a e || i vote e a c || i vote b d a || bfor 2x id prefer to get rid of cache or replay and leave only oneoperator with different settings without autoconnection by default:cachewithlimit/replaywithlimit cacheunbounded /replayunbounded etcon sat nov 21 2015 00:26 david karnok notifications@githubcom wrote:> my vote is a e> > > reply to this email directly or view it on github>  > ## @artem_zin || i would like @jakewharton votes but so far the a is the winner || b c d e  presuming a change in 1x means also making the change in 2xwe have empirical evidence that the name and parameter are confusing to users i cant imagine why wed ignore that evidence based on our own lack of confusioni also think its funny that this balloting gives a single """"do nothing"""" equal weight to four """"do something"""" options  by my count """"do something"""" is winning even before my vote || b c myselfi think its just confusing and have been bitten  cache(int)` before || i vote b || e&c then d&b then aon fri nov 20 2015 7:16 pm michael bailey notifications@githubcomwrote:> i vote b> > > reply to this email directly or view it on github>  || i think that e&c equate to to just c (assuming that all api changes made in 1x are carried over)  || b won and im fine with that @loganj could do the honors of changing this pr to match just to be clear that means that `observable` will have the methods `cache()` `@deprecated cache(int)` and `cachewithinitialcapacity(int)` rebased to one commit off of the 1x branch || ping @loganj lets do it! || updated to specified naming apologies for the delay was traveling on vacation ||   "";;;;1;1;rename cache(int) to cachewithcapacityhint(int)the parameter is a capacity hint but more frequently confused with abuffer size like replay(int) than it is correctly understood it alsooffers no guarantees only the weak hope of optimizationthis change renames the method deprecating the old name it also addsjavadoc calling out that the parameter is not a bound and referencingreplay(int)autoconnect() as a way to achieve that behavior;"
"3500;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;some code clean ups.;nothing that could change logic or application flow  just minor refactors to be consistent with good practices and clean code. to sum up changes: - simplified some conditions - changed small l to l in long number  as l tends to look like 1 and might confuse - removed  return  statements where those are not necessary (last instruction in function) - inlined returns where there were no need for creating new variable (easier to read) - deleted unnecessary colons;;0;some code clean ups;""nothing that could change logic or application flow just minor refactors to be consistent with good practices and clean codeto sum up changes:- simplified some conditions- changed small l to l in long number as l tends to look like 1 and might confuse- removed """"return"""" statements where those are not necessary (last instruction in function)- inlined returns where there were no need for creating new variable (easier to read)- deleted unnecessary colons"";could you also squash the commits? || squashed :) ||   ;;;;1;1;some code clean upsnothing that could change logic or application flow just minor refactors to be consistent with good practices and clean code;"
"3512;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: fix safesubscriber documentation regarding unsubscribe;the documentation was wrong in two points: unsubscription doesn t call oncompleted  and unsubscription doesn t directly prevent delivery of  onxxx  events since the implementation doesn t even check isunsubscribed: (it is the responsibility of the upstream to do that).  related issue: #3059.;;3059.0;1x: fix safesubscriber documentation regarding unsubscribe;the documentation was wrong in two points: unsubscription doesnt call`oncompleted` and unsubscription doesnt directly prevent delivery of `onxxx` events since the implementation doesnt even check isunsubscribed: (it is the responsibility of the upstream to do that)related issue: #3059; ;safesubscriber does not call `oncompleted` after `unsubscribe` allows further calls to `onnext`;""[the documentation for `safesubscriber`]( states:> if `unsubscribe` is called calls `oncompleted` and forbids any further `onnext` callshowever in practice it appears that `safesubscriber` does neither of those---the following code should call `oncompleted`:``` javasubscription sub  observableinterval(10 timeunitmilliseconds)  subscribe(    l -> systemoutprintln(""""received: """" + l)    e -> systemoutprintln(""""error: """" + e)    () -> systemoutprintln(""""completed"""")  )sleep(50)subunsubscribe()```however the output is as follows:```received: 0received: 1received: 2received: 3received: 4```---the following code should not call `onnext` after unsubscription:``` javaobservable<long> observable  observablecreate(subscriber -> {  long n  0  while (true) {    sleep(10)    subscriberonnext(n++)  }})subscription sub  observable  subscribeon(schedulersnewthread())  subscribe(    l -> systemoutprintln(""""received: """" + l)    e -> systemoutprintln(""""error: """" + e)    () -> systemoutprintln(""""completed"""")  )sleep(50)subunsubscribe()systemoutprintln(""""unsubscribed!"""")```however this is the output:```received: 0received: 1received: 2received: 3received: 4unsubscribed!received: 5received: 6received: 7received: 8```---it seems to me that one of three things is going on:1 `safesubscriber` isnt as safe as it should be2 the documentation is out-of-date3 im missing something"";> if unsubscribe is called calls oncompleted- `oncompleted` should only be called after all the `onnext` notifications have arrived so the behaviour described in the javadoc does not comply with the observable contract we should remove this > and forbids any further onnext calls- if unsubscription occurs it is preferred that no more notifications be forwarded to the subscriber (though this is not mandated behaviour generally) `safesubscriber` attempts no such guarantees currently as youve noticed though it could do so by adding an unsubscribe action to the underlying subscriber that sets a volatile boolean  when called that boolean could then be checked on each arrival to `safesubscriber` of a notification i assume the addition of a volatile read on every emission could be sufficiently expensive at runtime to make this undesirable im sure @akarnokd will have an opinion on this one for us  || > i assume the addition of a volatile read on every emission could be sufficiently expensive at runtime to make this undesirableand > if unsubscription occurs it is preferred that no more notifications be forwarded to the subscriber seem to slightly contradict in that to accurately stop notifications one has to check `!sisunsubscribed()` before emitting which _is_ that very volatile read anywayi discovered this problem last night when `unsubscribe()` was being called from a thread different than subscribe and emission and in order to stop future emission i had to get back onto the original thread``` javathing thing  //observable<object> o  observablecreate(s -> {  checkuithread()  thinglistener listener  v -> sonnext(v)  sadd(subscriptionscreate(() -> {    postuithread(() -> thingremovelistener(listener))  }))  thingaddlistener(listener)})```when unsubscribe happens we cannot detach the emitter without moving back to the original subscription thread this runs synchronously if you are already on that thread but sometimes it has to be queued and there might be an event already queued for processingwhere i find this extremely problematic is when you have a `doonunsubscribe` action on the stream this action will be fired yet you still might receive an `onnext` || hah yes of course just need to check `isunsubscribed` on the underlying subscriber as you point out! no surprise to you im sure but `doonunsubscribe` will report the unsubscribe request on its way upstream to the source and there could still be inflight emissions another possibility is that sources and operators are not bound to honour unsubscribe by the observable contract its best endeavoursthe catch with all this is that putting the `isunsubscribed` check in `safesubscriber` doesnt help much  if our observable looks like this:``` javaobservabledoonnext(systemout::println)subscribe()```in this case though `unsubscribe` was called and `safesubscriber` prevented the endpoint subscriber getting notifications after unsubscription we might still get more emissions fed to the `doonnext`i suppose there are probably techniques for making your use case more responsive to unsubscription @jakewharton and you are no doubt on top of them is there support youd like to see in the api that would help you? what sort of reliance on `doonunsubscribe` do you have (you said its extremely problematic)? || oops i may have a been a bit too apocalyptic with my words i have used subscribe/unsubscribe callbacks for holding state as a side-effect this almost certainly would trigger an unexpected condition if i tear down/complete the side-effect state and then receive another event and assume i could act on it but youre right it makes total sense that the notifications are happening in two directions herethankfully in practice this has never been a problem in all of these cases unsubscription has happened from the ui thread which allows everything to happen synchronously anyway i only discovered the errant behavior (and its subsequent documentation problem) during a unit test which was operating on two threadsi think all were really after here is a documentation change to remove the guarantees it currently claims to offer as to whether guarantees about `onnext` will be enforced on not ill leave that up to you all to decide based on the performance implications im pretty sure that checking for unsubscription before emitting is a best practice for operators so im perfectly fine if it results only in a documentation change as well || well @dlew found the errant documentation and wrote the nice tests i just assumed it was user error in my operator implementation! || the first example works as expected and the documentation is wrongthe behavior of `safesubscriber` is somewhat questionable but the general expectation is that sources check for `isunsubscribed` before calling `onnext` therefore `safesubscriber` doesnt duplicate such work || posted a pr that changes the javadoc in #3512 ||;1;0;1x: fix safesubscriber documentation regarding unsubscribethe documentation was wrong in two points: unsubscription doesnt calloncompleted and unsubscription doesnt directly prevent delivery ofonxxx events since the implementation doesnt even check isunsubscribed:(it is the responsibility of the upstream to do that);"
3513;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: add shorter rxjavaplugin class lookup approach.;this adds a new pattern and lookup method that let s the developer specify the custom plugins with shorter system property keys. android is quite restrictive and allows only 31 characters.  the new pattern splits the target simple class name and its implementation into two separate system properties:      rxjava.plugin.1.class=simpleclassname rxjava.plugin.1.impl=path.to.impl.class      the index tag ( 1 ) can be any string of your chosing:      rxjava.plugin.mykey.class=simpleclassname rxjava.plugin.mykey.impl=path.to.impl.class      but make sure they are paired  otherwise nothing will happen.  if there are multiple  class  entries with the same  simpleclassname  one of them will be chosen (depending on the walk order in  java.util.properties ).  related issue #2835.;;2835.0;1x: add shorter rxjavaplugin class lookup approach;this adds a new pattern and lookup method that lets the developer specify the custom plugins with shorter system property keys android is quite restrictive and allows only 31 charactersthe new pattern splits the target simple class name and its implementation into two separate system properties:```rxjavaplugin1classsimpleclassnamerxjavaplugin1implpathtoimplclass```the index tag (`1`) can be any string of your chosing:```rxjavapluginmykeyclasssimpleclassnamerxjavapluginmykeyimplpathtoimplclass```but make sure they are paired otherwise nothing will happenif there are multiple `class` entries with the same `simpleclassname` one of them will be chosen (depending on the walk order in `javautilproperties`)related issue #2835; updated: made strings local constants and using `length`instead of magic numbers plus if the default keying matches the properties is not traversed for an alternate specification || an alternative pattern could be this:```rxjavaplugin1simpleclassnameorgpackagenamingactualclass``` || i agree that if the plugin cannot be found we should crash the app  || updated the code to crash if the plugin implementation is missing || ;cannot define plugin properties on android;the property key max length on android devices/emulators is 31 characters thereby preventing the ability to set properties for use by the plug in system  the property key template is 29 characters on its own`rxjavaplugin[class-name-here]implementation`is it likely that a shorter key could be used to enable this feature on android?;im not familiar with the constraints on android how about we give you the following system property that wraps other system properties:```rxjavaprops1keyrxjavaplugin[class-name-here]implementationrxjavaprops1valuecomesomepathsomeclass```ie is it possible the use systemsetproperty(key value) on android with long keys? does the 31 character limit apply to command-line only? || i have to say that is a ridiculous limitationwe cant change existing keys but if someone wants to submit a pr with aliases that set both that could work || ive posted pr #3513 with a shorter scheme proposal || solution merged and delivered in 110 ||;1;0;1x: add shorter rxjavaplugin class lookup approach;
"3524;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix subscribe() javadoc;fix for javadoc issue #3523;;3523.0;fix subscribe() javadoc;fix for javadoc issue #3523;   ;""subscribe() doesnt actually """"ignore its emissions and notifications"""" as documented"";""the zero-arg rxobservable#subscribe() method says that it """"ignore its emissions and notifications"""" but in fact it throws an exception for onerror"";fix in #3524 ;1;0;amend javadocs for observablesubscribe() as per #3523;"
"3539;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;add single.zip() for iterable of singles;;;0;add singlezip() for iterable of singles;;""did you consider adding `zip(single funcn)` overload as well?otherwise looks good  ill add `zin(single funcn)` and `zipwith()` in separate prs if you dont mindbtw idk if @benjchristensen remembers how i was arguing against adding `single` to the rxjava my apologies  im starting loving `single` in our codebase!  || here is an implementation that avoids conversion to `observable`:``` java@suppresswarnings(""""unchecked"""")public static <t r> single<r> zip(        iterable<? extends single<? extends t>> singles                 funcn<? extends r> zipper) {    return singlecreate(f -> {        single<? extends t> sa        int count        if (singles instanceof list) {            list<? extends single<? extends t>> list                      (list<? extends single<? extends t>>)singles            count  listsize()            sa  listtoarray(new single[count])        } else {            sa  new single[8]            count  0            for (single<? extends t> s : singles) {                if (count  salength) {                    single<? extends t> sb  new single[count + (count >> 2)]                    systemarraycopy(sa 0 sb 0 count)                    sa  sb                }                sa[count]  s                count++            }        }        final atomicinteger wip  new atomicinteger(count)        final atomicboolean once  new atomicboolean()        final object values  new object[count]        compositesubscription csub  new compositesubscription()        fadd(csub)        for (int i  0 i < count i++) {            if (csubisunsubscribed() || onceget()) {                break            }            final int j  i            singlesubscriber<t> te  new singlesubscriber<t>() {                @override                public void onsuccess(t value) {                    values[j]  value                    if (wipdecrementandget()  0) {                        r r                        try {                            r  zippercall(values)                        } catch (throwable e) {                            exceptionsthrowiffatal(e)                            fonerror(e)                            return                        }                        fonsuccess(r)                    }                }                @override                public void onerror(throwable error) {                    if (oncecompareandset(false true)) {                        fonerror(error)                    } else {                        rxjavapluginsgetinstance()                        geterrorhandler()handleerror(error)                    }                }            }            csubadd(te)            if (csubisunsubscribed() || onceget()) {                break            }            sa[i]subscribe(te)        }    })}``` || @akarnokd ive used your code (rewrote some parts and  one bug) and now we dont have to convert `single`s to `observable`s! later we can switch other `singlezip` overloads to `singleoperatorzip` || @akarnokd changed `instanceof list` to `instanceof collection` so we are now really efficient for all collections and fall back to slightly less fast code for other `iterable`s rebased ptal || rebased! || blocked by #3569 || this needs to be rebased again ||   :+1: (for posterity) || "";;;;1;1;add singlezip() for iterable of singles;"
"3549;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove double whitespace in if conditions;just found them while walking through the source code trying to get a better overview of the rx internals.;;0;remove double whitespace in if conditions;just found them while walking through the source code trying to get a better overview of the rx internals;"":+1: youll find a lot of such issues@akarnokd checkstyle one day maybe? || i actually found only the one in `testsubscriber` after that i ran `ack """"if  """"` over the entire project and found also the other oneif you guys want i can add checkstyle in a separate pr || id be happy to see checkstyle in rxjava but my previous attempts to add it failed: #2807 #3147 and other comments || its hard to agree on some styles ie always use blocks with ifs and such || yes i get that though i dont see what the problem is fixing once they are mademaybe we could agree on some very basic checkstyle rules like dont use double whitespaces (if theres a rule for that) tab indention etc || is there anything against this being merged? || we usually require two likes from collaborators  "";;;;1;1;remove double whitespace in if conditions;"
3550;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;public api changes for 1.1.0 release;;;0;public api changes for 110 release;;this should be merged immediately after the next minor release (1017) the plan is to have a minor release that is identical to the following major release except for changes to the public api (which should not substantially change functionality)  ||   now we need to update the changesmd to reflect the public api changes that might have been easier in the old format of 1 pr per change ill probably do sub-bullets under the pr || so release notes for 110 state that single has been promoted out of beta but it looks like it is not actually out of beta ||;;;;1;1;public api changes for 110 release;
3561;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;corrected buffer operator onerror behaviour documentation;#3560;;0;corrected buffer operator onerror behaviour documentation;#3560;applied @akarnokd suggestion ||  ;;;;1;1;changed java docs to not suggesting if operation is hot;
3562;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;add single.doonunsubscribe();as promised  adding more operators to  single . this one is very useful for releasing resources if task can be cancelled externally via  subscription.unsubscribe()  and subscriber may not receive the result.;;0;add singledoonunsubscribe();as promised adding more operators to `single` this one is very useful for releasing resources if task can be cancelled externally via `subscriptionunsubscribe()` and subscriber may not receive the result; ;;;;1;1;add singledoonunsubscribe();
3563;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix typo in documentation;;;0;fix typo in documentation;;  ;;;;1;1;fix typo in documentation;
3565;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;replace never() calls in behaviorsubjecttest with verifynomoreinteractions;advantage is that we verify that there s no interaction at all so also something that we might not expect is not going to happen.;;0;replace never() calls in behaviorsubjecttest with verifynomoreinteractions;advantage is that we verify that theres no interaction at all so also something that we might not expect is not going to happen; ;;;;1;1;replace never() calls in behaviorsubjecttest with verifynomoreinteractionsmade testexception final again;
3566;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;deprecate observable.finallydo() and add observable.doafterterminate() instead;#3434 but for  observable .;;0;deprecate observablefinallydo() and add observabledoafterterminate() instead;#3434 but for `observable`;  ;;;;1;1;deprecate observablefinallydo() and add observabledoafterterminate() instead;
3567;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implemented observable#tocompletable;;;0;implemented observable#tocompletable;;addresses part of #3443 || ```rxinternaloperatorsonsubscribecompletabletest > testshoulduseunsafesubscribeinternallynotsubscribe failed    javalangassertionerror        at orgjunitassertfail(assertjava:92)        at orgjunitassertasserttrue(assertjava:43)        at orgjunitassertassertfalse(assertjava:68)        at orgjunitassertassertfalse(assertjava:79)        at rxinternaloperatorsonsubscribecompletabletesttestshoulduseunsafesubscribeinternallynotsubscribe(onsubscribecompletabletestjava:96)```the `completablefromobservable` needs to change to `unsafesubscribe` || thanks @akarnokd ||  ;;;;1;1;implemented observable#tocompletable;
3568;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;renamed completable#finallydo to #doafterterminate;renames as part of #3434 for the recently added completable.;;0;renamed completable#finallydo to #doafterterminate;renames as part of #3434 for the recently added completable;  ;;;;1;1;renamed completable#finallydo to #doafterterminate;
3569;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: fix renamed operator in single.;there was a cross dependency between two prs yielding a broken compilation in main.;;0;1x: fix renamed operator in single;there was a cross dependency between two prs yielding a brokencompilation in main;yup noticed that too git  im merging this to unblock other prs || ;;;;1;1;1x: fix renamed operator in singlethere was a cross dependency between two prs yielding a brokencompilation in main;
3570;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;implemented completable#andthen(observable);i expect some discussion around the method name.;;0;implemented completable#andthen(observable);i expect some discussion around the method name;adding unit tests and pushing shortly || ;;;;1;1;implemented completable#andthen(observable);
3575;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix typo in compositeexception documentation;;;0;fix typo in compositeexception documentation;;  ;;;;1;1;fix typo in compositeexception documentation;
3579;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: no more need to convert singles to observables for single.zip();ptal;;0;1x: no more need to convert singles to observables for singlezip();ptal; could you add `final` back for all these methods? otherwise  sorry was busy @zsxwing added `final` back will send separate pr to remove them everywhere once this  ;;;;1;1;no more need to convert singles to observables for singlezip();
"3584;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;clarify behaviour of groupby in javadoc;as discussed in #3411  some clarification of the behaviour of  groupby  looks necessary re its behaviour when the  groupedobservable  terminates early (for example has  .first()  applied to it). see also  #3581.  i also took the liberty of recommending  ignoreelements  instead of  take(0)  for the section in the javadoc that recommends how to ignore emissions because the  take(0)  approach would have more overhead (every emission from source would prompt the emission of a new  groupedobservable ) than the  ignoreelements  approach.  once this is accepted i ll look to submit a pr with  groupbyonce  (mentioned in #3411).;;3411.0;clarify behaviour of groupby in javadoc;as discussed in #3411 some clarification of the behaviour of `groupby` looks necessary re its behaviour when the `groupedobservable` terminates early (for example has `first()` applied to it) see also  #3581i also took the liberty of recommending `ignoreelements` instead of `take(0)` for the section in the javadoc that recommends how to ignore emissions because the `take(0)` approach would have more overhead (every emission from source would prompt the emission of a new `groupedobservable`) than the `ignoreelements` approachonce this is accepted ill look to submit a pr with `groupbyonce` (mentioned in #3411);corrected the documentation that said resubscription occurs when it is rather a new groupedobservable is emittted for a group || incorporated @akarnokd suggestion ||  :+1: > i also took the liberty of recommending ignoreelements instead of take(0) for the section in the javadoc that recommends how to ignore emissions because the take(0) approach would have more overhead (every emission from source would prompt the emission of a new groupedobservable) than the ignoreelements approachby the way `ignoreelements` has a drawback: it keeps all group `observable`s in memory even some of them wont emit items ||;#groupby resubscribes to observable after unsubscribing;_apologies if this is repeated #283 looked similar but im opening a new issue since that doesnt seem to be the current behavior_`observable#groupby` encourages us to unsubscribe from `observables` that we no longer want values from to avoid leaking that memory which makes total sense ``` javaobservable    groupby(somekey::new)    subscribe(groupedobservable -> {        // this is called again after unsubscribing        groupedobservable            take(1)            subscribe()    })```this works fine however theres a behavior i was not expecting: after `groupedobservable` has been unsubscribed the `observable` returned  observablegroupby` emits that observable again!is this expected?_(currently using version 1010)_;""this is the expected behavior``` javaobservablerange(1 10)groupby(v -> 1)flatmap(g -> gtake(1))subscribe(systemout::println)```this will print values from 1-10 whether or not this is reasonable is up for discussion the alternative would be to drop values once the single subscriber to the group unsubscribes so no groups are opened || seems counter intuitive and i think it at least deserves a comment in the docshow could i implement a similar `groupby` operator that never emits that same `observable` again? || this behaviour is not what i would hope from `groupby` either i can imagine both the resubscribing and non-resubscribing behaviour being useful but i would expect the default to be non-resubscribing  || thanks @davidmoten i agree || anyone out there know what the microsoft rx `groupby` behaviour is in this regard? || what i can deduce from the [source code]( is that groups are created but never removed and once all groups and the main output is disposed the source is stoppednote that rxnet doesnt have backpressure and the synchronous cancellation is a mistery to me in it> how could i implement a similar groupby operator that never emits that same observable again?groupby is perhaps the most complicated operator to think about because of the request/unsubscribe coordination requirement you could try using publish on a group to prevent it from unsubscribing:``` javaobservablerange(1 10)groupby(i -> i % 2  0)flatmap(g -> gpublish()autoconnect()take(1))subscribe(systemout::println)``` || thanks for checking that out @akarnokd i assume from your description that the microsoft rx `groupby` follows the non-resubscribing approach im tempted to describe the current `groupby` behaviour as a bug @benjchristensen any thoughts? || it is supposed to resubscribe and is different than the microsoft version on purpose which has issues with time gap and which does not support back pressure (which seriously changes things) see the 10 release notes for information (section on groupby/groupbyuntil  in  and  for the proposed changes and reasoning in v2 we will separate observable and flowable which will allow the resubscribe behavior to be different if we wanted again on the non-backpressured version  || another thought on this for clarification - if the operator remembers what has been unsubscribed so as to drop subsequent events that means it uses memory and is the """"memory leak"""" mentioned above not a big deal for small numbers of groups or short-lived streams but it does retain all group keys for the duration if that implementation is chosen  || > you could try using publish on a group to prevent it from unsubscribing:then were just leaking more memory than the group keys> another thought on this for clarification - if the operator remembers what has been unsubscribed so as to drop subsequent events that means it uses memory and is the """"memory leak"""" mentioned abovetrue but thats required to get the behavior that most people in this issue have labeled as expected (and unfortunately this is not documented)would it be easy to implement the old `groupbyuntil`? || the things i linked to explain why they were combined and groupbyuntil behaves how you dont want it (it would re-emit the group) your use case requires remembering previously seen keys so you have to retain that knowledge the solution from @akarnokd is a good one there are other ways involving filter such as not using take(1) but instead filtering out all values after the first  || this is a solution using `filter` as mentioned by @benjchristensen:``` javaobservablerange(1 10)  groupby(i -> i % 2  0)  flatmap(g ->     observabledefer(() -> {      final atomicboolean isfirst  new atomicboolean(true)      return gfilter(x -> isfirstcompareandset(true false))    }))  subscribe(systemout::println)```admittedly it doesnt offer the same guarantees as `take(1)` like emitting an error if the stream completes without emitting || thats only a solution equivalent to `take(1)` but in my case the inner `observable` is unsubscribed with more complex logic || > if the operator remembers what has been unsubscribed so as to drop subsequent events that means it uses memory and is the """"memory leak"""" mentioned aboveisnt that true with any operator that has """"memory"""" like `distinct`? in fact i dont see how this is any different than `distinct` || thanks @nachosoto for bringing the behaviour of `groupby` to my attention i think this behaviour needs description in the javadoc at minimum i checked my codebases for `groupby` usage to make sure i wasnt going to get bitten by this and ive nothing to worry about since ive become aware of the behaviour i keep bumping into use cases where i would want the resubscribing behaviour so ill be glad if the behaviour is retained under some method namemy leaning at the moment is to document the behaviour of the existing operator and not change it but add another operator say `groupbyonce` (?) that offers the non-resubscribing behaviour you expected thoughts? || :+1: :+1:  i cant read that comment @nachosoto say again? || ? || im preparing a pr to clarify the behaviour in the javadoc and notice that `groupby` says this in javadoc:```groups the items emitted by an {@code observable} according to a specified criterion and emits thesegrouped items as {@link groupedobservable}s one {@code groupedobservable} per group```no surprise that people have been confused by this operator because it is explicit that its output is _one_ `groupedobservable` per group! ill correct this and explain further || ~~correction: it is one `groupedobservable` per group just potentially multiple subscriptions~~ || blimey correction to my correction multiple groupedobservables can be emitted (against what the javadoc says) deleting my previous comment || im closing this issue due to inactivity if you have further input on the issue dont hesitate to reopen this issue or post a new one || "";1;0;add more detail to groupby javadoc;"
3584;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;clarify behaviour of groupby in javadoc;as discussed in #3411  some clarification of the behaviour of  groupby  looks necessary re its behaviour when the  groupedobservable  terminates early (for example has  .first()  applied to it). see also  #3581.  i also took the liberty of recommending  ignoreelements  instead of  take(0)  for the section in the javadoc that recommends how to ignore emissions because the  take(0)  approach would have more overhead (every emission from source would prompt the emission of a new  groupedobservable ) than the  ignoreelements  approach.  once this is accepted i ll look to submit a pr with  groupbyonce  (mentioned in #3411).;;3581.0;clarify behaviour of groupby in javadoc;as discussed in #3411 some clarification of the behaviour of `groupby` looks necessary re its behaviour when the `groupedobservable` terminates early (for example has `first()` applied to it) see also  #3581i also took the liberty of recommending `ignoreelements` instead of `take(0)` for the section in the javadoc that recommends how to ignore emissions because the `take(0)` approach would have more overhead (every emission from source would prompt the emission of a new `groupedobservable`) than the `ignoreelements` approachonce this is accepted ill look to submit a pr with `groupbyonce` (mentioned in #3411);corrected the documentation that said resubscription occurs when it is rather a new groupedobservable is emittted for a group || incorporated @akarnokd suggestion ||  :+1: > i also took the liberty of recommending ignoreelements instead of take(0) for the section in the javadoc that recommends how to ignore emissions because the take(0) approach would have more overhead (every emission from source would prompt the emission of a new groupedobservable) than the ignoreelements approachby the way `ignoreelements` has a drawback: it keeps all group `observable`s in memory even some of them wont emit items ||;observablefirst() not working properly after grouping data;i am calling things like this```observablejust(1 2 3 4 5 6)                groupby(i -> i % 3)                flatmap(o -> ofirst())                subscribe(systemout::println)```ideally this should return 123but the result is - ```123456```got this issue in version 1010 and 110 as well;this is expected `groupby` will emit a new `observable` if the previous `observable` of the same group is subscribed || this has been discussed in #3411 its about time i made this clearer in the javadoc so ill knock up a pr soon || looks like this issue can be closed?  || #3584 has updated the doc ||;1;0;add more detail to groupby javadoc;
3585;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: fix completable.using not disposing the resource if the factory crashes during the subscription phase.;this pr fixes the cases when the completable factory throws an exception or returns null and the resource is not disposed before reporting error to the subscriber.;;0;1x: fix completableusing not disposing the resource if the factory crashes during the subscription phase;this pr fixes the cases when the completable factory throws an exceptionor returns null and the resource is not disposed before reporting errorto the subscriber; ;;;;1;1;1x: fix completableusing not disposing the resource if the factorycrashes during the subscription phasethis pr fixes the cases when the completable factory throws an exceptionor returns null and the resource is not disposed before reporting errorto the subscriber;
3586;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fixed typo;;;0; typo;;  thanks a lot @mariusznet  ||;;;;1;1; typo;
3587;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove the need for javac to generate synthetic methods.;outer classes accessing inner class private fields and methods (and vise versa) causes javac to generate package-scoped trampolines. these bloat the class files  adds overhead to the inliner analysis  and for android create needless method that eat away at our fixed limit of methods in an application. by simply promoting the private interactions to package scope directly  the synthetic methods do not need generated.  2.5% of rxjava s methods were these needless generated trampolines accounting for 1.2% of jar size and 1.4% of dex size.      $ dex-method-count before.dex 5005  $ dex-method-count after.dex 4875          -rw-r--r--   1 jw  jw   699k dec 25 03:08 after.dex -rw-r--r--   1 jw  jw   952k dec 25 03:08 after.jar -rw-r--r--   1 jw  jw   709k dec 25 03:06 before.dex -rw-r--r--   1 jw  jw   964k dec 25 03:06 before.jar;;0;remove the need for javac to generate synthetic methods;outer classes accessing inner class private fields and methods (and vise versa) causes javac to generate package-scoped trampolines these bloat the class files adds overhead to the inliner analysis and for android create needless method that eat away at our  limit of methods in an application by simply promoting the private interactions to package scope directly the synthetic methods do not need generated25% of rxjavas methods were these needless generated trampolines accounting for 12% of jar size and 14% of dex size```$ dex-method-count beforedex5005$ dex-method-count afterdex4875``````-rw-r--r--   1 jw  jw   699k dec 25 03:08 afterdex-rw-r--r--   1 jw  jw   952k dec 25 03:08 afterjar-rw-r--r--   1 jw  jw   709k dec 25 03:06 beforedex-rw-r--r--   1 jw  jw   964k dec 25 03:06 beforejar```; ;;;;1;1;remove the need for javac to generate synthetic methodsouter classes accessing inner class private fields and methods (and vise versa) causes javac to generate package-scoped trampolines these bloat the class files and for android create needless method that eat away at our  limit of methods in an application by simply promoting the private interactions to package scope directly the synthetic methods do not need generated;
3592;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: add never test for  publishsubjecttest;this pr complete the never assert in publishsubjecttest.;;0;1x: add never test for  publishsubjecttest;this pr complete the never assert in publishsubjecttest; in every test method that is using `verifynomoreinteractions` you can remove the `verify(observer never())*` || > in every test method that is using verifynomoreinteractions you can remove the verify(observer never())*your are right but i think adding these verifies can make tests more clearly || fair enough i just thought you forgot to delete them and wanted to point it outin any case the deletion decision is something the repo owners have to dopersonally the less test code the preciser it is especially since `verifynomoreinteractions` clearly states it purpose ||  ;;;;1;1;add  verifynomoreinteractions(observer) for  publishsuibjecttext;
3609;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;delaysubscription(func0) does not use a scheduler;it subscribes to the upstream  observable  on the emitting thread of the other  observable  obtained from the  func0 .;;0;delaysubscription(func0) does not use a scheduler;it subscribes to the upstream `observable` on the emitting thread of the other `observable` obtained from the `func0`; ;;;;1;1;delaysubscription(func0) does not use a schedulerit subscribes to the upstream `observable` on the emitting thread of the other `observable` obtained from the `func0`;
"3614;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: just() now supports backpressure (+ related fixes/changes);updated  just()  to fully support backpressure.  this is a repost of #3496 due to merge and rebase problems.;;3496.0;1x: just() now supports backpressure (+ related fixes/changes);updated `just()` to fully support backpressurethis is a repost of #3496 due to merge and rebase problems;we were waiting to hear from @benjchristensen on this one i think any news? || +1 for correctness despite my hesitance due to perf impact  ||;1x: make just() support backpressure;""one does not simply add backpressure support to `just()`## fixesthe reason for this is the bugs hidden by the lack of backpressure support of just(): the overwriting of a previous producer  timeout` `zip` and `subscribeon` ive  up `timeout` with a proper `producerarbiter` had to apply the bugfix from #3493 to `zip` (may conflict) and had to rewrite `subscribeon` from scratch and have it an `onsubscribe` this change required that `singlesubscribeon` to be rewritten as well## benchmarklets see the benchmark comparison (i7 4790 windows 7 x64 java 8u66):( are two ways to implement backpressure: with strong atomics or with plain field accesses the latter tries to exploit the high chance that there wont be concurrent calls to `request()` ever and thus saves on the atomics as far as i can tell there is nothing in rxjava 1x or 2x that would violate this assumption however i added an escape hatch in case of rogue requesters: set the `rxjuststrong-mode` system parameter to """"true"""" and `just` will run with strong atomicsas seen in the table the weak version is just slightly better (+3-+10%) in some cases and slightly worse (up to -3%) in other cases note however the original cases have 2x-5x less overhead maybe the most revealing are the `simple` `simpleescape` and `simpleescapeall` comparison between and within version whats seen there is that with the original version the jit converted the test into a pure stack-allocation and thus saving on overhead in the `simple` case as the other tests add escapes it forces the jit to do regular allocations interesting that with this pr the escape doesnt really matter: this is due to how `subscribersetproducer` makes the jit believe the producer escapesin the `simpleescapeall` (which should be the most restrictive for jit) the overhead is still 2 - 23 times bigger: this is due to the extra allocation of a `producer` instance when subscribingif one remembers my recent [blog post]( it can be seen that rxjava 2x does quite well about 30 mops/s in the range-1 test (which is equivalent to `simple`) where does the overhead come from? `subscriptionlist` in 1x the `subscriber` creates a `subscriptionlist` whether or not it is ever required (ive tried my best several times to defer the creation of this list to no success: the performance improved for some cases while worsened for others see #3479)the strong/weak optimization is not applied to `scalarscheduleon` i havent benchmarked it but i guess the scheduling overhead overshadows it anyways## conclusioni believe the correctness of `just` is more important than its performance but the increased overhead bothers me nonetheless given the architecture of 2x ill look into ways to get rid of the mandatory `subscriptionlist` allocation without breaking public api classes such as `subscriber`"";rebased || interesting thanks!  this should probably be checked out by @benjchristensen before merging || just to check you are fine with the overhead right? || @akarnokd yes i think consistent behavior is worth the hit  ||  any plans to merge this one? || we are waiting for ben but i have to fix the merge conflict as well now i see || sorry ill redo this entire pr everything is messed up || replaced by #3614  ||;1;0;1x: just() now supports backpressure (+ related fixes/changes);"
3620;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: fix npe in compositeexception when nested throws on initcause;possible solution :);;0;1x: fix npe in compositeexception when nested throws on initcause;possible solution :); :+1: @msavitskiy can you please squash commits in your pr into one? || @artem-zinnatullin  i make squash commits i did the right thing? || @msavitskiy mm nopebasically you should have one commit after squash done right id suggest to read documentation and some examples (maybe even videos) about `git rebase`if itll be blocker for merge i can squash your pr and resubmit it (youll still be author of the commit!) || @artem-zinnatullin now everything is fine? || @msavitskiy yes  ;;;;1;1;fix for issue 3599move line to try block for avoid assigned twice;
3626;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;use exceptions.throworerror to simplify error handling;this pr simplifies error handling by making use of existing  exceptions.throworerror  overloads.  a number of classes are touched by this one pr but i m assuming review will be easy enough that merge can happen soon.;;0;use exceptionsthroworerror to simplify error handling;this pr simplifies error handling by making use of existing `exceptionsthroworerror` overloadsa number of classes are touched by this one pr but im assuming review will be easy enough that merge can happen soon;it looks like my optimize imports messed up the imports on `observablejava` ill restore them to what they were originally  ||  oops sorry wrong pr || ;;;;1;1;use exceptionsthroworerror to simplify error handling;
3627;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: added mergedelay operators for iterable of observables;pr for issue #3577;;0;1x: added mergedelay operators for iterable of observables;pr for issue #3577; just few things about code style otherwise lgtm  :+1: once you fix the style issue || :+1: after renaming the `mergeiterable` method || :+1: @johnwowus can you please squash commits in your pr into one? || @johnwowus could you squash commits?  @zsxwing done || ;;;;1;1;added mergedelay operators for iterable of observables;
3642;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: optimizate single just;this pr add similar optimization as scalarsynchronousobservable to single.just method.;;0;1x: optimizate single just;this pr add similar optimization as scalarsynchronousobservable to singlejust method;could you also squash the commits? || in the master there is a new class `singlesourceperf` could you run it before and after to see how well the optimizations work? || ok i will try to do it || @akarnokd i cant find class singlesourceperf in master do you mean singleperfbaseline? ||  || i have run the benchmark on 1x and this pr(intel core i5-2400 @310ghz windows 7 x64 java 180_45-b15) the results are as follows:### 1x![20160126163611]( this pr![20160126163953]( results show that most of scores in this pr is higher than 1x especially that flatmap and flatmapconnst have a great ascension ||  rebased || @chaoba could you rebase against the master and fix the minor subscription issue?  @zsxwing thanks for your comment should i squash the commits? || > @zsxwing thanks for your comment should i squash the commits?@chaoba yes please || the commits has been squashed || :+1: ping @akarnokd to take a final look and pull in :) || :+1:@artem-zinnatullin id like your opinion on this `single` matter || @chaoba please add tests for: `scalarmerge` `scalarobserveon` and `scalarsubscribeon` and squash pr into one commitotherwise looks great will be happy to see it in next release! || add some new testcases now the coverage is as follows:![20160202112639]( ||  great set of tests! just few comments left @chaoba please ping again once you fix them! (you can squash commits right away so we could merge it asap) || ping @artem-zinnatullin to review again please || :+1: thanks a lot @chaoba! (looks like we can merge it now) || ;;;;1;1;add optimization to just method in single;
3648;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add support for concurrently inserting actions while advancing time;this change is adding a bit of thread safety when some threads are trying to insert some actions while the time is changed in the testscheduler;;0;2x: add support for concurrently inserting actions while advancing time;this change is adding a bit of thread safety when some threads are trying to insert some actions while the time is changed in the testscheduler;im in for this small change could you rebase/redo this for the current 2x branch? || sure will do that today || ;;;;1;1;removing the unit test proving the thread safety ofa blockingpriorityqueue;
"3651;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: remove redundant  final  modifiers;as promised in #3579.;;0;""1x: remove redundant """"final"""" modifiers"";as promised in #3579; ;;;;1;1;""remove redundant """"final"""" modifiers"";"
3655;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: add single.onerrorresumenext(single);part of #3652  will submit a pr for  onerrorresumenext(func1<throwable  single>)  later.;;3652.0;1x: add singleonerrorresumenext(single);part of #3652 will submit a pr for `onerrorresumenext(func1<throwable single>)` later;@akarnokd changed to `implements singleonsubscribe`! ptal ||  @zsxwing ptal :) ||  ;mapping onerror notifications;i often have the use case that i want to map the `throwable` emitted by an `onerror` notification of an `observable` to something else for example wrapping or unwrapping itmaybe i missed something but apparently there is no stock solution in rxjava to achieve this currently i use a custom `operator` would it make sense to add such an `operator` along with its corresponding `observablemaperror` / `singlemaperror` methods to rxjava directly?;there is the `onerrorreturn` and `onerrorresumenext` operators that will give you the throwable which you can then map to a value or another error through `observableerror()` ie:``` javasourceonerrorresumenext(e -> observableerror(egetcause()))``` || materialize() is useful in this regard tooon wed 27 jan 2016 19:56 david karnok notifications@githubcom wrote:> there is the onerrorreturn and onerrorresumenext operators that will give> you the throwable which you can then map to a value or another error> through observableerror() ie:> > sourceonerrorresumenext(e -> observableerror(egetcause()))> > > reply to this email directly or view it on github>  || ah yeah `onerrorresumenext` is a bit more verbose but does the trick thanks! on the other hand theres no `onerrorresumenext` for `single` only `onerrorreturn` which cannot be used for the described use casewould it then perhaps make sense to add an implementation of `onerrorresumenext` to `single` too? || ill add required operators for `single` first one is #3655 next one later@twz123 looks like your issue is now resolved? if so  please close it :) || cool! `onerrorresumenext(func1<throwable single>)` would be the thing i need ill close this and wait for the pr ) thanks a lot! || see #3766 for second part ||;1;0;add singleonerrorresumenext(single);
3661;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: combinelatest now supports any number of sources;this pr is a backport of the 2.x  combinelatest  with  null  support and let s the programmer combine more than 128 sources at once. note that 2.x supports manual sizing of the prefetch buffer and allows delaying the exceptions to the last moment  i kept these in case such features are required by 1.x some day.  the original had this 128 limit due to using a single and non-parametric rxringbuffer to store values from sources. in addition  the original algorithm divided downstream requests among the sources with some strange logic in order to keep them running and not overflow the buffer.  this pr uses an unbounded-linked spsc queue which can now hold as many elements as there are sources times the default ring buffer size (this is not preallocated and grows/shrinks as necessary).  the algorithm stores the current latest array and the source subscriber in the queue in pairs so when that particular row is emitted to downstream  that source subscriber gets the request() replenishment call that generated the row.  in addition  i ve added an iterator overload from #3660 as well.;;3660.0;1x: combinelatest now supports any number of sources;this pr is a backport of the 2x `combinelatest` with `null` support and lets the programmer combine more than 128 sources at once note that 2x supports manual sizing of the prefetch buffer and allows delaying the exceptions to the last moment i kept these in case such features are required by 1x some daythe original had this 128 limit due to using a single and non-parametric rxringbuffer to store values from sources in addition the original algorithm divided downstream requests among the sources with some strange logic in order to keep them running and not overflow the bufferthis pr uses an unbounded-linked spsc queue which can now hold as many elements as there are sources times the default ring buffer size (this is not preallocated and grows/shrinks as necessary)the algorithm stores the current latest array and the source subscriber in the queue in pairs so when that particular row is emitted to downstream that source subscriber gets the request() replenishment call that generated the rowin addition ive added an iterator overload from #3660 as well; ;add combinelatest overload for collection;2x already uses `iterable` but thats a very drastic change compared to just `collection`motivation here is that im using set bindings to create observables in a dependency injector and i want to skip the current `new arraylist<>(sources)` that i have to do on the set;can we revisit this once #3507 is merged? || yep that allows exposing `iterable` as well which is even better || :+1: dont you want to add tests for your new `observablecombinelatest()`? `onsubscribecombinelatestjava` is internal will be great to cover public api as well for possible changes in future implementation and to test operator from users point of view || the tests were modified to use iton mon feb 1 2016 at 10:27 am artem zinnatullin notifications@githubcomwrote:> [image: :+1:]> > dont you want to add tests for your new observablecombinelatest()?> onsubscribecombinelatestjava is internal will be great to cover public> api as well for possible changes in future implementation and to test> operator from users point of view> > > reply to this email directly or view it on github>  || tests for `onsubscribecombinelatest` were modified but im talking about tests for `observablecombinelatest(collection funcn)` || they use that api ||;1;0;1x: combinelatest now supports any number of sources;
3668;1;0;0;0;0;1;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: full jdk 6 compatible backport + including bugfixes up to today;due to the issue with atomicxfieldupdaters on certain android devices  i had to manually replace all of them with regular atomicx classes.;;0;2x: full jdk 6 compatible backport + including bugfixes up to today;due to the issue with atomicxfieldupdaters on certain android devices i had to manually replace all of them with regular atomicx classes;this is basically unreviewable so i vote that it is just merged people can go through the code base passively and bring up any issues/questions/etc as theyre discovered || its not possible incrementally anyway ie by using our own function it affects all operators that take function || :+1: agree || im ok for merging it as is lets review it incrementally :+1: for all of this || merged happy reviewing! ||;;;;1;1;2x: full jdk 6 compatible backport + including bugfixes up to today;
3671;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix schedulerlifecycle.teststartidempotence vs cached threads dying;i forgot that rxcached threads can get evicted during the test. the new logic makes sure no new threads appeared.;;0;2x: fix schedulerlifecycleteststartidempotence vs cached threads dying;i forgot that rxcached threads can get evicted during the test the new logic makes sure no new threads appeared;   ;;;;1;1;2x: fix schedulerlifecycleteststartidempotence vs cached threads dying;
3678;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: fix counted buffer and window backpressure;this pr fixes the backpressure behavior of the counted  buffer  and  window  operators and consists of several changes.  the main issue lies when  count > skip  in the operators  yielding overlapping buffers/windows.   for  buffer   when the upstream completed  the logic emitted all remaining partial buffers even if there was no request for new buffers  which can result in  missingbackpressureexception  somewhere. the proper handling of the final buffers required a new backpressure management algorithm which is now part of the  backpressureutils  class and consists of two new methods:  postcompletedone  called from oncomplete to take over the emission of queued values and  postcompleterequest  which manages requests before and after the completed state.  for  window   the new window opened was emitted regardless of requests which was common due to request-amplification (i.e.  requesting n windows results in requesting  count + skip * (n - 1)  elements at first (then  skip * n  later) which opens  ceil(count / skip)  windows upfront. to avoid the overflow  the individual windows have to go through the usual queue/drain logic as well. i ve also updated the javadoc to reflect the backpressure behavior along with parameter validation.  in addition  the window case didn t manage cancellation properly. when the outer observable is unsubscribed  the inner subscribers may be still going and thus cancelling the upstream would stop/hang the inner windows. instead  the open window count is tracked (also counting the outer as 1 window) and when all get unsubscribed (i.e.  count reaches zero)  the upstream is unsubscribed. to accomplish this  the  unicastsubject  had to be retrofitted with a new optional callback  action0  which gets called at most once whenever either  onerror  or  oncompleted  is called or when the single  subscriber  unsubscribes.  a secondary issue was with the  testsubscriber  s initial request  some upstream operators could get triggered with  long.max_value  despite the initial request amount was set. this pr changes it to be set at construction time instead of in  onstart .;;0;1x: fix counted buffer and window backpressure;this pr fixes the backpressure behavior of the counted `buffer` and `window` operators and consists of several changesthe main issue lies when `count > skip` in the operators yielding overlapping buffers/windows for `buffer` when the upstream completed the logic emitted all remaining partial buffers even if there was no request for new buffers which can result in `missingbackpressureexception` somewhere the proper handling of the final buffers required a new backpressure management algorithm which is now part of the `backpressureutils` class and consists of two new methods: `postcompletedone` called from oncomplete to take over the emission of queued values and `postcompleterequest` which manages requests before and after the completed statefor `window` the new window opened was emitted regardless of requests which was common due to request-amplification (ie requesting n windows results in requesting `count + skip * (n - 1)` elements at first (then `skip * n` later) which opens `ceil(count / skip)` windows upfront to avoid the overflow the individual windows have to go through the usual queue/drain logic as well ive also updated the javadoc to reflect the backpressure behavior along with parameter validationin addition the window case didnt manage cancellation properly when the outer observable is unsubscribed the inner subscribers may be still going and thus cancelling the upstream would stop/hang the inner windows instead the open window count is tracked (also counting the outer as 1 window) and when all get unsubscribed (ie count reaches zero) the upstream is unsubscribed to accomplish this the `unicastsubject` had to be retrofitted with a new optional callback `action0` which gets called at most once whenever either `onerror` or `oncompleted` is called or when the single `subscriber` unsubscribesa secondary issue was with the `testsubscriber`s initial request some upstream operators could get triggered with `longmax_value` despite the initial request amount was set this pr changes it to be set at construction time instead of in `onstart`;ping @stevegury @stealthcode @zsxwing  || @inoles i think thats githubs fault you can see [here]( that the line is fine  ||  all 3 sites of `new arraylist` ||  ;;;;1;1;1x: fix counted buffer and window backpressure;
"3682;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: fix observeon resource handling  add delayerror capability;this pr fixes the  messing around  reported in #3002 and adds an overload to  observeon  that allows delaying errors without the need for wrapping (see #3542 and maybe there are other reports).  in addition  this pr adds a proper override of the  isempty  method to simply compare the two indexes for emptiness directly instead of  size() == 0  to avoid looping  multi-reading and casting.  benchmark comparison (i7 4790  windows 7 x64  java 8u66):  (  note that the benchmark is generally quite noisy  yielding hectic results (i.e.  firing up a thread with newthread may take quite some random microseconds). for example   observeonimmediate  shouldn t be affected by any of the changes yet the run-to-run variance is +/- 10%. i m fine with the results of the benchmark.;;3002.0;1x: fix observeon resource handling add delayerror capability;""this pr fixes the """"messing around"""" reported in #3002 and adds an overload to `observeon` that allows delaying errors without the need for wrapping (see #3542 and maybe there are other reports)in addition this pr adds a proper override of the `isempty` method to simply compare the two indexes for emptiness directly instead of `size()  0` to avoid looping multi-reading and castingbenchmark comparison (i7 4790 windows 7 x64 java 8u66):( that the benchmark is generally quite noisy yielding hectic results (ie firing up a thread with newthread may take quite some random microseconds) for example `observeonimmediate` shouldnt be affected by any of the changes yet the run-to-run variance is +/- 10% im fine with the results of the benchmark"";;observeon: unsubscribe of recursivescheduler;need to explore the unsubscribe of `recursivescheduler`:  seems to wrap with `childadd(scheduledunsubscribe)` and then defeat that with `childadd(recursivescheduler)`;yes looks odd i cant really remember why the unsubscription of the worker had to be scheduled maybe it had something to do with pitfall no 2: unsubscribing the downstream: something around subscribe and `safesubscriber` doing this and cutting off the last few events from the wrapped `subscriber` || might be another problem here that the call to `childsetproducer` is made before adding all the subscriptions i might test with #2997 || > why the unsubscription of the worker had to be scheduledwas it was because we could end up not emitting an `onerror` that was scheduled but then dropped because the `worker` got unsubscribed? || i think @akarnokd is right that `safesubscriber` reports `oncompleted` to its wrapped subscriber then unsubscribes which if `childadd(recursivescheduler)` is present can cut short the schedule in `operatorobserveon` so that it doesnt emit its stuff re `onerror` getting dropped this is still a possiblity but still consistent with the observable contract (?) all the scheduled polls of the queue do check for error first so that once a scheduled task is run the error can shortcut the queue perhaps we can do something to aid this scenario without stuffing up the `oncomplete` case || ive probably got my last comment backwards i was thinking that safesubscriber was upstream of observeon but should be downstream so wouldnt have the effect i stated || `safesubscriber` came into play earlier when the operators used `subscribe()` to attach to each other instead of `unsafesubscribe()` || closing via #3682 ||;1;0;1x: fix observeon resource handling add delayerror capability;"
"3682;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: fix observeon resource handling  add delayerror capability;this pr fixes the  messing around  reported in #3002 and adds an overload to  observeon  that allows delaying errors without the need for wrapping (see #3542 and maybe there are other reports).  in addition  this pr adds a proper override of the  isempty  method to simply compare the two indexes for emptiness directly instead of  size() == 0  to avoid looping  multi-reading and casting.  benchmark comparison (i7 4790  windows 7 x64  java 8u66):  (  note that the benchmark is generally quite noisy  yielding hectic results (i.e.  firing up a thread with newthread may take quite some random microseconds). for example   observeonimmediate  shouldn t be affected by any of the changes yet the run-to-run variance is +/- 10%. i m fine with the results of the benchmark.;;3542.0;1x: fix observeon resource handling add delayerror capability;""this pr fixes the """"messing around"""" reported in #3002 and adds an overload to `observeon` that allows delaying errors without the need for wrapping (see #3542 and maybe there are other reports)in addition this pr adds a proper override of the `isempty` method to simply compare the two indexes for emptiness directly instead of `size()  0` to avoid looping multi-reading and castingbenchmark comparison (i7 4790 windows 7 x64 java 8u66):( that the benchmark is generally quite noisy yielding hectic results (ie firing up a thread with newthread may take quite some random microseconds) for example `observeonimmediate` shouldnt be affected by any of the changes yet the run-to-run variance is +/- 10% im fine with the results of the benchmark"";;scheduling should serialize notifications;""currently `onerror` cuts ahead of `onnext` calls when you schedule work but does not (cannot) when you use a single thread```observablecreate(o -> {    oonnext(1)    oonerror(new notimplementedexception())})observeon(schedulersnewthread())subscribe(i -> systemoutprintln(i)         e -> systemoutprintln(""""error:"""" + e))```this yields `error` instead of `1 error` as expected other implementations of rx like rxnet do serialize notifications this cut ahead behavior is actually described as a [common pitfall]( in rxjava by some"";rxjava 20 will allow you to customize this behavior in many operators including `observeon` `delay` `combinelatest` `zip` `groupby` `onbackpressurebuffer` `skiplast` and `takelast`i was planning to post a pr targeting `observeon` to remove some unnecessary code (#3002) and may well do this as well || this is really scary nondeterministic behavior and against rx contract i hope the (future) default will be to not lose data if anything it might be an appropriate setting on the subscriber || the `observeon` operator received an overload that takes a `delayerror` parameter you can setclosing via #3682 ||;1;0;1x: fix observeon resource handling add delayerror capability;"
3683;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: javadoc for rx.exceptions.exceptions;see #1508;;0;1x: javadoc for rxexceptionsexceptions;see #1508;  ;;;;1;1;1x: javadoc for rxexceptionsexceptionssee #1508;
3686;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;added retry and retrywhen support for single;;;0;added retry and retrywhen support for single;;please dont unroll `import *` because it creates merge conflicts all the time || my codestyle settings messed everything a bit is there a exported codestylexml file or something similar so i could import into my ide? || not really also please squash your commits || could you also fix those 1 spaces removed everywhere? || i have  all reported problems || something went really wrong i merged latest changes from upstream 1x to my 1x branch || in this case id just start from a clean branch of master and reapply/merge my customizations || i managed to fix it now i just need to sort out the missing spaces || this looks much better ;;;;1;1;added retry and retrywhen support for single;
3689;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: unified onerrorx and onexceptionresumenext and fixed backpressure;the operators didn t honor backpressure when they switched over to the other observable.  this pr also includes the 3685.;;3685.0;1x: unified onerrorx and onexceptionresumenext and  backpressure;the operators didnt honor backpressure when they switched over to the other observablethis pr also includes the 3685;there was a test failure in backpressureteststestmergeasync run before any of the changes of this pr and shouldnt have any effect overloaded servers? || ;1x: onerrorresumenext(func1) should not call plugin handler there;when the operator switches to the other that counts as a handled error see also #3347;there are similar patterns in the other `onerror*` operators namely `operatoronerrorresumenextviaobservable` and `operatoronerrorreturn` - do those need changing as well? || yes ill update this pr || updated although all of these classes have backpressure bugs in them || replaced by #3689 ||;1;0;1x: unified onerrorx and onexceptionresumenext and  backpressure;
3692;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: fix completable using jdk 7 suppressed exceptions feature;the upgraded gradle switched my ide to use a jdk 6 library i have installed all along and these popped up immediately.;;0;1x: fix completable using jdk 7 suppressed exceptions feature;the upgraded gradle switched my ide to use a jdk 6 library i have installed all along and these popped up immediately;  although nebula gradle plugin requires java 7 im still wondering if we can setup a build to compile codes with java 6 to avoid such issue eg i can just use `find src/main/java/* -name *java | xargs javac` to compile them using java 6 and see if any error ||;;;;1;1;1x: fix completable using jdk 7 suppressed exceptions feature;
"3696;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: added single execution hooks;3595;;359.0;1x: added single execution hooks;3595;would you also apply these plugin methods in single?- onsubscribestart- onsubscribereturn- onsubscribeerror- onlift || below hooks are already called (i replaced previous calls of `rxjavaobservableexecutionhook`  rxjavasingleexecutionhook` calls)- onsubscribereturn- onsubscribeerror- onlifthowever there is problem with `onsubscribestart` this hook should be called in `onsubscribe` and `unsafesubscribe` unfortunately in `single` `onsubscribe` and `unsafesubscribe` methods get `subscriber` type as parameter instead of `singlesubscriber` i will make a commit to cover it soon || there is something wrong a bunch of single test failed ||  as far i see that failing test is not related with my changes is `rxschedulerscachedthreadschedulertest > testunsubscribeforscheduler` some kind of flaky test? || more tests would be appreciated but otherwise  could you squash the commits and rebase this pr? || :+1: (after you rebase/squash the commits) || ;varargs cause compiler warnings;""im trying to use the `concat` operator but i cant use it without getting a compiler warning heres my code:```observable<horrormovie> horrormovieswithexception() {    observable<horrormovie> movies  observablefrom(new horrormovie())    observable<horrormovie> ex  observableerror(new exception(""""test""""))     return observableconcat(movies ex) // (warning)}```i get the warning """"type safety: a generic array of observable<covariancetesthorrormovie> is created for a varargs parameter""""this problem was discussed on [stackoverflow]( and this [bug report]( explains why its not going to be "";""the same problem also occurs with `merge` `mergedelayerror` and if arguments with generic type are passed to `from` and `startwith` they are also affected || unless someone shows me how to get rid of this warning without using `@suppresswarnings(""""unchecked"""")` i would suggest that we remove the varargs methods and add instead-    an overloaded method for each arity-    a method taking an iterable (will be used by the scala adaptor) || like the zip operator?sent from my iphoneon sep 9 2013 at 1:50 am samuelgruetter notifications@githubcom wrote:> unless someone shows me how to get rid of this warning without using @suppresswarnings(""""unchecked"""") i would suggest that we remove the varargs methods and add instead> > an overloaded method for each arity> a method taking an iterable (will be used by the scala adaptor)> > reply to this email directly or view it on github || yes || that issue with varargs is definitely one of the weaknesses of generics how about if we had overloads for up to 9 arities and then on that one have a 10th vararg for scenarios were people truly do want/need more? that way it would only affect someone using beyond 9 args? || i dont quite get what you mean by """"a 10th vararg for scenarios"""" but id also be fine with overloads for up to 9 arguments plus another overload which takes only 1 argument of type `collection<observable<t>>` or `iterable<observable<t>>` so if people want more than 9 arguments they have to construct a list containing the arguments and pass this list to `concat` || i meant something like this ``` javaconcat(t t1 t t2) etc concat(t t1 t t2 t t3 t t4 t t5 t t6 t t7 t t8)concat(t t1 t t2 t t3 t t4 t t5 t t6 t t7 t t8 t t9)concat(t t1 t t2 t t3 t t4 t t5 t t6 t t7 t t8 t t9 t rest)```i will start refactoring vararg method signature later today or tonight (us pacific time) unless someone else is already doing it if one of you already are tackling this please let me know here so we dont replicate effort || closing as i have removed all varargs from observable || the `@safevarargs` annotation allows us to solve this trying to figure out if we can leverage this java 7 feature without breaking android support (which is obviously more important) || "";1;0;1x: added single execution hooks1x: enabled single onsubscribestart hook1x: added more single hooks unit tests;"
3701;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: add completable.dooncompleted and deprecate completable.dooncomplete;closes #3700.;;3700.0;1x: add completabledooncompleted and deprecate completabledooncomplete;closes #3700;wait what? i thought you wanted to add `completabledooncompleted()` i see no reason to change the established naming of `observabledooncompleted()` in fact for consistency id rather prefer adding `completabledooncompleted` || that makes sense the only reason i did it this way is because on the 2x branch both [observable]( and [completable]( use `dooncomplete()` || yes those follow the reactive-streams convention and completable started out as a 2x addition in the meantime ill fix that test failure || changed `completable` instead updated tests to match ||  @zach-klippenstein thanks! just updated the title  ;make observabledooncompleted name match completabledooncomplete in 1x;`observable` has a `dooncompleted` method (past tense) and `completable` has `dooncomplete` (present tense) the 2x branch changes `observable`s method to be present tense the 1x branch can add alias the past tense method in `observable` and deprecate itim happy to make the change if this is approved;sure ||;1;0;1x: alias observabledooncompleted to match completable and 2xcloses #3700;
3707;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: make completable.subscribe() report isunsubscribed consistently;the empty and lambda-based  completable.subscribe()  returns a  subscription  whose  isunsubscribed  should be consistent with the rest of the reactive objects by returning true if the sequence terminated (not just when one truly cancelled it).;;0;1x: make completablesubscribe() report isunsubscribed consistently;the empty and lambda-based `completablesubscribe()` returns a `subscription` whose `isunsubscribed` should be consistent with the rest of the reactive objects by returning true if the sequence terminated (not just when one truly cancelled it);updated || i see ;;;;1;1;1x: make completablesubscribe() report isunsubscribed consistently;
"3712;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;add takeuntil support in single;as discussed in #3708  this adds  takeuntil(observable)  and  takeuntil(single)  support in  single . it was mostly just adapting the logic from the existing  operatortakeuntil  and adjusting it for accepting a  single  and sending a  cancelattionexception  in the event of a submission from  other  prior to a terminal event in the source  single .  any feedback is appreciated it  this is my first time contributing an implementation to this project. particularly wondering if it s worth keeping both overloads or if the user should just coerce their  other  to one type or ther other. also particularly looking for feedback on what information to include in the  cancellationexception .;;3708.0;add takeuntil support in single;as discussed in #3708this adds `takeuntil(observable)` and `takeuntil(single)` support in `single` it was mostly just adapting the logic from the existing `operatortakeuntil` and adjusting it for accepting a `single` and sending a `cancelattionexception` in the event of a submission from `other` prior to a terminal event in the source `single`any feedback is appreciated it this is my first time contributing an implementation to this project particularly wondering if its worth keeping both overloads or if the user should just coerce their `other` to one type or ther other also particularly looking for feedback on what information to include in the `cancellationexception`;""just noticed my ide swapped the wildcard imports for explicit ones let me know if i should revert that || yes please || just style issues otherwise lgtm  cc @akarnokd @artem-zinnatullin for the tests most of them are adapted from `operatortakeuntiltest`  it looks like these tests have two different styles (one with `testobservable` and the other with `subject`) i reused both of them here but would we maybe want to stick with one or the other? especially with single i think some now overlapalso if we stick with one style here should we update the style in `operatortakeuntiltest` as well to match?  || im not too keen on how the tests are named or what test framework objects you useplease squash your commits || squashed ||  @zsxwing @stevegury any input? need another collaborator reviewmain points im wondering about:- should we only support one overload? if we support more than one should it support all three (including `completable`?)- should `takeuntil` test styles formalized looks like there are two styles right now judging  operatortakeuntiltest`: subject-based and `testobservable`-based || :+1: yes i think it makes sense to had an override for `completable`regarding test styles i dont think its a big deal the best thing to do slowly convert all the tests to the new convention (ideally in separated commits that dont change the behavior) || > sending a cancelattionexception in the event of a submission from other prior to a terminal event in the source singlethis behavior is really confusing why not be same as observable? am i missing anything? || @akarnokd and i discussed it in #3708 `single` currently emits a `nosuchelementexception` if the stream is terminated prior to any event emission by signaling a `cancellationexception` we can at least signal to the subscriber if the error was due to `takeuntil` unsubscribing it or normal missing emissions || @hzsweers thanks for clarifying however i would expect `singletakeuntil` returns something that contains 0 or 1 item how about returning observable instead? then the semantics of `singletakeuntil` is `onnext{0 1} (oncompleted | onerror)` which is consistent with `observabletakeuntil` (`onnext{0 n} (oncompleted | onerror)`) || the operators should stay in the same type as long as they can and there are operators that simply cant behave the same as their counterpart in other reactive types if one wishes the `observabletakeuntil` behavior one can use toobservable()takeuntil() and get that behavior || > the operators should stay in the same type as long as they can and there are operators that simply cant behave the same as their counterpart in other reactive types if one wishes the observabletakeuntil behavior one can use toobservable()takeuntil() and get that behaviorif so i vote for `nosuchelementexception` as `cancellationexception` seems counterintuitive to me `cancellationexception` looks some codes cancel single (eg i call `unsubscribe` in some place) but here the error is that `singletakeuntil` returns something that is not `single` hence i would expect `nosuchelementexception` || thats fair but is there something we could do to at least indicate whether the source was just unsubscribed or actually misbehaved? i was of the impression that `onerror` was primarily for serious unexpected errors whereas this seems like not unexpected or seriousconsider the followingwith `nosuchelementexception`:``` javapublishsubject<integer> source  publishsubjectcreate()publishsubject<integer> until  publishsubjectcreate()sourcetake(1)tosingle()        takeuntil(untiltake(1)tosingle())        subscribe(                new action1<integer>() {                    @override                    public void call(integer integer) {                        systemoutprintln(""""success"""")                    }                }                new action1<throwable>() {                    @override                    public void call(throwable throwable) {                        systemoutprintln(""""i dont know if it was due to unsubscribing or the source is misbehaving"""")                    }                })untilonnext(1)```vs with `cancellationexception```` javapublishsubject<integer> source  publishsubjectcreate()publishsubject<integer> until  publishsubjectcreate()sourcetake(1)tosingle()        takeuntil(untiltake(1)tosingle())        subscribe(                new action1<integer>() {                    @override                    public void call(integer integer) {                        systemoutprintln(""""success"""")                    }                }                new action1<throwable>() {                    @override                    public void call(throwable throwable) {                        if (throwable instanceof cancellationexception) {                            systemoutprintln(""""it was canceled"""")                        } else {                            systemoutprintln(""""source didnt emit"""")                        }                    }                })untilonnext(1)```the example i gave in the issue is probably the best example for me we use something similar to this for lifecycle binding in android when the lifecycle ends it might unsubscribe this in the middle for a normal error we might show a generic """"an error occurred"""" message in the event that its just the lifecycle ending we dont want to react that way and rather likely just want to do nothing at all or clean up resources im fine with not using `cancellationexception` but i think it would be useful to add a means of being able to differentiate between unsubscription reasons i thought about just specifying a message but felt that @akarnokds `cancellationexception` suggestion made it more clear || ill add an overload for `completable` as well and remove the old test style in the new tests here for now @stevegury just to be clear the """"new"""" style would be the `subject`-based approach right? || @hzsweers i actually typed """"its a big deal"""" but i was willing to say """"its **not** a big deal"""" (i corrected my previous comment) i prefer the subject based approach but i am not strongly opinionated about thati still :+1: on the current implementation || > thats fair but is there something we could do to at least indicate whether the source was just unsubscribed or actually misbehaved?my point here is if singletakeuntil() returns a single that emits nothing it should be `misbehaved` rather than `unsubscribed` || i think """"cancellationexception"""" is the clearer reaction here remember the problems around the observablesingle() and how it is a source of problem to find out exactly who didnt signal? here you know that if takeuntil is tripped and not some upstream machinery ends up being empty || > i think """"cancellationexception"""" is the clearer reaction here remember the problems around the observablesingle() and how it is a source of problem to find out exactly who didnt signal? here you know that if takeuntil is tripped and not some upstream machinery ends up being emptywhat if we want to add other operator that may return something doesnt signal? if it also emits `cancellationexception` then we still cannot find out exactly who didnt signal so why not use `nosuchelementexception` to indicate all cases that didnt signal? || what about a subclass of `nosuchelementexception`? a `cancelednosuchelementexception` so to speak wouldnt break the downstream apis but still allows for the subscriber to differentiate || > what about a subclass of nosuchelementexception? a cancelednosuchelementexception so to speak wouldnt break the downstream apis but still allows for the subscriber to differentiatemaybe a more general question should we add special exceptions for different operators or we just use a general exception to indicate the same error? || i think people should be aware of the implications of operators they use would `compositeexception` possibly be precedent for this? || > i think people should be aware of the implications of operators they use would compositeexception possibly be precedent for this?compositeexception is fine and clear it indicates there are multiple errors thrown all classes in rxexceptions are well defined and its very easy to connect them with the bad cases i can just read the exception name and tell what my codes violate but for `cancellationexception` its hard to connect it with `takeuntil` especially people use some library that calls `takeuntil` internally in addition imo if i see `cancellationexception` my first thought is `futurecancel` is called somewhereif we can define clearly that when should throw cancellationexception/cancelednosuchelementexception(or whatever you propose) when should throw nosuchelementexception i wont be against that for now the confusing thing for me is that if a single doesnt signal i may receive cancellationexception or nosuchelementexception || im fine with either i think we could be clear in the documentation and subclassing would still allow downstream subscribers to treat it as a `nosuchelementexception` @akarnokd @stevegury thoughts? || added `takeuntil(completable)` support and standardized tests updated with a separate commit for easier reviewing let me know if you want me to squash againping @akarnokd @stevegury ||   "";single and completable takeuntil();in reading the original pr for `single` i saw ben was ok with adding a `takeuntil(single/observable)` operator for `single` later i was wondering if this was still the plan and if you would be open to contributions on this front same with `completable`one caveat that ive thought of is that theres a potentially conflicting contact with `single` and `takeuntil()` in the sense that `takeuntil()` calls `oncompleted()` in observables but `single`s will actually go to `onerror()` if `oncompleted()` is called before any events are emitted (and by extension `onsuccess()`) not sure what the clear path would be but it seems like `single`s would have to only unsubscribe and not propagate any notifications differing from `observable`s and likely `completable`s in this regard;`singletakeuntil` still has to emit an onsuccess or onerror you need to emit a `nosuchelementexception` from the other `singleonsuccess` unsubscribing the main and not emitting anything is bad because it keeps the subscribers hanging i dont think it is worth it`completabletakeuntil` is just `completableambwith(other)` || the completable makes sense for `single` do you think theres a feasible way to do a sort of takeuntil-like behavior where it completes/unsubscribes on the emission of another observable/single? im working on some lifecycle handling for android and a use case thats worked well in the past is to emit lifecycle events via behaviorsubject and then just `takeuntil(lifecyclesubjectfilter(e -> e  detach))` the idea is you want it to unsubscribe when the detach happens and perhaps out of convenience weve always been using the fact that takeuntil would call oncomplete and eventually cause it to unsubscribe  || it seems like forcing an onsuccess or onerror defeats the purpose of having a subscription that supports `unsubscribe` prior to that || the best you can do with `takeuntil` is to signal an error like `cancellationexception` similar to how `future` does || i see would that be something you guys would be open to as pr? or at least consider making `single#lift()` public since its still experimental? otherwise it doesnt seem like its possible in the current api could catch existing `nosuchelementexception`s but thered be no way to know if it was due to completion or cancellation alternatively would there be a simple way to potentially swallow that error upstream rather than force the subscriber to handle it? || we are open for prs || closing via #3712 || actually this just reminded me would we want `single` and `observable` overloads for `completable` or just use `amb` and call `tocompletable` on those when passing them in? || maybe submit a pr and lets see the opinions || will do though likely not until this weekend or next week ||;1;0;add takeuntil(completable) support and standardize tests;"
3714;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: add maxconcurrent parameter to concatmapeager;relevant issue #3710;;3710.0;1x: add maxconcurrent parameter to concatmapeager;relevant issue #3710;will you update this pr? || yes on it ! || i submitted a commit with your proposed changes sorry for the delay feel free to give me more comments/changes also i can squash if needed || :+1:dont squash this time github has now a new feature for the merge button where it offers squashing id like to test if it really squashes everything and the main just gets 1 commit || nothing critical :+1: // @akarnokd squashing on github works and it works especially great when author of the pr just commits on top of previous commits because github now remembers what code youve checked and what not and you can continue reviewing from previous point (doesnt work for me when pr is always squashed) || i have updated the pr do pr commits trigger github notifications ? (should i comment after i do an update ? ) || unfortunately no notification || ;concatmapeager and maxconcurrent;how should i limit the maximum number of concurrently subscribed observables ?i think a parameter like the one in flatmap (maxconcurrent) could be very usefulconcatmapeage currently has an optional parameter capacityhinti think this is not very useful i expected to find something like maxconcurrentthis operator might be confusing for some people similar with #3498;the operator was designed to be eager on the input side and bounded on the mapped inner observablesi agree that adding a parameter would be confusing to `concatmapeager` but you can name the maxconcurrent+capacityhint version like `orderedmerge` or something like itwould you like to post a pr for this? || are you proposing to rename`concatmapeager(func1 mapper int capacityhint)` into `orderedmerge` ?i am proposing to add extra functionality to manage the number of concurrent observables and change the docs/rename some operators to make the functionality more obviousi can try to provide a pr || dont rename `concatmapeager` just add an overload `concatmapeager(func1 mapper int capacityhint int maxconcurrency)` and modify the `operatorconcatmapeager` to support the maxconcurrency mode || i am not sure how to write a proper test case for this change i tested various scenarios manually and ran the existing test case || add a `doonrequested` before the operator and capture the long values in a list then compare it against the expected pattern ie `5 1 1 1 1 1 1` || closing via #3714 ||;1;0;add test case and cleanup whitespace;
3718;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;new method concatmapiterable #3713;new method concatmapiterable #3713;;0;new method concatmapiterable #3713;new method concatmapiterable #3713;thanks @ginbalin for the addition could you also add a test please? || added a simple test is this enough? ||  please squash your commits || done || ;;;;1;1;add concatmapiterable;
3719;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;documentation fix.;;;0;documentation fix;;  ;;;;1;1;documentation fix;
3720;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: add vararg of subscriptions to compositesubscription.;;;0;1x: add vararg of subscriptions to compositesubscription;;could you make sure you dont have that many space changes? || sure i will fix it || i have  formatting not to add indents on empty lines || - squash your commit when youre done || please rebase and squash || this pr is a bit old im :+1: with the api change but the test worries me tooim merging this and will post a pr that hardens that test (+ renames them for @artem-zinnatullin sake :) ||;;;;1;1;add vararg of subscriptions to composite subscription;
3722;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add maxconcurrent parameter to flatmapiterable;refs #3711. should these new overloaded functions be annotated with  @beta ?;;3711.0;add maxconcurrent parameter to flatmapiterable;refs #3711 should these new overloaded functions be annotated with `@beta`?;the failing test (`testnomorerequestsafterunsubscribe`) seems unrelated all tests pass locally || if you could add one unit test for each method that verifies maxconcurrent is honored that would be great || while writing the test i figured you might have been right when commenting on issue #2627 if i am not mistaken all the observables created with `operatormappairconvertselector` use the same scheduler (there is no way to subscribe them to different schedulers) and thus are run sequentially and until completion would adding a scheduler parameter make sense? || there is no scheduler involved here so no || :+1: as it is now || ;flatmapiterable with maxconcurrent;as far as i saw flatmapiterable doesnt have maxconcurrent parameter and thus doesnt offer a way to apply backpressure in order to align it with other flatmap would be good to add an overload with maxconcurrentwhat do you think?;pr is welcome || although you stated here that this was useless   is it really the case?i believe with current implementation this would be usefull to control backpressure  || i was wrong back then || closing via #3722 ||;1;0;add maxconcurrent overload to flatmapiterable;
3733;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;avoid swallowing errors in completable;instead  deliver them up to the thread s uncaught exception handler.  fixes reactivex/rxjava#3726;;372.0;avoid swallowing errors in completable;instead deliver them up to the threads uncaught exception handlerfixes reactivex/rxjava#3726;what happened to `completabletest`? || @akarnokd sorry ij formatted it  will clean up and push again ||  just a nit about `timeout` in tests otherwise  removed timeouts || ;zip/map/select with index;im looking for a function corresponding to this rx c# function: we already have this in rxjava? im asking this because i want to implement the `zipwithindex` function in the scala adaptor;no we do not have that yet your naming convention will be what we need to use so we dont overload methods with functions of different arities as that causes issuesso `mapwithindex` and `zipwithindex` make sense || id be happy with `mapwithindex` and `zipwithindex` || i dont think we have the arity problem with `map` (`mapwithindex`) or do we? i think it should be specific to `zip` so we could name it `map` instead of `mapwithindex` if we wanted to but probably we should be consistent and still call it `mapwithindex` || i take that back i just experimented with this and noticed that at least clojure does indeed have a problem with that so `mapwithindex` it is ||;1;0;avoid swallowing errors in completableinstead deliver them up to the threads uncaught exception handlerfixes reactivex/rxjava#3726;
3738;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;creating observable#create overloads for synconsubscribe and asynconsubscribe;this is to facilitate the discovery of methods for creating observables that respect back pressure semantics. currently the  observable#create(onsubscribe)  static method is the easiest method to discover for creating an observable which does not provide clear facilities for managing back pressure.;;0;creating observable#create overloads for synconsubscribe and asynconsubscribe;this is to facilitate the discovery of methods for creating observables that respect back pressure semantics currently the `observable#create(onsubscribe)` static method is the easiest method to discover for creating an observable which does not provide clear facilities for managing back pressure;i like this addition it makes it far more discoverable to do create in a safer way +1 || im worried that having the same name will cause method resolution problems with other not so strict jvm languages || looks good @abersnaze whats an example? || sure these two methods point to the classes but id prefer those `createstateful` and such methods added to `observable` instead || @akarnokd so you would prefer to have the static create methods explicitly listed out? this is how that would look when in an ide (ie in eclipse with `observablecreate` then hitting ctrl+space)one static method per concrete option:``` javacreate(onsubscribe<t> f)createasyncsinglestate(func0<? extends s> generator action3<? super s long ? super observer<observable<? extends t>>> next)createasyncsinglestate(func0<? extends s> generator action3<? super s long ? super observer<observable<? extends t>>> next final action1<? super s> onunsubscribe)createasyncstateful(func0<? extends s> generator func3<? super s long ? super observer<observable<? extends t>> ? extends s> next action1<? super s> onunsubscribe)createasyncstateless(action2<long ? super observer<observable<? extends t>>> next)createasyncstateless(action2<long ? super observer<observable<? extends t>>> next action0 onunsubscribe)createsyncsinglestate(func0<? extends s> generator action2<? super s ? super observer<? super t>> next)createsyncsinglestate(func0<? extends s> generator action2<? super s ? super observer<? super t>> next action1<? super s> onunsubscribe)createsyncstateful(func0<? extends s> generator func2<? super s ? super observer<? super t> ? extends s> next action1<? super s> onunsubscribe)createsyncstateful(func0<? extends s> generator func2<? super s ? super observer<? super t> ? extends s> next)createsyncstateless(action1<? super observer<? super t>> next)createsyncstateless(action1<? super observer<? super t>> next action0 onunsubscribe)```one overload per highlevel category (sync async)``` javacreate(onsubscribe<t> f)create(synconsubscribe<s t> synconsubscribe)create(asynconsubscribe<s t> asynconsubscribe)```this isnt exactly a direct apples-to-apples representation as youd have to use the `synconsubscribe` static methods eg``` javacreate(synconsubscribecreatestateless(action1<? super observer<? super t>> next))```i think i prefer the latter because the surface area of the observable is constrained to two (three-ish) high level categories of creation options  || ive added more explanation to the javadoc  || i prefer current version (with overload per high-level category) the test seems to be a flaky unit test ```rxobservabletests > testerrorthrownissue1685 failed    javalangassertionerror: uncaughtexceptionhandler didnt get anything        at orgjunitassertfail(assertjava:93)        at orgjunitassertasserttrue(assertjava:43)        at orgjunitassertassertnotnull(assertjava:526)        at rxobservableteststesterrorthrownissue1685(observabletestsjava:1113)```i have added `@experimental` to these overloads (to mirror the status of the underlying sync/async os) is this otherwise an acceptable api addition or are there concerns? @akarnokd @abersnaze  || travis sometimes seems to slow down drastically that 1 second wait in that test is like 1000x more than usually needed to verify the behavior just rerun the test in this casewe can start with your two methods and add the rest later || i would prefer not to have both styles personally as redundancy makes for a cluttered and confusing api is it a personal preference for listing all variants?   || only the sync ones the async ones can be hidden behind that create overload || im fine discussing that when the time comes  || @davidmoten i cant remember the exact instances of the issue but im not as familiar with scala clojure groovy or kotlin  i did a simple test in groovy that worked just because i had a repl handy  it would be nice have a lowest common denominator for method signatures so we dont make it unnecessarily difficult in any of those languages || kotlin handles the overloads fine :+1:on thu mar 3 2016 at 7:26 pm george campbell notifications@githubcomwrote:> @davidmoten  i cant remember the exact> instances of the issue but im not as familiar with scala clojure groovy> or kotlin i did a simple test in groovy that worked just because i had a> repl handy it would be nice have a lowest common denominator for method> signatures so we dont make it unnecessarily difficult in any of those> languages> > > reply to this email directly or view it on github>  ||;;;;1;1;creating observable#create overloads for synconsubscribe and asynconsubscribe;
3741;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;add doonsubscribe for single;ref #3740.  i didn t write much unit tests for  doonsubscribe  because it internally uses  operatordoonsubscribe  which is well covered.;;3740.0;add doonsubscribe for single;ref #3740i didnt write much unit tests for `doonsubscribe` because it internally uses `operatordoonsubscribe` which is well covered;   thanks @aaronhe42!  ||;single#doonsubscribe is missing;just noticed that we have a `singledoonunsubscribe()` but not `singledoonsubscribe()` in rxjava 111;closing via #3741 ||;1;0;add doonsubscribe for single;
3752;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: single.using();this pr adds the factory method  using()  +1 overload to  single  as requested in #3732.  for convenience  i ve also added  single.subscribe(observer) .;;3732.0;1x: singleusing();this pr adds the factory method `using()` +1 overload to `single` as requested in #3732for convenience ive also added `singlesubscribe(observer)`; lgtm;request: singleusing;to match `observableusing````public static <t resource> single<t> using(        func0<resource> resourcefactory        func1<? super resource ? extends single<? extends t>> singlefactory        action1<? super resource> disposeaction)```and```public static <t resource> single<t> using(        func0<resource> resourcefactory        func1<? super resource ? extends single<? extends t>> singlefactory        action1<? super resource> disposeaction boolean disposeeagerly)```;ill do this || see #3752 || pr was merged and released as part of v112 this issue can be closed! || closing via #3752 ||;1;0;1x: singleusing();
3753;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: fix serializedobservertest.testnotificationdelay;this pr fixes the  serializedobservertest.testnotificationdelay  test to use reentrancy to verify the buffer in  serializedobserver  is properly drained. for now  it loops 10 000 times to see if the ci brings up the issue again. takes 400ms on my machine but i ll probably reduce it to 1 000 times.  (the previous version was a bit convoluted with all those countdowns that didn t properly lock out the other thread).  reported in issue #1389;;0;1x: fix serializedobservertesttestnotificationdelay;this pr fixes the `serializedobservertesttestnotificationdelay` test to use reentrancy to verify the buffer in `serializedobserver` is properly drained for now it loops 10000 times to see if the ci brings up the issue again takes 400ms on my machine but ill probably reduce it to 1000 times(the previous version was a bit convoluted with all those countdowns that didnt properly lock out the other thread)reported in issue #1389;:+1: // took me awhile to understand what are you doing in the test || ;;;;1;1;1x: fix serializedobservertesttestnotificationdelay;
"3756;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: clarify join/groupjoin no ordering guarantees;original issue: #3616.;;3616.0;1x: clarify join/groupjoin no ordering guarantees;original issue: #3616;  ;join operator incorrect sequence;""i found a weird bug where join operator is emitting incorrect sequence in **some** android devices here is the block of code that i am using:```observablejust(""""a"""" """"b"""")        join(observablejust(1)                new func1<string observable<object>>() {                    @override                    public observable<object> call(string s) {                        return observablenever()                    }                } new func1<integer observable<object>>() {                    @override                    public observable<object> call(integer integer) {                        return observablenever()                    }                } new func2<string integer string>() {                    @override                    public string call(string s integer integer) {                        return s + """" """" + integer                    }                })        subscribe(new action1<string>() {            @override            public void call(string s) {                systemoutprintln(s)            }        })```expected sequence:```a1b1```incorrect sequence:```b1a1```after digging in `rxinternaloperatorsonsubscribejoin` class i found this:```final class resultsink {        final compositesubscription group        final subscriber<? super r> subscriber        final object guard  new object()        /** guarded by guard */        boolean leftdone        /** guarded by guard */        int leftid        /** guarded by guard */        final map<integer tleft> leftmap        /** guarded by guard */        boolean rightdone        /** guarded by guard */        int rightid        /** guarded by guard */        final map<integer tright> rightmap        public resultsink(subscriber<? super r> subscriber) {            thissubscriber  subscriber            thisgroup  new compositesubscription()            thisleftmap  new hashmap<integer tleft>()            thisrightmap  new hashmap<integer tright>()        }        }```i suspect the cause is because its using `hashmap` to store left and right emitted values causing incorrect order in the values since `hashmap` cannot guarantee the order of the entries it should uses `linkedhashmap` to maintain the order of the entriesany thoughts? or did i miss something here? thanks!"";there was never a guaranteed order and even net has  no guarantees not to mention the two platform produce in different order from the beginning || by looking at the marble diagram i thought that the order is guaranteed i think it should be stated in the javadoc to avoid confusion for anyone else anyway thanks for the heads up @akarnokd! || see #3756 || great! thanks @akarnokd  closing via #3756 ||;1;0;1x: clarify join/groupjoin no ordering guarantees;"
3759;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: concatmap full rewrite + delayerror + performance;this is a full rewrite of the  concat / concatmap  operator with the following properties: - using  onsubscribe  to save on the allocation of  lift  -  concatdelayerror  and  concatmapdelayerror  to delay errors to the very end - new trampolining logic that also subscribes to the next source even if requested is zero - using  concatmap  or  concatmapdelayerror  on a scalar source now bypasses the operator completely and uses  scalarsynchronousobservable.scalarflatmap  as well. - the operator now detects  just  and  empty  sources and bypasses subscribing accordingly - added  exceptionsutils  to work with composite exceptions and terminal state  useful for other similar delaying operators later on. -  concat  is now implemented as  concatmap(v -> v)  which saves on the allocation of an entire  map  operator -  operatorwindowwithsizetest.testbackpressureouterinexact  had to be ignored because  window  doesn t honor backpressure properly and it is fixed in #3678  once it has been resolved  the test can be reenabled - added varargs constructor to  compositeexception  for convenience  avoids creating a list when the number of initial exceptions are known upfront.  performance comparison to baseline (i7 4770k  windows 7 x64  java 8u72):  (https://cloud.ent.com/assets/1269832/13744915/603866a8-e9eb-11e5-8711-8feb24fbb872.png);;0;1x: concatmap full rewrite + delayerror + performance;this is a full rewrite of the `concat`/`concatmap` operator with the following properties:- using `onsubscribe` to save on the allocation of `lift`- `concatdelayerror` and `concatmapdelayerror` to delay errors to the very end- new trampolining logic that also subscribes to the next source even if requested is zero- using `concatmap` or `concatmapdelayerror` on a scalar source now bypasses the operator completely and uses `scalarsynchronousobservablescalarflatmap` as well- the operator now detects `just` and `empty` sources and bypasses subscribing accordingly- added `exceptionsutils` to work with composite exceptions and terminal state useful for other similar delaying operators later on- `concat` is now implemented as `concatmap(v -> v)` which saves on the allocation of an entire `map` operator- `operatorwindowwithsizetesttestbackpressureouterinexact` had to be ignored because `window` doesnt honor backpressure properly and it is  in #3678 once it has been resolved the test can be reenabled- added varargs constructor to `compositeexception` for convenience avoids creating a list when the number of initial exceptions are known upfrontperformance comparison to baseline (i7 4770k windows 7 x64 java 8u72):(https://cloudentcom/assets/1269832/13744915/603866a8-e9eb-11e5-8711-8feb24fbb872png);this is the benchmark comparison against rsc:( || lgtm ;;;;1;1;1x: concatmap full rewrite + delayerror + performance;
3760;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: fix executorscheduler and genericscheduledexecutorservice reorder bug;this pr relates to the failure of  errorthrownissue1685 .  the underlying problem was with the  genericscheduledexecutorservice . by being multi-threaded  tasks scheduled from the same thread one after the other may get reordered because different worker threads inside the pool could pick them up at the same time. in this case  there is no guarantee they keep their fifo order.  _(i currently have no idea how one can use trampolining for this case  subsequent tasks may have any relative delays in respect to each other.)_  the solution creates n single threaded  scheduledexecutorservice s and getinstance() hands one of them out. in turn  executorservice  takes one in its worker upfront.  however  there is still the problem when the programmer uses a multi-threaded  scheduledexecutorservice  with  schedulers.from()  when the same issue comes back. a solution to that problem would be to always use the new  genericscheduledexecutorservice  for delaying timed tasks.;;0;1x: fix executorscheduler and genericscheduledexecutorservice reorder bug;this pr relates to the failure of `errorthrownissue1685`the underlying problem was with the `genericscheduledexecutorservice` by being multi-threaded tasks scheduled from the same thread one after the other may get reordered because different worker threads inside the pool could pick them up at the same time in this case there is no guarantee they keep their fifo order_(i currently have no idea how one can use trampolining for this case subsequent tasks may have any relative delays in respect to each other)_the solution creates n single threaded `scheduledexecutorservice`s and getinstance() hands one of them out in turn `executorservice` takes one in its worker upfronthowever there is still the problem when the programmer uses a multi-threaded `scheduledexecutorservice` with `schedulersfrom()` when the same issue comes back a solution to that problem would be to always use the new `genericscheduledexecutorservice` for delaying timed tasks;i have trouble understanding how this solve the problem could you please elaborate?the only thing i see that we could do to force the fifo order is to cap the thread number to 1 right? || yes executorschedulers worker needs a helper scheduledexecutorservice with a single thread only but we dont want all executorschedulers to wait in a single thread for their time to run this change similar to how computation scheduler works hands out single hreaded scheduledexecutorservices on demand || nice catch> however there is still the problem when the programmer uses a multi-threaded scheduledexecutorservice with schedulersfrom() when the same issue comes back a solution to that problem would be to always use the new genericscheduledexecutorservice for delaying timed tasksi vote for `always use the new genericscheduledexecutorservice for delaying timed tasks` correctness is more important than performance moreover when people use `schedule(action time)` they usually dont want the codes to run as fast as possible so the performance lost doesnt really matter || agree with @zsxwing that correctness is more important than performance || right ill fix them shortly || updated ||  ;;;;1;1;1x: fix executorscheduler and genericscheduledexecutorservice reorderbug;
3762;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: deprecate compositeexception constructor with message prefix;before this pr messageprefix was never used :dancer:   if you guys want i can revert the change on compositeexceptiontest.java:177. i just thought that way it  be nicer.  about the message is there any reason for having a space after the dot?;;0;1x: deprecate compositeexception constructor with message prefix;before this pr messageprefix was never used   if you guys want i can revert the change on compositeexceptiontestjava:177 i just thought that way it be nicerabout the message is there any reason for having a space after the dot?;we dont really use that constructor or the message so id prefer removing it altogether || yeah i also realized that later since no test broke after that change so do you want me to remove it? || yes but dont rush it as there is another much heavier pr #3759 that also changed this class || alright just ping me once #3759 is in || @akarnokd i updated the pr again and changed the commit message and the title i hope the changes are okay now if the removal of whitespace bugs you just let me know || yes please revert those space changes (are you using intellij?) || those changes i did in sublime and i set it up in a way that it should remove trailing whitespace )also updated the pr and removed the spaces || almost but forgot that its a public api component thus cant just remove the constructors could you instead deprecate `compositeexception(string message list<throwable> errors)`? || @akarnokd like this? || yes  ;;;;1;1;deprecate compositeexception constructor with message prefix;
3763;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: combinelatestdelayerror;this pr exposes the  delayerror  option in  combinelatest  as  combinelatestdelayerror .  (note that we have convenience overloads with 2-9 sources that could also use an overload  but that just expands the api surface drastically.);;0;1x: combinelatestdelayerror;this pr exposes the `delayerror` option in `combinelatest` as `combinelatestdelayerror`(note that we have convenience overloads with 2-9 sources that could also use an overload but that just expands the api surface drastically);:+1: (im starting feeling bad for guy who asked for map with indexes since his request we added so many overloads of other operators) ||  ;;;;1;1;1x: combinelatestdelayerror;
3765;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: switchonnextdelayerror and switchmapdelayerror;this pr adds a delayerror version to the  switchonnext  /  switchmap  operators.;;0;1x: switchonnextdelayerror and switchmapdelayerror;this pr adds a delayerror version to the `switchonnext` / `switchmap` operators;lgm ;;;;1;1;1x: switchonnextdelayerror and switchmapdelayerror;
3766;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: add single.onerrorresumenext(func);closes #3440  closes #3731  closes #3472 (whoa  3 issues at a time!);;3440.0;1x: add singleonerrorresumenext(func);closes #3440 closes #3731 closes #3472 (whoa 3 issues at a time!);@akarnokd  your comments btw should i add `@experimental` to these operators? || yes and copy over the experimental and since tags into the javadoc || :+1: there is this new like option but do you get a notification for them? || noon mon mar 14 2016 8:10 pm david karnok notifications@githubcom wrote:> [image: :+1:] there is this new like option but do you get a notification> for them?> > > you are receiving this because you are subscribed to this thread> > reply to this email directly or view it on github:>  ||  ;singleonerrorresumenext;observable has a onerrorresumenext to continue with a new observable if onerror is called id like something similar for single so:``` javasingle<t> onerrorresumenext(single<? extends t> resumesingle)single<t> onerrorresumenext(func1<? super throwable ? extends single<? extends t>> resumefunction)```single already has onerrorreturn it makes sense to have onerrorresumenext as well;related:  || ill work on this || @akarnokd i can do it in 2 ways: 1 convert `single` to `observable` and `lift` already implemented and tested `operatoronerrorresumenextviafunction` and `operatoronerrorresumenextviaobservable`2 re-implement these operators for `single` it may give some performance boost but adds two classes to the libraryi guess youll vote for 2nd way but i think it worth to ask :) || frankly im not satisfied with 1x single and how it tries to reuse observable components it leads to wrappers and un-wrappers and so on even for the trivial operators if they were `retrywhen` then id say convert back and forth like i do with 2x so yes i vote for option 2 || ok no problem :) ||;1;0;1x: add singleonerrorresumenext(func);
"3766;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: add single.onerrorresumenext(func);closes #3440  closes #3731  closes #3472 (whoa  3 issues at a time!);;3472.0;1x: add singleonerrorresumenext(func);closes #3440 closes #3731 closes #3472 (whoa 3 issues at a time!);@akarnokd  your comments btw should i add `@experimental` to these operators? || yes and copy over the experimental and since tags into the javadoc || :+1: there is this new like option but do you get a notification for them? || noon mon mar 14 2016 8:10 pm david karnok notifications@githubcom wrote:> [image: :+1:] there is this new like option but do you get a notification> for them?> > > you are receiving this because you are subscribed to this thread> > reply to this email directly or view it on github:>  ||  ;flatmap single into observable and ignore errors;i have ui observable which should work as long as my ui lives when my ui emits i create a network request which could be an observable or a single a single fits best for a network call``` javarxviewclicks(mybutton)    flatmap(v - > networkrequest())    subscribe(data -> showsomething(data)            e -> {                // should only be called when the rxviewclicks() throws                 // should not be called for network errors            })```when using an observable i would use `onerrorresumenext` returning `observableempty()` to prevent errors coming from the network request going into my ui observable and calling `onerror` because the ui observable should life forever:``` javaobservable networkrequest() {    mapiservicefireactionobservable()        onerrorresumenext(throwable -> {            // somehow handle error here            return observableempty()     })}```this in my opinion elegant way does not work for single because no `singleempty()` exists``` javasingle networkrequest() {    mapiservicefireactionsingle()        onerrorresumenext(throwable -> {            // somehow handle error here            return singleempty() // <-- does not exist i have to call success or error :/     })}````singleonerrorresumenext` is btw only available in 2xconverting my `single` to an `observable` seems wrong because the network request is a `single`!;""`singleempty()` doesnt make sense because `single` has to emit either an `onsuccess` or an `onerror` the best you can do is to have a `singlejust()` with a normal value that represents emptinessgenerally this is why im skeptic about `single` and `completable` because `observable` can """"emulate"""" both and the overhead in true async use is negligible || my current solution wraps my singles:``` java    public static <t> observable<t> onerrorresumenext(final single<t> single            final observable<? extends t> resumesequence) {        return singletoobservable()onerrorresumenext(resumesequence)    }    public static <t> observable<t> onerrorresumenext(final single<t> single            final func1<throwable ? extends observable<? extends t>> resumefunction) {        return singletoobservable()onerrorresumenext(resumefunction)    }`````` javarxviewclicks(mybutton)    flatmap(v - > onerrorresumenext(networkrequest()            throwable -> {            // somehow handle error here            return observableempty()     }))    subscribe(data -> showsomething(data)            e -> {                // only called when the rxviewclicks() throws            })```@benjchristensen what happened to the [initial idea]( of heaving a `single` with 3 final states?> a single will always behave in one of 3 ways:> > 1) respond with an error> 2) never respond> 3) respond with a successi was hoping a `single` is a `observable` where i dont have to care about multiple items nothing more like `observable#single()` but with zero item support and type safetyness || @artem-zinnatullin im starting to loose what is implemented where do you work on `singleonerrorresumenext(func1)`? || @akarnokd damn will submit pr today/tomorrow! || my solution:rxviewclicks(mybutton)    flatmap(v - > networkrequest())    compose(exceptionhandling())    subscribe(data -> showsomething(data)            e -> {                // now you should remove this lambda as it will never be called            })final: rxviewclicks(mybutton)    flatmap(v - > networkrequest())    compose(exceptionhandling())    subscribe(data -> showsomething(data))exceptionhandling:   protected  <t> observabletransformer<t t> exceptionhandling() {        return observable ->                observable                        doonerror(t ->{ /* handle error here */})                        retry() // ignore error to keep subscription    } || "";1;0;1x: add singleonerrorresumenext(func);"
3766;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: add single.onerrorresumenext(func);closes #3440  closes #3731  closes #3472 (whoa  3 issues at a time!);;3731.0;1x: add singleonerrorresumenext(func);closes #3440 closes #3731 closes #3472 (whoa 3 issues at a time!);@akarnokd  your comments btw should i add `@experimental` to these operators? || yes and copy over the experimental and since tags into the javadoc || :+1: there is this new like option but do you get a notification for them? || noon mon mar 14 2016 8:10 pm david karnok notifications@githubcom wrote:> [image: :+1:] there is this new like option but do you get a notification> for them?> > > you are receiving this because you are subscribed to this thread> > reply to this email directly or view it on github:>  ||  ;request: singleonerrorresumenext(func1<? super throwable single<? extends t>> resumefunction);to match `observable`s```public single<v> onerrorresumenext(func1<? super throwable single<? extends t>> resumefunction)```;we are also interested in this feature currently we are in the process of switching `observable` to `single` where it makes sense not having this feature is blocking us since we would use this internally and not expose the details to users does anybody know a workaround for accessing the `throwable`? || since we are just interested in mapping the emitted exception to something else here is something that just occurred to me its ugly but it seems that it works as a temporary workaround in our use case it may be useful for others too so here it is:``` javasingleonerrorreturn(throwable -> {    throw mapexception(throwable)})```where `mapexception` maps the `throwable` to one of our exceptions || isnt this a dupe of #3440 ? || yes youre right its a duplicate ||;1;0;1x: add singleonerrorresumenext(func);
"3777;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;observeon: allow configurable buffer size;the observeon operator is backed by a small queue of 128 slots that may overflow quickly on slow producers.  this could only be avoided by adding a backpressure operator before the observeon (not only inconvenient  but also taking a perf. hit as it forces hops between two queues).  this patch allows modifying the default queue size on the observeon operator.  fixes: #3751 signed-off-by: galo navarro anglorvaroa@gmail.com;;3751.0;observeon: allow configurable buffer size;the observeon operator is backed by a small queue of 128 slots that mayoverflow quickly on slow producers  this could only be avoided byadding a backpressure operator before the observeon (not onlyinconvenient but also taking a perf hit as it forces hops between twoqueues)this patch allows modifying the default queue size on the observeonoperatorfixes: #3751signed-off-by: galo navarro anglorvaroa@gmailcom; :+1: though id leave old test for default buffer size and just add a new one  || rebased  the javadoc link and a spelling mistake@artem-zinnatullin i reused this one to avoid redundancy as the code path is virtually the same and there are tests (the ones referenced in the @link) which use the default size let me know if you still prefer the 2 cases and ill fix that || yeah i understand just afraid that one may change linked  tests and we wont cover overload // one day well setup code coverage i hope || agh thanks @akarnokd i didnt notice i changed computers so i was back on the 1st patch and lost the overload resubmitted based on the one with all overloads and added the extra test instead of rewriting it hopefully fine now ||  ive seen some failures on the test locally and there is also a bug in the test (the loop should start at 2 not 1) i cant look into it right now but will take a look asap ||  im merging this the changes are algorithmically solid so im not sure what failures you see locally || thanks @akarnokd the failure was no error notifications emitted at random sizes but i did notice travis didnt complain ping me if it surfaces ||;confusion when using backpressure operators;""heywe have a use case in which a consumer might not be able to process items fast enough than what is emitted from a source observable i understood that in this case a backpressure with either `onbackpressurebuffer()` or `onbackpressuredrop()` might be useful in case of overflow / drop we would like to store items to a local storage and try processing them later when the consumer in this case is again able to handle the input rate our consumer is actually a remote rest call which might timeout or not be available in which case we retryanyways i tried alternative ways to address the problem but i cant find a suitable way to solve it to illustrate my testings here is some code:```package ioreactiveximport orgjunittestimport rxobservableimport rxsubscriberimport rxschedulersschedulerspublic class backpressuretest {    @test    public void testonbackpressuredrop() throws interruptedexception {        observable<integer> emitter  toobservable()                subscribeon(schedulersnewthread())        emitteronbackpressuredrop(i -> systemoutprintln(""""dropped """" + i))                observeon(schedulerscomputation())                map(this::dowork)                doonnext(i -> systemoutprintln(""""output """" + i))                toblocking()                subscribe(new singleitemsubscriber<>())    }    @test    public void testonbackpressurebuffer() throws interruptedexception {        observable<integer> emitter  toobservable()                subscribeon(schedulersnewthread())        emitteronbackpressurebuffer(2 () -> systemoutprintln(""""overflow""""))                observeon(schedulerscomputation())                map(this::dowork)                doonnext(i -> systemoutprintln(""""output """" + i))                toblocking()                subscribe(i -> systemoutprintln(""""subscriber received """" + i))    }    private observable<integer> toobservable() {        return observablecreate(subscriber -> {            for (int i  0 i < 10 i++) {                systemoutprintln(""""emitting """" + i)                subscriberonnext(i)                try {                    threadsleep(250)                } catch (interruptedexception e) {                    subscriberonerror(e)                }            }            subscriberoncompleted()        })    }    private int dowork(int integer) {        systemoutprintln(""""consuming """" + integer)        try {            threadsleep(1000)        } catch (interruptedexception e) {            eprintstacktrace()        }        return integer    }    private static class singleitemsubscriber<t> extends subscriber<t> {        @override        public void onstart() {            request(1)        }        @override        public void oncompleted() {        }        @override        public void onerror(throwable e) {        }        @override        public void onnext(t t) {            systemoutprintln(""""subscriber received """" + t)            request(1)        }    }}```in `testonbackpressuredrop()` i would assume that after the `emitter` has queued some items it would start dropping them however it seems that the backpressure operation subscription gets a receive size of 128 items 128 items in memory in this case is far too much for us and we would like to control the size of the request itemsin `testonbackpressurebuffer()` i would assume that the `emitter` would overflow after emitting more than two items into the bufferhowever in neither of the cases i dont experience an oveflow or dropped items also i realized that when using `onbackpressurebuffer()` it seems that in overflow the observable emits `onerror()` to me that wouldnt be an option since i want the `emitter` to continue and i want to deal with the problem myselfcould you please instruct me that what we are missing here or are we trying to do something that is not yet even possible eg is the api missing an operator like `onbackpressurebufferanddrop(int capacity action1 ondrop)`?i wrote my tests based on the documentation in https://githubcom/reactivex/rxjava/wiki/backpressure"";""it seems your source doesnt emit enough values thus the default buffer of 128 elements in `observeon` can hold all of it without backpressure the `onbackpressurebuffer(int)` behavior is expected and is there to give room to bursty sources but fail on sustained backpressure to prompt the developer to reevaluate the flowthere is a [pr]( in limbo that tries to address this buffer behavior by allowing dropping but if you want to queue on disk you have to write a custom operator || ive bumped into the queueing on disk use case a few times but havent implemented anything ill have a look (probably in a couple of weeks) || i seethe challenge with the pr above is that currently the overflow function does not supply the item(s) which caused the overflow it is just a void action (`action0`) changing that to eg `action1` would probably break the semantics of the original `onbackpressurebuffer()` api so i guess the naming would need to be reconsidered for a new api if it would accept a `action1` type functionbased on @akarnokds comment we should not use the buffer backpressure but ideally it seems that the current implementation of `onbackpressuredrop(action1<? super t> ondrop)` is close what im after here but i would need to be able to control the size of the default internal buffer (128 now) we can write a custom operator of course but i was just wondering would this be something other may benefit if part of the `observable` api? when using the current implementation of drop you have very little control when the dropping starts to happen and in our case we can calculate a value for the buffer based on the characteristics and configuration of the applicationthe term """"buffer"""" fooled me a bit in the api docs and i assumed that the capacity controls the size after which the source observable starts to overflow would it make sense to clarify that documentation at least and mention that there is an internal buffer which can hold actually more items than what you specify as your overflow buffer? thanks for the quick reply! || ive hit this a number of times and generally ended up turning most observeon() into onbackpressurebuffer()observeon() i guess the ability to control the 128 size buffer as an optional parameter to observeon would be a nice addition || @srvaroa pr welcome || "";1;0;observeon: allow configurable buffer sizethe observeon operator is backed by a small queue of 128 slots that mayoverflow quickly on slow producers  this could only be avoided byadding a backpressure operator before the observeon (not onlyinconvenient but also taking a perf hit as it forces hops between twoqueues)this patch allows modifying the default queue size on the observeonoperatorfixes: #3751signed-off-by: galo navarro <anglorvaroa@gmailcom>;"
3780;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;upgrading synconsubscribe from experimental to beta;;;0;upgrading synconsubscribe from experimental to beta;; @akarnokd is this alright with you? || im not seeing why the change before 12? || i think at netflix we are comfortable using these going forward is there any reason to wait? this only communicates our comfort level with this api slightly more strongly  || i see the value of `synconsubscribe` but id like some user opinion about `asynconsubscribe` outside netflix  || okay fair i would also like to see some usage and feedback on `asynconsubscribe` as well however i would prefer both of these apis to be in beta so people can reliably attempt to adopt them i am comfortable (eventually) upgrading synconsubscribe to part of the standard api but have async in beta is this fair? || fine but since this is a promotion id like a majority vote just like before 11i personally would :+1: for synconsubscribe promotion but im still not convinced about `asynconsubscribe`s usability because the unpredictable request count if chained with any reasonable prefetching/replenishing operator (observeon flatmap etc) || okay i still would like it if we cleaned up the prefetching behavior so the request 1 patterns which we know are detrimental to performance are resolved  || @abersnaze @zsxwing @benjchristensen any concerns with this api upgrade from experimental to beta? || could you open a separate issue with the problem description and example code so we can discuss it and not clutter this pr? || do you mean the prefetching/batching behavior of observeon and flatmap? to confirm you are in agreement that experimental to beta is acceptable for both? || >  i still would like it if we cleaned up the prefetching behavior so the request 1 patterns which we know are detrimental to performance are resolved || cool yes will do! || so to confirm you do not up vote this pr as is? || > so to confirm you do not up vote this pr as is?:+1: for `synconsubscribe` :-1: for `asynconsubscribe` youd better split the pr || ive used asynconsubcribe in a couple of places with success one of which made integrating elasticsearchs pagination api play nicely with rx while allowing backpressure semantics to just work maybe one can use the following real code as an example of asynconsubscribe usage:``` javaimport javautilconcurrenttimeunitimport orgelasticsearchactionactionrequestbuilderimport orgelasticsearchactionsearchsearchrequestbuilderimport orgelasticsearchactionsearchsearchresponseimport orgelasticsearchactionsearchsearchscrollrequestbuilderimport orgelasticsearchclientclientimport orgelasticsearchcommonunittimevalueimport rxobservableimport rxobservableonsubscribeimport rxobservablesasynconsubscribepublic class scrollobservable {    private static class elasticsearchrequeststate {        private final client client        private final actionrequestbuilder<? searchresponse ? ?> request        private final int pagenumber        private final long hitcount        private final timevalue timeout        private elasticsearchrequeststate nextstate        private elasticsearchrequeststate(client client searchrequestbuilder request timevalue timeout) {            thisclient  client            thisrequest  requestsetscroll(timeout)            thistimeout  timeout            thispagenumber  0            thishitcount  0        }        private elasticsearchrequeststate(client client searchscrollrequestbuilder request timevalue timeout int pagenumber long hitcount) {            thisclient  client            thisrequest  requestsetscroll(timeout)            thistimeout  timeout            thispagenumber  pagenumber            thishitcount  hitcount        }        public observable<searchresponse> getresponse() {            return observabledefer(() -> observablejust(requestexecute()actionget()))                    retrywhen(errors -> errorsflatmap(error -> {                        if (error instanceof interruptedexception || errorgetcause() instanceof interruptedexception) {                            return observablejust(null)                        } else {                            return observableerror(error)                        }                    }))                    doonnext(r -> {                        long currentcount  hitcount + rgethits()gethits()length                        if (rgethits()gethits()length > 0 && currentcount < rgethits()gettotalhits()) {                            nextstate  new elasticsearchrequeststate(client clientpreparesearchscroll(rgetscrollid()) timeout pagenumber + 1 currentcount)                        }                    })        }        public boolean hasnext() {            return nextstate ! null        }        public elasticsearchrequeststate next() {            return nextstate        }    }    public static observable<searchresponse> from(final client client final searchrequestbuilder request final timevalue timeout) {        onsubscribe<searchresponse> os  asynconsubscribecreatestateful(() ->                new elasticsearchrequeststate(client request timeout)                (state requested observer) -> {                    observeronnext(stategetresponse())                    if (statehasnext()) {                        return statenext()                    } else {                        observeroncompleted()                        return null                    }                })        return observablecreate(os)    }    public static observable<searchresponse> from(client client searchrequestbuilder request long duration timeunit timeunit) {        return from(client request new timevalue(duration timeunit))    }    public static observable<searchresponse> from(client client searchrequestbuilder request) {        return from(client request new timevalue(1 timeunitminutes))    }}``` || @kurzweil interesting it seems like you dont actually use the requested amount in producing an observable to return id recommend changing `stategetresponse()` to take the `long requested` and limit the upper bounds of the data events  || @stealthcode it was some time ago but last time i checked i couldnt find a detailed documentation on how to use these onsubscribe other than the javadoc after a quick search can you suggest a pointer to such resources if they exist? if they dont exist could promoting these to beta include some detailed piece of documentation like a wiki page giving examples on how and when to use the `asynconsubscribe` and `synconsubscribe`? || @simonbasle right now the documentation is pretty sparse on these topics i would certainly welcome more documentation but dont currently have the time myself @davidmgross would you have some cycles to work on detailed documentation for the `synconsubscribe` and `asynconsubscribe`? here is one relevant [so post]( || thanks @stealthcode  || to add some color here theres currently no stable apis for creating observables that do backpressure-aware work deferring even just for wrapping a synchronous method that returns a scalar valuethis make rxjava use in libraries very challenging since `fromcallable` and the helpers herein are unavailable || what do you mean by> that do backpressure-aware work deferring? || a common pattern for deferring work is `defer(() -> just(somemethod()))` but if the subscriber has requested 0 the defer func is still called immediately on subscription not on the first non-zero request `fromcallable` doesnt suffer from this problem and the heavyweight hitters in this pr dont either but all of those are non-stable apis as a workaround you can do things like `empty()startwith(defer(() -> just(somemethod())))` or `concat(just(defer(() -> just(somemethod()))))` but thats a bit nuts || @jakewharton would be nice to support this strict deferral of work formally in the api and `defer` seems like a good place to put this support (so that subscription doesnt happen till first non-zero request) id be happy to see this happen in the existing `defer` operator but it could happen in an overload or elsewhere would you like to raise an issue to discuss this one? || sure!on thu mar 31 2016 at 3:35 pm dave moten notifications@githubcom wrote:> @jakewharton  would be nice to support> this strict deferral of work formally in the api and defer seems like a> good place to put this support (so that subscription doesnt happen till> first non-zero request) id be happy to see this happen in the existing> defer operator but it could happen in an overload or elsewhere would you> like to raise an issue to discuss this one?> > > you are receiving this because you were mentioned> > reply to this email directly or view it on github>  || i have taken out `asynconsubscribe` @akarnokd  ||   im currently in a holding pattern waiting to see where netflix wants me toapply my hours for them this season (theyve been picking up the tab for mydocumentation work thusfar) but ive filed a documentation issue so that ior someone else can pick up the trail at some point: reactivex/reactivexgithubio#221on mon mar 28 2016 at 4:28 pm aaron tull notifications@githubcomwrote:> @simonbasle  right now the documentation> is pretty sparse on these topics i would certainly welcome more> documentation but dont currently have the time myself @davidmgross>  would you have some cycles to work on> detailed documentation for the synconsubscribe and asynconsubscribe?> > here is one so post>  > > you are receiving this because you were mentioned> reply to this email directly or view it on github>  david m grossplp consulting ||;;;;1;1;upgrading synconsubscribe from experimental to beta;
3783;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: rename and refactor classes to match the design document;this pr renames and moves classes around to match the design document.  in addition  jmh version is updated to 1.11.3 and gradle to 2.12.  internal classes haven t been renamed yet and i plan to do it after this pr is merged.  this pr can t be effectively reviewed on github. i suggest a clean checkout to your local ide and see the proposed structure there.;;0;2x: rename and refactor classes to match the design document;this pr renames and moves classes around to match the design documentin addition jmh version is updated to 1113 and gradle to 212internal classes havent been renamed yet and i plan to do it after this pr is mergedthis pr cant be effectively reviewed on github i suggest a clean checkout to your local ide and see the proposed structure there;great stuff    || im going to trust you on this one i didnt checkout the branch;;;;1;1;2x: rename and refactor classes to match the design document;
"3787;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: fix groupby delaying group completion till all groups were emitted;in 1.1.1   groupby  was fixed to properly honor backpressure on the outer  observable . the change included a drain loop that emitted  oncompleted()  to the groups only when all  groupedobservable s were drained from the main queue. this delayed the group s completion unnecessarily causing the  concat  operator to hang in some source-consumer cases such as #3775.  this pr fixes the behavior by signalling  oncompleted()  to the groups the moment the main completes.   note  however  that concatenating groups is eventually prone to hangs due to the groups not completing until the source completes  thus  concat  can t switch to the next source. one should use  flatmap  or  concatmapeager  instead.;;3775.0;1x: fix groupby delaying group completion till all groups were emitted;in 111 `groupby` was  to properly honor backpressure on the outer `observable` the change included a drain loop that emitted `oncompleted()` to the groups only when all `groupedobservable`s were drained from the main queue this delayed the groups completion unnecessarily causing the `concat` operator to hang in some source-consumer cases such as #3775this pr fixes the behavior by signalling `oncompleted()` to the groups the moment the main completes note however that concatenating groups is eventually prone to hangs due to the groups not completing until the source completes thus `concat` cant switch to the next source one should use `flatmap` or `concatmapeager` instead; ;concat cant display all the groupedby observers on version 111;""here are the code im using to test``` java        final observable<groupedobservable<string appinfo>> groupby  observablefrom(appinfolist)                groupby(appinfo -> {                    simpledateformat sdf  new simpledateformat(""""mm/yyyy"""")                    string groupedstr  sdfformat(new date(appinfogetlastupdatetime()))                    return groupedstr                })        observableconcat(groupby)                subscribe(msubscriber)```and the library is :```    compile ioreactivex 111    compile ioreactivex 110```` i got this result which apparently is not correct  i only got three results!:![device-2016-03-17-151005]( it should be like this as shown on the rxjava-essential-code( problem never occurs on version 110"";""strange this code works for me on 111:``` javapublic class groupconcat {    static final class appinfo {        string name        localdate date        @override        public string tostring() {            return name + """" @ """" + date        }    }    public static void main(string args) {        systemsetproperty(""""rxring-buffersize"""" """"16"""")        list<appinfo> list  new arraylist<>()        for (int i  0 i < 10 i++) {            for (int j  0 j < 3 j++) {                appinfo ai  new appinfo()                ainame  i + """" - """" + j                aidate  localdateof(2016 3 i + 1)                listadd(ai)            }        }        observable<groupedobservable<string appinfo>> o  observablefrom(list)        groupby(v -> vdateformat(datetimeformatterofpattern(""""mm/yyyy"""")))        observableconcat(o)        subscribe(systemout::println)    }}``` || ``` javapublic class concat {    public static class student {        public string classid        public string name        @override        public string tostring() {            return """"student{classid"""" + classid + """" name"""" + name + """"}""""        }    }    public static void main(string args) {        arraylist<student> list  new arraylist<>()        for (int i  0 i < 20 i++) {            student student  new student()            studentclassid  stringvalueof(i % 5)            studentname  stringvalueof(i)            listadd(student)        }        observable<groupedobservable<string student>> groupby                 observablefrom(list)                          groupby(new func1<student string>() {                              @override                              public string call(student student) {                                  return studentclassid                              }                          })        observableconcat(groupby)                  subscribe(new observer<student>() {                      @override                      public void oncompleted() {                          systemoutprintln(""""completed"""")                      }                      @override                      public void onerror(throwable e) {                          systemoutprintln(""""error"""")                      }                      @override                      public void onnext(student student) {                          systemoutprintln(student)                      }                  })    }}```in rxjava 111console print :```student{classid0 name0}student{classid0 name5}student{classid0 name10}student{classid0 name15}process finished with exit code 0```in rxjava 110console print :```student{classid0 name0}student{classid0 name5}student{classid0 name10}student{classid0 name15}student{classid1 name1}student{classid1 name6}student{classid1 name11}student{classid1 name16}student{classid2 name2}student{classid2 name7}student{classid2 name12}student{classid2 name17}student{classid3 name3}student{classid3 name8}student{classid3 name13}student{classid3 name18}student{classid4 name4}student{classid4 name9}student{classid4 name14}student{classid4 name19}completedprocess finished with exit code 0```111 only print first group and not call `oncompleted`110 print all groupsystem os : windows 10 64-bitjdk version : oracle jdk 170_80 64-bitgradle version : 212intellij idea version : 1416 || yep this is a bug the groups dont complete until all groups have been emitted which doesnt happen because concat() prefetches only 2 groups of the 5 i overlooked this case and apparently the unit tests werent checking for this || see the fix in #3787 ||  closing via #3787 || "";1;0;1x: fix groupby delaying group completion till all groups were emitted;"
"3789;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: prevent single.zip() of zero singles;closes #3784.;;3784.0;1x: prevent singlezip() of zero singles;closes #3784; ;singlezip on empty collection never terminate; javasinglezip(new arraylist<single<integer>>() i -> i)          doafterterminate(() -> systemoutprintln(""""terminated""""))          subscribe()```this behavior is different from `observablezip```` javaobservablezip(new arraylist<observable<integer>>() i -> i)                   doafterterminate(() -> systemoutprintln(""""terminated""""))                   subscribe()```"";what do you expect it to do? throw error? single either emits one result or throws error looks like the best we can do is to throw something like `illegalargumentexception`  || observablezip just completes if there are no sources if one converts an empty observable to single it produces a nosuchelementexception error || ill check this and work on pr soon  ||;1;0;1x: prevent singlezip() of zero singles;"
"3790;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: expose single.lift();closes #3161.;;3161.0;1x: expose singlelift();closes #3161; ;lift(final operator<? extends r ? super t>) has private access in rxsingle;""i was expecting `single#lift()` to be part of the public api like `observable#lift()` is there a reason for this restriction?`single#compose()` is public too (and links to `#lift()` in the docs) i guess the private access is just a bug workaround:```singlejust(""""value"""")        toobservable()        lift(myoperator)        tosingle()```"";single is in experimental phase its api is not stable and there wasnt enough confidence to open up many of the methods including lift || i think the time has come to expose `singlelift()` prs welcome ||;1;0;1x: expose singlelift();"
3791;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: fix observable delay methods typos in documenation;;;0;1x: fix observable delay methods typos in documenation;;great thanks!  @neoranga55 theres also one [here]( || @vanniktech do you suggest adding the fix for single to this current pr or opening a new one? || maybe its easier to search for that typo in all files and fix them in a single pr || @akarnokd thats exactly what i did `ack compuation` and it returned me the two places he already  it and then the other one in single || okay to be clear please fix the type on single as well in this pr || ok added the fix for single im not familiar with the branching flow here so i did the one im familiar with: rebase to collapse both changes into a single commit || looking good now  we prefer single commit prs so you did right by squashing the commits || ;;;;1;1;1x: fix delay methods typos in documenation;
3799;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: add completable.andthen(single);https://github.com/reactivex/rxjava/issues/3730;;0;1x: add completableandthen(single);https://githubcom/reactivex/rxjava/issues/3730;thanks for your review  || looks good! :+1: just few small things to fix || @artem-zinnatullin @akarnokd thanks for your review ill update this soon || updated and rebased ||  ;;;;1;1;1x: add completableandthen(single);
3803;1;0;0;0;0;1;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: fix typos in documentation and some code;;;0;1x: fix typos in documentation and some code;; ;;;;1;1;1x: fix typos in documentation and some code;
3818;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x fromcallable() @experimental -> @beta;part of #3816;;0;1x fromcallable() @experimental -> @beta;part of #3816;`testqueuefullemitserrorwithvaryingbuffersize` is an unreliable test i already  in #3795  ;;;;1;1;1x fromcallable() @experimental -> @beta;
"3820;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;making rxplugins reset() public;discussions found here: https://github.com/reactivex/rxjava/issues/2297;;0;making rxplugins reset() public;discussions found here: https://githubcom/reactivex/rxjava/issues/2297;"" based on the discussion its definitely helpful but also dangerouscould you add a comment indicating that its dangerous?otherwise  yeah same concern about dangerous that this method may add it looks like an easy way to do testing but in multithreaded environment (integrational or functional tests for example) it may break a lot of things in """"random"""" manner@stevegury @akarnokd lets also mark it as `@experimental` so well be able to remove it if community will have more issues than benefits? || yeah good idea for the `@experimental` flag || thanks for the feedback @stevegury  @artem-zinnatullin just added the `@experimental` tag comments in the pr + commit message  || please add a javadoc block and explicitly mention that resetting the plugins is dangerous/unsafe during application runtime (i suspect most people wont check the link) keep the link at the end || @shivangshah friendly ping please update with javadoc || @jakewharton yes  thanks for the reminder this totally slipped my mind  let me do it now   || @jakewharton : done ! let me know if we need to add anything else as a part of the documentation  ||   "";;;;1;1;making rxplugins reset() publicdiscussions found here:  @experimental tag because exposing reset() could be dangerousadding javadocs for `reset()` apiexplicitly mentioning how caution is advised when using `reset()` apialso mentioning links to detailed discussions on github issue;"
"3822;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: make defensive copy of the properties in rxjavaplugins;possible solution to #3749.;;3749.0;1x: make defensive copy of the properties in rxjavaplugins;possible solution to #3749;;concurrentmodificationexception in rxjavapluginsgetpluginimplementationviaproperty;""i am using rxjava 111 on android and getting the following error:``` javacaused by javautilconcurrentmodificationexception       at javautilhashtable$hashiteratornextentry(hashtablejava:727)       at javautilhashtable$entryiteratornext(hashtablejava:778)       at javautilhashtable$entryiteratornext(hashtablejava:776)       at rxpluginsrxjavapluginsgetpluginimplementationviaproperty(rxjavapluginsjava:177)       at rxpluginsrxjavapluginsgetschedulershook(rxjavapluginsjava:232)       at rxschedulersschedulers(schedulersjava)       at rxschedulersschedulers(schedulersjava)```my code is ``` javaunreadconversationsserver  unreadconversations      final schedulerworker worker  schedulersio()createworker()      workerschedule(() -> {        try {          computeunreadunsyncedconversationcount()        } catch (exception e) {          timbere(e """"error while computing unread unsynced conversation count"""")        }        workerunsubscribe()      })```full detail here: http://crashesto/s/4ecb8083b7f"";""you seem to have something changing `systemgetproperties()` concurrently with the initialization of the plugin || ping @niqo01: were you able to fix the problem? @akarnokd gave most possible reason of the issue probably some third-party library modifies system properties concurrently (you can debug access to system properties to find that out)// we can try to `clone()` properties before iterating over them (its a `hashtable` (ew) which is `synchronized` almost everywhere but iterating) but personally id like to not do it if possible || i dont know what kind of map it is thus copying might have the same issue we could catch the cme and retry the operation with a fresh iterator || `clone` looks good to me since its called only `once` for each hook we wont lose any performance after warming up> i dont know what kind of map it is thus copying might have the same issue we could catch the cme and retry the operation with a fresh iteratoraccording to the javadoc of properties i think `clone` is safe> each key and its corresponding value in the property list is a string> because properties inherits from hashtable the put and putall methods can be applied to a properties object their use is strongly discouraged as they allow the caller to insert entries whose keys or values are not strings the setproperty method should be used instead if the store or save method is called on a """"compromised"""" properties object that contains a non- string key or value the call will fail similarly the call to the propertynames or list method will fail if it is called on a """"compromised"""" properties object that contains a non- string key || @zsxwing great!pr welcome || closing via #3822 || "";1;0;1x: make defensive copy of the properties in rxjavaplugins;"
"3824;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: javac 9 compatibility fixes;the type inference of javac in jdk 9 has been changed in an incompatible way  marking many generics-related code invalid.  the most common problems: - the inference calculates  observable<? extends t>  but from its perspective  a call to  subscribe()  with a  subscriber<t>  is ambiguous as it matches  subscribe(observer<? super t>)  and  subscribe(subscriber<? super t>) . somehow  the more specific class is not considered as a valid choice. downcasting to  observable<t>  fixes the error. -  a<?>  no longer accepts  a<ti>  elements  requires the use of raw types to get around  the tests appear to compile fine.  note that i couldn t find a working ide for jdk 9 and had to revert to command line trickery:      @echo off  dir /s /b src\main\java\rx\*.java > sources.txt dir /s /b src\test\java\rx\*.java >> sources.txt   c:\program files\java\jdk-9\bin\javac.exe  -cp c:/temp/rx/junit.jar c:/temp/rx/mockito.jar @sources.txt   del sources.txt;;0;1x: javac 9 compatibility fixes;""the type inference of javac in jdk 9 has been changed in an incompatible way marking many generics-related code invalidthe most common problems:- the inference calculates `observable<? extends t>` but from its perspective a call to `subscribe()` with a `subscriber<t>` is ambiguous as it matches `subscribe(observer<? super t>)` and `subscribe(subscriber<? super t>)` somehow the more specific class is not considered as a valid choice downcasting to `observable<t>` fixes the error- `a<?>` no longer accepts `a<ti>` elements requires the use of raw types to get aroundthe tests appear to compile finenote that i couldnt find a working ide for jdk 9 and had to revert to command line trickery:```@echo offdir /s /b src\main\java\rx\*java > sourcestxtdir /s /b src\test\java\rx\*java >> sourcestxt""""c:\program files\java\jdk-9\bin\javacexe"""" -cp c:/temp/rx/junitjarc:/temp/rx/mockitojar @sourcestxt del sourcestxt```"";"":+1: // @akarnokd maybe report """"incorrect"""" behavior of jdk9 compiler to openjdk issue tracker? || there were reports such as [this]( before bottom line is that they are fine with their breaking change ||  "";;;;1;1;1x: javac 9 compatibility fixes;"
3826;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: fix testsubscriber.create doc;the docs of testsubscriber.create(subscriber) and testsubscriber.create(observer) got mixed up. i just swapped them.;;0;1x: fix testsubscribercreate doc;the docs of testsubscribercreate(subscriber) and testsubscribercreate(observer) got mixed upi just swapped them;  ;;;;1;1;1x: fix testsubscribercreate doc;
3828;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: asyncsubject now supports backpressure;asyncsubject  can trivially support backpressure when it emits a single item by setting the  singleproducer  on the child  subscriber  instead of calling  onnext  immediately.;;0;1x: asyncsubject now supports backpressure;`asyncsubject` can trivially support backpressure when it emits a single item by setting the `singleproducer` on the child `subscriber` instead of calling `onnext` immediately;;;;;1;1;1x: asyncsubject now supports backpressure;
3836;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: fix switchmap/switchonnext producer retention and backpressure;this pr fixes the producer retention problem and backpressure problem in  switchmap / switchonnext .  in the original  when an inner source completed  its producer was still referenced after it. if there was no new inner source or the next inner source didn t set a new producer  the operator leaked the previous inner source s internals. the fix involves nulling out the producer field when the inner source completes (and is still the current one).  the original had an additional bug due to a race condition between the request arbitration and switching inner sources. in some cases  the switch didn t properly forward the remaining request amount to the new inner source  causing hangs. in some other cases  both the old and new inner sources were able to emit  causing overflow. the fix involves a new queue-drain loop with some emitter-loop help to work out the state transitions.;;0;1x: fix switchmap/switchonnext producer retention and backpressure;this pr fixes the producer retention problem and backpressure problem in `switchmap`/`switchonnext`in the original when an inner source completed its producer was still referenced after it if there was no new inner source or the next inner source didnt set a new producer the operator leaked the previous inner sources internals the fix involves nulling out the producer field when the inner source completes (and is still the current one)the original had an additional bug due to a race condition between the request arbitration and switching inner sources in some cases the switch didnt properly forward the remaining request amount to the new inner source causing hangs in some other cases both the old and new inner sources were able to emit causing overflow the fix involves a new queue-drain loop with some emitter-loop help to work out the state transitions;;;;;1;1;1x: fix switchmap/switchonnext producer retention and backpressure;
3842;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: improve executorscheduler worker unsubscription;i noticed that when a worker built from  schedulers.from(executors.newfixedthread(1))  is unsubscribed the use of a  compositesubscription  to track task subscriptions means that the tasks may be unsubscribed in any old order ( compositesubscription  holds its subscriptions in a  hashset ).  this means that if the worker is given task a and task b then the race can prevent a from running but allow b to run! i ve included a unit test in this pr that demos it. fails every time on my machine on the first loop.  this  pr is really for discussion about the problem and possible fixes.  i have included a possible fix which is to track overall subscription using a volatile boolean and check that boolean before running any task. if this was considered the way to go some further simplification would take place in the operator (might not need to check individual task subscriptions).  i haven t checked other schedulers for this sort of problem yet.;;0;1x: improve executorscheduler worker unsubscription;i noticed that when a worker built from `schedulersfrom(executorsnewthread(1))` is unsubscribed the use of a `compositesubscription` to track task subscriptions means that the tasks may be unsubscribed in any old order (`compositesubscription` holds its subscriptions in a `hashset`)  this means that if the worker is given task a and task b then the race can prevent a from running but allow b to run! ive included a unit test in this pr that demos it fails every time on my machine on the first loopthis  pr is really for discussion about the problem and possible fixesi have included a possible fix which is to track overall subscription using a volatile boolean and check that boolean before running any task if this was considered the way to go some further simplification would take place in the operator (might not need to check individual task subscriptions)i havent checked other schedulers for this sort of problem yet;do you have a real case that the order does matter? i think this affects all compositesubscription usages || i see this as an eager cancellation matter than a race there is no need for the flag but just check tasksisunsubscribed() before and run some cleanup:``` javado {    if (tasksisunsubscribed()) {        queueclear()        return    }    scheduledaction sa  queuepoll()    if (tasksisunsubscribed()) {        queueclear()        return    }    if (!saisunsubscribed()) {        sarun()    }} while (wipdecrementandget() ! 0)``` || @zsxwing im confusing the issue talking about `compositesubscription` its really about subscription management in `executorscheduler` i dont have a problem with `compositesubscription` in general@akarnokd thanks that looks good ill amend the pr  its interesting you dont classify it as a bug but i guess we havent documented our expectations of `scheduler`s in this area do you think `schedulerunsubscribe()` should offer stronger guarantees similar to the guarantee offered  executorserviceshutdownnow()`?> attempts to stop all actively executing tasks halts the> processing of waiting tasks and returns a list of the tasks> that were awaiting executionthe relevant bit i suppose is _halts the processing of waiting tasks_ || @davidmoten  gotcha `eventloopworker` has the same issue you can try `schedulerscomputation()` or `schedulersio()` to reproduce it in your test || @zsxwing `computation()` and `io()` both fail too thanks  || @akarnokd dont you think that second check of `tasksisunsubscribed()` in your snippet is overkill? can i remove?im also wondering if `unsubscribe()` can look like this:``` java    @override    public void unsubscribe() {        queueclear()        tasksunsubscribe()    }``` and then `run()` would be: ``` java        @override        public void run() {            do {                if (tasksisunsubscribed()) {                    return                }                scheduledaction sa  queuepoll()                if (sa  null) {                    return                }                if (!saisunsubscribed()) {                    sarun()                }            } while (wipdecrementandget() ! 0)        }``` || no need for stronger guaranteesthat `unsubscribe` you are suggesting delays the `tasksunsubscribe()` and the queue could still be in use swap the two lines in addition youd still need a clear in the drain loop because it could be still scheduled with a non-empty queue || thanks @akarnokd  in terms of guarantees i was going to suggest that the javadoc of `scheduler` at the class level be supplemented with a statement similar to that of `executorserviceshutdownnow()` once all schedulers had been enhanced like this pr || updated pr squashed commits ||   @davidmoten mind thinking about how to fix `eventloopworker`? :) || @zsxwing sure ill have a look at `eventloopworker`i think there is an outstanding race with this pr:``` javaif (!saisunsubscribed()) {    sarun()}```might have to be:``` javaif (!tasksisunsubscribed()) {    sarun()}```ill have a look a bit later today and ill submit another pr if needed || `if (!saisunsubscribed()) {` is necessary  `sa` may be unsubscribed by the user || yep i just noticed that myself ta || @zsxwing i think it should look like this:``` java        @override        public void run() {            do {                if (tasksisunsubscribed()) {                    queueclear()                    return                }                scheduledaction sa  queuepoll()                if (sa  null) {                    return                }                if (!saisunsubscribed()) {                    if (!tasksisunsubscribed()) {                        sarun()                    } else {                        queueclear()                        return                    }                }            } while (wipdecrementandget() ! 0)        }``` ||;;;;1;1;fix undesired execution in executorscheduler worker when unsubscribed;
3848;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: deanonymize observable inner classes;this pr factors out many anonymous inner classes into named classes and moves them outside  observable .  this cleanup makes the  observable  more compact and helps debugging by showing more meaningful names in stacktraces.;;0;1x: deanonymize observable inner classes;this pr factors out many anonymous inner classes into named classes and moves them outside `observable`this cleanup makes the `observable` more compact and helps debugging by showing more meaningful names in stacktraces;great change observable class is a beast so readability and stacktrace improvements are always a  thanks @jakewharton ! updated pr based on your suggestions || ;;;;1;1;fix indentation rename lambda to action;
3849;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove unused local.;;;0;remove unused local;; ;;;;1;1;remove unused local;
"3856;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;provide factories for creating the default scheduler instances.;unlike other hooks  the  rxjavaschedulershook  has no access to the real  scheduler  instances in order to do wrapping/delegation. with these factory methods  a hook can access what would otherwise be the instance used since there is often no other means of creating these specialized schedulers.  for android this wrapping/delegation use-case is important for ui testing. we have a means to tell the testing framework when the app is idle and to do that we need to hook into the schedulers to know when they re empty. this is easy to do currently  but you cannot wrap the real instance and instead have to supply alternate implementations which might subtly alter the behavior under test.  these three methods are referenced in #3724  and i think providing the defaults is useful as well as eventually adding overloads which take  threadfactory  instances for each.;;3724.0;provide factories for creating the default scheduler instances;unlike other hooks the `rxjavaschedulershook` has no access to the real `scheduler` instances in order to do wrapping/delegation with these factory methods a hook can access what would otherwise be the instance used since there is often no other means of creating these specialized schedulersfor android this wrapping/delegation use-case is important for ui testing we have a means to tell the testing framework when the app is idle and to do that we need to hook into the schedulers to know when theyre empty this is easy to do currently but you cannot wrap the real instance and instead have to supply alternate implementations which might subtly alter the behavior under testthese three methods are referenced in #3724 and i think providing the defaults is useful as well as eventually adding overloads which take `threadfactory` instances for each;""please correct me if im wrong but looks like as soon as you access one of the new methods `static final schedulersinstance` will be instantiated which will make impossible to use `rxjavaschedulershook` as you described have you checked described use case? maybe add such tests as example if possible?> we have a means to tell the testing framework when the app is idle and to do that we need to hook into the schedulers to know when theyre emptyjust wanted to say for those who may find this pr later: empty/non-empty state of schedulers is not 100% source of truth for ui tests you may have some background or time related (periodic/etc) code that does not affect the ui directly and may even freeze tests || you are accessing the methods from the hook which was called from the static initializer of this class on first reference to `schedulersio()` or the like ill add a test || yup but there is still potential problem if somebody will try to create schedulers using these methods outside of the hook for example in `@beforeclass`/etc or probably even just for non-test needs -> may result in hours of trying to understand why hook is not overriding schedulersmaybe move these methods to `rxjavaschedulershook`? || that prevents package scoped methods from being used in the factory || > that prevents package scoped methods from being used in the factorywe can move schedulers to `internalschedulers` to """"defend"""" from that (otherwise somebody can always use reflection to break package scope) and make constructors publicideal solution would be to return schedulers in `rxjavaschedulershook` by default instead of returning `null` like it does now so calling `supergetsomescheduler()` will give original instance that you can wrap/etc as you wish though well have to handle `null` as default too// sorry im very tired and want to sleep so i may come to wrong conclusions || the factories were moved to the hook ||  :+1: now but let me ask again what about this:> ideal solution would be to return schedulers in `rxjavaschedulershook` by default instead of returning `null` like it does now so calling `supergetsomescheduler()` will give original instance that you can wrap/etc as you wish though well have to handle `null` as default toono need for new methods no need to fight with instantiation order and package scope visibility yes user wont be able to instantiate new scheduler of required type outside of the hook but its not possible at the moment so nobody loses nothing ||  "";apis for easily changing the thread priority of default schedulers via hook;""on android the main thread is a sacred holy land at which we must all worship as such this means other threads (ideally) shouldnt be favorably scheduled in priority with it for network and filesystem operations this usually means using low priority threadsone solution is to just use low priority threads on our own schedulers but this doesnt affect code using the standard `io()` and `computation()` schedulers unfortunately theres a whole bunch of ceremony around how various schedulers are initialized which includes a mixed bag of public vs non-public types and apis which makes replacing them in a scheduler hook difficulti think the most easy way to accomplish this is the following:-  ~~`rxthreadfactory` constructor overload which takes a thread priority to use~~ not needed-  factory methods on `schedulers` for creating instances of `io()` `computation()` and `newthread()` except using a supplied `threadfactory`  -  `schedulerscreateioscheduler(threadfactory)`  -  `schedulerscreatecomputationscheduler(threadfactory)`  -  `schedulerscreatenewthreadscheduler(threadfactory)`nice to have:-  `schedulers` using these factory methods to create the default implementations this involves moving the thread factories from the individual types """"up"""" to `shedulers`"";happy to do some of the work if this sounds acceptable || @jakewharton i think that sound acceptable im happy to review your pr || this is a little more tricky than i had initially anticipated perhaps its worth talking about a means of setting the default priority of the internal thread pools through a mechanism like properties as a separate easier first step? plus that would be a lot lower-overhead for android users anyway and we could even use the existing android platform detection to lower the thread priority by default || pass a threadfactoryon fri jan 20 2017 10:48 pm erdaren <notifications@githubcom> wrote:> so how to set thread priority in android with android values(like> processthread_priority_background)?>> > you are receiving this because you were mentioned>> reply to this email directly view it on github> < or mute the thread> < > ||;1;0;provide factories for creating the default scheduler instances;"
"3866;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: add single.tocompletable();closes #3865.;;3865.0;1x: add singletocompletable();closes #3865;  seems github doesnt add the pr description to the commit message automatically when squashing a pr i added it manually ||;flatmap from single to completable;is there an easy way of doing a `flatmap` from a `single` to a `completable`?currently i need to do something like this:``` java completable savedata(data data) {        } singlejust(data)        flatmapobservable(new func1<data observable<?>>() {            @override            public observable<?> call(data data) {                return savedata(data)toobservable()            }        })        tocompletable()```i think it would be good to have an operator like `singleflatmapcompletable()` so we could do:``` javasinglejust(data)        flatmapcompletable(new func1<data completable>() {            @override            public completable call(data data) {                return savedata(data)            }        })```;""at the moment you can pass the `single` to `completablefromsingle()` ill submit a pr for `singletocompletable()` || im not sure this issue is resolved by adding `singletocompletable()`? my question was how to """"link"""" a `single` to a `completable` using an operator like `flatmap` so that the `completable` can use the result from the `single` if i transform my source `single` to a completable using `singletocompletable()` then the value is lostmy suggestion is to add `singleflatmapcompletable()`  || > so that the `completable` can use the result from the `single``completable` is value-less type you wont be able to use result from `single` or `observable` it was created to replace `observable<void> / single<void>` when you just need to perform some side-effect workcan you use `single` instead of `completable`? || so if i have a method in class `a` like this:``` javacompletable savedata(data data) {     // creates and returns a completable that saves some data in local storage}```then in class `b` i have a method that retrieves some data from a rest api ``` javasingle<data> retrievedata() {     // creates and returns a single that gets some data}```now from class `c` i want to `flatmap` both methods so when `retrievedata()` completes i can pass the result to `savedata(data)` are you suggesting that `savedata(data)` should return a `single` instead of a `completable`? i would imagine a `completable` is a better option because i dont care about the value after its been saved  || if you want final result to be `completable` then one way is to do:``` javacompletable result  retrievedata()  flatmap(data -> savedata(data)tosingle(() -> """""""")) // just emit something  tocompletable()```if you want final result to be `single` then one way to do this:``` javasingle<data> result  retrievedata()  flatmap(data -> savedata(data)tosingle(() -> data))``` || yeah that makes sense i want the final result to be a `completable` so the first option would work for me however it seems a bit redundant having to call `tosingle()` and then call `tocompletable()` thats why i was thinking that adding a new operator like `singleflatmapcompletable()` could be useful thanks  || a simple extension function in kotlin would be the following:``` kotlinfun <t> single<t>flatmapcompletable(producer: (t) -> completable): completable {    return completablecreate { subscriber ->        subscribe(              { producer(it)subscribe(subscriber) }              { subscriberonerror(it) }        )    }}``` || could this please be re-opened? the scenario with a save method seems like a prime use case for `completable` to say that you cant go from single to a nested save is pretty hard to accept || there is the pr #4226 for that || didnt see that  "";1;0;1x: add singletocompletable();"
3867;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: improve executorscheduler worker unsubscription some more;as per discussion in #3842  there was an outstanding possibility that unsubscription of a  worker  would not cancel all tasks waiting in the queue. this pr addresses that possibility. i attempted to provoke the condition in a unit test but didn t manage it. nethertheless i think this change completes the protection desired in #3842.  i do have mixed feelings about the possible double calling of  queue.clear()  (once in the  run()  method and once in the  unsubscribe()  method. any preferences?;;0;1x: improve executorscheduler worker unsubscription some more;as per discussion in #3842 there was an outstanding possibility that unsubscription of a `worker` would not cancel all tasks waiting in the queue this pr addresses that possibility i attempted to provoke the condition in a unit test but didnt manage it nethertheless i think this change completes the protection desired in #3842i do have mixed feelings about the possible double calling of `queueclear()` (once in the `run()` method and once in the `unsubscribe()` method any preferences?;> there was an outstanding possibility that unsubscription of a worker would not cancel all tasks waiting in the queuetasks are tracked in a separate structure for cancellation which always happens but maybe not that eagerly and not the same order they were submittedyou should also keep the original up-front `clear()` part || thanks @akarnokd ive updated the pr and squashed commits ||  > there was an outstanding possibility that unsubscription of a worker would not cancel all tasks waiting in the queue@davidmoten could you explain how this will happen and why adding `if (!tasksisunsubscribed()) {` could help? even if `tasksisunsubscribed` returns `false` it may become `true` after you just check it || @zsxwing sure youre right that that is possible but that scenario doesnt worry me in that i just consider that as not being able to stop work in progress as opposed to work that is queued so i guess thats all that is happening here because the check of `tasksisunsubscribed()` at the start of of the loop is all thats required to prevent the issue that i was worried about in #3842 this additional check just firms up not running queued work that has been cancelled || > this additional check just firms up not running queued work that has been cancelledsounds like adding `isunsubscribed` in an operator? || yep analagous to that || ;;;;1;1;ensure waiting  tasks are cancelled on worker unsubscription;
3868;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;fix an unsubscribe race in eventloopworker;there is an unsubscribe race condition similar to #3842 in  cachedthreadscheduler.eventloopworker  and  eventloopsscheduler.eventloopworker . image the following execution order:  | execution order | thread 1 | thread 2 | | --- | --- | --- | | 1 |  | submit task a | | 2 |  | submit task b | | 3 | unsubscribe worker |  | | 4 | unsubscribe task a |  | | 5 |  | task a won t run as it s unsubscribed | | 6 |  | run task b | | 7 | unsubscribe task b |  |  so task b will run but its previous task a will be skipped.  this pr adds a check before running an action and moves  workerunderconcurrentunsubscribeshouldnotallowlatertaskstorunduetounsubscriptionrace  to  abstractschedulerconcurrencytests  to test all concurrent schedulers.;;0;fix an unsubscribe race in eventloopworker;there is an unsubscribe race condition similar to #3842 in `cachedthreadschedulereventloopworker` and `eventloopsschedulereventloopworker` image the following execution order:| execution order | thread 1 | thread 2 || --- | --- | --- || 1 |  | submit task a || 2 |  | submit task b || 3 | unsubscribe worker |  || 4 | unsubscribe task a |  || 5 |  | task a wont run as its unsubscribed || 6 |  | run task b || 7 | unsubscribe task b |  |so task b will run but its previous task a will be skippedthis pr adds a check before running an action and moves `workerunderconcurrentunsubscribeshouldnotallowlatertaskstorunduetounsubscriptionrace` to `abstractschedulerconcurrencytests` to test all concurrent schedulers; :+1:  thanks @zsxwing  ||;;;;1;1;fix a unsubscribe race in eventloopworker;
3871;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;deprecate remaining public scheduler types.;a continuation of some work done in #3856 of removing uninstantiable types from the public api (via deprecation).;;0;deprecate remaining public scheduler types;a continuation of some work done in #3856 of removing uninstantiable types from the public api (via deprecation); ;;;;1;1;deprecate remaining public scheduler types;
"3879;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;expose scheduler factories which accept thread factories.;this allows hooks to create schedulers whose threads have different priorities.  closes #3724.;;3724.0;expose scheduler factories which accept thread factories;this allows hooks to create schedulers whose threads have different prioritiescloses #3724; thanks!on fri apr 29 2016 at 2:13 pm david karnok notifications@githubcomwrote:> merged #3879  > > you are receiving this because you authored the thread> reply to this email directly or view it on github>  ||;apis for easily changing the thread priority of default schedulers via hook;""on android the main thread is a sacred holy land at which we must all worship as such this means other threads (ideally) shouldnt be favorably scheduled in priority with it for network and filesystem operations this usually means using low priority threadsone solution is to just use low priority threads on our own schedulers but this doesnt affect code using the standard `io()` and `computation()` schedulers unfortunately theres a whole bunch of ceremony around how various schedulers are initialized which includes a mixed bag of public vs non-public types and apis which makes replacing them in a scheduler hook difficulti think the most easy way to accomplish this is the following:-  ~~`rxthreadfactory` constructor overload which takes a thread priority to use~~ not needed-  factory methods on `schedulers` for creating instances of `io()` `computation()` and `newthread()` except using a supplied `threadfactory`  -  `schedulerscreateioscheduler(threadfactory)`  -  `schedulerscreatecomputationscheduler(threadfactory)`  -  `schedulerscreatenewthreadscheduler(threadfactory)`nice to have:-  `schedulers` using these factory methods to create the default implementations this involves moving the thread factories from the individual types """"up"""" to `shedulers`"";happy to do some of the work if this sounds acceptable || @jakewharton i think that sound acceptable im happy to review your pr || this is a little more tricky than i had initially anticipated perhaps its worth talking about a means of setting the default priority of the internal thread pools through a mechanism like properties as a separate easier first step? plus that would be a lot lower-overhead for android users anyway and we could even use the existing android platform detection to lower the thread priority by default || pass a threadfactoryon fri jan 20 2017 10:48 pm erdaren <notifications@githubcom> wrote:> so how to set thread priority in android with android values(like> processthread_priority_background)?>> > you are receiving this because you were mentioned>> reply to this email directly view it on github> < or mute the thread> < > ||;1;0;expose scheduler factories which accept thread factoriesthis allows hooks to create schedulers whose threads have different priorities;"
3880;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: testsubscriber/testobserver print values if number of items doesn t match;otherwise you have to manually print/debug values if test failed.;;0;1x: testsubscriber/testobserver print values if number of items doesnt match;otherwise you have to manually print/debug values if test failed;  ;;;;1;1;1x: testsubscriber/testobserver print values if number of items doesnt match;
"3883;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: fix multiple chained single.doafterterminate not calling actions;3881.  the bug is caused by the impedance mismatch between  observable  s  subscriber  and  single  s  singlesubscriber . the original code called  onnext()  which immediately signalled an  onsuccess  but also caused an unsubscription  preventing a delivery of  oncompleted()  in the inner single.  the fix keeps  onsuccess / onerror  rails intact  throughout the chain.;;3881.0;1x: fix multiple chained singledoafterterminate not calling actions;3881the bug is caused by the impedance mismatch between `observable`s `subscriber` and `single`s `singlesubscriber` the original code called `onnext()` which immediately signalled an `onsuccess` but also caused an unsubscription preventing a delivery of `oncompleted()` in the inner singlethe fix keeps `onsuccess`/`onerror` rails intact  throughout the chain;;single not calling doafterterminate when used in flatmap;""ive noticed that when i return a single from a flatmap and that single calls doafterterminate(action0) the action0s call method is never called  this behaviour is not consistent with what happens when you do the same thing with an observable  i am using 113when i run:``` javasinglejust(""""test"""")    flatmap(s ->         singlejust(""""test2"""")            doafterterminate(() -> systemoutprintln(""""singleflatmapdoafterterminate""""))        )doafterterminate(() -> systemoutprintln(""""singledoafterterminate""""))subscribe(new testsubscriber<string>())```i would expect the following to be printed to the console:> singledoafterterminate> singleflatmapdoafterterminatehowever only the following is printed to the console> singledoafterterminatewhen i do the same with an observable``` javaobservablejust(""""test"""")    flatmap(s -> observablejust(""""test2"""")        doafterterminate(() -> systemoutprintln(""""observableflatmapdoafterterminate""""))     )doafterterminate(() -> systemoutprintln(""""observabledoafterterminate""""))subscribe(new testsubscriber<string>())````i see the following printed to the console:> observabledoafterterminate> observableflatmapdoafterterminate"";interesting || thanks for reporting see #3883 for a fix || this works for me ||;1;0;1x: fix multiple chained singledoafterterminate not calling actions;"
"3886;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;throwiffatal() now throws oncompletedfailedexception;otherwise  if there s an error in oncompleted  the exception is swallowed and unreported.  3885;;388.0;throwiffatal() now throws oncompletedfailedexception;otherwise if theres an error in oncompleted the exception isswallowed and unreported3885; ;program using interval and take does not terminate;""when i run the following snippet:``` javastatic action1<long> onnextfunc(final string who) {    return new action1<long>() {        public void call(long x) {            systemoutprintln(who + """" got """" + x)        }                }}static action1<throwable> onerrorfunc(final string who) {    return new action1<throwable>() {        public void call(throwable t) {            tprintstacktrace()        }                }}    static action0 oncompletefunc(final string who) {    return new action0() {        public void call() {            systemoutprintln(who + """" complete"""")        }                }}public static void main(string args) {    observable<long> onenumberpersecond  observableinterval(1 timeunitseconds)take(5)    onenumberpersecondsubscribe(onnextfunc(""""subscriber 1"""") onerrorfunc(""""subscriber 1"""") oncompletefunc(""""subscriber 1""""))}```then i get (as expected) the following output:```subscriber 1 got 0subscriber 1 got 1subscriber 1 got 2subscriber 1 got 3subscriber 1 got 4subscriber 1 complete```however the program does not terminate and thats unexpectedi ran this test using `rxjava-core-0132-snapshotjar` built from commit 00d7c3b009053e6d5472f8bcb438e268a3d3c70b (sat sep 14 08 09 2013 -0700)due to this problem some tests in the [`rxscalademo`]( that im working on do not terminate which is annoying"";""just replicated it  taking a look to see if i can find the cause || the `operationinterval` class was creating a new `executorservice` on every invocation and that is never shut down and launches non-daemon threads``` javaschedulersexecutor(executorsnewsinglethreadscheduledexecutor())```changing that the demo code now doesnt even run as the app quits immediately as its all async (as it should)i revised the example to use `blockingobservable` for the demo (this and unit tests are where i generally use `blockingobservable`) and it runs then exits nicely``` java    public static void main(string args) {        observable<long> onenumberpersecond  observableinterval(1 timeunitseconds)take(5)        onenumberpersecondtoblockingobservable()foreach(onnextfunc(""""subscriber 1""""))    }```ill submit a fix shortly || thanks now it behaves as id expect but the example id like to get to work still doesnt because of problems with groupby   || "";1;0;throwiffatal() now throws oncompletedfailedexceptionotherwise if theres an error in oncompleted the exception isswallowed and unreported;"
3887;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;have undeliverable errors on subscribe() sent to plugin error handler.;this change will make sure if the  subscriber  has unsubscribed  the non-fatal error is sent to the plugin error handler at least. i.e.       java observable.create(s -> {     s.onerror(new runtimeexception())      throw new illegalargumentexception()  }).subscribe()       in addition  if the original code threw  runtimeexception  in case the  subscriber.onerror()  threw. i ve changed this to  onerrorfailedexception  but not sure the original type was intentional or just left out.;;0;have undeliverable errors on subscribe() sent to plugin error handler;this change will make sure if the `subscriber` has unsubscribed the non-fatal error is sent to the plugin error handler at least ie``` javaobservablecreate(s -> {    sonerror(new runtimeexception())    throw new illegalargumentexception()})subscribe()```in addition if the original code threw `runtimeexception` in case the `subscriberonerror()` threw ive changed this to `onerrorfailedexception` but not sure the original type was intentional or just left out;;;;;1;1;have undeliverable errors on subscribe() sent to plugin error handler;
3888;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: proposal: onterminatedetach - detach upstream/downstream for gc;by default  operators have final link to their child subscriber and they never clear the upstream s producer. if the end subscriber is referenced  for example in a  compositesubscription   that keeps an entire chain of objects alive and can cause memory leaks (a use case common on android).  this proposed operator detaches the structures and nulls out references if the sequence terminates or the downstream unsubscribes - at the cost of atomic operations and mandatory volatile read for each onnext().   i know this issue has been brought up several times  but instead of adding the overhead to every operator  i propose an operator that can be applied when the developer really needs it (i.e.  could be part of the usual compose(subscribeon/observeon) setup).  on the implementation side  this requires deferred  producer / request()  handling because requests from downstream may appear even before the upstream calls  setproducer  (if at all) and we can t use the base class  behavior for this.;;0;1x: proposal: onterminatedetach - detach upstream/downstream for gc;by default operators have final link to their child subscriber and they never clear the upstreams producer if the end subscriber is referenced for example in a `compositesubscription` that keeps an entire chain of objects alive and can cause memory leaks (a use case common on android)this proposed operator detaches the structures and nulls out references if the sequence terminates or the downstream unsubscribes - at the cost of atomic operations and mandatory volatile read for each onnext() i know this issue has been brought up several times but instead of adding the overhead to every operator i propose an operator that can be applied when the developer really needs it (ie could be part of the usual compose(subscribeon/observeon) setup)on the implementation side this requires deferred `producer`/`request()` handling because requests from downstream may appear even before the upstream calls `setproducer` (if at all) and we cant use the base class behavior for this; doesnt proper `subscription` nulling and/or `compositionexception` clearing solve this? i havent seen a lot of people complaining about leaks recently is something motivating this? || what ive seen in android examples is that you add to a composite on creation and clear() the composite on destroy but havent seen the subscriber removed from the composite when it finishes normally but still while the activity is active || ah i see and that leaks the observable itself not the activityon tue may 3 2016 at 4:18 pm david karnok notifications@githubcomwrote:> what ive seen in android examples is that you add to a composite on> creation and clear() the composite on destroy but havent seen the> subscriber removed from the composite when it finishes normally but still> while the activity is active> > > you are receiving this because you commented> > reply to this email directly or view it on github>  ||;;;;1;1;1x: proposal: onterminatedetach - detach upstream/downstream for gc;
3898;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: add missing license headers;this pr simply adds missing license header to main and test files.;;0;1x: add missing license headers;this pr simply adds missing license header to main and test files; was always curious if this really required if repo has `license` file and it referenced in the `pomxml`? || 99% of people copy/pasting code from this project arent going to look ateither those things to retain the correct licenseon fri apr 29 2016 at 4:04 pm artem zinnatullin notifications@githubcomwrote:> was always curious if this really required if repo has license file and> it referenced in the pomxml?> > > you are receiving this because you are subscribed to this thread> reply to this email directly or view it on github>  ||;;;;1;1;1x: add missing license headers;
3904;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: fix completable swallows onerrornotimplementedexception;fixed https://github.com/reactivex/rxjava/issues/3860;;0;1x: fix completable swallows onerrornotimplementedexception; https://githubcom/reactivex/rxjava/issues/3860;looks good :+1:i wonder shouldnt we switch to `exceptionsthrowiffatal` as in `observable`? of course the whole `completable` needs rechecking || updated to use `exceptionsthrowiffatal`  ;;;;1;1;1x: fix completable swallows onerrornotimplementedexception;
"3907;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: doonunsubscribe javadoc clarifications;see #3877;;387.0;1x: doonunsubscribe javadoc clarifications;see #3877;;zip calls onnext later than c#s zip does;""in the c# example below the zipped observable completes as soon as o3 has completed because all of o3s elements have been paired with an element from o6``` csstatic void main() {    var o3  observableinterval(timespanfrommilliseconds(1000))take(3)    var o6  observableinterval(timespanfrommilliseconds(1000))take(10)    var watch  new stopwatch()    watchstart()    observablezip(o3 o6)subscribe(        list > consolewriteline(""""("""" + list[0] + """" """" + list[1] + """") at t"""" + watchelapsedmilliseconds)         e > consolewriteline(estacktrace)        () > consolewriteline(""""complete at t"""" + watchelapsedmilliseconds)    )    consolereadline()}```outputs```(0 0) at t1055(1 1) at t2045(2 2) at t3047complete at t4058```in the corresponding java code however the zipped observable only completes once both o3 and o6 have completed``` javastatic func2<long long long> zipfunc  new func2<long long long>() {    public long call(long n1 long n2) {        if (n1equals(n2)) {            return n1        } else {            throw new runtimeexception(""""numbers not equal"""")        }    }}public static void main(string args) {    observable<long> o3  observableinterval(1000 timeunitmilliseconds)take(3)    observable<long> o6  observableinterval(1000 timeunitmilliseconds)take(10)    final long starttime  systemcurrenttimemillis()    observablezip(o3 o6 zipfunc)subscribe(        new action1<long>() { public void call(long n) {             systemoutprintln(n + """" at t"""" + (systemcurrenttimemillis()-starttime))        }}        new action1<throwable>() { public void call(throwable t) {            tprintstacktrace()        }}        new action0() { public void call() {            systemoutprintln(""""complete at t"""" + (systemcurrenttimemillis()-starttime))        }}    )}```outputs```0 at t10191 at t20192 at t3019complete at t10019```id like rxjava to follow c# here unless there are very good reasons against doing sothis difference becomes even more important if one of the observables never completes: then the zipped observable never completes either which was very unexpected for me"";""this unit test demonstrates the issue:``` java        @test        public void testonfirstcompletion() {            publishsubject<string> oa  publishsubjectcreate()            publishsubject<string> ob  publishsubjectcreate()            @suppresswarnings(""""unchecked"""")            observer<string> observer  mock(observerclass)            observable<string> o  observablecreate(zip(oa ob getconcat2strings()))            osubscribe(observer)            inorder inorder  inorder(observer)            oaonnext(""""a1"""")            inorderverify(observer never())onnext(anystring())            obonnext(""""b1"""")            inorderverify(observer times(1))onnext(""""a1-b1"""")            obonnext(""""b2"""")            inorderverify(observer never())onnext(anystring())            oaonnext(""""a2"""")            inorderverify(observer times(1))onnext(""""a2-b2"""")            oaonnext(""""a3"""")            oaonnext(""""a4"""")            oaonnext(""""a5"""")            oaoncompleted()            // assert we complete the zip stream here            inorderverify(observer times(1))oncompleted()            obonnext(""""b3"""")            obonnext(""""b4"""")            obonnext(""""b5"""")            obonnext(""""b6"""")            obonnext(""""b7"""")            // never completes (infinite stream for example)            // we should receive nothing else despite ob continuing after oa completed            inorderverifynomoreinteractions()        }``` || i need to play more with the c# version before i finish the changes as fixing this unit test could be done in different ways and the most obvious one breaks other unit tests || branch with unit test at  || hello ive ported my zip implementation and it appears to be doing almost the expected behavior:  at t10161 at t20162 at t3017complete at t3017the difference to rx seems to be that it terminates right after the 3rd item whereas rxnet after rejecting the 4th item of the second observable || i believe this is  in  thanks to @akarnokd  || "";1;0;1x: doonunsubscribe javadoc clarifications;"
3909;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: single.retrywhen javadoc clarifications;see #3774;;0;1x: singleretrywhen javadoc clarifications;see #3774;;;;;1;1;1x: singleretrywhen javadoc clarifications;
3918;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: replaysubject now supports backpressure;in addition  the behavior of time-limited mode has been changed. late subscribers will now skip stale data.  related issue: #3917;;0;1x: replaysubject now supports backpressure;in addition the behavior of time-limited mode has been changed late subscribers will now skip stale datarelated issue: #3917;would it be possible to split this up into a couple commits? github wont show the diff in its current state and says to view locally || no replaysubject has simply too many expected features: unbounded size bounded and size+time bounded modes each adding 100s of lines it is fully rewritten so comparison wouldnt do much help || this makes it very difficult to review what do you propose @akarnokd ? || check out and have your ide compare this pr against the master version || > late subscribers will now skip stale datadoes this mean that subscribers were not skipping stale data? this change sounds like fixing a bug? || in the original once the source completed the current elements in the bounded buffers were frozen in time late subscribers would get all the data including those who have become older by the time these subscriptions happen same was true for live but inactive replays where a subscriber would start from an outdated element these were expected by the unit tests but #3917 expected only fresh data || ;;;;1;1;1x: replaysubject now supports backpressure;
3919;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: subscriber.not_set long -> long  saves an unboxing per instance;somehow  subscriber.not_set was object  long  instead of primitive  long .;;0;1x: subscribernot_set long -> long saves an unboxing per instance;somehow subscribernot_set was object `long` instead of primitive `long`;a tiny win but a win no less  it bothered me for some time now seeing the long there this is not just about the unboxing but remove the indication that `not_set` can be null for meaningful reasons ||  looks like my bad from last year thanks  ;;;;1;1;1x: subscribernot_set long -> long saves an unboxing per instance;
3931;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: add groupby overload with evictingmapfactory;i have a long running stream using  groupby  that over time will accumulate 10s of millions of keys. if i can specify an evicting map to  groupby  then i ll be able to keep it down to ~10 000 keys.   this pr supports this use case and could be used with guava s  cachebuilder  like this:      java func1<action1<k>  map<k  object>> mapfactory =      action -> cachebuilder.newbuilder()               .maximumsize(1000)               .expireafteraccess(12  timeunit.hour)               .removallistener(key -> action.call(key))               .<k  object> build().asmap()  observable     .groupby(keyselector  elementselector  mapfactory)           i ll enhance this pr with more unit tests if this looks a good direction.;;0;1x: add groupby overload with evictingmapfactory;i have a long running stream using `groupby` that over time will accumulate 10s of millions of keys if i can specify an evicting map to `groupby` then ill be able to keep it down to ~10000 keys this pr supports this use case and could be used with guavas `cachebuilder` like this:``` javafunc1<action1<k> map<k object>> mapfactory      action -> cachebuildernewbuilder()              maximumsize(1000)              expireafteraccess(12 timeunithour)              removallistener(key -> actioncall(key))              <k object> build()asmap()observable    groupby(keyselector elementselector mapfactory)    ```ill enhance this pr with more unit tests if this looks a good direction;this pr may be useful still but ive realised i can get what i want with more control using `defer` `publishsubject` and `takeuntil` on the grouped observables || yes you can `timeout` or `takeuntil` on each group to get it removed from the internal map im not sure about the map factory because we need something concurrently modifiable || yep youre right but i put that requirement in the javadoc and the examplemap from cachebuilder is threadsafeon fri 13 may 2016 03:24 david karnok notifications@githubcom wrote:> yes you can timeout or takeuntil on each group to get it removed from> the internal map im not sure about the map factory because we need> something concurrently modifiable> > > you are receiving this because you authored the thread> reply to this email directly or view it on github>  || im happy using `timeout` with my use case now but ill leave this pr up for a few days to see if anyone else has a use case || @akarnokd  i think theres a catch with `timeout` im using it as below but i believe i could lose an emission due to timeout cutting in on say the processing occurring in `operator1`:``` javaogroupby()  flatmap(    g ->         goperator1()         timeout(10 timeunitseconds)         onerrorresumenext(completeontimeoutexception)))```i guess ill have to use `timeout` or `timer` in a different way so it doesnt shortcut an in-flight emission have i got this right? || yes there  is  chance values get dropped when an emission and group unsubscribe happens at the same time you cant know the value made it or not if your value has its own lifecycle thats going to be a problem rx is not designed for that and its the next challenge of the field - especially since reactive-io is full of life-cycle managed buffers || > if your value has its own lifecycle thats going to be a problem rx is not designed for that and its the next challenge of the field - especially since reactive-io is full of life-cycle managed buffersyour absolutely right that my use case has some special lifecycle that im trying to manage with `groupby` its an event sourcing/cqrs  use case where emissions upstream of `groupby` are persisted (you knew io was part of the scenario you perceptive fellow) and whenever a `groupby` emitted `groupedobservable` is subscribed to (or resubscribed to) the stream starts with the events already recorded for that key (read from disk) before processing the incoming event from upstream it does seem to me now that if i dont want to lose emissions for my use case (and want to keep the `groupby` keys down in numbers) then i have to record information about groups upstream of `groupby` and possibly modify the upstream to include some sort of keyed sentinel to tell the `groupedobservable` to complete based on last access time for a key for instance **or** i just use the modified `groupby` in this prill progress the implementation of the use case and see what else turns up || if you want to pursue this further please rebase it || yep id like to pursue this one this pr is not great to put in an external library because it is so coupled to the groupby implementation and its tests ill fix the api and i realize i may also need to put try-catch on `mapfactorycall` and `mapget` and `mapput` calls with some specific error handling (catching fatal errors calling onerror etc) ill have a look at itid also like to use the guava `cachebuilder` in unit tests can i add that test dependency? || im not against adding `testcompile` entries hopefully guava doesnt drag in too many other libraries || guava only has a few optional dependencies that i wouldnt include and the current version 190 still supports java 6 || great! ||    oops merged in a `buildgradle` change and broke this could you rebase again?/cc @artem-zinnatullin @stevegury for review on this || thanks for the review @artem-zinnatullinive addressed your comments and theres one little addition which is the rename of one of the test methods to use camel case and a number to differentiate from `testgroupbybackpressure` (`testgroupbybackpressure` -> `testgroupbybackpressure2`) ||  i take it that being an api enhancement this pr still requires one more collaborator approval? || oh and thanks @stevegury for giving it a look! || thanks @davidmoten for the contribution! ||;;;;1;1;add groupby overload with evictingmapfactory;
3934;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: testsubscriber extra info on assertion failures;this pr adds extra information to assertion failure messages on  testsubscriber  and  testobserver   indicating: - the listener didn t receive any  oncompleted  calls  which is an indication of hung or skipping operation  - there were errors received  indicating a failure in the event generation process.  previously  if there was something wrong with the sequence  the order and type of assertions were mostly unhelpful: if  assertvalues  was first  the lack of values failure could hide a revealing onerror call. if the  assertnoerrors()  was first  the error is visible but no way of knowing how far the sequence got.  now  it is generally okay to use  assertvalues  first  which along the difference  will print the lack of completion and the number of exceptions received  plus  the  assertionerror  will have its cause initialized to the actual or composited exception. the message format thus changes:      original assertion message with details (0 completions) (+1 error)  caused by ...      this extra information saved me a lot of time in 2.x and rsc development.  note that this change doesn t make the  assertxxx s also assert for completion or error at all. if the values match  but there is an additional error instead of completion  one has to assert that separately  just like now.;;0;1x: testsubscriber extra info on assertion failures;this pr adds extra information to assertion failure messages on `testsubscriber` and `testobserver` indicating:- the listener didnt receive any `oncompleted` calls which is an indication of hung or skipping operation- there were errors received indicating a failure in the event generation processpreviously if there was something wrong with the sequence the order and type of assertions were mostly unhelpful: if `assertvalues` was first the lack of values failure could hide a revealing onerror call if the `assertnoerrors()` was first the error is visible but no way of knowing how far the sequence gotnow it is generally okay to use `assertvalues` first which along the difference will print the lack of completion and the number of exceptions received plus the `assertionerror` will have its cause initialized to the actual or composited exception the message format thus changes:```original assertion message with details (0 completions) (+1 error)caused by```this extra information saved me a lot of time in 2x and rsc developmentnote that this change doesnt make the `assertxxx`s also assert for completion or error at all if the values match but there is an additional error instead of completion one has to assert that separately just like now;this is great! || added newline and plural/singular form ||  this is really awesome ||;;;;1;1;add plural/singular form;
3936;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: promote unicastsubject to be a standard+experimental subject;plus  the unsubscribe indirection has been inlined  making  state  implement  subscription  directly (instead of  action0  +  subscriptions.create ).;;0;1x: promote unicastsubject to be a standard+experimental subject;plus the unsubscribe indirection has been inlined making `state` implement `subscription` directly (instead of `action0` + `subscriptionscreate`); ;;;;1;1;1x: promote unicastsubject to be a standard+experimental subject;
"3941;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: fix single.flatmap not composing subscription through;see #3940.;;3940.0;1x: fix singleflatmap not composing subscription through;see #3940; ;tosingle() leaks subscriber if followed by flatmap;""not sure this is a correct test let me know if i can provide any extra information```    private subscriber<? super object> subscriber    @test public void thistestpasses() throws exception {        final subscription subscribe  observablecreate(subscriber -> {            thissubscriber  subscriber        })subscribeon(schedulersio())flatmap(o -> observablejust(""""""""))tosingle()subscribe()        subscribeunsubscribe()        assertthat(subscriberisunsubscribed())istrue()    }    @test public void thistestfails() throws exception {        final subscription subscribe  observablecreate(subscriber -> {            thissubscriber  subscriber        })subscribeon(schedulersio())tosingle()flatmap(o -> singlejust(""""""""))subscribe()        subscribeunsubscribe()        assertthat(subscriberisunsubscribed())istrue()    }```"";thanks for reporting indeed this is a bug in `singleflatmap` fix pr in #3941  ||;1;0;1x: fix singleflatmap not composing subscription through;"
3942;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: add completable.safesubscribe option + rxjavaplugins hook support;add option to safely subscribe a  completablesubscriber  / regular  subscriber  and handle  onxxx  failures.  see also: #3938  naming and whether or not the safe wrapping should be the default is open to discussion.;;3938.0;1x: add completablesafesubscribe option + rxjavaplugins hook support;add option to safely subscribe a `completablesubscriber` / regular `subscriber` and handle `onxxx` failuressee also: #3938naming and whether or not the safe wrapping should be the default is open to discussion;in my opinion safe wrapping should be the default as its the default in `observable` and `single` at least the 3 should behave the same way when using them one should expect them to have a difference in their essential semantics and not in these kind of things || should the tests about error handling plugin in #3938 be here? or we leave it in that pr? || @bryant1410 your pr has a test failure:```rxpluginsrxjavapluginstest > testonerrorwhenusingcompletable failed    javalangassertionerror: expected:<javalangruntimeexception: test onerror> but was:<null>        at orgjunitassertfail(assertjava:93)        at orgjunitassertfailnotequals(assertjava:647)        at orgjunitassertassertequals(assertjava:128)        at orgjunitassertassertequals(assertjava:147)        at rxpluginsrxjavapluginstesttestonerrorwhenusingcompletable(rxjavapluginstestjava:314)``` ||  typo renamed methods || @akarnokd they fail on purpose because i made the test but didnt fix the problem (completable is not calling the error handling plugin) || the methods should be the other way around following `single` and `observable` there should be a single `unsafesubscribe` method which accepts a parameter of type `completablesubscriber` and `subscribe` should be present in the following ways: `subscribe()` `subscribe(action0)` `subscribe(action1<? super throwable> action0)` `subscribe(subscriber)` and `subscribe(completablesubscriber)` || the `subscribe()` methods wrap with `safecomletablesubscriber` similar to how observablesubscribe wraps with `safesubscriber` subscribe(subscriber) is there to allow conversion and cross-type apis to bypass the safety overhead || updated with plugin support || can you cherry-pick the [commit that adds tests for the error handling plugn in `completable` and `single`]( from #3938? || sure || done || the comment `// todo plugin wrapping onsubscribe` in `completable#create` can be deleted as the constructor is already calling the hook now  || removed comment changed to reuse methods added onstart call || please add the missing `@experimental` otherwise  added missing annotations || ;1x: add missing error handler call in completable;;why do you think its missing? in operators only undeliverable exceptions are supposed to be sent to the global handler || im not pretty sure if this call to the handler goes there but it arises from using the retrofits rxjava adapter and realizing that completables endpoints errors are not caught by an error handler while observables and singles are || interesting could be that completable doesnt use safesubscriber which is responsible to deliver some errors thrown by onxxx methods to be sure could you add a unit test that demonstrates how single gets your exception and how completable isnt? || okey || i think this comment is related: [completablejava#l1968]( from what i see `completable` in a different way to `observable` and `single` does calls to the error handler plugin by itself instead of delegating it to a `safecompletablesubscriber` (which btw doesnt exist) why there is no safe subscriber for `completable` and why is this done this way?the call to the handler is missing from `onerror` in `subscribe(action1<? super throwable> action0)` `subscribe(completablesubscriber)` and `subscribe(subscriber)` methods but `subscribe()` and `subscribe(action0)` have it this should be refactored to have just one place for calling the handler as in `observable` and `single` || completable was designed with a modern mindset where end-completablesubscribers are not expected to throw from the onxxx methods but apparently there was no safesubscribe() added to the api the current 1x convention is to have subscribe() do additional safeguards and have an unsafesubscribe() as direct as possible || see #3942 for other forms of handling errors || closing via #3942 ||;1;0;added @experimental annotations;
3944;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix exception message from observer to subscriber;;;0;fix exception message from observer to subscriber;;  ;;;;1;1;fix exception message;
3948;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;add completable.andthen(completable)  deprecate endwith();see #3947;;3947.0;add completableandthen(completable) deprecate endwith();see #3947;please update unit tests that use these deprecated methods || done ||   but id either duplicate tests or make universal test functions and test both `endwith` and `andthen` to make sure that we dont break old behavior of public api  || the question is also since completable is still `@experimental` we could if this is wanted go the hard way and remove the deprecated methods and make everyone force to use the standard (new) methods since there are already quite a few deprecated / duplicated methods ||  > but id either duplicate tests or make universal test functions and test both endwith and andthen to make sure that we dont break old behavior of public api@artem-zinnatullin im not against it but this is really minor as `andthen` just calls `endwith` im going to merge this feel free to add tests in a separate pr if you wish ||;request: completableandthen(completable);to match `completable#andthen(observable<t> next)` and `completable#andthen(single<t> next)` it would be nice if there were an operator like this:`completable#andthen(completable next)`unless there is some other way to achieve the same functionality right now;there is the `endwith` operator for this purpose but you can post a pr renaming it || @akarnokd thanks for the quick reply posted a pr for that just a quick question what about `endwith(observable<t> next)` should that stay or should there also be `andthen` used? || you can deprecate that as well || alright thanks i updated the pr let me know whether i should squash commits and change commit message to match the new updated title or whether youll use the github squash and merge functionality || no need for squashing on your end || closing via #3948 ||;1;0;adjust tests;
3949;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: javac- and javadoc-related cleanup in components  part 1;my eclipse warned me about several hundred javac and javadoc errors which could hide other significant warnings. this pr is the first part to fix those warnings. note that  observable  and  single  itself is full of those as well (several hundred in each).;;0;1x: javac- and javadoc-related cleanup in components part 1;my eclipse warned me about several hundred javac and javadoc errors which could hide other significant warnings this pr is the first part to fix those warnings note that `observable` and `single` itself is full of those as well (several hundred in each);:+1:thanks for getting this done ||;;;;1;1;1x: javac- and javadoc-related cleanup in components part 1;
3951;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: javac- and javadoc-related cleanup in components  part 2;next round of cleanup  still about 100 cases remain in  completable  and  observable   but those will most likely conflict with open prs.;;0;1x: javac- and javadoc-related cleanup in components part 2;next round of cleanup still about 100 cases remain in `completable` and `observable` but those will most likely conflict with open prs; ;;;;1;1;1x: javac- and javadoc-related cleanup in components part 2 final;
3966;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: add multi-other withlatestfrom operators;add  withlatestfrom  operator version that can take 2 to n other sources and combine them with the main source.  related: #3779.;;3779.0;1x: add multi-other withlatestfrom operators;add `withlatestfrom` operator version that can take 2 to n other sources and combine them with the main sourcerelated: #3779;;withlatestfrom interface inconsistent with combinelatest;why withlatestfrom has only 1 calling signature while combinelatest has plenty of convenient overload for combining multiple observables  should it be the same or this is by design?;how would you imagine those missing forms of `withlatestfrom` especially in their behavior? || does this make sense?```a$withlatestfrom(b$ c$ d$ new func4<abcd>{// use a b c d relying on timing emit by a only})``` || would you like to submit a pr? || i would love to if i have some spare time  i look into the code a bit and found out that combinelatest is just thin wrapper of onsubscribecombinelatest factory inside observable class  the test is done on onsubscribecombinelatest class itself the factory methods are untested  it will be trivial if i can just create an overload by the calling exist (current) withlatestfrom method multiple times to aggregate the value one by one in observable class without additional test on the overloads  is this the way to go?  if yes you can expect me to send the pr eventually(dont know when if anyone want it fast feel free to pick it up it is just convenient overloads after all we can continue working without it)  if no please give me your opinion about my proposed method at least i will learn a thing or two from this issue  || no you have to work from `withlatestfrom` with more sources subscribers and current values || yep thats the reply i expectedby looking at the code i have to integrate iterable into the operator classfor sure it will be easier than combinelatest implementation but i dont know concurrency concerns and proper way (exist method/pattern) to handle it inside rxjava that wellso it will require more time digging into the code i dont even sure if i am able to do itso i will say dont expect pr from me anytime soonthank you for your feedback || do you have an use case for such an operator? id say it is uncommon and id guess the original [request]( for `withlatestfrom` didnt mention a multi-source versionyou can achieve an effect with some tuple types:``` javasourcewithlatestfrom(b (a b) -> pairof(a b))withlatestfrom(c (ab c) -> funccall(aba abb c))``` || sorry for the delayyes this is coming from a real use casei use withlatestfrom heavily to handles observable from user (eg button pressed)the actual case i am facing is a bit complicate but i can give you one common concrete case of multiple withlatestfrom usage it is for handle (says) form validation and submitif all fields in form are valid the submit button will be enabled and when user press submit button all value emit from field observables will form the server requestwithlatestfrom will be used for field observables compilation based on timing of button press in this casethank you for pair suggestion but i already go with sparsearray (list map will work the same way too but sparsearray just fit the bill in my case) the downsize is losing type safety but it is so local so i am ok with it || i also have a use case for that basically i want to get latest state of several observables when main trigger event happensi approached it by creating observable that is `combinelatest` of all the secondary observables and then used it as an argument for `withlatestfrom` unfortunately it involved creating of mostly useless holder object just to feed last items of several observables into `withlatestfrom`i guess the better way would be to use `combinelatest` chained  distinctuntilchanged(selector)` where selector would return items of trigger observable || i have a use case for this in the current project i am using reactive sensors to keep track of motion position env and location sensors location sensor is the driving sensor others use `window(locationobservable)` to then compute min max avg for the windowed list for x y z because location is the driver i was hoping that i could do:`locationobservablewithlatestfrom(positionobs motionobs envobs (location position motion env) -> sensorpoint::new)`but it only takes just one observable || see #3966 || added via #3966 ||;1;0;1x: add multi-other withlatestfrom operators;
"3971;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: request rebatch operator;this is a follow-up on #3964 but with a separate operator on  observable .;;3964.0;1x: request rebatch operator;this is a follow-up on #3964 but with a separate operator on `observable`; @abersnaze @stealthcode you had some use cases for this any objections? || the reuse of the observeon is interesting but couldnt it be done without the allocation of a queue? || if the downstream request is unbounded and the downstream has caught up then the queue can be skipped in this case `observeon` cant be reused anymore and a custom drain logic has to be implementedotherwise the upstream emissions have to be stored temporarily for an underrequesting downstream ||  i know that @abersnaze still had reservations about this i think that this should not be using `observeon` || my concern is this - if @abersnaze implemented the batching functionality then why wouldnt we use that? the queue in observeon scheduling creates a layer of indirection that seems unnecessary  || remember this started out as a change to `observeon` to not ignore the `immediate` scheduler but people wanted this behavior exposed behind a proper name || thanks for reminding me of the context of this work it seems like we have 2 implementations for the same functionality i think @abersnaze and i agree that the 2 features of request batching and request valve type functionality could be composed however i think that using `observeon` for this functionality is not necessarily the best way to accomplish this  || i personally would be okay with either implementation i think `observeon` is a nice choice because of the request management but would prefer it more if there wasnt a queue but realistically i think the choice is fine also its interesting to note that users are gravitating more and more to taking direct control over the `requester-producer` interactions  || for example this pr does something similar but exactly n (could be modified to have optional 25%) and without a queue #3781  ||;1x: observeon + immediate scheduler to be a request rebatcher;""this pr removes the `immediate()` scheduler """"optimization"""" from `observeon` and treats it as a common scheduler since `observeon` has a stable request pattern this turns it into a rebatching operator no matter what the downstream requests the upstream will requests of the specified size (with 25% as low water mark ie replenishment after 75%) since `immediate` is synchronous this will run the drain loop non-reentrant on the caller threadi found this mode of operation very handy in my reactive-rpc prototype and a simple streaming echo rpc call it prevents going unbounded and bloating the message sender threads:``` java// remotepublic observable<integer> echo(rpcstreamcontext<?> ctx observable<integer> in) {   return inobserveon(schedulersimmediate() 16)}// clientapiecho(observablerange(1 100_000))observeon(schedulersimmediate() 32)subscribe(systemout::println throwable::printstacktrace)```"";great! what about adding a method to `observable` that calls it so this functionality is discoverable? say `observablebatchrequests(n)`? || that could be a follow-up pr if this gets accepted || why not just adding a `batchrequests` operator instead of changing the existing behavior? this probably affects some users applications if they depends on the optimizationsecondly using `observeon(schedulersimmediate() 16)` and assuming how it implements is not reliable this is not an api contract and it could be changed in any time || the alternative requires duplicating code which triggers more outcry usually || i think you can add a flag (eg disallowoptimization) to `operatorobserveon` and use it for `batchrequests` ||;1;0;fix javadoc add experimental;"
3974;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: add terminal clarification to switchmap operators;see #3576 .;;3576.0;1x: add terminal clarification to switchmap operators;see #3576;;clarify behaviour in javadoc of switchonnext() with respect to completions;the javadoc of `switchonnext()` doesnt currently say anything about how the resulting observable will complete the marble diagram implies (but not totally clearly) that if an inner observable completes after an outer `onnext()` that completion is swallowed and if an inner observable completes after the outer observable completes that the resulting observable also completeshowever theres no info about what happens in an inner observable completes _before_ an outer `onnext()` does the resulting observable complete at that point or not?ive read the tests and it seems the answer is that the resulting observable will complete exactly when the following happen in this order:1 the outer observable completes (implying that the current inner observable will never be switched to any other)2 the current inner observable completesand that the resulting observable wont complete under any other circumstancesfirstly is my understanding correct and secondly can the javadoc be improved?;if i have understood things correctly id be happy to submit a pr clarifying the javadoc || prs are welcome! || see #3974  ||;1;0;1x: add termination clarification to switchmap operators;
"3977;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: use the correct throwable to set the cause for compositeexception;the cause of #3679 is we use a wrong throwable (its cause has been set) to set the cause and  initcause  will throw an exception. hence  the cause chain is not created correctly. in this pr  it searches the root cause (which doesn t have a cause) and use it to call  initcause .;;3679.0;1x: use the correct throwable to set the cause for compositeexception;the cause of #3679 is we use a wrong throwable (its cause has been set) to set the cause and `initcause` will throw an exception hence the cause chain is not created correctly in this pr it searches the root cause (which doesnt have a cause) and use it to call `initcause`; ;actual exception is being hidden by onerrorfailedexception;""using rxjava 110 (and similar issue on 1015) i stumbled upon a mysterious stack trace that made no sense in my app after a lot of debugging i found that rxjava will report the wrong exception in some scenarios for example if you run this sample code:```observablejust(1)doonnext(new action1<integer>() {        @override public void call(integer val) {            throw new illegalstateexception(""""doonnextexception"""")        }    })retrywhen(new func1<observable<? extends throwable> observable<?>>() {        @override public observable<?> call(observable<? extends throwable> errorobservable) {            return errorobservableflatmap(new func1<throwable observable<?>>() {                @override public observable<?> call(throwable throwable) {                    return observablejust(3)delay(1 timeunitseconds)doonnext(                            new action1<integer>() {                                @override public void call(integer integer) {                                    throw new unsupportedoperationexception(""""retry exception"""")                                }                            })                }            })        }    })subscribe(new subscriber<integer>() {        @override public void oncompleted() {            logv(""""ex"""" """"oncompleted"""")        }        @override public void onerror(throwable e) {            logv(""""ex"""" """"onerror"""")            throw new illegalthreadstateexception()        }        @override public void onnext(integer integer) {            logv(""""ex"""" """"onnext"""")        }    })```the expected behaviour should be that `illegalthreadstateexception` (thrown within the `onerror` handler of the subscriber) is included as the cause however the actual stack trace contains `unsupportedoperationexception` as the cause - which is not the problem in the code snippet above the `unsupportedoperationexception` is totally fine but the problem arises when `onerror` throwsthis leads to a stack trace that points to the wrong cause and does not include the actual cause (which would be the `illegalthreadstateexception`) if i removed the `retrywhen()` block - then the stack trace correctly includes `illegalthreadstateexception` as the exception from within `onerror`the (incorrect) trace from the code snippet above:```process: comexamplemydemoapp pid: 14118javalangillegalstateexception: fatal exception thrown on schedulerworker thread    at rxinternalschedulersscheduledactionrun(scheduledactionjava:62)    at javautilconcurrentexecutors$runnableadaptercall(executorsjava:422)    at javautilconcurrentfuturetaskrun(futuretaskjava:237)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskaccess$201(scheduledthreadpoolexecutorjava:152)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:265)    at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1112)    at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:587)    at javalangthreadrun(threadjava:818) caused by: rxexceptionsonerrorfailedexception: error occurred when trying to propagate error to observeronerror    at rxobserverssafesubscriber_onerror(safesubscriberjava:194)    at rxobserverssafesubscriberonerror(safesubscriberjava:120)    at rxinternaloperatorsonsubscriberedo$4$1onerror(onsubscriberedojava:331)    at rxinternaloperatorsoperatormerge$mergesubscriberreporterror(operatormergejava:240)    at rxinternaloperatorsoperatormerge$mergesubscribercheckterminate(operatormergejava:776)    at rxinternaloperatorsoperatormerge$mergesubscriberemitloop(operatormergejava:537)    at rxinternaloperatorsoperatormerge$mergesubscriberemit(operatormergejava:526)    at rxinternaloperatorsoperatormerge$innersubscriberonerror(operatormergejava:810)    at rxinternaloperatorsoperatordooneach$1onerror(operatordooneachjava:71)    at rxexceptionsexceptionsthroworreport(exceptionsjava:187)    at rxinternaloperatorsoperatordooneach$1onnext(operatordooneachjava:82)    at rxinternaloperatorsoperatordelay$1$3call(operatordelayjava:88)    at rxinternalschedulersscheduledactionrun(scheduledactionjava:55)    at javautilconcurrentexecutors$runnableadaptercall(executorsjava:422)    at javautilconcurrentfuturetaskrun(futuretaskjava:237)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskaccess$201(scheduledthreadpoolexecutorjava:152)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:265)    at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1112)    at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:587)    at javalangthreadrun(threadjava:818) caused by: rxexceptionscompositeexception: 2 exceptions occurred     at rxobserverssafesubscriber_onerror(safesubscriberjava:194)    at rxobserverssafesubscriberonerror(safesubscriberjava:120)    at rxinternaloperatorsonsubscriberedo$4$1onerror(onsubscriberedojava:331)    at rxinternaloperatorsoperatormerge$mergesubscriberreporterror(operatormergejava:240)    at rxinternaloperatorsoperatormerge$mergesubscribercheckterminate(operatormergejava:776)    at rxinternaloperatorsoperatormerge$mergesubscriberemitloop(operatormergejava:537)    at rxinternaloperatorsoperatormerge$mergesubscriberemit(operatormergejava:526)    at rxinternaloperatorsoperatormerge$innersubscriberonerror(operatormergejava:810)    at rxinternaloperatorsoperatordooneach$1onerror(operatordooneachjava:71)    at rxexceptionsexceptionsthroworreport(exceptionsjava:187)    at rxinternaloperatorsoperatordooneach$1onnext(operatordooneachjava:82)    at rxinternaloperatorsoperatordelay$1$3call(operatordelayjava:88)    at rxinternalschedulersscheduledactionrun(scheduledactionjava:55)    at javautilconcurrentexecutors$runnableadaptercall(executorsjava:422)    at javautilconcurrentfuturetaskrun(futuretaskjava:237)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskaccess$201(scheduledthreadpoolexecutorjava:152)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:265)    at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1112)    at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:587)    at javalangthreadrun(threadjava:818) caused by: rxexceptionscompositeexception$compositeexceptioncausalchain: chain of causes for compositeexception in order received >    at androidutilloggetstacktracestring(logjava:504)    at comandroidinternalosruntimeinitclog_e(runtimeinitjava:59)    at comandroidinternalosruntimeinitaccess$200(runtimeinitjava:43)    at comandroidinternalosruntimeinit$uncaughthandleruncaughtexception(runtimeinitjava:91)    at javalangthreadgroupuncaughtexception(threadgroupjava:693)    at javalangthreadgroupuncaughtexception(threadgroupjava:690)    at rxinternalschedulersscheduledactionrun(scheduledactionjava:66)    at javautilconcurrentexecutors$runnableadaptercall(executorsjava:422)    at javautilconcurrentfuturetaskrun(futuretaskjava:237)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskaccess$201(scheduledthreadpoolexecutorjava:152)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:265)    at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1112)    at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:587)    at javalangthreadrun(threadjava:818) caused by: javalangunsupportedoperationexception: retry exception    at comexamplemydemoappmainactivity$3$1$1call(mainactivityjava:74)    at comexamplemydemoappmainactivity$3$1$1call(mainactivityjava:72)    at rxobservable$11onnext(observablejava:4445)    at rxinternaloperatorsoperatordooneach$1onnext(operatordooneachjava:80)    at rxinternaloperatorsoperatordelay$1$3call(operatordelayjava:88)    at rxinternalschedulersscheduledactionrun(scheduledactionjava:55)    at javautilconcurrentexecutors$runnableadaptercall(executorsjava:422)    at javautilconcurrentfuturetaskrun(futuretaskjava:237)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskaccess$201(scheduledthreadpoolexecutorjava:152)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:265)    at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1112)    at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:587)    at javalangthreadrun(threadjava:818) caused by: rxexceptionsonerrorthrowable$onnextvalue: onerror while emitting onnext value: 3    at rxexceptionsexceptionsthroworreport(exceptionsjava:187)    at rxinternaloperatorsoperatordooneach$1onnext(operatordooneachjava:82)    at rxinternaloperatorsoperatordelay$1$3call(operatordelayjava:88)    at rxinternalschedulersscheduledactionrun(scheduledactionjava:55)    at javautilconcurrentexecutors$runnableadaptercall(executorsjava:422)    at javautilconcurrentfuturetaskrun(futuretaskjava:237)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskaccess$201(scheduledthreadpoolexecutorjava:152)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:265)    at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1112)    at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:587)    at javalangthreadrun(threadjava:818)```"";""you shoudnt throw from `observeronerror` or `subscriberonerror` but there are safeguards which have to wrap exceptions and deliver it somewhere upstream || > you shoudnt throw from observeronerror or subscriberonerror but there are safeguards which have to wrap exceptions and deliver it somewhere upstreamthis is just an example to illustrate the problem my point was not that there shouldnt be exception my point is that the cause exception that `onerrorfailedexception` wraps is the wrong exception and not the causeinstead the log is of an exception which is already handled this is confusing and can take a lot of time to understand and to find the actual causefor example in my app there is a rare bug somewhere inside my `onerror` handler which causes an exception but i dont know which line inside my handler throws or what exception it throws because i do not see the actual stack trace instead i see the error that caused the `onerror` to be invokedif you run the same example above with the `retrywhen` removed you get the correct exception (note **illegalstateexception** is at the bottom of the stack trace while in the first stack trace above the already-handled **unsupportedoperationexception** is at the bottom of the stack trace):```rxexceptionsonerrorfailedexception: error occurred when trying to propagate error to observeronerror    at rxobserverssafesubscriber_onerror(safesubscriberjava:194)    at rxobserverssafesubscriberonerror(safesubscriberjava:120)    at rxinternaloperatorsoperatordooneach$1onerror(operatordooneachjava:71)    at rxexceptionsexceptionsthroworreport(exceptionsjava:187)    at rxinternaloperatorsoperatordooneach$1onnext(operatordooneachjava:82)    at rxinternalutilscalarsynchronousobservable$1call(scalarsynchronousobservablejava:46)    at rxinternalutilscalarsynchronousobservable$1call(scalarsynchronousobservablejava:35)    at rxobservable$2call(observablejava:162)    at rxobservable$2call(observablejava:154)    at rxobservablesubscribe(observablejava:8191)    at rxobservablesubscribe(observablejava:8158)    at comexamplemydemoappmainactivitytestretryerror(mainactivityjava:65)    at comexamplemydemoappmainactivityonoptionsitemselected(mainactivityjava:53)    at androidappactivityonmenuitemselected(activityjava:2908)    at androidsupportv4appfragmentactivityonmenuitemselected(fragmentactivityjava:361)    at androidsupportv7appappcompatactivityonmenuitemselected(appcompatactivityjava:147)    at androidsupportv7viewwindowcallbackwrapperonmenuitemselected(windowcallbackwrapperjava:100)    at androidsupportv7viewwindowcallbackwrapperonmenuitemselected(windowcallbackwrapperjava:100)    at androidsupportv7apptoolbaractionbar$2onmenuitemclick(toolbaractionbarjava:68)    at androidsupportv7widgettoolbar$1onmenuitemclick(toolbarjava:172)    at androidsupportv7widgetactionmenuview$menubuildercallbackonmenuitemselected(actionmenuviewjava:760)    at androidsupportv7viewmenumenubuilderdispatchmenuitemselected(menubuilderjava:811)    at androidsupportv7viewmenumenuitemimplinvoke(menuitemimpljava:152)    at androidsupportv7viewmenumenubuilderperformitemaction(menubuilderjava:958)    at androidsupportv7viewmenumenubuilderperformitemaction(menubuilderjava:948)    at androidsupportv7viewmenumenupopuphelperonitemclick(menupopuphelperjava:191)    at androidwidgetadapterviewperformitemclick(adapterviewjava:310)    at androidwidgetabslistviewperformitemclick(abslistviewjava:1145)    at androidwidgetabslistview$performclickrun(abslistviewjava:3042)    at androidwidgetabslistview$3run(abslistviewjava:3879)    at androidoshandlerhandlecallback(handlerjava:739)    at androidoshandlerdispatchmessage(handlerjava:95)    at androidoslooperloop(looperjava:148)    at androidappactivitythreadmain(activitythreadjava:5417)    at javalangreflectmethodinvoke(native method)    at comandroidinternaloszygoteinit$methodandargscallerrun(zygoteinitjava:726)    at comandroidinternaloszygoteinitmain(zygoteinitjava:616) caused by: rxexceptionscompositeexception: 2 exceptions occurred     at rxobserverssafesubscriber_onerror(safesubscriberjava:194)    at rxobserverssafesubscriberonerror(safesubscriberjava:120)    at rxinternaloperatorsoperatordooneach$1onerror(operatordooneachjava:71)    at rxexceptionsexceptionsthroworreport(exceptionsjava:187)    at rxinternaloperatorsoperatordooneach$1onnext(operatordooneachjava:82)    at rxinternalutilscalarsynchronousobservable$1call(scalarsynchronousobservablejava:46)    at rxinternalutilscalarsynchronousobservable$1call(scalarsynchronousobservablejava:35)    at rxobservable$2call(observablejava:162)    at rxobservable$2call(observablejava:154)    at rxobservablesubscribe(observablejava:8191)    at rxobservablesubscribe(observablejava:8158)    at comexamplemydemoappmainactivitytestretryerror(mainactivityjava:65)    at comexamplemydemoappmainactivityonoptionsitemselected(mainactivityjava:53)    at androidappactivityonmenuitemselected(activityjava:2908)    at androidsupportv4appfragmentactivityonmenuitemselected(fragmentactivityjava:361)    at androidsupportv7appappcompatactivityonmenuitemselected(appcompatactivityjava:147)    at androidsupportv7viewwindowcallbackwrapperonmenuitemselected(windowcallbackwrapperjava:100)    at androidsupportv7viewwindowcallbackwrapperonmenuitemselected(windowcallbackwrapperjava:100)    at androidsupportv7apptoolbaractionbar$2onmenuitemclick(toolbaractionbarjava:68)    at androidsupportv7widgettoolbar$1onmenuitemclick(toolbarjava:172)    at androidsupportv7widgetactionmenuview$menubuildercallbackonmenuitemselected(actionmenuviewjava:760)    at androidsupportv7viewmenumenubuilderdispatchmenuitemselected(menubuilderjava:811)    at androidsupportv7viewmenumenuitemimplinvoke(menuitemimpljava:152)    at androidsupportv7viewmenumenubuilderperformitemaction(menubuilderjava:958)    at androidsupportv7viewmenumenubuilderperformitemaction(menubuilderjava:948)    at androidsupportv7viewmenumenupopuphelperonitemclick(menupopuphelperjava:191)    at androidwidgetadapterviewperformitemclick(adapterviewjava:310)    at androidwidgetabslistviewperformitemclick(abslistviewjava:1145)    at androidwidgetabslistview$performclickrun(abslistviewjava:3042)    at androidwidgetabslistview$3run(abslistviewjava:3879)    at androidoshandlerhandlecallback(handlerjava:739)    at androidoshandlerdispatchmessage(handlerjava:95)    at androidoslooperloop(looperjava:148)    at androidappactivitythreadmain(activitythreadjava:5417)    at javalangreflectmethodinvoke(native method)    at comandroidinternaloszygoteinit$methodandargscallerrun(zygoteinitjava:726)    at comandroidinternaloszygoteinitmain(zygoteinitjava:616) caused by: rxexceptionscompositeexception$compositeexceptioncausalchain: chain of causes for compositeexception in order received >    at androidutilloggetstacktracestring(logjava:338)    at comandroidinternalosruntimeinitclog_e(runtimeinitjava:61)    at comandroidinternalosruntimeinit-wrap0(runtimeinitjava)    at comandroidinternalosruntimeinit$uncaughthandleruncaughtexception(runtimeinitjava:86)    at javalangthreadgroupuncaughtexception(threadgroupjava:693)    at javalangthreadgroupuncaughtexception(threadgroupjava:690) caused by: javalangillegalstateexception: doonnextexception    at comexamplemydemoappmainactivity$3call(mainactivityjava:63)    at comexamplemydemoappmainactivity$3call(mainactivityjava:61)    at rxobservable$11onnext(observablejava:4445)    at rxinternaloperatorsoperatordooneach$1onnext(operatordooneachjava:80)    at rxinternalutilscalarsynchronousobservable$1call(scalarsynchronousobservablejava:46)    at rxinternalutilscalarsynchronousobservable$1call(scalarsynchronousobservablejava:35) at rxobservable$2call``` || simpler way to reproduce is to just throw within a `doonerror()` - the exception that is thrown is swallowed and is not part of the causal chain```    observablejust(1)doonnext(new action1<integer>() {        @override public void call(integer val) {            throw new illegalstateexception(""""doonnextexception"""")        }    })doonerror(new action1<throwable>() {                @override public void call(throwable throwable) {                    throw new unsupportedoperationexception(""""onerror exception"""")                }    })subscribe(new subscriber<integer>() {        @override public void oncompleted() {            logv(""""ex"""" """"oncompleted"""")        }        @override public void onerror(throwable e) {            logv(""""ex"""" """"onerror"""")            throw new illegalthreadstateexception()        }        @override public void onnext(integer integer) {            logv(""""ex"""" """"onnext"""")        }    })``` || i see this issue too when i see logs via crashlytics the stacktrace just shows the composite exception but not the details of the actual crash in `onerror()` i see theres a bug in `compositeexceptionjava` fixing in a new pr || closing via #3977 || "";1;0;1x: use the correct throwable to set the cause for compositeexceptionthe cause of #3679 is we use a wrong throwable (its cause has been set) to set the cause and `initcause` will throw an exception hence the cause chain is not created correctly in this pr it searches the root cause (which doesnt have a cause) and use it to call `initcause`;"
"3981;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: document zip() eagerness;see #3960 and #3124.;;3124.0;1x: document zip() eagerness;see #3960 and #3124; ;zip: doonterminate is not called on some observables; java    @test    public void test() {        observablezip(                observablejust(""""1"""")                        doonterminate(() -> systemoutprintln(""""terminate 1""""))                observablejust(""""2"""")                        delay(1 timeunitseconds)                        doonterminate(() -> systemoutprintln(""""terminate 2""""))                (result1 result2) -> null)                doonterminate(() -> systemoutprintln(""""terminate""""))                toblocking()                single()    }```output:```terminate 1terminate```expected output:```terminate 1terminate 2terminate```or maybe my thinking is wrong?context of the problem: i use [hystrix]( observable commands in zip:``` javaobservablezip(  new myhystrixobservablecommand(arg1)toobservable()  new myhystrixobservablecommand(arg2)toobservable()  (result1 result2) -> null)toblocking()single()```and hystrix command semaphore release happens in doonterminate one of them is not called and semaphore is not released"";""once the second delayed value runs the zip it detects that the first source has terminated completes and unsubscribes the second source at this time there is an oncompleted scheduled by the second source which due to the unsubscription wont be executed and you dont see the doonterminate called || i felt back to merge:``` java        observablemerge(                observablejust(""""1"""")                        doonterminate(() -> systemoutprintln(""""terminate 1""""))                observablejust(""""2"""")                        delay(1 timeunitseconds)                        doonterminate(() -> systemoutprintln(""""terminate 2"""")))                doonterminate(() ->                        systemoutprintln(""""terminate""""))                ignoreelements()                singleordefault(null)                toblocking()                single()``````terminate 1terminate 2terminate```this code looks strange to me please advice how to properly run some observables in parallel and wait for them to finish i can go with merge for now because i do not need observable results || you can use `lastordefault` to shorten your codes eg `o1mergewith(o2)toblocking()lastordefault(null)` || @vleushin is your issue resolved ? i am facing same issue  what is the drawback of using `merge` ?  || i use merge drawback of merge is that its hard to combine results if you need them if you dont need them (like in my case) you can be good with merge || i just encountered this same thing i want to zip together two `observables` and do some simple logging on each when complete you dont even need the `delay` to make this happen```        observable<integer> nums  observablejust(1 2 3 4)                dooncompleted(() -> systemoutprintln(""""done with nums""""))        observable<string> letters  observablejust(""""a"""" """"b"""" """"c"""" """"d"""")                dooncompleted(() -> systemoutprintln(""""done with letters"""")) // this wont appear        numszipwith(letters (n l) -> """"got """" + n + """" and """" + l)                toblocking()                foreach(systemout::println)```i found this behavior to be very surprising could zip be changed to allow the source `observables` to fully complete in the case where they are the same length? || id add `doonunsubscribe` so you can execute the cleanup action or simply use `using` that will execute the cleanup if the source completes normally or is cancelled || why is this closed? i think the current zip behavior is incorrectmy point is if inner observables of zip emit the same number of items then oncompleted (dooncompleted doonterminate etc) should be called on each of them || doonterminate wont be called if the observable is unsubscribed before the oncompleted/onerror use doonunsubscribe if you need to always get a call back || that is what im talking aboutwhy unsubscribe just before completion? an event is lost without a reasonalso there is an obvious inconsistency: you have two identical inner observables the first completes then unsubscribes the second one unsubscribes before completion even though it was about to do so || with collections over time you cant know you are just before completion the `zip` operator behaves correctly and you need a different operator `doonterminate`+`doonunsubscribe` or `using` to handle completion and unsubscription case together || it is clear to me now thank you all for clarifications i think we can close this issue || @abersnaze doonunsubscribe can be an acceptable workaround but what if i dont want it to trigger on error?@akarnokd formally `zip` behaves correctly since it is not documented whether oncompletes (and so on) should be called on inner observablesthe fact is the behavior is unspecified and unpredictable the problem is i want to know exactly what does my code do || see the proposed documentation changes in #3981 || "";1;0;1x: document zip() eagerness;"
"3981;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: document zip() eagerness;see #3960 and #3124.;;3960.0;1x: document zip() eagerness;see #3960 and #3124; ;zip(o1 o2) doesnt unsubscribe from o1;""a simple example looks ok``` javaobservable<integer> o1  observablejust(1)    dooncompleted(() -> systemoutprintln(""""o1 completed""""))observable<integer> o2  observablejust(1 2 3 4)    dooncompleted(() -> systemoutprintln(""""o2 completed""""))observablezip(o1 o2 (integer1 integer2) -> null)subscribe()```output:```o1 completed```now swap o1 and o2``` javaobservable<integer> o1  observablejust(1 2 3 4)    dooncompleted(() -> systemoutprintln(""""o1 completed""""))observable<integer> o2  observablejust(1)    dooncompleted(() -> systemoutprintln(""""o2 completed""""))observablezip(o1 o2 (integer1 integer2) -> null)subscribe()```output:```o1 completedo2 completed```"";zip uses a prefetch of 128 elements by default since both sources are synchronous the second case takes all 4 from the first source including completion then moves onto `o2` which first emits 1 then its completion completes the whole sequence thus you see both dooncompleted executedthe first case `o1` signals 1 and completion then once `o2` signals its 1 it is known `o2` wont ever signal more values thus `o2` gets unsubscribed and never allowed to run to completionboth are the expected behavior if you need resource cleanup associated with a sequence you cant rely on dooncompleted as sequences may get unsubscribed before that || i see but isnt this implementation details? || it is the explanation for what you experienced the `zip` javadoc has this clause:> the resulting `observable<r>` returned from `zip` will invoke `observer#onnext`> as many times as the number of `onnext` invocations of the source observable that emits the fewest> itemssince `zip`s behavior seems to be confusing maybe we could add a clause that `zip` completes eagerly if one of the sources emits fewer elements than the others and unsubscribes the rest || i agree that docs should be updated although the new clause you suggested needs to be more accurate:1 examples in this issue contradict it2 if source observables emit equal number of elements (and not fewer) some (which? this one really bothers me) are still going to be unsubscribed || see the proposed documentation changes in #3981 || thanks now i know what to expect from `zip` the current implementation still feels unpolished to me though ||;1;0;1x: document zip() eagerness;"
"3986;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add schedulers.reset() for better testing;3985  this adds a  reset()  method to  schedulers   with the main benefit being improved testing support. this does slightly tweak the internal api of  schedulers  to use a  getinstance()  approach to allow lazy init. this way we don t have to replace the singleton instance during  reset()  and allow it to lazily re-evaluate upon next usage. otherwise  if you change your scheduler hook  you d always have to make sure you set it before you call  schedulers.reset() .  will run perf tests overnight in case  i m not sure how much of a tradeoff moving to an internal  getinstance()  approach costs  if anything.  cc @zsxwing;;3985.0;add schedulersreset() for better testing;3985this adds a `reset()` method to `schedulers` with the main benefit being improved testing support this does slightly tweak the internal api of `schedulers` to use a `getinstance()` approach to allow lazy init this way we dont have to replace the singleton instance during `reset()` and allow it to lazily re-evaluate upon next usage otherwise if you change your scheduler hook youd always have to make sure you set it before you call `schedulersreset()`will run perf tests overnight in case im not sure how much of a tradeoff moving to an internal `getinstance()` approach costs if anythingcc @zsxwing;""i think the failing test might be flaky it doesnt fail for me locally  ||  thanks! i dont suppose this could be squeezed into the `requires review` of #3970 could it? || that test doesnt fail for me locally im not really sure what do do about it any ideas? || ive extended the timeout in some tests in pr #3987 once it appears it was enough ill merge that and this pr should work || cool ill rebase after thats merged then  non need to rebase but to rerun the travis job did it for you || ah i pushed the rebase as you commented oh well \_()_/ || cool looks like the timeout tweaks worked || code is ok so  but> resetting the schedulers is dangerous>    during application runtime and also bad code could invoke it in>    the middle of an application life-cycle and really break applications>    if not used cautiouslywhy were adding more and more apis to break things and allow people use bad practices? || its two and theyre largely targeted at testing i dont think having a reset is bad practice and like most code only breaks things if you make poor decisions with it i could just as easily add a bad scheduling hook or buggy global error handlerhaving to otherwise use di to inject schedulers everywhere gets tedious fast and inadvertantly discourages people from actually using the conventional static apis with this it can be wrapped up in a nice test rule and enforces a clean state before and after tests using the plugins api also allows you to control the schedulers used across modules and 3rd party libraries as wellfor me its a missing and much needed api i dont think requiring di everywhere you use a scheduler just to test is a scalable approach considering how ubiquitous they are could you imagine injecting say `timber` everywhere you wanted to use it?thats my speel for why i think this is useful || i wonder why people with such testing needs dont roll their own global """"myschedulers"""" class which lets them easily switch scheduler types and use that like `observeon(myschedulersforcomputation())` of course this means you have to remember to use the `scheduler`-overloaded operators everywhere || i also just copied that doc from the other reset i dont know that its as dangerous though it just forces a re-init if its dangerous its because resetting rx plugins is dangerous since theyre not explicitly bound i wouldnt mind making the doc warning a little less severe? :p || 3rd party libraries dont use your apps global class :/ plus that case still requires you to hook in a delegate scheduler in tests early enough were adding a global scheduler of sorts for background work and still planning to have a reset on the schedulers || libraries should expose the option to customize the `scheduler` they run on do you know a library that doesnt allow such customization? || most actually they just use the built-in schedulerswhatever() or androidschedulersmainthread() i dont see how a wrapper with static methods solves this either you still need some mechanism of resetting the underlying scheduleris there any harm in allowing reset here to facilitate just having developers go through the standard api? || but heres a quick example off the top of my head:  || otherwise i think the whole plugin system in rxjava 1x is getting cumbersome in 2x i did a much simpler and direct approach for overriding stufffor example this is how the schedulers get initialized: is where they are returned: what scheduler is returned from schedulers is easy via adding a function that can wrap or completely replace the scheduleri dont know if netflix wants 12 at all but if so id be glad to rewrite the plugin system || > but heres a quick example off the top of my head:  where does it use rxjava schedulers forcefully? || found one: [reversegeocodeobservablejava]( should have provided a way to customize that scheduler anyway ||  this one || may sound crazy but what about marking `reset()` as `@deprecated` with explanation of better ways? || i think `@experimental` with a doc explaining that the api will be revamped in the future would make more sense i dont have strong feelings for or against `@deprecated` though and can switch to that if others want anything to help move this pr along :) || `@deprecated` will produce compile warning and will be visible in ide pretty sure most of the people who will use `schedulersreset()` will copy-paste from so or some blog post which will arrive as soon as we merge/release this and wont even know that its `@experimental`// im not blocking pr if that matters || fair point @akarnokd any thoughts? it seems like this has the requisite s to move forward can add deprecated if you think its worthwhile || do we really expect people to accidentally use this and be surprised?deprecating the method sounds like it punishes those who want to use itid deprecate create() and others long before this methodon mon jun 6 2016 5:19 pm zac sweers notifications@githubcom wrote:> fair point @akarnokd  any thoughts? it> seems like this has the requisite s to move forward can add> deprecated if you think its worthwhile> > > you are receiving this because you are subscribed to this thread> reply to this email directly view it on github>  or mute the thread>   || when you put it that way i think i agree || dont deprecate it || > do we really expect people to accidentally use this and be surprised?have seen/helped people asking how to solve problems after applying scheduler hooks for testing they didnt realize (mostly) how it can break things`create()` is local evil it doesnt break global state alternative solution would be to move apis like `create()` `reset()` and so on to `rxunsafe` like java rust and so on its there but use it at your own risk || "";proposal: make schedulers should be more friendly to tests;`rxjavapluginsreset()` was recently made public but there was a common misconception that this would also reset schedulers this isnt the case however since schedulers permanently cache their resolved schedulers so `rxjavapluginsreset()` actually doesnt help in this regard id like to propose adding a `schedulersreset()` function as well it comes with same caveats that `rxjavapluginsreset()` has in that its dangerous to call in live code but it would be enormously helpful in testing this would simply null out the cached schedulers to force a re-check the next time theyre used and thus letting you change the scheduling hook and have the new ones output propagate with junit it could be nicely wrapped up in a rule that could be optionally dropped into test suites on the fly otherwise schedulers must be set at the beginning of your whole test suite and delegate schedulers put in place that can be configured laterif people would be open to this id be happy to provide a pr i looked for prior discussion around this but wasnt able to find any if i missed them somewhere please let me know; in the long term i would like to see that `rxjavapluginsreset()` can reset static fields related to plugins || actually it wouldnt just be nulling out those fields it would have to replace the singleton `instance` of schedulers to re-trigger its constructor and evaluation of those scheduler instances for just tests though i still think this is a reasonable tradeoff since its opt-in and doesnt change existing behavior by default || @hzsweers thats what i meant :) || opened a pr in #3986 for further review ||;1;0;more accurate doc;"
3987;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;add more time to certain tests that failed under heavy ci load;sometimes  the heavy travis ci load (or throttling) makes a few tests fail with timeout. this increases the timeout for some of them to reduce the likelihood.;;0;add more time to certain tests that failed under heavy ci load;sometimes the heavy travis ci load (or throttling) makes a few tests fail with timeout this increases the timeout for some of them to reduce the likelihood;;;;;1;1;add more time to certain tests that failed under heavy ci load;
"3996;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: fix reset() shutting down everything other than the schedulers;the reset shut down all the main schedulers and the helper pools  causing the failure in #3993 .  @hzsweers  you were right with the need for the instance-shutdown method.;;3993.0;1x: fix reset() shutting down everything other than the schedulers;the reset shut down all the main schedulers and the helper pools causing the failure in #3993 @hzsweers you were right with the need for the instance-shutdown method;minor nit rest of the code looks good  nice catch sorry for the inadvertent bug and glad it was a relatively simple fix ||  ;schedulerlifecycletest failures;after merging #3986 these to fail in master (worked as pr):```rxschedulersschedulerlifecycletest > testshutdown failed    javautilconcurrentrejectedexecutionexception: task javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetask@73f20bba rejected from javautilconcurrentscheduledthreadpoolexecutor@17e01bce[terminated pool size  0 active threads  0 queued tasks  0 completed tasks  0]        at javautilconcurrentthreadpoolexecutor$abortpolicyrejectedexecution(threadpoolexecutorjava:2048)        at javautilconcurrentthreadpoolexecutorreject(threadpoolexecutorjava:821)        at javautilconcurrentscheduledthreadpoolexecutordelayedexecute(scheduledthreadpoolexecutorjava:325)        at javautilconcurrentscheduledthreadpoolexecutorschedule(scheduledthreadpoolexecutorjava:530)        at javautilconcurrentscheduledthreadpoolexecutorexecute(scheduledthreadpoolexecutorjava:619)        at rxschedulersschedulerlifecycletesttryoutschedulers(schedulerlifecycletestjava:98)        at rxschedulersschedulerlifecycletesttestshutdown(schedulerlifecycletestjava:36)rxschedulersschedulerlifecycletest > teststartidempotence startedrxschedulersschedulerlifecycletest > teststartidempotence failed    javautilconcurrentrejectedexecutionexception: task javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetask@18264a30 rejected from javautilconcurrentscheduledthreadpoolexecutor@17e01bce[terminated pool size  0 active threads  0 queued tasks  0 completed tasks  0]        at javautilconcurrentthreadpoolexecutor$abortpolicyrejectedexecution(threadpoolexecutorjava:2048)        at javautilconcurrentthreadpoolexecutorreject(threadpoolexecutorjava:821)        at javautilconcurrentscheduledthreadpoolexecutordelayedexecute(scheduledthreadpoolexecutorjava:325)        at javautilconcurrentscheduledthreadpoolexecutorschedule(scheduledthreadpoolexecutorjava:530)        at javautilconcurrentscheduledthreadpoolexecutorexecute(scheduledthreadpoolexecutorjava:619)        at rxschedulersschedulerlifecycletesttryoutschedulers(schedulerlifecycletestjava:98)        at rxschedulersschedulerlifecycletestteststartidempotence(schedulerlifecycletestjava:117)```@hzsweers can you have a look at these? (its night time for me btw);""sure ill take a look || they run fine on 1x/master for me locally maybe something to do with travis? or related to or in the same vein as  || @hzsweers i guess its related to cpu/cores configuration + machine state please try to run tests on travis through your fork of rxjava (via prs or other ways) just add env variable `travis_pull_requesttrue` on travis for your forkps sorry for """"laugh"""" reaction removed thought that it was funny and """"ive warned you"""" things but this project is too significant to break it so yeah sorry ill be here to review fix in few hours || so weve chatted with @hzsweers about the problem he has to go for few hours if somebody interested in fixing that  looks like #3986 shuts down scheduler too early or tests that run after `reset()` see shutdowned scheduler or something like this: > reset startedrxschedulersschedulerlifecycletest > testshutdown startedrxschedulersschedulerlifecycletest > testshutdown failed    javautilconcurrentrejectedexecutionexception: task javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetask@4240096f rejected from javautilconcurrentscheduledthreadpoolexecutor@7a2b7863[terminated pool size  0 active threads  0 queued tasks  0 completed tasks  0]        at javautilconcurrentthreadpoolexecutor$abortpolicyrejectedexecution(threadpoolexecutorjava:2048)        at javautilconcurrentthreadpoolexecutorreject(threadpoolexecutorjava:821)        at javautilconcurrentscheduledthreadpoolexecutordelayedexecute(scheduledthreadpoolexecutorjava:325)        at javautilconcurrentscheduledthreadpoolexecutorschedule(scheduledthreadpoolexecutorjava:530)        at javautilconcurrentscheduledthreadpoolexecutorexecute(scheduledthreadpoolexecutorjava:619)        at rxschedulersschedulerlifecycletesttryoutschedulers(schedulerlifecycletestjava:108)        at rxschedulersschedulerlifecycletesttestshutdown(schedulerlifecycletestjava:46)rxschedulersschedulerlifecycletest > teststartidempotence startedrxschedulersschedulerlifecycletest > teststartidempotence failed    javautilconcurrentrejectedexecutionexception: task javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetask@7cbac34b rejected from javautilconcurrentscheduledthreadpoolexecutor@7a2b7863[terminated pool size  0 active threads  0 queued tasks  0 completed tasks  0]        at javautilconcurrentthreadpoolexecutor$abortpolicyrejectedexecution(threadpoolexecutorjava:2048)        at javautilconcurrentthreadpoolexecutorreject(threadpoolexecutorjava:821)        at javautilconcurrentscheduledthreadpoolexecutordelayedexecute(scheduledthreadpoolexecutorjava:325)        at javautilconcurrentscheduledthreadpoolexecutorschedule(scheduledthreadpoolexecutorjava:530)``` || so `schedulersreset()` shuts down `genericscheduledexecutorservice` then `schedulerlifecycletest` tries to run some tasks on it `genericscheduledexecutorservicegetinstance()execute()` and fails because `reset()` test already shut it downthe fix would be to restart `genericscheduledexecutorservice` correctly in `schedulerlifecycletest` or `schedulersreset()` or `genericscheduledexecutorservicegetinstance()` || yes the `reset` is overscoped it should only shutdown the main schedulers but leave the helper schedulers ill post a fix || this can be closed now || closing via #3996 || "";1;0;1x: fix reset() shutting down everything other than the schedulers;"
4005;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: fix spsc queues reporting not empty but then poll() returns null;in the spsc queues  the indexes were written before the actual elements and thus a concurrent  isempty  check would report a non-empty queue but a  poll  would still return  null . the fix swaps the two writes.  note that this an inconsistency in the original jctools code and not the lack of keeping up with it.;;0;1x: fix spsc queues reporting not empty but then poll() returns null;in the spsc queues the indexes were written before the actual elements and thus a concurrent `isempty` check would report a non-empty queue but a `poll` would still return `null` the fix swaps the two writesnote that this an inconsistency in the original jctools code and not the lack of keeping up with it; ;;;;1;1;1x: fix spsc queues reporting not empty but then poll() returns null;
4011;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: deprecate testobserver  enhance testsubscriber a bit;this pr deprecates  testobserver  in favor of the richer  testsubscriber .  in addition   testsubscriber  gets 3 new methods and 1 deprecation: -  getcompletions()  to return the oncompleted count as int instead of notifications -  getvaluecount()  returns the committed number of onnext events for thread-safe checking of values up to this count -  awaitvaluecount  repeatedly sleeps up to a timeout and waits till the committed onnext count reaches/passes the expected amount.;;0;1x: deprecate testobserver enhance testsubscriber a bit;this pr deprecates `testobserver` in favor of the richer `testsubscriber`in addition `testsubscriber` gets 3 new methods and 1 deprecation:- `getcompletions()` to return the oncompleted count as int instead of notifications- `getvaluecount()` returns the committed number of onnext events for thread-safe checking of values up to this count- `awaitvaluecount` repeatedly sleeps up to a timeout and waits till the committed onnext count reaches/passes the expected amount;other than that suggestion lgtm  thanks for the feedback im merging this as is and im open for prs if you think `awaitvaluecount` should use a different wait strategy ||;;;;1;1;1x: deprecate testobserver enhance testsubscriber a bit;
4014;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add specificity to documentation for asyncsubject;this documentation answers questions i had while reading it.;;0;add specificity to documentation for asyncsubject;this documentation answers questions i had while reading it;id also add if the source terminated with an `onerror` (with or without prior `onnext`s) all current and future `subscriber`s will receive only the error ||  what is the protocol from here on out? || thanks for the contribution ill merge this as is ill write up my intentions as a lead developer including cases such as this as an example || theres an additional marble diagram you could add that illustrates thisif you think that would help: fri jun 17 2016 at 12:00 am david karnok notifications@githubcomwrote:> id also add if the source terminated with an onerror (with or without> prior onnexts) all current and future subscribers will receive only the> error> > > you are receiving this because you are subscribed to this thread> reply to this email directly view it on github>  or mute the thread>  ## david m grossplp consulting || thanks @davidmgross ! @hospitalitarian would you like to submit another pr? || yes i will  how do you generate marble diagrams?  there are a few more cases that i would like to add || omnigraffle is the tool were using to create the diagrams you can checkout the diagram set from the rxjava wiki here: by reactivex/reactivexgithubio#223 this file may get moved overto that repo at some point as it makes more sense to have it there)on fri jun 17 2016 at 10:02 am david andrews notifications@githubcomwrote:> yes i will how do you generate marble diagrams? there are a few more> cases that i would like to add> > > you are receiving this because you were mentioned> reply to this email directly view it on github>  or mute the thread>  ## david m grossplp consulting || should i wait for that file to be moved?  otherwise how do i go aboutediting the wiki file?on fri jun 17 2016 at 3:08 pm david gross notifications@githubcomwrote:> omnigraffle is the tool were using to create the diagrams you can check> out the diagram set from the rxjava wiki here:> >  > (though by reactivex/reactivexgithubio#223 this file may get moved over> to that repo at some point as it makes more sense to have it there)> > on fri jun 17 2016 at 10:02 am david andrews notifications@githubcom> wrote:> > > yes i will how do you generate marble diagrams? there are a few more> > cases that i would like to add> > > > > > you are receiving this because you were mentioned> > reply to this email directly view it on github> >  > or mute the thread> > <> >  > > > > > ## > > david m gross> plp consulting> > > you are receiving this because you were mentioned> reply to this email directly view it on github>  or mute the thread>   || ive got other things on my plate so probably wont be moving the grafflefile soon you can check it out from the repo at to make changes let me know ifyouve got questions about how the file is organized how to generate pngimages from it and check those in etcon fri jun 17 2016 at 12:16 pm david andrews notifications@githubcomwrote:> should i wait for that file to be moved? otherwise how do i go about> editing the wiki file?> > on fri jun 17 2016 at 3:08 pm david gross notifications@githubcom> wrote:> > > omnigraffle is the tool were using to create the diagrams you can check> > out the diagram set from the rxjava wiki here:> > > >  > > > (though by reactivex/reactivexgithubio#223 this file may get moved> > over> > to that repo at some point as it makes more sense to have it there)> > > > on fri jun 17 2016 at 10:02 am david andrews <> > notifications@githubcom>> > wrote:> > > > > yes i will how do you generate marble diagrams? there are a few more> > > cases that i would like to add> > > > > > > > > you are receiving this because you were mentioned> > > reply to this email directly view it on github> > > < > > > > > or mute the thread> > > <> > > >  > > > > > > > > ## > > > > david m gross> > plp consulting> > > > > > you are receiving this because you were mentioned> > reply to this email directly view it on github> >  > or mute the thread> > <> >  > > > > > > you are receiving this because you were mentioned> reply to this email directly view it on github>  or mute the thread>  ## david m grossplp consulting ||;;;;1;1;update asyncsubjectjava;
4019;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: make the latest compositesubscription test more robust.;make sure there is enough time for the test and the latch is always counted down.  /cc @artem-zinnatullin;;0;1x: make the latest compositesubscription test more robust;make sure there is enough time for the test and the latch is always counted down/cc @artem-zinnatullin; ;;;;1;1;1x: make the latest compositesubscription test more robust;
4024;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: update dooneach(observer) javadoc;fixes the documentation problem reported in #3721.;;3721.0;1x: update dooneach(observer) javadoc;fixes the documentation problem reported in #3721;nice improvement ;dooneach marble diagram incorrect;should show the completion event forwarded to the supplied `action1` or `observer`;if so the javadocs also need to be rewritten to indicate that thecompletion event is sent to the action or observeri notice also that the description of the parameter in the javadoc ofdooneach(observer) describes the observer as an action rather than anobserveron thu feb 18 2016 at 11:30 am jake wharton notifications@githubcomwrote:> should show the completion event forwarded to the supplied action1 or> observer> > > reply to this email directly or view it on github>  david m grossplp consulting || reopening because the javadocs still need correctionalso: theres a new dooneachopng marble diagram thats specific to the dooneach(observer) operator and should replace the diagram in the javadocs for that operator || see #4024 for my proposed text changes || great! closing via #4024 ||;1;0;1x: update dooneach(observer) javadoc;
4026;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: expand and explain cache() in more detail;this pr rephrases the  cache  documentation a bit and adds workaround for stopping and forgetting the cached values.  related: #3007.;;3007.0;1x: expand and explain cache() in more detail;this pr rephrases the `cache` documentation a bit and adds workaround for stopping and forgetting the cached valuesrelated: #3007; this obviously isnt related to that but `testreplaysubjectconcurrentsubscriptions` failed in ci || thanks will look into it before merging this could be a bug due a pattern they share || nothing obvious so far the test passes for me locally when run 1000 times will investigate it further through #4028 ||;javadoc for cache suggests eager subscribe;lines 27-28 of onsubscribecache:- this method has similar behavior to {@link observable#replay()} except that this auto-subscribes  - to the source observable rather than returning a connectable observableit appears that the subscribe() to the source is lazy;care to submit a pr for this? || see #4026 for the proposed javadoc changes || closing via #4026 ||;1;0;1x: expand and explain cache() in more detail;
4027;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: fix completable.onerrorcomplete(func1) not relaying function crash;the catch around the predicate didn t actually signal the compositeexception.  discovered in #4025;;0;1x: fix completableonerrorcomplete(func1) not relaying function crash;the catch around the predicate didnt actually signal the compositeexceptiondiscovered in #4025; ;;;;1;1;1x: fix completableonerrorcomplete(func1) not relaying function crash;
4030;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: first step switching to the reduced-allocation architecture;this is the first step towards the new architecture where operator implementations are themselves of the base type instead of a 2-3 layer indirection as in 1.x.  this pr removes the instance field  onsubscribe  from the base reactive classes and introduces  subscribeactual  to be overridden with the custom operator logic now on. existing operators are still working through the classical onsubscribe/lift indirection and will be updated in subsequent prs.  naming and existence of  subscribeactual  is up for (post-merge) discussion. to recap  the method is needed so that the default  subscribe  method can be made final and ensure plugin hooks can be called (once available). the method is protected and only affects operator implementors that chose to extend the base reactive classes directly.   the alternative is to leave  subscribe  abstract and add a hook to every operator method (for example  see [this]( and [this](https://github.com/reactor/reactive-streams-commons/blob/master/src/main/java/rsc/publisher/px.java#l162).;;0;2x: first step switching to the reduced-allocation architecture;this is the first step towards the new architecture where operator implementations are themselves of the base type instead of a 2-3 layer indirection as in 1xthis pr removes the instance field `onsubscribe` from the base reactive classes and introduces `subscribeactual` to be overridden with the custom operator logic now on existing operators are still working through the classical onsubscribe/lift indirection and will be updated in subsequent prsnaming and existence of `subscribeactual` is up for (post-merge) discussion to recap the method is needed so that the default `subscribe` method can be made final and ensure plugin hooks can be called (once available) the method is protected and only affects operator implementors that chose to extend the base reactive classes directly the alternative is to leave `subscribe` abstract and add a hook to every operator method (for example see [this]( and [this](https://githubcom/reactor/reactive-streams-commons/blob/master/src/main/java/rsc/publisher/pxjava#l162);lgtm ;;;;1;1;2x: first step switching to the reduced-allocation architecture;
4034;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: distinctuntilchanged with direct value comparator - alternative;alternative implementation to #4001.;;4001.0;1x: distinctuntilchanged with direct value comparator - alternative;alternative implementation to #4001;lgtm  thanks jake for the review! || ;1x: added distinctuntilchanged(comparator);for some cases `observabledistinctuntilchanged(keyselector)` isnt enough for example when data consists of 2+ objects with id you cannot simply summarize them and use it as a key also often there are stream of arrays of data which cant be distincted easily and genericallyso i think `observabledistinctuntilchanged(comparator)` would be helpful i use kinda tricky implementation but think it is okey firstly i tried to add ctor to operatordistinctuntilchanged() but it was too bad**ps** i was really confused by > if you would like to contribute code you can do so through github by forking the repository and sending a pull request (on a branch other than master 1x 2x or gh-pages)and spent some time trying to create some sort of temporal branch here (newbie me) but finally looked up into prs and so that it is okey to pr into 1x is it an error in md-file?;please add unit tests that verify the behavior || how about this one? || sorry for the delay i remembered there was a discussion about this overload a while ago in #395the verdict was to not have them and you have to create your own wrapper class with custom `equals` and use it as a keyselectorthe decision may be revised depending on the others opinions(otherwise i would have done it differently not with that subscriberprovider) || see #4034 about how id implement this instead (easier shown in code than as a comment) let me know if you want to adjust your pr ||  adjust your pr` you mean copy-paste your implementation as successive commit to existed ones? || > by adjust your pr you mean copy-paste your implementation as successive commit to existed ones?if you think that my pr doesnt cover everything you wanted then yes otherwise i leave it to you || > if you think that my pr doesnt cover everything you wanted then yesno i think your pr is just okay and do what i wanted and do it better than mine own :+1: so i guess i need to close this pr now? || yes you can close this thanks for your contribution anyway! if you have any further improvement suggestions / prs for the library dont hesitate to post them (if you need some hints about operator coding styles and structure try looking at the common and simpler operators implementations) ||;1;0;add experimental annotation;
4036;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: added zip function with observable array.;as discussed in #4035 with @akarnokd;;4035.0;1x: added zip function with observable array;as discussed in #4035 with @akarnokd;thanks! almost forgot please also add a unit test that verifies this overload works with 0 1 or a couple of sources (you can add a unit test that for example loops from 0 to 31 generates an array with that many simple sources and checks if all source values actually zipped into the final value) || @akarnokd sorry for the delay i just added tests for 0 1 and multiple array sizes let me know if thats ok ||  ;consider adding zip function with observable array for reduced overhead;currently the `zip` function takes an iterable in the form `iterable<? extends observable<?>> ws` and then is transformed into an array:```list<observable<?>> os  new arraylist<observable<?>>()for (observable<?> o : ws) {    osadd(o)}return observablejust(ostoarray(new observable<?>[ossize()]))lift(new operatorzip<r>(zipfunction))```this causes not only the copy from one list to another but also a copy from the created list to the array which will add some overhead if the list is big enoughinstead consider adding the following function:```public static <r> observable<r> zip(observable<?> ws funcn<? extends r> zipfunction) {    return observablejust(ws)lift(new operatorzip<r>(zipfunction))}```so whoever who has the chance to create an array instead of a list will save some cpu timeid be glad to create a pull request with the related code to any specified branch if neededthanks for your attention;it should be a straightforward addition with minimal api surface expansion cost pr is welcome ||;1;0;added zip function with observable array;
4039;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: add missing javadoc elements  fix some descriptions;- fixes to javadoc warnings - type arguments - missing descriptions;;0;1x: add missing javadoc elements fix some descriptions;- fixes to javadoc warnings- type arguments- missing descriptions; @artem-zinnatullin  ||   thanks @stevegury & @artem-zinnatullin @davidmgross let me know if you are okay with the update ||  love it nice to see those &#64warn messages going away ||;;;;1;1;fix copy-paste error in completable;
4041;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: update observable s ops to work with observableconsumable;this pr updates the  observable  method signatures to accept  observableconsumable   similar to how  flowable  methods accept  publisher .  the architecture switch may take a couple of more prs. i ll try to limit the change amount in each.;;0;2x: update observables ops to work with observableconsumable;this pr updates the `observable` method signatures to accept `observableconsumable` similar to how `flowable` methods accept `publisher`the architecture switch may take a couple of more prs ill try to limit the change amount in each;;;;;1;1;2x: update observables ops to work with observableconsumable;
4042;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: use xconsumable in completable and single;update to  completable  and  single  to use  completableconsumable  and  singleconsumable  as input.;;0;2x: use xconsumable in completable and single;update to `completable` and `single` to use `completableconsumable` and `singleconsumable` as input;;;;;1;1;2x: use xcompletable in completable and single;
4043;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: factor out completable ops  unify disposed markers;- moved the operators of completable into their respective classes. updated them to extend  completable  directly. - fixed a large set of inconsistend  disposable  management among the  observable  operators.;;0;2x: factor out completable ops unify disposed markers;- moved the operators of completable into their respective classes updated them to extend `completable` directly-  a large set of inconsistend `disposable` management among the `observable` operators;;;;;1;1;2x: factor out completable ops make them direct fix disposed markers;
4045;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: single operators factored out  headers added;single  operators factored out and made them extend  single  directly. added missing headers.;;0;2x: single operators factored out headers added;`single` operators factored out and made them extend `single` directly added missing headers;;;;;1;1;2x: single operators factored out headers added;
4049;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: make flowable operators extend flowable directly to reduce allocation;relatively straightforward  although manual an tedious  refactoring of the flowable operators. the number of files is this large because for consistency  the tests have been renamed as well.;;0;2x: make flowable operators extend flowable directly to reduce allocation;relatively straightforward although manual an tedious refactoring of the flowable operators the number of files is this large because for consistency the tests have been renamed as well; ;;;;1;1;update remaining operators to implement flowable directly;
4051;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: fix replaysubject anomaly around caughtup by removing that optimization;adding the backpressure support to  replaysubject  exposed a race condition around the  caughtup  optimization.  the problem occurs when the source thread has caught up after  drain()  returned true but at the same time  a concurrent  drain()  starts running (due to a subscribe() process finishing or requesting on top of the previous  long.max_value ). this concurrent drain may think the replay hasn t started yet (by finding  rp.node  null) or seeing that the buffer has more elements (that may get double emitted).  the current solution is to remove this optimization until we come up with a correct optimization.  related: #4028.;;4028.0;1x: fix replaysubject anomaly around caughtup by removing that optimization;adding the backpressure support to `replaysubject` exposed a race condition around the `caughtup` optimizationthe problem occurs when the source thread has caught up after `drain()` returned true but at the same time a concurrent `drain()` starts running (due to a subscribe() process finishing or requesting on top of the previous `longmax_value`) this concurrent drain may think the replay hasnt started yet (by finding `rpnode` null) or seeing that the buffer has more elements (that may get double emitted)the current solution is to remove this optimization until we come up with a correct optimizationrelated: #4028; ;replaysubjectconcurrencytest > testreplaysubjectconcurrentsubscriptions failed;```rxsubjectsreplaysubjectconcurrencytest > testreplaysubjectconcurrentsubscriptions failed    javalangruntimeexception: concurrency bug        at rxsubjectsreplaysubjectconcurrencytesttestreplaysubjectconcurrentsubscriptions(replaysubjectconcurrencytestjava:235)```;new crash type:```rxsubjectsreplaysubjectconcurrencytest > testreplaysubjectconcurrentsubscriptions failed    javalangnullpointerexception        at rxsubjectsreplaysubjectconcurrencytesttestreplaysubjectconcurrentsubscriptions(replaysubjectconcurrencytestjava:221)``` ||  via #4051 ||;1;0;1x: fix replaysubject anomaly around caughtup by disabling that opt;
"4053;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: convert schedulersupport annotation to accept a string value.;closes #4052.;;4052.0;2x: convert schedulersupport annotation to accept a string value;closes #4052;  i meant to include in the pr description that i removed the `single` value it was unused and the javadoc didnt make it clear as to what the exact usage would be anyway || no problem can be added later if necessary although `singlescheduler` is not (planned to be) a default for any operators right now ||;2x: change schedulersupport to string?;""in some specific uses of rxjava its common to have other important schedulers that one cares about if the `@schedulersupport` annotation was changed to use a `string` as its value and provide constants on that type for its first-party values this would allow those other schedulers to be analyzed in the same waythis will allow static analysis tools to enforce constraints with these """"custom"""" schedulers as actual named-entities instead of having to rely on the otherwise opaque `custom` value additionally libraries will be able to annotate their factory methods which operate on these schedulers appropriatelyim thinking specifically of android rxandroid and having `""""mainthread""""` be a valuehappy to make this change if it sounds like a good idea"";:+1: im not touching the base reactive types in the next 12 hours so go ahead with the pr || resolved by #4053 not sure why it didnt auto-close  || > resolved by #4053 not sure why it didnt auto-closeonly patches merged to the `default` branch can auto-close issues || ah good callon tue jun 21 2016 8:36 pm shixiong zhu notifications@githubcom wrote:> resolved by #4053  not> sure why it didnt auto-close> > only patches merged to the default branch can auto-close issues> > > you are receiving this because you modified the open/close state> > reply to this email directly view it on github>  or mute the thread>   ||;1;0;convert schedulersupport annotation to accept a string value;"
4055;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: update conversion method name to reflect new base type names.;;;0;2x: update conversion method name to reflect new base type names;; ;;;;1;1;update conversion method name to reflect new base type names;
4058;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;use disposablehelper and subscriptionhelper to reduce duplication.;a lot of operators contained their own marker instance and class definition of disposable or subscription. this changes almost all of them to use the shared instance provided by their respective helper class. some duplication still exists but can be cleaned up in a subsequent change.;;0;use disposablehelper and subscriptionhelper to reduce duplication;a lot of operators contained their own marker instance and class definition of disposable or subscription this changes almost all of them to use the shared instance provided by their respective helper class some duplication still exists but can be cleaned up in a subsequent change;theres some actual bug fixes in here too more than once an atomicreference was being compared against a disposable/subscription using identity without calling get() ||   maybe i made that up i cant see them now its late || :+1: thanks for this heroic work! ||;;;;1;1;use disposablehelper and subscriptionhelper to reduce duplicationa lot of operators contained their own marker instance and class definition of disposable or subscription this changes almost all of them to use the shared instance provided by their respetive helper class some duplication still exists but can be cleaned up in a subsequent change;
4059;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: cleanup a few additional subscriptionhelper locations;follow up to #4058 .;;0;2x: cleanup a few additional subscriptionhelper locations;follow up to #4058; ;;;;1;1;2x: cleanup a few additional subscriptionhelper locations;
4060;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: coverage improvements  small adjustments;- update to junit 4.12 - remove deprecated use of  junit.framework.assert  - update to mockito 1.10.19 - notification.accept() now uses switch (note that jacoco can t properly cover enum switches as it only sees the default and impossible path is not taken). - in  scheduler.scheduleperiodically   move the unsubscribe check after the action to prevent unnecessary schedule of the next iteration. - remove the inner counted loop from  serializedobserver  as being unnecessary - increate timeout in  operatorswitchtest  - add  completablesubscribertest  - extend  scheduler    serializedobserver;;0;1x: coverage improvements small adjustments;- update to junit 412- remove deprecated use of `junitframeworkassert`- update to mockito 11019- notificationaccept() now uses switch (note that jacoco cant properly cover enum switches as it only sees the default and impossible path is not taken)- in `schedulerscheduleperiodically` move the unsubscribe check after the action to prevent unnecessary schedule of the next iteration- remove the inner counted loop from `serializedobserver` as being unnecessary- increate timeout in `operatorswitchtest`- add `completablesubscribertest`- extend `scheduler` `serializedobserver`; ;;;;1;1;1x: coverage improvements small adjustments;
4063;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: scan & reduce give javadoc about unsharing the initialvalue;replacement for #3959.;;3959.0;1x: scan & reduce give javadoc about unsharing the initialvalue;replacement for #3959; **  this to not get in conflict with other prs targeting `observable` ||;1x: scan with an initial factory callback;this pr adds an overload to `scan` which allows specifying an initial value factory the initial value factory is invoked for each incoming subscriber individually and provides a non-shared starting point for the `scan` operationi propose the `scan(func2 accumulator func0 initialfactory)` parameter order because some java 8+ compilers cant properly disambiguate with `scan(r initialvalue func2 accumulator)` thinking that r can be made `func0` related: #3667;why add the overload if it can be done with defer and scan then? || yep it can be done a decision has to be made if this convenience should make it into the library or not and notify @niteshkant the outcome in #3667 || id like to see this overload in  im not strong against adding it but not like the idea of the new parameter order i would give +1 if giving it a better name instead of changing the parameter order by the way there is already a `operatorscan(func0<r> initialvaluefactory func2<r ? super t r> accumulator)` for this overload so you dont need to use `defer`probably @benjchristensen should take a look since you removed it before || it was removed due to ambiguity as shown in  long as that issue is not recreated i have nothing against the functionality pursued here i too dont like solving the overload ambiguity by moving parameter order around but there is no good solution its either that or a new name  || as an alternative i suggest extending `scan`s javadoc with the example of the defer trick || the argument order bothers me as well ill close this and post a javadoc update instead ||;1;0;1x: scan & reduce give javadoc about unsharing the initialvalue;
"4069;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;remove second type parameter from subject and flowprocessor.;closes #4056.;;4056.0;remove second type parameter from subject and flowprocessor;closes #4056;;2x: unify two type parameters from subject into one?;this came up in passing in an issue or pr before (that i cant find at this moment) but the two type parameters on `subject` seem to only be a nuisance instead of a benefitshould we remove them?none of the built-in implementations allow consuming a type different than is being emitted which makes the two type parameters on the supertype seem very out of place;"":+1: rxscala uses one parameter for a long time and no one complaints || its a remnant of the """"subject as a processing stage"""" mentality of rxnet but unlike java you can have classes with the same name and different number of type parameters:+1: would you like to do it? || i can tomorrow! its 3am here and that other pr i sent wore me outon wed jun 22 2016 2:57 am david karnok notifications@githubcom wrote:> its a remnant of the """"subject as a processing stage"""" mentality of rxnet> but unlike java you can have classes with the same name and different> number of type parameters> >  would you like to do it?> > > you are receiving this because you authored the thread> reply to this email directly view it on github>  or mute the thread>   || "";1;0;remove second type parameter from subject and flowprocessor;"
4070;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: merge serialdisposable and multipleassignmentdisposable.;closes #4057 although doesn t address the name of the class.;;4057.0;2x: merge serialdisposable and multipleassignmentdisposable;closes #4057 although doesnt address the name of the class;  excellent :+1:> although doesnt address the name of the classno problem ||;2x: serialdisposable and multipleassignmentdisposable are exactly the same;either one is erroneously implemented or lets pick one to keep;there is a difference: doesnt dispose the previous disposable but serial doeshowever im totally for merging the two classes and have `set` and `replace` on them || wow super subtle! i had them open side-by-side and wasnt able to see thati can take this change tomorrow as well is there a preference for the nameof this merged type?on wed jun 22 2016 3:06 am david karnok notifications@githubcom wrote:> there is a difference:> >  >  > multiple doesnt dispose the previous disposable but serial does> > however im totally for merging the two classes and have set and replace> on them> > > you are receiving this because you authored the thread> reply to this email directly view it on github>  or mute the thread>   || open for discussion i was leaning towards `singledisposable` but could get confused with `single` in ide content assist || `assignabledisposable`? `referencedisposable`? || closed by #4070 || i think `serialdisposable` is good enough now ||;1;0;merge serialdisposable and multipleassignmentdisposable;
4074;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: use more disposablehelper and subscriptionhelper in operators.;;;0;2x: use more disposablehelper and subscriptionhelper in operators;;;;;;1;1;use more disposablehelper and subscriptionhelper in operators;
4080;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: replace custom empty disposables with global instance.;i keep thinking i found all of these and then more crop up;;0;2x: replace custom empty disposables with global instance;i keep thinking i found all of these and then more crop up; there are still some empty disposable objects in those files:flowablethrottlefirsttimedjavaflowabletimeouttimedjavanbpoperatorthrottlefirsttimedjavanbpoperatortimeouttimedjavashould they also be replaced with emptydisposableinstance? || no those are marker instances that must be discernable from emptyon fri jun 24 2016 5:12 am niklas baudy notifications@githubcom wrote:> there are still some empty disposable objects in those files:> > flowablethrottlefirsttimedjava> flowabletimeouttimedjava> nbpoperatorthrottlefirsttimedjava> nbpoperatortimeouttimedjava> > should they also be replaced with emptydisposableinstance?> > > you are receiving this because you authored the thread> reply to this email directly view it on github>  or mute the thread>   ||;;;;1;1;replace custom empty disposables with global instance;
4081;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: do not leak the disposed marker instance into public api.;if this were to be used by public code it could have have very bad effects by causing operators to think that they already disposed resources when they actually had not. since  disposable  is stateless it s safe for  disposed()  and  empty()  to be synonymous  although that might change in the future so both methods are retained.;;0;2x: do not leak the disposed marker instance into public api;if this were to be used by public code it could have have very bad effects by causing operators to think that they already disposed resources when they actually had not since `disposable` is stateless its safe for `disposed()` and `empty()` to be synonymous although that might change in the future so both methods are retained;  ;;;;1;1;do not leak the disposed marker instance into public apiif this were to be used by public code it could have have very bad effects by causing operators to think that they already disposed resources when they actually had not since `disposable` is stateless its safe for `disposed()` and `empty()` to be synonymous although that might change in the future so both methods are retained;
4083;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: merge cancelledsubscriber into emptysubscriber.;;;0;2x: merge cancelledsubscriber into emptysubscriber;; **  this for now and work out their existence later ||;;;;1;1;merge cancelledsubscriber into emptysubscriber;
4084;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: more uses of subscriptionhelper.;;;0;2x: more uses of subscriptionhelper;;  ;;;;1;1;more uses of subscriptionhelper;
4087;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: normalize request validation using subscriptionhelper.;;;0;2x: normalize request validation using subscriptionhelper;;this method is super weird with `true` indicating _invalid_ and `false` indicating _valid_ ||   i agree looked like a good idea back then to flip i think it should be straight: true means valid would you like to do the flip? || yep ill add it to my liston thu jun 23 2016 at 3:04 am david karnok notifications@githubcomwrote:> merged #4087  > > you are receiving this because you authored the thread> reply to this email directly view it on github>  or mute> the thread>   ||;;;;1;1;normalize request validation using subscriptionhelper;
4088;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: fix some flaky tests  add more timeout to others;some tests are sensitive to travis hiccups. this adds more timeout to some and reduces heavyness on others.;;0;1x: fix some flaky tests add more timeout to others;some tests are sensitive to travis hiccups this adds more timeout to some and reduces heavyness on others;nit: maybe worth pulling this out to a constant rather than having to update all the locations each time?otherwise  @hzsweers sure your pr is welcome at any time ||  ;;;;1;1;1x: fix some flaky tests add more timeout to others;
4091;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: apply fixes based on pmd suggestions;some notable changes: - move fields to the beginning of a class - remove unnecessary modifiers and initializers - avoid creating objects to early - update most drain algorithm to use the (more modern)  while (e != r)  pattern - pmd has a few incorrect checks: complaining about a final local that gets used in an inner class - adding braces to ifs - documenting deliberately empty methods - fix internal field and method namings - delegate to  exceptions.propagate;;0;1x: apply fixes based on pmd suggestions;some notable changes:- move fields to the beginning of a class- remove unnecessary modifiers and initializers- avoid creating objects to early- update most drain algorithm to use the (more modern) `while (e ! r)` pattern- pmd has a few incorrect checks: complaining about a final local that gets used in an inner class- adding braces to ifs- documenting deliberately empty methods- fix internal field and method namings- delegate to `exceptionspropagate`;travis doesnt pick up this one for some reason reopening ||   /cc @hzsweers @artem-zinnatullin let me know if you want to review this and need some time ||  || ill review it in 24 hours if you dont mind || sure ill return to 2x till then || some of these i really like some i dont documenting empty methods seems like pure noise || updated || @jakewharton we can iterate on the ruleset after this gets   i agree with @jakewharton adding a one-word comment to empty methods does not add substantial information we should disable this warning which doesnt prevent us to document empty methods where it makes sense || okay then if you dont mind lets have the comments in this pr as is and have a separate pr disable the rule ||  sound good! || updated: removed my name swapped the backpressurestategy constants disabled empty method/constructor/catch block rules ||  some minor nits lgtm  thanks @hzsweers! ||;;;;1;1;remove by akarnokd update rules;
4094;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: remove emptysubscriber  start to remove nbpemptysubscriber.;follow up from comments in #4083 and #4085.;;0;2x: remove emptysubscriber start to remove nbpemptysubscriber;follow up from comments in #4083 and #4085;   ;;;;1;1;remove emptysubscriber start to remove nbpemptysubscriber;
4095;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: invert request validation return type for better semantics.;;;0;2x: invert request validation return type for better semantics;;  ;;;;1;1;invert request validation return type for better semantics;
4096;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: convert observable onsubscribe to direct implementation;first part of converting the onsubscribe operators of  observable  into direct implementors of  observable  - saves allocation.  don t worry about the unnecessary parenthesis  will be removed in a future pr.;;0;2x: convert observable onsubscribe to direct implementation;first part of converting the onsubscribe operators of `observable` into direct implementors of `observable` - saves allocationdont worry about the unnecessary parenthesis will be removed in a future pr;;;;;1;1;2x: convert observable onsubscribe to direct implementation;
4097;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: update map() and filter() to implement onsubscribe directly;this change reduces the indirection and allocation count when using  map  or  filter .;;0;1x: update map() and filter() to implement onsubscribe directly;this change reduces the indirection and allocation count when using `map` or `filter`;   thanks @stevegury ! could you give your opinion about #4098 as well? ||  // great that we have enough tests and coverage reports to perform such rewrites! ||;;;;1;1;1x: update map() and filter() to implement onsubscribe directly;
4101;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: switch a serialresource use to serialdisposable.;;;0;2x: switch a serialresource use to serialdisposable;;  ;;;;1;1;switch a serialresource use to serialdisposable;
"4102;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: expose isdisposed method on disposable.;this is a fairly  dumb  addition. there s lots of room for follow-up improvement in the utilization of base helper classes and even removing some now-duplicated state management.  closes #4075.;;4075.0;2x: expose isdisposed method on disposable;""this is a fairly """"dumb"""" addition theres lots of room for follow-up improvement in the utilization of base helper classes and even removing some now-duplicated state managementcloses #4075"";there are a bunch of compilation errors:  || probably missing imports i have to edit those by hand in each file so thediffs dont go wildon fri jun 24 2016 at 2:59 am david karnok notifications@githubcomwrote:> there are a bunch of compilation errors:>  > > you are receiving this because you authored the thread> reply to this email directly view it on github>  or mute the thread>   ||   :+1: thanks  ||;2x: expose disposableisdisposed()?;in `disposablejava` currently:``` java// todo lets see if we really need this// boolean isdisposed()```i think we should add this since `dispose()` already states:> dispose the resource the operation should be idempotentwhich means every disposable already needs a mechanism for idempotence which should trivially translate into `isdisposed()`theres some massive refactors that can be done if this change is made `booleandisposable` can completely disappear from the public api since `disposablesfrom(runnable)` + `disposablesempty()` mimic its behavior additionally a large portion of the other internal custom disposables can be rewritten to build on an internal `booleandisposable` which manages both idempotence and the `isdisposed()` implementation for youi did some of this work last night as an experiment and it looks like a good win the argument against the refactor would be if theres a reason we dont actually want to expose `isdisposed()` on `disposable` directly ill note that `booleandisposable` is not unique in having an `isdisposed()` method most other implementations also have this method they simply dont share it from the interface;""and im volunteering for this work if that wasnt obvious || the problem with adding `isdisposed` that it mandates stateful `disposable` implementations for all use cases (empty cant be constant but requires newing up a new instance because it has to switch to disposed state in a visible manner) as the current 2x demonstartes checking for `isdisposed` is only required by a few container classes thus id like to keep `disposable` as is you can introduce an interface on top of it for the container classes if you really want to || ok let me see how far i can get without exposing method i did see that empty had to become a factory as a result but i dont know how frequent the need for an empty instance is such that it would be a problem || after more investigation it looks like `empty()` is the _only_ stateless `disposable` in the entire lib aside from `disposed()` every other implementation is stateful and if it doesnt already declare `isdisposed()` it can do so triviallytell me what you think about this plan:1 document `disposablehelperdisposed` as a marker instance to be compared by identity (done in #4081) and `emptydisposableinstance` as a no-op implementation to be used internally as a value2 change `disposablesempty()` to return `new booleandisposable()`3 uncomment `isdisposed()` on `disposable` and ensure a proper implementation on all implementationsthat said im not convinced `empty()` needs to even exist as a public api but if it does then its likely used so rarely that the fact that it needs to allocate a single tiny object shouldnt matter internally all """"empty"""" values will use `emptydisposableinstance` which will behave like an already-disposed `disposable` || okay go ahead with the pr || "";1;0;expose isdisposed method on disposable;"
4103;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: prepare the operator-fusion enhancement;this pr adds 3 operator-fusion related interfaces:  -  queuesubscription  will support fusion for  flowable  - avoid creating queues  avoid cost of multiple enqueue-dequeue  reduce  request()  overhead -  queuedisposable  will support fusion for  observable  - avoid creating queues  avoid cost of multiple enqueue-dequeue -  scalarcallable  - indicate a scalar constant source  in addition  conditionalsubscriber  is marked and will be moved to the new package and its method renamed to  tryonnext .  unlike reactor-core (and rsc)  there is no  fuseable  marker interface. the ability of fusing is indicated by calling  onsubscribe  with the above  queuex  enabled instances and then called back via  requestfusion . this allows having less duplicated code compared to reactor/rsc - at the cost of usually one extra field to store the  queuex  value that may be null.;;0;2x: prepare the operator-fusion enhancement;this pr adds 3 operator-fusion related interfaces: - `queuesubscription` will support fusion for `flowable` - avoid creating queues avoid cost of multiple enqueue-dequeue reduce `request()` overhead- `queuedisposable` will support fusion for `observable` - avoid creating queues avoid cost of multiple enqueue-dequeue- `scalarcallable` - indicate a scalar constant sourcein addition `conditionalsubscriber` is marked and will be moved to the new package and its method renamed to `tryonnext`unlike reactor-core (and rsc) there is no `fuseable` marker interface the ability of fusing is indicated by calling `onsubscribe` with the above `queuex` enabled instances and then called back via `requestfusion` this allows having less duplicated code compared to reactor/rsc - at the cost of usually one extra field to store the `queuex` value that may be null;  nice ;;;;1;1;2x: prepare the operator-fusion enhancement;
4105;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: remove some superfluous reads before writes.;;;0;2x: remove some superfluous reads before writes;;  ;;;;1;1;remove some superfluous reads before writes;
4106;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: remove explicit cancel flags where it can be inferred.;i suspect there s quite a few of these all over. these are just the ones i noted while doing other changes.;;0;2x: remove explicit cancel flags where it can be inferred;i suspect theres quite a few of these all over these are just the ones i noted while doing other changes;  ;;;;1;1;remove explicit cancel flags where it can be inferred;
4107;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: make sure the helper returns true if the pre-swap value was null;the original behavior was somewhat inconsistent: if the target was null before the cancel/dispose  the method didn t return true indicating a successful swap for the current thread. now that many  cancelled  flag has been removed  it has to consistently trigger the remaining cleanup actions.;;0;2x: make sure the helper returns true if the pre-swap value was null;the original behavior was somewhat inconsistent: if the target was null before the cancel/dispose the method didnt return true indicating a successful swap for the current thread now that many `cancelled` flag has been removed it has to consistently trigger the remaining cleanup actions;;;;;1;1;2x: make sure the helper returns true if the pre-swap value was null;
4108;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: invert subscription validation return type for better semantics.;;;0;2x: invert subscription validation return type for better semantics;;similar to #4095 ||   ;;;;1;1;invert subscription validation return type for better semantics;
4110;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: remove explicit cancel flags where it can be inferred.;;;0;2x: remove explicit cancel flags where it can be inferred;;code looks ok but is the ci failure related to your changes? || i see it locally so it must be will look later tonight and try to figure out which is the cause ||  ;;;;1;1;remove explicit cancel flags where it can be inferred;
4111;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: simplify boolean disposables which run code on dispose.;;;0;2x: simplify boolean disposables which run code on dispose;;theres some classes in `internal` which could probably also extend from this type so we might want to move it to `internaldisposables` and make it public for their use in the future || another option to make this more widely applicable would be to have a single class and accept a `consumer<t> disposer` that might open it up for use in more places internally ||   you can experiment with that if you wish;;;;1;1;simplify boolean disposables which run code on dispose;
4112;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: switch the last serialresource to manual resource management.;;;0;2x: switch the last serialresource to manual resource management;;test failure is flake #4054 || new one? doesnt fail locally```ioreactivexinternaloperatorsflowableflowablereplaytest > testasynccomeandgo failed    javalangassertionerror: error(s) present: [ioreactivexexceptionsmissingbackpressureexception: cant deliver value 184 due to lack of requests]        at ioreactivexsubscriberstestsubscriberfail(testsubscriberjava:355)        at ioreactivexsubscriberstestsubscriberassertnoerrors(testsubscriberjava:418)        at ioreactivexinternaloperatorsflowableflowablereplaytesttestasynccomeandgo(flowablereplaytestjava:1022)        caused by:        ioreactivexexceptionscompositeexception            at ioreactivexsubscriberstestsubscriberfail(testsubscriberjava:356)             2 more            caused by:            ioreactivexexceptionscompositeexception$compositeexceptioncausalchain: chain of causes for compositeexception in order received >                caused by:                ioreactivexexceptionsmissingbackpressureexception: cant deliver value 184 due to lack of requests``` ||  **  #4112  into 2x  will> increase coverage by _ ;;;;1;1;switch the last serialresource to manual resource management;
4114;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: case io acronym like a word.;this is already being done in the library  and is fairly [standard practice](https://google.github.io/styleguide/javaguide.html#s5.3-camel-case).;;0;2x: case io acronym like a word;this is already being done in the library and is fairly [standard practice](https://googlegithubio/styleguide/javaguidehtml#s53-camel-case); ;;;;1;1;case io acronym like a word;
4118;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: provide an explanation why certain tests are ignored;during code reading i ve found some tests that are ignored but don t have a record why they are being ignored. some of them have meaningful explanations present as line comments  so i decided to make them the parameters of  @ignore  annotation  so it will be correct.;;0;1x: provide an explanation why certain tests are ignored;during code reading ive found some tests that are ignored but dont have a record why they are being ignored some of them have meaningful explanations present as line comments so i decided to make them the parameters of `@ignore` annotation so it will be correct; ;;;;1;1;1x: provide an explanation why certain tests are ignored;
4120;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: provide an explanation why certain tests are ignored;the same as #4118  but for 2.x;;0;2x: provide an explanation why certain tests are ignored;the same as #4118 but for 2x; ;;;;1;1;2x: provide an explanation why certain tests are ignored;
4122;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;refactor conditionalsubscriber  add base fuseable subscribers;this pr refactors  conditionalsubscriber  and renames its method to  tryonnext . in addition  two new abstract subscriber types were added:  basicfuseablesubscriber  and  basicfuseableconditionalsubscriber  to help writing operators that support fusion (queue and/or conditional).;;0;refactor conditionalsubscriber add base fuseable subscribers;this pr refactors `conditionalsubscriber` and renames its method to `tryonnext` in addition two new abstract subscriber types were added: `basicfuseablesubscriber` and `basicfuseableconditionalsubscriber` to help writing operators that support fusion (queue and/or conditional); ;;;;1;1;refactor conditionalsubscriber add base fuseable subscribers;
4124;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;switch some observable ops to direct  map fuseable;- switch a few  observable  operators to direct implementations (reduces allocation) - update  map  to support operator fusion  there are no sources or consumer yet though. - adjust  basicfuseablex  to have different default conveniences - modify  compositeresource  to indicate success of the mutator methods - increase timeout of  flowableonbackpressuredroptest.testfixbackpressurewithbuffer;;0;switch some observable ops to direct map fuseable;- switch a few `observable` operators to direct implementations (reduces allocation)- update `map` to support operator fusion there are no sources or consumer yet though- adjust `basicfuseablex` to have different default conveniences- modify `compositeresource` to indicate success of the mutator methods- increase timeout of `flowableonbackpressuredroptesttestfixbackpressurewithbuffer`; ;;;;1;1;switch some observable ops to direct map fuseable;
"4125;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: test all private constructors;;;0;1x: test all private constructors;;""  :+1: great!/cc @artem-zinnatullin  ||  now im not that fanatic regarding testing private constructors but since test coverage causes addiction and constant desire to increase it  lets merge it! || can i suggest in the spirit of dry that you make a static method available somewhere (a new class `testingutil` say) like this:``` javapublic static void checkconstructorprivate(class<?> cls)  {    privateconstructorchecker         forclass(cls)        expectedtypeofexception(illegalstateexceptionclass)        expectedexceptionmessage(""""no instances!"""")check()}```and call that instead? || thanks!@davidmoten ill refactor those checks into a simple call as you and [i]( suggested || "";;;;1;1;revert exception type and message back;"
4126;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove xresource classes;this pr removes the  xresource  types and replaces them with  xdisposable  or  xsubscription  where necessary.;;0;remove xresource classes;this pr removes the `xresource` types and replaces them with `xdisposable` or `xsubscription` where necessary; ;;;;1;1;remove xresource classes;
4127;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: correct method name for flowable-->observable.;;;0;2x: correct method name for flowable-->observable;; ;;;;1;1;correct method name for flowable-->observable;
4128;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: reduce the visibility of internal methods.;;;0;2x: reduce the visibility of internal methods;; ;;;;1;1;reduce the visibility of internal methods;
4129;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: cleanup of pmd suggestions;this pr adjusts the pmd rules and fixes about 300 suggestions.;;0;2x: cleanup of pmd suggestions;this pr adjusts the pmd rules and fixes about 300 suggestions; ;;;;1;1;2x: cleanup of pmd suggestions;
4133;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;refactor private constructor checker into a utility class;move into  testutil.checkutilityclass() .;;0;refactor private constructor checker into a utility class;move into `testutilcheckutilityclass()`;   /cc @davidmoten  || ;;;;1;1;refactor private constructor checker into a utility class;
4134;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: cleanup and test renames;this pr adds the missing  @override  annotations and renames the  observable  unit tests to conform a single name pattern.;;0;2x: cleanup and test renames;this pr adds the missing `@override` annotations and renames the `observable` unit tests to conform a single name pattern; ;;;;1;1;2x: cleanup and test renames;
4136;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: enable fuseable sources  adjust operators;- adds an operator  hide  to allow hiding and breaking optimizations - update  filter  to support fusions: queue and conditional -  range  now supports fusion: sync-queue and conditional -  fromarray  now supports fusion: sync-queue and conditional -  fromiterable  now supports fusion: sync-queue and conditional - enhanced  testsubscriber  methods to return this - allows chaining the assertions - extended  testsubscriber  to act as a consumer for queue-fusion - introduced  flowablesource  as an intermediate type for operators: allows discovering the upstream in a standard way  allows the ide to generate a constructor with a source value. - added  basicqueuesubscription  that locks down unused  queue  methods plus is a container for an atomic long value useful for request/wip tracking.;;0;2x: enable fuseable sources adjust operators;- adds an operator `hide` to allow hiding and breaking optimizations- update `filter` to support fusions: queue and conditional- `range` now supports fusion: sync-queue and conditional- `fromarray` now supports fusion: sync-queue and conditional- `fromiterable` now supports fusion: sync-queue and conditional- enhanced `testsubscriber` methods to return this - allows chaining the assertions- extended `testsubscriber` to act as a consumer for queue-fusion- introduced `flowablesource` as an intermediate type for operators: allows discovering the upstream in a standard way allows the ide to generate a constructor with a source value- added `basicqueuesubscription` that locks down unused `queue` methods plus is a container for an atomic long value useful for request/wip tracking; ;;;;1;1;2x: enable fuseable sources adjust operators;
"4139;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix flaky tests;this pr should fix some test timing out otherwise sensitive to thread hiccups. #4138 #4109 #4054;;405.0;2x: fix flaky tests;this pr should fix some test timing out otherwise sensitive to thread hiccups#4138#4109#4054;  ;combinewithmostrecent;im looking for an operation which does the following:whenever observable o1 emits an item combine this item with the most recent item of observable o2illustration:```----a-------b------c----->  o1--0----1-2----3-4-------->  o2    |       |      |    v       v      v  (a0)   (b2)  (c4)```i cant find a nice way of doing thiscan anyone help me?or do we need to add a new operation to `rxobservable`?;""actually `combinelatest` together with `distinctuntilchanged` with equality based on the tuple projection would work here i think maybe theres an easier way but this is what first came to my mind || but what if o1 emits two equal items in sequence? || if that is part of your problem were discussing the distinct operator here  || maybe this is a `join` use case? i found a description [here]( || join is hardly ever used and the semantics are subtle and because of all the functions you need to pass pretty nasty if you dont have groupby query comprehension syntaxbut implementing it would be a fun task for anyone that wants to dig down to the next level of detailwatch  first > on sep 24 2013 at 7:32 am joachim hofer notifications@githubcom wrote:> > maybe this is a join use case? i found a description here> > > reply to this email directly or view it on github || this means that maybe its a good idea to add `combinewithmostrecent` (as described by @samuelgruetter) as an operator? - to me it sounds like a relatively frequent use case || i have similar problem - came up with:```public static <t u r> observable<r> enrich(observable<t> source observable<u> data func2<t u r> f) {    return observablezip(source datasample(source) f)}```but noticed sample() doesnt really sample input - it doesnt emit last value multiple times when no change occured between timer causing zip operation to get out of sync isnt that a bug (or at least serious documentation problem) with sample()?marcin || i agree thats inconsistent: `sample(long timeunit)` emits the last value multiple times if the source observable didnt emit a new value between two ticks but `sample(observable<u>)` does not repeat it and [this line]( suggests it was done on purpose but i think `sample(observable<u>)` should be changed to match the behavior of `sample(long timeunit)` || how about this?``` groovy    observablecombinelatest(a b { x y -> [x y] })        distinctuntilchanged({ tuple -> tuple[0]})        distinctuntilchanged({ tuple -> tuple[1]})        toblockingobservable()foreach({ v-> println(v)})``` || regarding issue1: how to get combinewithmostrecent/enrich behavior: what if the source observable `a` emits two equal values in succession? we still want to see this in the resulting observable so we cant use an approach with `distinctuntilchanged`regarding issue2: is the behavior of `sample(observable<u>)` correct? @benjchristensen what do you think? || the `sample` operator was  in v0182 || note: the `sample` operator was indeed fixed but not the way @zorba128 and me would have expected  `sample(observable<u>)` and `sample(long timeunit)` are now consistent and both do **not** emit the last value multiple times if it hasnt changed between two sampler ticks[ive reread this thread because this question was asked on [stackoverflow]( || would something like the following work:``` javaobservableacombinewithmostrecentfrom(observableb)```this would different from `combinelatest` as it would not emit all permutations it would only emit when `a` emits and take whatever the last from `b` was then the `a` observable could be the """"slow one"""" and we just grab whatever the last from `b` was  || guys guys we need to solve this one ive been using this """"combinewithmostrecent"""" or """"enrich"""" (i call it """"combineprev"""") many times in an android project in production its very useful basically what we need is the asymmetric version of combinelatest i used to have an implementation of it based on `join` and i informed @mattpodwysocki that it would be good if we could do that in rxjs too see  implementation of the operator with join is this:``` java /**   * similar to combinelatest except it joins the latestitems from the two source   * observables only when the first observable emits an item   *    * first:  ------f----f-------------f--------------f----|>   * second: ---s1----------s---s--s3-----s-s-s-s4--------|>   * result: ------r1---r1------------r3-------------r4---|>   *    * @param first   *        the first source observable   * @param second   *        the second source observable   * @param combinefunction   *        the aggregation function used to combine the items emitted by the source   *        observables   * @return an observable that emits items that are the result of combining the items   *         emitted by the source observables by means of the given function   */  public static <tfirst tsecond r> observable<r> combineprev(    final observable<tfirst> first     final observable<tsecond> second     final func2<tfirst tsecond r> combinefunction)   {    final observable<tsecond> hotsecond  secondpublish()refcount()    return firstjoin(hotsecond new func1<tfirst observable<object>>() {      public observable<object> call(final tfirst it) {        return observable<object>empty()      }    } new func1<tsecond observable<tsecond>>() {      public observable<tsecond> call(final tsecond it) {        return hotsecond      }    } combinefunction)  }```but i just figured a much simpler implementation based only on map and switch basically this:```amap({a -> bmap({b -> [a b]})})switch()```see [this stackoverflow answer i wrote]( || > not the way @zorba128 and me would have expectedwhat was expected? it emits the last item in a given time window if something was emitted if nothing was emitted then nothing is emitted at the end of the time window  || > we need to solve this onesure lets get it solved once  is confirmed lets add a new operator marked with `@beta` and make sure it works well for everyone and then in 11 or 12 we can mark it as stable and remove the `@beta` marker  || so we just need to find a proper name for it i prefer shorter names but `enrich` didnt ring a bell to me maybe `samplecombine`? || its not quite `sample` though as its not sampling with a time interval it really is just taking whatever the last value is similar to `behaviorsubject` or `blockingobservablelatest()` the static `observablecombinatelatest` combines all permutations of all observables it combines to confirm here we want to combine every value from one observable with the latest or most recent of another correct?it feels like an instance method of `combinewithmostrecent` or `combinewithlatest` or is `combine` too confusing with the static `combinelatest` that does all permutations?it ends up being very similar to `zipwith` if we had a `zipwithlatest` variant?does this have a proper name in haskell scala or some other functional language that im unaware of? @headinthebox your input on this would be helpful  || let me think what the shortest way to implement this is using the existing combinators cant believe it is very long but i am jetlagged -) || this appears to be producing the expected results:``` javapublic class combinewhenother {    public static void main(string args) {        publishsubject<integer> source  publishsubjectcreate()        behaviorsubject<integer> other  behaviorsubjectcreate()        sourceconcatmap(e -> othertake(1)map(f -> e + f))        subscribe(systemout::println throwable::printstacktrace                        () -> systemoutprintln(""""done""""))        sourceonnext(1)        otheronnext(10)        otheronnext(20)        otheronnext(30)        sourceonnext(2)        sourceonnext(3)        otheronnext(40)        sourceoncompleted()    }}```but both sources are hot and since we dont have multicast() i dont know how to convert a general other observable to behaviorsubject with the stable api || sorry with this implementation```amap({a -> bmap({b -> [a b]})})switch()```i forgot to mention that b must be hot> its not quite sample though as its not sampling with a time interval it really is just taking whatever the last value is similar to behaviorsubject or blockingobservablelatest()it is sample as in `asample(b)` combined with `b` it is not sampling with a time interval it is sampling with b as the sampler see this [jsfiddle]( (c is `asample(b)`)> the static observablecombinelatest combines all permutations of all observables it combines> > to confirm here we want to combine every value from one observable with the latest or most recent of another correct?> > it feels like an instance method of combinewithmostrecent or combinewithlatest or is combine too confusing with the static combinelatest that does all permutations?if we _could_ afford renaming existing operators one suggestion is `combinesymmetric` for `combinelatest` and `combineasymmetric` for this new one the problem with names such as `combinewithmostrecent`and `combinewithlatest` is that in english they mean basically the same as `combinelatest` and a lot of confusion can emerge from this ambiguityanother thing to keep in mind is that this new operator is an instance method and shouldnt have a static version because of the asymmetric behavior there should be one source observable that commands the emission of the resulting observableif we take that into consideration we could name it `withlatest` since it will be always applied on some source observable `a`:```c  awithlatest(b combinefunction)```another insight is that since the `c` observable emits at the same time `a` emits we can take advantage of the `map` concept `mapwithlatest` could work as a namemy humble suggestions are then either `samplecombine` or `withlatest` or `mapwithlatest`  || > would something like the following work:> > ```> observableacombinewithmostrecentfrom(observableb)> ```> > this would different from combinelatest as it would not emit all permutations it would only emit when a emits and take whatever the last from b was thats exactly what i was looking for> > not the way @zorba128 and me would have expected> > what was expected? it emits the last item in a given time window if something was emitted if nothing was emitted then nothing is emitted at the end of the time window> >  example if i sample an audio signal `s` at a frequency of 44100 hz i expect to get one sample every 1/44100 seconds no matter what the shape of `s` is taking this analogy to observables id expect that```myobservablesample(50 milliseconds)```emits an element every 50 milliseconds no matter when `myobservable` emits how many items that is id expect that if nothing was emitted in the time window the last value is repeatedbut i agree that the way rxjava understands """"sample"""" also makes sense and its well explained in the docs what happens so im not saying we should change anything> if we take that into consideration we could name it `withlatest` since it will be always applied on some source observable `a`:> > ```> c  awithlatest(b combinefunction)> ```i think `withlatest` would be a nice name || i agree this is a very useful operator and @staltz  i like your map - switch implementation just for cross-reference i have already raised this issue (#912) some time agonaming the new operator indeed is difficult now that `sample` is taken perhaps `sampleeach` could be considered to express that there is a difference in behavior to `sample` while still asserting that it is sampling in some sense? || or what about `combinesampled`? i like how it is simillar to `combinelatest` - both do combining both have same type signatures (`(t u) > (t u)`) they but they differ in _what_ they combine - either latest values or values taken at times defined by the sampler they even sort close alphabetically so the user can see he has a choice what suits him best`sampleeach` could be used as an alternative to just `sample` with slightly different behavior (not filtering out non-changed values) if need for its inclusion in the library ever arises (but it can be trivially replaced  combinesampled` so it will probably not) || @dvtomas if we would use `acombinesampled(b combinefunction)` it would sound like we are combining `a` with `bsample(something)` while in reality we are combining `asample(b)` with `b`  || or `acombinewithlatestof(b throughafunction)` || @staltz sorry cant see it my mind is already too deeply connected with my interpretation also i work in scala the combinefunction would probably be absent it would be just `a combinesampled b` i havent thought of java@akarnokd that sounds reasonable wrt to `combinelatest` being widely understood and used i had to go through some pondering about what the `latest` part in `combinelatest` really means first to appreciate that || > it would be just `a combinesampled b` i havent thought of javaso to clarify which of `a` or `b` do you think is being sampled by the other in this `a combinesampled b` idiom? how are you """"reading"""" this in plain english? || @staltz i see your point now it reads roughly as _`a` combine with sampled `b`_ (sampled with what?) thats not right i like @akarnokds  `combinewithlatestof` the best so far || @dvtomas precisely when we say """"sampled b"""" we think """"we take samples of b"""" which to rxjava translates to `bsample(something)` which does not happen in reality i dont want this to become a [gotcha]( || now implemented in [rxjs as `withlatestfrom`]( i would make a pr in rxjava as well but im having a hard time navigating through the core in the codebase maybe someone else familiar with the codebase could implement it?the implementation can be roughly ```amap({a -> hotbmap({b -> [a b]})})switch()```or a state machine like i did in rxjs ||  are asking for this operatorsome one please implement it? || :+1: i have had 4 separate instances of need of this in the last two weeks that i felt dirty working around! || ill do this || :+1:  see #2760 for the proposed name and behavior || this issue can be closed || the `window` operator looks like an interesting option for building this the initial drawing looks almost exactly like the marble diagram for the operator![window marble diagram]( || damn it i couldnt stop thinking about this all night```package asdfimport static rxobservablezipimport rxsubjectspublishsubjectimport rxsubjectssubjectpublic class main {    private static class tuple {        public final string t        public final int i        tuple(string t int i) {            thist  t            thisi  i        }        @override        public string tostring() {            return t + """":"""" + i        }    }    public static void main(string args) {        subject<string string> trigger  publishsubjectcreate()        subject<integer integer> data  publishsubjectcreate()        triggerpublish(trigger_ -> {            return zip(trigger_ datawindow(trigger_)flatmap(window -> windowlastordefault(-1)) tuple::new)        })scan((last curr) -> curri  -1 ? new tuple(currt lasti) : curr)subscribe(systemout::println)        dataonnext(0)        triggeronnext(""""a"""")        dataonnext(1)        dataonnext(2)        triggeronnext(""""b"""")        triggeronnext(""""c"""")        dataonnext(3)        dataonnext(4)        triggeronnext(""""d"""")    }}```produces the output```a 2c 4```it would simpler if you dont need the triggers value```package asdfimport rxsubjectspublishsubjectimport rxsubjectssubjectpublic class main {    public static void main(string args) {        subject<string string> trigger  publishsubjectcreate()        subject<integer integer> data  publishsubjectcreate()        datawindow(trigger)flatmap(window -> windowlastordefault(-1))scan((last curr) -> curr  -1 ? last : curr)subscribe(systemout::println)        dataonnext(0)        triggeronnext(""""a"""")        dataonnext(1)        dataonnext(2)        triggeronnext(""""b"""")        triggeronnext(""""c"""")        dataonnext(3)        dataonnext(4)        triggeronnext(""""d"""")    }}```produces the output```0224``` || @abersnaze or just``` javaaswitchmap({a -> hotbmap({b -> [a b]})})``` || i had to change the variable names to grok it  much better than mine`dataswitchmap(i -> triggermap(t -> new tuple(t i)))subscribe(systemout::println)` || "";1;0;2x: fix flaky tests;"
4139;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix flaky tests;this pr should fix some test timing out otherwise sensitive to thread hiccups. #4138 #4109 #4054;;4109.0;2x: fix flaky tests;this pr should fix some test timing out otherwise sensitive to thread hiccups#4138#4109#4054;  ;2x: nbpoperatorconcattest > testissue2890nostackoverflow failed;looks like a timeout issue```ioreactivexinternaloperatorsobservablenbpoperatorconcattest > testissue2890nostackoverflow failed    javalangassertionerror: expected:<5000> but was:<3797>        at orgjunitassertfail(assertjava:88)        at orgjunitassertfailnotequals(assertjava:834)        at orgjunitassertassertequals(assertjava:645)        at orgjunitassertassertequals(assertjava:631)        at ioreactivexinternaloperatorsobservablenbpoperatorconcattesttestissue2890nostackoverflow(nbpoperatorconcattestjava:730)```;closing via #4139 ||;1;0;2x: fix flaky tests;
4139;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix flaky tests;this pr should fix some test timing out otherwise sensitive to thread hiccups. #4138 #4109 #4054;;4138.0;2x: fix flaky tests;this pr should fix some test timing out otherwise sensitive to thread hiccups#4138#4109#4054;  ;2x: flowablereplaytest > testasynccomeandgo;could be an bug with `replay()` or the fact that it goes lockstep and doesnt request in time if the further downstream (observeon) is slow```ioreactivexinternaloperatorsflowableflowablereplaytest > testasynccomeandgo failed    javalangassertionerror: error(s) present: [ioreactivexexceptionsmissingbackpressureexception: cant deliver value 236 due to lack of requests]        at ioreactivexsubscriberstestsubscriberfail(testsubscriberjava:397)        at ioreactivexsubscriberstestsubscriberassertnoerrors(testsubscriberjava:465)        at ioreactivexinternaloperatorsflowableflowablereplaytesttestasynccomeandgo(flowablereplaytestjava:1022)        caused by:        ioreactivexexceptionscompositeexception            at ioreactivexsubscriberstestsubscriberfail(testsubscriberjava:398)             2 more            caused by:            ioreactivexexceptionscompositeexception$compositeexceptioncausalchain: chain of causes for compositeexception in order received >                caused by:                ioreactivexexceptionsmissingbackpressureexception: cant deliver value 236 due to lack of requests```;closing via #4139 || its [back]( || closing again havent encountered this for a while ||;1;0;2x: fix flaky tests;
"4140;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: change completable.subscribe(onerror  oncomplete) to (oncomplete  onerror);closes #3851  closes #4137.;;3851.0;1x: change completablesubscribe(onerror oncomplete) to (oncomplete onerror);closes #3851 closes #4137;actually i can deprecate old one and add new one as overload it will have less impact on user code because only calls like `subscribe(actionsempty() actionsempty())` will be ambiguous to the compilerthoughts? ||    dynamic languages have trouble with the two methods lets only have 1 method || ;completablesubscribe(onerror oncomplete) design issue;""this [particular overload]( of `completablesubscribe()` looks out of design in compare to other rxjava classes like `observable` and `single`spent ~5 minutes trying to understand why such code didnt compile:``` javacompletable  fromaction(() -> dosomething())  subscribe(    () -> uisuccess()     error -> uierror(error)  )```and the reason is because this overload accepts `error` handler **first** and `complete` handler secondi do understand that it comes from `observablesubscribe(onnext onerror oncomplete)` but in compare to many other overloads like:- `observablesubscribe(onnext onerror)`- `singlesubscribe(onsuccess onerror)` // this one has very similar semantic to target overload- `observablesubscribe(onnext)`- `singlesubscribe(onsuccess)`error handler is **never first** parameter in `observablesubscribe()` and `singlesubscribe()`another point is that compiler error displayed in ide makes it even worse:<img width""""303"""" alt""""screen shot 2016-04-12 at 00 35 50"""" src"""" is still in `@experimental` so we can change this signature as we want we can `@deprecate` this overload and add """"better"""" alternative and then delete deprecated overload after one-two releases"";the design pattern was:``` javasubscribe(action0 oncomplete)subscribe(action0 oncomplete action1<throwable> onerror)``` || @akarnokd what do you mean by> was? || i mean that is your suggestion but the current is swapped for case 2 because it is in the same order as the 3 arg `observablesubscribe` minus `onnext` not sure which order feels more consistent with the other classes || right i pointed that in the issue description but we do have `singlesubscribe(onsuccess onerror)` even though its also `observablesubscribe(onnext onerror oncomplete)` minus `onnext`as said before: no other overloads of `subscribe()` in any classes accept `onerror` first -> makes `completable` inconsistent || okay since completable is experimental lets swap the arguments as you suggested || oh great will do pr soon! ||;1;0;1x: change completablesubscribe(onerror oncomplete) to (oncomplete onerror);"
4140;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: change completable.subscribe(onerror  oncomplete) to (oncomplete  onerror);closes #3851  closes #4137.;;4137.0;1x: change completablesubscribe(onerror oncomplete) to (oncomplete onerror);closes #3851 closes #4137;actually i can deprecate old one and add new one as overload it will have less impact on user code because only calls like `subscribe(actionsempty() actionsempty())` will be ambiguous to the compilerthoughts? ||    dynamic languages have trouble with the two methods lets only have 1 method || ;inverted onerror and oncomplete in completable;in completable subscribe method there is inverted order of methods (in compare to ex observable) in every other classes there is onnext/onsucces first and in completable there is onerror first;dupe of #3851  || closing as duplicate if you have time you could post a pr that swaps the params as described in #3851 ||;1;0;1x: change completablesubscribe(onerror oncomplete) to (oncomplete onerror);
4142;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: add rxjavahooks tests  fix small bugs;this pr adds unit tests for the new  rxjavahooks  facility and fixes - small mistakes in calling the right hook. - dealing with constant  completable  sources such as  complete()  and  never() : they executed the hook on class initialization so they couldn t be properly overridden later via an  oncreate  hook. (this could affect the other constants and will be addressed separately.);;0;1x: add rxjavahooks tests fix small bugs;this pr adds unit tests for the new `rxjavahooks` facility and fixes- small mistakes in calling the right hook- dealing with constant `completable` sources such as `complete()` and `never()`: they executed the hook on class initialization so they couldnt be properly overridden later via an `oncreate` hook (this could affect the other constants and will be addressed separately);  updated ||;;;;1;1;use static assert update conpletable param name;
4145;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;observable direct rest;this concludes the architecture switch for 2.x.;;0;observable direct rest;this concludes the architecture switch for 2x;  @jakewharton do you want to review this? || lgtm  thanks @jakewharton ! ||;;;;1;1;last set of operators test renames;
4146;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix the initialization of completable.complete();i forgot to invert the nohook -> usehook change.;;0;fix the initialization of completablecomplete();i forgot to invert the nohook -> usehook change;the related tests failed for me due to test ordering if they were the very first encounters of `completable` ||  ;;;;1;1;fix the initialization of completablecomplete();
4151;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: enable scalar and async fuseable sources and intermediates;this pr enables operator fusion for scalar and knowingly single-element sources.  there are no fusion-consumers yet.;;0;2x: enable scalar and async fuseable sources and intermediates;this pr enables operator fusion for scalar and knowingly single-element sourcesthere are no fusion-consumers yet;  @jakewharton @artem-zinnatullin want to take a look? || yes in 24 hours if you dont mind || lgtm    thanks to everyone for the review ||;;;;1;1;2x: enable scalar and async fuseable sources and intermediates;
"4154;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;ability to create custom schedulers with behavior based on composing operators.;based on #4115  allows the use of operators for controlling the timing around when actions scheduled on workers are actually done. this makes it possible to layer additional behavior on an existing  scheduler . the main parameter is a function that flattens an  observable<completable>  into just one  completable . there must be a chain of operators connecting the returned value to the source observable otherwise any work scheduled on the scheduler will not be executed.  when  scheduler.createworker()  is invoked a  completable  is onnext d to the combinator to be flattened. if the  completable  is not immediately subscribed to an calls to  worker.schedule()  are buffered. once the  completable  is subscribed to actions are then scheduled on the actual scheduler. when the  worker  is unsubscribed the  completable  emits an oncomplete and triggers any behavior in the flattening operator. the  observable<completable>  and all  completable s give to the flattening function never onerror.  slowing down the rate to no more than than 1 a second.      java  scheduler slowsched = new schedulewhen(workers -> {     // use concatenate to make each worker happen one at a time.     return completable.concat(workers.map(worker -> {         // delay the starting of the next worker by 1 second.         return worker.delay(1  timeunit.seconds)      }))   }  schedulers.computation())       limit the amount concurrency two at a time without creating a new fix size thread pool:      java  scheduler limitsched = new schedulewhen(workers -> {     // use merge max concurrent to two at a time     return completable.merge(workers  2)   }  schedulers.computation());;4115.0;ability to create custom schedulers with behavior based on composing operators;based on #4115allows the use of operators for controlling the timing around when actions scheduled on workers are actually done this makes it possible to layer additional behavior on an existing `scheduler` the main parameter is a function that flattens an `observable<completable>` into just one `completable` there must be a chain of operators connecting the returned value to the source observable otherwise any work scheduled on the scheduler will not be executedwhen `schedulercreateworker()` is invoked a `completable` is onnextd to the combinator to be flattened if the `completable` is not immediately subscribed to an calls to `workerschedule()` are buffered once the `completable` is subscribed to actions are then scheduled on the actual scheduler when the `worker` is unsubscribed the `completable` emits an oncomplete and triggers any behavior in the flattening operator the `observable<completable>` and all `completable`s give to the flattening function never onerrorslowing down the rate to no more than than 1 a second``` java scheduler slowsched  new schedulewhen(workers -> {    // use concatenate to make each worker happen one at a time    return completableconcat(workersmap(worker -> {        // delay the starting of the next worker by 1 second        return workerdelay(1 timeunitseconds)    })) } schedulerscomputation())```limit the amount concurrency two at a time without creating a new fix size thread pool:``` java scheduler limitsched  new schedulewhen(workers -> {    // use merge max concurrent to two at a time    return completablemerge(workers 2) } schedulerscomputation())```;""this test changes its timing pattern when run on one of the merging-customization of this scheduler:``` java@testpublic void fasttasks() {    final scheduler sched  new schedulewhen(new func1<observable<completable> completable>() {        @override        public completable call(observable<completable> workers) {            return completablemerge(workers 2)        }    } schedulerscomputation())    observablerange(1 4)flatmap(new func1<integer observable<string>>() {        @override        public observable<string> call(final integer v) {            return observableinterval(500 timeunitmilliseconds sched)            take(10)map(new func1<long string>() {                @override                public string call(long u) {                    return v + """" refresh """" + u                }            })        }    }    )    timeinterval()    toblocking()    subscribe(new action1<timeinterval<string>>() {        @override        public void call(timeinterval<string> v) {            systemoutprintln(v)        }    })}```what i get is that for the first 5 seconds i get `1 refresh x` and `2 refresh x` in 500 ms intervals but after thet all the `3 refresh x` and `4 refresh x` gets printed instantly```timeinterval [intervalinmilliseconds515 value2 refresh 0]timeinterval [intervalinmilliseconds0 value1 refresh 0]timeinterval [intervalinmilliseconds500 value1 refresh 1]timeinterval [intervalinmilliseconds0 value2 refresh 1]timeinterval [intervalinmilliseconds500 value2 refresh 2]timeinterval [intervalinmilliseconds0 value1 refresh 2]timeinterval [intervalinmilliseconds500 value2 refresh 3]timeinterval [intervalinmilliseconds0 value1 refresh 3]timeinterval [intervalinmilliseconds485 value2 refresh 4]timeinterval [intervalinmilliseconds0 value1 refresh 4]timeinterval [intervalinmilliseconds516 value2 refresh 5]timeinterval [intervalinmilliseconds0 value1 refresh 5]timeinterval [intervalinmilliseconds486 value1 refresh 6]timeinterval [intervalinmilliseconds0 value2 refresh 6]timeinterval [intervalinmilliseconds500 value1 refresh 7]timeinterval [intervalinmilliseconds0 value2 refresh 7]timeinterval [intervalinmilliseconds499 value2 refresh 8]timeinterval [intervalinmilliseconds0 value1 refresh 8]timeinterval [intervalinmilliseconds500 value2 refresh 9]timeinterval [intervalinmilliseconds0 value1 refresh 9]timeinterval [intervalinmilliseconds516 value3 refresh 0]timeinterval [intervalinmilliseconds0 value4 refresh 0]timeinterval [intervalinmilliseconds0 value3 refresh 1]timeinterval [intervalinmilliseconds0 value4 refresh 1]timeinterval [intervalinmilliseconds0 value4 refresh 2]timeinterval [intervalinmilliseconds0 value4 refresh 3]timeinterval [intervalinmilliseconds0 value4 refresh 4]timeinterval [intervalinmilliseconds0 value4 refresh 5]timeinterval [intervalinmilliseconds0 value4 refresh 6]timeinterval [intervalinmilliseconds0 value4 refresh 7]timeinterval [intervalinmilliseconds0 value4 refresh 8]timeinterval [intervalinmilliseconds0 value3 refresh 2]timeinterval [intervalinmilliseconds0 value4 refresh 9]timeinterval [intervalinmilliseconds0 value3 refresh 3]timeinterval [intervalinmilliseconds0 value3 refresh 4]timeinterval [intervalinmilliseconds0 value3 refresh 5]timeinterval [intervalinmilliseconds0 value3 refresh 6]timeinterval [intervalinmilliseconds0 value3 refresh 7]timeinterval [intervalinmilliseconds0 value3 refresh 8]timeinterval [intervalinmilliseconds0 value3 refresh 9]```if i understand the purpose of this scheduler especially with the `merge(workers 2)` case you want to limit the number of concurrently running tasks however the implementation blocks out further workers from executing anything until a previous worker is released for example given a service that accepts 2 connections per client if i have to periodically execute 3 or more tasks against this service (via the `interval()` above) only the first two would execute periodically in addition the other 2 would slowly pile up tasks in the internal queue and if the associated sequence uses timeout this will make it timeouti think the solution is to use a  thread pool instead: it limits the number of concurrent tasks while allowing all workers to make progressmy second reservation is that since the `schedulewhen` is a self-contained class (unlike operators that need a method in `observable`) this can live in any external library (just like `androidschedulers`) || this isnt intended for long running observables your example is a pathological case rather than scheduling on the outer timer if flatmap and schedule on the inner observables it would not block and all three would be able to runthere are many was to misuse this but if used in a controlled setting of a service library it can be use to protect service from bursts of traffic the main point is to be able to reuse an existing scheduler with some additional behavior rather than having to create new thread pools to enforce rate limits || to address your concern ive changed the api from `ob<comp> -> comp` to `ob<ob<comp>> -> comp` this is a more direct mapping of scheduler of workers of actions that give the user complete control how and when the actions  in the example above the actions from all workers can be merged into one stream of actions and then the merge max (n) concurrent could be applied to the actions to better simulate running on a n threads ||   @akarnokd i think ive addressed all the concerns regrading this pr what can i do help get this experiment merged? || oh sorry was busy with something elseokay lets continue with the experiment :+1:/cc @zsxwing @artem-zinnatullin  || does   mean the pr is merged now? should we wait for a review from @zsxwing and/or @artem-zinnatullin? || lets wait for at least one of them ||   for this experiment api just one comment about `synchronized (actionqueue)` || very interesting api @abersnaze! few comments and im  with it || i dont know how i would draw the marble diagram for this one || @abersnaze if all feedback is resolved feel free to merge this pr and if you want post any short description of this addition beyond the ref to this pr || thanks for the feed back || as far as im concerned the feedback cycle hadnt really finished on this im hoping that api changes etc are not out of scope if i raise an issue || my comment about the use of `subscribe()` in the constructor was not addressed should be `unsafesubscribe()` i think || @davidmoten if you have further concerns dont hesitate to open an issue or post a pr the file needs some javadoc tidying up anyway || "";throttling observables;we have a problem where multiple code paths are making different calls to a backend service but we want to throttle the number of concurrent requests that each client is making the problem is that different requests could be different types or without knowledge of the other happening something like this:``` javaservicegeta()    subscribe(processresponsea())```i was thinking that it would be cool to have a throttlingscheduler and/or a maxconcurrentscheduler that could limit the number of observables that are active without having to interfere with the data of any of them and without having to make a new thread pool``` javastatic scheduler servicelimiter  schedulersmaxconcurrent(2 schedulerscomputation())servicegeta()    subscribeon(servicelimiter)    subscribe(processresponsea())```;so the completion of the subscribe action upstream of the call to `subscribeon(servicelimiter)` would release back to the pool? || i was thinking `rxschedulerworkerunsubscribe()` would be when the next observable in the queue would be subscribed too || with the existing api you can submit observables to a publishsubject+flatmap with maxconcurrency of 2:``` java    observable<t1> t1  observablefromcallable(() -> 1)observeon(schedulerscomputation())    observable<t1> t2      subject<observable observable> ps  publishsubjectcreate()toserialized() // raw observable    psflatmap(v -> vignoreelements() 2)subscribe(() -> { } e -> log(e))    psonnext(t1)    psonnext(t2)``` || i was thinking of using mergemaxconcurrent inside the scheduler implementation i would map createworker() to observablecreate and onnext to a subject then map workerunsubscribe() to oncomplete() while this strange worker + observable thing is subscribed to it schedules its actions on the underlying actual scheduler im not sure if schedule() would be mapped on onnext or if any uncaught exceptions would be mapped to onerror it might be interesting to think abouthaving the user do all the subject stuff would mean significant constraint of all code paths to only make at most one call the service the result of each service call observable would need to be returned and sent through a publish subject for throttling for example how would could this code be rewritten to only run 2 at a time across the whole of the vm```void foo() {   return zip(servicegeta() servicegetb() servicegetc() (abc) -> {})}```with the max concurrent as a scheduler the service code and apply the subscribeon to protect itself without the client being any the wiser of the throttling || i made two versions of the idea im kind of partial to the fine grained version because i think coarse grain throttling will result in deadlocks for example in the zip in my last comment if `geta()` and `getb()` could end up blocking `getc()` from being subscribed to until `geta()` completes and deadlocking the cost is the fine grain throttling creates an observable for each scheduled actionfine grained throttling: grained throttling: || closing via #4154 and 117 ||;1;0;ability to create custom schedulers with behavior based on composing operators made it private and added a instance method to scheduler rewrote the test to get a little more coverage wrapping each of the onnext/oncompleted to ensure no overlapping calls break up the worker as completable into worker as observable now the schedules actions are the indivisible elements that are subscribed to the user has additional choice at the cost of making the api more complicated;"
4157;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: enable fusion-consumers;this pr enables fusion-consumers such as  observeon    flatmap    zip    concatmap   makes  unicastprocessor  async-fuseable (used by  window )  fixes a few hidden issues with operators and has convenience renames of  subscriptionhelper.validatex . in addition  it features the new  flowableflatteniterable  used by  flatmapiterable  and  concatmapiterable .;;0;2x: enable fusion-consumers;this pr enables fusion-consumers such as `observeon` `flatmap` `zip` `concatmap` makes `unicastprocessor` async-fuseable (used  window`) fixes a few hidden issues with operators and has convenience renames of `subscriptionhelpervalidatex` in addition it features the new `flowableflatteniterable` used  flatmapiterable` and `concatmapiterable`;  wow this was dense! i tried my best to parse a lot of the queue/drain changes but i definitely didnt get a full mental model going of each one since there were so many i started pattern matching and just checking for more simple issues i have confidence in the present and future tests for these as well which helps thanks @jakewharton it is really simple concept: instead of creating a queue operators reuse the queue-view of their upstream which could be queue views themselves the drain algorithms hardly change except when `request()` has to be suppressed the difficulty is the need to know **all** operator internals over the entire library || > the difficulty is the need to know all operator internals over the entire libraryi havent had a chance to go through your changes in any detail just have a question what will this mean for `lift` `extend` and general extensibility use cases? || @stealthcode `lift` `to` and `compose` are still usable there is no `extend` in 2x because the 1x is just simply too restrictive on its function-input `to(function<flowable x>)` gives access to all operators and you can have your favorite leave-transform function with it:``` javafunction<flowable<integer> integer> conv  f -> fmap(a -> a + 1)toblocking()last()systemoutprintln(sourceto(conv))```implementing operators is now generally harder because the lifecycle of reactive-streams is different operator-fusion adds an extra requirement that you should not forward an upstream `subscription`:``` java    @override    public void onsubscribe(subscription s) {         childonsubscribe(s) // <- not allowed may break the operator or fusion around it    }``` || it looks like `to` offers at least all of the functionality of `extend` clearly as there is no `onsubscribe` the same api isnt possible > you should not forward an upstream `subscription`in 2x the disposable model forced changes in this area but not such that subscriptions couldnt be forwarded down the chain afaik this was a common optimization pattern in 1x for some operators @abersnaze and i talked and i think my understanding is that a fuseable operator will pass along a subscription but a non-fusable operator will create its own is that correct? || > in 2x the disposable model forced changes in this area but not such that subscriptions couldnt be forwarded down the chain that was true before operator-fusion came into picture> afaik this was a common optimization pattern in 1x for some operatorsthe architecture change induced by reactive-streams and operator-fusion added a lot of optimizations surpassing those in 1x> @abersnaze and i talked and i think my understanding is that a fuseable operator will pass along a subscription but a non-fusable operator will create its own is that correct?no every intermediate `subscriber` implements `subscription` should pass itself along at least if the operator doesnt want to support fusion thats the minimum``` java    @override    public void onsubscribe(subscription s) {         if (subscriptionhelpervalidate(thiss s)) {             thiss  s             childonsubscribe(this)         }    }    @override    public void request(long n) {         srequest(n)    }    @override    public void cancel() {         scancel()    }```otherwise if an operator would pass the `subscription` along it could cut itself out from the dataflow as the `queuesubscriptionpoll` skips over it || @artem-zinnatullin i guess you want to review this as well? || @akarnokd yup looking || ok  in general pattern looks understandable but amount of code and states in it make it hard to understand// dont want to complain but will be easier to review smaller prs :) (i know that at least i create backpressure for your prs so i understand why youre doing such huge amounts of work in one pr sorry for that) || thanks @artem-zinnatullin  most of the time i start small but then a change activates cascading effects: fixing a base structure exposes a bug in another operator that has to be updated ||;;;;1;1;code cleanup;
4160;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: enable op-fusion on groupby  doonx  fix mistakes in map and filter;this short pr enables operator fusion on  groupby  and on the  doonnext    doonerror    dooncomplete  and  dooneach  operators.  in addition  it fixes small mistakes in  map  and  filter  and adds a method to  testsubscriber  to print better fusion-assertion failure message.;;0;2x: enable op-fusion on groupby doonx fix mistakes in map and filter;this short pr enables operator fusion on `groupby` and on the `doonnext` `doonerror` `dooncomplete` and `dooneach` operatorsin addition it fixes small mistakes in `map` and `filter` and adds a method to `testsubscriber` to print better fusion-assertion failure message;   thanks @artem-zinnatullin! @jakewharton or anybody else wants to review this? || ;;;;1;1;2x: enable op-fusion on groupby doonx fix mistakes in map and filter;
4165;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix wrong reference check in flatteniterable;this was due to bad rewrite of field updater to atomic reference.;;0;2x: fix wrong reference check in flatteniterable;this was due to bad rewrite of field updater to atomic reference;;;;;1;1;2x: fix wrong reference check in flatteniterable;
4166;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: measure overhead of toblocking() first and last;this updates the perf classes a bit and adds a blocking benchmark.  (https://cloud.ent.com/assets/1269832/16580974/5ff08e54-42a7-11e6-889e-cfbb5c0bdecb.png);;0;2x: measure overhead of toblocking() first and last;this updates the perf classes a bit and adds a blocking benchmark(https://cloudentcom/assets/1269832/16580974/5ff08e54-42a7-11e6-889e-cfbb5c0bdecbpng); ;;;;1;1;2x: measure overhead of toblocking() first and last;
4167;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: reduce overhead of blocking first/last/single;optimize the reception  less allocation  less overhead in general.  benchmark comparison (i7 4790  windows 7 x64  java 8u92)  (https://cloud.ent.com/assets/1269832/16583761/065268fc-42b8-11e6-86a1-4ac91da80c97.png);;0;2x: reduce overhead of blocking first/last/single;optimize the reception less allocation less overhead in generalbenchmark comparison (i7 4790 windows 7 x64 java 8u92)(https://cloudentcom/assets/1269832/16583761/065268fc-42b8-11e6-86a1-4ac91da80c97png);  lgtm ;;;;1;1;2x: reduce overhead of blocking first/last/single;
"4172;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: add missing backpressure descriptions and update old ones;this pr adds or updates places where the  backpressure:  description was missing or outdated.  unfortunately  github has a hard limit on diff size per file so reviewers have to use their own local diff.;;0;1x: add missing backpressure descriptions and update old ones;this pr adds or updates places where the `backpressure:` description was missing or outdatedunfortunately github has a hard limit on diff size per file so reviewers have to use their own local diff;""""""it &ltt&gtmay&lt/i&gt lead to illegalstateexception being throw""""> """"it **&ltem&gt**may**&lt/em&gt** lead to illegalstateexception being **thrown**""""but better yet would be to avoid the passive voice and indicate what entity throws the exception eg """"if any of the source observables violate this xxx may throw an illegalstateexception when the source observable completes"""" || """"no backpressue applied to them"""" > """"no **backpressure** applied to them"""" || """"the other observables supplied by the function is consumed"""" > """"the other observables supplied by the function **are** consumed"""" || i notice that some of the `<dd>`s arent being closed with `</dd>` also || typo: """"apply any of the `onbackpressurexxx` opertors &ltb&gtbefore&lt/b&gt applying `observeon` itself"""" > """"apply any of the `onbackpressurexxx` **operators** **&ltstrong&gt**before**&lt/strong&gt** applying `observeon` itself"""" || for operators that both accept and return an observable (most of them) i find the phrase """"this observable"""" in the documentation to be ambiguous: does it mean the observable about to be operated on or the observable that results from the operation?  id recommend replacing it with """"the source observable"""" or """"the resulting observable"""" or something like that depending on which one youre talking about || typo: """"the outputs backpressure behavior is derermined by"""" > """"the outputs backpressure behavior is **determined** by"""" || ```+     *  <dt><b>backpressure:</b></dt>+     *  <dd>the operator honors backpressure from downstream and consumes this {@code observable} in an+     *  unbounded manner (ie no backpressure is applied to it)</dd>+     *  behavior</dd>```that last line seems to be extraneous || some of those typos appear in multiple places in the fileits great to see these sections getting filled out and made more precise! || thanks for the review ive updated the text ||  **  this so work touching `observablejava` can commence anybody let me know if you find something else (or better yet post a pr) || thank you for this @akarnokd! || beaut! || "";;;;1;1;update based on suggestions;"
4176;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: optimize collect  reduce and takelast(1);this pr reduces the overhead with  collect    reduce  and  takelast  and introduces the  deferredscalarsubscriber  to support similar unbounded-in single-out scenarios.  benchmark comparison (i7 4770k  windows 7 x64  java 8u92)  (  relative to each other: (each practically returning the very last value)  ![image](https://cloud.ent.com/assets/1269832/16669793/a35183fa-4497-11e6-9a93-36f7effe7e3b.png);;0;1x: optimize collect reduce and takelast(1);this pr reduces the overhead with `collect` `reduce` and `takelast` and introduces the `deferredscalarsubscriber` to support similar unbounded-in single-out scenariosbenchmark comparison (i7 4770k windows 7 x64 java 8u92)( to each other: (each practically returning the very last value)![image](https://cloudentcom/assets/1269832/16669793/a35183fa-4497-11e6-9a93-36f7effe7e3bpng);updated header year @jakewharton  || lgtm    /cc @artem-zinnatullin was it you that wanted more [unit test coverage]( for the deferred-scalar algorithm? ||;;;;1;1;update header year;
4178;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: improve coverage of rx.observable methods;this pr improves the coverage of  rx.observable  methods plus  - fixes a javadoc issue  - fixes an enum-coverage anomaly in notification (now it is simply biased towards onnext signals) - removes  equals()  from  testexception  as it caused anomalies with deduplication inside  compositeexception  - fixes 3 pmd rule violations (2 suppressed  1 corrected) -  timestamp  and  timeinterval  now use the  schedulers.computation()  as the source for the current time instead of  schedulers.immediate()  which can t be properly hooked. by default  they both return  system.currenttimemillis() .;;0;1x: improve coverage of rxobservable methods;this pr improves the coverage of `rxobservable` methods plus - fixes a javadoc issue - fixes an enum-coverage anomaly in notification (now it is simply biased towards onnext signals)- removes `equals()` from `testexception` as it caused anomalies with deduplication inside `compositeexception`- fixes 3 pmd rule violations (2 suppressed 1 corrected)- `timestamp` and `timeinterval` now use the `schedulerscomputation()` as the source for the current time instead of `schedulersimmediate()` which cant be properly hooked by default they both return `systemcurrenttimemillis()`; **  this as it may contain the cure for the memory-kill on travis let me know if there are tests that need more tidying up ||;;;;1;1;update based on feedback;
4182;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: add missing rxjavahooks options  fix bugs;these pr adds the remaining hooks which weren t even tested with the original rxjavaplugins plus a full coverage of the rxjavahooks itself.  this is a mandatory addition and 1.1.7 can t be released without it (i.e.  with an incomplete rxjavahooks that is).;;0;1x: add missing rxjavahooks options fix bugs;these pr adds the remaining hooks which werent even tested with the original rxjavaplugins plus a full coverage of the rxjavahooks itselfthis is a mandatory addition and 117 cant be released without it (ie with an incomplete rxjavahooks that is);lgtm  thanks @jakewharton  travis ci doesnt execute the build for like 30 minutes now ||;;;;1;1;1x: add missing rxjavahooks options fix bugs;
4188;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: add missing headers  add suppresswarnings;i still forget about these sometimes.;;0;1x: add missing headers add suppresswarnings;i still forget about these sometimes; ;;;;1;1;1x: add missing headers add suppresswarnings;
"4190;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: implement concat(map)eager(delayerror) and expose concat(map)delayerror overload;started a syncing process between 1.x and 2.x operators (based on [this diff]( the first set is the addition of the eager version of  concat  and  concatmap . in addition  all of them get a  xdelayerror  overloads as well.;;0;2x: implement concat(map)eager(delayerror) and expose concat(map)delayerror overload;started a syncing process between 1x and 2x operators (based on [this diff]( the first set is the addition of the eager version of `concat` and `concatmap` in addition all of them get a `xdelayerror` overloads as well;""  also ive expanded flowable with a `test()` method should give a nice answer to the question """"how do you test a flowable?"""" || updated the `if`s || im thinking if there is a way to test such [`if (!cancelled)`]( errors java debuggers allows suspending a thread on a particular breakpoint and allow other threads to run at the same time maybe such mechanism will allow us to simulate and test concurrent access in particular parts of code (drain loops and so on) something like:``` java@testpublic void concurrentcancel() {  testthread thread1  testthread({     disposable  flowablejust(1)concatmap(v -> flowablejust(2))subscribe()  })  testthread thread2  testthread({    disposabledispose()  })  testthreadsbuilder()    start(thread1) // one or multiple    thensuspend(thread1 flowableconcatmapeagerclass 128) // thread source class line    thenstart(thread2)    thenresume(thread1)    run() // run and wait all test threads to complete  // assert behavior}```just thoughts || :+1: for pr || thanks @artem-zinnatullin ! || "";;;;1;1;wrong expression;"
4192;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: +fromasync  distinctuc  skip  take overloads  fix testsubscriber api;this pr adds a few operators and overloads from 1.x -  fromasync  -  just  - 10 arguments -  distinctuntilchanged(bipredicate<? super t  ? super t> comparer)  -  skip  timed - default scheduler -  take  timed - default scheduler -  tocompletable   in addition  this pr fixes the api of testsubscriber by making the initial value primitive  long  and having 0 as no initial request instead of the trickery with  null .;;0;2x: +fromasync distinctuc skip take overloads fix testsubscriber api;this pr adds a few operators and overloads from 1x- `fromasync`- `just` - 10 arguments- `distinctuntilchanged(bipredicate<? super t ? super t> comparer)`- `skip` timed - default scheduler- `take` timed - default scheduler- `tocompletable`in addition this pr fixes the api of testsubscriber by making the initial value primitive `long` and having 0 as no initial request instead of the trickery with `null`;  /cc @artem-zinnatullin @jakewharton if this could me merged soon i could start on syncing the unit tests in which there are [roughly 1500]( methods to check - some of them are simple relocations once done i have to sync the flowable-observable tests (which have a more symmetric layout luckily) || will look in several hourson tue 12 jul 2016 15:22 david karnok notifications@githubcom wrote:> /cc @artem-zinnatullin  @jakewharton>  > if this could me merged soon i could start on syncing the unit tests in> which there are roughly 1500>  methods to check - some of them are simple relocations once done i have> to sync the flowable-observable tests (which have a more symmetric layout> luckily)> > > you are receiving this because you were mentioned> > reply to this email directly view it on github>  or mute the thread>   || @artem-zinnatullin fixing what you discovered so far notify me when you `bipredicate` conforms with (and thus conflicts with) java 8 functional interface naming conventions calling it `pred2` is possible but then `func1funcn` would conflict with rxjava 1 if in the same project || done  but comments> bipredicate conforms with (and thus conflicts with) java 8 functional interface naming conventions calling it pred2 is possible but then func1funcn would conflict with rxjava 1 if in the same projectthey wont conflict because package names are different though youll have to use fqn if youll need both in same source file || > they wont conflict because package names are differentsure but when you type in `function` then ctrl+space in ide you get the java version and rxjava 2 version sometimes you copy-paste a `function f  ` and get a squiggly line saying `function` is not compatible with `function` || thanks @artem-zinnatullin ! ||;;;;1;1;address review comments;
4195;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: sync unit tests of completable  add missing features;don t worry about not all things tested in this pr  anything extra relative to 1.x will be covered after the sync.;;0;2x: sync unit tests of completable add missing features;dont worry about not all things tested in this pr anything extra relative to 1x will be covered after the sync; ;;;;1;1;fix small documentation errors;
4204;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: test sync + cleanup;- more unit tests ported  -  testobserver  cleanup and sync with  testsubscriber   - fix travis to run with java 7 instead of 8  - added animalsniffer  - cleaned up  combinelatest   introduced  combinelatestdelayerror   - test names are as in 1.x  please don t complain about the  test  prefix in the method names!;;0;2x: test sync + cleanup;- more unit tests ported- `testobserver` cleanup and sync with `testsubscriber`- fix travis to run with java 7 instead of 8- added animalsniffer- cleaned up `combinelatest` introduced `combinelatestdelayerror`- test names are as in 1x please dont complain about the `test` prefix in the method names!; **  this so we can progress with other tasks that would affect the same files ill address the review feedback in a separate pr if necessary ||;;;;1;1;fix a scheduler leak in abstractschedulertests;
4211;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: use generic type instead of object in combinelatest and zip;as discussed in   this pr gives a stricter type signature for  combinelatest    zip    ziparray  and  zipiterable . it replaces occurrences of  object  with its generic type  t . in practice users will not need to type-cast arrays in the combine function anymore.;;0;2x: use generic type instead of object in combinelatest and zip;as discussed in  pr gives a stricter type signature for `combinelatest` `zip` `ziparray` and `zipiterable` it replaces occurrences of `object` with its generic type `t` in practice users will not need to type-cast arrays in the combine function anymore;     thanks for the contribution ||;;;;1;1;2x: use generic type instead of object in combinelatest and zip;
4217;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: test sync  +groupjoin  +join  +onterminatedetach;- add  groupjoin    join    onterminatedetach  - fix missing cancellation in  flowableflatteniterable  - fix  fromiterable  error handling - added several unit test methods and classes from 1.x;;0;2x: test sync +groupjoin +join +onterminatedetach;- add `groupjoin` `join` `onterminatedetach`- fix missing cancellation in `flowableflatteniterable`- fix `fromiterable` error handling- added several unit test methods and classes from 1x;   thanks @stevegury and @artem-zinnatullin  ||;;;;1;1;finish up the observable variants;
4222;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: subscribeon allow cancelling before the actual subscription happens (just like 1.x);this pr fixes the  subscribeon  operator to allow cancellation before the actual subscription to the source takes place - just like how 1.x works.;;0;2x: subscribeon allow cancelling before the actual subscription happens (just like 1x);this pr fixes the `subscribeon` operator to allow cancellation before the actual subscription to the source takes place - just like how 1x works;  ;;;;1;1;2x: subscribeon allow cancelling before the actual subscription happens(just like 1x);
"4225;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: publishsubject fail-fast when backpressured;this pr modifies the  publishsubject  to fail fast if the child subscriber can t keep up. therefore  instead of some other operator failing somewhere downstream  the  missingbackpressureexception  now points to the  publishsubject  instead.   in addition  there were complaints in #3850 that cross-unsubscription doesn t stop another subscriber from receiving events if it comes after the unsubscribe() call in the dispatch loop. since  publishsubject  now tracks request - which is the main extra overhead - it is trivial to add the necessary eager check for the unsubscribed state.  benchmark comparison (i7 4790  windows 7 x64  java 8u102)  (  as expected  this adds some overhead although most noticeably for the mid-range only. short-lived publishing is now slightly faster even.  interestingly  many benchmarks behave oddly in these 1000s range - we could be hitting some jit threshold. while in other benchmarks  the warmup iteration numbers keep increasing as jit does its work but here  it starts out quite nicely then drops 25% and stays that way. i m on windows so jmh -perfasm doesn t work.  if this direction is accepted  i ll update  behaviorsubject    timer()  and  interval()  do do the same tracking.;;3850.0;1x: publishsubject fail-fast when backpressured;this pr modifies the `publishsubject` to fail fast if the child subscriber cant keep up therefore instead of some other operator failing somewhere downstream the `missingbackpressureexception` now points to the `publishsubject` instead in addition there were complaints in #3850 that cross-unsubscription doesnt stop another subscriber from receiving events if it comes after the unsubscribe() call in the dispatch loop since `publishsubject` now tracks request - which is the main extra overhead - it is trivial to add the necessary eager check for the unsubscribed statebenchmark comparison (i7 4790 windows 7 x64 java 8u102)( expected this adds some overhead although most noticeably for the mid-range only short-lived publishing is now slightly faster eveninterestingly many benchmarks behave oddly in these 1000s range - we could be hitting some jit threshold while in other benchmarks the warmup iteration numbers keep increasing as jit does its work but here it starts out quite nicely then drops 25% and stays that way im on windows so jmh -perfasm doesnt workif this direction is accepted ill update `behaviorsubject` `timer()` and `interval()` do do the same tracking;""  4225  **<  "";unsubscribed observer receives event;""this code:``` javaimport rxobservableimport rxsubscriptionimport rxsubjectspublishsubjectfinal class unsubscribing {   private static subscription mfirst   private static subscription msecond   public static void main(final string args) {      final publishsubject<integer> publisher  publishsubjectcreate()      mfirst  publishersubscribe(i -> {            msecondunsubscribe()            log(""""first: """" + i)         } )      msecond  publishersubscribe(i -> {            log(""""second: """" + i)         } )      publisheronnext(1)      publisheronnext(2)   }   private static void log(final string msg) {      systemoutprintln(msg)   }}```unsubscribes second subscription in the first callback at the time second callback called it is not subscribed (unsubscribe call completed for it) its expected that second callback will not be called but it isoutput of that program is```first: 1second: 1first: 2```"";""this is due to the best-effort way of unsubscribing: publishsubject to remain low overhead as possible doesnt check `isunsubscribed` before calling `onnext` on a child and the dispatch loop works on a snapshot of the available subscribers therefore if the first unsubscribes the second that is not becoming visible to `publishsubjectonnext` but only the next time || im closing this issue due to inactivity if you have further input on the issue dont hesitate to reopen this issue or post a new one || @akarnokd isnt from point of view of observer pattern which is rx based on this situation is incorrect? i mean """"subscribed"""" and """"unsubscribed"""" states from abstractions point of view differs only by fact if observer continues to receive events """"subscribed""""  """"receives events"""" """"unsubscribed""""  """"not receives events"""" is this something to be  or user code needs additional checks to ensure that unsubscribed subscriber will not get events? || yes you should check `msecondisunsubscribed()` in this case || @akarnokd as a consequence this makes """"unsubscribe"""" method non trustworthyevery time this method is used we need additinally check if subscriber was unsubscrubed when receiving eventsimagine next code:``` javapublic final class somemechanics {    private final subscription meventsubscription    public somemechanics(final observable<event> eventstream) {        meventsubscription  eventstreamsubscribe(/*  */)    }     public void stop() {        meventsubscriptionunsubscribe()    } } ```this code must check if meventsubscription is unsubscribed because it cant guarantee the conditions """"stop"""" called from``` javapublic final class somemechanics {    private final subscription meventsubscription    public somemechanics(final observable<event> eventstream) {        meventsubscription              eventstreamsubscribe(onnext -> {                    if (meventsubscriptionisunsubscribed()) return                    // do stuff                } )    }     public void stop() {        meventsubscriptionunsubscribe()    } }```moreover that behavior is in contradictory in the description of """"unsubscribe"""" method from documentation:  || see #4225 for an update to `publishsubject` which includes a fix for this case || @akarnokd  "";1;0;inline get() use smaller error array at first;"
4226;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: single.flatmapcompletable;addresses #4216   happy to receive feedback on the implementation. also should i take the documentation from  flatmapobservable  and adjust it?;;4216.0;1x: singleflatmapcompletable;addresses #4216 happy to receive feedback on the implementation also should i take the documentation from `flatmapobservable` and adjust it?;  4226 also should i take the documentation from flatmapobservable and adjust it?yes || updated the documentation i hope the wording is okay now also im pointing to  which does not exist yet but  @davidmgross already tracked it at  i hope thats okaythanks for the `completableflatmapsingletocompletable` i knew something was missing i also created two more tests that cover some of the previously missing behaviour ||  would it be possible to get this one into 118? || if @zsxwing or anyone from netflix approves it in time || ;1x: feature request single#flatmapcompletable;would be nice to flatmap from single to completable unless there is any other way to do this right now `flatmapobservable` already does existhappy to hear thoughts on that from you guys;pr welcome || im curious how would you start implementing this? || subscribe to the `single` and in the `onsuccess` call the mapper and subscribe to the returned `completable` || closing via #4226 ||;1;0;change test for artem;
4234;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: fix some typos;;;0;1x: fix some typos;;  4234   ;;;;1;1;1x: fix some typos;
4238;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: fix typo eigth to eighth;found another one;;0;1x: fix typo eigth to eighth;found another one;  4238   ;;;;1;1;1x: fix typo eigth to eighth;
"4251;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;tomap - prevent multiple terminal events  support backpressure;as per discussion in #4242  if an operator maps an  onnext  emission to an  onerror  emission downstream then it needs be defensive about an  oncompleted  being sent from upstream even if upstream has been unsubscribed.  includes three unit tests that failed on the original code. the fix also has the side effect of enabling gc of  map  when the factory fails ( onerror  was called on the child  not  this  so  map  was not set to null).;;4242.0;tomap - prevent multiple terminal events support backpressure;as per discussion in #4242 if an operator maps an `onnext` emission to an `onerror` emission downstream then it needs be defensive about an `oncompleted` being sent from upstream even if upstream has been unsubscribedincludes three unit tests that failed on the original code the fix also has the side effect of enabling gc of `map` when the factory fails (`onerror` was called on the child not `this` so `map` was not set to null);i thought it supported backpressure could you rewrite it by using `deferredscalarsubscription`? || unrelated test failure:```rxschedulerscomputationschedulertests > testhandlederrorisnotdeliveredtothreadhandler failed    javalangassertionerror: handler should not have received anything expected:<0> but was:<1>        at orgjunitassertfail(assertjava:88)        at orgjunitassertfailnotequals(assertjava:834)        at orgjunitassertassertequals(assertjava:645)        at rxschedulersschedulerteststesthandlederrorisnotdeliveredtothreadhandler(schedulertestsjava:102)        at rxschedulerscomputationschedulerteststesthandlederrorisnotdeliveredtothreadhandler(computationschedulertestsjava:153)``` || > i thought it supported backpressure could you rewrite it by using deferredscalarsubscription?sure || what i might do is fix multiple terminal emissions in  `onsubscribecollect` first and make necessary `done` changes to `deferredscalarsubscriber` in that pr ill follow that with the backpressure fix for `operatortomap` || @akarnokd in terms of releasing a value so can be gcd i thought to modify `deferredscalarsubscriber` in this method so that the field `thisvalue` is set to null just before the call to `aonnext()`:``` javaprotected final void complete(r value) {        subscriber<? super r> a  actual        for () {            int s  stateget()            if (s  no_request_has_value || s  has_request_has_value || aisunsubscribed()) {                return            }            if (s  has_request_no_value) {                r v  value // <--------------------------------                value  null // <--------------------------------                aonnext(v)                if (!aisunsubscribed()) {                    aoncompleted()                }                statelazyset(has_request_has_value)                return            }            thisvalue  value            if (statecompareandset(no_request_no_value no_request_has_value)) {                return            }        }    }```is that ok? || dont review latest change just committed so could work on it from another location || im not sure if its worth it many operators dont really do that because it is also likely the whole chain gets forgotten and gc claims all of them on its own if you want to make sure there is no leak use `onterminatedetach` || could you rebase the whole thing? somehow you picked up changes to master and they show up in the diff ||   4251   - rebased- rewrote to use `deferredscalarsubscribersafe`- use singleton of `defaultmapfactory`- moved to `onsubscribe` to save allocations- added backpressure test  ||  good idea ive updated the pr || ;observablemap unsubscribe question;just looking at `onsubscribemap`  and i noticed a possibly undesirable `unsubscribe()` call in `mapsubscriber` (l72):``` java        @override        public void onnext(t t) {            r result            try {                result  mappercall(t)            } catch (throwable ex) {                exceptionsthrowiffatal(ex)                unsubscribe()                onerror(onerrorthrowableaddvalueaslastcause(ex t))                return            }            actualonnext(result)        }```if an exception occurs we eagerly unsubscribe from the source before emitting the error im not sure we have a policy on this yet but my first impression is that a length `unsubscribe` activity could delay the emission of the error and this might not be expected i wonder if we should delete this `unsubscribe()` call?;""another question about `onsubscribemap` is the defensive use of `done` is this necessary and can i remove it (and thus reduce allocation)? i know the boolean is only one bit but requires a byte and with padding can be up to 8 bytes``` java        @override        public void onerror(throwable e) {            if (done) {                rxjavahooksonerror(e)                return            }            done  true            actualonerror(e)        }        @override        public void oncompleted() {            if (done) {                return            }            actualoncompleted()        }``` || it has to tell the upstream to stop emitting most `unsubscribe` is simple enough that this doesnt take that longthe defensive `done` is required as some sources dont expect unsubscription before sending out the terminal event and would cause double termination in many casesdont change anything in map || > it has to tell the upstream to stop emitting most unsubscribe is simple enough that this doesnt take that long> > the defensive done is required as some sources dont expect unsubscription before sending out the terminal event and would cause double termination in many cases> > dont change anything in maprighto as a general rule then is it fair to say when an operator maps an `onnext` emission to a terminal event that we should follow this pattern (unsubscribe eagerly and use defensive `done` flag)? || yes i found a bunch of operators violating this rule before (around the same time map and filter were ) but there could be others || i thought id add this rule to the  page but i couldnt edit it i was thinking of adding  just above further readingwhen an operator maps an `onnext` emission to a terminal event then before calling the terminal event it should unsubscribe the subscriber to upstream (usually called the `parent`) in addition  because upstream may (legally) do something like this:``` javachildonnext(blah)//  no check for unsubscribed herechildoncompleted()```we should ensure that the operator complies with the observable contract and only emits one terminal event so we use a defensive `done` flag:``` javaboolean done  false@override public void onerror(throwable e) {    if (done) {        return   }   done  true   }@override public void oncompleted(throwable e) {    if (done) {        return   }   done  true   }```an example of this pattern is seen in `onsubscribemap`would you like to add this info the wiki page @akarnokd? || done || thanks ill have a look for operators not complying with this || you might consider instead adding this information to the page at your own operators"""")as most of the rxjava operator-oriented documentation has moved to thereactivexio siteon tue jul 26 2016 at 2:02 pm dave moten notifications@githubcomwrote:> closed #4242  > > you are receiving this because you are subscribed to this thread> reply to this email directly view it on github>  or mute> the thread>  ## david m grossplp consulting || good idea @davidmgross ill make a pr || "";1;0;tomap - prevent multiple terminal events and support backpressures;"
4254;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: fix singletest generics warnings;this fixes the generics warnings in the new  single.flatmapcompletable  unit tests.;;0;1x: fix singletest generics warnings;this fixes the generics warnings in the new `singleflatmapcompletable` unit tests; didnt see those since i have java 8 as default in my ide || im using eclipse which turned out to be an excellent tool to warn about these things are you using intellij? ive noticed that people using intellij end up with such hidden problems (while intellij for me complained about almost everything else when i loaded rxjava into it once) ||   4254   yes im using android studio which is based on intellij thats weird i had no problems loading the project into as ||;;;;1;1;1x: fix singletest generics warnings;
4261;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: concatdelayerror multiple arguments;this pr adds multiple arguments to concatdelayerror operator  related to: #4152;;4152.0;1x: concatdelayerror multiple arguments;this pr adds multiple arguments to concatdelayerror operatorrelated to: #4152;  4261    /cc @artem-zinnatullin @stevegury @zsxwing  ||;1x: concatdelayerror with multiple args;i think itd be great if `concatdelayerror` supports multiple parameters as `mergedelayerror`btw doesnt `mergedelayerror` miss a variation in which a variable number of args is admitted?;/cc @matir91 || the general problem with these that they expand the api surface (like + 8 methods per operator) which is already bloatedwe dont do variable arguments in java 6 because it necessitates `@suppresswarnings` almost always (hence the convenience 2-9 arg operators) || closing via #4261 ||;1;0;updates wording;
4262;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;dooneach - reduce allocations  report to rxjavahooks;as discussed in #4260  - call  rxjavahooks.onerror  for secondary errors - reduced allocations ( actionsubscriber  ->  actionobserver    operator  ->  onsubscribe ) - added 5 unit tests;;4260.0;dooneach - reduce allocations report to rxjavahooks;as discussed in #4260 - call `rxjavahooksonerror` for secondary errors- reduced allocations (`actionsubscriber` -> `actionobserver` `operator` -> `onsubscribe`)- added 5 unit tests;  4262    actionsubscriber usage and removed empty test ta || ;operatordoeach could do with some work;while looking for emissions after terminal events i was looking at `operatordoeach` which is called  doonnext` `doonerror` `dooncompleted` and `dooneach` of course i noticed these things:- lots of wasted allocations per call (use of `actionsubscriber` when all that is needed is an `actionobserver`) and passing three actions to `operatordoeach` when for three of the four operators we only need one action- it doesnt call `rxjavahookserror` for secondary error emissions from upstream- it does call `exceptionsthrowiffatal` for all error emissions (do we want to do this generally? i havent seen it much outside error catching on externally supplied functions or actions)id quite like to see `doonnext` and `doonerror` in particular more efficient because i use them a lot should i create dedicated operator/onsubscribe classes for the single action operators or perhaps one shared one that has an extra parameter (to indicate what notification type is being used)?;you may optimize it into an onsubscribe im not sure about splitting as it triples the method count for the sake of saving 16 bytes || i could also use `actionobserver` instead of `actionsubscriber` i suppose (saves 32 bytes) let me know what you think of the `throwiffatal` issue and ill do it || the `throwiffatal` shouldnt be there the operators should not call onerror with a fatal exceptions anymore but throw them immediately - this should be also reviewed and  in 2x as well || fyi i follow [this]( list when i port tests || closing via #4262 ||;1;0;dooneach - reduce allocations report to rxjavahooks use onsubscribe;
4266;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add dedicated concat for array of publishers;this pr adds a dedicated  concat  implementation that works with the source array. the main benefit is that there is no need to serialize emissions because the source array can t throw (unlike  concatmap  where there could be an onerror from the main source while an inner source is running). plus  there is a new  concatarraydelayerror  version.;;0;2x: add dedicated concat for array of publishers;this pr adds a dedicated `concat` implementation that works with the source array the main benefit is that there is no need to serialize emissions because the source array cant throw (unlike `concatmap` where there could be an onerror from the main source while an inner source is running) plus there is a new `concatarraydelayerror` version;  4266   lgtm ;;;;1;1;2x: add dedicated concat for array of publishers;
4268;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: test sync and operator fixes;- rename  finallydo  (deprecated in 1.x) to  doafterterminate  - upgrade sized  buffer()   fix backpressure bug - add post-complete helper methods - fix  tosingle  not complaining about an empty/longer source -  rxjavaplugins  to reset the base-type lifecycle callbacks as well;;0;2x: test sync and operator fixes;- rename `finallydo` (deprecated in 1x) to `doafterterminate`- upgrade sized `buffer()` fix backpressure bug- add post-complete helper methods- fix `tosingle` not complaining about an empty/longer source- `rxjavaplugins` to reset the base-type lifecycle callbacks as well;  4268   lgtm  thanks @jakewharton ! ||;;;;1;1;2x: test sync and bugfixes;
4270;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;tomultimap - prevent post terminal emissions  reduce allocations;- switched to  onsubscribe  - switched to use  deferredscalarsubscribersafe  - previous source failed to handle post terminal emissions  - added 4 unit tests;;0;tomultimap - prevent post terminal emissions reduce allocations;- switched to `onsubscribe`- switched to use `deferredscalarsubscribersafe`- previous source failed to handle post terminal emissions - added 4 unit tests;  4270   ;;;;1;1;tomultimap - prevent post-terminal-emissions;
4273;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: test sync and missing operators (8/02);- add  rebatchrequests  which delegates to  observeon  with the help of an internal  immediatethinscheduler  that only executes tasks immediately. still not planning to expose an immediate scheduler. - fix  flowablemapnotification  s type signature  no need to restrict it to return  publisher<r>  but can go with  r  itself. - make sure  flatmap  doesn t reorder scalars and elements of the same inner source. - change parameter ordering on  mergedelayerror(iterator)  overloads.;;0;2x: test sync and missing operators (8/02);- add `rebatchrequests` which delegates to `observeon` with the help of an internal `immediatethinscheduler` that only executes tasks immediately still not planning to expose an immediate scheduler- fix `flowablemapnotification`s type signature no need to restrict it to return `publisher<r>` but can go with `r` itself- make sure `flatmap` doesnt reorder scalars and elements of the same inner source- change parameter ordering on `mergedelayerror(iterator)` overloads;  4273  ;;;;1;1;2x: test sync and missing operators (8/02);
4278;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: functional interfaces now throw;it had a bit of a cascading effect.;;0;2x: functional interfaces now throw;it had a bit of a cascading effect;  4278   @akarnokd jfyi im reviewing this but it takes a lot of time will try to finish today || holy long pr batman!  yeah ive finished like 60% looks good yeton sat 6 aug 2016 02:23 jake wharton notifications@githubcom wrote:> holy long pr batman! > > > you are receiving this because you commented> > reply to this email directly view it on github>  or mute the thread>   || merged it so jake & i can progress on other things just shout out if you found something wrong || was it really a thought-out change?now we have to rewrite each lambda-call to new classes from ``ioreactivexfunctions`` with hacks like described in  a checked exceptions in functional interfaces is a well-known java antipattern why have you implemented such a drastic change that will prevent people from migrating to rxjava 2? || @dmitry-weirdo many have successfully migrated to rxjava 2 since we support java 6 which has barely any standard functional interfaces it doesnt really matter what we introduce especially if one uses lambda expressions the throws clause gives some convenience when interacting with exception throwing traditional methods ||;;;;1;1;fix mistakes;
4282;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: make observable takeuntil documentation more explicit;;;0;1x: make observable takeuntil documentation more explicit;;   4282  ;;;;1;1;1x: make observable takeuntil documentation more explicit;
4285;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: remove defunct  nbp  prefix from observable interfaces.;;;0;2x: remove defunct nbp prefix from observable interfaces;;all other nbp references are in tests which ill clean up next || also worth noting that these names are the same now as those in `flowable` but youre not only unlikely to use both in the same file the disambiguation of the two is trivial with an `observable` or `flowable` qualifier ||   4285    what about `nbpfullarbiter` & `nbpqueuedrain`? they are not in the test scope || yeah i saw those after commentingon sun aug 7 2016 at 5:29 pm niklas baudy notifications@githubcomwrote:> what about nbpfullarbiter & nbpqueuedrain? they are not in the test scope> > > you are receiving this because you authored the thread> reply to this email directly view it on github>  or mute the thread>   ||;;;;1;1;remove defunct nbp prefix from observable interfaces;
4287;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: elide observablewrapper for empty and never.;;;0;2x: elide observablewrapper for empty and never;;not sure whether the use of `create` is intentional or not internally as of right now its just a trampoline/indirection to `subscribeactual` so if extending `observable` is fine i can go through and eliminate all of these ||   4287   ;;;;1;1;elide observablewrapper for empty and never;
4288;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: move exceptions to public area  + exceptionhelper;related: #4280.  the  exceptions.propagate  and  exceptions.throwiffatal  are too useful to be hidden in an internal package so this pr moves them into the public  io.reactivex.exceptions  package. the terminal atomics related to throwable containers lives in the  exceptionhelper  enum.;;4280.0;2x: move exceptions to public area + exceptionhelper;related: #4280the `exceptionspropagate` and `exceptionsthrowiffatal` are too useful to be hidden in an internal package so this pr moves them into the public `ioreactivexexceptions` package the terminal atomics related to throwable containers lives in the `exceptionhelper` enum;  4288   lgtm ;2x: exceptions is in internal package;despite its tests being in the public api packageits hard to write libraries without `exceptionsthrowiffatal` should this be in the public api?;possibly what should happen with the rest of the methods?if youd review #4278 that would allow the refactoring to happen without interference || i would think theyd split although having two classes of the same name would obviously be less than ideal maybe it could be hoisted onto rxjavaplugins since its often used with calling `rxjavapluginsonerror`? there could even be a combination method that does both since theres a few hundred uses of the pair throughout rxjavas codebase as-is || this can be closed!   || oh wait its my issue i can do that! ||;1;0;2x: move exceptions to public area + exceptionhelper;
4289;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: elide more create/callback wrappers in favor of direct observables.;;;0;2x: elide more create/callback wrappers in favor of direct observables;;   4289   ;;;;1;1;elide more create/callback wrappers in favor of direct observables;
4291;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: promote anonymous observables to top-level types.;;;0;2x: promote anonymous observables to top-level types;;  4291   i think this is ready i have another one following it to normalize the implementations of never+empty for all types (they vary slightly currently) || this needs rebasing || ;;;;1;1;promote anonymous observables to top-level types;
4292;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: actually apply custom scheduler when applying future.;correct annotatoin declaration as well.;;0;2x: actually apply custom scheduler when applying future;correct annotatoin declaration as well;  #4292  into 2x  will> decrease coverage by _ ;;;;1;1;actually apply custom scheduler when applying futurecorrect annotatoin declaration as well;
4293;1;0;0;0;0;1;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: correct default subscriber name.;;;0;2x: correct default subscriber name;;  4293  ;;;;1;1;correct default subscriber name;
4294;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: inline generic-free runnable and long consumer method.;;;0;2x: inline generic-free runnable and long consumer method;;  4294  ;;;;1;1;inline generic-free runnable and long consumer method;
4296;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: observable.range fix exception message;;;0;2x: observablerange fix exception message;;  4296  ;;;;1;1;2x: observablerange fix exception message;
"4297;1;0;0;0;0;1;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: rename single base interface types for consistency;addresses #4044;;404.0;2x: rename single base interface types for consistency;addresses #4044;  4297   lgtm   @jakewharton if you want me to and you havent started yet id continue on that list and rename the other classes / interfaces as well || sure go for it!on sun aug 7 2016 at 1:55 pm niklas baudy notifications@githubcomwrote:> @jakewharton  if you want me too and you> havent started yet id continue on that list and rename the other classes> / interfaces as well> > > you are receiving this because you were mentioned> > reply to this email directly view it on github>  or mute the thread>   ||;add fromchangeevents methods to swingobservable;for swing components which fire `changeevent`s i added a method `swingobservablefromchangeevents` similar to the other methods of `swingobservable` unfortunately there is no common base interface for all components which fire `changeevents`s so i created one myself: `changeeventsourcechangeeventcomponentwrapper`then each component which fires `changeevents`s needs its own overload in `swingobservable`an other approach would be to use reflection but then we loose typesafety;""#309] before merging this we should also try a solution with reflection and then decide which one is better || @jmhofer can you comment on this as well since you were involved in the first submission of rxjava-swing? || looks good to me - will all these overloads work with dynamic languages though?i wouldnt want to switch to reflection for this even if its a bit ugly doing all this by hand || i think we should at least try a solution with reflection because this would also work with custom components which have `addchangelistener` and `removechangelistener` methods with reflection we lose typesafety but c# also uses reflection when i call something like``` csobservablefromeventpattern<eventargs>(mytextfieldcomponent """"textchanged"""")```see  || im always very sceptical when it comes to anything to do with reflection but i see your point if i understand you right you want to simulate a scala structural type here correct? this could very well be worth it || #318 for testing the negative maybe send a mock(observer) and then verify(obr times(1))onnext(sentevent) || this is a very long discussion  is this ready for final review and merge? || @abersnaze is this ready to merge? || ive added some more commits just to avoid duplicate work but imho this is not yet ready for merge || #340  is this waiting on peoples time or is there something fundamental still to decide upon? || last comment 20 days ago was that this is still not ready to merge so where is this going? || i think the current reflection-based approach is good but the unit tests need to be rewritten from scratch and it might also need some polishing i dont have time now but if no one does it until december i will do it then || closing  if any of you want to revive at some point please send another request || "";1;0;2x: rename single base interface types for consistency;"
4298;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: clarify behavior of rxjavaplugins.reset() in javadoc;noticed in rxandroid https://github.com/reactivex/rxandroid/pull/316#discussion_r73783555;;0;2x: clarify behavior of rxjavapluginsreset() in javadoc;noticed in rxandroid https://githubcom/reactivex/rxandroid/pull/316#discussion_r73783555;  4298  ;;;;1;1;2x: clarify behavior of rxjavapluginsreset() in javadoc;
"4299;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: rename flowable base interface types for consistency;addresses #4044;;404.0;2x: rename flowable base interface types for consistency;addresses #4044;lgtm    4299   ;add fromchangeevents methods to swingobservable;for swing components which fire `changeevent`s i added a method `swingobservablefromchangeevents` similar to the other methods of `swingobservable` unfortunately there is no common base interface for all components which fire `changeevents`s so i created one myself: `changeeventsourcechangeeventcomponentwrapper`then each component which fires `changeevents`s needs its own overload in `swingobservable`an other approach would be to use reflection but then we loose typesafety;""#309] before merging this we should also try a solution with reflection and then decide which one is better || @jmhofer can you comment on this as well since you were involved in the first submission of rxjava-swing? || looks good to me - will all these overloads work with dynamic languages though?i wouldnt want to switch to reflection for this even if its a bit ugly doing all this by hand || i think we should at least try a solution with reflection because this would also work with custom components which have `addchangelistener` and `removechangelistener` methods with reflection we lose typesafety but c# also uses reflection when i call something like``` csobservablefromeventpattern<eventargs>(mytextfieldcomponent """"textchanged"""")```see  || im always very sceptical when it comes to anything to do with reflection but i see your point if i understand you right you want to simulate a scala structural type here correct? this could very well be worth it || #318 for testing the negative maybe send a mock(observer) and then verify(obr times(1))onnext(sentevent) || this is a very long discussion  is this ready for final review and merge? || @abersnaze is this ready to merge? || ive added some more commits just to avoid duplicate work but imho this is not yet ready for merge || #340  is this waiting on peoples time or is there something fundamental still to decide upon? || last comment 20 days ago was that this is still not ready to merge so where is this going? || i think the current reflection-based approach is good but the unit tests need to be rewritten from scratch and it might also need some polishing i dont have time now but if no one does it until december i will do it then || closing  if any of you want to revive at some point please send another request || "";1;0;2x: rename flowable base interface types for consistency;"
"4300;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: rename observable base interface types for consistency;addresses #4044.;;4044.0;2x: rename observable base interface types for consistency;addresses #4044;there are a large amount of compilation errors || rebased against 2x and re-did the last changes || looks good this time    4300  **< ;2x: new base interface types;as part of the 2x design new base interface types have been recently merged & applied the aim is to match the style of the reactive-streams base types + their fluent base class:`flowable` -> `publisher` -> `subscriber``observable` -> `observableconsumable` -> `observer``single` -> `singleconsumable` -> `singlesubscriber``completable` -> `completableconsumable` -> `completablesubscriber`they feel odd to me too so any idea is welcome;""just to be clear before i start thinking about this more `publisher` and `subscriber` are the only rs types here right? and `single` and `completable` are always backpressure-aware types? || > publisher and subscriber are the only rs types yes> single and completable are always backpressure-aware types?the other base types (including observable) dont have a notion for backpressure || can we please keep names for `observable` `single` and `completable` since theyre not part of [rs]( theyre short and well known id just rename `observer` to `observablesubscriber` to have same pattern as `singlesubscriber` and `completablesubscriber` and not interfere with `publisher -> subscriber` || i wouldnt mind renaming `observable` since its a description of the pattern to which all these types conform its the least descriptive of the bunch and you wouldnt chose it today given the othersi used to like `flowable` and i still do but now that we have a non-bp vs bp distinction perhaps we should consider making bp-aware variants of all 3 types and using `flowable` as an adjective instead of a noun? the problem is that gets verbose || `single` and `completable` dont need backpressure because they emit 1 or 0 items respectivelythe non-backpressured `observable` was requested to allow pure gui event handling where the sources are hot and cant be backpressured || hmm what about the `request(0)` case though? where work isnt triggered upon subscription but deferred until explicitly requested || sorry i mean the case where an operation cannot respect `request(0)` im struggling to come up with an example but i know ive ran into potential cases before but i never wrote them down (because we never had `flowable` either) || the current rule of thumb is that if an operator cant respect the request amount it will signal a `missingbackpressureexception` instead of overflowing the downstream this behavior still requires request tracking the reason for signalling is due to the confusion about the situation in 1x where exception is signalled in the operator that suffered the buffer overflow attempt and no indication whose fault it was really || theres also the `subject` and `flowprocessor` types in the mix here || i made a chart of the current naming:<img width""""639"""" alt""""screen shot 2016-08-07 at 2 11 01 am"""" src"""" heres my proposal for normalization:<img width""""639"""" alt""""screen shot 2016-08-07 at 2 22 10 am"""" src"""" changes from current `master` are highlighted ||  ill give the single changes a try || will continue with completable once the other 2 prs are merged to avoid merge conflicts || the proposed new names have been applied and i guess this issue can be closed then if there is no further input || renames and refactorings happened || "";1;0;2x: rename observable base interface types for consistency;"
4301;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: rename observablesource to observablewithupstream;to unblock #4300;;0;2x: rename observablesource to observablewithupstream;to unblock #4300;lgtm    4301  **< ;;;;1;1;2x: rename observablesource to observablewithupstream;
"4302;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: rename completable base interface types for consistency;addresses #4044;;4044.0;2x: rename completable base interface types for consistency;addresses #4044;   4302   ;2x: new base interface types;as part of the 2x design new base interface types have been recently merged & applied the aim is to match the style of the reactive-streams base types + their fluent base class:`flowable` -> `publisher` -> `subscriber``observable` -> `observableconsumable` -> `observer``single` -> `singleconsumable` -> `singlesubscriber``completable` -> `completableconsumable` -> `completablesubscriber`they feel odd to me too so any idea is welcome;""just to be clear before i start thinking about this more `publisher` and `subscriber` are the only rs types here right? and `single` and `completable` are always backpressure-aware types? || > publisher and subscriber are the only rs types yes> single and completable are always backpressure-aware types?the other base types (including observable) dont have a notion for backpressure || can we please keep names for `observable` `single` and `completable` since theyre not part of [rs]( theyre short and well known id just rename `observer` to `observablesubscriber` to have same pattern as `singlesubscriber` and `completablesubscriber` and not interfere with `publisher -> subscriber` || i wouldnt mind renaming `observable` since its a description of the pattern to which all these types conform its the least descriptive of the bunch and you wouldnt chose it today given the othersi used to like `flowable` and i still do but now that we have a non-bp vs bp distinction perhaps we should consider making bp-aware variants of all 3 types and using `flowable` as an adjective instead of a noun? the problem is that gets verbose || `single` and `completable` dont need backpressure because they emit 1 or 0 items respectivelythe non-backpressured `observable` was requested to allow pure gui event handling where the sources are hot and cant be backpressured || hmm what about the `request(0)` case though? where work isnt triggered upon subscription but deferred until explicitly requested || sorry i mean the case where an operation cannot respect `request(0)` im struggling to come up with an example but i know ive ran into potential cases before but i never wrote them down (because we never had `flowable` either) || the current rule of thumb is that if an operator cant respect the request amount it will signal a `missingbackpressureexception` instead of overflowing the downstream this behavior still requires request tracking the reason for signalling is due to the confusion about the situation in 1x where exception is signalled in the operator that suffered the buffer overflow attempt and no indication whose fault it was really || theres also the `subject` and `flowprocessor` types in the mix here || i made a chart of the current naming:<img width""""639"""" alt""""screen shot 2016-08-07 at 2 11 01 am"""" src"""" heres my proposal for normalization:<img width""""639"""" alt""""screen shot 2016-08-07 at 2 22 10 am"""" src"""" changes from current `master` are highlighted ||  ill give the single changes a try || will continue with completable once the other 2 prs are merged to avoid merge conflicts || the proposed new names have been applied and i guess this issue can be closed then if there is no further input || renames and refactorings happened || "";1;0;2x: rename completable base interface types for consistency;"
4304;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add missing license headers;now every file has a license header.;;0;2x: add missing license headers;now every file has a license header;  4304   ;;;;1;1;2x: add missing license headers;
4305;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: rename source/publisher wrapper class to more semantic  from  name.;;;0;2x: rename source/publisher wrapper class to more semantic from name;;  4305   ;;;;1;1;rename source/publisher wrapper class to more semantic from name;
4307;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: promote lift implementations to top-level types.;;;0;2x: promote lift implementations to top-level types;;  4307  ;;;;1;1;promote lift implementations to top-level types;
4308;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: promote observable to single/flowable adapters to top-level types.;;;0;2x: promote observable to single/flowable adapters to top-level types;;  4308  ;;;;1;1;promote observable to single/flowable adapters to top-level types;
4309;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: remove unused exceptions in public api;as wanted in #4306;;4306.0;2x: remove unused exceptions in public api;as wanted in #4306;  4309   /cc @jakewharton  || :+1: if the test changes are acceptable for your setup || ;2x: unused exceptions in public api;currently theres a few exceptions which are unused that are in the public api:- `oncompletefailedexception`- `onerrorfailedexception`- `onerrornotimplementedexception`- `unsubscribefailedexception`there are tests which use these for various reasons but the primary cause of lack of use is that subscribers cannot throw according to the reactive streams specificationthis is just a tracking issue for doing something about that or removing them before 20;yes they are there mostly to satisfy some tests that are mostly ignored by the way certainly we cant throw them  so they can be removed if you remove them from tests please keep the test method with `@ignored` so they dont show up as missing for the test-sync im doing ||;1;0;2x: remove unused exceptions in public api;
"4310;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix subscriptionarbiter reentrancy/cancel bug;this pr fixes the case when a call to request() prevented cancellation of the arbiter if the call never returned  thus locking out the drain loop from the cancellation call.  the pr makes sure  request()  is only called outside the guarded region.  1.x is not affected because unsubscription and requesting go on separate  channels .  the pr also fixes  flowableredo  by serializing the repeat signal  processor .;;0;2x: fix subscriptionarbiter reentrancy/cancel bug;""this pr fixes the case when a call to request() prevented cancellation of the arbiter if the call never returned thus locking out the drain loop from the cancellation callthe pr makes sure `request()` is only called outside the guarded region1x is not affected because unsubscription and requesting go on separate """"channels""""the pr also fixes `flowableredo` by serializing the repeat signal `processor`"";  4310  **< ;;;;1;1;use an infinite source with timeout as 1g element takes only 2 secs;"
4311;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: schedulers.from() to call rxjavahooks.onscheduleaction;the  executorscheduler  wrapper did not call the  rxjavahooks.onscheduledaction()  to decorate actions sent to a custom scheduler.;;0;1x: schedulersfrom() to call rxjavahooksonscheduleaction;the `executorscheduler` wrapper did not call the `rxjavahooksonscheduledaction()` to decorate actions sent to a custom scheduler;  4311   ;;;;1;1;1x: schedulersfrom() to call rxjavahooksonscheduleaction;
4314;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: rename flowablesource to flowablewithupstream to match observablewithupstream.;;;0;2x: rename flowablesource to flowablewithupstream to match observablewithupstream;; ;;;;1;1;rename flowablesource to flowablewithupstream to match observablewithupstream;
4315;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: use arraylistsupplier in more places  add hashmapsupplier.;;;0;2x: use arraylistsupplier in more places add hashmapsupplier;;;;;;1;1;use arraylistsupplier in more places add hashmapsupplier;
4316;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: normalize empty and never sources.;;;0;2x: normalize empty and never sources;;   4316  ;;;;1;1;normalize empty and never sources;
"4317;1;0;0;0;0;1;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: rename create to unsafecreate  add  safe  create methods.;this is a proposal to solve #4255 but for 2.x and closes #4286 built around one goal: make the  create  methods actually usable by developers!  currently the advice given to most developers using 1.x is avoid  create  unless you are absolutely 100% sure you understand backpressure and cancellation  and even then avoid it if possible. this method is a trap that most new developers fall into. _the method is named  create   after all  so it must be how i create these things!_ i want to make that statement not only correct  but advisable (at least when the still-convenient  from  methods are not suitable  such as when wrapping callback-based apis).  because  observable    single   and  completable  are backpressure-free  this amounts to just suppressing downstream notifications when disposed. this doesn t seem too controversial.  the most controversial part is that i have renamed  flowable.fromasync  to  flowable.create  thus making it the canonical way for users to create  flowable s directly. i m much less opinionated on this change  but it felt wrong to have an  flowable.unsafecreate  with no associated  create  and  fromasync  is the  safest  version we have.;;4255.0;""2x: rename create to unsafecreate add """"safe"""" create methods"";""this is a proposal to solve #4255 but for 2x and closes #4286 built around one goal: make the `create` methods actually usable by developers!currently the advice given to most developers using 1x is avoid `create` unless you are absolutely 100% sure you understand backpressure and cancellation and even then avoid it if possible this method is a trap that most new developers fall into _the method is named """"create"""" after all so it must be how i create these things!_ i want to make that statement not only correct but advisable (at least when the still-convenient """"from"""" methods are not suitable such as when wrapping callback-based apis)because `observable` `single` and `completable` are backpressure-free this amounts to just suppressing downstream notifications when disposed this doesnt seem too controversialthe most controversial part is that i have renamed `flowablefromasync` to `flowablecreate` thus making it the canonical way for users to create `flowable`s directly im much less opinionated on this change but it felt wrong to have an `flowableunsafecreate` with no associated `create` and `fromasync` is the """"safest"""" version we have"";""  4317   i think its also important to point out i replaced `consumer<asynemitter<t>>` with `flowablesource<t>` for parity with other """"safe"""" `create` method parameter types the unsafe variant still takes a raw `publisher<t>` however ||     ||  "";1x: rename observablefromasync();`fromasync()` sounds like its ok to emit from multiple threads in parallel while in fact it doesnt serialize emissioncan we rename it? for example to `observablefromcallback()` which also seems more obvious to use when you convert callback-styled code to `observable`;the suggested name is too close to `fromcallable` besides the javadoc of `asyncemitter` warns about sequential use:``` java/** * abstraction over a rxjava subscriber that allows associating * a resource with it and exposes the current number of downstream * requested amount * <p> * the onnext onerror and oncompleted methods should be called  * in a sequential manner just like the observers methods the * other methods are threadsafe * * @param <t> the value type to emit */``` || > the suggested name is too close to fromcallableyoure worried about dynamic languages like groovy? theyre not _that_ bad!> besides the javadoc of asyncemitter warns about sequential usewell to me it looks ~like `void threadsafe()` which has note in javadoc that its not thread safe   || they sound to similar and may lead to speaker embarrassment when mixed up not to mention users getting confused and content assist/intellisense bringing up both of them when typing `fromcall` || i dont think something being asynchronous immediately implies that its also concurrent || true but not a lot of people understand thatonly because of `asynctask` a lot of android devs think that async  bgthreadanother point is that `fromasync()` is probably not what developer wouldlook into when he/she will need to convert callback-styled api to rx`fromcallback()` looks more user-friendly (in my opinion of course)on fri aug 5 2016 at 5:54 pm jake wharton notifications@githubcomwrote:> i dont think something being asynchronous immediately implies that its> also concurrent> > > you are receiving this because you authored the thread> reply to this email directly view it on github>  or mute the thread>   || using an `asynctask` inside `fromasync` would be perfectly fine since its not concurrent`fromcallback` is clearly not usable for the reasons previously stated im not against a rename but im having a hard time coming up with a better name than what we already have || i would almost rename _both_ `fromcallable` and `fromasync` to just overloads of `from` we already have a few overloads of `from` for adapting various sources so i dont see why these are treated any differently than just more sourcesadditionally the naming conventions of `fromcallable` and `fromasync` disagree with each other and other rxjava conventionsthe first one `fromcallable` describes the mechanism (`callable`) of what its adapting we dont see `fromiterable` or `fromfuture` so why `fromcallable`?`fromasync` on the other hand describes the behavior that it is adapting (a callback-based source) again we dont have `fromsynchronous` or `justsynchronous` so why `fromasync`? additionally `fromasync` is perfectly usable for non-asynchronous sources its merely adapting a callback-based system (the foundation of artems argument) but theres no reason it has to be asynchronous it might be just be abstracting over a visitor-based apii would prefer both of these be renamed to `from` because thats how you adapt an external implementation of a data source into an `observable` it doesnt matter if its an `iterable` `future` `callable` or a callback-based source i would also rename `asyncemitter` to just `emitter` with this change || humorously enough rxjava 2 actually does postfix `from` with the source (eg `fromarray` `fromiterable` etc) i stand by my argument that both of these should be just `from()` in rxjava 1x and we can bikeshed the name for 2x in a separate issue || > i would almost rename both fromcallable and fromasync to just overloads of from i dont recommend it java 8 compiler gets sometimes quite confused for example:```from(() -> 1)from(() -> new iterator() { })```in this case `from()` could mean any of the pre operators and youll end up casting a lot to make it right - postfix is shorter || great point in that case i still think `fromasync` is the wrong name based solely on the fact that its a potentially-inaccurate description of whats being adapted but im not sold on the need to change it for 1x || could be `fromemitter` || `fromemitter` sounds better than `fromasync` to me  see #4442 || closing via #4442 ||;1;0;""rename create to unsafecreate add """"safe"""" create methodsthis change is built around one goal: make the `create` methods actually usable by developers!currently the advice given to most developers using 1x is avoid `create` unless you are absolutely 100% sure you understand backpressure and cancellation and even then avoid it if possible this is a trap that most new developers fall into _the method is named """"create"""" after all so it must be how i create these things!_ i want to make that not only correct but advisable (at least when the still-convenient """"from"""" methods are not suitable such as when wrapping callback-based apis)because `observable` `single` and `completable` are backpressure-free this amounts to just suppressing downstream notifications when disposed this doesnt seem too controversialthe most controversial part is that i have renamed `flowablefromasync` to `flowablecreate` thus making it the canonical way for users to create `flowable`s directly im much less opinionated on this change but it felt wrong to have an `flowableunsafecreate` with no associated `create` and `fromasync` is the """"safest"""" version we have"";"
"4317;1;0;0;0;0;1;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: rename create to unsafecreate  add  safe  create methods.;this is a proposal to solve #4255 but for 2.x and closes #4286 built around one goal: make the  create  methods actually usable by developers!  currently the advice given to most developers using 1.x is avoid  create  unless you are absolutely 100% sure you understand backpressure and cancellation  and even then avoid it if possible. this method is a trap that most new developers fall into. _the method is named  create   after all  so it must be how i create these things!_ i want to make that statement not only correct  but advisable (at least when the still-convenient  from  methods are not suitable  such as when wrapping callback-based apis).  because  observable    single   and  completable  are backpressure-free  this amounts to just suppressing downstream notifications when disposed. this doesn t seem too controversial.  the most controversial part is that i have renamed  flowable.fromasync  to  flowable.create  thus making it the canonical way for users to create  flowable s directly. i m much less opinionated on this change  but it felt wrong to have an  flowable.unsafecreate  with no associated  create  and  fromasync  is the  safest  version we have.;;4286.0;""2x: rename create to unsafecreate add """"safe"""" create methods"";""this is a proposal to solve #4255 but for 2x and closes #4286 built around one goal: make the `create` methods actually usable by developers!currently the advice given to most developers using 1x is avoid `create` unless you are absolutely 100% sure you understand backpressure and cancellation and even then avoid it if possible this method is a trap that most new developers fall into _the method is named """"create"""" after all so it must be how i create these things!_ i want to make that statement not only correct but advisable (at least when the still-convenient """"from"""" methods are not suitable such as when wrapping callback-based apis)because `observable` `single` and `completable` are backpressure-free this amounts to just suppressing downstream notifications when disposed this doesnt seem too controversialthe most controversial part is that i have renamed `flowablefromasync` to `flowablecreate` thus making it the canonical way for users to create `flowable`s directly im much less opinionated on this change but it felt wrong to have an `flowableunsafecreate` with no associated `create` and `fromasync` is the """"safest"""" version we have"";""  4317   i think its also important to point out i replaced `consumer<asynemitter<t>>` with `flowablesource<t>` for parity with other """"safe"""" `create` method parameter types the unsafe variant still takes a raw `publisher<t>` however ||     ||  "";2x: add fromasync observable factory;but potentially with a different name based on what the resolution of #4255 is;""and bonus: no backpressure strategy argument needed! || i would also argue for the deletion of `flowablefromasync` since its just `observablefromasync()toflowable(strategy)` which isnt much longer than `flowablefromasync( strategy)` plus visitor/callback-based apis are unlikely to have built-in backpressure so it makes sense to wrap them as a backpressure-free type and then apply a strategy ||  ill try to give this a go tomorrow im afraid ive sent too many prs already and the statistical likelihood of conflicts is approaching 100% || i have an alternate proposal:- remove `flowablefromasync` + `asyncemitter`- rename `observablecreate` to `observableunsafecreate`- add `observablecreate` which wraps the incoming `observer` in one which checks for cancelation (similar to what `baseasyncemitter` is doing now)this has a few advantages:- it makes `observablecreate(observablesource)` actually usable by """"normal"""" users! no more traps to fall in!- it still allows fully-compliant `observablesource` implementations via `unsafecreate` (or subclassing)- it re-uses the same interface types and names we already have without needing new ones- it re-uses the existing `onbackpressure*` methods for adding backpressure to created observablesand disadvantages:- it removes the ability to do proper backpressure-aware implementations easily but perhaps something similar to `asynconsubscribe` could be brought along for handling requests and then using this new safer `observablecreate` for its return values || in terms of the last disadvantage `flowablecreate` could be renamed to `flowableunsafecreate` and `flowablecreate(batchpublisher)` could be added where `batchpublisher` is something like a pared down `asynconsubscribe` || this happened! || "";1;0;""rename create to unsafecreate add """"safe"""" create methodsthis change is built around one goal: make the `create` methods actually usable by developers!currently the advice given to most developers using 1x is avoid `create` unless you are absolutely 100% sure you understand backpressure and cancellation and even then avoid it if possible this is a trap that most new developers fall into _the method is named """"create"""" after all so it must be how i create these things!_ i want to make that not only correct but advisable (at least when the still-convenient """"from"""" methods are not suitable such as when wrapping callback-based apis)because `observable` `single` and `completable` are backpressure-free this amounts to just suppressing downstream notifications when disposed this doesnt seem too controversialthe most controversial part is that i have renamed `flowablefromasync` to `flowablecreate` thus making it the canonical way for users to create `flowable`s directly im much less opinionated on this change but it felt wrong to have an `flowableunsafecreate` with no associated `create` and `fromasync` is the """"safest"""" version we have"";"
4318;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: switch (almost) all chain operators to flowablewithupstream.;;;0;2x: switch (almost) all chain operators to flowablewithupstream;;  4318  ;;;;1;1;switch (almost) all chain operators to flowablewithupstream;
4319;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: switch (almost) all remaining chain operators to observablewithupstream.;;;0;2x: switch (almost) all remaining chain operators to observablewithupstream;;  4319  ;;;;1;1;switch (almost) all chain operators to observablewithupstream;
4322;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: add testsubscriber.assertvaluesandclear;this pr adds an ~~ assertandconsume ~~  assertvaluesandclear  method to  testsubscriber  to assert on value content and then clear the internal value list. this helps asserting on received values without the need to list all previously seen values in  assertvalues .   on a sidenote   getonnextevents()  returns the internal list and one can call  clear()  on it.;;0;1x: add testsubscriberassertvaluesandclear;this pr adds an ~~`assertandconsume`~~ `assertvaluesandclear` method to `testsubscriber` to assert on value content and then clear the internal value list this helps asserting on received values without the need to list all previously seen values in `assertvalues` on a sidenote `getonnextevents()` returns the internal list and one can call `clear()` on it;  4322    but method name i just cant treat it as good for this api ||  @jakewharton / @zsxwing / @vanniktech can you ptal? would be great if we could include it in 119 || old method name was better ||;;;;1;1;tag as experimental;
4323;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: no scheduler change happens for timeinterval() and timestamp().;;;0;2x: no scheduler change happens for timeinterval() and timestamp();;  4323  **< ;;;;1;1;no scheduler change happens for timeinterval() and timestamp();
4324;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: skip static factories when converting between stream types.;also rename publisher->completable factory method and operator implementation to match other stream types.;;0;2x: skip static factories when converting between stream types;also rename publisher->completable factory method and operator implementation to match other stream types;  4324  ;;;;1;1;skip static factories when converting between stream typesalso rename publisher->completable factory method and operator implementation to match other stream types;
4326;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: extract  withupstream  interfaces.;this allows use with types that do not extend directly from their base stream types.;;0;2x: extract withupstream interfaces;this allows use with types that do not extend directly from their base stream types;  4326  **< ;;;;1;1;extract withupstream interfacesthis allows use with types that do not extend directly from their base stream types;
4330;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;added observable.concat(iterable);see #4329   i also adjusted the test as it was testing the wrong thing before.;;4329.0;added observableconcat(iterable);see #4329 i also adjusted the test as it was testing the wrong thing before;  4330     ;concat<iterable<observable>>;is there a reason that there is `observablemerge(iterable<observable>)` but not `observableconcat(iterable<observable>)`?if i understand correctly it could work similarly as`concat(from(iterable))`;cant remember people just kept writing `concat(from(iterable))` || working on it -) || closing via #4330 ||;1;0;adjusted testconcatwithiterableofobservable to really test iterables before it was testing the same as testconcatwithobservableofobservable;
4333;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add  withupstream  interfaces to connectable implementations.;;;0;2x: add withupstream interfaces to connectable implementations;;  4333  ;;;;1;1;add withupstream interfaces to connectable implementations;
4337;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: move disposableobserver to public area  add some javadocs;move  disposableobserver  to  io.reactivex.observers  + some documentation.  related: #4082.;;4082.0;2x: move disposableobserver to public area add some javadocs;move `disposableobserver` to `ioreactivexobservers` + some documentationrelated: #4082;  4337   :+1:having these in the public api make it seem like `asyncobserver` becomes obsolete in the case where its not managing any additional resources should we rename it to `resourceobserver` (or something) and have it always manage resources? || sure will you do it? || yep! ||;2x: subscribers observables classes leak internal types into the public api;all of the methods doing this are at present unused if theyre for public consumption we need `disposablesubscriber` and `nbpdisposablesubscriber` (or equivalent) to be in a public package;yes we should avoid these || id like to resolve this could you point me to the problematic classes and what exactly is leaking? || its the `createdisposable` methods in `subscribers` and `observers` which return `disposablesubscriber` and `disposableobserver` || see #4337 || i think this has been resolved let me know if you find something else (or post a fix pr) ||;1;0;2x: move disposableobserver to public area add some javadocs;
"4338;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: remove conditional resource management from async listeners.;rename them to have a  resource  prefix.;;0;2x: remove conditional resource management from async listeners;rename them to have a resource prefix;""the value of and distinction between the resource listeners default listeners and disposable listeners seems very low do we need all these individual types? || i believe the minimum we require is the ability to dispose a `subscriber` because thats expected the most i dont think associating resources with or allowing async requesting is that common ||   4338   i leave it to you to remove the unnecessary we can add them back later or better yet they can live in a separate library || yeah i need to write something non-trivial with 2x first maybe ill trythis weekend i definitely think we should be aggressive in minimizing apisurface since its easy to add but impossible to take away after releaseon wed aug 10 2016 at 4:23 pm david karnok notifications@githubcomwrote:> i leave it to you to remove the unnecessary we can add them back later or> better yet they can live in a separate library> > > you are receiving this because you authored the thread> reply to this email directly view it on github>  or mute the thread>   || i have a 2x """"dumping ground"""" for leftovers:  so we dont lose things || "";;;;1;1;remove conditional resource management from async listenersrename them to have a resource prefix;"
4342;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: sync javadoc of flowable;this pr adds the javadoc to the  flowable  plus removes some deprecated or unnecessary operator overloads.  by the sheer amount of documentation   flowable  can t be reviewed on github. once the ci passes  i ll merge it and people who wish to review it can immediately start a pr to fix any documentation mistakes.;;0;2x: sync javadoc of flowable;this pr adds the javadoc to the `flowable` plus removes some deprecated or unnecessary operator overloadsby the sheer amount of documentation `flowable` cant be reviewed on github once the ci passes ill merge it and people who wish to review it can immediately start a pr to fix any documentation mistakes;;;;;1;1;2x: sync javadoc of flowable;
4343;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove tabs indent and redundant space.;- remove tabs indent and redundant space.   - currently tabs and spaces are mixed up in the code so just unify them.;;0;remove tabs indent and redundant space;- remove tabs indent and redundant space  - currently tabs and spaces are mixed up in the code so just unify them;;;;;1;1;remove tabs indent and redundant space;
4344;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix some typos in flowable + observer documentation;;;0;2x: fix some typos in flowable + observer documentation;;;;;;1;1;2x: fix some typos in flowable + observer documentation;
4346;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: sync javadoc of observable (copy&adjust flowable s);this pr adds javadoc to  observable  by mainly copying and adjusting  flowable  s documentation.  in addition  the method set was synced as well and placeholders added for unported 1.x operators.  the drill is the same as before: after ci  i merge this and reviewers can post prs with necessary fixes.;;0;2x: sync javadoc of observable (copy&adjust flowables);this pr adds javadoc to `observable` by mainly copying and adjusting `flowable`s documentationin addition the method set was synced as well and placeholders added for unported 1x operatorsthe drill is the same as before: after ci i merge this and reviewers can post prs with necessary fixes;  4346  ;;;;1;1;2x: sync javadoc of observable (copy&adjust flowables);
4349;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: observable + flowable fix some typos;;;0;2x: observable + flowable fix some typos;;  4349  ;;;;1;1;2x: observable + flowable fix some typos;
4352;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: sync single javadoc with 1.x;this pr adds javadoc to the  single  methods  fixes a few api differences.;;0;2x: sync single javadoc with 1x;this pr adds javadoc to the `single` methods fixes a few api differences;  4352  ;;;;1;1;2x: sync single javadoc with 1x;
4353;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: accept subclasses of throwable for asserting failure.;;;0;2x: accept subclasses of throwable for asserting failure;;  4353  ;;;;1;1;accept subclasses of throwable for asserting failure;
4355;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: sync completable javadoc and related changes;this pr mainly adds  scheduler:  descriptions to  completable   removes deprecated operators or unnecessary aliases. in addition  blocking methods now are named  blockingawait  and  blockingget .;;0;2x: sync completable javadoc and related changes;this pr mainly adds `scheduler:` descriptions to `completable` removes deprecated operators or unnecessary aliases in addition blocking methods now are named `blockingawait` and `blockingget`;;;;;1;1;2x: sync completable javadoc and related changes;
4357;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: switch to throwing action  switchmapdelayerror  other cleanup;notable changes: - replace the use of  runnable  in the base reactive types to  action  whose  run  method can throw a checked exception. - fix javadoc referencing 1.x types no longer available. - the  switchmap  operator has been enhanced to support delaying errors. - update  concat(iterable)  to use  concatmapdelayerror  because iterable can t throw just anytime but on the boundary  reducing the per-element overhead. -  flowableemitter  has been enhanced with a  serialize()  method that serializes calls to  onxxx  methods. - factored out  flowableemitter.cancellable  into  io.reactivex.functions  as it will be used by the other base reactive types with their  xemitter  implementations. - added  atomicthrowable  with convenience methods that use  exceptionhelper  s terminal atomics with  throwable s.;;0;2x: switch to throwing action switchmapdelayerror other cleanup;notable changes:- replace the use of `runnable` in the base reactive types to `action` whose `run` method can throw a checked exception- fix javadoc referencing 1x types no longer available- the `switchmap` operator has been enhanced to support delaying errors- update `concat(iterable)` to use `concatmapdelayerror` because iterable cant throw just anytime but on the boundary reducing the per-element overhead- `flowableemitter` has been enhanced with a `serialize()` method that serializes calls to `onxxx` methods- factored out `flowableemittercancellable` into `ioreactivexfunctions` as it will be used by the other base reactive types with their `xemitter` implementations- added `atomicthrowable` with convenience methods that use `exceptionhelper`s terminal atomics with `throwable`s;  4357   ;;;;1;1;2x: switch to throwing action switchmapdelayerror;
4360;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: factor out inner classes from the base reactive types;this pr factors out the anonymous inner classes from the base reactive types and introduces the appropriate classes and methods in  *helper  enums.;;0;2x: factor out inner classes from the base reactive types;this pr factors out the anonymous inner classes from the base reactive types and introduces the appropriate classes and methods in `*helper` enums;  4360  **< ;;;;1;1;2x: factor out inner classes from the base reactive types;
4361;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: test sync  fix retrywhen/redowhen/publish(function);notable changes: - implement the  onbackpressurebuffer  with overflow strategy  change the strategy to plain enum. - additional unit tests from 1.x - implement  publish(function)  properly to support latecommers. - split  flowableredo  into  flowableretrywhen  and  flowablerepeatwhen . - make sure  take(0)  still triggers upstream subscription that is immediately cancelled.;;0;2x: test sync fix retrywhen/redowhen/publish(function);notable changes:- implement the `onbackpressurebuffer` with overflow strategy change the strategy to plain enum- additional unit tests from 1x- implement `publish(function)` properly to support latecommers- split `flowableredo` into `flowableretrywhen` and `flowablerepeatwhen`- make sure `take(0)` still triggers upstream subscription that is immediately cancelled;  4361  ;;;;1;1;fix spelling error use common parameter validation at more places;
4364;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x collect - handle post terminal events;just looking at moving some recent 1.x bug fixes and tests over to 2.x.  this is my first pr in 2.x so before i proceed adding more tests from 1.x (to this pr) i want to get some feedback on my approach. in particular in the test  testcollectorfailuredoesnotresultintwoerroremissions  is the  flowable  creation method ok?;;0;2x collect - handle post terminal events;just looking at moving some recent 1x bug fixes and tests over to 2xthis is my first pr in 2x so before i proceed adding more tests from 1x (to this pr) i want to get some feedback on my approach in particular in the test `testcollectorfailuredoesnotresultintwoerroremissions` is the `flowable` creation method ok?;if youd make it more concise that would be great also note that most flowable operators have an observable counterpart so it would be nice if such changes would contain the fix & tests for both ||   4364   > if youd make it more concise that would be great also note that most flowable operators have an observable counterpart so it would be nice if such changes would contain the fix & tests for bothcan do || i was trying to avoid this class till now will you be able to finish what you wanted till thursday or may i do it? || @akarnokd i rebased but ioreactivexoptional disappeared and i was using it in tests ill add it back in internal test package || @akarnokd the work is done for `flowable` and i have done the work for `observable` as well but is on my laptop at home so will finish pr tonight (in about 11 hours time) || @akarnokd im noticing that rxjava 2x is really slow to compile (2 minutes) in eclipse 451 and 46 (say after switching branches) have you noticed that? got any tips? || please try without `optional` yes eclipse is slow if you change `observable` and `flowable` it doesnt like the cycle between the base classes and their implementations not sure why maybe collecting metadata makes is much slower || ive removed `optional` would you like to assess this pr as it stands without the observable fix that i can do in another pr? you guys are moving fast (as usual) and keeping prs open a while is a bit of an obstacle || ;;;;1;1;2x collect - handle post-terminal events properly;
4368;1;0;0;0;0;1;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add withlatestfrom many  cleanups and other enhancements;notable changes: - implemented  withlatestfrom  with multiple other sources (both  flowable  and  observable ) - added missing  exceptions.throwiffatal()  after catching throwables - added  sequentialdisposable  and replaced internal use of  serialdisposable  with it - added  package-info.java  to public packages - added javadoc to some interfaces and methods - removed  @experimental  tags and set those methods to  @since 2.0  - added  halfserializer  to deal with single onnext and multiple onerror/oncomplete callers;;0;2x: add withlatestfrom many cleanups and other enhancements;notable changes:- implemented `withlatestfrom` with multiple other sources (both `flowable` and `observable`)- added missing `exceptionsthrowiffatal()` after catching throwables- added `sequentialdisposable` and replaced internal use of `serialdisposable` with it- added `package-infojava` to public packages- added javadoc to some interfaces and methods- removed `@experimental` tags and set those methods to `@since 20`- added `halfserializer` to deal with single onnext and multiple onerror/oncomplete callers;  4368    thanks @jakewharton ! ||;;;;1;1;2x: add withlatestfrom many cleanups and other enhancements;
"4370;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: remove try+optional  introduce notification;this pr removes the  try  and  optional  classes and (re)introduces  notification<t> .  there are several ways to implement it. this pr uses the abstract class + private subclasses approach that saves on instance size.  related discussion: #4365.;;4365.0;2x: remove try+optional introduce notification;this pr removes the `try` and `optional` classes and (re)introduces `notification<t>`there are several ways to implement it this pr uses the abstract class + private subclasses approach that saves on instance sizerelated discussion: #4365;""> this pr uses the abstract class + private subclasses approach that saves on instance sizethis seems like it would prevent a lot of inlining of the simple """"is""""ers and """"get""""ers because the callsites become polymorphic instead of monomorphicwhen i check the object layout having two fields in a root object doesnt increase the size because of object padding```$ cat notificationjavafinal class notification<t> {  private static final object completed  new object()  private final t value  private final throwable error  notification(t value throwable error) {    thisvalue  value    thiserror  error  }}$ javac notificationjava$ java -cp :/users/jw/downloads/jol-cli-05-fulljar orgopenjdkjolmain internals notificationobjc[95020]: class javalaunchhelper is implemented in both /library/java/javavirtualmachines/jdk180_92jdk/contents/home/bin/java and /library/java/javavirtualmachines/jdk180_92jdk/contents/home/jre/lib/libinstrumentdylib one of the two will be used which one is undefined# warning: unable to attach serviceability agent you can try again with escalated privileges two options: a) use -djoltrywithsudotrue to try with sudo b) echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope# running 64-bit hotspot vm# using compressed oop with 3-bit shift# using compressed klass with 3-bit shift# warning | compressed references base/shifts are guessed by the experiment!# warning | therefore computed addresses are just guesses and are not reliable# warning | make sure to attach serviceability agent to get the reliable addresses# objects are 8 bytes aligned# field sizes by type: 4 1 1 2 2 4 4 8 8 [bytes]# array element sizes: 4 1 1 2 2 4 4 8 8 [bytes]vm fails to invoke the default constructor falling back to class-only introspectionnotification object internals: offset  size      type description                    value      0    12           (object header)                n/a     12     4    object notificationvalue             n/a     16     4 throwable notificationerror             n/a     20     4           (loss due to the next object alignment)instance size: 24 bytesspace losses: 0 bytes internal + 4 bytes external  4 bytes total``` || oops i wrote my comparison wrong (and left it out of the comment)youre right the individual classes are only 16 bytes (12 header + 4 field) that said 24 vs 16 isnt that big of a deal to gain guaranteed monomorphism || there are other ways of doing it ie single object field + private wrapper for throwables: 16 bytes per onnext and 32 bytes per onerror || true ill leave it up to you though or getting at least bimorphic by having value  null represent oncomplete || updated now we have the smaller size but an instanceof check for every isonnext() and getvalue calls ||   4370   looks good! || "";2x design: try+optional vs notification;in 1x we have the `notification<t>` that can hold a value error or completionwhen i started with 20 it was aimed at java 8+ back then thus i thought we could leverage java 8s own `optional` type plus a `try<t>` to hold an error or an `optional<t>` since now we aim at java 6 the `optional<t>` was manually ported back as well to retain the signatures of operatorsuses: `materialize()` `dematerialize()` pacing out `oncomplete()` with `retrywhen` and `repeatwhen`the drawback of `try<optional<t>>` is that for each normal value it incurs 2 allocations whereas the 1x notification required only 1 allocation the completion signal in 1x requires no allocation - 2x requires 1 allocation (the `try`)should we prefer less allocation and thus go back to (something like) `notification<t>` or do we keep the java 8 style?;i much prefer the more semantic notification type which maps into the rxdomain better than try+optionalon thu aug 18 2016 at 4:11 am david karnok notifications@githubcomwrote:> in 1x we have the notification<t> that can hold a value error or> completion> > when i started with 20 it was aimed at java 8+ back then thus i thought> we could leverage java 8s own optional type plus a try<t> to hold an> error or an optional<t> since now we aim at java 6 the optional<t> was> manually ported back as well to retain the signatures of operators> > uses: materialize() dematerialize() pacing out oncomplete() with> retrywhen and repeatwhen> > the drawback of try<optional<t>> is that for each normal value it incurs> 2 allocations whereas the 1x notification required only 1 allocation the> completion signal in 1x requires no allocation - 2x requires 1 allocation> (the try)> > should we prefer less allocation and thus go back to (something like)> notification<t> or do we keep the java 8 style?> > > you are receiving this because you are subscribed to this thread> reply to this email directly view it on github>  or mute the thread>   || :+1: for notifications less allocations easier to understand || see #4370 ||;1;0;2x: remove try+optional introduce notification;"
4371;1;0;0;0;0;1;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: move blocking operators into the base classes;this pr removes the  blockingflowable  and  blockingobservable  classes and moves the blocking operators into the respective reactive classes and names prefixed with  blocking .  in addition  many of the mentions of  flowable  has been replaced with  observable  in  observable .  related: #4366.;;4366.0;2x: move blocking operators into the base classes;this pr removes the `blockingflowable` and `blockingobservable` classes and moves the blocking operators into the respective reactive classes and names pre with `blocking`in addition many of the mentions of `flowable` has been replaced with `observable` in `observable`related: #4366;  4371   lgtm ;2x design: blockingflowable blockingobservable;the `blockingflowable` and `blockingobservable` classes host blocking operations they were introduced to make absolutely clear someone uses blocking operationsthe drawback is that they wrap a `flowable` and `observable` respectively which incurs allocation whenever `toblocking()` is called on the base classi suggest discarding these blocking classes and moving their operators into the base classes prefixing the operator name with `blockingx`;sgtm || im supportive of this only to see two types removed from the public apiand seeing the disconnect of having no blockingsingle andblockingcompletable eliminated it seems a bit ridiculous to worry about asingle allocation though when every other operator already allocates atleast once and this operator is already doing something 10x worse bythrowing away the current thread on a lockon thu aug 18 2016 at 8:04 am david karnok notifications@githubcomwrote:> the blockingflowable and blockingobservable classes host blocking> operations they were introduced to make absolutely clear someone use> blocking operations> > the drawback is that they wrap a flowable and observable respectively> which incurs allocation whenever toblocking() is called on the base class> > i suggest discarding these blocking classes and mving their operators into> the base classes prefixing the operator name with blockingx> > > you are receiving this because you are subscribed to this thread> reply to this email directly view it on github>  or mute the thread>   || see #4371 ||;1;0;2x: move blocking operators into the base classes;
4372;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: implement observablehide for also masking the disposable.;;;0;2x: implement observablehide for also masking the disposable;;  4372  ;;;;1;1;implement observablehide for also masking the disposable;
4375;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: added missing ops  cleanup 8/19-1;notable changes: - renamed and added safe  create  support to  observable    single  and  completable  - added some javadoc - added  test()  method to  single  and  completable  - factored out  errormode  into  internal.util  (used by various  concat  operators);;0;2x: added missing ops cleanup 8/19-1;notable changes:- renamed and added safe `create` support to `observable` `single` and `completable`- added some javadoc- added `test()` method to `single` and `completable`- factored out `errormode` into `internalutil` (used by various `concat` operators);  4375   ;;;;1;1;2x: added missing ops cleanup 8/19-1;
4378;1;0;0;0;0;1;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: implement ops  add javadoc  remove unused components 8/19-2;notable changes: - use jmh 1.13 - fix javadoc generator exclude pattern - add javadoc to many components - remove  observers  and  subscribers  - all their function is available via subscribe() and/or by implementing the abstract  xobserver / xsubscriber  provided - remove  schedulers.immediate()  - remove  single.subscribe(subscriber)    single.subscribe(observer)    completable.subscribe(subscriber)  and  completable.subscribe(observer)  - remove  completableserializedobserver  and  singleserializedobserver  and their parent package - implement  single.takeuntil    single.flatmapcompletable  - update the time-shift handling in the default  scheduler.scheduleperiodically()  to match 1.x - fix  single.subscribeon  disposable management - renamed  subject.hassubscribers  to  subject.hasobservers;;0;2x: implement ops add javadoc remove unused components 8/19-2;notable changes:- use jmh 113- fix javadoc generator exclude pattern- add javadoc to many components- remove `observers` and `subscribers` - all their function is available via subscribe() and/or by implementing the abstract `xobserver`/`xsubscriber` provided- remove `schedulersimmediate()`- remove `singlesubscribe(subscriber)` `singlesubscribe(observer)` `completablesubscribe(subscriber)` and `completablesubscribe(observer)`- remove `completableserializedobserver` and `singleserializedobserver` and their parent package- implement `singletakeuntil` `singleflatmapcompletable`- update the time-shift handling in the default `schedulerscheduleperiodically()` to match 1x- fix `singlesubscribeon` disposable management- renamed `subjecthassubscribers` to `subjecthasobservers`;  4378   :+1: to code changes skimmed the javadoc for formatting only not content || im not worried about javadoc the community is great at finding errors in there that can be trivially  ||;;;;1;1;2x: implement ops add javadoc remove unused components 8/19-2;
4379;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: move single-use top-level type to nested class of its only use.;;;0;2x: move single-use top-level type to nested class of its only use;;  4379  ;;;;1;1;move single-use top-level type to nested class of its only use;
4380;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: remove test scheduler factory.;this method is misleading in that it s a factory next to a bunch of accessor methods to shared resources. the testscheduler constructor is public and can be used directly.;;0;2x: remove test scheduler factory;this method is misleading in that its a factory next to a bunch of accessor methods to shared resources the testscheduler constructor is public and can be used directly;  4380  ;;;;1;1;remove test scheduler factorythis method is misleading in that its a factory next to a bunch of accessor methods to shared resources the testscheduler constructor is public and can be used directly;
4381;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: correct factory method name for converting an rs publisher.;;;0;2x: correct factory method name for converting an rs publisher;;  4381  ;;;;1;1;correct factory method name for converting an rs publisher;
4382;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: correctly dereference subscription before comparing against null.;;;0;2x: correctly dereference subscription before comparing against null;;  4382  ;;;;1;1;correctly dereference subscription before comparing against null;
4383;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: remove double dash on rxthreadfactory thread names.;also optimize name creation to avoid  stringbuilder  having to expand its underlying  char .;;0;2x: remove double dash on rxthreadfactory thread names;also optimize name creation to avoid `stringbuilder` having to expand its underlying `char`;  4383  ;;;;1;1;remove double dash on rxthreadfactory thread namesalso optimize name creation to avoid stringbuilder having to expand its underlying char;
4385;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: free upstream resources when default observer/subscriber is canceled.;;;0;2x: free upstream resources when default observer/subscriber is canceled;;  4385  **< ;;;;1;1;free upstream resources when default observer/subscriber is canceled;
4386;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: move error consumer helper to internal api.;;;0;2x: move error consumer helper to internal api;;  4386  ;;;;1;1;move error consumer helper to internal api;
"4387;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: remove unused test methods from safe observer/subscriber.;;;0;2x: remove unused test methods from safe observer/subscriber;;""im not a huge fan of the word """"safe"""" here what about calling these `contractobserver` and `contractsubscriber` to more accurately describe what they do? ||   4387  **<  "";;;;1;1;remove unused test methods from safe observer/subscriber;"
4390;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: remove explicit stackoverflow check as its a virtualmachineerror.;looks like [the linked comment]( was misinterpreted (but not in a way that affected the implementation) as scala considered stackoverflowerror as non-fatal but rxjava always considered it fatal. as such  its explicit check was redundant.;;0;1x: remove explicit stackoverflow check as its a virtualmachineerror;looks like [the linked comment]( was misinterpreted (but not in a way that affected the implementation) as scala considered stackoverflowerror as non-fatal but rxjava always considered it fatal as such its explicit check was redundant;  4390  ;;;;1;1;remove explicit stackoverflow check as its a virtualmachineerrorlooks like [the linked comment][1] was misinterpreted (but not in a way that affected the implementation) as scala considered stackoverflowerror as non-fatal but rxjava always considered it fatal as such its explicit check was redundant [1]: https://githubcom/reactivex/rxjava/issues/748#issuecomment-32471495;
4391;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: remove explicit stackoverflow check as its a virtualmachineerror.;looks like [the linked comment]( was misinterpreted (but not in a way that affected the implementation) as scala considered stackoverflowerror as non-fatal but rxjava always considered it fatal. as such  its explicit check was redundant.;;0;2x: remove explicit stackoverflow check as its a virtualmachineerror;looks like [the linked comment]( was misinterpreted (but not in a way that affected the implementation) as scala considered stackoverflowerror as non-fatal but rxjava always considered it fatal as such its explicit check was redundant;  4391  ;;;;1;1;remove explicit stackoverflow check as its a virtualmachineerrorlooks like [the linked comment][1] was misinterpreted (but not in a way that affected the implementation) as scala considered stackoverflowerror as non-fatal but rxjava always considered it fatal as such its explicit check was redundant [1]: https://githubcom/reactivex/rxjava/issues/748#issuecomment-32471495;
4394;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: single.test cancel testsubscriber when wanted;;;0;2x: singletest cancel testsubscriber when wanted;;  4394  ;;;;1;1;2x: singletest dispose testsubscriber when wanted;
4395;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: completable.test cancel testsubscriber when wanted;;;0;2x: completabletest cancel testsubscriber when wanted;;  4395  ;;;;1;1;2x: completabletest cancel testsubscriber when wanted;
4398;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: avoid potential npe when onerror throws.;t2 was only initialized if canceling threw an exception. in the happy path it would have never been initialized so when onerror threw the call to suppress() would npe.;;0;2x: avoid potential npe when onerror throws;t2 was only initialized if canceling threw an exception in the happy path it would have never been initialized so when onerror threw the call to suppress() would npe;  4398  ;;;;1;1;avoid potential npe when onerror throwst2 was only initialized if canceling threw an exception in the happy path it would have never been initialized so when onerror threw the call to suppress() would npe;
4403;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add missing ops  cleanup  fusion fixes;notable changes: - implement  concateager  and its variants - implement  onterminatedetach  - implement  distinctuntilchanged(bipredicate)  - replace  emptydisposable.instance  with  disposables.empty()  due to clash with fusion (sending an instance tells a fusion-enabled source to not expect onnext values yet the test still send those - this was a problem with emptysubscription.instance a while back too). also added javadoc warning about its use - add  observablescalarxmap  optimization to  observable.xmap(function)  and their operator s  subscribeactual  - make  observablejust   scalarcallable  and sync-fuseable with  scalardisposable  (similar to  flowable.just() ) - make  observable.buffersize()  public for convenience. - fix  flatmap  fused  callable  handling - renamed  objects  to  objecthelper  to avoid accidental bad imports of  java.util.objects  of java 8.;;0;2x: add missing ops cleanup fusion fixes;notable changes:- implement `concateager` and its variants- implement `onterminatedetach`- implement `distinctuntilchanged(bipredicate)`- replace `emptydisposableinstance` with `disposablesempty()` due to clash with fusion (sending an instance tells a fusion-enabled source to not expect onnext values yet the test still send those - this was a problem with emptysubscriptioninstance a while back too) also added javadoc warning about its use- add `observablescalarxmap` optimization to `observablexmap(function)` and their operators `subscribeactual`- make `observablejust` `scalarcallable` and sync-fuseable with `scalardisposable` (similar to `flowablejust()`)- make `observablebuffersize()` public for convenience- fix `flatmap` fused `callable` handling- renamed `objects` to `objecthelper` to avoid accidental bad imports of `javautilobjects` of java 8;  4403  ;;;;1;1;fix scalar handling in flatmaps rename objects to objecthelper;
4410;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: cleanup  enhancements 8/23-1;notable changes: - introduce  emitter<t>  as a base interface for  flowableemitter  and  observableemitter   use it for the  generate()  operators to be the push surface. - hide fusion-related methods in  testsubscriber  and  testobserver   remove  test()  method overload from the base reactive classes  introduce  subscriberfusion  and  observerfusion  helper in the test source set - enable fusion on  observable.range() . - move  observer -related tests into the  observers  test package.;;0;2x: cleanup enhancements 8/23-1;notable changes:- introduce `emitter<t>` as a base interface for `flowableemitter` and `observableemitter` use it for the `generate()` operators to be the push surface- hide fusion-related methods in `testsubscriber` and `testobserver` remove `test()` method overload from the base reactive classes introduce `subscriberfusion` and `observerfusion` helper in the test source set- enable fusion on `observablerange()`- move `observer`-related tests into the `observers` test package;  4410   ;;;;1;1;2x: cleanup enhancements 8/23-1;
4413;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: api removals and renames;notable changes: - delete  concat  5-9 arguments  use  concat(just())  or  concatarray(...)  instead - delete  withlatestfrom  5-8 arguments - rename  merge(publisher...)  into  mergearray(publisher...)  to disambiguate - rename  merge(int  int  publisher...)  into  mergearray(int  int  publisher...)  to disambiguate - delete  merge(int  publisher...)  overload - rename  mergedelayerror(publisher...)  into  mergearraydelayerror(publisher...)  to disambiguate - rename  mergedelayerror(int  int  publisher...)  into  mergearraydelayerror(int  int  publisher...)  to disambiguate - delete  mergedelayerror(int  publisher...)  overload - delete  takelatestbuffer  overloads;;0;2x: api removals and renames;notable changes:- delete `concat` 5-9 arguments use `concat(just())` or `concatarray()` instead- delete `withlatestfrom` 5-8 arguments- rename `merge(publisher)` into `mergearray(publisher)` to disambiguate- rename `merge(int int publisher)` into `mergearray(int int publisher)` to disambiguate- delete `merge(int publisher)` overload- rename `mergedelayerror(publisher)` into `mergearraydelayerror(publisher)` to disambiguate- rename `mergedelayerror(int int publisher)` into `mergearraydelayerror(int int publisher)` to disambiguate- delete `mergedelayerror(int publisher)` overload- delete `takelatestbuffer` overloads;  4413    /cc @zsxwing  ||     ||;;;;1;1;2x: api removals and renames;
4417;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add assembly tracking  minor fixes and cleanup;notable changes: - renamed  amb(sources)  to  ambarray(sources...)  to be consistent with the naming of other operators with varargs input - renamed some other varargs operators ot  xarray  to be consistent - added  rxjavaplugins.onassembly()  to operators  note that no other infrastructure (such as  enableassemblytracking  was added  companion libraries may later utilize these hooks to inject the necessary wrapper classes. - extended  rxjavaplugins.onassembly()  to support  connectablex  operators - renamed  flowprocessor  into  flowableprocessor  to avoid future confusion with jdk 9 s  flow.processor  - removed common value extraction methods from  subject  and  flowableprocessor  and left them in the implementations - made common terminal state checking methods of  subject  and  flowableprocessor  as abstract since all subtypes can implement them reasonably - fixed copy-paste errors in javadocs  such as wrong class named  referencing non-existent backpressure;;0;2x: add assembly tracking minor fixes and cleanup;notable changes:- renamed `amb(sources)` to `ambarray(sources)` to be consistent with the naming of other operators with varargs input- renamed some other varargs operators ot `xarray` to be consistent- added `rxjavapluginsonassembly()` to operators note that no other infrastructure (such as `enableassemblytracking` was added companion libraries may later utilize these hooks to inject the necessary wrapper classes- extended `rxjavapluginsonassembly()` to support `connectablex` operators- renamed `flowprocessor` into `flowableprocessor` to avoid future confusion with jdk 9s `flowprocessor`- removed common value extraction methods from `subject` and `flowableprocessor` and left them in the implementations- made common terminal state checking methods of `subject` and `flowableprocessor` as abstract since all subtypes can implement them reasonably-  copy-paste errors in javadocs such as wrong class named referencing non-existent backpressure;  4417  **< ;;;;1;1;add missing header add more time to test;
4418;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: sync dooneach java doc;the other  dooneach  function has the right java doc. terminal events such as  oncompleted  /  onerror  are also included in  dooneach .;;0;1x: sync dooneach java doc;the other `dooneach` function has the right java doc terminal events such as `oncompleted` / `onerror` are also included in `dooneach`;   4418  ;;;;1;1;1x: sync dooneach java doc;
"4421;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fixes  cleanups  renames;changes: - fix spelling mistakes - more consistent parameter naming scheme based on #1353 (but incomplete  rc2) - fix bugs due to wrong variable naming - compact logic expressions - fix  completable.doafterterminate  not called the right time -  onerrorreturnvalue  renamed to  onerrorreturnitem   @davidmgross once this pr has been merged  it would be great you submitted one that has  //todo  markers on those lines that need attention. the naming scheme you suggested doesn t come intuitively to me so i may skip many of them without the markers.;;1353.0;2x: fixes cleanups renames;changes:- fix spelling mistakes- more consistent parameter naming scheme based on #1353 (but incomplete rc2)- fix bugs due to wrong variable naming- compact logic expressions- fix `completabledoafterterminate` not called the right time- `onerrorreturnvalue` renamed to `onerrorreturnitem`@davidmgross once this pr has been merged it would be great you submitted one that has `//todo` markers on those lines that need attention the naming scheme you suggested doesnt come intuitively to me so i may skip many of them without the markers;  4421   ;make operator parameter names consistent across operators;""i recommend that some of the parameter names used in observable operators be changed so that similar parameters have similar names from operator to operatorspecifically:#### collections of observablesan iterable list or array of observables is called """"`sources`"""" in `amb()` and `combinelatest()` """"`sequences`"""" in `merge()` and """"`ws`"""" in `zip()`i recommend standardizing on """"`observables`"""" as the parameter name for these#### observables that emit observablesan observable that emits observables is called """"`observables`"""" in `concat()` """"`source`"""" in `merge()` and `mergedelayerror()` """"`sequenceofsequences`"""" in `switchonnext()` and """"`ws`"""" in `zip()`i recommend standardizing on """"`observables`"""" as the parameter name for these#### ordinary observablesome operators take an ordinary observable as a parameterthe `zip()` operator calls the observable that you pass as a parameter to zip with the source observable """"`other`"""" the `groupjoin()` and `join()` operators use the parameter name """"`right`"""" to describe a similar thing(the new operators `ambwith()` `concatwith()` and `mergewith()` use """"`t1`"""" for this sort of parameter `zipwith()` uses """"`other`"""")i recommend standardizing on """"`other`"""" for this#### multiple observablessome operators take two or more observables as parameters- `amb()` `combinelatest()` and `zip()` call these """"`o1`"""" """"`o2`"""" """"`o3`"""" etc- `concat()` `merge()` and `mergedelayerror()` call these """"`t1`"""" """"`t2`"""" """"`t3`"""" etc- `sequenceequal()` calls these """"`first`"""" and """"`second`""""my recommendation: for at least the operators in the first two bullet points choose a single naming scheme and standardize over it for all of those operators#### special-function observablessome operators are passed observables that emit indicators that instruct the operators to do certain things at certain times  the naming schemes for these could be improvedcurrently:**`buffer()`**- opening indicator: `bufferopenings`- closing indicator: `bufferclosingselector`- boundary indicator: `boundary`**`window()`**- opening indicator: `windowopenings`- closing indicator: `closingselector`- boundary indicator: `boundary`my recommendation for both:- opening indicator: `openingindicator`- closing indicator: `closingindicator`- boundary indicator: `boundaryindicator`i also recommend changing the names of the following parameters so that they conform to a similar naming scheme:- """"`durationselector`"""" """"`leftduration`"""" """"`rightduration`"""" (`groupbyuntil()`)- """"`leftdurationselector`"""" """"`rightdurationselector`"""" (`join()`)- """"`other`"""" (`skipuntil()` and `takeuntil()`)- """"`firsttimeoutselector`"""" and """"`timeoutselector`"""" (`timeout()`)- """"`debounceselector`"""" (`debounce()`)- """"`sampler`"""" (`sample()`)(there are also parameter names for functions that _generate_ observables that emit indicators: """"`subscriptiondelay`"""" and """"`itemdelay`"""" from `delay()` """"`closingselector`"""" from `window()` and """"`notificationhandler`"""" from `repeatwhen()` and `retrywhen()`)#### observables that act as back-up sequencesobservables that are meant to supply items in case of failure in a primary observable are called """"`resumesequence`"""" in `onerror/exceptionrresumenext()` and """"`other`"""" in `timeout()`i recommend standardizing on a single parameter name for these#### number of repetitions`repeat()` uses """"`count`"""" to indicate how many times the items should be repeated `retry()` uses """"`retrycount`"""" to indicate how many times to attempt to retryrecommendation: either use """"`count`"""" for both or change the first one to """"`repeatcount`""""#### numbers of items to skip emit or observeyou can instruct some operators to ignore a certain number of items emitted by an observable you indicate this number with """"`skip`"""" (`buffer()` and `window()`) """"`num`"""" (`skip()`) or """"`count`"""" (`skiplast()`) i recommend standardizing on """"`skip`"""" for all threeyou can also instruct some operators to attend to or to emit a particular number of items emitted by an observable you indicate this number with """"`num`"""" (`limit()` and `take()`) """"`count`"""" (`buffer()` `range()` `takelast()` `takelastbuffer()` and `window()`) or """"`capacity`"""" (`cache()`) i recommend standardizing on one or the other for all of these operators#### durationsseveral operators have parameters that indicate durations of time there are currently at least eight parameter names for parameters indicating duration i recommend this be reduced not necessarily to one but to fewer here are the current ones:- """"`timespan`"""" (`buffer()` `window()`)- """"`timeout`"""" (`debounce()` `from()` `throttlewithtimeout()` `timeout()`)- """"`interval`"""" (`interval()`)- """"`time`"""" (`replay()` `skip()` `skiplast()` `take()` `takelast()` `takelastbuffer()`)- """"`period`"""" (`sample()` `timer()`)- """"`windowduration`"""" and """"`skipduration`"""" (`throttlefirst()`)- """"`intervalduration`"""" (`throttlelast()`)there are also several operators that have parameters related to shifting things forward in time or delaying things in time there are three names for these parameters now: one or maybe two are probably sufficient:- """"`timeshift`"""" (`buffer()` `window()`)- """"`delay`"""" (`delay()` `delaysubscription()`)- """"`initialdelay`"""" (`timer()`)there is a single inconsistency in the parameter for indicating the time unit this is called """"`unit`"""" everywhere except in `timeout()` where it is called """"`timeunit`"""" -- i recommend changing it to """"`unit`"""" there as well#### items emitted by observablesthere are many names used for the parameters that describe an item emitted or to be emitted by an observable: for instance """"`element`"""" (`contains()`) and """"`value`"""" (`just()`) also """"`t1`"""" (`startwith()`) and """"`initialvalue`"""" (`publish()` `reduce()` `blockingobservablemostrecent()`) for an item to emit as the first emission and """"`defaultvalue`"""" (many operators) for an item to emit if there were no emitted items from the source or none that met a predicateive been using """"item"""" in the wiki & javadocs to describe things emitted from observables rather than """"value"""" """"element"""" or """"object"""" this is because observables can emit lots of sorts of things (eg objects elementals additional observables) and usually in the documentation the important thing about these emissions is _that_ theyre emissions rather than that theyre a particular sort of thing """"item"""" is a less-misleading vague specifier for such emissionsfor this reason i recommend that the parameter names also standardize on the """"item"""" terminology so:- """"`element`"""" and """"`value`"""" become **""""`item`""""**- """"`t1`"""" and """"`initialvalue`"""" become **""""`initialitem`""""**- """"`defaultvalue`"""" becomes **""""`defaultitem`""""**there are also a few different names for parameters describing _arrays_ of items:- """"`t1`"""" (`from()`)- """"`items`"""" (`from()`)- """"`values`"""" (`startwith()`)i recommend consolidating these into """"`items`""""#### collectors and accumulatorsare collectors and accumulators two different sorts of things or pretty much the same sort of thing?  `collect()` calls its function a """"`collector`"""" while `reduce()` and `scan()` call theirs an """"`accumulator`""""  im not certain whether these are distinct enough things to necessitate distinct terminology#### functions that transform items emitted by observablesthe following are used as parameter names for passing functions that are meant to transform items emitted by observables:- """"`valueselector`"""" (`groupbyuntil()` `tomap()` `tomultimap()`)- """"`elementselector`"""" (`groupby()`)- """"`func`"""" (`map()`)- """"`selector`"""" (`multicast()` `publish()` `publishlast()` `replay()`)i recommend standardizing on a single name and considering something other than """"selector"""" since these functions arent really """"selecting"""" items so much as _changing_ them#### functions that combine multiple items emitted by observables to create single itemsthe following parameter names describe functions that take items emitted by multiple observables and operate on them to generate a single new item to be emitted:- """"`combinefunction`"""" (`combinelatest()`)- """"`resultselector`"""" (`groupbyuntil()` `join()` `mergemap()` `mergemapiterable()`)- """"`zipfunction`"""" (`zip()` `zipwith()`)i recommend standardizing on a single name for all of these and again im not sold on the """"selector"""" terminology#### functions that generate observablesthere are a number of parameters that describe functions that generate observables:- """"`func`"""" (`concatmap()` `flatmap()` `mergemap()` `switchmap()`)- """"`collectionselector`"""" (`mergemap()`)- """"`observablefactory`"""" (`defer()` `using()`)- """"`resumefunction`"""" (`onerrorflatmap()` `onerrorresumenext()`)my recommendation: change """"`func`"""" to something more descriptive and see if you can consolidate some of these others as well#### on[state] actions/functions`dooncompleted()` and `mergemap()` have """"`oncompleted`"""" parameters `foreach()` and `subscribe()` call their parameters """"`oncomplete`"""" recommendation: change `foreach()` and `subscribe()` to use """"`oncompleted`"""" so as to better match the name of the observer method`finallydo()` takes a parameter called """"`action`"""" most other operators of this sort take parameters of the form """"onsomething"""" (eg """"`onterminate`"""" """"`onnotification`"""" """"`onnext`"""")  recommendation: change the name of this parameter to use an """"onsomething"""" form#### iterables`from()` calls its iterable parameter """"`iterable`"""" `zip()` calls it """"`other`"""" recommendation change `zip()` to match `from()` in this respect"";""great notes @davidmgross! one remark from my side i would like to stay as close as possible to the original rx net names as we can  even if it is a bit suboptimal (for instance for buffer  then we can maintain some uniformity in rx across the different languages without creating a tower of babel[of course one can also argue to use the same parameter names as java streams if there is a match]besides that i am all for improving parameter names and making them more uniform(note that in scala everything is called `f` and `g` etc to match the local style nothing to gain there) || like! @davidmgross  seems like a good idea @headinthebox if we see inconsistencies in the rxnet parameter names whats the plan (@benjchristensen)?  || then lets make a list of those so we can see whats going on and relay back to the net folks and js/c++ || beauton 22 jun 2014 19:04 """"headinthebox"""" notifications@githubcom wrote:> then lets make a list of those so we can see whats going on and relay> back to the net folks and js/c++> > > reply to this email directly or view it on github>  || anyone want to tackle this? i would ignore the rxnet parameter names since parameter names themselves do not affect the public api so it doesnt affect functionality or uniformity || @headinthebox parameter name is more important in rxscala since changing parameter names will break the source compatibility therefore do you think if its worth to review the names in rxscala and make them consistent? || yes but lets make them consistent with the _scala libraries_ instead ie `def map[r](func: t > r): observable[r]` should be `def map[b](f: (a) > b): observable[b]` and `filter(predicate: t > boolean): observable[t]` should be `filter(p: t > boolean): observable[t]` to be consistent with the native scala style as in say  so i guess that means lots of alpha-renaming of `s``t` ~~> `a``b` and using `f` `g` and `h` and `op`makes sense? || removing milestone as this is nice-to-have (doesnt affect behavior) || any chance some of the low-hanging fruit in this issue could be tackled before 10?(for example: the scheduler parameter to parallel() the use of oncompleted vs oncomplete)a little work here could do a lot to improve the clarity of the api and also make it look more deliberately and carefully engineered which would improve first impressions and make people more confident in using it || giving this a bump in the hopes of getting it on the radar of folks who are working on the 20 versions || @artem-zinnatullin - as long as youre doing code clean-up stuff care to tackle this one? || i am afraid that versioning scheme wont allow us to do it several jvm langs such as kotlin groovy  scala supports [""""named arguments""""]( and we can break compilation of someones code though i think that in terms of java we are not breaking anything and this is rxjava not rxkotlin or rxscala @benjchristensen i can do this in 1x if you dont mind or its time to start 2x and move on || this will be tackled in 2x before rc 1 lets rename parameters based on @davidmgross suggestions then || bump || im doing some minor cleanups for 20 rc1 now and will try to unify the field names as well || the names were mostly unified if anything left out we can do that post 20 for perhaps a few months it may take some time other language adapters who actually rely on parameter naming pick 20 up || "";1;0;rename a few more parameters;"
"4422;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add subscribewith to get back the subscriber/observer fluently;this pr adds the  subscribewith  methods to the base reactive types to mainly help with the 1.x to 2.x changeover as 2.x  subscribe(subscriber)  return void instead of the resource/cancellation/unsubscription type  disposable . see the javadocs and the unit test for example use.  related: #4400;;440.0;2x: add subscribewith to get back the subscriber/observer fluently;this pr adds the `subscribewith` methods to the base reactive types to mainly help with the 1x to 2x changeover as 2x `subscribe(subscriber)` return void instead of the resource/cancellation/unsubscription type `disposable` see the javadocs and the unit test for example userelated: #4400;  4422   ;libgdx support;this is the start of a new contrib project that lays the foundation for rxjava support for **[libgdx]( is still missing tests because its very difficult to unit test this properly due to the nature of libgdx however ill be using this a lot in my own android projectsim not sure whether this should be a contrib subproject of rxjava or maybe a separate repo if you think this should be separate just decline the pr;""#357 what do you think is the determination for something being contrib or separate?to me the benefit of contrib is simplified artifact publishing (goes along for the ride) and increased visibility for things that are common extensions bindings and add-onsthe drawback is that the release cycle is tied to rxjava a breaking change in a module will not result in a major revision bump for the rxjava projectthus things are that simple bindings of common projects make perfect sense as contrib modules  things wed almost consider putting in core but dont because of dependencies on other librariesconsidering that do you think the lifecycle of this library is suited to being part of rxjava or being on its own? || what is the common model in the jvm world? my guess s that at some point rxjava will converge to a stable version and then you want to want to have bindings being released at their own faster paceerikon oct 22 2013 at 9:30 pm ben christensen notifications@githubcom wrote:> what do you think is the determination for something being contrib or separate?> > to me the benefit of contrib is simplified artifact publishing (goes along for the ride) and increased visibility for things that are common extensions bindings and add-ons> > the drawback is that the release cycle is tied to rxjava a breaking change in a module will not result in a major revision bump for the rxjava project> > thus things are that simple bindings of common projects make perfect sense as contrib modules  things wed almost consider putting in core but dont because of dependencies on other libraries> > considering that do you think the lifecycle of this library is suited to being part of rxjava or being on its own?> > > reply to this email directly or view it on github || the release cycle is no problem at all - im just wondering if libgdx is common enough || @jmhofer i have no idea about the commonality of libgdx as i dont work in that space id never heard of it but that doesnt mean much i lean towards this being a separate project but being linked to from here:  i have never seen a one-size-fits-all approach generally the best is to keep them separate and decoupled so they have their own release cycle submodules work well though when things are tightly coupled but not wanted in the same project so the core stays lean and has less dependencies (such as what were doing with android/swing in the contrib modules) || thats exactly what i was trying to say ben keep the core as lean as possible then pick and choose what libraries you wanton oct 22 2013 at 9:43 pm ben christensen notifications@githubcom wrote:> @jmhofer i have no idea about the commonality of libgdx as i dont work in that space id never heard of it but that doesnt mean much i lean towards this being a separate project but being linked to from here:  > @headinthebox i have never seen a one-size-fits-all approach generally the best is to keep them separate and decoupled so they have their own release cycle submodules work well though when things are tightly coupled but not wanted in the same project so the core stays lean and has less dependencies (such as what were doing with android/swing in the contrib modules)> > > reply to this email directly or view it on github || > keep the core as lean as possibleyes which is why it is a single-jar project at this point with no external dependenciesthe use of rxjava-contrib is somewhat fuzzy though as we use it for things that """"could"""" go in core but we choose not to because they have other dependencies or are """"extra"""" but are still tightly associated so we want them in the rxjava project and not a 3rd partythe rxjava-android and rxjava-swing contrib modules are good examples of this the rxjava-apache- one is murkier it could easily be argued for that to be a separate project and id probably agree even though i put it there  || i think it makes sense for this to be kept separate lets definitely link to it though from  || "";1;0;2x: add subscribewith to get back the subscriber/observer fluently;"
4423;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: add to() conversion function to all stream types.;this deprecates extend() on observable  which is a less powerful version of these functions.;;0;1x: add to() conversion function to all stream types;this deprecates extend() on observable which is a less powerful version of these functions;  4423   ;;;;1;1;add to() conversion function to all stream typesthis deprecates extend() on observable which is a less powerful version of these functions;
"4425;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: remove  completable  prefix from nested interfaces  move its subscription to top-level.;this is only the  completable  part of #4420. it does not make  completablesubscriber  an abstract class nor create  single.operator .;;4420.0;1x: remove completable prefix from nested interfaces move its subscription to top-level;this is only the `completable` part of #4420 it does not make `completablesubscriber` an abstract class nor create `singleoperator`;[compiler error]( ||   4425   looks okay what about the `@deprecated` markers? || oh sure ill add them in real quick i wasnt sure on your stance on them but i think itll make migration easier || yes having deprecated markers is more forgiveable than lacking the entire type i dont know how extensively `completable` is in use by other libraries right now (beyond rxjavareactivestreams reactors converter retrofit`) || updated! ||  || compilation issue resolved || i know  still waiting for a second approval || okay lets have this one can complain anytime later ||;1x: base interface types;""before `single` and `completable` progress to stable id like to address the interface naming inconsistency in a similar fashion to what #4044 did for 2xheres the current state:<img width""""614"""" alt""""screen shot 2016-08-24 at 1 30 57 pm"""" src"""" very clear that theres a lack of normalization ~~id like to take the same approach as we did in 2x and move to prefixes and top-level types~~ id like to normalize the names of the nested classes and make the subscribers top-level types we can `@deprecate` the existing types and make them extend from these new top-level types to make migration easier deleting these `@deprecated` types whenever these apis turn stable   ?additionally theres a problem with `completablesubscriber` in that its an interface instead of an abstract class that also implements `subscription` (as both `subscriber` and `singlesubscriber` do) i would like to correct this   ?"";""1) kind of disruptive at this point plus `@deprecated` never get removed from the main versions (since it was promised)2) its a modern design just like in 2x but you can introduce the `resourcecompletable` similar to 2x `resourcesubscriber` || er sorry i meant to change that paragraph before hitting create i want to propose non-pre inner types similar to what `observable` has except for the `subscribers` which will be top-levelthis will only change non-stable apis so they could just be renamedi was suggesting `@deprecating` these non-stable old interfaces so that it didnt immediately break people upgrading then eventually you could delete those interfaces since they were never stable in the first place we also could just rename them though and not botherthe changes would look like this:<img width""""614"""" alt""""screen shot 2016-08-24 at 3 51 00 pm"""" src"""" || lets see a pr so the diff is more telling about the consequences || can we do more about this or can this be closed? || i think were now at a good enough place with 1x here any more changes would only be disruptive for the sake of being disruptive || great! || "";1;0;remove completable prefix from nested interfaces move its subscription to top-level;"
4428;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: collect - handle post terminal events  - observable;post-terminal event handling for  observable.collect .  added three unit tests that failed on original logic.;;0;2x: collect - handle post terminal events  - observable;post-terminal event handling for `observablecollect`added three unit tests that failed on original logic;  4428  ;;;;1;1;2x - collect - handle post-terminal events for observable;
4430;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x improve coverage  fix bugs;the new tests revealed some bugs (nothing major).;;0;2x improve coverage fix bugs;the new tests revealed some bugs (nothing major);  4430    updated those in the first commit in this pr and all other places that used `exceptionspropagate` || ;;;;1;1;update to exceptionhelperwraporthrow;
4431;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: coverage  fixes  cleanup 8/27-1;- updated  single.cache()  to be lock-free  to allocate less and work properly - added test coverage to some classes - remove unused internal  emptyobserver  - update  publishsubject  to support cross-cancellation - update  testhelper.race  to use the current thread for one of the tasks;;0;2x: coverage fixes cleanup 8/27-1;- updated `singlecache()` to be lock-free to allocate less and work properly- added test coverage to some classes- remove unused internal `emptyobserver`- update `publishsubject` to support cross-cancellation- update `testhelperrace` to use the current thread for one of the tasks;  4431   ;;;;1;1;2x: coverage fixes cleanup 8/27-1;
4434;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: cleanup  bugfixes  coverage 8/27-2;- remove unused code - improve coverage of  single    completable  and  observable  - fix minor bugs in operators;;0;2x: cleanup bugfixes coverage 8/27-2;- remove unused code- improve coverage of `single` `completable` and `observable`- fix minor bugs in operators;   4434  ;;;;1;1;2x: cleanup bugfixes coverage 8/27-2;
4435;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: cleanup  behavior clarifications  fixes  coverage 8/28-1;- add tests - fix mistakes in  testobserver  - combine  disposablehelper  and its inner  disposed  enum - compact  notificationlite  and its inner  complete  enum - fix npe in  listcompositedisposable  constructor - fix  deferredscalarobserver  fusion and state management - turned a few empty enums into classes with private constructor: coverage can t cover them 100% otherwise. these empty enums have a constructor in their bytecode which never gets called and thus there s always 10 instructions / 2 method calls missing. - removed  testobserver.awaitdone()   one should always await with timeout;;0;2x: cleanup behavior clarifications fixes coverage 8/28-1;- add tests- fix mistakes in `testobserver`- combine `disposablehelper` and its inner `disposed` enum- compact `notificationlite` and its inner `complete` enum- fix npe in `listcompositedisposable` constructor- fix `deferredscalarobserver` fusion and state management- turned a few empty enums into classes with private constructor: coverage cant cover them 100% otherwise these empty enums have a constructor in their bytecode which never gets called and thus theres always 10 instructions / 2 method calls missing- removed `testobserverawaitdone()` one should always await with timeout;  4435   > turned a few empty enums into classes with private constructorthis saves methods for android as well i wanted to see how many were being added before pressing the issue about this convention but nice to see theres another motivation for not using enums here || ;;;;1;1;2x: cleanup behavior clarifications fixes coverage 8/28-1;
"4436;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: maybe for lazy optional;in #4321 i hit on the problem of needing a lazy object that could either be zero or one value. in that issue the idea of switching the return value of  reduce(r  func2<r t r>)  from  observable<r>  to  single<r>  because that operator can only ever produce an observable that emits exactly one value. the problem was that  reduce(func2<t t t>)  could not be changed to  single<t>  because the source observable could be empty and therefore not produce one and only one value.  to solve this problem i mentioned we could create a lazy type that represents either 1 or no value could fill the gap between  completable  and  single<t> .  this pr is for the introduction of the  maybe<t>  type.;;4321.0;2x: maybe for lazy optional;in #4321 i hit on the problem of needing a lazy object that could either be zero or one value in that issue the idea of switching the return value of `reduce(r func2<rtr>)` from `observable<r>` to `single<r>` because that operator can only ever produce an observable that emits exactly one value the problem was that `reduce(func2<ttt>)` could not be changed to `single<t>` because the source observable could be empty and therefore not produce one and only one valueto solve this problem i mentioned we could create a lazy type that represents either 1 or no value could fill the gap between `completable` and `single<t>`this pr is for the introduction of the `maybe<t>` type;""you referenced java 8 types in your code || my problem with adding another base type is the increased maintenance cost currently we have 3 + 4 types in the major versions and it is likely adding a new operator overload or making a fix has to be done for all of them im one-man armying rxjava for a considerable time now but i have my limits therefore my suggestion is that you have this `maybe` as a separate library that depends on rxjava 2 but rxjava 2 doesnt depend on it since rxjava 2 offers fluent conversion method(s) it should be only a small inconvenience to convert to `maybe`:``` javaflowable<integer> source  flowablerange(1 10)maybe<integer> mb  sourceto(maybereduceflowable((a b) -> a + b))mbfilter(v -> false)subscribe(    systemout::println throwable::printstacktrace () -> systemoutprintln(""""done""""))mbtoflowable()subscribe(    systemout::println throwable::printstacktrace () -> systemoutprintln(""""done""""))``` || as i mentioned my plans were to greatly increase the coupling between observable & flowable to single & maybe by having the various operators that return exactly 1 or sometimes 1 value to these two types ||   4436 type exactly for this purpose i suggest you try that first || im not strictly opposed because> my plans were to greatly increase the coupling between observable & flowable to single & maybe by having the various operators that return exactly 1 or sometimes 1 value to these two typesappeals to me but i dont have a really strong feeling without using it more || okay then lets merge this and see how it works out || please dont post prs targeting maybe - im working on cleaning it up a bit (plus a few other classes if i find something wrong) the code copied from an older commit of the other types || "";2x changing some observable operators to return single;i was looking through the observable operators and wondering if now would be a good time to change the following methods to return singles instead of observables-  `single<boolean> all(predicate<? super t> predicate)`-  `single<boolean> any(predicate<? super t> predicate)`-  `<u> single<u> collect(callable<? extends u> initialvaluesupplier biconsumer<? super u ? super t> collector)`-  `<u> single<u> collectinto(final u initialvalue biconsumer<? super u ? super t> collector)`-  `single<boolean> contains(final object o)`-  `single<long> count()`-  `maybe<t> elementat(long index)`-  `single<t> elementat(long index t defaultvalue)`-  `maybe<t> firstelement()`-  `single<t> first(t defaultitem)`- [x] `completable ignoreelements()`- [x] `single<boolean> isempty()`- [x] `maybe<t> lastelement()`- [x] `single<t> last(t defaultitem)`- [x] `maybe<t> reduce(bifunction<t t t> reducer)`- [x] `<r> single<r> reduce(r seed bifunction<r ? super t r> reducer)`- [x] `<r> single<r> reducewith(callable<r> seedsupplier bifunction<r ? super t r> reducer)`- [x] `maybe<t> singleelement()`- [x] `single<t> single(t defaultitem)`- [x] `single<list<t>> tolist()`- [x] `single<list<t>> tolist(final int capacityhint)`- [x] `<k> single<map<k t>> tomap(final function<? super t ? extends k> keyselector)`- [x] `<k v> single<map<k v>> tomap(final function<? super t ? extends k> keyselector final function<? super t ? extends v> valueselector)`- [x] `<k> single<map<k collection<t>>> tomultimap(function<? super t ? extends k> keyselector)`- [x] `<k v> single<map<k collection<v>>> tomultimap(function<? super t ? extends k> keyselector function<? super t ? extends v> valueselector)`- [x] `single<list<t>> tosortedlist()`- [x] `single<list<t>> tosortedlist(final comparator<? super t> comparator)`- [x] `single<list<t>> tosortedlist(final comparator<? super t> comparator int capacityhint)`- [x] `single<list<t>> tosortedlist(int capacityhint)`(these were removed from the api:)- ~~`single<list<t>> takelastbuffer(int count)`~~- ~~`single<list<t>> takelastbuffer(int count long time timeunit unit)`~~- ~~`single<list<t>> takelastbuffer(int count long time timeunit unit scheduler scheduler)`~~- ~~`single<list<t>> takelastbuffer(long time timeunit unit)`~~- ~~`single<list<t>> takelastbuffer(long time timeunit unit scheduler scheduler)`~~;""im +1 for it i also suggested that here for a few operators #4277  || i dont know looks like one needs to convert back to `flowable` all the time plus one needs to update a large amount of unit tests manually || @akarnokd why dont the operators on single return flowables? isnt singlesubscribe an implicit request one?as for the unit tests its a large task but not insurmountable || some do like `singleconcat` that have to be """"widened"""" but mostly single stays single plus single doesnt have backpressure at all so no request(1) inside it reactors `mono` (0 1 error) is a `publisher` so they have to honor backpressure for that maybe 1 element || @akarnokd yes i agree single should not have back pressure because it is  size and subscribing can be thought of as an implicit request one in other words if the subscriber doesnt have enough room in the queue for one element then dont subscribe || im a bit nervous about single not supporting backpressure we got into trouble with `observablejust(item)` not supporting backpressure in 1x see which includes references to failures || i agree with @davidmoten it was clear that a mistake was made with `just` ignoring backpressure and it feels like the same mistake is being made again plus gaining compatibility with `mono` is something which i would much appreciate || the main difference in this case is that single isnt meant to support back pressure so it wouldnt mix of behavior like there was with just || i understand i just dislike the lack of consistency between the flow control mechanisms on `flowable` and `single`/`completeable` ie for `flowable` i call `request` to control flow but i need to hold off on subscription entirely for `single`/`completeable`i do get that `observable` relates much better to `single`/`completeable` than `flowable` but i also feel that backpressure should be a default and only turned off if performance is truly a consideration - ie use `flowable` until it is known that `observable` is truly going to improve performance and transform an `observable` to `flowable` as soon as possible using one of the flow control mechanisms (afaik the only reason `observable` exists is for performance right?) || i dont see single or completable missing backpressure being a problem inthis specific case because observable itself doesnt support it either iwouldnt expect the equivalent operators for flowable to return singleon wed aug 10 2016 8:44 pm lalit maganti notifications@githubcomwrote:> i understand i just dislike the lack of consistency between the flow> control mechanisms on flowable and single/completeable ie for flowable> i call request to control flow but i need to hold off on subscription> entirely for single/completeable> > i do get that observable relates much better to single/completeable than> flowable but i also feel that backpressure should be a default and only> turned off if performance is truly a consideration - ie use flowable> until it is known that observable is truly going to improve performance> and change observable to flowable as soon as possible (afaik the only> reason observable exists is for performance right?)> > > you are receiving this because you are subscribed to this thread> reply to this email directly view it on github>  or mute the thread>   || its not necessarily a problem and i guess reworking single is unfeasible anyway this close to 2x rc just a small gripe i had :) || backpressure is there to avoid buffer bloat with unknown length streams single has only one element to get buffered and generally not a problem`observable` was introduced because some got annoyed with backpressure and want truly unbounded flows no matter the cost it has lower overhead than with backpressure but generally the late optimizations to `flowable` put them [quite close]( id get rid of all but `flowable` because it can support all the other behaviors plus i dont have to do 3x the work to keep everybody symmetric in terms of features || yeah even 1x codebase is quite hard to maintain 2x with different flowable/observable makes it even harder to work with@akarnokd you can add basic support of `single` and `consumable` in 2x (basically just make library architecture aware of them from the beginning instead of adding them post-factum as it was in 1x) non-basic operators can be added by community according to its needs as it happens/happened in 1x || the reason for `single` and `completable` being in the main library is that people expect convenient transformations to them: `flowabletosingle` `flowabletocompletable()` if these returned `singlesource` or `completablesource` those dont provide operators at all and are practically useless `tox`s need the full classesthe alternative could be to make this dependence indirect via reflection:``` javasingle<t> single  someflowableto(singleclass)public z to(class<z> target) {   return (z)targetgetmethod(""""from"""" publisherclass)invoke(null this)}```but even a cached method may be too expensive on some platformsotherwise:``` javasomeflowableto(single::from)blah()blah()somesingletoflowable() // single library depending on flowable library is okay``` || i was talking about this a bit more and noticed that `reduce(func2<r t r>)` would have to return a `maybe<t>` in the case that source `observable<t>`/`flowable<t>` was empty  i couldnt find any issues on thinking about supporting a `maybe<t>` type  im also not sure if people are willing to support yet another type in rx java || theres already an optional and try type!on wed aug 17 2016 5:44 pm george campbell notifications@githubcomwrote:> i was talking about this a bit more and noticed that reduce(func2<r t> r>) would have to return a maybe<t> in the case that source observable<t>/> flowable<t> was empty i couldnt find any issues on thinking about> supporting a maybe<t> type im also not sure if people are willing to> support yet another type in rx java> > > you are receiving this because you commented> > reply to this email directly view it on github>  or mute the thread>   || im not sure about try but isnt `javautiloptional` eager? || ah i see its a custom optional not java 8s so we could make a lazyfactory but its not a good idea to reuse it for two behaviorson wed aug 17 2016 7:09 pm george campbell notifications@githubcomwrote:> im not sure about try but isnt javautiloptional eager?> > > you are receiving this because you commented> > reply to this email directly view it on github>  or mute the thread>   || ive been going over method signatures trying to come up with a plan for all of the conversion methods:| from\to | completable | maybe | single | flow/observable || --- | --- | --- | --- | --- || completable |  | `tomaybe()` `tomaybe(t)` `tomaybe(()->t)` | `tosingle(t)` `tosingle(()->t)` | `toflow/observable()` || maybe | `tocompletable()` |  | `tosingle(t)` `tosingle(()->t)` | `toflow/observable()` || single | `tocompletable()` | `tomaybe()` |  | `toflow/observable()` || flow\observable | `tocompletable()` | `tomaybelast()` `tomaybefirst()` | `tosinglefirst(t)` `tosinglefirst(()->t)` `tosinglelast(t)` `tosinglelast(()->t)` |  |from 5 reactive types i want to drop the methods like `first` `last` `single` and `ignoreelements` since they are redundant  i would like to also take out the `blocking*` variants of the methods leaving the only the type specific blocking methods for each typethis is the core of the changes that im working on the effects of which will ripple out to all of the unit tests || please dont remove the internal operators backing the original same-type behavior || @abersnaze how is your progress on this? i held off changes to 2x but rc3 time is nearing and id like to improve performance on various elements || ive got a branch that compiles but theyre unit tests that failing for reasons ill push my branch to my fork if you want to take over > on sep 20 2016 at 03:23 david karnok notifications@githubcom wrote:> > @abersnaze how is your progress on this? i held off changes to 2x but rc3 time is nearing and id like to improve performance on various elements> > > you are receiving this because you were mentioned> reply to this email directly view it on github or mute the thread || no i think its best if i redo it step-by-step one operator at a time to rule out test anomalies and also apply optimizations || the operator last() effect 100s of tests> on sep 20 2016 at 08:03 david karnok notifications@githubcom wrote:> > no i think its best if i redo it step-by-step one operator at a time to rule out test anomalies and also apply optimizations> > > you are receiving this because you were mentioned> reply to this email directly view it on github or mute the thread || see #4570 || what should happen with- `single()` vs `tosingle()`- `ignoreelements()` vs `tocompletable()` ?should these be merged into the former or the latter of each?  || i picked single first last & ignoreelements over tosingle tomaybe & tocompletable because the former were more descriptive of what it does when there more than one value || thanks for the info || `first` `last` and `reduce` signal `nosuchelementexception` traditionally do you think we should have `maybefirst` `maybelast` and `maybereduce` to avoid the exception? || i think that if we are going to make a breaking change to the api that we should also take the opportunity to change the behavior (not throwing exceptions) || to be clear this is what can happen:`single<t> first(t defaultitem)` and `maybe<t> first()``single<t> last(t defaultitem)` and `maybe<t> last()``single<t> elementat(long index t defaultitem)` and `maybe<t> elementat(long index)` <-- not sure`single<t> single(t defaultitem)` and `maybe<t> single()` <-- looks odd || you could postfix """"element"""" onto the names which has precedence from `ignoreelements` (eg `firstelement()` `singleelement()`) this makes the return type mismatch less odd looking || closing via #4573 #4574 #4576 #4579let me know if i missed some classic operator || what about `observable<t> takefirst(predicate<t>)` in my opinion it should become:`maybe<t> takefirst(predicate<t>)``single<t> takefirstorerror(predicate<t>` || actually since all other such predicate versions were removed `takefirst` should be removed use `filter()first()` instead || you want me to remove it? || yes but only the api and please fix up the tests that used  it || what about `observabletimer()`? that one only ever emits one item || we need those to jumpstart their respective types without conversion || "";1;0;add a maybe type as a lazy optional type;"
4437;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: subject/processor improvements & small cleanup;- open up  verifypositive  as protected for validation convenience in subclasses - improve size and state handling of  deferredscalarsubscription  - enable async-fusion on  asyncsubject  and  asyncprocessor   compact the classes - **behavior change**  asyncx.hasvalue()  returns false until the terminal state has been reached - compact the classes  publishsubject    publishprocessor    behaviorsubject    behaviorprocessor    replaysubject  and  replayprocessor  - enable async-fusion on  unicastsubject   compact the class - rename  basexqueuedisposable  to  basicxqueuedisposable  to match  basicxqueuesubscription  - introduce  deferredscalardisposable   refactor  deferredscalarobserver  - adjust tests that asserted on the former parameter names - subjects and processors can now be created with newing up their constructor:  new publishsubject<>()   there is no mandatory shared state between the  observer  part and the  observable  part because both are now stateless on their own.;;0;2x: subject/processor improvements & small cleanup;- open up `verifypositive` as protected for validation convenience in subclasses- improve size and state handling of `deferredscalarsubscription`- enable async-fusion on `asyncsubject` and `asyncprocessor` compact the classes- **behavior change** `asyncxhasvalue()` returns false until the terminal state has been reached- compact the classes `publishsubject` `publishprocessor` `behaviorsubject` `behaviorprocessor` `replaysubject` and `replayprocessor`- enable async-fusion on `unicastsubject` compact the class- rename `basexqueuedisposable` to `basicxqueuedisposable` to match `basicxqueuesubscription`- introduce `deferredscalardisposable` refactor `deferredscalarobserver`- adjust tests that asserted on the former parameter names- subjects and processors can now be created with newing up their constructor: `new publishsubject<>()` there is no mandatory shared state between the `observer` part and the `observable` part because both are now stateless on their own;  4437   thanks ;;;;1;1;2x: subject/processor improvements & small cleanup;
4441;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;fix flowableonbackpressurebufferstrategy;fix buffered objects not propagated downstream in flowableonbackpressurebufferstrategy fix drop strategy logic in flowableonbackpressurebufferstrategy add unit test for flowableonbackpressurebufferstrategy  copied from flowableonbackpressurebuffertest  there is still some work needed to have a better coverage;;0;fix flowableonbackpressurebufferstrategy;fix buffered objects not propagated downstream in flowableonbackpressurebufferstrategyfix drop strategy logic in flowableonbackpressurebufferstrategyadd unit test for flowableonbackpressurebufferstrategy copied from flowableonbackpressurebuffertest there is still some work needed to have a better coverage;  4441   thanks! ;;;;1;1;fix flowableonbackpressurebufferstrategymove the call to drain out of the synchronized blockcleaned up unit tests to follow recommendations from akarnokd;
4442;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: cleanup  javadoc  completable.fromemitter;- add javadoc to  asyncemitter.backpressuremode  (#4199) - deprecate  observable.fromasync   add  observable.fromemitter  instead (#4255) - add  completable.fromemitter()  (#4356) - add missing placeholder  @since  tags - fix some generics error  rxjavahooks  - add race helper to  testutil  - fix javadoc warnings;;4199.0;1x: cleanup javadoc completablefromemitter;- add javadoc to `asyncemitterbackpressuremode` (#4199)- deprecate `observablefromasync` add `observablefromemitter` instead (#4255)- add `completablefromemitter()` (#4356)- add missing placeholder `@since` tags- fix some generics error `rxjavahooks`- add race helper to `testutil`- fix javadoc warnings;  4442   ;add documentation for asyncemitterbackpressuremode;`asyncemitterbackpressuremode` does not have documentation explaining how the different backpressure modes work maybe there could be a breadcrumb linking to `observable#onbackpressuredrop` `observable#onbackpressurebuffer` and `observable#onbackpressurelatest`?it doesnt look like theres a corresponding `observable` method for `backpressuremodeerror` so this could also be documented;a pr is welcome || see #4442 || closing via #4442 ||;1;0;1x: cleanup javadoc completablefromemitter;
4442;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: cleanup  javadoc  completable.fromemitter;- add javadoc to  asyncemitter.backpressuremode  (#4199) - deprecate  observable.fromasync   add  observable.fromemitter  instead (#4255) - add  completable.fromemitter()  (#4356) - add missing placeholder  @since  tags - fix some generics error  rxjavahooks  - add race helper to  testutil  - fix javadoc warnings;;4255.0;1x: cleanup javadoc completablefromemitter;- add javadoc to `asyncemitterbackpressuremode` (#4199)- deprecate `observablefromasync` add `observablefromemitter` instead (#4255)- add `completablefromemitter()` (#4356)- add missing placeholder `@since` tags- fix some generics error `rxjavahooks`- add race helper to `testutil`- fix javadoc warnings;  4442   ;1x: rename observablefromasync();`fromasync()` sounds like its ok to emit from multiple threads in parallel while in fact it doesnt serialize emissioncan we rename it? for example to `observablefromcallback()` which also seems more obvious to use when you convert callback-styled code to `observable`;the suggested name is too close to `fromcallable` besides the javadoc of `asyncemitter` warns about sequential use:``` java/** * abstraction over a rxjava subscriber that allows associating * a resource with it and exposes the current number of downstream * requested amount * <p> * the onnext onerror and oncompleted methods should be called  * in a sequential manner just like the observers methods the * other methods are threadsafe * * @param <t> the value type to emit */``` || > the suggested name is too close to fromcallableyoure worried about dynamic languages like groovy? theyre not _that_ bad!> besides the javadoc of asyncemitter warns about sequential usewell to me it looks ~like `void threadsafe()` which has note in javadoc that its not thread safe   || they sound to similar and may lead to speaker embarrassment when mixed up not to mention users getting confused and content assist/intellisense bringing up both of them when typing `fromcall` || i dont think something being asynchronous immediately implies that its also concurrent || true but not a lot of people understand thatonly because of `asynctask` a lot of android devs think that async  bgthreadanother point is that `fromasync()` is probably not what developer wouldlook into when he/she will need to convert callback-styled api to rx`fromcallback()` looks more user-friendly (in my opinion of course)on fri aug 5 2016 at 5:54 pm jake wharton notifications@githubcomwrote:> i dont think something being asynchronous immediately implies that its> also concurrent> > > you are receiving this because you authored the thread> reply to this email directly view it on github>  or mute the thread>   || using an `asynctask` inside `fromasync` would be perfectly fine since its not concurrent`fromcallback` is clearly not usable for the reasons previously stated im not against a rename but im having a hard time coming up with a better name than what we already have || i would almost rename _both_ `fromcallable` and `fromasync` to just overloads of `from` we already have a few overloads of `from` for adapting various sources so i dont see why these are treated any differently than just more sourcesadditionally the naming conventions of `fromcallable` and `fromasync` disagree with each other and other rxjava conventionsthe first one `fromcallable` describes the mechanism (`callable`) of what its adapting we dont see `fromiterable` or `fromfuture` so why `fromcallable`?`fromasync` on the other hand describes the behavior that it is adapting (a callback-based source) again we dont have `fromsynchronous` or `justsynchronous` so why `fromasync`? additionally `fromasync` is perfectly usable for non-asynchronous sources its merely adapting a callback-based system (the foundation of artems argument) but theres no reason it has to be asynchronous it might be just be abstracting over a visitor-based apii would prefer both of these be renamed to `from` because thats how you adapt an external implementation of a data source into an `observable` it doesnt matter if its an `iterable` `future` `callable` or a callback-based source i would also rename `asyncemitter` to just `emitter` with this change || humorously enough rxjava 2 actually does postfix `from` with the source (eg `fromarray` `fromiterable` etc) i stand by my argument that both of these should be just `from()` in rxjava 1x and we can bikeshed the name for 2x in a separate issue || > i would almost rename both fromcallable and fromasync to just overloads of from i dont recommend it java 8 compiler gets sometimes quite confused for example:```from(() -> 1)from(() -> new iterator() { })```in this case `from()` could mean any of the pre operators and youll end up casting a lot to make it right - postfix is shorter || great point in that case i still think `fromasync` is the wrong name based solely on the fact that its a potentially-inaccurate description of whats being adapted but im not sold on the need to change it for 1x || could be `fromemitter` || `fromemitter` sounds better than `fromasync` to me  see #4442 || closing via #4442 ||;1;0;1x: cleanup javadoc completablefromemitter;
"4442;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: cleanup  javadoc  completable.fromemitter;- add javadoc to  asyncemitter.backpressuremode  (#4199) - deprecate  observable.fromasync   add  observable.fromemitter  instead (#4255) - add  completable.fromemitter()  (#4356) - add missing placeholder  @since  tags - fix some generics error  rxjavahooks  - add race helper to  testutil  - fix javadoc warnings;;4356.0;1x: cleanup javadoc completablefromemitter;- add javadoc to `asyncemitterbackpressuremode` (#4199)- deprecate `observablefromasync` add `observablefromemitter` instead (#4255)- add `completablefromemitter()` (#4356)- add missing placeholder `@since` tags- fix some generics error `rxjavahooks`- add race helper to `testutil`- fix javadoc warnings;  4442   ;setcancellation for single and completable;""we can use `setcancellation` for the `asyncemitter` that we have inside `observablefromasync` method its very useful because we are able to release something in the case when the subscription was terminated for example: ``` javaobservablefromasync(emitter -> {    someprotocolclient client  new someprotocolclient(geturi())    callback callback  new callback() {        @override        public void onload(response response) {            model model  parse(response)            emitteronnext(model)            emitteroncompleted()        }        @override        public void onerror() {            emitteronerror(new apiexception(""""no response""""))        }    }    request request  clientget(callback)    emittersetcancellation(request::cancel) // release some resources its useful to have setcalcellation} asyncemitterbackpressuremodebuffer)```wouldnt it be nice to have something like that for the `single` and `completable`? "";sounds good || there is already such api:``` javasinglecreate(subscriber -> {  subscriberadd(subscriptionscreate(request::cancel))})```same for `consumable`  not sure if we should add `fromasync` to `completable` and `single` in 1x since in 2x itll be `create()` || a small drawback with the `singlesubscriberadd` approach is that you need try-catch if `request::cancel` throws checked exceptioncompletable doesnt support such resource management so youd need to manually use `multipleassignmentsubscription` or other containers before calling `onsubscribe`besides we will (have to) provide a safe `create` in 2x with similar api for all base reactive types || // damn why we didnt do it for `completable`?!ok  for adding `fromasync` to both `completable` and `single` in 1x i can work on that if you dont mind || go ahead ill do 2x anyway within a few days || why not just call `tosingle()` or `tocompletable()` on the `observablefromasync`? || to indicate on the api level that you should call exactly one of `onsuccess(t)` `onerror()` or `oncompleted()` methods || i dont see how thats possible `singleonsubscribe` doesnt prevent me from calling methods on the `singlesubscriber` multiple times || by having `singleemitter` and `completableemitter` as input to you:``` javapublic static <t> single<t> fromasync(action1<singleemitter<t>> emitter)singlefromasync(e -> {   esetcancellable(() -> { })   eonsuccess(null)   eonsuccess(null) // will be dropped})```> singleonsubscribe doesnt prevent me from calling methods on the singlesubscriber multiple timeslike all `create` operators there are no safeguards with the raw access extending `fromasync` (`create` in 2x) to the other base reactive types give the necessary safeguards || that should throw an exception not be silently ignored youve violated the contract of the type || see #4442 should there be one for single? || agree its confusing that there is observablefromemitter completablefromemitter but not singlefromemitter || see #4851 || closing via #4851 & #4442 ||;1;0;1x: cleanup javadoc completablefromemitter;"
4447;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix withlatestfrom s tparam;;;0;fix withlatestfroms tparam;;  4447  ;;;;1;1;fix withlatestfroms tparam;
4450;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fixes  cleanup  coverage 8/31-1;- improve coverage of internal classes - turn more empty enums into classes with private constructors - fix  single.subscribeon  and  completable.subscribeon  disposable management. - create a compact  futuresubscriber  and  futureobserver  classes  drop their former enums - deprecate  disposables.from  methods  add  disposables.fromx  methods where x = argument type - fix error management in  completable.mergex  operators. - remove unused methods from internal classes;;0;2x: fixes cleanup coverage 8/31-1;- improve coverage of internal classes- turn more empty enums into classes with private constructors- fix `singlesubscribeon` and `completablesubscribeon` disposable management- create a compact `futuresubscriber` and `futureobserver` classes drop their former enums- deprecate `disposablesfrom` methods add `disposablesfromx` methods where x  argument type- fix error management in `completablemergex` operators- remove unused methods from internal classes;  4450   ;;;;1;1;2x: fixes cleanup coverage 8/31-1;
4452;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;enhance generics on onerrorresumenext and onerrorreturn;func1<throwable >  parameter should be  func1<? super throwable  ...>;;0;enhance generics on onerrorresumenext and onerrorreturn;`func1<throwable>` parameter should be `func1<? super throwable >`;  4452  ;;;;1;1;enhance generics on observableonerrorresumenext and onerrorreturn;
4453;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;wrap interruptedexception with an unchecked exception in testsubscriber#awaitvaluecount().;in its current form   awaitvaluecount()  is the only  testsubscriber#await* method that throws a checked exception (that is   interruptedexception )  whereas the others wrap it with a  illegalstateexception . this spreads a try-catch disease throughout the entire code base where  awaitvaluecount()  is used. one can argue that why not just declaring the exception in the caller method footprint: because you might be implementing an interface (e.g.  runnable ) which does not allow any exceptions in its footprint. this patch wraps the  interruptedexception  with an unchecked exception in  testsubscriber#awaitvaluecount() .;;0;wrap interruptedexception with an unchecked exception in testsubscriber#awaitvaluecount();in its current form `awaitvaluecount()` is the only `testsubscriber#await*`method that throws a checked exception (that is `interruptedexception`) whereas the others wrap it with a `illegalstateexception` this spreads a try-catch disease throughout the entire code base where `awaitvaluecount()` is used one can argue that why not just declaring the exception in the caller method footprint: because you might be implementing an interface (eg `runnable`) which does not allow any exceptions in its footprint this patch wraps the `interruptedexception` with an unchecked exception in `testsubscriber#awaitvaluecount()`;  4453   ;;;;1;1;throw unchecked exception in testsubscriber#awaitvaluecount();
4454;1;0;0;1;0;1;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: start reimplementing maybe with up-to-date javadoc  tests and algo;this pr reimplements the  maybe  with more up-to-date algorithms (the original was a copy-paste of some older single and completable code it seems) and adds javadoc and tests along the way. not all operators have been rewritten yet (and no placeholders). early adopters should refer to the  tox  methods on the base reactive types. the pr also adds the  rxjavaplugins  hooks to support  maybe .  in addition  i ve fixed javadoc mistakes in the other base reactive types (referring to the wrong types).;;0;2x: start reimplementing maybe with up-to-date javadoc tests and algo;this pr reimplements the `maybe` with more up-to-date algorithms (the original was a copy-paste of some older single and completable code it seems) and adds javadoc and tests along the way not all operators have been rewritten yet (and no placeholders) early adopters should refer to the `tox` methods on the base reactive types the pr also adds the `rxjavaplugins` hooks to support `maybe`in addition ive  javadoc mistakes in the other base reactive types (referring to the wrong types);  4454    thanks @jakewharton ! ||;;;;1;1;2x: start reimplementing maybe with up-to-date javadoc tests and algo;
4458;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: rename observable and single #dooncancel to #doondispose;#4456  completable already used .doondispose() however i renamed the arguments to match observable and single;;4456.0;2x: rename observable and single #dooncancel to #doondispose;#4456completable already used doondispose() however i renamed the arguments to match observable and single;the diff for observable doesnt show but the offline-comparison only lists 30-40 lines changes did you run some whitespace cleanup? || @akarnokd whoops youre right sorry auto formatter seems to have changed some whitespaces ill revert that ||   4458    this update is missing in release notes on github please remember to mention such changes in the future ||;2x: naming of dooncancel();as i understand it the `dooncancel()` operator is basically the replacement of `doonunsubscribe()` in the 1x worldin that case: just from a naming perspective wouldnt it be clearer to name it `doondispose()` ?;`flowable` -> `dooncancel()` because of `subscriptioncancel()` the other can be called `doondispose()` want to submit a pr? || ah i was not looking much at flowable yet thats why i missed that part thanks for explaining!ill get started on the pr ||;1;0;aligns javadoc;
"4460;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: completable add dooneach;first part of #4457   is it okay that i reused notification like that?  also are there any java 6 generics missing? it would be nice if this project was set up to target java sdk 6  as my default seems to be java 8 and i don t get any errors shown in the ide.;;4457.0;1x: completable add dooneach;first part of #4457 is it okay that i reused notification like that?also are there any java 6 generics missing? it would be nice if this project was set up to target java sdk 6 as my default seems to be java 8 and i dont get any errors shown in the ide;okay but you have [generics problem]( || alright its  now ||   4460  **< ;1x: single and completable are missing dooneach;both are missing that method is this one wanted?;""single is either success or error and completable is either complete or error and both types have doon- methods for those events || yes im aware of that however id like something like a `dooneach` also in observable `dooneach` includes terminal eventsif you want to execute some code regardless of whether it was successful or an error was thrown youd need to call that method  in `onsuccess` and `onerror` where as with a `dooneach` youd call it once insteadagain just a proposal if this is not wanted at all im also happy to live without it || oh i misread as next not each go for it || alright will do in the next few hours || how about 2x in this case? both `single` and `completable` are also """"missing"""" `dooneach` there will the changes automatically be merged from 1x to 2x? || for 2x id imagine `completabledoonevent(consumer<? super throwable> onevent)` and `singledoonevent(biconsumer<? super t ? super throwable>)` where if the `throwable` is null it means the other event happened there is a similar  api in `completablefuturewhencomplete(biconsumer)` or something || what about the maybe type? that one would need one too right? || im currently expanding maybe so ill add one || "";1;0;fix generics;"
"4461;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: single add dooneach;really not that happy with  onnotification.call(notification.<t>createonnext(t))   do you guys have any other way of doing this? there s no way of creating a notification that has the  oncompleted  plus a value. a new one could be introduced there though. also the  dooneachsuccess  test feels clunky.  also why does single when using the  do  methods does the job by using an observable? and later converting it back to a single again. is it due to the way single was implemented in 1.x? with completable there is no converting of back and forth needed.  javadoc will follow once we sorted out the few nits here.  4457;;4457.0;1x: single add dooneach;really not that happy with `onnotificationcall(notification<t>createonnext(t))` do you guys have any other way of doing this? theres no way of creating a notification that has the `oncompleted` plus a value a new one could be introduced there though also the `dooneachsuccess` test feels clunkyalso why does single when using the `do` methods does the job by using an observable? and later converting it back to a single again is it due to the way single was implemented in 1x? with completable there is no converting of back and forth neededjavadoc will follow once we sorted out the few nits here4457;  4461 fails although im not quite sure what the purpose of that test is also it seems a bit off to me can you give some insights there? || looks like removing the toobservabletosingle no longer wraps the subscriber into a safesubscriber and the test just crashes with a different exception || no exception is being thrown at all || can you single step the test? in the orginal dooneach it has throwiffatal an throworreport you missed btw || ;1x: single and completable are missing dooneach;both are missing that method is this one wanted?;""single is either success or error and completable is either complete or error and both types have doon- methods for those events || yes im aware of that however id like something like a `dooneach` also in observable `dooneach` includes terminal eventsif you want to execute some code regardless of whether it was successful or an error was thrown youd need to call that method  in `onsuccess` and `onerror` where as with a `dooneach` youd call it once insteadagain just a proposal if this is not wanted at all im also happy to live without it || oh i misread as next not each go for it || alright will do in the next few hours || how about 2x in this case? both `single` and `completable` are also """"missing"""" `dooneach` there will the changes automatically be merged from 1x to 2x? || for 2x id imagine `completabledoonevent(consumer<? super throwable> onevent)` and `singledoonevent(biconsumer<? super t ? super throwable>)` where if the `throwable` is null it means the other event happened there is a similar  api in `completablefuturewhencomplete(biconsumer)` or something || what about the maybe type? that one would need one too right? || im currently expanding maybe so ill add one || "";1;0;add javadoc;"
4466;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: deprecate notification.createoncompleted;4462   it might just as well shine some light into which method should be used and explain why there are 2;;4462.0;1x: deprecate notificationcreateoncompleted;4462 it might just as well shine some light into which method should be used and explain why there are 2;  4466  ;1x: unused notificationcreateoncompleted(class<t> type);while reading the notification class due to #4457 i noticed [`notificationcreateoncompleted(class<t> type)`]( which seems to be only used in one [test]( and that test does not really add any value so im wondering since this is in the public api and not used can be it removed or do you see any value in having this method around?;you could deprecate it but since the 1x series cant remove methods that are non-beta and non-experimental it doesnt make much difference ||;1;0;1x: deprecate notificationcreateoncompleted;
4467;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add more maybe operators  fix a few javadoc mistakes;- move  verifypositive  into  objecthelper  - fix javadoc of  flowable.subscribe()  and  observable.subscribe()  mentioning  subscription  from 1.x -  maybe : add  amb    concat    concatarray    merge    mergearray    concatmap    subscribe    subscribewith    doonevent;;0;2x: add more maybe operators fix a few javadoc mistakes;- move `verifypositive` into `objecthelper`- fix javadoc of `flowablesubscribe()` and `observablesubscribe()` mentioning `subscription` from 1x- `maybe`: add `amb` `concat` `concatarray` `merge` `mergearray` `concatmap` `subscribe` `subscribewith` `doonevent`;  4467   ;;;;1;1;2x: add more maybe operators fix a few javadoc mistakes;
4468;1;0;0;0;0;1;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: coverage  bugfixes  9/03-1;- fixed bugs in  flowable.sequenceequal    flowable.zip  when errors are delayed   flowable.onbackpressurebuffer  when errors are delayed - fixed mentions of  nbpx  in some places - synchronized unit tests between  observable  and  flowable;;0;2x: coverage bugfixes 9/03-1;-  bugs in `flowablesequenceequal` `flowablezip` when errors are delayed `flowableonbackpressurebuffer` when errors are delayed- fixed mentions of `nbpx` in some places- synchronized unit tests between `observable` and `flowable`;   4468  ;;;;1;1;2x: coverage bugfixes 9/03-1;
4469;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: coverage and fixes 9/03-2;- enable fusion with  observable.map  - remove impossible branches in some classes - add more tests to cover tool classes - fix  observable.range()  entering regular emission if fusion-drain is interrupted - fix  fullarbiter  and  observablefullarbiter  not cancelling/disposing the incoming subscription/disposable in some cases;;0;2x: coverage and fixes 9/03-2;- enable fusion with `observablemap`- remove impossible branches in some classes- add more tests to cover tool classes- fix `observablerange()` entering regular emission if fusion-drain is interrupted- fix `fullarbiter` and `observablefullarbiter` not cancelling/disposing the incoming subscription/disposable in some cases;  4469   ;;;;1;1;2x: coverage and fixes 9/03-2;
4478;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix typo javadocs testobserver;;;0;fix typo javadocs testobserver;;  4478   ;;;;1;1;replace all occurrences testsubscriber  by testobserver in testobserver class;
4479;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add doonevent to single & completable;;;0;2x: add doonevent to single & completable;;  4479  ;;;;1;1;2x: add doonevent to single & completable;
"4484;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: flowable.reduce() to return single  macro fusion;this pr adds the baseline for changing  flowable  and  observable  operators to return  single    completable  or  maybe  but in case the user wants to go back to the original type via  toflowable  or  toobservable  we switch to a natively  flowable / observable  operator (macro-fusion).  benchmark comparison (i7 4790  windows 7 x64  java 8u102):  (  no changes were applied to  observable  yet hence the roughly same result there.  flowable.reduce()  has been updated plus there is a new  flowablereduce  instead of  scan().last() .;;0;2x: flowablereduce() to return single macro fusion;this pr adds the baseline for changing `flowable` and `observable` operators to return `single` `completable` or `maybe` but in case the user wants to go back to the original type via `toflowable` or `toobservable` we switch to a natively `flowable`/`observable` operator (macro-fusion)benchmark comparison (i7 4790 windows 7 x64 java 8u102):( changes were applied to `observable` yet hence the roughly same result there `flowablereduce()` has been updated plus there is a new `flowablereduce` instead of `scan()last()`;  4484   ;;;;1;1;""fix """"a observable""""s"";"
4486;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: completable enhance doonevent to reduce allocations;;;0;2x: completable enhance doonevent to reduce allocations;;  4486  **< ;;;;1;1;2x: completable enhance doonevent to reduce allocations;
4488;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add new methods to maybe  observable and single from 4481;this pr adds just the new methods from #4481 to allow a much cleaner change of return types later on.;;4481.0;2x: add new methods to maybe observable and single from 4481;this pr adds just the new methods from #4481 to allow a much cleaner change of return types later on;   4488   updated with corrections ||;integrate maybe and single into observable *** do not merge;ive been working on the this for too long in the background and want to get this out for review even though many of the units tests dont pass yet its a bit rough at the moment but there was a couple of things that i wanted to talk about1 does it make sense to have ignoreelements where there is a tocompletable2 the same goes for single when there is a tosingle3 moved tofuture to single since it seems to fit better;dont delete the old ops because we can macro fuse them back in such cases: `sourcereduce()toflowable()` || ill post a pr that incorporates some helper types and demoes what i mean by macro-fusion for these flowable->x and observable->x conversions || @abersnaze your commit somehow has me as its author || @mauin yeah its odd@abersnaze see #4484 about how we could do this while keeping the performance when converting back to the `flowable`/`observable`also it would be great if you didnt mix plain addition to `maybe` with the other changes in one pr || @mauin something wires must have got crossed my last rebate ill try and fix it before its merged@akarnokd would you like the additions as preliminary pr before this one? || yes that would be great || let me take out the maybe additions into a separate pr || > does it make sense to have ignoreelements where there is a tocompletable> the same goes for single when there is a tosinglereactors `flux` does return `mono<void>` for `ignoreelements` (last time i checked) and their community liked it i think `ignoreelements` is more intuitive for naming the function the question is how the return type change will disrupt the developers flow and how many time does he/she apply `toflowable()` (which we dutifully try to optimize) to get back to the `flowable`/`observable` world:``` javaflowablerange(1 10)flatmap(v -> savetodb(restcall(v))ignoreelements()toflowable())blockinglast(0)```to avoid this burden we have to provide `flatmapcompletable(t -> completable)` etc in the `flowable`/`observable` as well or for basically any xmap(function) operator there is (`concatmap` `concatmapdelayerror` `flatmap` `switchmap`) || closing as out of date and will be redone in subsequent prs ||;1;0;fix javadoc mistakes;
4490;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: rename emitters #iscancelled to #isdisposed;renames observable/single/completableemitter#iscancelled to #isdisposed.  this now causes a bit of a weird situation where most (not all) emitter classes implement  disposable  as well  so both interfaces expose the same  #isdisposed  method. before the  #iscancelled  methods were basically just calling  #isdisposed  or had the same implementation.   suggestions on how to improve this?;;0;2x: rename emitters #iscancelled to #isdisposed;renames observable/single/completableemitter#iscancelled to #isdisposedthis now causes a bit of a weird situation where most (not all) emitter classes implement `disposable` as well so both interfaces expose the same `#isdisposed` method before the `#iscancelled` methods were basically just calling `#isdisposed` or had the same implementation suggestions on how to improve this?;  4490   im tempted to remove `setdisposable` from the emitter and keep this method named `iscanceled()` if you want to set a disposable why not use `unsafecreate` and `observablesource` directly? || @jakewharton these are the safe versions that also manages a resource for you without the need to worry about (and lose) backpressure or cancellation in general from `unsafecreate` || otherwise  im not sure how that is an argument against what i said having both `setcancelable` and `setdisposable` in the api is ugly and redundant || if you believe users dont really need the disposable overload then im open to remove them also consider dropping disposablesfrom variants not in use and adding cancellablesfrom || as for `setcancelable` and `setdisposable` i agree with @jakewharton would probably be best to somehow merge them or get rid of one to clean the api but that would be a separate issue/pr i guess? || yes lets have a separate pr for that ||;;;;1;1;rename emitters #iscancelled to #isdisposed;
4491;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: reduce blockingx overhead  move internal observers to common pkg;this pr compacts the  blockingx  operators by extending  countdownlatch  and implementing  singleobserver    completableobserver  and  maybeobserver  with the necessary blocking await mechanics.  benchmark comparison (i7 4770  windows 7 x64  java 8u102):  (  in addition  the internal package  subscribers.single  and  subscribers.completable  has been removed and the classes moved into  io.reactivex.internal.observers  package. the old blocking enum helpers were removed as well.  the  blockingsinglesubscriber  and  blockingsingleobserver  abstract classes have been renamed to  blockingbasex  to avoid name confusion (they have nothing to do with the  single  type).;;0;2x: reduce blockingx overhead move internal observers to common pkg;this pr compacts the `blockingx` operators by extending `countdownlatch` and implementing `singleobserver` `completableobserver` and `maybeobserver` with the necessary blocking await mechanicsbenchmark comparison (i7 4770 windows 7 x64 java 8u102):( addition the internal package `subscriberssingle` and `subscriberscompletable` has been removed and the classes moved into `ioreactivexinternalobservers` package the old blocking enum helpers were removed as wellthe `blockingsinglesubscriber` and `blockingsingleobserver` abstract classes have been renamed to `blockingbasex` to avoid name confusion (they have nothing to do with the `single` type);  4491   ;;;;1;1;2x: reduce blockingx overhead move internal observers to common pkg;
4493;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: more maybe operators  minor cleanups 9/07-1;- minor javadoc corrections - note: some maybe operators shifted within the file - add to  maybe :  concatarraydelayerror    concatarrayeager    concateager    concatdelayerror    mergearraydelayerror    mergedelayerror    sequenceequal    timer    using    zip    ziparray  - improve coverage of  observable    single  and  maybe . - move tests from  observabletests  into  observabletest  drop the former.;;0;2x: more maybe operators minor cleanups 9/07-1;- minor javadoc corrections- note: some maybe operators shifted within the file- add to `maybe`: `concatarraydelayerror` `concatarrayeager` `concateager` `concatdelayerror` `mergearraydelayerror` `mergedelayerror` `sequenceequal` `timer` `using` `zip` `ziparray`- improve coverage of `observable` `single` and `maybe`- move tests from `observabletests` into `observabletest` drop the former;  4493   ;;;;1;1;2x: more maybe operators minor cleanups 9/07-1;
"4496;1;0;0;0;0;1;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: remove trailing whitespace;removed them like this:   find . -type f -name  *.java  | xargs sed -i    -e s/[ \t]*$//   $1    i think it s best to review this locally or by appending  ?w=1  to this url to let github ignore white space changes.;;0;2x: remove trailing whitespace;""removed them like this:`find  -type f -name """"*java"""" | xargs sed -i  -es/[ \t]*$// """"$1""""`i think its best to review this locally or by appending `?w1` to this url to let github ignore white space changes"";  4496  ;;;;1;1;2x: remove trailing whitespace;"
4500;1;0;0;0;0;1;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: remove trailing whitespace;dunno whether this is wanted or not in 1.x. if not just close this pr.;;0;1x: remove trailing whitespace;dunno whether this is wanted or not in 1x if not just close this pr;i havent seen ides adding them back but only remove them so lets have this to avoid future unneccessary removals from unrelated changes in files || alright sounds good and then #4123 can be closed ||   4500  ;;;;1;1;1x: remove trailing whitespace;
4502;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: replace  finallydo  references with  doafterterminate;this should be less confusing.;;0;2x: replace `finallydo` references with `doafterterminate`;this should be less confusing;great thanks!  the test failure looks unrelated || no problem ive rerun the check ||;;;;1;1;replace `finallydo` references with `doafterterminate`;
4503;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add system properties to adjust thread priorities of schedulers;this pr adds the ability to specify the default thread priorities of  computation()    io()    newthread()  and  single()  schedulers via system properties. i ve added the property names to the  schedulers  javadoc.  related: #4389.;;4389.0;2x: add system properties to adjust thread priorities of schedulers;this pr adds the ability to specify the default thread priorities of `computation()` `io()` `newthread()` and `single()` schedulers via system properties ive added the property names to the `schedulers` javadocrelated: #4389;  4503   thanks! ;2x: ability/api to set thread priority of shared schedulers;in 1x i implemented this with factory methods that accept user-supplied `threadfactory` instances we could mimic this in 2x or we could add per-scheduler properties for the thread priority a nice advantage of the property-based approach is that we can do platform detection and automatically lower the default when running on android (which was the initial motivation for the feature);pr welcome || see #4503 || closing via #4503 ||;1;0;2x: add system properties to adjust thread priorities of schedulers;
4504;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add disposable observer for maybe  completable & single;also any reason the dispoable is called  s ? is it still from the subscription time?  4501;;4501.0;2x: add disposable observer for maybe completable & single;also any reason the dispoable is called `s`? is it still from the subscription time?4501;seems unrelated:```ioreactivexinternaloperatorsobservableobservablerefcounttest > testrepeat failed    javalangassertionerror: error(s) present: [javalangillegalstateexception: onsubscribe not called in proper order] (latch  1 values  51 errors  1 completions  0)        at ioreactivexobserverstestobserverfail(testobserverjava:363)        at ioreactivexobserverstestobserverassertnoerrors(testobserverjava:411)        at ioreactivexinternaloperatorsobservableobservablerefcounttesttestrepeat(observablerefcounttestjava:195)        caused by:        ioreactivexexceptionscompositeexception            at ioreactivexobserverstestobserverfail(testobserverjava:364)             2 more            caused by:            ioreactivexexceptionscompositeexception$compositeexceptioncausalchain: chain of causes for compositeexception in order received >                caused by:                javalangillegalstateexception: onsubscribe not called in proper order``` || yep ill fix that next - started to become annoying to me too ||;2x: matching disposableobserver class for single;how do you feel about adding a matching class for `disposableobserver` with single support?instead of `observer` itll implement `singleobserver`;sounds good please add one for completable and maybe while you are at it || will do  closing via #4504  ||;1;0;2x: add disposable observer for maybe completable & single;
4506;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix operator refcount  disable findbugs (due to travis oom);this pr fixes the operators  refcount  (ensure proper call order to onxxx)  disables findbugs due to out-of-memory kills on travis and increases the half-time sleep of a flaky unit-test.;;0;2x: fix operator refcount disable findbugs (due to travis oom);this pr fixes the operators `refcount` (ensure proper call order to onxxx) disables findbugs due to out-of-memory kills on travis and increases the half-time sleep of a flaky unit-test; ;;;;1;1;2x: fix operator refcount disable findbugs (due to travis oom);
4507;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add reactive-streams tck infrastructure and couple of tests;this pr sets up the build to run testng tests as well and adds the reactive-streams tck to allow validating our operators.  included tests are:  just    fromarray    fromiterable    concat    merge .  note that the tck tests for invalid  request()  amount which  according to the spec  should be reported to the running  subscriber  via  onerror . unfortunately  this is a very expensive requirement (requiring half-serialization all the time) and we are not going to support it in rxjava 2. negative requests are bugs in operators and should be fixed  we only provide a notification about such situations in the  rxjavaplugins.onerror  for those who want to check for such errors.   therefore  the  flowabletck  has been added with does the required behavior by the tck and can be used as  flowabletck.wrap(flowable)  when returning from the tck s  createpublisher(long) .;;0;2x: add reactive-streams tck infrastructure and couple of tests;this pr sets up the build to run testng tests as well and adds the reactive-streams tck to allow validating our operatorsincluded tests are: `just` `fromarray` `fromiterable` `concat` `merge`note that the tck tests for invalid `request()` amount which according to the spec should be reported to the running `subscriber` via `onerror` unfortunately this is a very expensive requirement (requiring half-serialization all the time) and we are not going to support it in rxjava 2 negative requests are bugs in operators and should be  we only provide a notification about such situations in the `rxjavapluginsonerror` for those who want to check for such errors therefore the `flowabletck` has been added with does the required behavior by the tck and can be used as `flowabletckwrap(flowable)` when returning from the tcks `createpublisher(long)`;  4507  ;;;;1;1;2x: add reactive-streams tck infrastructure and couple of tests;
4508;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add exception message in singlefromcallable;;;0;2x: add exception message in singlefromcallable;;@akarnokd what do you think about a custom exception that explains why null is not allowed anymore? and if someone goes and wants to emit null that one will be thrown instead of nullpointerexception || you mean like`the callable returned a null value null values are generally not allowed in 2x operators and sources`if you manually change all locations then okay but dont try to factor this out into some parametric method because that extra amount of conditional code might prevent some jit optimizations due to dept/code size increase ||   4508  ;;;;1;1;2x: add exception message in singlefromcallable;
4509;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: adjust some javadoc in emitters;;;0;2x: adjust some javadoc in emitters;; ;;;;1;1;fix a/an;
"4513;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix switchmap bad cancellation;both  switchmap  implementations didn t properly cancel the current inner consumer (but instead cancelled the outer  connection  only).  reported in #4512.;;4512.0;2x: fix switchmap bad cancellation;both `switchmap` implementations didnt properly cancel the current inner consumer (but instead cancelled the outer connection only)reported in #4512;   4513  **< ;[rxjava 200-rc2] observableswitchmap doesnt unsubscribe from inner observable; javapublic class switchmapbug {  public static void main(string args) throws exception {    final disposable disposable  observablejust(true)        subscribeon(schedulersio())        switchmap(value -> observabletimer(1000 timeunitmilliseconds)            compose(new tracecomposer<>(""""inner""""))        )        compose(new tracecomposer<>(""""outer""""))        subscribe()    threadsleep(500)    disposabledispose()    threadsleep(2000)  }  private static class tracecomposer<t> implements function<observable<t> observable<t>> {    private final string prefix    private tracecomposer(final string prefix) {      thisprefix  prefix    }    @override    public observable<t> apply(observable<t> observable) throws exception {      return observable          doonsubscribe(disposable -> systemoutprintln(""""["""" + prefix + """"]"""" + """" """" + """"doonsubscribe""""))          doondispose(() -> systemoutprintln(""""["""" + prefix + """"]"""" + """" """" + """"doondispose""""))          doonnext(value -> systemoutprintln(""""["""" + prefix + """"]"""" + """" """" + """"doonnext"""" + """" """" + value))          doonerror(error -> systemoutprintln(""""["""" + prefix + """"]"""" + """" """" + """"doonerror"""" + """" """" + error))          dooncomplete(() -> systemoutprintln(""""["""" + prefix + """"]"""" + """" """" + """"dooncomplete""""))          doonterminate(() -> systemoutprintln(""""["""" + prefix + """"]"""" + """" """" + """"doonterminate""""))          doafterterminate(() -> systemoutprintln(""""["""" + prefix + """"]"""" + """" """" + """"doafterterminate""""))    }  }}```output:```[outer] doonsubscribe[inner] doonsubscribe[outer] doondispose[inner] doonnext 0[inner] dooncomplete[inner] doonterminate[inner] doafterterminate```expected output:```[outer] doonsubscribe[inner] doonsubscribe[inner] doondispose[outer] doondispose```"";looks like `acancel()` is missed here: || thanks for the feedback indeed that line should be `acancel()` ill post a fix soon || closing via #4513 ||;1;0;2x: fix switchmap bad cancellation;"
"4516;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix single.using  add unit tests and coverage;i ve forgotten to create a branch so the first part of todays coverage work [landed in 2.x direct]( - removed unused methods from various classes - compacted  spscarrayqueue  - added null checks to  spsclinkedarrayqueue.offer()  and  mpsclinkedqueue.offer()  - fixed  resourceobserver  not calling  onstart  - added direct notificationlite-emission methods to  appendonlylinkedarraylist   updated  serializedobserver  and  serializedsubscriber  to use it directly instead of the former indirection -  testobserver.isdisposed  now reports true if terminal events were received (#4514) -  resourcesubscriber  to use  subscriptionhelper  s deferred subscription/requesting management - added unit tests to cover  disposablexobserver s -  serializedobserver  and  serializedsubscriber  now have proper unit tests each  this current pr fixes  single.using  not properly managing the resource and adds unit tests to verify the behavior along with a few extra coverage improvements.;;4514.0;2x: fix singleusing add unit tests and coverage;ive forgotten to create a branch so the first part of todays coverage work [landed in 2x direct]( removed unused methods from various classes- compacted `spscarrayqueue`- added null checks to `spsclinkedarrayqueueoffer()` and `mpsclinkedqueueoffer()`-  `resourceobserver` not calling `onstart`- added direct notificationlite-emission methods to `appendonlylinkedarraylist` updated `serializedobserver` and `serializedsubscriber` to use it directly instead of the former indirection- `testobserverisdisposed` now reports true if terminal events were received (#4514)- `resourcesubscriber` to use `subscriptionhelper`s deferred subscription/requesting management- added unit tests to cover `disposablexobserver`s- `serializedobserver` and `serializedsubscriber` now have proper unit tests eachthis current pr fixes `singleusing` not properly managing the resource and adds unit tests to verify the behavior along with a few extra coverage improvements;   4516  ;2x should observer be disposed after the source observable has finished emitting items?;""with 1x this test pass:``` java@test  public void subscribershouldbeunsubscribed() {    rxobserverstestsubscriber subscriber  new rxobserverstestsubscriber()    rxobservablejust("""""""")subscribe(subscriber)    subscriberawaitterminalevent()    subscriberassertnoerrors()    subscriberassertcompleted()    subscriberassertunsubscribed()  }```but with 2x this test does not pass:``` java  @test  public void observershouldbedisposed()  {    testobserver observer  new testobserver()    observablejust("""""""")subscribe(observer)    observerawaitterminalevent()    observerassertnoerrors()    observerassertcomplete()    assertthat(observerisdisposed() is(true))  }```i think that dispose is similar to unsubscribe (but maybe im wrong) so i was wondering if this is the expected behaviour  thanks"";""its a small inconsistency ill fix that in my next cleanup/coverage pr || closing via  || @akarnokd with rxjava 207 the test still fails:```java    @test    public void observershouldbedisposed()  {        testobserver observer  new testobserver()        observablejust("""""""")subscribe(observer)        observerawaitterminalevent()        observerassertnoerrors()        observerassertcomplete()        asserttrue(observerisdisposed())    }``` || there was a problem with that change and has been reverted in #4873 || "";1;0;2x: fix singleusing add unit tests and coverage;"
"4518;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add missing resource observer for maybe  completable & single and adjust some javadoc;4517;;451.0;2x: add missing resource observer for maybe completable & single and adjust some javadoc;4517;  4518   it might be worth considering removing the protected `cancel()` methods as they are duplicates of `dispose` for `resourcesubscriber` i dont know because it works with `subscriptioncancel()` but also is a `disposable` so `dispose()` is there as well || so should i remove the `cancel()` method on all `resource*observer`? || @jakewharton your opinion on the removal? || im supportive of removing `cancel()` i much prefer when theres only one way to do something! || ;(question) how can i show the task progress with rxjava?;;""this is a snippet of groovy code that will probably do most of what you want``` javainput  from([1234])// we are going to be branching off of the input observable three times so cache itcached  inputcache()// produce an observable that is the fraction completed in this case 025 05 075 1fract  cachedreduce(0 {countvalue -> count+1})mapmany({size -> cachedmapwithindex({valueindex -> (index+1)/size})})// zip the fraction observable with the values to sync the timing of the values coming out with the fraction of completionoutput  observablezip(cachedfract {value fractiondone ->    // side effect to update progress bar with fraction done    println """"done $fractiondone""""    return value})// or// if updating the status of a progress bar produces an observable youll have to use this for the last zipoutput  observablemerge(observablezip(cachedfract {value fractiondone ->    // operation to update progress bar with fraction done results in an observable too    update  just(""""done $fractiondone"""")    return zip(just(value) update {value2 updatestatus -> value2})}))``` || closing out  further conversation can be taken up on  || "";1;0;remove cancel methods;"
4519;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add more maybe operators 9/09-1;this pr adds some more  maybe  operators: -  ambwith  -  cache  -  concatwith  -  contains  -  count  -  defaultifempty  -  delay  -  switchifempty  -  zipwith   plus a small cleanup and additional  testhelper  test support (check double onsubscribe calls  dispose() state management).;;0;2x: add more maybe operators 9/09-1;this pr adds some more `maybe` operators:- `ambwith`- `cache`- `concatwith`- `contains`- `count`- `defaultifempty`- `delay`- `switchifempty`- `zipwith`plus a small cleanup and additional `testhelper` test support (check double onsubscribe calls dispose() state management);  4519   ;;;;1;1;2x: add more maybe operators 9/09-1;
"4522;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;observable/flowable/completable/single.delay should always call onerror on the provided scheduler;4521;;4521.0;observable/flowable/completable/singledelay should always call onerror on the provided scheduler;4521;  4522    great job applying the changes to all of the base types! ||;[rxjava 200-rc2] observabledelay doesnt respect the provided scheduler; javapublic class delaybug {  public static void main(string args) throws exception {    final countdownlatch latch  new countdownlatch(1)    observable<string>error(new exception())        delay(100 timeunitmilliseconds schedulersio())        doonerror(throwable -> systemoutprintln(""""onerror @ """" + threadcurrentthread()getname()))        onerrorresumenext(observableempty())        doafterterminate(latch::countdown)        subscribe()    latchawait()  }}```output:```onerror @ main```expected output:```onerror @ rxcachedthreadscheduler-1```"";please check the available overloads for the feature you are looking for || i dont want to delay the error but i still want to receive `onerror` callback on the provided scheduler this is how rxjava 1 works ([operatordelayjava#l66-l78]( i think the following code [observabledelayjava#l89-l105]( should be:``` java@overridepublic void onerror(final throwable t) {    wschedule(new runnable() {        @override        public void run() {            try {                actualonerror(t)            } finally {                wdispose()            }        }    } delayerror ? delay : 0 unit)}``` || pr welcome || closed via #4522  ||;1;0;fix completabletestdelayerrorimmediately;"
4525;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix generics t in zip & combinelatest;4524  test for combinelatest fill follow;;4524.0;2x: fix generics t in zip & combinelatest;4524test for combinelatest fill follow;  4525  **< ;rxjava2 `observablezip` taking `iterable` and a `zipper` is broken; `zipper` signature is `function<? super t> ? extends r> zipper` where use of `t` breaks it just invoke it with non `object` t and a `classcastexception` is throwni checked with `single` and `flowable` they have different signatures for the comparable `zip` operators they use `object` where `t` is used for `observable` which are also consistent with the 1x zip operatori think this is just a bug in the signature;totally possible can you post a small unit test that fails? || ``` java    @test    public void zipiterableofobservables() {        list<observable<integer>> observables                 new arraylist<observable<integer>>()        observablesadd(observablejust(1 2 3))        observablesadd(observablejust(1 2 3))        observablezip(observables new function<integer integer>() {            @override            public integer apply(integer o) throws exception {                int sum  0                for (int i : o) {                    sum + i                }                return sum            }        })test()assertresult(2 4 6)    }```please note that if we use lambda as a zipper it eventually generates what the above test has || fyi the following works and its what is generated with the 1x signature:``` java    @test    public void zipiterableofobservables() {        list<observable<integer>> observables                 new arraylist<observable<integer>>()        observablesadd(observablejust(1 2 3))        observablesadd(observablejust(1 2 3))        observablezip(observables new function<object object>() {            @override            public object apply(object o) throws exception {                int sum  0                for (object i : o) {                    sum + (integer) i                }                return sum            }        })test()assertresult(2 4 6)    }``` || thanks the underlying problem is that we cant do `new t[n]` and such lambdas cast the bridge `object apply(object)` argument to `integer` which fails since `zip` and `combinelatest` use `object` internallycurrently i cant write a pr @vanniktech could you change all `? super t` signatures back to `? super object` and add unit tests like above to verify there is no `classcastexception` in a pr? || sure  closing via #4525 || btw why use array instead of `list` there? any reason? if `list` is used then at least it seems safe with generics doesnt it? || using array has reduced allocation cost and less indirection || ive singles of different types to run with singlezip and im getting classcastexception as singlezipiterable is it wrong zipping singles of different type together? || you have to be careful which index you cast back to what type || my singlezip returns ioreactivexinternaloperatorssinglesinglezipiterable but im expecting a single<object> any advice? || please provide a standalone unit test that demonstrates your problem ||;1;0;add it to single too;
4526;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: more usage of objecthelper;;;0;2x: more usage of objecthelper;;  4526   ;;;;1;1;2x: more usage of objecthelper;
4527;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: remove unused declarations;;;0;2x: remove unused declarations;;  4527   thanks! fyi im adding operators to maybe so please avoid that class and related components until i post the pr || alright didnt plan creating any other pr today tomorrow i have a few things planned though ||;;;;1;1;2x: remove unused declarations;
4528;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add maybe operators  add annotation and source code checker tests;- add  maybe  operators:  delay    hide    isempty    onerrorcomplete    onerrorresumenext    onexceptionresumenext  - add more fusion interfaces and mark  maybe.just  and  maybe.empty  as  scalarcallable . - added unit test to verify base reactive classes have proper scheduler and backpressure annotations (wherever appropriate) - added unit test to verify the javadoc of the main reactive types have the **backpressure:** and **scheduler:** sections in them (via scanning the source files if it can find it possible  works for me) - added unit test to verify that when **scheduler:** section mentions a method name  it actually matches the method the javadoc is there for (lots of copy-paste errors were found this way) - fix the annotations and documentation errors detected above - the backpressure javadoc section checker for 3 types are currently disabled as i m out of time for tonight.;;0;2x: add maybe operators add annotation and source code checker tests;- add `maybe` operators: `delay` `hide` `isempty` `onerrorcomplete` `onerrorresumenext` `onexceptionresumenext`- add more fusion interfaces and mark `maybejust` and `maybeempty` as `scalarcallable`- added unit test to verify base reactive classes have proper scheduler and backpressure annotations (wherever appropriate)- added unit test to verify the javadoc of the main reactive types have the **backpressure:** and **scheduler:** sections in them (via scanning the source files if it can find it possible works for me)- added unit test to verify that when **scheduler:** section mentions a method name it actually matches the method the javadoc is there for (lots of copy-paste errors were found this way)- fix the annotations and documentation errors detected above- the backpressure javadoc section checker for 3 types are currently disabled as im out of time for tonight;  4528  ;;;;1;1;2x: add maybe operators add annotation and source code checker tests;
4529;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix maybetimber by using scheduler and unit;also one question why does  completabletimer  check  if (!sd.isdisposed()) {  before replacing but singletimer does not? i adjusted maybetimber to singletimer so i didn t add the check there either.  however i feel like this should be consistent  can you elaborate which one is wanted?;;0;2x: fix maybetimber by using scheduler and unit;also one question why does `completabletimer` check `if (!sdisdisposed()) {` before replacing but singletimer does not? i adjusted maybetimber to singletimer so i didnt add the check there eitherhowever i feel like this should be consistent can you elaborate which one is wanted?;  4529  ;;;;1;1;use star imports;
"4530;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: cleanup 9/12-1  more maybe operators  more source code checking;- more  maybe  operators:  onterminatedetach    repeat    retry  - fixed missing  backpressure:  entries of the javadoc where the base type uses flowable/publisher - new base type source parser and check for javadoc mistakes: wrong type mentions  a/an use - fixes of those javadoc mistakes;;0;2x: cleanup 9/12-1 more maybe operators more source code checking;- more `maybe` operators: `onterminatedetach` `repeat` `retry`-  missing `backpressure:` entries of the javadoc where the base type uses flowable/publisher- new base type source parser and check for javadoc mistakes: wrong type mentions a/an use- fixes of those javadoc mistakes;""  4530   /cc @davidmgross do you recall any common mistake pattern in the documentation? || there could also be a test that checks that every file has a license header || how about adding code that checks the headers and adds them when the unit tests are run locally? i usually just run the junit tests from eclipse || the parser didnt check the instance methods properly so a bunch of mistakes remained posting a new pr shortly || its been a while since ive worked with the rx javadocs but here are somethings worth looking out for:- parameter names change in the code but the javadocs still refer to the  old names- potential exceptions change in the code and the javadocs arent  updated to match- missing backpressure / scheduler / since-annotations and outdated  information in each of these- changing things from consonant- to vowel-sound-starting doing a  search-and-replace and not replacing """"a"""" with """"an"""" or vice-versa to  match  also sometimes changing singulars to plurals or vice-versa by  search-and-replace which causes its own set of grammatical headaches- if you see any documentation that uses the passive voice you can  almost always make it clearer and less prone to misinterpretation by  rewriting it in the active voice- urls for marble diagrams are copy-and-pasted the name of the operator  is changed but the width/height values in the img tag are not so that the  right image appears but in the wrong dimensions (there were a couple of  these in the javadocs last i looked)i wish i had more time to devote to the rx docs but im 99% committed toanother project right nowon mon sep 12 2016 at 3:49 am david karnok notifications@githubcomwrote:> /cc @davidmgross  do you recall any> common mistake pattern in the documentation?> > > you are receiving this because you were mentioned> reply to this email directly view it on github>  or mute the thread>  ## david m grossplp consulting || "";;;;1;1;2x: cleanup 9/12-1 more maybe operators more source code checking;"
4531;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: publishsubject enhance npe when onnext(null) is called;;;0;2x: publishsubject enhance npe when onnext(null) is called;;  4531  ;;;;1;1;2x: publishsubject enhance npe when onnext(null) is called;
4533;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: more cleanup and fixed checker  maybe.takeuntil;- fix missed javadoc mistakes  fix the checker that hid those mistakes in instance methods  javadoc due to a bug - add  maybe.takeuntil;;0;2x: more cleanup and  checker maybetakeuntil;- fix missed javadoc mistakes fix the checker that hid those mistakes in instance methods javadoc due to a bug- add `maybetakeuntil`;  4533   ;;;;1;1;2x: more cleanup and  checker maybetakeuntil;
4536;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;observable.timeout/flowable.timeout should unsubscribe from underlying subscription on dispose;;;0;observabletimeout/flowabletimeout should unsubscribe from underlying subscription on dispose;;  4536  **< ;;;;1;1;observable/flowable should unsubscribe from underlying subscription on dispose;
4537;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: last maybe operators;this pr adds the last couple of  maybe  operators  timeout  and  unsubscribeon .  @abersnaze let me know if i missed an operator or you want some overload.  in the subsequent prs  i ll change the return types of some classical operators to better indicate the cardinality they have ( single    completable ).;;0;2x: last maybe operators;this pr adds the last couple of `maybe` operators `timeout` and `unsubscribeon`@abersnaze let me know if i missed an operator or you want some overloadin the subsequent prs ill change the return types of some classical operators to better indicate the cardinality they have (`single` `completable`);  4537   ;;;;1;1;2x: last maybe operators;
4538;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add most relevant ~100 operators  reactive-streams tck tests;this pr adds about ~100 reactive-streams test compatibility kit (tck) tests of rxjava s most relevant operators and operation modes.  the pr also contains a behavior fix for  unsubscribeon  that now stops propagating events if the cancelled because it may take arbitrary time for the scheduled cancellation to reach the upstream which generally keeps emitting in the meantime.;;0;2x: add most relevant ~100 operators reactive-streams tck tests;this pr adds about ~100 reactive-streams test compatibility kit (tck) tests of rxjavas most relevant operators and operation modesthe pr also contains a behavior fix for `unsubscribeon` that now stops propagating events if the cancelled because it may take arbitrary time for the scheduled cancellation to reach the upstream which generally keeps emitting in the meantime;  4538  ;;;;1;1;2x: add most relevant ~100 operators reactive-streams tck tests;
4540;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add create test with cancelable for all types and add more maybecreatetest cases;setcancellable  was not tested before.;;0;2x: add create test with cancelable for all types and add more maybecreatetest cases;`setcancellable` was not tested before;> gradle suite > gradle test > ioreactivextckobserveontcktest failed>     javalangassertionerror: illegal concurrent access detected (entering critical section)! thread[rxsinglescheduler-15main] emited onnext(0) signal before thread[test worker5main] finished its onsubscribe() signal || tck doesnt seem to like that onsubscribe may trigger emission before it even returns - which is completely legal btw ill add a workaround for that in the tck shortly ||   4540  ;;;;1;1;2x: add create test with cancelable for all types and add more maybecreatetest cases;
4541;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: small cleanup and tck fix;- change the  callable<publisher<t>>  parameter of  timeout  to plain  publisher<t>  to simplify the api surface  use  defer(callable<publisher<t>>)  as input instead - change the parameter order of  timeout  from  (long  timeunit  publisher  scheduler)  to  (long  timeunit  scheduler  publisher)  to better match the general pattern of time-unit-scheduler. -  observable.timeout  has been updated similarly - add  flowableawaitonsubscribetck  to workaround the case when calling  onnext  (indirectly) from  onsubscribe  may be unexpected (plus randomly fails the observeon tck test).;;0;2x: small cleanup and tck fix;- change the `callable<publisher<t>>` parameter of `timeout` to plain `publisher<t>` to simplify the api surface use `defer(callable<publisher<t>>)` as input instead- change the parameter order of `timeout` from `(long timeunit publisher scheduler)` to `(long timeunit scheduler publisher)` to better match the general pattern of time-unit-scheduler- `observabletimeout` has been updated similarly- add `flowableawaitonsubscribetck` to workaround the case when calling `onnext` (indirectly) from `onsubscribe` may be unexpected (plus randomly fails the observeon tck test); ;;;;1;1;2x: small cleanup and tck fix;
"4542;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: cleanup of some javadoc errors and mentions of  nbp;- fix some javadoc typos - replace javadoc mentioning of  unsubscribe  with either  cancel  or  dispose  - some minor algorithm reorganizations based on intellij analysis - remove the mention of  nbp  from the code and documentation (it refers to an earlier naming scheme for observables and observers);;0;2x: cleanup of some javadoc errors and mentions of nbp;""- fix some javadoc typos- replace javadoc mentioning of """"unsubscribe"""" with either """"cancel"""" or """"dispose""""- some minor algorithm reorganizations based on intellij analysis- remove the mention of """"nbp"""" from the code and documentation (it refers to an earlier naming scheme for observables and observers)"";  4542  ;;;;1;1;2x: cleanup of some javadoc errors and mentions of nbp;"
4549;1;0;0;0;0;1;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.2 preparation cleanup and experimental/beta/deprecated adjustments;this pr contains some cleanup  javadoc fixes as well as the api changes for 1.2: ### promote beta to standard -  rx.observable.create(synconsubscribe<s  t>)  -  rx.observable.doonrequest(action1<long>)  -  rx.observable.flatmap(func1<? super t  ? extends observable<? extends r>>  func1<? super throwable  ? extends observable<? extends r>>  func0<? extends observable<? extends r>>  int)  -  rx.observable.flatmap(func1<? super t  ? extends observable<? extends r>>  int)  -  rx.observable.flatmap(func1<? super t  ? extends observable<? extends u>>  func2<? super t  ? super u  ? extends r>  int)  -  rx.observable.flatmapiterable(func1<? super t  ? extends iterable<? extends r>>  int)  -  rx.observable.flatmapiterable(func1<? super t  ? extends iterable<? extends u>>  func2<? super t  ? super u  ? extends r>  int)  -  rx.observable.fromcallable(callable<? extends t>)  -  rx.observable.tosingle()  - _ _ -  rx.single.fromcallable(callable<? extends t>)  - _ _ -  rx.singlesubscriber<t>  - _ _ -  rx.observables.connectableobservable.autoconnect()  -  rx.observables.connectableobservable.autoconnect(int  action1<? super subscription>)  -  rx.observables.connectableobservable.autoconnect(int)  - _ _ -  rx.observables.synconsubscribe<s  t>  - _ _ -  rx.subjects.asyncsubject.getthrowable()  -  rx.subjects.asyncsubject.getvalue()  -  rx.subjects.asyncsubject.hascompleted()  -  rx.subjects.asyncsubject.hasthrowable()  -  rx.subjects.asyncsubject.hasvalue()  - _ _ -  rx.subjects.behaviorsubject.getthrowable()  -  rx.subjects.behaviorsubject.getvalue()  -  rx.subjects.behaviorsubject.getvalues()  -  rx.subjects.behaviorsubject.getvalues(t)  -  rx.subjects.behaviorsubject.hascompleted()  -  rx.subjects.behaviorsubject.hasthrowable()  -  rx.subjects.behaviorsubject.hasvalue()  - _ _ -  rx.subjects.publishsubject.getthrowable()  -  rx.subjects.publishsubject.hascompleted()  -  rx.subjects.publishsubject.hasthrowable()  - _ _ -  rx.subjects.replaysubject.getthrowable()  -  rx.subjects.replaysubject.getvalue()  -  rx.subjects.replaysubject.getvalues()  -  rx.subjects.replaysubject.getvalues(t)  -  rx.subjects.replaysubject.hasanyvalue()  -  rx.subjects.replaysubject.hascompleted()  -  rx.subjects.replaysubject.hasthrowable()  -  rx.subjects.replaysubject.hasvalue()  -  rx.subjects.replaysubject.size()  ### promote experimental to standard  none. ### promote to beta -  rx.backpressureoverflow  -  rx.observable.concatdelayerror(iterable<? extends observable<? extends t>>)  -  rx.observable.concatdelayerror(observable<? extends observable<? extends t>>)  -  rx.observable.concateager(iterable<? extends observable<? extends t>>  int)  -  rx.observable.concateager(iterable<? extends observable<? extends t>>)  -  rx.observable.concateager(observable<? extends observable<? extends t>>  int)  -  rx.observable.concateager(observable<? extends observable<? extends t>>)  -  rx.observable.concateager(observable<? extends t>  observable<? extends t>  observable<? extends t>  observable<? extends t>  observable<? extends t>  observable<? extends t>  observable<? extends t>  observable<? extends t>  observable<? extends t>)  -  rx.observable.concateager(observable<? extends t>  observable<? extends t>  observable<? extends t>  observable<? extends t>  observable<? extends t>  observable<? extends t>  observable<? extends t>  observable<? extends t>)  -  rx.observable.concateager(observable<? extends t>  observable<? extends t>  observable<? extends t>  observable<? extends t>  observable<? extends t>  observable<? extends t>  observable<? extends t>)  -  rx.observable.concateager(observable<? extends t>  observable<? extends t>  observable<? extends t>  observable<? extends t>  observable<? extends t>  observable<? extends t>)  -  rx.observable.concateager(observable<? extends t>  observable<? extends t>  observable<? extends t>  observable<? extends t>  observable<? extends t>)  -  rx.observable.concateager(observable<? extends t>  observable<? extends t>  observable<? extends t>  observable<? extends t>)  -  rx.observable.concateager(observable<? extends t>  observable<? extends t>  observable<? extends t>)  -  rx.observable.concateager(observable<? extends t>  observable<? extends t>)  -  rx.observable.concatmapdelayerror(func1<? super t  ? extends observable<? extends r>>)  -  rx.observable.concatmapeager(func1<? super t  ? extends observable<? extends r>>  int  int)  -  rx.observable.concatmapeager(func1<? super t  ? extends observable<? extends r>>  int)  -  rx.observable.concatmapeager(func1<? super t  ? extends observable<? extends r>>)  -  rx.observable.delaysubscription(observable<u>)  -  rx.observable.distinctuntilchanged(func2<? super t  ? super t  boolean>)  -  rx.observable.mergedelayerror(observable<? extends observable<? extends t>>  int)  -  rx.observable.onbackpressurebuffer(long  action0  strategy)  -  rx.observable.switchmapdelayerror(func1<? super t  ? extends observable<? extends r>>)  -  rx.observable.switchonnextdelayerror(observable<? extends observable<? extends t>>)  -  rx.observable.tocompletable()  -  rx.observable.tosortedlist(func2<? super t  ? super t  integer>  int)  -  rx.observable.tosortedlist(int)  -  rx.observable.using(func0<resource>  func1<? super resource  ? extends observable<? extends t>>  action1<? super resource>  boolean)  - _ _ -  rx.observables.blockingobservable.subscribe()  -  rx.observables.blockingobservable.subscribe(action1<? super t>  action1<? super throwable>  action0)  -  rx.observables.blockingobservable.subscribe(action1<? super t>  action1<? super throwable>)  -  rx.observables.blockingobservable.subscribe(action1<? super t>)  -  rx.observables.blockingobservable.subscribe(observer<? super t>)  -  rx.observables.blockingobservable.subscribe(subscriber<? super t>)  - _ _ -  rx.completable  - _ _ -  rx.single.defer(callable<single<t>>)  -  rx.single.delay(long  timeunit  scheduler)  -  rx.single.delay(long  timeunit)  -  rx.single.delaysubscription(observable<?>)  -  rx.single.doafterterminate(action0)  -  rx.single.doonerror(action1<throwable>)  -  rx.single.doonsubscribe(action0)  -  rx.single.doonsuccess(action1<? super t>)  -  rx.single.doonunsubscribe(action0)  -  rx.single.lift(operator<? extends r  ? super t>)  -  rx.single.onerrorresumenext(func1<throwable  ? extends single<? extends t>>)  -  rx.single.onerrorresumenext(single<? extends t>)  -  rx.single.toblocking()  -  rx.single.tocompletable()  -  rx.single.using(func0<resource>  func1<? super resource  ? extends single<? extends t>>  action1<? super resource>  boolean)  -  rx.single.using(func0<resource>  func1<? super resource  ? extends single<? extends t>>  action1<? super resource>)  - _ _ -  rx.exceptions.compositeexception.compositeexception(throwable)  - _ _ -  rx.exceptions.exceptions.throworreport(throwable  observer<?>  object)  -  rx.exceptions.exceptions.throworreport(throwable  observer<?>)  -  rx.exceptions.exceptions.throworreport(throwable  singlesubscriber<?>)  - _ _ -  rx.singles.blockingsingle<t>   ### removed -  rx.observable.extend(func1<onsubscribe<t>  r>)  -  rx.observable.fromasync()  - _ _ -  rx.completable.completablesubscriber  -  rx.completable.completableonsubscribe  -  rx.completable.completablelift  -  rx.completable.completabletransform;;0;12 preparation cleanup and experimental/beta/deprecated adjustments;this pr contains some cleanup javadoc fixes as well as the api changes for 12:### promote beta to standard- `rxobservablecreate(synconsubscribe<s t>)`- `rxobservabledoonrequest(action1<long>)`- `rxobservableflatmap(func1<? super t ? extends observable<? extends r>> func1<? super throwable ? extends observable<? extends r>> func0<? extends observable<? extends r>> int)`- `rxobservableflatmap(func1<? super t ? extends observable<? extends r>> int)`- `rxobservableflatmap(func1<? super t ? extends observable<? extends u>> func2<? super t ? super u ? extends r> int)`- `rxobservableflatmapiterable(func1<? super t ? extends iterable<? extends r>> int)`- `rxobservableflatmapiterable(func1<? super t ? extends iterable<? extends u>> func2<? super t ? super u ? extends r> int)`- `rxobservablefromcallable(callable<? extends t>)`- `rxobservabletosingle()`- _ _- `rxsinglefromcallable(callable<? extends t>)`- _ _- `rxsinglesubscriber<t>`- _ _- `rxobservablesconnectableobservableautoconnect()`- `rxobservablesconnectableobservableautoconnect(int action1<? super subscription>)`- `rxobservablesconnectableobservableautoconnect(int)`- _ _- `rxobservablessynconsubscribe<s t>`- _ _- `rxsubjectsasyncsubjectgetthrowable()`- `rxsubjectsasyncsubjectgetvalue()`- `rxsubjectsasyncsubjecthascompleted()`- `rxsubjectsasyncsubjecthasthrowable()`- `rxsubjectsasyncsubjecthasvalue()`- _ _- `rxsubjectsbehaviorsubjectgetthrowable()`- `rxsubjectsbehaviorsubjectgetvalue()`- `rxsubjectsbehaviorsubjectgetvalues()`- `rxsubjectsbehaviorsubjectgetvalues(t)`- `rxsubjectsbehaviorsubjecthascompleted()`- `rxsubjectsbehaviorsubjecthasthrowable()`- `rxsubjectsbehaviorsubjecthasvalue()`- _ _- `rxsubjectspublishsubjectgetthrowable()`- `rxsubjectspublishsubjecthascompleted()`- `rxsubjectspublishsubjecthasthrowable()`- _ _- `rxsubjectsreplaysubjectgetthrowable()`- `rxsubjectsreplaysubjectgetvalue()`- `rxsubjectsreplaysubjectgetvalues()`- `rxsubjectsreplaysubjectgetvalues(t)`- `rxsubjectsreplaysubjecthasanyvalue()`- `rxsubjectsreplaysubjecthascompleted()`- `rxsubjectsreplaysubjecthasthrowable()`- `rxsubjectsreplaysubjecthasvalue()`- `rxsubjectsreplaysubjectsize()`### promote experimental to standardnone### promote to beta- `rxbackpressureoverflow`- `rxobservableconcatdelayerror(iterable<? extends observable<? extends t>>)`- `rxobservableconcatdelayerror(observable<? extends observable<? extends t>>)`- `rxobservableconcateager(iterable<? extends observable<? extends t>> int)`- `rxobservableconcateager(iterable<? extends observable<? extends t>>)`- `rxobservableconcateager(observable<? extends observable<? extends t>> int)`- `rxobservableconcateager(observable<? extends observable<? extends t>>)`- `rxobservableconcateager(observable<? extends t> observable<? extends t> observable<? extends t> observable<? extends t> observable<? extends t> observable<? extends t> observable<? extends t> observable<? extends t> observable<? extends t>)`- `rxobservableconcateager(observable<? extends t> observable<? extends t> observable<? extends t> observable<? extends t> observable<? extends t> observable<? extends t> observable<? extends t> observable<? extends t>)`- `rxobservableconcateager(observable<? extends t> observable<? extends t> observable<? extends t> observable<? extends t> observable<? extends t> observable<? extends t> observable<? extends t>)`- `rxobservableconcateager(observable<? extends t> observable<? extends t> observable<? extends t> observable<? extends t> observable<? extends t> observable<? extends t>)`- `rxobservableconcateager(observable<? extends t> observable<? extends t> observable<? extends t> observable<? extends t> observable<? extends t>)`- `rxobservableconcateager(observable<? extends t> observable<? extends t> observable<? extends t> observable<? extends t>)`- `rxobservableconcateager(observable<? extends t> observable<? extends t> observable<? extends t>)`- `rxobservableconcateager(observable<? extends t> observable<? extends t>)`- `rxobservableconcatmapdelayerror(func1<? super t ? extends observable<? extends r>>)`- `rxobservableconcatmapeager(func1<? super t ? extends observable<? extends r>> int int)`- `rxobservableconcatmapeager(func1<? super t ? extends observable<? extends r>> int)`- `rxobservableconcatmapeager(func1<? super t ? extends observable<? extends r>>)`- `rxobservabledelaysubscription(observable<u>)`- `rxobservabledistinctuntilchanged(func2<? super t ? super t boolean>)`- `rxobservablemergedelayerror(observable<? extends observable<? extends t>> int)`- `rxobservableonbackpressurebuffer(long action0 strategy)`- `rxobservableswitchmapdelayerror(func1<? super t ? extends observable<? extends r>>)`- `rxobservableswitchonnextdelayerror(observable<? extends observable<? extends t>>)`- `rxobservabletocompletable()`- `rxobservabletosortedlist(func2<? super t ? super t integer> int)`- `rxobservabletosortedlist(int)`- `rxobservableusing(func0<resource> func1<? super resource ? extends observable<? extends t>> action1<? super resource> boolean)`- _ _- `rxobservablesblockingobservablesubscribe()`- `rxobservablesblockingobservablesubscribe(action1<? super t> action1<? super throwable> action0)`- `rxobservablesblockingobservablesubscribe(action1<? super t> action1<? super throwable>)`- `rxobservablesblockingobservablesubscribe(action1<? super t>)`- `rxobservablesblockingobservablesubscribe(observer<? super t>)`- `rxobservablesblockingobservablesubscribe(subscriber<? super t>)`- _ _- `rxcompletable`- _ _- `rxsingledefer(callable<single<t>>)`- `rxsingledelay(long timeunit scheduler)`- `rxsingledelay(long timeunit)`- `rxsingledelaysubscription(observable<?>)`- `rxsingledoafterterminate(action0)`- `rxsingledoonerror(action1<throwable>)`- `rxsingledoonsubscribe(action0)`- `rxsingledoonsuccess(action1<? super t>)`- `rxsingledoonunsubscribe(action0)`- `rxsinglelift(operator<? extends r ? super t>)`- `rxsingleonerrorresumenext(func1<throwable ? extends single<? extends t>>)`- `rxsingleonerrorresumenext(single<? extends t>)`- `rxsingletoblocking()`- `rxsingletocompletable()`- `rxsingleusing(func0<resource> func1<? super resource ? extends single<? extends t>> action1<? super resource> boolean)`- `rxsingleusing(func0<resource> func1<? super resource ? extends single<? extends t>> action1<? super resource>)`- _ _- `rxexceptionscompositeexceptioncompositeexception(throwable)`- _ _- `rxexceptionsexceptionsthroworreport(throwable observer<?> object)`- `rxexceptionsexceptionsthroworreport(throwable observer<?>)`- `rxexceptionsexceptionsthroworreport(throwable singlesubscriber<?>)`- _ _- `rxsinglesblockingsingle<t>``### removed- `rxobservableextend(func1<onsubscribe<t> r>)`- `rxobservablefromasync()`- _ _- `rxcompletablecompletablesubscriber`- `rxcompletablecompletableonsubscribe`- `rxcompletablecompletablelift`- `rxcompletablecompletabletransform`;  4549   ;;;;1;1;12 preparation cleanup and experimental/beta/deprecated adjustments;
4554;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: make internal naming consistent  refactor some classes 9/14-2;- make internal naming of components consistent with the base reactive type - move  io.reactivex.internal.subscribers.flowable.*  to  io.reactivex.internal.subscribers  - move  io.reactivex.internal.subscribers.observable.*  to  io.reactivex.internal.observers;;0;2x: make internal naming consistent refactor some classes 9/14-2;- make internal naming of components consistent with the base reactive type- move `ioreactivexinternalsubscribersflowable*` to `ioreactivexinternalsubscribers`- move `ioreactivexinternalsubscribersobservable*` to `ioreactivexinternalobservers`;  4554   oh god the rebasing || @abersnaze i recommend you post one or two operator changes at a time as it is likely they need some extra changes until they match structure i expect (such as in maybeisempty()) this way you dont have large interference from cascading fixes in the 2x branch || its hard because they are so intertwinedon wed sep 14 2016 at 1:49 pm david karnok notifications@githubcomwrote:> @abersnaze  i recommend you post one or two> operator changes at a time as it is likely they need some extra changes> until they match structure i expect (such as in maybeisempty()) this way> you dont have large interference from cascading fixes in the 2x branch> > > you are receiving this because you were mentioned> reply to this email directly view it on github>  or mute the thread>   || ive run out of ideas about what to clean up so you should have no interference from me in the following days ||;;;;1;1;2x: make internal naming consistent refactor some classes 9/14-2;
4555;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: enhance generics doonerror doonrequest;want to able to call  doonerror(action1<object>)  and similarly enhanced  doonrequest  while i was about it.;;0;1x: enhance generics doonerror doonrequest;want to able to call `doonerror(action1<object>)` and similarly enhanced `doonrequest` while i was about it;  4555   > test to ensure bounds are maintained?ive added a couple of tests to get coverage of new lower bounds || is it okay if this goes into 12 only ? technically this isnt a behavior change but an api change and besides o f `doonrequested` upgrading to standard `doonerror` was established earlier || ok with me to go in 12 || oh something conflicted could you rebase? || rebased || thanks ;;;;1;1;enhance generics doonerror doonrequest;
4560;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix typo in single + maybe defer();;;0;2x: fix typo in single + maybe defer();;  4560  ;;;;1;1;2x: fix typo in single + maybe defer();
4561;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: enhance npe message in create functions of all base reactive types;;;0;2x: enhance npe message in create functions of all base reactive types;;  4561  **< ;;;;1;1;2x: enhance npe message in create functions of all base reactive types;
4567;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;add extra maybe iterable amb tests for overlapped emissions;- asserting that downstream will get the results of the first source that began emission  even if multiple sources have overlapped emissions - testing success and error paths;;0;add extra maybe iterable amb tests for overlapped emissions;- asserting that downstream will get the results of the first source that began emission even if multiple sources have overlapped emissions- testing success and error paths;as far as i can see the ci error is coming from a seemingly unrelated test:```ioreactivexinternaloperatorsmaybemaybeunsubscribeontest > normal failedjavalangassertionerror    at orgjunitassertfail(assertjava:86)    at orgjunitassertasserttrue(assertjava:41)    at orgjunitassertassertfalse(assertjava:64)    at orgjunitassertassertfalse(assertjava:74)    at ioreactivexinternaloperatorsmaybemaybeunsubscribeontestnormal(maybeunsubscribeontestjava:50)```im a bit confused here - did i really manage to break this test or is this one known to be flaky? || it was a flaky test: the unsubscription may not reach the processor in time the latch unblocks the main thread and thus there appear to be subscribers there:+1: thanks for the unit tests ||;;;;1;1;add extra maybe iterable amb tests for overlapped emissions- asserting that downstream will get the results of the first source that began emission even if multiple sources have overlapped emissions- testing success and error paths;
4570;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: last() to return single;this pr changes the return type of  last()  to  single<t>  and updates the relevant locations.  originally  it was implemented as  takelast(1).single()  so to reduce impact  all other original uses now have this inlined.;;0;2x: last() to return single;this pr changes the return type of `last()` to `single<t>` and updates the relevant locationsoriginally it was implemented as `takelast(1)single()` so to reduce impact all other original uses now have this inlined;  4570   ps ive pushed my current branch here  || > ps ive pushed my current branch herei see you didnt keep the original typed code to help with `toflowable()` also im not fond of moving the `blockingx` because it adds an extra step/overheadid have to redo/reoptimize them anyways so dont really need that ||;;;;1;1;2x: last() to return single;
4573;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: make any() and all() return single  patch up tests;this pr changes the return type of  any()  and  all()  to  single .  i ve also did a small change to  testobserver  by having it implement the other  xobserver  types. this resulted in one extra method  onsuccess  to be added but now you can subscribe  testobserver  to  single    maybe  and  completable  without conversion yet still  test()  them with the same convenient api.      java flowable.range(1  10).any(v -> true).test().assertresult(true);;0;2x: make any() and all() return single patch up tests;this pr changes the return type of `any()` and `all()` to `single`ive also did a small change to `testobserver` by having it implement the other `xobserver` types this resulted in one extra method `onsuccess` to be added but now you can subscribe `testobserver` to `single` `maybe` and `completable` without conversion yet still `test()` them with the same convenient api``` javaflowablerange(1 10)any(v -> true)test()assertresult(true)```;  4573  ;;;;1;1;2x: make any() and all() return single patch up tests;
4574;1;0;0;0;0;1;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: collect  tolist  tosortedlist  tomap  tomultimap to return single;this pr makes the following operators return  single : -  collect  -  collectinto  -  tolist  -  tosortedlist  -  tomap  -  tomultimap   and changes the documentation to mention  single  instead as well. (there are some whitespace removals i forgot previously).;;0;2x: collect tolist tosortedlist tomap tomultimap to return single;this pr makes the following operators return `single`:- `collect`- `collectinto`- `tolist`- `tosortedlist`- `tomap`- `tomultimap`and changes the documentation to mention `single` instead as well (there are some whitespace removals i forgot previously);  4574  ;;;;1;1;2x: collect tolist tosortedlist tomap tomultimap to return single;
4576;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: count  elementat  ingoreelements  last  single  reduce  reducewith to return non-flowable;this pr updates many  flowable  operators to return  single    maybe  or  completable : -  count()  ->  single  -  elementat()  ->  maybe  -  elementat(t)  ->  single  -  first(t)  ->  single  -  firstelement()  ->  maybe  -  ignoreelements()  ->  completable  -  reduce(callable  bifunction)  ->  single  -  reducewith(u  bifunction)  ->  single  -  single(t)  ->  single  -  singleelement()  ->  maybe   and deletes  flowable.tosingle    flowable.tomaybe  and  flowable.tocompletable .   flowble.reduce(bifunction)  was not yet changed from  single  to  maybe  (to allow empty sources to be reduced to empty maybe).  related: #4321;;0;2x: count elementat ingoreelements last single reduce reducewith to return non-flowable;this pr updates many `flowable` operators to return `single` `maybe` or `completable`:- `count()` -> `single`- `elementat()` -> `maybe`- `elementat(t)` -> `single`- `first(t)` -> `single`- `firstelement()` -> `maybe`- `ignoreelements()` -> `completable`- `reduce(callable bifunction)` -> `single`- `reducewith(u bifunction)` -> `single`- `single(t)` -> `single`- `singleelement()` -> `maybe`and deletes `flowabletosingle` `flowabletomaybe` and `flowabletocompletable``flowblereduce(bifunction)` was not yet changed from `single` to `maybe` (to allow empty sources to be reduced to empty maybe)related: #4321;  4576  ;;;;1;1;2x: count elementat ingoreelements last single reduce reducewithto return non-flowable;
4579;1;0;0;0;0;1;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: convert the observable operators to return single/maybe;this pr updates many  observable  operators to return  single    maybe  or  completable : - count() -> single - elementat() -> maybe - elementat(t) -> single - first(t) -> single - firstelement() -> maybe - ignoreelements() -> completable - lastelement() -> maybe - reduce(bifunction) -> maybe - reduce(callable  bifunction) -> single - reducewith(u  bifunction) -> single - single(t) -> single - singleelement() -> maybe  and deletes observable.tosingle  observable.tomaybe and observable.tocompletable.  in addition   flowable.reduce(bifunction)  now returns  maybe<t> .  related: #4321;;0;2x: convert the observable operators to return single/maybe;this pr updates many `observable` operators to return `single` `maybe` or `completable`:- count() -> single- elementat() -> maybe- elementat(t) -> single- first(t) -> single- firstelement() -> maybe- ignoreelements() -> completable- lastelement() -> maybe- reduce(bifunction) -> maybe- reduce(callable bifunction) -> single- reducewith(u bifunction) -> single- single(t) -> single- singleelement() -> maybeand deletes observabletosingle observabletomaybe and observabletocompletablein addition `flowablereduce(bifunction)` now returns `maybe<t>`related: #4321;  4579   thanks @jakewharton ! ||;;;;1;1;2x: convert the observable operators to return single/maybe;
4580;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;rename asyncemitter to emitter;as per discussion in #4577  renaming  asyncemitter  to  emitter  via deprecation.  there is a catch though.  completableemitter  is correctly named now and depends on  asyncemitter  via the method:      java  void setcancellation(asyncemitter.cancellable c)       when can we break the api of that class?;;4577.0;rename asyncemitter to emitter;as per discussion in #4577 renaming `asyncemitter` to `emitter` via deprecationthere is a catch though `completableemitter` is correctly named now and depends on `asyncemitter` via the method:``` java void setcancellation(asyncemittercancellable c)```when can we break the api of that class?;   4580   thanks for review @akarnokd  i take it we have to wait for 13 to break the api of experimental `completableemitter`? || deleting experimental apis has to wait one patch version so 121 will have both and 122 can remove the asyncemitter || ok ill patch again once 121 is outon thu 22 sep 2016 21:25 david karnok notifications@githubcom wrote:> deleting experimental apis has to wait one patch version so 121 will> have both and 122 can remove the asyncemitter> > > you are receiving this because you authored the thread> reply to this email directly view it on github>  or mute the thread>   || /cc @jakewharton @artem-zinnatullin  || make the cancelable interfaces extend each other as wellon thu sep 22 2016 6:33 pm dave moten notifications@githubcom wrote:> ## _@davidmoten_ commented on this pull request> > in src/main/java/rx/asyncemitterjava>  > >   */> >  @experimental> > +@deprecated> >  public interface asyncemitter<t> extends observer<t> {> > cannot extend emitter because of two versions of cancellable would break> existing asyncemitter use> > > you are receiving this because you were mentioned> > reply to this email directly view it on github>  or mute the thread>   || > make the cancelable interfaces extend each other as wellgood idea  um i dont think its worth it juggling with inheritance of these interfaces straight after next release im just going to delete the deprecated stuff || ive added a `@deprecated` annotation to `completableemitter` let me know if you guys still want the interface inheritance business || forgot to move `cancellable` to `rxfunctions` thats done now || thanks for working this out! ||;fromemitter cleanup;the rename of `observablefromasync` to `observablefromemitter` isnt quite complete in that the signature of `observablefromemitter` still refers to an interface `asyncemitter` which i would like to rename to `emitter` im happy to make a pr it would add a new method ``` java@experimentalpublic static <t> observable<t> fromemitter(action1<emitter<t>> emitter emitterbackpressuremode backpressure) ```and i would deprecate this one:``` javapublic static <t> observable<t> fromemitter(action1<asyncemitter<t>> emitter asyncemitterbackpressuremode backpressure)```proceed with pr?;yes pr welcome ||;1;0;rename asyncemitter to emitter;
4581;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: remove some dead code;also what about intfunction it s right now in the public api however not used. so the question is does rx want to expose that interface?;;0;2x: remove some dead code;also what about intfunction its right now in the public api however not used so the question is does rx want to expose that interface?;  4581  **< ;;;;1;1;2x: remove some dead code;
4582;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add missing maybe tests for concatwith & onerrorresumenext;they had no tests previously;;0;2x: add missing maybe tests for concatwith & onerrorresumenext;they had no tests previously;  4582  ;;;;1;1;2x: add missing maybe tests for concatwith & onerrorresumenext;
4583;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x fix flowable.create() not reporting null values properly  unify;exception msg across  reported on [stackoverflow](  there was no proper null check in the various emitters. i ve also unified the message pattern across all  create()  emitters.;;0;2x fix flowablecreate() not reporting null values properly unify;exception msg acrossreported on [stackoverflow]( was no proper null check in the various emitters ive also unified the message pattern across all `create()` emitters;  4583  ;;;;1;1;2x fix flowablecreate() not reporting null values properly unifyexception msg across;
"4585;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: evaluate schedule initialization via callable;this implements the solution proposed in #4572 - to initialize the schedulers via a callable  rather than directly via a value.;;4572.0;2x: evaluate schedule initialization via callable;this implements the solution proposed in #4572 - to initialize the schedulers via a callable rather than directly via a value;""  4585   @akarnokd correct me if im wrong but in order to avoid the evaluation of the default scheduler instance when it is being overridden i still need to change the `oninit[single|io|new|computation]handler` signatures to be `function<callable<scheduler> scheduler>` as per -```    static volatile function<callable<scheduler> scheduler> oninitsinglehandler```otherwise the invocation of `initsinglescheduler` will cause the evaluation of the default value to pass it as a parameter to the overriding/transforming function: `oninitsinglehandler` || yes you still need `callable` as the indirection but the inner class will be evaluated only if `call` is actually invoked || ive added the remaining lazy initializationive also fairly aggressively enforced non-null in the associated functions for example:``` javapublic static scheduler initioscheduler(callable<scheduler> defaultscheduler) {    objecthelperrequirenonnull(defaultscheduler """"scheduler callable cant be null"""")    callable<scheduler> scheduler> f  oninitiohandler    if (f  null) {        return callrequirenonnull(defaultscheduler)    }    return applyrequirenonnull(f defaultscheduler)}```however to me this seems slightly out of place / over the top is that enforcement necessary or should the resultant null scheduler be left unasserted and left to the eventual nullpointerexception when the scheduler is used? either way im happy to keep or remove that based upon review feedback || aggressive input validation is never over the top if you defer checkingthen the stacktrace tells you nothing about what actually caused the brokenstateon sun sep 25 2016 7:09 am peter tackage notifications@githubcomwrote:> ive added the remaining lazy initialization> > ive also fairly aggressively enforced non-null in the associated> functions for example:> > public static scheduler initioscheduler(callable<scheduler> defaultscheduler) {>     objecthelperrequirenonnull(defaultscheduler """"scheduler callable cant be null"""")>     callable<scheduler> scheduler> f  oninitiohandler>     if (f  null) {>         return callrequirenonnull(defaultscheduler)>     }>     return applyrequirenonnull(f defaultscheduler)> }> > however to me this seems slightly out of place / over the top is that> enforcement necessary or should the resultant null scheduler be left> unasserted and left to the eventual nullpointerexception when the scheduler> is used? either way im happy to keep or remove that based upon review> feedback> > > you are receiving this because you commented> > reply to this email directly view it on github>  or mute the thread>   || @akarnokd all done as far as i am concerned do i need to anything else for this to be merged?  || i was waiting for you to settle with the implementation thanks for the contribution || "";2x: defer scheduler initialization in hook init api;""an issue was [filed on rxandroid]( asking for the default """"main thread"""" scheduler to be lazily initialized this would allow support for unit testing on the jvm by swapping out the scheduler for one that works where androids main thread doesnt existthe hook api provides a means of replacing the scheduler during initialization but the problem is that in order to call these """"init"""" methods the instance needs to be eagerly createdwhat im proposing is that we change the """"init"""" functions from `function<scheduler scheduler>` to `function<scheduler callable<scheduler>>` which would allow ignoring the default scheduler instance by never delegating to `callablecall()` to create itthe implementation of the initializer would change to something like:``` javascheduler initfoo(callable<scheduler> defaultscheduler)function f  initfuncif (f  null) {  return defaultschedulercall()}return apply(f defaultscheduler)```now we can make this change _only_ in rxandroid to support this case i think that theres a large value in having as much symmetry between the two libraries as possible howeveris this something that would be acceptable to change in rxjava? or are there any alternative apis that anyone can think of for this?"";i dont think rxjava needs this change we have standard java executorservices backing the schedulers so their creation should always succeed in a reasonable jdk implementationmaybe you could combine `androidschedulers` the plugin and use a holder class to defer the creation of the looper/handler if the function happens to be null the first time `main` is invoked i can see this needs to change the callback to `callable` and not rely on the default anymore``` javaclass androidschedulers {    static final class defaultholder {        static final scheduler default_main  new handlerscheduler(            new handler(loopergetmainlooper())))    }    static volatile callable<scheduler> mainhook    public static scheduler main() {        function f  mainhook        if (f  null) {            return default_holderdefault_main // initialized once and lazily        }        try {            return mainhookcall()        } catch (throwable ex) {            throw exceptionhelperwraporthrow(ex)        }    }}``` || that doesnt allow decorating the default scheduler which is a common useof these init hooks on androidi know rxjava doesnt need this what im asking is if the change would beacceptable for symmetry as an added bonus: it means you no longer have toremember to call shutdown() on the original scheduler when returning adifferent one (which i bet 100% of people dont do and we dont check for)on wed sep 21 2016 3:40 am david karnok notifications@githubcom wrote:> i dont think rxjava needs this change we have standard java> executorservices backing the schedulers so their creation should always> succeed in a reasonable jdk implementation> > maybe you could combine androidschedulers the plugin and use a holder> class to defer the creation of the looper/handler if the function happens> to be null the first time main is invoked i can see this needs to change> the callback to callable and not rely on the default anymore> > class androidschedulers {>     static final class defaultholder {>         static final scheduler default_main  new handlerscheduler(>             new handler(loopergetmainlooper())))>     }> > ```> static volatile callable<scheduler> mainhook> > public static scheduler main() {>     function f  mainhook>     if (f  null) {>         return default_holderdefault_main // initialized once and lazily>     }>     try {>         return mainhookcall()>     } catch (throwable ex) {>         throw exceptionhelperwraporthrow(ex)>     }> }> ```> > }> > > you are receiving this because you authored the thread> reply to this email directly view it on github>  or mute the thread>   || > that doesnt allow decorating the default scheduler which is a common use> of these init hooks on androidthe op wanted to avoid depending on handler completely so he could test on desktop the only workaround i see is a boolean flag that when set invokes the function with null instead of loading the default android scheduler``` javaclass androidschedulers {    static final class defaultholder {        static final scheduler default_main  new handlerscheduler(            new handler(loopergetmainlooper())))    }    static volatile boolean nodefault    static volatile function<scheduler scheduler> mainhook    public static scheduler main() {        function f  mainhook        if (f  null) {            return default_holderdefault_main // initialized once and lazily        }        try {            if (nodefault) {                return fapply(null)            }            return fapply(default_holderdefault_main)        } catch (throwable ex) {            throw exceptionhelperwraporthrow(ex)        }    }}``` || my original proposal passes a `callable<scheduler>` to the function that is what im proposing || right sounds reasonable now how about a pr? || @akarnokd im the said op happy to put together a pr for the change || sure || closing via #4585 ||;1;0;make oninithandler functions lazy and enforce non null;"
4586;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add error assertion with predicate to testsubscriber and testobserver;added support for error assertions with to testsubscriber requested in #4498 to support custom error evaluation. removes the need to implement equals and hashcode in exceptions.;;4498.0;2x: add error assertion with predicate to testsubscriber and testobserver;added support for error assertions with to testsubscriber requested in #4498 to support custom error evaluation removes the need to implement equals and hashcode in exceptions;could you do it for testobserver as well? || sure i will update the pr ||   4586  ;matcher for testsubscriberasserterror();in order to test occurred error in subscriber we are using `testsubscriberasserterror()` however the method accepts either `throwable` or class so if we want to check the details of the thrown exception we need to have methods `equals()` and `hashcode()` in each exception but its a bad practicedoes it make sense to have a matcher for checking thrown exception and it?;not sure what you mean or how you imagine it but pr is welcome || closing via #4586 ||;1;0;add error assertion with predicate to testobserver (#4498);
4589;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add singleorerror  firstorerror  lastorerror & elementatorerror to observable and flowable;closes #4588;;0;2x: add singleorerror firstorerror lastorerror & elementatorerror to observable and flowable;closes #4588;there are javadoc mistakes btw || yup i saw them and ill fix them up i didnt execute that test locally (running all tests take forever on my local machine) ||   4589   oh this broke because of the error fixes/cc @jakewharton and @abersnaze on naming/functionality ||;;;;1;1;address issues;
4590;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: report errors from onerror to plugin when done;for the first one that i found i even wrote a test. then i started noticing more missing spots. if wanted i could port that one test to every operator that i touched. though i didn t really find tests testing that errors are propagated through the plugin api.;;0;2x: report errors from onerror to plugin when done;for the first one that i found i even wrote a test then i started noticing more missing spots if wanted i could port that one test to every operator that i touched though i didnt really find tests testing that errors are propagated through the plugin api;  4590   `testhelper` has a few generic test methods to check `maybe` and `single` the same pattern could be extended to test these without duplicating that long method i was planning that as part of another run of coverage improvements but im behind with performance work too ||;;;;1;1;2x: report errors from onerror to plugin when done;
4592;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: unicastsubject fix onterminate;;;0;2x: unicastsubject fix onterminate;;  4592   leave this as is and ill think about it ||;;;;1;1;2x: unicastsubject fix onterminate;
4593;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: enhance npe messages;now all npe thrown internally are having this standard message;;0;2x: enhance npe messages;now all npe thrown internally are having this standard message;  4593  ;;;;1;1;2x: enhance npe messages;
4595;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: remove takefirst(predicate) in observable & flowable;;;0;2x: remove takefirst(predicate) in observable & flowable;;  4595  ;;;;1;1;2x: remove takefirst(predicate) in observable & flowable;
4597;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add missing @test annotation on tests;;;0;2x: add missing @test annotation on tests;;test you enabled failed ||   4597  **< ;;;;1;1;fix test;
4601;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: sync behaviour between unicastprocessor & unicastsubject + add a few test cases;;;0;2x: sync behaviour between unicastprocessor & unicastsubject + add a few test cases;;  4601  ;;;;1;1;2x: sync behaviour between unicastprocessor & unicastsubject + add a few test cases;
4602;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: benchmark just() and fromcallable() throughput;this pr adds benchmarks for measuring  just()  and  fromcallable()  when using  subscribeon    observeon  and  subscribeon().observeon()  with them. # benchmark baseline - i7 4770k  windows 7 x64  java 8u102  jmh 1.13 - throughput ops/s  larger is better ## just  (  ![image]( ## fromcallable  ![image](  ![image]( ## just vs. fromcallable  ![image](https://cloud.ent.com/assets/1269832/18817632/d7109ac0-8365-11e6-9936-e287477965e5.png);;0;2x: benchmark just() and fromcallable() throughput;this pr adds benchmarks for measuring `just()` and `fromcallable()` when using `subscribeon` `observeon` and `subscribeon()observeon()` with them# benchmark baseline- i7 4770k windows 7 x64 java 8u102 jmh 113- throughput ops/s larger is better## just( fromcallable![image]( just vs fromcallable![image](https://cloudentcom/assets/1269832/18817632/d7109ac0-8365-11e6-9936-e287477965e5png);  4602  ;;;;1;1;2x: benchmark just() and fromcallable() throughput;
4603;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: rxjavaplugins - don t pass null throwable down to error handler;;;0;2x: rxjavaplugins - dont pass null throwable down to error handler;;  4603  **< ;;;;1;1;2x: rxjavaplugins - dont pass null throwable down to error handler;
4604;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add flattenas{observable flowable} to single and maybe;this pr adds  single.flattenasobservable    single.flattenasflowable    maybe.flattenasobservable  and  maybe.flattenasflowable  to map a success value into an  iterable  sequence and stream it as  flowable  or  observable . it is more efficient than  single.toflowable().flatmapiterable() .;;0;2x: add flattenas{observableflowable} to single and maybe;this pr adds `singleflattenasobservable` `singleflattenasflowable` `maybeflattenasobservable` and `maybeflattenasflowable` to map a success value into an `iterable` sequence and stream it as `flowable` or `observable` it is more efficient than `singletoflowable()flatmapiterable()`;  4604   `flattenasflowable` `flattenasobservable`? ||;;;;1;1;2x: add flattenas{observableflowable} to single and maybe;
4606;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: verify same onnext / onerror null behavior across all subjects and processors;;;0;2x: verify same onnext / onerror null behavior across all subjects and processors;;  4606  ;;;;1;1;2x: verify same onnext / onerror null behavior across all subjects and processors;
4607;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: testsubscriber & testobserver add assertvalue(predicate);;;0;2x: testsubscriber & testobserver add assertvalue(predicate);;;;;;1;1;adjust;
4609;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: factor out typical testobserver/testsubscriber methods;this pr introduces a new abstract internal class  basetestconsumer  which now hosts the  assertx  methods of  testsubscriber  and  testobserver  which were duplicates before.;;0;2x: factor out typical testobserver/testsubscriber methods;this pr introduces a new abstract internal class `basetestconsumer` which now hosts the `assertx` methods of `testsubscriber` and `testobserver` which were duplicates before;the drawback is that the generated javadoc doesnt have the method documentation and doesnt reference `basetestconsumer` because its in the `internal` zone i can move it to the public zone so the javadoc links work:( ||   4609  ;;;;1;1;move basetestconsumer into the public so its javadoc is available;
4612;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: improve performance of observable.flatmapiterable;this pr improves the performance of  flatmapiterable  by inlining the consumption of the generated  iterable . the performance improvement comes from direct iteration and emission plus removing the overhead of the regular  flatmap  as such source mappings are inherently synchronous. ### benchmark  i7 4790  windows 7 x64  java 8u102  jmh 1.13  ops/s - bigger is better  (  10x overhead reduction in flattening a single element  iterable .  ![image](  half the overhead compared to (an already optimized)  flowable.flatmapiterable .  ![image](  nice improvement on the cross-range benchmark (stream 1 million element split into n outer and m inner elements where n \* m = 1 million):  ![image](  also quite better than  flowable.flatmapiterable .;;0;2x: improve performance of observableflatmapiterable;this pr improves the performance of `flatmapiterable` by inlining the consumption of the generated `iterable` the performance improvement comes from direct iteration and emission plus removing the overhead of the regular `flatmap` as such source mappings are inherently synchronous### benchmarki7 4790 windows 7 x64 java 8u102 jmh 113 ops/s - bigger is better( overhead reduction in flattening a single element `iterable`![image]( the overhead compared to (an already optimized) `flowableflatmapiterable`![image]( improvement on the cross-range benchmark (stream 1 million element split into n outer and m inner elements where n \* m  1 million):![image]( quite better than `flowableflatmapiterable`;  4612  ;;;;1;1;2x: improve performance of observableflatmapiterable;
4614;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add maybe.flatmapsingle;gave that implementation a try. feedback is welcome i think there are improvements that can be done.;;0;2x: add maybeflatmapsingle;gave that implementation a try feedback is welcome i think there are improvements that can be done;  4614  **< ;;;;1;1;fix generics;
4616;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add completable.andthen(maybesource);;;0;2x: add completableandthen(maybesource);;there is a compilation error || ah yes import is missing i still manually stage them and sometimes forget that one is needed since usually every package is already included with `*` ||   4616  ;;;;1;1;requested changes;
4617;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add single.flatmapmaybe;;;0;2x: add singleflatmapmaybe;;  4617  ;;;;1;1;2x: add singleflatmapmaybe;
4619;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: make compositeexcpetion thread-safe like 1.x and also fix some issues;right now compositeexcpetion has several issues: -  compositeexception(throwable exceptions)  doesn t deduplicate exceptions and flatten compositeexceptions like  compositeexception(iterable<? extends throwable> errors)  - if using  compositeexception(iterable<? extends throwable> errors)  to create compositeexception   suppress  cannot be used. -  suppress  doesn t update  cause . -  suppress  doesn t deduplicate exceptions and flatten compositeexceptions. -  suppress  and  throwable.addsuppressed  are pretty confusing for java 7+ users. without looking at the implementation  it s hard to figure out the differences.  this pr made the following changes: - remove  compositeexception.suppress  so that it s easy to make compositeexception thread-safe.   - this may cause some performance lost in some path rarely happening  e.g.  an excpetion is thrown from  onerror   but that s not a big deal.   - since  suppress  is removed  it doesn t make sense to create an empty compositeexception  so  isempty  is removed and defense codes are added. - defense codes for bad exceptions. - deduplicate excepctions and flatten compositeexceptions for  compositeexception(throwable... exceptions) .;;0;2x: make compositeexcpetion thread-safe like 1x and also fix some issues;right now compositeexcpetion has several issues:- `compositeexception(throwable exceptions)` doesnt deduplicate exceptions and flatten compositeexceptions like `compositeexception(iterable<? extends throwable> errors)`- if using `compositeexception(iterable<? extends throwable> errors)` to create compositeexception `suppress` cannot be used- `suppress` doesnt update `cause`- `suppress` doesnt deduplicate exceptions and flatten compositeexceptions- `suppress` and `throwableaddsuppressed` are pretty confusing for java 7+ users without looking at the implementation its hard to figure out the differencesthis pr made the following changes:- remove `compositeexceptionsuppress` so that its easy to make compositeexception thread-safe  - this may cause some performance lost in some path rarely happening eg an excpetion is thrown from `onerror` but thats not a big deal  - since `suppress` is removed it doesnt make sense to create an empty compositeexception so `isempty` is removed and defense codes are added- defense codes for bad exceptions- deduplicate excepctions and flatten compositeexceptions for `compositeexception(throwable exceptions)`;  4619  **< ;;;;1;1;2x: make compositeexcpetion thread-safe like 1x and also fix some issuesright now compositeexcpetion has several issues:- `compositeexception(throwable exceptions)` doesnt deduplicate exceptions and flatten compositeexceptions like `compositeexception(iterable<? extends throwable> errors)`- if using `compositeexception(iterable<? extends throwable> errors)` to create compositeexception `suppress` cannot be used- `suppress` doesnt update `cause`- `suppress` doesnt deduplicate exceptions and flatten compositeexceptions- `suppress` and `throwableaddsuppressed` are pretty confusing for java 7+ users without looking at the implementation its hard to figure out the differencesthis pr made the following changes:- remove `compositeexceptionsuppress` so that its easy to make compositeexception thread-safe  - this may cause some performance lost in some path rarely happening eg an excpetion is thrown from `onerror` but thats not a big deal  - since `suppress` is removed it doesnt make sense to create an empty compositeexception so `isempty` is removed and defense codes are added- defense codes for bad exceptions- deduplicate excepctions and flatten compositeexceptions for `compositeexception(throwable exceptions)`;
4621;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: notificationlite - reduce allocations;a lot of commonly used operators allocated an instance of  notificationlite  as a field in a subscriber but for no great type-safety benefit. i ve cut these fields by converting all instance methods of  notificationlite  to static methods and removing the  notificationlite.instance()  method.  the changes are trivial till you get to the  subjects  that would pass instances of  notificationlite  in methods of the  subjectsubscriptionmanager . still simple changes but reviewing these is a good idea.  rxjava2 goes a bit further in the internals of  notificationlite . i d like to leave changes to the internals beyond making methods static for another pr if appropriate.;;0;1x: notificationlite - reduce allocations;a lot of commonly used operators allocated an instance of `notificationlite` as a field in a subscriber but for no great type-safety benefit ive cut these fields by converting all instance methods of `notificationlite` to static methods and removing the `notificationliteinstance()` methodthe changes are trivial till you get to the `subjects` that would pass instances of `notificationlite` in methods of the `subjectsubscriptionmanager` still simple changes but reviewing these is a good idearxjava2 goes a bit further in the internals of `notificationlite` id like to leave changes to the internals beyond making methods static for another pr if appropriate;  4621  ;;;;1;1;notificationlite - reduce allocations;
4622;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: enable operator fusion in onbackpressurebuffer;this pr enables operator fusion in  onbackpressurebuffer . the main benefit is that given a non-backpressured source  using  observeon  now reuses  onbackpressurebuffer  s (un)bounded queue seamlessly.;;0;2x: enable operator fusion in onbackpressurebuffer;this pr enables operator fusion in `onbackpressurebuffer` the main benefit is that given a non-backpressured source using `observeon` now reuses `onbackpressurebuffer`s (un)bounded queue seamlessly;  4622  ;;;;1;1;2x: enable operator fusion in onbackpressurebuffer;
4625;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: replace  resource  observers with plain  disposable  observers in tests.;this makes the resource observers unused internally and i m curious as to whether they deserve to stick around in the public api. any thoughts?;;0;2x: replace resource observers with plain disposable observers in tests;this makes the resource observers unused internally and im curious as to whether they deserve to stick around in the public api any thoughts?;they are there to provide the resource support similar to 1x `subscriber` and `singlesubscriber` we could move them to rxjava2extensions || ah yes that makes sense ||   4625  ;;;;1;1;replace resource observers with plain disposable observers in tests;
4627;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: use predicates in basetestconsumer asserterror(class/throwable) to remove duplicate code  tests tweaks to remove few ide warnings;messages and error checking was duplicates between all three asserterror overloads.;;0;2x: use predicates in basetestconsumer asserterror(class/throwable) to remove duplicate code tests tweaks to remove few ide warnings;messages and error checking was duplicates between all three asserterror overloads;  4627   super odd traviss java 7 compiled it fine but 8u102 javac fails to compile it even though -source 16 is set eclipse complains about (u) ive restored (u) in master ||;;;;1;1;testobserver & testsubscriber tests cleanup to remove ide warnings;
4629;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add completable.fromrunnable();addresses #4628  > there s  maybe.fromrunnable  but  completable  is missing this method.;;4628.0;2x: add completablefromrunnable();addresses #4628> theres `maybefromrunnable` but `completable` is missing this method;  4629    thanks! ||;2x: completable missing fromrunnable;theres `maybefromrunnable` but `completable` is missing this method;pr welcome || closing via #4629 ||;1;0;2x: add completablefromrunnable();
4631;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: don t wrap with compositeexception when there is only one error;;;0;2x: dont wrap with compositeexception when there is only one error;;  4631  **< ;;;;1;1;dont wrap with compositeexception when there is only one error;
4632;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: clean up singleflatmap;;;0;2x: clean up singleflatmap;;  4632  ;;;;1;1;2x: clean up singleflatmap;
4636;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;update mockito to 2.1.0-rc.2;equivalent of #4634   but now for the 2.x branch.;;4634.0;update mockito to 210-rc2;equivalent of #4634  but now for the 2x branch;the test `ioreactivexmaybemaybetest > onterminatedetach` seems to be failing claiming there is a memory leak i sadly have no experience with this test to fix it || that test is a bit flaky (maybe the new mockito increased the base memory usage?) ill fix that test and rerun this one ||     thanks a lot and enjoy   ! || fyi mockito 210 has been released which is equivalent to 210-rc2 once again thanks a lot for using mockito    ||;upgrade mockito to 210-rc2;the second release candidate of mockito 2 has been released which is mostly backwards compatible with your code base i had to remove the deprecated usage of `matchers` and replace it with the new `mockito` equivalent matchers this solved several ambiguity issues where both `mockito` and `matchers` were imported in the same file other than that all tests were passing locally so lets see if ci agrees toothanks a lot for using mockito and if you have any feedback we are eager to hear from you!;any particular reason we should upgrade? mockito 11019 worked for us so far also why rc2 and not wait for final? || @akarnokd this pr allows us to verify the behaviour of mockito in the wild before the finalheres features that may be of interest :  || @akarnokd thank you for your response mockito 2 should be in general compatible with 11019 the main change in mockito 2 is using bytebuddy as mock maker engine bytebuddy is future proof and works on more recent java versions while it is also (almost) ready for java 9 cglib was sadly becoming outdated and had several issues we could not work aroundthis pr was mainly for us to investigate the impact of upgrading especially since we have published our release candidate we expect to release final in the next week i understand if you would rather wait a couple of days for the final releaseapart from the import changes it does seem some tests started failing on ci which we will take a look if this is an issue with mockito 2 in particular or a breaking change in its usagehopefully this addresses your concerns right now if you have more questions we are happy to answer them || > other than that all tests were passing locallystrange i get 4 deterministic failures when i run your code locally- it seems that `any(tclass)` no longer matches `null`- test that matched exception such as `onerror(any(nullpointerexceptionclass))` now get a different exception even stranger the tests expected the wrong exception all along yet never complained || ah i see `any(t)` no longer accepts nulls and `any(class<t>)` now actually checks for the type || @akarnokd yes they are failing for me locally now too i sadly have no explanation for why they werent earlieryes `any` rejects null now users were missing bugs because the matchers accepted too many values this also seems the case for the second point where types are actually checked || for 1x the allowing null is important so unless theres a way to accept nulls with mockito we cant move to 21 yet || @akarnokd luckily checking for null is as easy as `verify(observer times(1))onnext(null)`   the four failing tests should now be  with explicit checks for null as well as the correct types of exceptions ||   4634   generally speaking it is not an issue to disallow `null` also this allow more control api wise any family was broken in design in the 1x to avoid casts because of this we felt it was an important step to rework the any matchersheres the change about any family matchers- `<t> t any()` will matches anything including `null`- `t anyt()` / `<t> any(class<t>)` are aliases of `<t> isa(t)` will matches non-`null` object of given type eg :  - `int anyint()` wont match `null` (for integers) anymore  - `int anystring()` wont match `null` (for strings) anymore and will check the object is indeed a `string`  - `int anymap()` wont match `null` (for maps) anymore and will check the object is indeed a `map`  - `<t> list<t> anylistof(class<t>)` wont match `null` and will check the object is indeed a `list`signature have been reworked and is balanced between the worlds of jdk6 and jdk8 although favoring jdk8 compilerwe welcome your feed back on this ! || thanks for looking into this but i believe wed be better experimenting with this in the 2x branch and then apply the lessons learned in 1x with the final/ga of mockito 21 could you post a pr targeting 2x? || thanks for looking into this im closing this for now as may become conflicting in the meantime anyway once you release 21 im gladly redoing these changes on the fresh base ||;1;0;update mockito to 210-rc2;
4637;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: remove unused methods in basicfuseableobserver;;;0;2x: remove unused methods in basicfuseableobserver;;  4637   please next time on provide a short description of what you did in the pr even with trivial looking changes ;;;;1;1;2x: remove unused methods in basicfuseableobserver;
4639;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix mockito 2.1 changes using deprecated api of its own;anylistof()  is deprecated in mockito 2.1.0-rc.2 and the github diff can t show such uses.  (in addition  there was a missing  serialversionuid  in another pr.);;0;2x: fix mockito 21 changes using deprecated api of its own;`anylistof()` is deprecated in mockito 210-rc2 and the github diff cant show such uses(in addition there was a missing `serialversionuid` in another pr);  4639  ;;;;1;1;2x: fix mockito 21 changes using deprecated api of its own;
4641;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: safesubscriber not to call rxjavahooks before delivering the original error.;before the introduction of  rxjavahooks   the  safesubscriber._onerror  called the original error handler with the exception it received which was by default an empty handler. the default  rxjavahooks.onerror  behavior  however is to signal errors to the uncaught exception handler of the caller thread which leads to unnecessary logging or app crashes even though the error itself is to be handled properly.  this pr restores the  safesubscriber._onerror  to skip the  rxjavahooks  and call the original handler directy so old tracking code should still get all safe error while newer hooking doesn t get called.  related: #4332.;;4332.0;1x: safesubscriber not to call rxjavahooks before delivering the original error;before the introduction of `rxjavahooks` the `safesubscriber_onerror` called the original error handler with the exception it received which was by default an empty handler the default `rxjavahooksonerror` behavior however is to signal errors to the uncaught exception handler of the caller thread which leads to unnecessary logging or app crashes even though the error itself is to be handled properlythis pr restores the `safesubscriber_onerror` to skip the `rxjavahooks` and call the original handler directy so old tracking code should still get all safe error while newer hooking doesnt get calledrelated: #4332;  4641   /cc @dlew || lgtm thanks for doing this ||;rxjavahooksonerror() catches all throwables (not just undeliverable ones);the `rxjavahooksonerror()` documentation says:> consume undeliverable throwables (acts as a global catch)however it consumes deliverable `throwables` just as much for example `safesubscriber_onerror()` immediately calls it ([source]( whether theres an onerror set for the subscriber or noteither the documentation is wrong (and it should say it consumes _all_ `throwables`) or the behavior is wrong;the behavior of `safesubscriber` is wrong but many rely on this property already || would it make sense to have a second hook that is _really_ just for undelivered `throwables`? that would be handy || maybe `safesubscriber` could call `rxjavapluginshandleerror()` again skipping `rxjavahooks` entirely || that would work for me - want a pr? || sure || see #4641 || closing via #4641 ||;1;0;1x: safesubscriber not to call rxjavahooks before delivering theoriginal error;
4645;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x signal npe observableamb flowableamb;this pr addresses #4640;;464.0;2x signal npe observableamb flowableamb;this pr addresses #4640;  4645  **< ;(question) is it right that rxobservablesblockingobservablelast() returns null when the observable is empty?;now `rxobservablesblockingobservablelast()` returns `null` when the observable is empty however `null` is a valid value in an observable so when `last` returns `null` we can not make a distinction between these two situations i think throwing an `indexoutofboundexception` is more reasonable;have  in #470 ||;1;0;signal npe observableamb flowableamb;
4647;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: merge ambarray and ambiterable into amb for single  maybe and completable types;this pr addresses #4633 - merge singleambarray and singleambiterable operators into singleamb - merge maybeambarray and maybeambiterable operators into maybeamb - merge completableambarray and completableambiterable operators into completableamb;;4633.0;2x: merge ambarray and ambiterable into amb for single maybe and completable types;this pr addresses #4633- merge singleambarray and singleambiterable operators into singleamb- merge maybeambarray and maybeambiterable operators into maybeamb- merge completableambarray and completableambiterable operators into completableamb;  4647  **< ;2x operators reactivetype::ambarray + reactivetype::ambiterable vs reactivetype::amb;it seems that for the implementation of the operators `ambarray` and `ambiterable` different strategies have been adopted depending on the reactive type - `single` uses `singleambarray` and `singleambiterable`- `maybe` uses `maybeambarray` and `maybeambiterable`- `completable` uses `completableambarray` and `completableambiterable`- `observable` uses `observableamb`- `flowable` uses `flowableamb`i propose to adopt the same approach for `single` `maybe` and `completable` merging xambarray and xambiterable into one single class xamb just like `observable` and `flowable`i think this will increase the test coverage for the internal operators should i create a pr?;sure || im following the `flowableamb` operator implementation to create the singleamb operator implementation regarding the conversion of the `iterable` to array `flowableamb```` javaif (sources  null) {    sources  new publisher[8]    for (publisher<? extends t> p : sourcesiterable) {        if (count  sourceslength) {            publisher<? extends t> b  new publisher[count + (count >> 2)]            systemarraycopy(sources 0 b 0 count)            sources  b        }        sources[count++]  p    }}```if the `sourcesiterable` has less elements than 8 `sources` array will contain null references it seems to be fine for `flowableamb` somehow it will remove or ignore the null references later `singleamb` (current adaptation of singleambarray)``` javaif (sources  null) {    sources  new singlesource[8]    int count  0    for (singlesource<? extends t> element : sourcesiterable) {        if (count  sourceslength) {            singlesource<? extends t> b  new singlesource[count + (count >> 2)]            systemarraycopy(sources 0 b 0 count)            sources  b        }        sources[count++]  element    }}```but thats not the case for `singleamb` operator this class validates that none of the sources value is null  so i will need to reduce the value of the initial size of  sources to 1 or remove all the null references at some point laterbut all this overhead could be avoided just converting internally from array to `iterable` and work always with `iterable``arraysaslist(sources)`is there any particular reason for not be doing that (performance?)? and what approach should i take for singleamb? > somehow it will remove or ignore the nulljust look a further bit down to see that `count` is used for pre-creating the consumers and the subscribe loop only considers that many elements from the input array whose tail has nulls (but should have checked for null returned by the iterable and array)the separate implementations were there to reduce overhead and branching during subscription time null checks should be enforced everywhere || thanks @akarnokd for the explanationill change the for-each loop implementation for a classic loop using the `count` as part of the termination expression  ||;1;0;2x: merge ambarray and ambiterable into amb for single maybe and completable types;
4648;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: rework single internals to reduce overhead and stack depth;this pr makes the  single.onsubscribe  as the primary means to execute the subscribe action in  single  and former couple of reused  observable  operators are now recreated with  single.onsubscribe .  because  single  is now marked final  we can t remove the former  observable.operator  and  observable.onsubscribe  entry points (but may be deprecated in a separate pr).;;0;1x: rework single internals to reduce overhead and stack depth;this pr makes the `singleonsubscribe` as the primary means to execute the subscribe action in `single` and former couple of reused `observable` operators are now recreated with `singleonsubscribe`because `single` is now marked final we cant remove the former `observableoperator` and `observableonsubscribe` entry points (but may be deprecated in a separate pr);  4648  ;;;;1;1;remove auto-gen todo mark single(observableonsubscribe) deprecated;
4651;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;switch maybe and single to use their transformers in compose();4650;;4650.0;switch maybe and single to use their transformers in compose();4650;whoops forgot to update the tests will update in a sec || intellij user i presume? || indeed does (i presume ) eclipse do something to protect against this? || eclipse has an error view which doesnt obscure the project structure plus when one shows the breadcrumbs they get error icons indicating theres still something wrong (also the project tree gets error icons) so it is much harder to miss these kinds of errors  ||   4651   interesting ill have to check that out! ||;2x: should maybe and single have a corresponding transformers?;currently `maybecompose()` requires a `function<? super maybe<t> ? extends maybesource<r>>` and `singlecompose()` requires something similarwhile other types have `flowabletransformer` and `completabletransformer` would it make sense to bring them into the same pattern? aside from consistency early testing for me shows that the generics gymnastics involved in `maybe` and `single`s `function` approaches is a major headache as any parameterized stream type gets lost and requires manual specification forfeiting the ability to  reuse apisconsider rxlifecycle which historically has just returned an implementation of the required transformer``` javasomesingle    compose(rxlifecyclebind(this)forsingle())    subscribe()```this works for simple unparameterized types but breaks down when parameterized types come in![screenshot 2016-10-01 02 21 10]( java// same result with both single and maybe screenshot is maybe example below is single// the type is now a list<t> of some type tsomelistsingle    compose(confineto(this)forsingle())  // compiler error because r type instance not found    subscribe()```where `confineto` returns a bridging helper like this:``` javapublic static class lifecycletransformer2<t> implements flowabletransformer<t t> {  // delegate transformer whats currently returned by rxlifecyclebind()  private lifecycletransformer<t> delegate  public static <t> lifecycletransformer2<t> create(@nonnull lifecycletransformer<t> delegate) {    return new lifecycletransformer2<>(delegate)  }  private lifecycletransformer2(@nonnull lifecycletransformer<t> delegate) {    thisdelegate  delegate  }  public function<maybe<t> maybesource<t>> formaybe() {    return source -> {      observable<t> o  tov1observable(sourcetoflowable())      o  delegatecall(o)      return rxjavainteroptov2flowable(o)singleelement()    }  }  public function<? super ioreactivexsingle<t> ? extends singlesource<t>> forsingle() {    return new function<ioreactivexsingle<t> singlesource<t>>() {      @override      public singlesource<t> apply(ioreactivexsingle<t> source) throws exception {        single<t> o  tov1single(source)        o  (single<t>) delegateforsingle()call((single<object>) o)        return rxjavainteroptov2single(o)      }    }  }  public completabletransformer forcompletable() {    return source -> {      completable o  tov1completable(source)      o  delegateforcompletable()call(o)      return rxjavainteroptov2completable(o)    }  }  @override  public publisher<? extends t> apply(flowable<t> source) throws exception {    observable<t> o  tov1observable(source)    o  delegatecall(o)    return rxjavainteroptov2flowable(o)  }}````flowabletransformer` and `completabletransformer` work fine but the other two have been really tricky to nail down;we have those kind of transformers but they are not wired up to `compose` for some reason  (forgotten?) pr welcome || totally missed that they already existed done! -  || closing via #4651 ||;1;0;update compose() tests;
4654;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;upcast concurrenthashmap to map to avoid compatibility issue;resovles #4653  see http://stackoverflow.com/a/32955708/61158;;4653.0;upcast concurrenthashmap to map to avoid compatibility issue;resovles #4653see http://stackoverflowcom/a/32955708/61158;  4654  ;2x: possible 6x/android compatibility issue;if i have an android app targeting source compatibility 18 i get the following exception at runtime on a 70 device:```fatal exception: rxschedulerpurge-1     process: iosweerscatchupdebug pid: 29250     javalangnosuchmethoderror: no virtual method keyset()ljava/util/concurrent/concurrenthashmap$keysetview in class ljava/util/concurrent/concurrenthashmap or its super classes (declaration of javautilconcurrentconcurrenthashmap appears in /system/framework/core-libartjar)         at ioreactivexinternalschedulersschedulerpoolfactory$1run(schedulerpoolfactoryjava:69)         at javautilconcurrentexecutors$runnableadaptercall(executorsjava:428)         at javautilconcurrentfuturetaskrunandreset(futuretaskjava:278)         at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:273)         at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1133)         at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:607)         at javalangthreadrun(threadjava:761)```the exact line is:``` javafor (scheduledthreadpoolexecutor e : new arraylist<scheduledthreadpoolexecutor>(poolskeyset())) {  // chmkeyset returns keysetview in java 8+ false positive here```when i look at it in the debugger it is indeed a keysetview but im not sure what the issue is here let me know if this would be better served posting in rxandroidcc @jakewharton;interestingly if i breakpoint this line the rest of the app appears to run just fine and isnt blocked as soon as i let it pass though it crashes || java 8 changed the return type of `keyset` and it trips animalsniffer as well in theory by compiling with javac 7 there should be no binding to java 8s type there || doesnt that come at the expense of being able to target java 8 entirely though? || lets see if  works for us as well || while you are at this could you post a pr with the fix above? || looks like that  it when i test locally will upload a pr in a sec || closing via #4654 ||;1;0;fix imports remove now-unnecessary animalsniffer suppression;
4658;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: observable.compose to use observabletransformer;this changes the  observable.compose  type to  observabletransformer  to reduce the type-argument/inference problem. the other base types have been previously updated to their respective transfomer types.;;0;2x: observablecompose to use observabletransformer;this changes the `observablecompose` type to `observabletransformer` to reduce the type-argument/inference problem the other base types have been previously updated to their respective transfomer types;  4658  ;;;;1;1;2x: observablecompose to use observabletransformer;
4661;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: cleanup and coverage 10/03;- remove unused methods and classes - make sure  maybe.toflowable  and  maybe.toobservable  allows macro-fusion back to the original type - improve coverage of various components;;0;2x: cleanup and coverage 10/03;- remove unused methods and classes- make sure `maybetoflowable` and `maybetoobservable` allows macro-fusion back to the original type- improve coverage of various components;  4661  ;;;;1;1;2x: cleanup and coverage 10/03;
4663;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: cleanup and fixes 10/03-2;- more coverage - fix some composite exception ordering - fix a few bugs;;0;2x: cleanup and fixes 10/03-2;- more coverage- fix some composite exception ordering- fix a few bugs;  4663  ;;;;1;1;2x: cleanup and fixes 10/03-2;
4666;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: coverage and cleanup 10/04-1;- improve coverage - remove unused  unnecessary or impossible code paths - fix order of inner exceptions in the reported  compositeexception  in various operators -  maybe.ignoreelement()  now returns  completable;;0;2x: coverage and cleanup 10/04-1;- improve coverage- remove unused unnecessary or impossible code paths- fix order of inner exceptions in the reported `compositeexception` in various operators- `maybeignoreelement()` now returns `completable`;  4666  ;;;;1;1;2x: coverage and cleanup 10/04-1;
4667;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: flatmap{completable  maybe  single} operators;this pr adds  observable.flatmapcompletable(function<t  completablesource>)  and  flowable.flatmapcompletable(function<t  completablesource>)   both resulting in  completable  (+ support for fusing back to the original type).  **edit**  added  flatmapmaybe  and  flatmapsingle  variants to both  flowable  and  observable .;;0;2x: flatmap{completable maybe single} operators;this pr adds `observableflatmapcompletable(function<t completablesource>)` and `flowableflatmapcompletable(function<t completablesource>)` both resulting in `completable` (+ support for fusing back to the original type)**edit**added `flatmapmaybe` and `flatmapsingle` variants to both `flowable` and `observable`;the build gets killed at the jacocotestresults:```:jacocotestreportgradle/buildviatravissh: line 16:  2970 killed                  /gradlew -preleaseuselasttagtrue build```ive rerun it a couple of times maybe travis is overloaded at the moment ||   4667   updated with the remaining operators || thanks a lot for taking this one over @akarnokd  ||;;;;1;1;fix active counting race condition;
4669;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix javadoc for single.flatmapobservable;- wrong return type was described - some git merging information was added;;0;2x: fix javadoc for singleflatmapobservable;- wrong return type was described- some git merging information was added;;;;;1;1;2x: fix javadoc for singleflatmapobservable;
"4672;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x remove function from transformer interfaces to allow a single obj;this pull request removes function from the super type of the various transformer interfaces. while these are technically functions  the problem is that if they all extend function then you cannot have a single object instance that can implement multiple transformer interfaces. the goal is to be able to call a function that returns an object that can be passed to observable.compose or single.compose and so on.  this was an issue with rxlifecycle project. see this for more info: https://github.com/trello/rxlifecycle/issues/39;;0;2x remove function from transformer interfaces to allow a single obj;this pull request removes function from the super type of the various transformer interfaces while these are technically functions the problem is that if they all extend function then you cannot have a single object instance that can implement multiple transformer interfaces the goal is to be able to call a function that returns an object that can be passed to observablecompose or singlecompose and so onthis was an issue with rxlifecycle project see this for more info: https://githubcom/trello/rxlifecycle/issues/39;""/cc @jakewharton  || another cleanup is that some of the compose methods use paramater name transformer and some use composer should settle on one or the other ||   4672   whats the reasoning for the exception in the signatures? || the reasoning for the exception was that the previous version where they implemented function supported throwing exceptions so i wasnt trying to change the method signature (there was actually a test for it on one of the types which is why the first build failed)for the more general reasoning for why all the functional interfaces in rxjava2 declare throws exception see this section:  || cool thanks for the explanation! || should not a unit test be added to guarantee this behavior? || it seems i have to do that myself || how do you guys feel if all of the operators (completableoperator flowableoperator ) would change to this behavior too for consistency and for the same reasons @dalewking already stated  || they can be standalone just dont forget the javadoc || i am also thinking about this for the """"to"""" method by changing the xxxxxtransformer interfaces to be more general purpose and usable by both compose and to here is what i am suggesting as applied to observable and if it sounds good to you i will do a pr:the new observabletransformer:```/** * interface to transform observables used for composing and """"to"""" transformations * * @param <upstream> the upstream value type * @param <result> the transformation result type */public interface observabletransformer<upstream result> {    /**     * applies a function to the upstream observable and returns a new result with     * optionally different element type     * @param upstream the upstream observable instance     * @return the transformed result     * @throws exception in case the transformation throws checked exceptions will be wrapped     * into a runtimeexception     */    result apply(observable<upstream> upstream) throws exception}```compose and to methods:```@schedulersupport(schedulersupportnone)public final <r> observable<r> compose(observabletransformer<t observablesource<r>> composer) {        return wrap(to(composer))}@schedulersupport(schedulersupportnone)public final <r> r to(observabletransformer<t r> converter) {    try {        return converterapply(this)    } catch (throwable ex) {        exceptionsthrowiffatal(ex)        throw exceptionhelperwraporthrow(ex)    }}``` || yes || after having tried implementing what i showed above and seeing how many changes that required in the unit test i am not sure it is the best approach it may be better to introduce interfaces like `observablefunction<t r>` which signature wise is like `function<observable<t> r>` but not extending function that is used for the """"to"""" method and observabletransformer extends that interface where r is `observablesource<downstream>` interested in feedback || "";;;;1;1;fix missing exception declarations from transformers;"
4674;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add javadoc and unit test to the recently changed xtransformers;this pr adds the javadoc and crash-testing for each xtransformer interface changed by #4672.;;0;2x: add javadoc and unit test to the recently changed xtransformers;this pr adds the javadoc and crash-testing for each xtransformer interface changed by #4672;we may have to drop jacoco as it kills builds 1 out of 3 ||   4674  ;;;;1;1;use uppercase f;
4677;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: cleanups from making notificationlite stateless.;;;0;1x: cleanups from making notificationlite stateless;;;;;;1;1;cleanups from making notificationlite stateless;
4678;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix flatmapx calling spsclinkedarrayqueue.offer concurrently;i forgot to synchronize the offer part of the new flatmapx operators (since of course  spsc is for single producer only but here there could be concurrent non fast-path queueing of values).   (there is an mpsclinkedarrayqueue in jctools but i m not confident in it and don t want to use mpsclinkedqueue due to the node allocation.);;0;2x: fix flatmapx calling spsclinkedarrayqueueoffer concurrently;i forgot to synchronize the offer part of the new flatmapx operators (since of course spsc is for single producer only but here there could be concurrent non fast-path queueing of values) (there is an mpsclinkedarrayqueue in jctools but im not confident in it and dont want to use mpsclinkedqueue due to the node allocation);  4678  ;;;;1;1;2x: fix flatmapx calling spsclinkedarrayqueueoffer concurrently;
4681;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix flowable + single elementat and elementatorerror operators on empty sources;this will 4680 - elementatorerror(1) on an empty source just leaves the new single hanging without signalling onerror() - elementat(1) on an empty source just leaves the maybe hanging without signalling oncomplete() - i also noticed that elementat() with a default value on an empty source did not work either.;;4680.0;2x: fix flowable + single elementat and elementatorerror operators on empty sources;this will 4680- elementatorerror(1) on an empty source just leaves the new single hanging without signalling onerror()- elementat(1) on an empty source just leaves the maybe hanging without signalling oncomplete()- i also noticed that elementat() with a default value on an empty source did not work either;  4681   you may have to check the build and restart it a few times if it fails with `jacocotestreport` ||;2x: elementat operators in observable and flowable dont behave correctly on empty sources;`elementatorerror(1)` on an empty source just leaves the new single hanging without signalling `onerror()`:``` javaobservableempty()    elementatorerror(1)    test()    assertfailure(nosuchelementexceptionclass)````elementat(1)` on an empty source just leaves the maybe hanging without signalling `oncomplete()`:```observableempty()    elementat(1)    test()    assertresult()```just tested this against rc4 happy to fix this;sure || closing via #4681 ||;1;0;2x: fix flowable + single elementat and elementatorerror operators on empty sources;
4685;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: test static from methods and add maybe.fromsingle & fromcompletable;- add maybe.fromsingle by reusing maybefromsingle - add maybe.fromcompletable by resuing maybefromcompletable - remove anonymous classes in various operators - add tests for   - completable.fromaction()   - completable.fromcallable()   - completable.fromobservable()   - completable.frompublisher()   - completable.fromrunnable()   - completable.fromsingle()   - maybe.fromaction()   - maybe.fromcallable()   - maybe.fromcompletable()   - maybe.fromrunnable()   - maybe.fromsingle()   - single.fromcallable();;0;2x: test static from methods and add maybefromsingle & fromcompletable;- add maybefromsingle by reusing maybefromsingle- add maybefromcompletable by resuing maybefromcompletable- remove anonymous classes in various operators- add tests for  - completablefromaction()  - completablefromcallable()  - completablefromobservable()  - completablefrompublisher()  - completablefromrunnable()  - completablefromsingle()  - maybefromaction()  - maybefromcallable()  - maybefromcompletable()  - maybefromrunnable()  - maybefromsingle()  - singlefromcallable();  4685   anything missing here? i updated this pr on sunday with the requested changes ||;;;;1;1;2x: test static from methods and add maybefromsingle & fromcompletable;
"4686;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.: fix flatmapx over-cancellation in case of an inner error;a non-delayed error set the cancellation flag and thus any subsequent drain would just quit instead of delivering the error.  (and while i m at it  i ll try to figure out a way to not get killed by oomkiller).  reported in #4684.;;4684.0;2: fix flatmapx over-cancellation in case of an inner error;a non-delayed error set the cancellation flag and thus any subsequent drain would just quit instead of delivering the error(and while im at it ill try to figure out a way to not get killed by oomkiller)reported in #4684; ;200 rc4 errors get lost with flatmapsingle and singlefromcallable;""try the following code:```public static void main(final string args) {        observablefromarray(new string{""""1""""""""a""""""""2""""})flatmapsingle(new function<string singlesource<integer>>() {            @override            public singlesource<integer> apply(final string s) throws numberformatexception {                //return singlejust(integervalueof(s)) //this works                return singlefromcallable(new callable<integer>() {                    @override                    public integer call() throws numberformatexception {                        return integervalueof(s)                    }                })            }        })subscribe(new observer<integer>() {            @override            public void onsubscribe(final disposable d) {                systemoutprintln(""""subscribe"""")            }            @override            public void onnext(final integer value) {                systemoutprintln(""""value: """" + value)            }            @override            public void onerror(final throwable e) {                systemoutprintln(""""error: """" + e)            }            @override            public void oncomplete() {                systemoutprintln(""""complete"""")            }        })    }```the program will only output the value 1 the numberformatexception gets lost if i were to use singlejust the exception gets printed correctly"";does `singlefromcallable` work on its own? || yes if i subscribe just to the singlefromcallable onerror gets called i noticed that innererror and dispose get called on observableflatmapsingle before drainloop just returns because the cancelled flag is set || yes thats a bug || i cant fix this today but perhaps you or @vanniktech can do it just dont have the code call dispose but inline the cleanup code or factor that out into a method everybody calls note that this is likely affecting all 4 flatmapx || closing via #4686 ||;1;0;2: fix flatmapx over-cancellation in case of an inner error;"
4687;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add observable.rangelong & flowable.rangelong;will 4683 - adds observable.rangelong() - adds flowable.rangelong()  both implementations are copied same for the unit tests.  what should we do about the range overflow check? we could use bigdecimal to check that.;;4683.0;2x: add observablerangelong & flowablerangelong;will 4683- adds observablerangelong()- adds flowablerangelong()both implementations are copied same for the unit testswhat should we do about the range overflow check? we could use bigdecimal to check that;  4687  ;2x: observablerange(long start long count);id like to have a range of long values as an observable however only a range method with ints do exist is there a reason for this?the only way i could imagine doing this now would be by using `intervalrange` with a low period however that does not seem right;nobody wanted to have more than 2^31 elements and you can map an int to long via `map` || ive often wanted a range that wouldnt run out using 1x when i call ```observablerange(1 integermax_value)subscribe()```it completes in 6 seconds sure i can manufacture a `rangelong` myself but library support might be nice || pr welcome you may call it rangelong() to avoid overload problems down the line || alright will add it for flowable too || should i copy the existing classes and just them to work on long instead of int or should i make them reusable? || copy || closing via #4687 ||;1;0;fix observablerangelongtesttestrangewithoverflow5;
4689;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: coverage and cleanup 10/11-1;this pr enhances the coverage of  maybe  operators (run out of time for this batch  5 remaining) and fixes an npe bug in  maybe.doonevent  due to not saving the  disposable . some inner receivers no longer implement  disposable  as  isdisposed  is unreachable and not really necessary.  in addition  maybe.tocompletable  was removed in favor of  maybe.ignoreelement() .;;0;2x: coverage and cleanup 10/11-1;this pr enhances the coverage of `maybe` operators (run out of time for this batch 5 remaining) and fixes an npe bug in `maybedoonevent` due to not saving the `disposable` some inner receivers no longer implement `disposable` as `isdisposed` is unreachable and not really necessaryin addition `maybetocompletable` was removed in favor of `maybeignoreelement()`;  4689  ;;;;1;1;2x: coverage and cleanup 10/11-1;
4690;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: basetestconsumer add assertvalueat(index  predicate<t>);4688 - adds assertvalueat(index  predicate) to basetestconsumer;;4688.0;2x: basetestconsumer add assertvalueat(index predicate<t>);4688- adds assertvalueat(index predicate) to basetestconsumer;  4690  **< ;2x: basetestconsumer add assertvalueat(index predicate<t>);that one would check that the value at the given index matches the predicate also assertvalue(predicate<t>) could forward to the new method with the given index 0what are your thoughts?;fine with me || closing via #4690  ||;1;0;2x: basetestconsumer add assertvalueat(index predicate<t>);
4692;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: coverage  fixes and cleanup 10/11-2;- cover remaining  maybe  operators - cover  single  operators - cover some of the  completable  operators - fix missing  onsubscribe  calls - compact a few operator implementations - fix the order of inner throwables on certain  compositeexception  emissions;;0;2x: coverage fixes and cleanup 10/11-2;- cover remaining `maybe` operators- cover `single` operators- cover some of the `completable` operators- fix missing `onsubscribe` calls- compact a few operator implementations- fix the order of inner throwables on certain `compositeexception` emissions;  4692   it was sitting in the travis job queue ||;;;;1;1;2x: coverage fixes and cleanup 10/11-2;
4693;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: improve timer javadoc;javadoc was correct but not very helpful. had to look further down in the javadoc to the  @return  section to see what value was emitted.;;0;1x: improve timer javadoc;javadoc was correct but not very helpful had to look further down in the javadoc to the `@return` section to see what value was emitted;  4693  **< ;;;;1;1;improve timer javadoc;
4694;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x - improve timer javadoc;make it clearer what gets emitted (0l).;;0;2x - improve timer javadoc;make it clearer what gets emitted (0l);  4694  ;;;;1;1;2x - improve timer javadoc;
4695;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: compositeexception fix order of exceptions;after looking at #4692 i found a few more exceptions which were passed in the wrong order to compositeexception.;;0;2x: compositeexception fix order of exceptions;after looking at #4692 i found a few more exceptions which were passed in the wrong order to compositeexception;  4695  **< ;;;;1;1;take out completable classes;
4696;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: coverage and cleanup 10/12-1;- add coverage to remaining  completable  operators - fix inner throwable order for  completablepeek  - compact/rewrite a few operators;;0;2x: coverage and cleanup 10/12-1;- add coverage to remaining `completable` operators- fix inner throwable order for `completablepeek`- compact/rewrite a few operators;  4696   @vanniktech yeah would you like to do a pr? || ill include that in one that i was planning to push out anyways today which is a big bigger ~60 files || what are you changing in 60 files? || null cleanups ||;;;;1;1;2x: coverage and cleanup 10/12-1;
4699;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: clean up null usages by using objecthelper.requirenonnull;instead of using an if statement to check for  null    objecthelper.requirenonnull  will be used now. this reduces a lot of duplicated code. also i found a few places (mostly zip operators) where the wrong throwable was being onerror d.  in addition for one of the completable operators the compositeexception call has been fixed. in addition i found another one that was wrong.;;0;2x: clean up null usages by using objecthelperrequirenonnull;instead of using an if statement to check for `null` `objecthelperrequirenonnull` will be used now this reduces a lot of duplicated code also i found a few places (mostly zip operators) where the wrong throwable was being onerrordin addition for one of the completable operators the compositeexception call has been  in addition i found another one that was wrong;  4699  ;;;;1;1;2x: clean up null usages by using objecthelperrequirenonnull;
4701;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: coverage and cleanup 10/13-1;improve coverage of  subject s and  flowableprocessor s  remove impossible paths  cleanup code.;;0;2x: coverage and cleanup 10/13-1;improve coverage of `subject`s and `flowableprocessor`s remove impossible paths cleanup code;  4701  ;;;;1;1;2x: coverage and cleanup 10/13-1;
4705;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: coverage  cleanup fixes 10/14-1;- improve coverage of  observable  operators - remove impossible or unused code paths - fix  observable.flatmap  s dispose behavior and error accumulation;;0;2x: coverage cleanup fixes 10/14-1;- improve coverage of `observable` operators- remove impossible or unused code paths- fix `observableflatmap`s dispose behavior and error accumulation;  4705  ;;;;1;1;2x: coverage cleanup fixes 10/14-1;
4706;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: cleanup  coverage  fixes 10/14-2;- more  observable  operator coverage - enable fusion with  filter  and  fromcallable  - change order of size parameter in timed  buffer  and  window  operators - fix minor mistakes in operators;;0;2x: cleanup coverage fixes 10/14-2;- more `observable` operator coverage- enable fusion with `filter` and `fromcallable`- change order of size parameter in timed `buffer` and `window` operators- fix minor mistakes in operators;  4706  ;;;;1;1;fix npes;
4707;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix flowable.elementat on empty sources. plus sync tests;- fixes flowable.elementat on an empty source  - sync tests between observable & flowable elementat;;0;2x: fix flowableelementat on empty sources plus sync tests;- fixes flowableelementat on an empty source - sync tests between observable & flowable elementat;  4707  ;;;;1;1;2x: fix flowableelementat on empty sources plus sync tests;
4708;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: coverage  fixes  cleanup 10/15-1;- improve coverage of  observable  operators - remove unnecessary code paths - fix  publish(function)  latecommer behavior - remove  buffersize  overloads of  publish  as there is no need to buffer anything for an  observable  - simplify  observable.publish;;0;2x: coverage fixes cleanup 10/15-1;- improve coverage of `observable` operators- remove unnecessary code paths- fix `publish(function)` latecommer behavior- remove `buffersize` overloads of `publish` as there is no need to buffer anything for an `observable`- simplify `observablepublish`;  4708  ;;;;1;1;fix error message;
4710;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: remove checked exceptions from transformer interfaces.;these functions are for transforming the stream shape  not doing work. any operation that would throw a checked exception should happen inside the stream  not when shaping it.  closes #4709.;;4709.0;2x: remove checked exceptions from transformer interfaces;these functions are for transforming the stream shape not doing work any operation that would throw a checked exception should happen inside the stream not when shaping itcloses #4709;  4710  ;2x: remove checked exceptions from transformer interfaces?;now that transformers are not `function` extensions does it makes sense that they allow throwing checked exceptions? when a transformer is being invoked its job is taking an observable and _transforming_ it into another observable but not actually doing any real work thus it seems strange that you would ever encounter something that threw a checked exception in this operation it would be a sign that you need to move that work into the stream pipeline instead of the observable creation pipelinethis also makes code that has to deal with transformers annoying because they now have to handle (aka wrap and throw) these checked exceptionshappy to send a pr but wanted to get some thoughts first and make sure i wasnt missing anything;works for me both ways so its up to the community to decide || ok sent a pr for it no rush to merge if you want to wait for other opinions || im a fan of this change for the reason stated above - due to its nature a transformer should rarely (never?) be throwing a checked exception || i thought about it and couldnt find a reason to allow throwing thereclosing via #4710 ||;1;0;remove checked exceptions from transformer interfacesthese functions are for transforming the stream shape not doing work any operation that would throw a checked exception should happen inside the stream not when shaping it;
4711;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: decouple stream operators from function interface.;this allows a single class to implement itself as an operator for all stream types. a similar change was recently made to the transformer types.  from https://github.com/reactivex/rxjava/pull/4672#issuecomment-252417909.;;0;2x: decouple stream operators from function interface;this allows a single class to implement itself as an operator for all stream types a similar change was recently made to the transformer typesfrom https://githubcom/reactivex/rxjava/pull/4672#issuecomment-252417909;  4711  ;;;;1;1;decouple stream operators from function interfacethis allows a single class to implement itself as an operator for all stream types a similar change was recently made to the transformer types;
4712;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: coverage  cleanup  fixes 10/15-2;- more  observable  coverage - make  observable.sequenceequal  return  single<boolean>  - reimplement  observable.distinct()  - fix  observable.combinelatest  error management - remove or compact unused code paths - fix  observable.flatmap  maxconcurrency behavior with scalars  use of unbounded queue - fix  observable.timeinterval  not saving the  disposable;;0;2x: coverage cleanup fixes 10/15-2;- more `observable` coverage- make `observablesequenceequal` return `single<boolean>`- reimplement `observabledistinct()`- fix `observablecombinelatest` error management- remove or compact unused code paths- fix `observableflatmap` maxconcurrency behavior with scalars use of unbounded queue- fix `observabletimeinterval` not saving the `disposable`;  4712  ;;;;1;1;add missing header;
4714;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: test sync from observable to flowable 10/16-1;- copy the recent unit tests from  observable  to  flowable  - fix the same bugs - perform the same cleanups - compact the same operators - factor out fusion method and constants to  queuefuseable  - have  flowable.tolist(callable)  return  single;;0;2x: test sync from observable to flowable 10/16-1;- copy the recent unit tests from `observable` to `flowable`- fix the same bugs- perform the same cleanups- compact the same operators- factor out fusion method and constants to `queuefuseable`- have `flowabletolist(callable)` return `single`;  4714  ;;;;1;1;2x: test sync from observable to flowable 10/16-1;
"4716;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: fix subscribe(action1 [  action1]) to report isunsubscribed;the lambda version didn t report  isunsubscribed()  as before because of the removal of the  safesubscriber  wrapping. this pr makes sure it reports consistently again.  repored in: #4715  note that there is no  unsafesubscribe(singlesubscriber)  so a regular  subscribe(singlesubscriber)  by default won t report  isunsubscribed() == true  unless the implementation of  onsuccess  and  onerror  - controlled by the user - doesn t call  unsubscribe  on itself.;;4715.0;1x: fix subscribe(action1 [ action1]) to report isunsubscribed;the lambda version didnt report `isunsubscribed()` as before because of the removal of the `safesubscriber` wrapping this pr makes sure it reports consistently againrepored in: #4715note that there is no `unsafesubscribe(singlesubscriber)` so a regular `subscribe(singlesubscriber)` by default wont report `isunsubscribed()  true` unless the implementation of `onsuccess` and `onerror` - controlled by the user - doesnt call `unsubscribe` on itself;  4716  **< ;subscription#isunsubscribed of single keep false after onsuccess/onerror;""i updated from 120 to 121until 120 `subscription#isunsubscribed` return `true` after `onsuccess`but from 121 `subscription#isunsubscribed` keeps `false` even if `onsuccess` / `onerror` is calledis this a expected behavior change? if so sorry to file rude issuethis can reproduce with below simple code ``` javapublic class mainactivity extends appcompatactivity {    @override    protected void oncreate(bundle savedinstancestate) {        superoncreate(savedinstancestate)        setcontentview(rlayoutactivity_main)        final subscription subscription  singlecreate(new singleonsubscribe<boolean>() {            @override            public void call(singlesubscriber<? super boolean> singlesubscriber) {                try {                    threadsleep(1000)                } catch (interruptedexception e) {                    eprintstacktrace()                } finally {                    singlesubscriberonsuccess(true)                }            }        })                subscribeon(schedulersio())                observeon(androidschedulersmainthread())                subscribe(                        new action1<boolean>() {                            @override                            public void call(boolean aboolean) {                                toastmaketext(mainactivitythis """"success"""" toastlength_short)show()                            }                        }                        new action1<throwable>() {                            @override                            public void call(throwable throwable) {                                toastmaketext(mainactivitythis """"error"""" toastlength_short)show()                            }                        }                )        findviewbyid(ridcheck_subscription_button)setonclicklistener(new viewonclicklistener() {            @override            public void onclick(view v) {                boolean status  subscriptionisunsubscribed()                toastmaketext(mainactivitythis """"unsubscribed status: """" + status                        toastlength_short)show()            }        })    }}```thanks"";there were internal changes to `single` that got rid of the `safesubscriber` and with it the reporting on `isunsubscribed` if you dont call `unsubscribe` it doesnt report `true` on termination ill try to hunt down such cases || closing via #4716 ||;1;0;1x: fix subscribe(action1 [ action1]) to report isunsubscribed;"
4717;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: coverage and cleanup 10/17-1;a small set of coverage and cleanup of  observable  operators.;;0;2x: coverage and cleanup 10/17-1;a small set of coverage and cleanup of `observable` operators;  4717  ;;;;1;1;2x: coverage and cleanup 10/17-1;
4718;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: distinct operator - delegate null collection down to onerror;- returning null as a collection in the callable didn t go to onerror - adopted flowable & observable;;0;2x: distinct operator - delegate null collection down to onerror;- returning null as a collection in the callable didnt go to onerror- adopted flowable & observable;  4718  ;;;;1;1;2x: distinct operator - delegate null collection down to onerror;
4720;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: remove variance from the input source of retrywhen;the variance of the  retrywhen  operator doesn t infere properly with java 8. this pr removes the  ? extends  from the function s input  observable .  reported in: https://twitter.com/hanswurst315/status/788108336285753344;;0;2x: remove variance from the input source of retrywhen;the variance of the `retrywhen` operator doesnt infere properly with java 8 this pr removes the `? extends` from the functions input `observable`reported in: https://twittercom/hanswurst315/status/788108336285753344;;;;;1;1;2x: remove variance from the input source of retrywhen;
4723;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: coverage  fixes  enhancements  cleanup 10/18-1;- improve coverage of more  observable  operators - reduce allocation of  connectableobservable.connect(consumer)  and  connectableflowable.connect(consumer)  - enable fusion on  observable.observeon  - fix fusion of  observable.just  - remove  flatmapiterable(function  int)  overload and have  flatmapiterable(function)  use the flatten operator. - fix  observable.replay()  potential emission before  onsubscribe  call;;0;2x: coverage fixes enhancements cleanup 10/18-1;- improve coverage of more `observable` operators- reduce allocation of `connectableobservableconnect(consumer)` and `connectableflowableconnect(consumer)`- enable fusion on `observableobserveon`- fix fusion of `observablejust`- remove `flatmapiterable(function int)` overload and have `flatmapiterable(function)` use the flatten operator- fix `observablereplay()` potential emission before `onsubscribe` call;  4723  ;;;;1;1;2x: coverage fixes enhancements cleanup 10/18-1;
4725;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: remove asyncemitter deprecations;discussed in #4580;;0;1x: remove asyncemitter deprecations;discussed in #4580;  4725  ;;;;1;1;remove asyncemitter deprecations;
4729;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;merge flowableemitter.backpressuremode into backpressurestrategy;this is the implementation of #4727;;4727.0;merge flowableemitterbackpressuremode into backpressurestrategy;this is the implementation of #4727;  4729   i have implemented the changes from the code commentsill keep in mind to rely on code coverage in the futureshould i reply to the review comments directly ? || no need in this case ;2x why is flowableemitterbackpressuremode and backpressurestrategy not merged;why are the two enums not merged into one they both serve the same purpose and both places where they are used should have the same featuresalso because `backpressurestrategynone` does not exist i currently can not use a `bufferstrategy` on an `observable`i dont think this code is simple easy``` javaobservabletoflowable(backpressurestrategynone)onbackpressurebuffer(10 functionsempty_action backpressureoverflowstrategydrop_oldest)```;if you can make it work then pr welcome || closing via #4729 ||;1;0;cleanup code;
4730;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: coverage  fixes  cleanup  copy to flowable 10/19-1;- explain  observable.observeon  unboundedness - improve  observable  operator coverage - copy test methods over to  flowable  operators - apply fixes to  flowable  operators - add missing calls to  rxjavaplugins.onerror()  - add more time to rs tck test of  observeon;;0;2x: coverage fixes cleanup copy to flowable 10/19-1;- explain `observableobserveon` unboundedness- improve `observable` operator coverage- copy test methods over to `flowable` operators- apply fixes to `flowable` operators- add missing calls to `rxjavapluginsonerror()`- add more time to rs tck test of `observeon`;  4730  ;;;;1;1;2x: coverage fixes cleanup copy to flowable 10/19-1;
4731;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: delegate null collections down to onerror in tolist;- if null from a collection supplier is returned delegate to onerror - adapted flowable & observable - unified exception message;;0;2x: delegate null collections down to onerror in tolist;- if null from a collection supplier is returned delegate to onerror- adapted flowable & observable- unified exception message;  4731  ;;;;1;1;2x: delegate null collections down to onerror in tolist;
4732;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: coverage  minor fixes  cleanup 10/19-2;- improve coverage of a few  observable  operators - move some classes into their solo user parent class -  checkdisposed  now calls  dispose / cancel  twice to have better conditional coverage of those methods;;0;2x: coverage minor fixes cleanup 10/19-2;- improve coverage of a few `observable` operators- move some classes into their solo user parent class- `checkdisposed` now calls `dispose`/`cancel` twice to have better conditional coverage of those methods;travis still waiting for a vm ||   4732  ;;;;1;1;2x: coverage minor fixes cleanup 10/19-2;
4736;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: cleanup  fixes  coverage 10/20-1;- finished covering  observable  operators to a reasonable level (the remaining are either impossible or only reachable by probabilistic race) - synced operator coverage between  observable  and  flowable  - started covering  flowable  operators - cleaning up a few  flowable  operators (cache  concatmap) - fix  onbackpressurebuffer(long  action  bufferoverflowstrategy)  return type - fix  concatmapdelayerror  wrong barrier mode selected;;0;2x: cleanup fixes coverage 10/20-1;- finished covering `observable` operators to a reasonable level (the remaining are either impossible or only reachable by probabilistic race)- synced operator coverage between `observable` and `flowable`- started covering `flowable` operators- cleaning up a few `flowable` operators (cache concatmap)- fix `onbackpressurebuffer(long action bufferoverflowstrategy)` return type- fix `concatmapdelayerror` wrong barrier mode selected;  4736  ;;;;1;1;2x: cleanup fixes coverage 10/20-1;
4738;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: coverage  fixes  cleanup 10/20-2;i cut this short so there is time for the **2.0.0-rc release preparations**. - introduce  simpleplainqueue  where  poll  doesn t throw  avoiding the need for try-catches where the queue is one of the standard lock-free queues. - fix  flatmap  error  cancellation and resource management. - coverage of some  flowable  operators - removal of impossible and unused code paths.;;0;2x: coverage fixes cleanup 10/20-2;i cut this short so there is time for the **200-rc release preparations**- introduce `simpleplainqueue` where `poll` doesnt throw avoiding the need for try-catches where the queue is one of the standard lock-free queues- fix `flatmap` error cancellation and resource management- coverage of some `flowable` operators- removal of impossible and unused code paths;;;;;1;1;fix generate not saving the state;
4742;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: coverage  fixes  cleanup 10/21-1;- fix  flowable.materialize()  terminal signal emission in face of backpressure - fix  flowable.onerrorreturn()  terminal signal emission in face of backpressure - cleanup  flowable.publish()  and enable operator fusion on its input - fix  flowable.flatmapsingle()  and  flowable.flatmapmaybe()  termination detection - compact  flowable.blockingsubscribe()  and  observable.blockingsubscribe()  - compact  flowable.subscribeon();;0;2x: coverage fixes cleanup 10/21-1;- fix `flowablematerialize()` terminal signal emission in face of backpressure- fix `flowableonerrorreturn()` terminal signal emission in face of backpressure- cleanup `flowablepublish()` and enable operator fusion on its input- fix `flowableflatmapsingle()` and `flowableflatmapmaybe()` termination detection- compact `flowableblockingsubscribe()` and `observableblockingsubscribe()`- compact `flowablesubscribeon()`;there seems to be a problem between github and travis at the moment ||   4742  ;;;;1;1;2x: coverage fixes cleanup 10/21-1;
4745;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: remove unused helper class previously used by extend().;;;0;1x: remove unused helper class previously used by extend();;;;;;1;1;remove unused helper class previously used by extend();
"4747;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: distinctuntilchanged to store the selected key instead of the value;fix  distinctuntilchanged  to store the selected key instead of the input value.  reported in #4743;;4743.0;2x: distinctuntilchanged to store the selected key instead of the value;fix `distinctuntilchanged` to store the selected key instead of the input valuereported in #4743; ;[200-rc5] distinctuntilchanged doesnt work nicely with mutable objects; javapublic class main {  static class header {    string name  """"key""""    string value  """"one""""  }  public static void main(string args) {    final header header  new header()    final behaviorsubject<header> subject  behaviorsubjectcreatedefault(header)    subjectdistinctuntilchanged(new function<header object>() {      @override      public object apply(final header header) throws exception {        return headervalue      }    })subscribe(new consumer<header>() {      @override      public void accept(final header header) throws exception {        systemoutprintln(""""name  """" + headername + """" value  """" + headervalue)      }    })    headervalue  """"two""""    subjectonnext(header)  }}```output:```name  key value  one```expected output:```name  key value  onename  key value  two```the same code used to work as expected with 200-rc4 and all previous rxjava versions""; via #4747 ||;1;0;fix null test and whitespaces;"
4749;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;new 2.x marble diagrams;adds some new marble diagrams and adjusts some for operators that now return single/maybe/completable where they used to return observable in 1.x.;;0;new 2x marble diagrams;adds some new marble diagrams and adjusts some for operators that now return single/maybe/completable where they used to return observable in 1x;thanks @davidmgross ! ||;;;;1;1;new 2x marble diagrams;
4751;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix flowable.concatmapeager hang due to bad request management;flowable.concatmapeager  s drain loop when encountering a finished inner jumped back to the beginning of the loop but disregarded the potentially changed request amount and just stopped emitting. the fix is to use the typical request management approach of reading the current request at the beginning of the loop and then committing the emission amount before trying to leave the loop.  related: #4620  in addition  testhelper.asserterror  has been changed to attach the whole unexpected exception to the  assertionerror .;;4620.0;2x: fix flowableconcatmapeager hang due to bad request management;`flowableconcatmapeager`s drain loop when encountering a finished inner jumped back to the beginning of the loop but disregarded the potentially changed request amount and just stopped emitting the fix is to use the typical request management approach of reading the current request at the beginning of the loop and then committing the emission amount before trying to leave the looprelated: #4620in addition `testhelperasserterror` has been changed to attach the whole unexpected exception to the `assertionerror`;  4751  ;flowableconcatmapeagertest > testasynchronousrun failed;```ioreactivexinternaloperatorsflowableflowableconcatmapeagertest > testasynchronousrun failed    javalangassertionerror: value counts differ expected: 2000 actual: 1184 (latch  1 values  1184 errors  0 completions  0)        at ioreactivexobserversbasetestconsumerfail(basetestconsumerjava:132)        at ioreactivexobserversbasetestconsumerassertvaluecount(basetestconsumerjava:389)        at ioreactivexinternaloperatorsflowableflowableconcatmapeagertesttestasynchronousrun(flowableconcatmapeagertestjava:583)```;closing via #4751 ||;1;0;missed negation of check;
4752;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add more new marble diagrams & update old ones;;;0;add more new marble diagrams & update old ones;;;;;;1;1;add more new marble diagrams & update old ones;
4754;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: remove some unused fields;remove some unused fields that are either - present in their parent class - not set;;0;2x: remove some unused fields;remove some unused fields that are either- present in their parent class- not set;  4754  ;;;;1;1;2x: remove some unused fields;
4755;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix window-timed test leaking an mbe that affects unrelated tests;the  flowablewindowwithtimetest.restarttimermany  did not wait for its source to receive the cancellation and subsequent tests could delay this cancel.  related: #4750;;0;2x: fix window-timed test leaking an mbe that affects unrelated tests;the `flowablewindowwithtimetestrestarttimermany` did not wait for its source to receive the cancellation and subsequent tests could delay this cancelrelated: #4750;  4755  ;;;;1;1;2x: fix window-timed test leaking an mbe that affects unrelated tests;
4757;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: add cache() to single;#4702  uses the same test as the observable one.;;4702.0;1x: add cache() to single;#4702uses the same test as the observable one;  4757   sorry im late to the party here this seems to be rxjava1x only is this going to reach 2x ? || its in 2 || uupps right ! thanks ! ||;1x: replaying a `single` to future subscribers cache() missing?;as far as i can tell there isnt a way to replay a `single`s result to future subscribers without re-subscribing upstream or round-tripping through an `observable` for `cache()` this has come up 3 times in various channels with no good answer foundis `cache()` missing? or is there some other way of doing this that i cant see?;so far nobody complained about it for 1x pr welcome || closing via #4757 ||;1;0;update javadoc;
4760;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add single.fromobservable(observablesource);- adds an overload to create a single from an observablesource;;0;2x: add singlefromobservable(observablesource);- adds an overload to create a single from an observablesource;;;;;1;1;add null test;
4761;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: cleanup  fixes  coverage 10/24-1;- remove unused or unnecessary code paths. - fix cancellation bugs in  flowable  operators. - unify  mapnotification    materialize    onerrorreturn  last element backpressure under the same helper class. - move  flowableblockingiterator  into  flowableblockingiterable . - reuse parts of  flowablesequenceequal  in  flowablesequenceequalsingle .;;0;2x: cleanup fixes coverage 10/24-1;- remove unused or unnecessary code paths- fix cancellation bugs in `flowable` operators- unify `mapnotification` `materialize` `onerrorreturn` last element backpressure under the same helper class- move `flowableblockingiterator` into `flowableblockingiterable`- reuse parts of `flowablesequenceequal` in `flowablesequenceequalsingle`;;;;;1;1;add missing default method;
4763;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: cleanup & coverage 10/24-2;- better coverage of  flowable  operators - cleanup of operator internals - better coverage of standard schedulers. - rewrite of  takeuntil  to avoid  onsubscribe()  races.;;0;2x: cleanup & coverage 10/24-2;- better coverage of `flowable` operators- cleanup of operator internals- better coverage of standard schedulers- rewrite of `takeuntil` to avoid `onsubscribe()` races;  4763  ;;;;1;1;2x: cleanup & coverage 10/24-2;
4766;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: cleanup  fixes and coverage 10/25;this is the last part of my dedicated coverage improvement run. - update code paths and remove unnecessary and unused parts. - fix  skipuntil  lifecycle and concurrency properties. - fix  concatmapeager  error management. -  flowable.scan(t  bifunction)  now emits the initial value only when the upstream signals an event. this has the effect that even if there is a downstream request  the initial value won t get emitted. this change reduces the overhead of the operator greatly.;;0;2x: cleanup fixes and coverage 10/25;this is the last part of my dedicated coverage improvement run- update code paths and remove unnecessary and unused parts- fix `skipuntil` lifecycle and concurrency properties- fix `concatmapeager` error management- `flowablescan(t bifunction)` now emits the initial value only when the upstream signals an event this has the effect that even if there is a downstream request the initial value wont get emitted this change reduces the overhead of the operator greatly;  4766  ;;;;1;1;2x: cleanup fixes and coverage 10/25;
"4767;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: rename backpressurestrategy.none to missing;as discussed in #4643.;;4643.0;2x: rename backpressurestrategynone to missing;as discussed in #4643;  4767  **< ;2x: remove/hide flowable backpressuremodenone?;so we have `observable` for nbp streams and `flowable` for bp streamswhat im afraid of is that a lot of users will do `flowablecreate(emitter backpressuremodenone)` or `toflowable(backpressuremodenone)` while in fact they should use `observable`the only correct usage of `backpressuremodenone` i see at the moment is rs interop since `observable` is not rs type (please share other valid cases that cant be changed to `observable`)i might be overworrying of course so opinions of project members are very appreciated;""the `none` can be used if you use `onbackpressurebuffer(int capacity)` or other parametrized `onbackpressurexxx` method the default enums only support the parameterless behavior of `onbackpressurexxx`s || ```        /**         * onnext events are written without any buffering or dropping         * downstream has to deal with any overflow         * <p>useful when one applies one of the custom-parameter onbackpressurexxx operators         */        none``` || yeah i see hm but isnt it kind of weird to create flowable with nobackpressure strategy and apply afterwards if you can accept it from clientand use it at creation time?on 29 sep 2016 5:12 pm """"david karnok"""" notifications@githubcom wrote:> ```>     /**>      * onnext events are written without any buffering or dropping>      * downstream has to deal with any overflow>      * <p>useful when one applies one of the custom-parameter onbackpressurexxx operators>      */>     none> ```> > > you are receiving this because you authored the thread> reply to this email directly view it on github>  or mute the thread>   || so what should we do about it? i still think that its kind of weird to have such easily-available api that can and probably will be misused pretty often and as a result will lead to `missingbackpressureexception` though one of the ideas of `flowable` was to move backpressure to type level and force users to handle it while `backpressuremodenone` basically disables thatclosest semantic problem i can think of is `observablecreate()` in rxjava v1 which was misused so often that we had to """"deprecate"""" it> the none can be used if you use onbackpressurebuffer(int capacity) or other parametrized onbackpressurexxx method the default enums only support the parameterless behavior of onbackpressurexxxs@akarnokd what if we add apis to apply parametrized `onbackpressurexxx()` at creation time?cc @jakewharton weve discussed that offline a little bit and i would like to invite you to discussion here || > what if we add apis to apply parametrized onbackpressurexxx() at creation time?either you supply a varargs of options or introduce 8+ overloads> i still think that its kind of weird to have such easily-available api that can and probably will be misused pretty oftenhere the user puts in the mode parameter and is explicit so if someone reports a missingbackpressureexception and posts a create( none) thats a clear indication of the user error || > here the user puts in the mode parameter and is explicit so if someone reports a missingbackpressureexception and posts a create( none) thats a clear indication of the user erroryes but im not sure that a lot of users will understand that `backpressuremodenone` basically ` missingbackpresssureexception`and even worse that when you use already created `flowable` you cant be sure that it handles backpressure which basically `` situation with `observable` in rxjava v1 || lot of users copy from examples and so far almost all 2x create examples used `backpressuremodebuffer`> you cant be sure that it handles backpressureif you wrote the `create()` then its on you if you get a `flowable` somewhere and fails you can check the source code of the provider and apply the missing operator if no source available complain to the developer who created it || cant completely agree ok what about renaming `backpressuremodenone` to something that mentions consequences of its usage? im bad at naming: `unsafe_none` etc || if you find a good name || variants from my team: `missing` `unsafe_none` `todo` `up_to_downstream`i really like `missing` because it matches `missingbackpressureexception` || unsupportedon wed oct 5 2016 7:05 am artem zinnatullin notifications@githubcomwrote:> variants from my team: missing unsafe_none todo up_to_downstream> > i really like missing because it matches missingbackpressureexception> > > you are receiving this because you were mentioned> > reply to this email directly view it on github>  or mute the thread>   || alright `missing` is compact enough pr welcome || closing via #4767 || "";1;0;rename backpressurestrategynone to missing;"
4770;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: allow subscribeon to work with blocking create;when running a blocking emission in  flowable.create  with  subscribeon   the default behavior of  subscribeon  is to schedule downstream requests onto the same thread. unfortunately  the blocking emission prevents the backing threadpool the  create  from accumulating that request amount leading to either buffer bloat or dropped emissions till the very end of the sequence.  this pr introduces a  nonscheduledrequests  parameter to  subscribeon  that simply calls the upstream s  request()  from the caller s thread without scheduling it. the parameter is not exposed to the surface api but the  subscribeon  operator does an  instanceof  check to see if the upstream type is  flowablecreate .  note that this requires a direct upstream  create  and any intermediate operator re-enables the default behavior. it is possible to traverse the upstream graph to locate a  flowablecreate  but it has relatively high cost and thus penalizing all  subscribeon  usages.  related: #4735;;0;2x: allow subscribeon to work with blocking create;when running a blocking emission in `flowablecreate` with `subscribeon` the default behavior of `subscribeon` is to schedule downstream requests onto the same thread unfortunately the blocking emission prevents the backing threadpool the `create` from accumulating that request amount leading to either buffer bloat or dropped emissions till the very end of the sequencethis pr introduces a `nonscheduledrequests` parameter to `subscribeon` that simply calls the upstreams `request()` from the callers thread without scheduling it the parameter is not exposed to the surface api but the `subscribeon` operator does an `instanceof` check to see if the upstream type is `flowablecreate`note that this requires a direct upstream `create` and any intermediate operator re-enables the default behavior it is possible to traverse the upstream graph to locate a `flowablecreate` but it has relatively high cost and thus penalizing all `subscribeon` usagesrelated: #4735;  4770   options:- ignore the issue- teach users to have `create( missing)subscribeon()onbackpressuredrop()` instead- add explicit parameter to subscribeon() and teach users- add more extensive lookupthis impacts only those who have busy loop inside `create` instead of using `generate` users converting other async api or callback style sources are not affected as those dont block the create() || this seems like a patchwork fix for what is a deeper problem which really should be  in a more user-visible manner its is very possible that users are using other operators between create and subscribeon and hardcoding to create seems to be simply deferring the problem to those other cases || blocking and backpressure dont play nice together another fix could forcefully include a `scheduler` parameter into `create` and as such cant be overridden by applying another `subscribeon` ||;;;;1;1;2x: allow subscribeon to work with blocking create;
"4777;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: support observable.test();the new method chaining  testsubscriber  in 2.x is too good not to have in 1.x as well (while i wait for 2.x to mature and to make my existing unit tests less verbose).      java observable   .just(1)   .test()   .assertvalue(1)   .assertcompleted()        observable.test()  returns a  testsubscriber2  that wraps a  testsubscriber  and enables method chaining where it can.  i ve added tests to get to 100% test coverage though i ve been pretty slap-dash about testing some of the details (for example i haven t tested that  awaitxxx  really does wait for stuff).  i ve noted it as  @since 1.2.3  but can update to 1.2.2 if you are happy to squeak it into the release.;;0;1x: support observabletest();the new method chaining `testsubscriber` in 2x is too good not to have in 1x as well (while i wait for 2x to mature and to make my existing unit tests less verbose)``` javaobservable  just(1)  test()  assertvalue(1)  assertcompleted()````observabletest()` returns a `testsubscriber2` that wraps a `testsubscriber` and enables method chaining where it canive added tests to get to 100% test coverage though ive been pretty slap-dash about testing some of the details (for example i havent tested that `awaitxxx` really does wait for stuff)ive noted it as `@since 123` but can update to 122 if you are happy to squeak it into the release;""  4777 - provides additional assertions but also introduce some limitations || @akarnokd @mydogtom i have been using this functionality in _rxjava-extras_ using `to(testinghelpertest())` for about five weeks it just seems too useful to miss out on natively (dont have to add extra library to pomxml add import put up with slightly less readable line in code)  discoverability is sorted for new users toofor anyone writing tests for their observables i think this is very attractive functionality to have natively and i was stoked to use it with rxjava 2note that my motivation for this is for writing tests in my projects (not rxjava 1x core though that would be nice too) i forgot to consider `completable` and `single` because i dont use them (the majority of our rxjava based code predates their existence) do they need special treatment (other than addition of a `test` method there)? || how about having an interface with the get and assert methods and the 3 test()s return it in an internal package then you can implement them and have delegates as necessary || > how about having an interface with the get and assert methods and the 3 test()s return it in an internal package then you can implement them and have delegates as necessaryyep i can do that || > how about having an interface with the get and assert methods and the 3 test()s return it in an internal package then you can implement them and have delegates as necessaryhaving extracted an interface the one implementation can serve all `test()` methods by subscribing to `completable` `single` or `observable` instances using `subscribe(subscriber)` how do you want the implementations to differ? || i think `test()` should be added also for `blockingobservable` || unnecessary testconsumer should have awaitterminalevent that blocks || testconsumer maybe not ideal because sounds like its a significantly different beast from a testsubscriber i prefer to retain the word subscriber in the name what about testsubscriberfluent? || `assertablesubscriber` || +1 for `testsubscriberfluent` because it reflects the main difference from `testsubscriber` - fluent api -1 for `assertablesubscriber` it doesnt provide any additional info (`testsubscriber` is also """"assertable"""")@akarnokd i still think that `blockingobservable` should have `test()` method lets assume that i encounter some legacy code that use `blockingobservable` (regardless its not recommended) i would like to be able write test first and refactor it afterwards (get rid of `blockingobservable`)   || @mydogtom  puts it well i think after all `assertablesubscriber` would provoke as many """"whats the difference?"""" questions as `testsubscriber2` `testsubscriberfluent` describes exactly what the class is ||  imports renamed `testsubscriber2` to `testsubscriberfluent` (though im not assuming the naming discussion has finished)squashed commits and rebased on latest 1x || `assertablesubscriber` should be an interface with all the relevant `assert` methods that any actual internal test class can implement on top of the respective receiver type > i think after all assertablesubscriber would provoke as many """"whats the difference?""""if this comes up we will answer that it is the base api interface for asserting a subscribers state for all 3 reactive typesi see confusion going the other way around: why `testsubscriber2` or `testsubscriberfluent` its prefix `testsubscriber` matches well `testsubscriber` itself || righto lets go with `assertablesubscriber` modified code and squashed commits || thanks @akarnokd made fixes and squashed commits || "";;;;1;1;add testsubscriber2 to provide method chained version of testsubscriber and support observabletest();"
"4783;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix observable.repeatwhen & retrywhen not disposing the inner;the  observer  that is subscribing to the  observable  returned by the handler function was not properly linked to the disposing of the end observer. this pr fixes it by making that  observer  do async  disposable  management and make sure the end  observer  receives a disposable list with both the main and the handler  disposable s.  the  flowable  versions worked properly but added unit tests to them regardless.  reported in #4782.;;4782.0;2x: fix observablerepeatwhen & retrywhen not disposing the inner;the `observer` that is subscribing to the `observable` returned by the handler function was not properly linked to the disposing of the end observer this pr fixes it by making that `observer` do async `disposable` management and make sure the end `observer` receives a disposable list with both the main and the handler `disposable`sthe `flowable` versions worked properly but added unit tests to them regardlessreported in #4782;  4783  ;[200] repeatwhen/retrywhen memory leak;""the following test case fails with `rxjava-200` but works fine with `121`:``` javapublic class repeatwhentest {  @test  public void shoulddisposeinnerobservable() {    final publishsubject<string> subject  publishsubjectcreate()    final disposable disposable  observablejust(""""leak"""")        repeatwhen(completions -> completionsswitchmap(ignore -> subject))        subscribe()    asserttrue(subjecthasobservers())    disposabledispose()    assertfalse(subjecthasobservers())  }}```"";""the same issue with `retrywhen`:``` javapublic class retrywhentest {  @test  public void shoulddisposeinnerobservable() {    final publishsubject<string> subject  publishsubjectcreate()    final disposable disposable  observableerror(new runtimeexception(""""leak""""))        retrywhen(errors -> errorsswitchmap(ignore -> subject))        subscribe()    asserttrue(subjecthasobservers())    disposabledispose()    assertfalse(subjecthasobservers())  }}``` || thanks ill investigate the reasons and post a fix the `flowable` variants seem to work || see #4783 || closing via #4783 || "";1;0;2x: fix observablerepeatwhen & retrywhen not disposing the inner;"
"4793;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix exceptions in javadoc;i ve corrected some javadocs for methods that check arguments using  objecthelper.requirenonnull(arg   message ) . it throws  nullpointerexception  instead of  illegalargumentexception   but as we know copy-pasting is an insidious thing.  );;0;2x: fix exceptions in javadoc;""ive corrected some javadocs for methods that check arguments using `objecthelperrequirenonnull(arg """"message"""")` it throws `nullpointerexception` instead of `illegalargumentexception` but as we know copy-pasting is an insidious thing )"";  4793  ;;;;1;1;2x: correct exceptions in single javadoc;"
4798;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;documentation updates;;;0;documentation updates;;ioreactivexjavadocwording > observabledocreferstoobservabletypes failed    javalangassertionerror: javalangruntimeexception: a/an typo flowable     at ioreactivexobservable (observablejava:11740)        at orgjunitassertfail(assertjava:88)        at ioreactivexjavadocwordingobservabledocreferstoobservabletypes(javadocwordingjava:418)ioreactivextextualaoran > checkfiles failed    javalangassertionerror: javalangruntimeexception:  an flowable     at ioreactivexobservable (observablejava:11740)        at ioreactivextextualaorancheckfiles(textualaoranjava:82) ||   #4798  into 2x  will> decrease coverage by _ ;;;;1;1;update observablejava;
4803;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix typo;;;0;fix typo;;  4803  ;;;;1;1;update observableemitterjava;
4810;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;subtle change in completable s documentation for retrywhen.;small change as discussed in #4809;;4809.0;subtle change in completables documentation for retrywhen;small change as discussed in #4809;  4810  ;1x and 2x javadoc for completables retrywhen differs from observable single and docs;while trying to use the `retrywhen` operator of the completable i had problems understanding the behaviour detailed in its javadoc:> returns a completable which given a publisher and when this completable emits an error delivers that error through an observable and the publisher should return a value indicating a retry in response or a terminal event indicating a terminationwhich highly differs from the documentation of observable single and the docs where the need of calling the provided observables onnext/onerror/oncompleted is more detailed:> returns an observable that emits the same values as the source observable with the exception of an {@code onerror} an {@code onerror} notification from the source will result in the emission of a {@link throwable} item to the observable provided as an argument to the {@code notificationhandler} function if that observable calls {@code oncomplete} or {@code onerror} then {@code retry} will call {@code oncompleted} or {@code onerror} on the child subscription otherwise this observable will resubscribe to the source observablei could prepare a pr for both 1x and 2x versions if needed;most people set up a flow inside the retrywhen so nobody calls `onnext` manually in there however the text should use a bit of a cleanup:> returns a completable which given a publisher and when this completable emits an error delivers that error through a **flowable** and the publisher should **signal** a value indicating a retry in response or a terminal event indicating a termination || subtle but meaningful change! :)@akarnokd would you prefer to do the change yourself or should i? || you are welcome to change 2x dont change 1x || @akarnokd any specific reason why not to change 1x? just curious || dont want to mix in 2x terminologyclosing via #4810 ||;1;0;subtle change in completables documentation for retrywhen;
4815;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix typo in javadoc of maybe::tosingle;;;0;fix typo in javadoc of maybe::tosingle;;  4815  ;;;;1;1;fix typo in javadoc of maybe::tosingle;
4819;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: observable.repeatwhen fix for onerror;observable.repeatwhen  was not properly signalling an upstream  onerror  case. the  flowable.repeatwhen  works as expected.;;0;2x: observablerepeatwhen fix for onerror;`observablerepeatwhen` was not properly signalling an upstream `onerror` case the `flowablerepeatwhen` works as expected;;;;;1;1;2x: observablerepeatwhen fix for onerror;
4824;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: update assertablesubscriber api and add javadoc;this pr adds 3 convenience methods -  assertresult    assertfailure  and  assertfailureandmessage  from 2.x  makes the  assertvaluecount  fluent to allow chaining a subsequent  requestmore  call and adds the missing javadoc to the  assertablesubscriber  interface.;;0;1x: update assertablesubscriber api and add javadoc;this pr adds 3 convenience methods - `assertresult` `assertfailure` and `assertfailureandmessage` from 2x makes the `assertvaluecount` fluent to allow chaining a subsequent `requestmore` call and adds the missing javadoc to the `assertablesubscriber` interface;  4824  ;;;;1;1;1x: update assertablesubscriber api and add javadoc;
4826;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;schedule when bug fix;in using this in production we found a bug where some actions were dropped.  i ve tracked it down to the premature oncompleted and unsubscription of the completable that represents the scheduled action causes the future to get canceled before it is started.;;0;schedule when bug fix;in using this in production we found a bug where some actions were dropped  ive tracked it down to the premature oncompleted and unsubscription of the completable that represents the scheduled action causes the future to get canceled before it is startedthe fix was to delay the oncompleted until the action was truly donei did the pr as two commits because the first one is changing all the tabs to spaces! look at the second commit for the actual functional difference;  4826  ;;;;1;1;fixing a bug in the subscription logic of the actions that caused work to get unsubscribed too early changed the code to delay the calling of oncompleted of the completablesubscriber until the actualaction is truly done;
4827;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;porting the scheduler.when operator from 1.x to 2.x;in fixing the scheduler.when in 1.x i noticed that it hadn t been ported to 2.x. this pr tries to fix that translating observable to flowable and subscription to disposable. this also includes the fix from 1.x;;0;porting the schedulerwhen operator from 1x to 2x;in fixing the schedulerwhen in 1x i noticed that it hadnt been ported to 2x this pr tries to fix that translating observable to flowable and subscription to disposable this also includes the fix from 1x;  4827  ;;;;1;1;porting the schedulerwhen operator from 1x to 2x;
4828;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;changing inner classes to package-private.;to  in #4826;;482.0;changing inner classes to package-private;to  in #4826;  4828  ;wiki documentation missing link;i cannot find `rxjava-examples` supposedly at  which is linked from https://githubcom/netflix/rxjava/wiki/getting-started;forgot to change those we started out having a single example project but it didnt work as the number of languages expanded so we ended up moving examples into each language || updated on wiki ||;1;0;changing inner classes to package-private;
4830;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: completable.doafterterminate to run after onerror as well;doafterterminate was intended to call the callback after either oncompleted or onerror but somehow missed that behavior in 1.x.;;482.0;1x: completabledoafterterminate to run after onerror as well;doafterterminate was intended to call the callback after either oncompleted or onerror but somehow missed that behavior in 1xrelated: #4822;  4830  **< ;wiki documentation missing link;i cannot find `rxjava-examples` supposedly at  which is linked from https://githubcom/netflix/rxjava/wiki/getting-started;forgot to change those we started out having a single example project but it didnt work as the number of languages expanded so we ended up moving examples into each language || updated on wiki ||;1;0;1x: completabledoafterterminate to run after onerror as well;
4831;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add dofinally for handling post-terminal or cancel cleanup;this pr adds the  flowable.dofinally  method that executes an action when the upstream terminates or the downstream cancels (but only once per subscriber). formerly  one could use  doafterterminate  +  dooncancel  together but no support for making sure only one executed the cleanup action.;;0;2x: add dofinally for handling post-terminal or cancel cleanup;this pr adds the `flowabledofinally` method that executes an action when the upstream terminates or the downstream cancels (but only once per subscriber) formerly one could use `doafterterminate` + `dooncancel` together but no support for making sure only one executed the cleanup actionbased on the feedback the rest of the base reactive types can get the same operator a bit later;  4831  ;;;;1;1;2x: add dofinally for handling post terminal or cancel cleanup;
4832;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add dofinally to the rest of the reactive base classes;this pr adds the  dofinally  operator to the rest of the base reactive classes.;;0;2x: add dofinally to the rest of the reactive base classes;this pr adds the `dofinally` operator to the rest of the base reactive classes;  4832  ;;;;1;1;2x: add dofinally to the rest of the reactive base classes;
4833;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add  flowable.doafternext  operator + 3 dox tcks;this pr adds the  flowable.doafternext  operator which calls a  consumer  after the call to  downstream.onnext()  with the same value.;;0;2x: add `flowabledoafternext` operator + 3 dox tcks;this pr adds the `flowabledoafternext` operator which calls a `consumer` after the call to `downstreamonnext()` with the same valuein addition `doonnext` `doafternext` and `dofinally` received their reactive-streams tck tests;  4833  ;;;;1;1;fix operator name in the scheduler javadoc;
4835;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add doafternext & doaftersuccess to the other types;this pr adds  observable.doafternext    maybe.doaftersuccess  and  single.doaftersuccess .;;0;2x: add doafternext & doaftersuccess to the other types;this pr adds `observabledoafternext` `maybedoaftersuccess` and `singledoaftersuccess`;  4835  ;;;;1;1;2x: add doafternext & doaftersuccess to the other types;
4838;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add fluent requestmore to testsubscriber;this pr just adds the  testsubscriber.requestmore  that calls  request  and returns  this  for method chaining purposes.;;0;2x: add fluent requestmore to testsubscriber;this pr just adds the `testsubscriberrequestmore` that calls `request` and returns `this` for method chaining purposes;  4838  ;;;;1;1;2x: add fluent requestmore to testsubscriber;
4839;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: javadoc: fix wording of some operators  remove @throws implications;this pr fixes some javadoc mistakes with operators such as  single    first    last  and co and removes  @throws  tags from operators since those don t throw it when the method is invoked.;;0;2x: javadoc: fix wording of some operators remove @throws implications;this pr fixes some javadoc mistakes with operators such as `single` `first` `last` and co and removes `@throws` tags from operators since those dont throw it when the method is invoked;  4839   thanks @jakewharton  those problems ||;;;;1;1;fix some introduced mistakes;
4846;1;0;0;0;0;1;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: remove objectpool  code style cleanups;this pr removes the  objectpool  and  synchronizedqueue   as their utility now seems surpassed.;;0;1x: remove objectpool code style cleanups;this pr removes the `objectpool` and `synchronizedqueue`  as their utility now seems surpassedin addition this pr contains a bunch of code style cleanups use the `?w1` [parameter to hide whitespace changes]( changes:  - fix finality of `backpressureoverflow`  - introduce the system parameter for io scheduler time-to-live counter: `rxio-schedulerkeepalive`  - mention scheduler system parameters in the `schedulers` javadoc;  4846  ;;;;1;1;1x: remove objectpool code style cleanups;
4849;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: fix completable.concat & merge hanging in async situations;this pr fixes the hang in  completable.concat(observable)  and  completable.merge(observable)  mainly due to using  subscribe  instead of  unsafesubscribe . the underlying problem was that  safesubscriber  unsubscribed the dowstream consumer which cancelled the outstanding elements of  range .;;0;1x: fix completableconcat & merge hanging in async situations;this pr fixes the hang in `completableconcat(observable)` and `completablemerge(observable)` mainly due to using `subscribe` instead of `unsafesubscribe` the underlying problem was that `safesubscriber` unsubscribed the dowstream consumer which cancelled the outstanding elements of `range`in addition ive upgraded the `concat(observable)` to use an up-to-date concatenation algorithm and more compact memory footprint;  4849  ;;;;1;1;1x: fix completableconcat & merge hanging in async situations;
4851;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: add single.fromemitter;this pr adds the  single.fromemitter  operator  driving a  singleemitter  instance similar to  observable.fromemitter  and  completable.fromemitter .;;0;1x: add singlefromemitter;this pr adds the `singlefromemitter` operator driving a `singleemitter` instance similar to `observablefromemitter` and `completablefromemitter`;  4851  ;;;;1;1;1x: add singlefromemitter;
4852;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: single::takeuntil cancellationexception message enh.;this pr modifies the  cancellationexception  message to include the operator name and source type.;;0;1x: single::takeuntil cancellationexception message enh;this pr modifies the `cancellationexception` message to include the operator name and source typerelate: #4756;  4852  ;;;;1;1;1x: single::takeuntil cancellationexception message enh;
4858;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add maybe.flatmapsingleelement returning maybe;this pr adds the  maybe.flatmapsingleelement()  operator that returns a  maybe  and completes if the source completes unlike  flatmapsingle  where the returned  single  signals  nosuchelementexception .;;485.0;2x: add maybeflatmapsingleelement returning maybe;this pr adds the `maybeflatmapsingleelement()` operator that returns a `maybe` and completes if the source completes unlike `flatmapsingle` where the returned `single` signals `nosuchelementexception`related #4857;  4858  ;added  aliases and objects for concrete subject types in scala;-asyncsubject[t]-behaviorsubject[t]-publishsubject[t]-replaysubject[t];#410  this is not really helping as subjects are unrelated to rxlangscalaobservable at this point i believe we need to give up on transparent interop from scala to javai am finishing up a binding that feels more native scala and is very close to what i catually promise in my slides object observable {}trait observable[+t] {  def asjavaobservable: rxobservable[_ <: t]}object observer {}trait observer[-t] {   def asjavaobserver: rxobserver[_ >: t]}object subject {}trait subject[-t +r] extends observable[r] with observer[t] { val asjavasubject: rxsubjectssubject[_ >: t _<: r]}object scheduler {}trait scheduler {  def asjavascheduler: rxscheduler}object notification {}trait notification[+t] { def asjavanotification: rxnotification[_ <: t]}object subscription {}trait subscription {  def asjavasubscription: rxsubscription}from: rob emanuele [mailto:notifications@githubcom] sent: friday november 15 2013 2:38 pmto: netflix/rxjavasubject: [rxjava] added aliases and objects for concrete subject types in scala (#485)-asyncsubject[t]-behaviorsubject[t]-publishsubject[t]-replaysubject[t]---you can merge this pull request by running  git pull  subjectsor view comment on or merge it at:   summary-   added aliases and objects for concrete subject typesfile changes-   m language-adaptors/rxjava-scala/todomd   (1) -   m language-adaptors/rxjava-scala/src/main/scala/rx/lang/scala/subjects/packagescala   (78) -   m rxjava-core/src/main/java/rx/subjects/asyncsubjectjava   (2) -   m rxjava-core/src/main/java/rx/subjects/publishsubjectjava   (2) patch links:-       || fair i wanted to use publishsubjects idiomatically from scala and wrapping them was in the todo list but if something better is in the pipeline then thats great is there a link to the slides you mention? ||;1;0;2x: add maybeflatmapsingleelement returning maybe;
4873;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: testobserver shouldn t clear the upstream disposable on terminated;testobserver  replaced the upstream s  disposable  with the disposed-sentinel when it got a terminal event (unlike  testsubscriber ) and there seems to be a need for triggering  dispose  in some upstream even after that. this pr changes this behavior and also updates unit tests that expect  isdisposed()  true without actually calling  dispose() .;;4872.0;2x: testobserver shouldnt clear the upstream disposable on terminated;`testobserver` replaced the upstreams `disposable` with the disposed-sentinel when it got a terminal event (unlike `testsubscriber`) and there seems to be a need for triggering `dispose` in some upstream even after that this pr changes this behavior and also updates unit tests that expect `isdisposed()` true without actually calling `dispose()`related #4872;  4873  ;completabledoondipose() not called when disposing with testobserver;the following test case fails:```javafinal atomicboolean atomicboolean  new atomicboolean()assertthat(atomicbooleanget())isfalse()completablecomplete()    doondispose(() -> atomicbooleanset(true))    test()    assertresult()    dispose()assertthat(atomicbooleanget())istrue() // fails```in my opinion this is a bit misleading and probably should not be the case is this working as intended?;apparently `testobserver` disconnects from the upstream on `oncomplete` but `testsubscriber` doesnt so this might be some residue ill post a pr to fix thisgenerally though some operators disconnect in a similar fashion so calling dispose has no effect after they complete || closing via #4873 ||;1;0;2x: testobserver shouldnt clear the upstream disposable on terminated;
4877;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: apply missing rxjavaplugins.onassembly on ops;this pr adds the missing calls to  rxjavaplugins.onassembly  on a few operators.;;0;2x: apply missing rxjavapluginsonassembly on ops;this pr adds the missing calls to `rxjavapluginsonassembly` on a few operators;  4877  ;;;;1;1;2x: apply missing rxjavapluginsonassembly on ops;
"4881;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;add checkreturnvalue annotation;first draft on this.;;4878.0;add checkreturnvalue annotation;first draft on thisso far i have only annotated `subscribewith()` and `test()` methodsi checked this against error prone and their [check]( is able of picking up the rxjava annotationhow do you feel if i extend `basetypeannotations` to test for `@checkreturnvalue` too?related #4878;  4881   would you manually ignore methods like `disposable subscribe()`? || @vanniktech see  || @artem-zinnatullin weird somehow findbugs didnt pick it up though could be a configuration error on my sideid argue that not annotating `diposable subscribe()` is fine however i feel like `disposable subscribe(consumer<t>)` and the others should be annotated i personally almost never use subscribewith and prefer the variations with lambdaswere on the same point that static factory methods and operators such as flatmap first() last() etc should be annotated right? if so id apply those and then we can see which might need an annotation too || @akarnokd added the `@checkreturnvalue` annotation to all public api methods of `flowable` `maybe` `single` `observable` and `completable` except for private methods void methods and the `disposable subscribe()` method is that okay now? || yes/cc @jakewharton  ||;2x: @checkreturnvalue for public api;how do you guys feel if the `@checkreturnvalue` annotation was added to certain public api methods?the one that would probably benefit the most in my opinion would be the `subscribe` method where you get a `subscription` or `disposable` back in 99% of the cases you want to handle italso static analyze tools such as [error prone]( could emit an error / warning;""i frequently fire up `subscribe(consumer)` and dont care about cancellation so it would just bother me also `@checkreturnvalue` sounds like part of some extra dependency and we dont want that the only dependency is the reactive-streams api || yes either get the annotation from jsr 305 or i believe that creating our own annotation with the same name would also work || i think `subscribewith` is a reasonable target here as its purpose is to give you back what you gave to it so you can continue with that value also methods returning `flowable` etc shouldnt be ignored if you can make it without external dependencies im fine with the extra annotations || alright will give it a try soon || closing via #4881 || whats the rationale behind forcing handling of a `disposable` return value? in most of the cases ive encountered ive preferred a setup where my subscription runs indefinitely is it unsafe to ignore the return here? if so why? || @markelliot it was decided anything that returns `disposable` should not have `@checkreturnvalue` did you find method(s) that do? || im on 205 and the source for subscribe looks like this:```java    @checkreturnvalue    @schedulersupport(schedulersupportnone)    public final disposable subscribe(consumer<? super t> onnext) {        return subscribe(onnext functionserror_consumer functionsempty_action functionsemptyconsumer())    }``` || cant link to the source since gh is truncating at ~10k lines but it looks like on master the code is the same || #5244 || why would you want to not handle the returned disposable? || per above im subscribing a consumer with intent to subscribe to every subsequent event in that case why should i handle the disposable? || since you may need to `dispose()` it later? || nope intent is to subscribe for the remaining lifetime of my program  || i see it differently but it might be just because im on android and youre forced to dispose() when you hit a certain lifecycle method (eg activity gets destroyed) || @vanniktech we have quite a few subscriptions within our android app that  from one singleton to another and do not require disposing  one example is a memory cache observing a disk cache  || both having and not having this annotation makes sense cant you just ignore warnings at that location that can legally ignore the return value? || you most certainly can the minor inconvenience we see is having to suppress the warning when using static analyzers/lint inspectors for example error prone failed our build without `    @suppresswarnings(""""checkreturnvalue"""")` || i like to think of it as a forced documentation opportunity to indicate that you really dont care about the `disposable` you either _always_ care about it and thus use the return value or you explicitly dont care and should suppress and comment as why its being ignored || cool i guess im asking when one _should_ check `disposable` its not clear from this thread under what conditions its safe to ignore if its always safe to ignore it seems like this annotation is erroneous if not id like to know when and why so that i can write my code sanely || id add that the current code explicitly excepts methods with signature `disposable subscribe()` so would be good to understand why those `disposable`s are always safe to ignore but the others are not || the no-arg `subscribe()` seems in general an anti-pattern to use it indicates you want the side-effects of subscription to happen but do not actually care about the results success or failure which is a recipe for a bad user experience when such side-effect actually does fail or emit something unexpected which goes entirely unhandled || i love the `@checkreturnvalue` but in some projects with [rxlifecycle]( we do not actually need to care about this return value in this case we have to use `suppress` everywhere ps i finally found  a perfect solution:  || ugh after updating to rxjava 2112 i have awful yellow warning highlighting everywhere my two cents -- i hate `@checkreturnvalue` i do the following which works well for my project:```doonsubscribe(subscriptions::add) // subscriptions is a compositedisposable```i find this much more readable than```disposable disposable  somethingserviceget()subscribe()composititedisposableadd(disposable)```i dont want to suppress that warning _everywhere_ so now i have to litter my code with local suppressions || i am with @autonomousapps on this onei also have a convenience method to be used with `compose()````protected <t> observabletransformer<t t> asdisposable() {        return upstream ->                upstreamdoonsubscribe(disposable -> mdisposablesadd(disposable))    }```and i needed to add `@suppresswarnings(""""checkreturnvalue"""")` in order to pass on error prone while  in fact i am using the disposable on `doonsubscribe` || i see little point in using `disposable` of `single`/`completable`/`maybe` sure you might want to explicitly cancel them at some point but thats definitely not something that youll always needplus `@checkreturnvalue` is incompatible with [rxlifecycle]( for regular `observable`project-wide or even class-wide `@suppresslint(""""checkresult"""")` is a very bad idea so im forced to use ```subscribe(() -> {	})isdisposed()```looks ugly || id like to kick the tires on this discussion again> in 99% of the cases you want to handle iti dont think i agree with that for cases like @digitalbuddha mentioned with singletons or places where the scope of the execution is implicitly bound to the object (such as subscribing to an android views click events from within the view) to me `@checkreturnvalue` should only apply in cases where it is **100% programmer error to not** capture it such as a factory method this to me is not such a casethoughts? || views have a lifecycle you should be using to unsubscribe for singletons you can suppress with a comment to document the rare nature of that object and its exception to the rule || > views have a lifecycle you should be using to unsubscribeif you need to dispose at some point before the view is up for gc sure thats not the case 100% of the time though i could be listening for detach events too for instance or tracking through multiple attach/detaches theres no other lifecycle event to hook into beyond detach but im happy to let the subscription die with the view once theyre all leafs for gc if the subscription is only internal to the viewanother example would be synchronous cases like `just` or `fromiterable`i just dont think this case is as rare as is being described on top of that conditions for cases like lifecycle management vary depending on the codebase and often doesnt involve directly dealing with the `disposable` itself in rxlifecycle a completion event is sent from upstream in autodispose its handled internally (though there we just omit these annotations from the returned subscribe proxy interfaces) some codebases might use kotlin with their own extensions or `compositedisposable`s in some fancy way or even pass in a `consumer<disposable>` directly to the full-arg `subscribe()` overload yet still will have this imposed on them by static analysis tools i think enforcement for this case is much better left to consumers to implement what fits their codebase best perhaps a community ep/lint check that recreates this behavior would be useful for those that want to keep it without requiring it for all || "";1;0;java 6 compatibility;"
4882;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: common test classes for processors.;caused by https://github.com/jakewharton/rxrelay/pull/20#discussion_r89308736;;0;2x: common test classes for processors;caused by https://githubcom/jakewharton/rxrelay/pull/20#discussion_r89308736;  4882   @artem-zinnatullin what about the subject tests? || @vanniktech in a separate pr it was just a try to see if approach will be approved :)  ||;;;;1;1;2x: common test classes for processors;
4884;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: enable testscheduler with nanosecond periodic scheduling;the default periodic scheduling code accessed the current worker time as milliseconds which prevents running microsecond and nanosecond scale unit tests with testscheduler as its internal nanosecond resolution time is always converted  losing precision.;;488.0;1x: enable testscheduler with nanosecond periodic scheduling;the default periodic scheduling code accessed the current worker time as milliseconds which prevents running microsecond and nanosecond scale unit tests with testscheduler as its internal nanosecond resolution time is always converted losing precisionthis pr introduces the internal `scheduleperiodichelper` class moves the default scheduling code into a static method and defines a `nownanosupplier` interface that is now implemented by testschedulerworker to return the current nano time the default `workerscheduleperiodically` delegates to this static method and given a `null` `nonanosupplier` the `workernow()` is converted to nanoseconds as usualrelated: #4883;  4884  ;possible interop with spring reactor;hireactor pattern is very much related to observable so is it possible to have some level of interop with reactor (https://githubcom/reactor/reactor)suminda;bindings for it would make sense but probably as part of reactor itself it doesnt make sense for rxjava itself to try and have bindings for every possible 3rd party library out there and their different release cycles || i see you already opened [an issue there]( || there is a good fit here only minor concern is if there is an impedance mismatch on speedreactor selector-based dispatching w/ dynamic consumer assignment: ~10-15m events/sec reactor selector-based dispatching w/o dynamic consumer assignment: ~20-25m events/sec reactor processor (lmax disruptor wrapper) no dispatching at all  consumer: ~90-100m events/sec reactor tcp syslog to hdfs: 600k messages/sec (source:  || if there are performance issues then we should fix them if you make progress on this please let the rxjava community know and if you find performance bottlenecks please help identity and/or fix them ||;1;0;1x: enable testscheduler with nanosecond periodic scheduling;
4885;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: dedicated reduce() op implementations;this pr adds dedicated operator implementations to;;0;2x: dedicated reduce() op implementations;this pr adds dedicated operator implementations to  - `flowablereduce(seed reducer)` (returns `single`)  - `flowablereducewith(seedsupplier reducer)`  (returns `single`)  - `observablereduce(reducer)` (returns `maybe`)  - `observablereduce(seed reducer)`  (returns `single`) and  - `observablereducewith(seedsupplier reducer)`  (returns `single`)instead of using `scan()takelast(1)` (`flowablereduce(reducer)` already had a dedicated operator)comparison (celeron 1005m 4gb ram windows 7 x64 java 8u112 jmh 116):( new `reduceperf` benchmark does a simple sum over a list of integer values unfortunately this creates a lot of garbage for longer sequences (plus the cpu/ram is not really suited for such benchmarks the `flowmaybe` lines should be roughly the same since the code didnt change but there is a significant run-to-run variance);  4885   :+1: with the qualifier that im not up on rxjava2/reactivestreams lifecycle in terms of subscription and disposal yet (thats for another day sorry!) ||;;;;1;1;check for more terminal state;
4893;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix compilation errors when using java 8;this pr fixes a few compilation errors that happen when the project is compiled with java 8 target (eclipse is even slower then).;;0;2x: fix compilation errors when using java 8;this pr fixes a few compilation errors that happen when the project is compiled with java 8 target (eclipse is even slower then)some covariant casts dont work in 8 and some type arguments inferred as object get inferred as a more concrete type in 8 the slight drawback is that with the changes java 6 compilation needs extra suppressions;  4893   this is added in order to support java 8 or 9 compile targets (the default is java 6 in the project) ||;;;;1;1;suppress warnings for java 6;
4899;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: flowablescanseed - prevent multiple terminal events;this pr;;0;2x: flowablescanseed - prevent multiple terminal events;this pr* prevents multiple terminal events being emitted when the scan function throws* prevents processing of a later `onnext` if the previous `onnext` processing resulted in an error emission* increases coverage to 100% of `flowablescanseed`;  4899   updated pr with `onnext` protection and test (had forgotten to commit) ||;;;;1;1;flowablescanseed - prevent post-terminal events;
4900;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix typo in disposablehelper;fixed a typo in disposablehelper.  curren  ->  current;;0;2x: fix typo in disposablehelper; a typo in disposablehelper `curren` -> `current`;  4900  ;;;;1;1;2x: fix typo in disposablehelper;
4901;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: flowablescan - prevent multiple terminal emissions;for scan without seed this pr;;0;2x: flowablescan - prevent multiple terminal emissions;for scan without seed this pr* prevents multiple terminal events being emitted when the scan function throws* prevents processing of a later `onnext` if the previous `onnext` processing resulted in an error emission* ensures post terminal errors are reported to `rxjavaplugins` error handlerfor scan with seed (forgot this one in the last pr)* ensures post terminal errors are reported to `rxjavaplugins` error handler;  4901  ;;;;1;1;flowablescan - prevent multiple terminal emissions;
4903;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: doafternext - prevent post-error calls to consumer;this pr;;0;2x: doafternext - prevent post-error calls to consumer;this pr* prevents further calls to the consumer if an error has been thrown;  4903  ;;;;1;1;doafternext - prevent post-terminal emission;
4904;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: observable.scan  no seed - fix post-terminal behaviour;this pr;;0;2x: observablescan no seed - fix post-terminal behaviour;this pr* ensures that scan function throwing cannot result in two terminal events (error or complete) and that additional error event is reported to `rxjavaplugins` error handler* ensures that scan function if throws is not called again;;;;;1;1;observablescan no seed fix post-terminal behaviour;
4907;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;use t instead of value to allow for ide naming;naming the value  t  instead of  value  allows the intellij to intelligently name the variable based on the type when autocompleting.;;0;use t instead of value to allow for ide naming;naming the value `t` instead of `value` allows the intellij to intelligently name the variable based on the type when autocompleting before:```singlejust(new dog())subscribe(new singleobserver<string>() {            @override            public void onsubscribe(disposable d) {                            }            @override            public void onsuccess(dog value) {            }            @override            public void onerror(throwable e) {            }        })```after:```singlejust(new dog())subscribe(new singleobserver<string>() {            @override            public void onsubscribe(disposable d) {            }            @override            public void onsuccess(dog dog) {            }            @override            public void onerror(throwable e) {            }        })```;this is for 2x did i make a mistake? i could add this to 1x also if desired || hah yeah i meant 1x off-by-one error ||  surprisingly it was already done a lot more in 1x so there were only a few cases i found ||   4907  ;;;;1;1;use t instead of value to allow for ide naming;
4908;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;use t instead of value to allow for ide naming 1.x;same as  but for 1.x. most places already named the variable  t   there were just a few missing.;;0;use t instead of value to allow for ide naming 1x;same as  but for 1x most places already named the variable `t` there were just a few missing;  4908  ;;;;1;1;use t instead of value to allow for ide naming;
4911;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix & update observable.repeatwhen and retrywhen (again);this pr fixes the  observable.repeatwhen  not completing properly if the handler completes. in addition  the  observableredo  has been split to  observableretrywhen  and  observablerepeatwhen  just like their  flowable  counterpart and are now they use a less convoluted algorithm.;;490.0;2x: fix & update observablerepeatwhen and retrywhen (again);this pr fixes the `observablerepeatwhen` not completing properly if the handler completes in addition the `observableredo` has been split to `observableretrywhen` and `observablerepeatwhen` just like their `flowable` counterpart and are now they use a less convoluted algorithmrelated: #4909;i dont know why the travis-ci/push still shows up ||   4911  ;scala adaptor: inheritance subscriptions and subjects;i tried to add subscriptions and subjects using the value class trick and came to the conclusion that it wont work the problem is that inheritance and value classes dont work together because value classes cannot be extended we want observable to be a value class and at the same time we want subject to extend observable so that doesnt workthis pr is very similar to [eriks code]( but i added a trait``` scalatrait javawrapper[+w] {  def asjava: w}```which all classes extend this allows us to have an `asjava` method everywhere (instead of `asjavasubject` / `asjavaobserver` etc) the main challenge was to get the double inheritance subject extends observer and observable workingnow all wrappers  the same way for instance observable looks as follows:``` scalatrait observable[+t] extends javawrapper[rxobservable[_ <: t]] {    }object observable {  private[observable] class observablewrapper[+t](val asjava: rxobservable[_ <: t]) extends observable[t] {}  def apply[t](asjava: rxobservable[_ <: t]): observable[t]  {    new observablewrapper[t](asjava)  }  }```in scala code to convert from scala types to java types theres the `asjava` method and to convert from java types to scala types theres an `apply` method in each companion objectwhen we used value classes such conversions were not necessary in java because scala types appeared as java types for the java compiler now they become necessary but note that this pr does not yet contain such conversions but that should be no big problem;#413  im reviewing this with erik tomorrow and will get this or some variant of it pulled in || yes this pr is incomplete closing ||;1;0;2x: fix & update observablerepeatwhen and redowhen;
4921;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix testsubscriber/observer message texts;fix the wrong messages in  testsubscriber  and  testobserver .;;4920.0;2x: fix testsubscriber/observer message texts;fix the wrong messages in `testsubscriber` and `testobserver`related: #4920;  4921  ;2x: testsubscriber/testobserver wrong error message;testsubscriber:210 `onnext received a null subscription`testsubscriber:229 `onerror received a null subscription`testobserver:152  `onnext received a null subscription`;closing via #4921 ||;1;0;2x: fix testsubscriber/observer message texts;
4924;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: change completable to completablesource;changing  completable  to  completablesource . also found one other wrong spot that i fixed within this pr.;;4923.0;2x: change completable to completablesource;changing `completable` to `completablesource` also found one other wrong spot that i  within this pr4923;  4924  ;2x singleflatmapcompletable expects completable instead of completablesource;the signature looks like this:`final function<? super t ? extends completable> mapper`although it should be `final function<? super t ? extends completablesource> mapper`;i dont think there are any `completablesource` implementations other than rxjava but you are welcome to send a pr || well its mostly for consistency and ill send one right away || closing via #4924 ||;1;0;2x: change completable to completablesource;
4927;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix timer() ise due to bad resource mgmt;both  observable.timer()  and  flowable.timer()  could report  illegalstateexception  because if the delayed task completed before the task s  disposable  was set  the  setonce  found a non-null  non-terminal reference already set.;;4926.0;2x: fix timer() ise due to bad resource mgmt;both `observabletimer()` and `flowabletimer()` could report `illegalstateexception` because if the delayed task completed before the tasks `disposable` was set the `setonce` found a non-null non-terminal reference already setrelated: #4926;  4927  ;[2x] illegalstateexception on observabletimer with 0 milliseconds;- library version 203the following test occasionally fails (about 200 out of 1000 fail):```kotlin@testfun test() {    var t: throwable?  null    rxjavapluginsseterrorhandler { t  it }    observabletimer(0l milliseconds)blockingfirst()    t?let { throw it }}```stacktrace:```javalangillegalstateexception: disposable already set!	at ioreactivexinternaldisposablesdisposablehelperreportdisposableset(disposablehelperjava:144)	at ioreactivexinternaldisposablesdisposablehelpersetonce(disposablehelperjava:70)	at ioreactivexinternaloperatorsobservableobservabletimer$intervalonceobserversetresource(observabletimerjava:74)	at ioreactivexinternaloperatorsobservableobservabletimersubscribeactual(observabletimerjava:40)	at ioreactivexobservablesubscribe(observablejava:10514)	at ioreactivexobservableblockingfirst(observablejava:4535)	at myappmytesttest(mytestkt:15)```whenever the test fails [intervalonceobserver#setresource]( is called _after_ it is disposed;thanks for reporting if the emission happens before the `setresource` call the `setresource` will find the wrong reference there and complain about it ill fix it shortly || closing via #4927 || tried v202 in production and seeing a lot of these crashes come up i know this has been  but do we have an eta for v204? thank you || see  ||;1;0;2x: fix timer() ise due to bad resource mgmt;
4930;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add completable.cache();this pr adds the operator  cache()  to  completable  to cache the terminal event of a  completable  sequence.;;0;2x: add completablecache();this pr adds the operator `cache()` to `completable` to cache the terminal event of a `completable` sequencei came across the need for this when [answering a question]( where the intent of using `completable` was to indicate an operation has completed but not actually trigger the operation whenever one subscribeda small drawback just like with other `cache()` operators is that once connected there is no way for cancel it from within the operator itself returning `completable & disposable` doesnt work because of the the type restriction of `rxjavapluginsonassembly` there could be a `cache(consumer<? super disposable> ondispose)` overload or an example showing `sourceambwith(disposer)cache()`;  4930   great improvement thanks!in one of my projects i applied this transformer to a lot of sequences:```javaprivate static final completabletransformer cache  completable ->    completabletoobservable()      cachewithinitialcapacity(1)      ignoreelements()``` ||;;;;1;1;eaadb540dad556cb524a7376b5bc6f07f108b93d;
4932;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add safeguards to generate();flowable.generate()  and  observable.generate()  lacked the safeguards that were present in 1.x. this adds those and adds extra state cleanup.;;493.0;2x: add safeguards to generate();`flowablegenerate()` and `observablegenerate()` lacked the safeguards that were present in 1x this adds those and adds extra state cleanuprelated: #4931;  4932  **< ;zip many from scratch missing concat of iterable;;#416  #417;1;0;fix typo in the test name;
4943;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix publish(function) not replenishing its queue;i was working on converting the [monte carlo pi benchmark]( to rxjava 2 and it turned out i forgot to replenish the internal queue of  publish(function)  in case the upstream was not sync-fuseable.;;4902.0;2x: fix publish(function) not replenishing its queue;i was working on converting the [monte carlo pi benchmark]( to rxjava 2 and it turned out i forgot to replenish the internal queue of `publish(function)` in case the upstream was not sync-fuseablethis pr fixes the replenishment problem for non-fused and async-fused sources by requesting after 75% consumptionin addition if an inner subscriber cancelled while it was at request 0 the other inner subscribers might not have resumed drainingive also  two unit tests with wrong timeout unit of measure that randomly failed the tests on a slow machine or travis (#4902);  4943  ;flowablepublishfunctiontest > inputoutputsubscriberace failed;```ioreactivexinternaloperatorsflowableflowablepublishfunctiontest > inputoutputsubscriberace failed    javalangassertionerror: value count differs expected: 1 [1] actual: 0  (latch  1 values  0 errors  0 completions  0)        at ioreactivexobserversbasetestconsumerfail(basetestconsumerjava:133)        at ioreactivexobserversbasetestconsumerassertvalues(basetestconsumerjava:404)        at ioreactivexobserversbasetestconsumerassertresult(basetestconsumerjava:613)        at ioreactivexinternaloperatorsflowableflowablepublishfunctiontestinputoutputsubscriberace(flowablepublishfunctiontestjava:410)```;closing via #4943 ||;1;0;2x: fix publish(function) not replenishing its queue;
"4945;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix timeout with fallback not cancelling the main source;this pr fixes the lack of dispose/cancel call towards the upstream in the timed+fallback  timeout  operator version.;;4944.0;2x: fix timeout with fallback not cancelling the main source;this pr fixes the lack of dispose/cancel call towards the upstream in the timed+fallback `timeout` operator versionin addition the selector version received similar unit tests to ensure they work properly (they did)related: #4944;  4945  ;using observabletimeout could cause uncaught exception in rxjava 2x;""please have a look at this sample:    public void testsubject() {        ioreactivexsubjectspublishsubject<integer> subject  ioreactivexsubjectspublishsubjectcreate()               subject                timeout(10 timeunitseconds ioreactivexobservableerror(new runtimeexception()))                takewhile(integer -> integer < 3)                tolist()                subscribe(integers -> systemoutprintln(integers) throwable -> systemoutprintln(""""throwable""""))        subjectonnext(0)        subjectonnext(1)        subjectonnext(2)        subjectonnext(3)        subjectonerror(new runtimeexception())    }`it is expected that after posting value 3 chain emits result [0 1 2] and unsubscribes from the subject and subsequent posting of runtimeexception doesnt push it anywhere and doesnt throw itbut on v203 it crashes with runtimeexceptionthe same test with rxsubjectspublishsubject on v124 works as expectedif remove timeout from the chain everything works as expectedthanks"";thanks for reporting this is a bug with the fallback version of the `timeout` operator both in `observable` and `flowable` the fix is underway || closing via #4945 ||;1;0;2x: fix timeout with fallback not cancelling the main source;"
4946;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: a simple javadoc typo fix.;fixed javadoc for singletoobservable  maybetoobservable  completabletoobservable;;0;2x: a simple javadoc typo fix; javadoc for singletoobservable maybetoobservable completabletoobservable;  4946  ;;;;1;1;2x:  javadoc for singletoobservable maybetoobservable completabletoobservable;
4949;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: header and whitespace cleanup;- add missing header to 3 files;;0;1x: header and whitespace cleanup;- add missing header to 3 files  - remove trailing whitespaces from recent additions;  4949  ;;;;1;1;1x: header and whitespace cleanup;
4951;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix javadoc for behaviorsubject;-fix examples for creating behaviorsubject with or without initial value.;;0;fix javadoc for behaviorsubject;-fix examples for creating behaviorsubject with or without initial value;  4951  ;;;;1;1;fix javadoc for behaviorsubject-fix examples for creating behaviorsubject with or without initial value;
"4955;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add sample() overload that can emit the very last buffered item;the  sample()  operator in 1.x has been changed to always emit the very last buffered item before completion for [1.1.3]( [discussion](  [pr](https://github.com/reactivex/rxjava/pull/3757).;;495.0;2x: add sample() overload that can emit the very last buffered item;""the `sample()` operator in 1x has been changed to always emit the very last buffered item before completion for [113]( [discussion]( [pr]( change has been forgotten in 2x (because 2x `sample()` was implemented several months earlier) but unlike 1x i dont want to break existing use cases hence the introduction of 6 overloads (3 for each base type) that lets one define the """"tail"""" behaviornote that the associated marble diagrams are inconsistent with the operators implemented we need a new diagram where the timed-sample also emits the last value:( one new diagram where the sampler-sample doesnt emit the last value:![image]( default sampler-sample should use this and the `emitlast  true` version can use the current diagram(i dont have a mac thus cant run omnigraffle)related: #4952"";  4955  ;zip many rewritten concat with iterable merge with iterable;ive rewritten the zip method to terminate as soon as possible in addition the concat(iterable<observable<t>> and merge(iterable<observable<t>>) where missing from observable;""#418  @akarnokd thank you for this im checking out the branch now to play with it and see how the problematic unit tests behavewould you mind re-submitting the pull request though after rebasing this onto a new branch so we dont have all the commit clutter resulting from you working on your master branch? the commit """"merge origin/master""""  and commits before that are a result of merging /netflix/rxjava master into your master then submitting back from the same branch it is preferable to always commit only to a clean branch and submit a pull request from that so only the relevant commits are applied the only time anything should commit to your forked master is when fetching from the upstream to sync back up i want to confirm a unit test for this code @headinthebox can you please validate something? the following unit test shows how this will correctly complete once the first stream completes however it still waits until all items are emitted before the `oncompleted` is sent i want to ensure thats how it should behave as opposed to skipping those and completing as soon as oncomplete is sent (like onerror should)``` java    @test    public void testonfirstcompletion() {        publishsubject<string> oa  publishsubjectcreate()        publishsubject<string> ob  publishsubjectcreate()        @suppresswarnings(""""unchecked"""")        observer<string> observer  mock(observerclass)        observable<string> o  observablecreate(zip(oa ob getconcat2strings()))        osubscribe(observer)        inorder inorder  inorder(observer)        oaonnext(""""a1"""")        inorderverify(observer never())onnext(anystring())        obonnext(""""b1"""")        inorderverify(observer times(1))onnext(""""a1-b1"""")        obonnext(""""b2"""")        inorderverify(observer never())onnext(anystring())        oaonnext(""""a2"""")        inorderverify(observer times(1))onnext(""""a2-b2"""")        oaonnext(""""a3"""")        oaonnext(""""a4"""")        oaonnext(""""a5"""")        oaoncompleted()        // should oncomplete be emitted here instead of waiting       // for b3 b4 b5 to be emitted?        obonnext(""""b3"""")        obonnext(""""b4"""")        obonnext(""""b5"""")        inorderverify(observer times(1))onnext(""""a3-b3"""")        inorderverify(observer times(1))onnext(""""a4-b4"""")        inorderverify(observer times(1))onnext(""""a5-b5"""")        // we receive the oncomplete here        inorderverify(observer times(1))oncompleted()        obonnext(""""b6"""")        obonnext(""""b7"""")        obonnext(""""b8"""")        obonnext(""""b9"""")        // never completes (infinite stream for example)        // we should receive nothing else despite ob continuing after oa completed        inorderverifynomoreinteractions()    }    private func2<string string string> getconcat2strings() {        return new func2<string string string>() {            @override            public string call(string t1 string t2) {                return t1 + """"-"""" + t2            }        }    }``` || this confirms the `onerror` event is propagated immediately:``` java@test    public void testonerrortermination() {        publishsubject<string> oa  publishsubjectcreate()        publishsubject<string> ob  publishsubjectcreate()        @suppresswarnings(""""unchecked"""")        observer<string> observer  mock(observerclass)        observable<string> o  observablecreate(zip(oa ob getconcat2strings()))        osubscribe(observer)        inorder inorder  inorder(observer)        oaonnext(""""a1"""")        inorderverify(observer never())onnext(anystring())        obonnext(""""b1"""")        inorderverify(observer times(1))onnext(""""a1-b1"""")        obonnext(""""b2"""")        inorderverify(observer never())onnext(anystring())        oaonnext(""""a2"""")        inorderverify(observer times(1))onnext(""""a2-b2"""")        oaonnext(""""a3"""")        oaonnext(""""a4"""")        oaonnext(""""a5"""")        oaonerror(new runtimeexception(""""forced failure""""))        // it should emit failure immediately        inorderverify(observer times(1))onerror(any(runtimeexceptionclass))        obonnext(""""b3"""")        obonnext(""""b4"""")        obonnext(""""b5"""")        obonnext(""""b6"""")        obonnext(""""b7"""")        obonnext(""""b8"""")        obonnext(""""b9"""")        // never completes (infinite stream for example)        // we should receive nothing else despite ob continuing after oa completed        inorderverifynomoreinteractions()    }``` || sorry for the clutter im new to git in this manner will do a new pull shortly || > sorry for the clutter im new to git in this manner will do a new pull shortlynot a problem the git flow for pull requests is not obvious when first starting i totally messed up a few repos when i first started had to wipe them out and start fresh with clean forks until i got the hang of it :-) || closing as replaced by  || "";1;0;2x: add sample() overload that can emit the very last buffered item;"
"4957;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix lambdaobserver calling dispose when terminating;this pr changes the  lambdaobserver  to not dispose the upstream when it receives a terminal event. the  lambdasubscriber  has been previoulsy updated but apparently not synced.;;4956.0;2x: fix lambdaobserver calling dispose when terminating;this pr changes the `lambdaobserver` to not dispose the upstream when it receives a terminal event the `lambdasubscriber` has been previoulsy updated but apparently not syncedreported in #4956this pr fixes 2 unit test methods of `flowableignoreelements()` as they were not actually testing the operator (discovered when the `observableignoreelements()` initially failed after the patch to `lambdaobserver`);  4957  ;rxjava 204 observable calls dispose before terminal event;""recently discovered behaviour that brings incorrect order for observabledofinallyhere is code to check``` java    @test    public void operationfinallyorder() throws exception {        singleerror(new runtimeexception())                doondispose(() -> systemoutprintln(""""singledoondispose""""))                dofinally(() -> systemoutprintln(""""singledofinally""""))                subscribe(o -> systemoutprintln(""""singleonsuccess"""")                        t -> systemoutprintln(""""singleonerror""""))        systemoutprintln()        completableerror(new runtimeexception())                doondispose(() -> systemoutprintln(""""completabledoondispose""""))                dofinally(() -> systemoutprintln(""""completabledofinally""""))                subscribe(() -> systemoutprintln(""""completableoncomplete"""")                        t -> systemoutprintln(""""completableonerror""""))        systemoutprintln()        observableerror(new runtimeexception())                doondispose(() -> systemoutprintln(""""observabledoondispose""""))                dofinally(() -> systemoutprintln(""""observabledofinally""""))                subscribe(o -> systemoutprintln(""""observableonnext"""")                        t -> systemoutprintln(""""observableonerror"""")                        () -> systemoutprintln(""""observableoncomplete""""))        systemoutprintln()        observablejust(new object())                doondispose(() -> systemoutprintln(""""observabledoondispose""""))                dofinally(() -> systemoutprintln(""""observabledofinally""""))                subscribe(o -> systemoutprintln(""""observableonnext"""")                        t -> systemoutprintln(""""observableonerror"""")                        () -> systemoutprintln(""""observableoncomplete""""))    }```output:```singleonerrorsingledofinallycompletableonerrorcompletabledofinallyobservabledoondisposeobservabledofinallyobservableonerrorobservableonnextobservabledoondisposeobservabledofinallyobservableoncomplete```as you can see order and amount of messages for single and completable are correct but ```lambdaobserver``` calls dispose before terminal event that triggers dofinally too early according to new lifecycle (confirmed here  no messages observabledoondispose should be there"";indeed `observable` behaves differently from `flowable`:```flowableonerrorflowabledofinallyflowableonnextflowableoncompleteflowabledofinally```ill post a fix shortly || see #4957 || closing via #4957 ||;1;0;2x: fix lambdaobserver calling dispose when terminating;"
4962;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix single.takeuntil() other triggering twice;this pr fixes the double termination of  single.takeuntil(publisher)  when the  other  fires an item and then completes while ignoring the cancellation in between  trying to signal a  cancellationexception  again which is routed to the  rxjavaplugins.onerror  and crashing on android.;;4961.0;2x: fix singletakeuntil() other triggering twice;this pr fixes the double termination of `singletakeuntil(publisher)` when the `other` fires an item and then completes while ignoring the cancellation in between trying to signal a `cancellationexception` again which is routed to the `rxjavapluginsonerror` and crashing on androidin addition the `maybetakeuntil()` received a unit test verifying this doesnt also happen to itrelated: #4961;  4962  **< ;203 singletakeuntil() crashes;```javasingle<t> mainflowable<t> othermaintakeuntil(othertake(1))subscribe()```this pseudo-code crashes when `other` emits an item `singletakeuntiltakeuntilothersubscriberoncompleted()` is called twice and second call generate a crash please fix this;please provide the crash stacktrace || closing via #4962 ||;1;0;2x: fix takeuntil() other triggering twice;
4963;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: add missing marbles  fix image sizes;- add  create(synconsubscribe)  marble and update image dimensions;;0;1x: add missing marbles fix image sizes;- add `create(synconsubscribe)` marble and update image dimensions  - add `create(asynconsubscribe)` marble and update image dimensions  - add `switchifempty()` marble  - add `tocompletable()` marble and update image dimensions;;;;;1;1;1x: add missing marbles fix image sizes;
4966;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add strict() operator for strong rs conformance;this pr adds a new instance operator  strict() :;;0;2x: add strict() operator for strong rs conformance;this pr adds a new instance operator `strict()`:ensures that the event flow between the upstream and downstream follow the reactive-streams 10 specification by honoring the 3 additional rules (which are omitted in standard operators due to performance reasons) * 13: onnext should not be called concurrently until onsubscribe returns * 23: onerror or oncomplete must not call cancel * 39: negative requests should emit an onerror(illegalargumentexception)in addition if rule 212 (onsubscribe must be called at most once) is violated the sequence is cancelled an onerror(illegalstateexception) is emitted note that the reactive-streams specification doesnt have any sanction for violating 212the `strict()` operator also replaces the test-only operators that were supporting the reactive-streams tcks already;  4966  ;;;;1;1;fix javadoc and annotation;
4967;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add subjects for single  maybe and completable;this pr adds 3 new subject types:  singlesubject    maybesubject  and  completablesubject . their purpose is to provide an imperative way to multicast 0-1-error events as well as cache these events for later observers. they are thread-safe by design and there is no need for a serialized wrapper unlike the other  subject s.;;0;2x: add subjects for single maybe and completable;this pr adds 3 new subject types: `singlesubject` `maybesubject` and `completablesubject` their purpose is to provide an imperative way to multicast 0-1-error events as well as cache these events for later observers they are thread-safe by design and there is no need for a serialized wrapper unlike the other `subject`s;  4967   @vanniktech updated ||;;;;1;1;add checkreturnvalue rename local test vars;
4970;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix withlatestfrom null checks  lifecycle;this pr fixes the lack of null check on the result of the  combiner  function as well as fixes the lifecycle of the  flowablewithlatestfrom  to avoid races with the  onsubscribe .;;0;2x: fix withlatestfrom null checks lifecycle;this pr fixes the lack of null check on the result of the `combiner` function as well as fixes the lifecycle of the `flowablewithlatestfrom` to avoid races with the `onsubscribe`;  4970  ;;;;1;1;2x: fix withlatestfrom null checks lifecycle;
4971;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add @checkreturnvalue to create methods of subjects + processors;- adds the @checkreturnvalue annotation to subjects + processors since single/completable and maybesubject got them recently too;;0;2x: add @checkreturnvalue to create methods of subjects + processors;- adds the @checkreturnvalue annotation to subjects + processors since single/completable and maybesubject got them recently too;  4971  ;;;;1;1;2x: add @checkreturnvalue to create methods of subjects + processors;
"4972;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;improve compose() generics;4950;;4950.0;improve compose() generics;4950i tested and built with the added tests on java 6 7 and 8 not sure if you want to keep them in before merging since theyre not really functional in nature just there to make sure they compile;""side-note: gets even better on java 8 which removes the need for a type argument at all in those examples!<img width""""680"""" alt""""screen shot 2017-01-08 at 2 58 20 am"""" src"""" ||   4972    "";2x: compose() generics;migrating some of our code to rxjava 2 weve run into some issues around transformers due to the following signature change:```java// 1public <r> observable<r> compose(transformer<? super t ? extends r> transformer) {        return ((transformer<t r>) transformer)call(this)}// 2public final <r> observable<r> compose(observabletransformer<t r> composer) {        return wrap(composerapply(this))}```was this intentionally narrowed? if not open to a pr to add back the `? super` semantics?;""do you have an example that doesnt compile for you without `? super`? we have to be careful with such variance changes because it may break current users || whoops just saw your response ill put together a sample later tonight || so heres an example where an observable emits `a` instances down the stream and transforms them into `b` instances```javainterface a<t r> {}interface b<t> {}// rxjava 1static <t> rxobservabletransformer<a<t ?> b<t>> oldstyle() {    return new rxobservabletransformer<a<t ?> b<t>>() {        @override        public rxobservable<b<t>> call(rxobservable<a<t ?>> a) {            return rxobservableempty()        }    }}// rxjava 2static <t> observabletransformer<a<t ?> b<t>> newstyle() {    return new observabletransformer<a<t ?> b<t>>() {        @override        public observablesource<b<t>> apply(observable<a<t ?>> a) {            return observableempty()        }    }}void test() {        a<string integer> a  new a<string integer>() { }    // rxjava 1    rxobservablejust(a)            compose(transformerstest<string>oldstyle())  // yay because integer is irrelevant here            subscribe(new action1<b<string>>() {                @override                public void call(b<string> stringb) {                }            })    // rxjava 2    observablejust(a)            compose(transformerstest<string>newstyle())   // this doesnt compile            subscribe(new consumer<b<string>>() {                @override                public void accept(b<string> tb) throws exception {                }            })}```in the rxjava 2 example the `compose()` line there doesnt compile because of generics issues<img width""""1341"""" alt""""screen shot 2017-01-07 at 11 55 01 pm"""" src"""" order to make it compile the transformer signature needs to be changed to be like the following:```javastatic <t r> observabletransformer<a<t r> b<t>> newstyle() {    return new observabletransformer<a<t r> b<t>>() {        @override        public observablesource<b<t>> apply(observable<a<t r>> a) {            return observableempty()        }    }}```and imposes some boilerplate on the consumer in that they now have to specify the second type even though its irrelevant```javaobservablejust(a)        compose(transformerstest<string integer>newstyle())  // :(        subscribe(new consumer<b<string>>() {            @override            public void accept(b<string> tb) throws exception {            }        })``` || okay please verify that with the variance changes it compiles with java 6 7 and 8 targets || "";1;0;improve compose() generics4950;"
4973;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add completable.hide();- adds completable.hide() operator so that completablesubject as well as other custom completable implementations can be hidden;;0;2x: add completablehide();- adds completablehide() operator so that completablesubject as well as other custom completable implementations can be hidden; ;;;;1;1;2x: add completablehide();
"4974;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add flowable.parallel() and parallel operators;this pr adds the  parallel()  method to  flowable  which opens up a sub-dsl with parallel operations. (note that only a few operators make sense in a parallel settings.);;0;2x: add flowableparallel() and parallel operators;""this pr adds the `parallel()` method to `flowable` which opens up a sub-dsl with parallel operations (note that only a few operators make sense in a parallel settings)this parallel sub-dsl is not limited to computation tasks as it allows specifying the parallelism and the `scheduler` to run the parallel rails for example you can have parallel downloads that block:```javaflowablerange(1 100)parallel(10)runon(schedulersio())map(v ->  + v))sequential()observeon(androidschedulersmainthread())subscribe()```"";""  4974 smaller computation parallel has less overhead for longer computation they are roughly next to each other parallel uses round-robin collection whereas flatmap collects from a source as long as it can || "";;;;1;1;fix groupby benchmark;"
"4979;1;0;0;0;0;1;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;add newline to end of files missing a newline;this is to get rid of the  no newline at end of file  warning that exist on many but not all files in the project  so adds a newline to any file missing a newline. this came about while modifying a large number of files for https://github.com/reactivex/rxjava/issues/4978.;;0;add newline to end of files missing a newline;""this is to get rid of the """"no newline at end of file"""" warning that exist on many but not all files in the project so adds a newline to any file missing a newline this came about while modifying a large number of files for  is intended to clean this up once so it doesnt cause warnings and noise in each pr this can affect probably would be good if the project had a formatter than ensured this as part of ci"";;;;;1;1;""add newline to end of files missing a newlinethis is to get rid of the """"no newline at end of file"""" warning"";"
4980;1;0;0;0;0;1;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;update copyright to  rxjava contributors;updating all files containing a copyright header to change from  netflix  inc  to  rxjava contributors  as per https://github.com/reactivex/rxjava/issues/4978.;;0;update copyright to rxjava contributors;updating all files containing a copyright header to change from netflix inc to rxjava contributors as per https://githubcom/reactivex/rxjava/issues/4978;hello you still have netflix in few files  || hi @punksta  not sure why the standard apache license had that part but i think it could be removed as for the other netflix comments the urls should be updated: [reactivex/rxjava/issues/1451]( || pr welcome ||;;;;1;1;update copyright to rxjava contributorssee  for more information;
"4982;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix observable.concatmapeager bad logic for immediate scalars;the operator  observable.concatmapeager  had a bad optimization targeting scalar and callable sources and emitted their values immediately even if it wasn t that particular source s turn for it.;;4981.0;2x: fix observableconcatmapeager bad logic for immediate scalars;the operator `observableconcatmapeager` had a bad optimization targeting scalar and callable sources and emitted their values immediately even if it wasnt that particular sources turn for itthe `flowable` is not affected added unit tests for bothreported in #4981;  4982  ;2x observable#concatmapeager doesnt always preserve order;""sample code (using rxjava 204):```javaobservablejust(1 2 3 4 5)        concatmapeager(i -> {            systemoutprintln(""""processing """" + i)            return i  3 ? observablejust(i) : observable                    just(i)                    delay(1 timeunitmilliseconds schedulersio())        })        observeon(schedulersio())        subscribe(i -> systemoutprintln(""""value: """" + i))```expected output:```processing 1processing 2processing 3processing 4processing 5value: 1value: 2value: 3value: 4value: 5```actual output:```processing 1processing 2processing 3processing 4processing 5value: 3value: 1value: 2value: 4value: 5```as you can see the order is incorrect this is due to the fact that the item `3` is mapped to a `callable` source which wont wait for the previous observables"";thanks for the feedback this is indeed a bug with `observableconcatmapeager()` `flowable` works properlyill post a fix shortly a workaround is to use `just(i)hide()` to break the bad/false internal optimization || closing via #4982 ||;1;0;dont print-log;"
4984;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix cross-boundary invalid fusion with observeon  flatmap & zip;when  flatmap  and  zip  fuses its sources  it was possible one of the async source polls on another source which executed boundary-sensitive operators ( map    filter ) on the wrong thread.;;0;2x: fix cross-boundary invalid fusion with observeon flatmap & zip;when `flatmap` and `zip` fuses its sources it was possible one of the async source polls on another source which executed boundary-sensitive operators (`map` `filter`) on the wrong threadfor clarity here is a diagram showing the execution flow of a classical and fused setup:( the classical flow everything is push and when flatmap collects the available elements all side-effects happened inside `map`in the fused flow there are no queues and the onnext call is an indication to `poll()` on the sources inside `flatmap` (or zip) if the first source triggers onnext that source is correctly polled and `map` executes on the right thread however when the flatmap continues to collect other available elements it polls on the other source and executes that `map` still on the first scheduler despite that source having its own scheduler specifiedthe solution is to mark `flatmap` and `zip`s inner consumer as boundary sensitive which prevents the fusion above since `map` is also marked as boundary sensitiverelated: https://githubcom/reactor/reactor-core/issues/342;  4984  ;;;;1;1;2x: fix cross-boundary invalid fusion with observeon & zip;
"4987;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: make obs.combinelatest consistent with flowable + doc cornercase;this pr fixes  observable.combinelatest  to be consistent with  flowable.combinelatest  by not subscribing to additional input sources if the operator reached a terminal state due to a valueless source (that completes or errors). in addition  such early termination didn t properly cancel the other sources when  delayerrors == true .;;4414.0;2x: make obscombinelatest consistent with flowable + doc cornercase;this pr fixes `observablecombinelatest` to be consistent with `flowablecombinelatest` by not subscribing to additional input sources if the operator reached a terminal state due to a valueless source (that completes or errors) in addition such early termination didnt properly cancel the other sources when `delayerrors  true`ive also extended the documentation on the overloads to warn about empty sources that will terminate the operator even with `combinelatestdelayerror` and thus subscription side-effects may not happenthere is a related issue #4414 where the operator should fully consume each input source no matter what and terminate when all terminate im still considering what would be the best way to introduce thisreported in #4986;""  4987  **<  "";combinelatestdelayerror emits error before all inner observables emit result;""recently i came across following issue while using `combinelatestdealyerror` operator this code has been tested on android nexus 5x running os 601```observable<boolean> errorobservable  observablecreate(subscriber -> {    subscriberonerror(new nullpointerexception())})observable timeoutobservable  observablecreate(subscriber -> {    subscriberonnext(true)    subscriberoncompleted()})delay(5 timeunitseconds androidschedulersmainthread())doonnext(result -> logd(""""combine"""" """"delay emitted""""))observable<object> zippedobservable  observablezip(        observablejust(true) timeoutobs        (flag1 flag2) -> {            logd(""""combine"""" """"on zip emitted"""")            return new object()        })return observablecombinelatestdelayerror(        arraysaslist(errorobservable zippedobservable)        result -> {            boolean flag1  (boolean) result[0]            object object  result[1]            logd(""""combine"""" """"result of errorobservable: """" + flag1)            logd(""""combine"""" """"result of zippedobservable: """" + object)            return null        })subscribeon(schedulersio())        observeon(androidschedulersmainthread())        subscribe(new subscriber<object>() {            @override            public void oncompleted() {                logd(""""combine"""" """"oncompleted"""")            }            @override            public void onerror(throwable e) {                logd(""""combine"""" """"onerror"""")            }            @override            public void onnext(object o) {                logd(""""combine"""" """"onnext"""")            }        })```this piece of code is trying to simulate callbacks using delays - for example android pay availability callbackproblem here arises once this code is run the log will be:```onerrordelay emittedon zip emitted```this is quite contradictory to the docs that state that expected behavior should be:```delay emittedon zip emittedonerror```the expected result does happens if you add `subscriberonnext(true)`  to the `errorobservable` before `subscriberonerror`"";""your `errorobservable` doesnt emit any value and since `combinelatestdelayerror` wont ever be able to combine values it terminates with the error immediately || docs state:> concatenates the observable sequence of observables into a single sequence by subscribing to each inner observable one after the other one at a time and delays any errors till the all inner and the outer observables terminatein diff:[ empahsis is on:> and delays any errors till the all inner and the outer observables terminatein this scenario second observable is not finished and error is not delayedwhat if you want to make two api calls no matter of the result of previous and combine their result? i do understand that there is always different type of solution and approach but i just believe that either docs are not correct or this is potential bug since it should behave as stated || the documentation is incorrect as there is no """"outer `observable`"""" with this operator otherwise its an undocumented corner case that needs a revisit note however that even if the operator delayed the error to the very end you wouldnt see any combined values ever (but perhaps the errors of the others)ill see what it takes to make the operator wait out all events || this is more complicated to work out the proper rules for example what should happen if you `combinelatestdelayerror(empty() error(x) func2)` or `combinelatestdelayerror(error(x) empty() just(1) func3)`? || for `combinelatestdelayerror(empty() error(x) func2)` it makes sense that `empty()` will terminate and `onerror` will be invoked?for second i would say `empty()` then `just(1)` then `onerror` will be invoked?im just following up with an idea its not that i expect it to work that way || `combinelatestdelayerror` can wait out all terminal events to make sure errors are reported after the problem is that if you write `combinelatest(empty() just())` and `combinelatestdelayerror(empty() just())` they are no longer behaving the same way || /cc @zsxwing  || sorry for the delay once rc3 is released ill look into it and work out the details || ive considered many alternatives and can give you a reasonable workaround: apply `cache()` on the source `observable` which you want to be consumed entirely even if the `combinelatest` cancels its consumer || i spent a considerable amount of time on this and was unable to come up with a reasonable way for changing `combinelatest` inside rxjava all i can offer is i write you a custom operator that awaits all sources to terminate in some fashion regardless of having been emitted values or not || "";1;0;early termination to cancel the other sources;"
"4987;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: make obs.combinelatest consistent with flowable + doc cornercase;this pr fixes  observable.combinelatest  to be consistent with  flowable.combinelatest  by not subscribing to additional input sources if the operator reached a terminal state due to a valueless source (that completes or errors). in addition  such early termination didn t properly cancel the other sources when  delayerrors == true .;;498.0;2x: make obscombinelatest consistent with flowable + doc cornercase;this pr fixes `observablecombinelatest` to be consistent with `flowablecombinelatest` by not subscribing to additional input sources if the operator reached a terminal state due to a valueless source (that completes or errors) in addition such early termination didnt properly cancel the other sources when `delayerrors  true`ive also extended the documentation on the overloads to warn about empty sources that will terminate the operator even with `combinelatestdelayerror` and thus subscription side-effects may not happenthere is a related issue #4414 where the operator should fully consume each input source no matter what and terminate when all terminate im still considering what would be the best way to introduce thisreported in #4986;""  4987  **<  "";implement the repeat operator;hi this pr implemented the `repeat` operator #70 please take a look thanks!;""#422  i believe this stack overflows:``` java        observablefrom(1)repeat()toblockingobservable()foreach(new action1<integer>() {            @override            public void call(integer t1) {            }})```stacktrace:```javalangruntimeexception: javalangstackoverflowerror    at rxobservablesblockingobservableforeach(blockingobservablejava:159)    at rxoperatorsoperationrepeattestmain(operationrepeattestjava:39)caused by: javalangstackoverflowerror    at javautilhashmap$entry<init>(hashmapjava:814)    at javautilhashmapcreateentry(hashmapjava:901)    at javautilhashmapaddentry(hashmapjava:888)    at javautilhashmapput(hashmapjava:509)    at rxsubjectsreplaysubject$subscriptionfunccall(replaysubjectjava:115)    at rxsubjectsreplaysubject$subscriptionfunccall(replaysubjectjava:1)    at rxsubjectsreplaysubject$delegatesubscriptionfunconsubscribe(replaysubjectjava:84)    at rxobservablesubscribe(observablejava:224)    at rxoperatorsoperationmulticast$multicastconnectableobservable$1onsubscribe(operationmulticastjava:41)    at rxobservablesubscribe(observablejava:224)    at rxoperatorsoperationobserveon$observeononsubscribe(operationobserveonjava:50)    at rxobservablesubscribe(observablejava:224)    at rxoperatorsoperationrepeat$1$1oncompleted(operationrepeatjava:82)    at rxsubjectsreplaysubjectoncompleted(replaysubjectjava:141)    at rxoperatorsoperationmulticast$multicastconnectableobservable$2oncompleted(operationmulticastjava:54)    at rxoperatorsoperationtoobservableiterable$toobservableiterableonsubscribe(operationtoobservableiterablejava:48)    at rxobservablesubscribe(observablejava:224)    at rxoperatorsoperationmulticast$multicastconnectableobservableconnect(operationmulticastjava:51)    at rxoperatorsoperationrepeat$1$1oncompleted(operationrepeatjava:83)    at rxsubjectsreplaysubjectoncompleted(replaysubjectjava:141)    at rxoperatorsoperationmulticast$multicastconnectableobservable$2oncompleted(operationmulticastjava:54)    at rxoperatorsoperationtoobservableiterable$toobservableiterableonsubscribe(operationtoobservableiterablejava:48)    at rxobservablesubscribe(observablejava:224)    at rxoperatorsoperationmulticast$multicastconnectableobservableconnect(operationmulticastjava:51)    at rxoperatorsoperationrepeat$1$1oncompleted(operationrepeatjava:83)    at rxsubjectsreplaysubjectoncompleted(replaysubjectjava:141)    at rxoperatorsoperationmulticast$multicastconnectableobservable$2oncompleted(operationmulticastjava:54)    at rxoperatorsoperationtoobservableiterable$toobservableiterableonsubscribe(operationtoobservableiterablejava:48)    at rxobservablesubscribe(observablejava:224)    at rxoperatorsoperationmulticast$multicastconnectableobservableconnect(operationmulticastjava:51)    at rxoperatorsoperationrepeat$1$1oncompleted(operationrepeatjava:83)    at rxsubjectsreplaysubjectoncompleted(replaysubjectjava:141)    at rxoperatorsoperationmulticast$multicastconnectableobservable$2oncompleted(operationmulticastjava:54)    at rxoperatorsoperationtoobservableiterable$toobservableiterableonsubscribe(operationtoobservableiterablejava:48)    at rxobservablesubscribe(observablejava:224)    at rxoperatorsoperationmulticast$multicastconnectableobservableconnect(operationmulticastjava:51)    at rxoperatorsoperationrepeat$1$1oncompleted(operationrepeatjava:83)    at rxsubjectsreplaysubjectoncompleted(replaysubjectjava:141)    at rxoperatorsoperationmulticast$multicastconnectableobservable$2oncompleted(operationmulticastjava:54)    at rxoperatorsoperationtoobservableiterable$toobservableiterableonsubscribe(operationtoobservableiterablejava:48)    at rxobservablesubscribe(observablejava:224) etc```if `subscriptions` has not been touched before the stackoverflow you will instead see this:```javalangnoclassdeffounderror: could not initialize class rxsubscriptionssubscriptions    at rxobservablesubscribe(observablejava:254)    at rxobservablesblockingobservableprotectivelywrapandsubscribe(blockingobservablejava:93)    at rxobservablesblockingobservableforeach(blockingobservablejava:121)    at rxoperatorsoperationrepeattestmain(operationrepeattestjava:39)```we need to use the recursive scheduler idiom to implement repeat || small detail: in some places you should replace """"thenumberoftimestorepeattheelement"""" by """"thenumberoftimestorepeatthe source sequence"""" || is there a reason the repeat() uses an external scheduler and the replaysubject? how about a simpler approach:``` java    public static <t> onsubscribefunc<t> repeat(final observable<t> source final int count) {        return new onsubscribefunc<t>() {            @override            public subscription onsubscribe(final observer<? super t> t1) {                final serialsubscription sreg  new serialsubscription()                final observable<t> ssource  sourcesubscribeon(schedulerscurrentthread())                observer<t> o  new observer<t>() {                    int remaining  count                    @override                    public void onnext(t args) {                        t1onnext(args)                    }                    @override                    public void onerror(throwable e) {                        try {                            t1onerror(e)                        } finally {                            sregunsubscribe()                        }                    }                    @override                    public void oncompleted() {                        if (remaining-- > 0) {                            sregsetsubscription(ssourcesubscribe(this))                        } else {                            t1oncompleted()                            sregunsubscribe()                        }                    }                }                sregsetsubscription(ssourcesubscribe(o))                return sreg            }        }    }``` || @benjchristensen i think using schedulersimmediate() causes the stack overflow problem here is a test in c#:``` c#        static void main(string args)        {            iobservable<int> obs  observablecreate<int>(o > new foo(o)test(schedulerimmediate 0))            obssubscribe(                x > consolewriteline(""""onnext: """" + x)                )            consolereadline()        }        class foo        {            iobserver<int> _o            public foo(iobserver<int> o)            {                _o  o            }            public idisposable test(ischeduler s int i)            {               return sschedule(i + 1  (scheduler x) > {                    _oonnext(x)                    return thistest(scheduler x)                })            }        }```this code does not cause a stack overflow exceptionbut in rxjava the following unit test will cause a stack overflow exception:``` java    @test    public void testrecursivescheduler1() {        observable<integer> obs  observable                create(new onsubscribefunc<integer>() {                    @override                    public subscription onsubscribe(                            final observer<? super integer> observer) {                        return schedulersimmediate()schedule(0                                new func2<scheduler integer subscription>() {                                    @override                                    public subscription call(                                            scheduler scheduler integer i) {                                        observeronnext(i)                                        return schedulerschedule(i + 1 this)                                    }                                })                    }                })        obssubscribe(new observer<integer>() {            @override            public void oncompleted() {            }            @override            public void onerror(throwable e) {                eprintstacktrace()            }            @override            public void onnext(integer args) {                systemoutprintln(args)            }        })    }```im trying to understand the immediatescheduler in rxnet seems that it also uses a queue to save the actions to avoid the stack overflow exception || #444 #445 [rxjava-pull-requests #446 the current implementation still has some problems which can not be simply handled in `operationrepeat` if using immediatescheduler in `repeat` operator there may be a stack overflow exception mentioned above if using currentthreadscheduler the following test will not stop i suppose it should stop when the observer has some error``` java    @test    public void testrepeatwithinfiniterepeatcountwithcurrentthread() {        observable<string> observable  repeat(""""foo"""" schedulerscurrentthread())        @suppresswarnings(""""unchecked"""")        observer<string> observer  (observer<string>) mock(observerclass)        doanswer(new answer<void>() {            private int count  0            @override            public void answer(invocationonmock invocation) throws throwable {                count++                if (count  100) {                    // only verify if repeating 100 times                    // we can not really verify if repeating infinitely                    throw new runtimeexception(""""some error"""")                }                return null            }        })when(observer)onnext(anystring())        observablesubscribe(observer)        inorder inorder  inorder(observer)        inorderverify(observer times(100))onnext(""""foo"""")        inorderverify(observer)onerror(isa(runtimeexceptionclass))        inorderverifynomoreinteractions()    }``` || - you should use the current thread scheduler (which is what c# does) see my pull request- i dont think we need an overload with count just as easy to do a take(n) afterwards- there is an issue with toblocking observable where it does not terminate that does not appear in toeneumerable() in net || > you should use the current thread scheduler (which is what c# does) see my pull requestagree but now as the current thread has some issue i use immediatescheduler to pass the unit test> i dont think we need an overload with count just as easy to do a take(n) afterwardscould you give me an example? how can we know the `n` to use in `take` when the observable size is unknown> there is an issue with toblocking observable where it does not terminate that does not appear in toeneumerable() in neti suppose my problem its about safeobservablesubscription and safeobserver but maybe we are talking about the same issue since safeobservablesubscription and safeobserver are used in toblockingobservable too || this hangs in rxnet as well (21302140)``` c#observablereturn(1)repeat()take(100)subscribe(consolewriteline)```the issue is in the `repeatsubscribe()` not returning until the (infinite) re-subscription finishes so there is no way the take method can signal its uplink to terminate as it hasnt yet received a reference to it however this works:``` c#observablereturn(1 schedulerdefault)repeat()take(100)subscribe(consolewriteline)```as now the repeatoncompleted can run in another thread and the repeatsubscribe() can returni believe this can be achieved by not subscribing to the raw source in the repeatsubscribe() but rather using subscribeon(schedulersnewthread()) to move the subscription into a parallel thread and let the repeatsubscribe() return``` javapublic static <t> onsubscribefunc<t> repeat(final observable<t> source final int count) {    return new onsubscribefunc<t>() {        @override        public subscription onsubscribe(final observer<? super t> t1) {            final serialsubscription sreg  new serialsubscription()            final observable<t> ssource  sourcesubscribeon(schedulersnewthread())            observer<t> o  new observer<t>() {                int remaining  count                @override                public void onnext(t args) {                    t1onnext(args)                }                @override                public void onerror(throwable e) {                    try {                        t1onerror(e)                    } finally {                        sregunsubscribe()                    }                }                @override                public void oncompleted() {                    if (remaining-- > 0) {                        sregsetsubscription(ssourcesubscribe(this))                    } else {                        t1oncompleted()                        sregunsubscribe()                    }                }            }            sregsetsubscription(ssourcesubscribe(o))            return sreg        }    }}``` || > i believe this can be achieved by not subscribing to the raw source in the repeatsubscribe() but rather using subscribeon(schedulersnewthread()) to move the subscription into a parallel thread and let the repeatsubscribe() returnthanks you remind me one thing: there is not an `repeat` overload with observable and scheduler together in rxnet when i tried to implement the `repeat` overload i was wondering why there was not a such overload maybe this is because `repeat` can not be used with all of schedulers however even if we do not provide such overload users still can use schedulers  observeon` for example `observablefrom(1)repeat()take(100)observeon()(schedulerscurrentthread)`so is it ok that we do not provide this kind of method and warn that `should not use repeat with schedulerscurrentthread() or schedulersimmediate()` in the document? || i think rxnet started out its return operator to run on the threadpool if manually put back there the example works nowadays it runs on the immediate scheduler causing the problem even if you warn the user about the scheduler there is no way to know if an incoming observable is dangerous or not this affects other operators such as concat and onerrorresume || return always used the immediate scheduler :-) || same stack overflow issue happens in `interval```` java    @test    public void testintervalwithimmediatescheduler() {        observableinterval(1 timeunitmilliseconds schedulersimmediate())                subscribe(new observer<long>() {                    @override                    public void oncompleted() {                        systemoutprintln(""""oncompleted"""")                    }                    @override                    public void onerror(throwable e) {                        eprintstacktrace()                    }                    @override                    public void onnext(long args) {                        systemoutprintln(args)                    }                })    }``` || currentthreadscheduler can work with `interval` because `interval` does not use safeobservablesubscription and safeobserver || i am working with @headinthebox on changes to schedulers including `interval` and will come back to this and  when ready || completed in  || "";1;0;early termination to cancel the other sources;"
4989;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix observable.singleelement doc;fixes a subtle documentation bug.  observable.singleelement  returns  maybe<t>   not  observable<t> .;;0;2x: fix observablesingleelement doc;fixes a subtle documentation bug `observablesingleelement` returns `maybe<t>` not `observable<t>`;  4989   ;;;;1;1;2x: fix observablesingleelement doc;
4990;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: update marble diagrams for sample overloads;this pr updates the referenced marble diagrams to reflect the actual behavior and options with  sample .;;0;2x: update marble diagrams for sample overloads;this pr updates the referenced marble diagrams to reflect the actual behavior and options with `sample`new images:  - `sample(time emitlast)`(  - `sample(time scheduler emitlast)`![image](  - `sample(other)` - the [original image]( indicated the emission of the last item which was not the case![image](  - `sample(other emitlast)`![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/sampleoemitlastpng);  4990 is reflected in some of the existing marble diagrams || those tail symbols look odd to me and look easy to miss or categorize as diagram errors ||;;;;1;1;add maybe and switchifempty diagrams;
4992;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: a.flatmapb to eagerly check for cancellations before subscribing;the  flatmap  implementations always subscribed to the generated inner source even if there was an asynchronous cancel while the function was running. with typical functions  there is only a really tiny window inside function but some users tend to block/sleep in the function and when that returns  the  flatmap  operator is already cancelled.;;0;2x: aflatmapb to eagerly check for cancellations before subscribing;the `flatmap` implementations always subscribed to the generated inner source even if there was an asynchronous cancel while the function was running with typical functions there is only a really tiny window inside function but some users tend to block/sleep in the function and when that returns the `flatmap` operator is already cancelled if the generated inner source emitted an error disregarding its own cancellation signal (the `error()` operators do this) those errors end up in the `rxjavapluginsonerror` and crash the app (on android)this pr adjusts the `flatmap` implementations to check for the disposed/cancelled state before subscribing to the inner source for `observable` and `flowable` this has practically no extra overhead as the add/remove already checks for the terminal state and can return a boolean for it the rest require an explicit `isdisposed()` check;  4992   ;;;;1;1;2x: aflatmapb to eagerly check for cancellations before subscribing;
4994;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: assertnever(t value) / assertnever(predicate<t> valuepredicate);this pull request adds to any class extending    baseconsumertest    the ability to assert that a given value was not emitted by the observable it was subscribed to  either with    assertnever(t value)   or    assertnever(predicate<t> valuepredicate);;0;2x: assertnever(t value) / assertnever(predicate<t> valuepredicate);this pull request adds to any class extending ```baseconsumertest``` the ability to assert that a given value was not emitted by the observable it was subscribed to either with ```assertnever(t value)```or ```assertnever(predicate<t> valuepredicate)```;  4994  ;;;;1;1;changes according second pr review;
"5000;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add which are the other stardard methods of create;i was using  observable.create(onsubscribe) . i knew about the warning:;;0;add which are the other stardard methods of create;i was using `observablecreate(onsubscribe)` i knew about the warning:> this method requires advanced knowledge about building operators and data sources please consider other standard methods firstbut i didnt know which were the *other stadard methods* there were no clue in the javadoc with this change the problem is gone;""> but i didnt know which were the other stadard methodsi accept this change but developers should really spend time discovering the methods of rxjava for themselves otherwise wed have 30k lines in `observablejava` just to link and explain correlated methods ||   5000   updatedi understand your concerns about the lenght of this file but theres too much noise on internet about this method: posts tutorials gists || the reactivexio docs group operators by category including a """"creatingobservables"""" < this may help you if youre trying to find just the rightoperator to initiate an observableon tue jan 17 2017 at 4:36 am david karnok <notifications@githubcom>wrote:> merged #5000 < > you are receiving this because you are subscribed to this thread> reply to this email directly view it on github> < or mute> the thread> < >-- david m grossplp consulting || i know and this is all the information that i can find there:> rxjava implements this operator as create>> it is good practice to check the observers isunsubscribed state from within the function you pass to create so that your observable can stop emitting items or doing expensive calculations when there is no longer an interested observernothing about `fromemitter` the other overloads of `create` or the advance usage of `create(onsubscribe)` an update there would be great too but i dont how to contribute there || "";;;;1;1;add which are the other stardard methods of create;"
5002;1;0;0;0;0;1;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add scheduler creation factories;4993;;4993.0;2x: add scheduler creation factories;4993this is a pretty vanilla copy from rxjava 1s implementation note that i had to tune newthread scheduler to not be a singleton to support thiswe had talked about borrowing from project reactors apis for different overloads let me know if you think we should add more fine-grained controls through these;one other thing im worried about - is `schedulers` the best place for this? rxjava 1 had them in its `rxjavahooks` class my concern is that having these alongside the normal `io()`/`computation()`/etc factories will make them look overly inviting for use and accidental abuse || > one other thing im worried about - is schedulers the best place for this? rxjava 1 had them in its rxjavahooks class my concern is that having these alongside the normal io()/computation()/etc factories will make them look overly inviting for use and accidental abuseanother problem is that people will try to override the scheduler-init with these method calls for `rxjavaplugins` but referencing `schedulers` will init the default schedulers regardlessindeed `rxjavaplugins` sounds like a better place for the methods but keep only the `threadfactory` variants || heading to bed right now but will update the pr in the morning with requested changes also let me know if theres anywhere i should put tests as i wasnt sure what the right place would be || > indeed rxjavaplugins sounds like a better place for the methods but keep only the threadfactory variantssounds good to me will do that in my updates tomorrow || yes tests that verify the custom thread factory actually worked by checking a custom thread name for each case ||   5002   > indeed rxjavaplugins sounds like a better place for the methods8b4d461> but keep only the threadfactory variants8009333also tweaked the naming a bit `newnewthread` was a little weird (went with `create`) and added `scheduler` suffix since were not in the `schedulers` class anymore> yes tests that verify the custom thread factory actually worked by checking a custom thread name for each casei tried setting this up matching some of the cdl-based approaches in the plugin tests but want able to get it working (just hangs) pushed what i had in a1029b4 any insight? || heading on vacation for a couple weeks but let me know what you think of getting the tests to work i should have some time here and there to update the pr || ive already told you: use the runnable in the factory method on the thread constructor || > use the runnable in the factory method on the thread constructorarent i just testing the test threadfactory implementations then and not that the schedulers are hooked up properly to power the scheduler? ||  || whats the problem with the tests? they seem to be verifying that the supplied factory was used || oh you didnt pass the supplied `runnable` when calling `new thread()` inside the factory || > oh you didnt pass the supplied runnable when calling new thread() inside the factoryah! this is what i was missing thanks for pointing that out ive updated tests (which should now all be passing) and also made them a bit more robust (full integration with schedulers) to simulate a more real world use case  || failing test looks like a flake || wait no its not reprod locally will fix ||  i think i added manual shutdowns of schedulers after theyre done only io had this lifecycle issue over tests but i did the shutdown in all to be safe || ok this time it seems actually flaky as the same commit passed in a different travis job against my fork -  || ;2x: should schedulers have rxthreadfactory constructor parameters?;rxjava 1 allowed for specifying a custom thread factory but it looks like this feature did not make it to rxjava 2 was this intentional or something that a pr would be welcome for?;which scheduler? computation? it was intentional you can now configure the priority of each scheduler so there was little benefit from a customizing the factory use the [parallelscheduler]( from extensions which allows more [customization]( || we used it for the io scheduler as well it was useful for tracking our own thread naming and setting their priority to android-specific priorities wed like to use it for that and singlescheduler can parallelscheduler be used as a substitute for non-computation schedulers too? || since scheduler implementations are internal it is not recommended anyway to use them directlyparallelscheduler is an individual scheduler with a specified number of threads that doesnt change over time so unlike io() parallelscheduler wont stop its threads when they become idle for too long || > since scheduler implementations are internal it is not recommended anyway to use them directlyim not sure i follow as in we shouldnt create a new ioscheduler instance? || prior discussions/work for reference - #3724 #3879 || anything in the `ioreactivexinternal*` is considered private and not part of any binary or api compatibility contracts || so either use `schedulersfrom(executor)` with your own pool or copy the internal code and change it locally || i missed that they were internal now thats disappointing to see and seems like a bit of a step backward compared to rxjava 1 well just copy then :| || theyre internal in 1x too the only remnants are public for binarycompatibility that no one should be using anyway are you referring to thefactory methods? those could easily be replicated on 2xon fri jan 13 2017 4:22 am zac sweers <notifications@githubcom> wrote:> i missed that they were internal now thats disappointing to see and> seems like a bit of a step backward compared to rxjava 1 well just copy> then :|>> > you are receiving this because you are subscribed to this thread> reply to this email directly view it on github> < or mute the thread> < > || yeah i was referring to the factory methods basically wanted to do the same thing you added in the linked pr above || > those could easily be replicated on 2x@akarnokd any thoughts on this? this is what i was thinking of in opening this issue in case i wasnt clear before || they will be still internal classes however we could expose them for example `schedulersnewcomputation()` `schedulersnewio()` etc where extra parameters can be passed in similar to how project reactors schedulers were exposed || that sounds reasonable to me[ the apis they expose cover pretty much everything wed want]( would be happy to make a pr matching those if youre up for it || sure ||;1;0;merge branch 2x into schedulerfactories;
5005;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: executorscheduler.scheduledirect to report isdisposed on complete;this pr makes the  disposable  returned by the  executorscheduler.scheduledirect()  report  isdisposed   true  if the task has actually finished  which should now be consistent with the  worker  behavior of other schedulers.;;5004.0;2x: executorschedulerscheduledirect to report isdisposed on complete;this pr makes the `disposable` returned by the `executorschedulerscheduledirect()` report `isdisposed` `true` if the task has actually finished which should now be consistent with the `worker` behavior of other schedulersreported in #5004;  5005  ;204: an infinite disposable;this fails:    @test    public void directscheduleonsinglethreadexecutor() {        scheduler scheduler  schedulersfrom(executorsnewsinglethreadexecutor())        disposable disposable  schedulerscheduledirect(() -> {        })        long start  nanotime()        while (!disposableisdisposed()) {            asserttrue(nanotime() - start < secondstonanos(10))        }    }while replacing `from()` with `io()` worksi cant find where the error exactly is my debugger cant jump in to the right source code line;yes the internal `executorschedulerbooleandisposable` doesnt set its state to disposed after the task has runhow much problem is it for you? (sidenote: it is generally not recommended to spin on `isdisposed()` because that nullifies the reason rxjava exists: not blocking on `futureget()` or spinning on `futureisdone()`) || the bug it was causing is that when user scrolls messages up i wanted paging to run if it is not already running after the transition to rxjava 2 i started to use this new `scheduledirect` method the first paging iteration worked as expected but after that it just hangs up without any signs of livingthis is my current workaround:    public static disposable scheduledirect(scheduler scheduler runnable runnable) {        schedulerworker worker  schedulercreateworker()        workerschedule(() -> {            try {                runnablerun()            } finally {                workerdispose()            }        })        return worker    } || (as a sidenote: some real-world tasks do require blocking operations or running of tasks depending on other tasks state) || okay for consistency with other schedulers ill post a fix for this || cool! :) || closing via #5005 ||;1;0;2x: executorschedulerscheduledirect to report isdisposed on complete;
5006;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: improve the parallel() mode test coverage  improve its code;this pr adds additional unit tests for the  parallel()  operators  plus:;;0;2x: improve the parallel() mode test coverage improve its code;this pr adds additional unit tests for the `parallel()` operators plus:  - adds conditional fusion to `runon` `filter` and `map` operators  - exposes the `flowableflatmap`s internal `subscriber` to be reused with `parallelflowableflatmap`  - uses the `flowableconcatmap`s internal `subscriber` to be reused with `parallelflowableconcatmap`  - fix generics with `collect` and `reduce`  - change queue overflow errors to `missingbackpressureexception`  - make sure join-like operators dont emit the same upstream `throwable` to the `rxjavapluginsonerror` handler if all rails have the same error reference;  5006  ;;;;1;1;2x: improve the parallel() mode test coverage improve its code;
"5007;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: update sample(time) diagram to indicate emission of last;this pr updates the 1.x  sample(time)  diagram to indicate the last value is emitted when the sequence completes. it is the same (style) as for 2.x:;;495.0;1x: update sample(time) diagram to indicate emission of last;this pr updates the 1x `sample(time)` diagram to indicate the last value is emitted when the sequence completes it is the same (style) as for 2x:default scheduler:( scheduler:![image]( #4952;  5007  ;zip many rewritten concat with iterable merge with iterable;ive rewritten the zip method to terminate as soon as possible in addition the concat(iterable<observable<t>> and merge(iterable<observable<t>>) where missing from observable;""#418  @akarnokd thank you for this im checking out the branch now to play with it and see how the problematic unit tests behavewould you mind re-submitting the pull request though after rebasing this onto a new branch so we dont have all the commit clutter resulting from you working on your master branch? the commit """"merge origin/master""""  and commits before that are a result of merging /netflix/rxjava master into your master then submitting back from the same branch it is preferable to always commit only to a clean branch and submit a pull request from that so only the relevant commits are applied the only time anything should commit to your forked master is when fetching from the upstream to sync back up i want to confirm a unit test for this code @headinthebox can you please validate something? the following unit test shows how this will correctly complete once the first stream completes however it still waits until all items are emitted before the `oncompleted` is sent i want to ensure thats how it should behave as opposed to skipping those and completing as soon as oncomplete is sent (like onerror should)``` java    @test    public void testonfirstcompletion() {        publishsubject<string> oa  publishsubjectcreate()        publishsubject<string> ob  publishsubjectcreate()        @suppresswarnings(""""unchecked"""")        observer<string> observer  mock(observerclass)        observable<string> o  observablecreate(zip(oa ob getconcat2strings()))        osubscribe(observer)        inorder inorder  inorder(observer)        oaonnext(""""a1"""")        inorderverify(observer never())onnext(anystring())        obonnext(""""b1"""")        inorderverify(observer times(1))onnext(""""a1-b1"""")        obonnext(""""b2"""")        inorderverify(observer never())onnext(anystring())        oaonnext(""""a2"""")        inorderverify(observer times(1))onnext(""""a2-b2"""")        oaonnext(""""a3"""")        oaonnext(""""a4"""")        oaonnext(""""a5"""")        oaoncompleted()        // should oncomplete be emitted here instead of waiting       // for b3 b4 b5 to be emitted?        obonnext(""""b3"""")        obonnext(""""b4"""")        obonnext(""""b5"""")        inorderverify(observer times(1))onnext(""""a3-b3"""")        inorderverify(observer times(1))onnext(""""a4-b4"""")        inorderverify(observer times(1))onnext(""""a5-b5"""")        // we receive the oncomplete here        inorderverify(observer times(1))oncompleted()        obonnext(""""b6"""")        obonnext(""""b7"""")        obonnext(""""b8"""")        obonnext(""""b9"""")        // never completes (infinite stream for example)        // we should receive nothing else despite ob continuing after oa completed        inorderverifynomoreinteractions()    }    private func2<string string string> getconcat2strings() {        return new func2<string string string>() {            @override            public string call(string t1 string t2) {                return t1 + """"-"""" + t2            }        }    }``` || this confirms the `onerror` event is propagated immediately:``` java@test    public void testonerrortermination() {        publishsubject<string> oa  publishsubjectcreate()        publishsubject<string> ob  publishsubjectcreate()        @suppresswarnings(""""unchecked"""")        observer<string> observer  mock(observerclass)        observable<string> o  observablecreate(zip(oa ob getconcat2strings()))        osubscribe(observer)        inorder inorder  inorder(observer)        oaonnext(""""a1"""")        inorderverify(observer never())onnext(anystring())        obonnext(""""b1"""")        inorderverify(observer times(1))onnext(""""a1-b1"""")        obonnext(""""b2"""")        inorderverify(observer never())onnext(anystring())        oaonnext(""""a2"""")        inorderverify(observer times(1))onnext(""""a2-b2"""")        oaonnext(""""a3"""")        oaonnext(""""a4"""")        oaonnext(""""a5"""")        oaonerror(new runtimeexception(""""forced failure""""))        // it should emit failure immediately        inorderverify(observer times(1))onerror(any(runtimeexceptionclass))        obonnext(""""b3"""")        obonnext(""""b4"""")        obonnext(""""b5"""")        obonnext(""""b6"""")        obonnext(""""b7"""")        obonnext(""""b8"""")        obonnext(""""b9"""")        // never completes (infinite stream for example)        // we should receive nothing else despite ob continuing after oa completed        inorderverifynomoreinteractions()    }``` || sorry for the clutter im new to git in this manner will do a new pull shortly || > sorry for the clutter im new to git in this manner will do a new pull shortlynot a problem the git flow for pull requests is not obvious when first starting i totally messed up a few repos when i first started had to wipe them out and start fresh with clean forks until i got the hang of it :-) || closing as replaced by  || "";1;0;1x: update sample(time) diagram to indicate emission of last;"
"5020;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: option to fail for using blockingx on the computation scheduler;this pr adds an  rxjavaplugins  option  failonnonblockingscheduler  that triggers an  illegalstateexception  when the user tries to run a blocking method while the execution is on the  computation()  or  single()   scheduler :;;0;2x: option to fail for using blockingx on the computation scheduler;""this pr adds an `rxjavaplugins` option `failonnonblockingscheduler` that triggers an `illegalstateexception` when the user tries to run a blocking method while the execution is on the `computation()` or `single()` `scheduler`: ```javaflowablejust(1)subscribeon(schedulerscomputation())map(v -> flowablejust(""""query"""")subscribeon(schedulersio())blockingfirst())doonnext(v -> someapi(v)subscribeon(schedulersnewthread())blockingsubscribe())blockingfirst()```it is an optional setting default offthe check is done before going into an await method (and a few other types of blocking) most blocking operators usually poll the status and try to avoid the actual blocking thus this shouldnt affect synchronous sequences that one extracts a value fromdetection of a blocking-sensitive schedulers thread is done by checking the current threads class for implementing the `nonblockingthread` marker interface (currently `internal`)the `rxthreadfactory` has been updated to allow picking a default `thread` implementation or a custom one for the `newthread()` note that since #5002 you can create custom schedulers by providing a `threadfactory`this works for rxjavas default schedulers but not for `androidschedulersmainthread()` where similar blocking should be avoided as well for them a plugin-callback action would be more suitable ~~question is how that callback should behave (throw return false should it be always executed or only when the flag is true)~~my proposed solution is to have a plugin callback `rxjavapluginssetonbeforeblocking(booleansupplier)` that android users can define the callback for:```javarxjavapluginssetonbeforeblocking(() -> loopermylooper()  loopergetmainlooper())rxjavapluginssetfailonnonblockingscheduler(true)```this callback is only executed if the `failonnonblockingscheduler` is set to true"";  5020  ;;;;1;1;add a custom rxjavaplugins callback onbeforeblocking;"
"5023;1;0;0;0;0;1;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add nullability annotations to io.reactivex.annotations interfaces.;(addresses https://github.com/reactivex/rxjava/issues/4876);;0;add nullability annotations to ioreactivexannotations interfaces;""(addresses  pull request annotates everything in the `ioreactivexannotations` package with a new `@nonnull` annotation defined in rxjava this doesnt annotate everything but i think its a good startin particular when migrating a large codebase of rxjava 1x code to 2x catching null returns in these interfaces was very difficult at best its noticed while migrating otherwise its up to unit tests or a production crash to catch thesewith these new annotations you get much better ide support (once you tell intellij about the new annotation):<img width""""563"""" alt""""screen shot 2017-01-27 at 2 30 18 pm"""" src"""" in this example `getphonenumber()` is marked as `@nullable`in addition support for this annotation can easily be added to static analysis tools like infer checker or any other popular toolopen questions* does this even make sense to add? there seem to be some concerns in the issue* the `@nonnull` annotation needs javadoc - im planning on following up with whatever is in existing nonnull annotations floating around unless anyone thinks otherwise* there are no tests since this is essentially just metadata should there be something that enforces this? im not sure if there is any kind of lint tool that runs on this project but one approach would be to write a check that enforces everything in specific packages in annotated this would also help keep future changes annotated* is it worth adding this elsewhere? i find these function interfaces to be the easiest place to run into nullability problems but im curious what others think a simple but kind of crazy brute force approach would be to require annotations on every public api"";  5023   /cc @dlew @vanniktech  || this looks fine to me as a start || great! ||;;;;1;1;annotate function interfaces;"
5027;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: dedicated single.zip implementation  no dispose on all-success;this adds a dedicated implementation for zipping  single s (adapted from  maybezipx ).;;5024.0;2x: dedicated singlezip implementation no dispose on all-success;this adds a dedicated implementation for zipping `single`s (adapted from `maybezipx`)routing the original `zip` through `flowable` added the usually unwanted behavior of cancelling the sources if one of them reports a completion after a row has been consumed from all (when converted to `flowable` `singleobserveronsuccess` becomes `subscriberonnext` + `oncomplete`) since there is only `onsuccess` and `onerror` in `single` there is no need to dispose the sources once all signalled their only `onsuccess`related: #5024;  5027  ;question about interrupted threads in rxjava2;hii have a question thats similar to #4863 but a bit simpler i am running into a strange issue that i have been able to simplify to a simple test case - whats happening is sometimes by the time my most downstream method is called the thread is interrupted (which causes issues because the code i call there bails if the thread is interrupted)ive been able to simplify the code and repro using this:```java  private single<arraylist<integer>> fakedatapiece() {    return singlefromcallable(() -> {      threadsleep(500)      return new arraylist<integer>()    })subscribeon(schedulersio())  }  private single<bookmarkdata> fakegetdata() {    return singlezip(fakedatapiece() fakedatapiece() fakedatapiece()        (integers integers2 integers3) ->            new bookmarkdata(new arraylist<>() new arraylist<>() new arraylist<>()))        subscribeon(schedulersio())  }  public single<uri> exportbookmarksobservable() {        return fakegetdata()        flatmap(bookmarkdata -> singlejust(exportbookmarks(bookmarkdata)))        subscribeon(schedulersio())  }```by the time `exportbookmarks` is called in many cases `threadcurrentthread()isinterrupted()` returns `true`my question is: why is the thread interrupted? (i am curious as to whether this is expected or if there is something i am misunderstanding or doing wrong)observations:1 if i explicitly remove all the `subscribeon`s except for the one in `exportbookmarksobservable` then i dont see the issue (though it does change the behavior a bit in the sense that with this all workers are run on the same thread as opposed to each piece of work happening on a potentially different thread)2 if i add a `doonsuccess` in `fakegetdata()` i find the thread is interrupted (and is the same thread that `exportbookmarks` gets called on while also being interrupted) this also is the same as one of the `fakedatapiece` threads which at the time of its completion is not interrupted3 calling `threadinterrupted()` as suggested in #4863 also fixes the problemi am using rxjava 204 - thanks!;could you create a self contained unit test (in a gist)? or you could apply doondisposed() everywhere to see if the problem is due to internal disposing || here is a self contained unit test that fails: respect to `doondisposed` i find that only the first 3 parameters to `zip` get `doondisposed` called with the same thread for all 3 and with `isinterrupted()` set to true for the second and third parameters || could you post the stacktrace at those doondispose placed to see what is calling through them || sure:```fakedatapiece: thread[rxcachedthreadscheduler-25main] falsejavalangthreadgetstacktrace(threadjava:1556)comquranlabsandroidquranmodelbookmarkcontrivedtestlambda$fakedatapiece$1(contrivedtestjava:15)ioreactivexinternaloperatorssinglesingledoondispose$doondisposeobserverdispose(singledoondisposejava:60)ioreactivexinternaloperatorssinglesingletoflowable$singletoflowableobservercancel(singletoflowablejava:74)ioreactivexinternalsubscriptionssubscriptionhelpercancel(subscriptionhelperjava:188)ioreactivexinternaloperatorsflowableflowablezip$zipsubscribercancel(flowablezipjava:404)ioreactivexinternaloperatorsflowableflowablezip$zipcoordinatorcancelall(flowablezipjava:161)ioreactivexinternaloperatorsflowableflowablezip$zipcoordinatordrain(flowablezipjava:208)ioreactivexinternaloperatorsflowableflowablezip$zipsubscriberonnext(flowablezipjava:388)ioreactivexinternalsubscriptionsdeferredscalarsubscriptioncomplete(deferredscalarsubscriptionjava:117)ioreactivexinternaloperatorssinglesingletoflowable$singletoflowableobserveronsuccess(singletoflowablejava:63)ioreactivexinternaloperatorssinglesingledoondispose$doondisposeobserveronsuccess(singledoondisposejava:84)ioreactivexinternaloperatorssinglesinglesubscribeon$subscribeonobserveronsuccess(singlesubscribeonjava:68)ioreactivexinternaloperatorssinglesinglefromcallablesubscribeactual(singlefromcallablejava:37)ioreactivexsinglesubscribe(singlejava:2656)ioreactivexinternaloperatorssinglesinglesubscribeon$subscribeonobserverrun(singlesubscribeonjava:89)ioreactivexscheduler$1run(schedulerjava:134)ioreactivexinternalschedulersscheduledrunnablerun(scheduledrunnablejava:59)ioreactivexinternalschedulersscheduledrunnablecall(scheduledrunnablejava:51)javautilconcurrentfuturetaskrun(futuretaskjava:266)javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskaccess$201(scheduledthreadpoolexecutorjava:180)javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:293)javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1142)javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:617)javalangthreadrun(threadjava:745)fakedatapiece: thread[rxcachedthreadscheduler-25main] truejavalangthreadgetstacktrace(threadjava:1556)comquranlabsandroidquranmodelbookmarkcontrivedtestlambda$fakedatapiece$1(contrivedtestjava:15)ioreactivexinternaloperatorssinglesingledoondispose$doondisposeobserverdispose(singledoondisposejava:60)ioreactivexinternaloperatorssinglesingletoflowable$singletoflowableobservercancel(singletoflowablejava:74)ioreactivexinternalsubscriptionssubscriptionhelpercancel(subscriptionhelperjava:188)ioreactivexinternaloperatorsflowableflowablezip$zipsubscribercancel(flowablezipjava:404)ioreactivexinternaloperatorsflowableflowablezip$zipcoordinatorcancelall(flowablezipjava:161)ioreactivexinternaloperatorsflowableflowablezip$zipcoordinatordrain(flowablezipjava:208)ioreactivexinternaloperatorsflowableflowablezip$zipsubscriberonnext(flowablezipjava:388)ioreactivexinternalsubscriptionsdeferredscalarsubscriptioncomplete(deferredscalarsubscriptionjava:117)ioreactivexinternaloperatorssinglesingletoflowable$singletoflowableobserveronsuccess(singletoflowablejava:63)ioreactivexinternaloperatorssinglesingledoondispose$doondisposeobserveronsuccess(singledoondisposejava:84)ioreactivexinternaloperatorssinglesinglesubscribeon$subscribeonobserveronsuccess(singlesubscribeonjava:68)ioreactivexinternaloperatorssinglesinglefromcallablesubscribeactual(singlefromcallablejava:37)ioreactivexsinglesubscribe(singlejava:2656)ioreactivexinternaloperatorssinglesinglesubscribeon$subscribeonobserverrun(singlesubscribeonjava:89)ioreactivexscheduler$1run(schedulerjava:134)ioreactivexinternalschedulersscheduledrunnablerun(scheduledrunnablejava:59)ioreactivexinternalschedulersscheduledrunnablecall(scheduledrunnablejava:51)javautilconcurrentfuturetaskrun(futuretaskjava:266)javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskaccess$201(scheduledthreadpoolexecutorjava:180)javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:293)javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1142)javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:617)javalangthreadrun(threadjava:745)fakedatapiece: thread[rxcachedthreadscheduler-25main] truejavalangthreadgetstacktrace(threadjava:1556)comquranlabsandroidquranmodelbookmarkcontrivedtestlambda$fakedatapiece$1(contrivedtestjava:15)ioreactivexinternaloperatorssinglesingledoondispose$doondisposeobserverdispose(singledoondisposejava:60)ioreactivexinternaloperatorssinglesingletoflowable$singletoflowableobservercancel(singletoflowablejava:74)ioreactivexinternalsubscriptionssubscriptionhelpercancel(subscriptionhelperjava:188)ioreactivexinternaloperatorsflowableflowablezip$zipsubscribercancel(flowablezipjava:404)ioreactivexinternaloperatorsflowableflowablezip$zipcoordinatorcancelall(flowablezipjava:161)ioreactivexinternaloperatorsflowableflowablezip$zipcoordinatordrain(flowablezipjava:208)ioreactivexinternaloperatorsflowableflowablezip$zipsubscriberonnext(flowablezipjava:388)ioreactivexinternalsubscriptionsdeferredscalarsubscriptioncomplete(deferredscalarsubscriptionjava:117)ioreactivexinternaloperatorssinglesingletoflowable$singletoflowableobserveronsuccess(singletoflowablejava:63)ioreactivexinternaloperatorssinglesingledoondispose$doondisposeobserveronsuccess(singledoondisposejava:84)ioreactivexinternaloperatorssinglesinglesubscribeon$subscribeonobserveronsuccess(singlesubscribeonjava:68)ioreactivexinternaloperatorssinglesinglefromcallablesubscribeactual(singlefromcallablejava:37)ioreactivexsinglesubscribe(singlejava:2656)ioreactivexinternaloperatorssinglesinglesubscribeon$subscribeonobserverrun(singlesubscribeonjava:89)ioreactivexscheduler$1run(schedulerjava:134)ioreactivexinternalschedulersscheduledrunnablerun(scheduledrunnablejava:59)ioreactivexinternalschedulersscheduledrunnablecall(scheduledrunnablejava:51)javautilconcurrentfuturetaskrun(futuretaskjava:266)javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskaccess$201(scheduledthreadpoolexecutorjava:180)javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:293)javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1142)javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:617)javalangthreadrun(threadjava:745)``` || thanks i see the problem now: `singlezip` delegates to `flowablezip` which cancels when a source completes before the others completethis has to be  on the operator level so i cant give you any workaround other than the clearing of the interrupted flag or a custom operator that suppresses cancellation if it comes after an onsuccess || closing via #5027 || ;1;0;2x: dedicated singlezip implementation no dispose on all-success;
5036;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: reintroduce onerrornotimplementedexception for 0-1 argument subscribe();this pr reintroduces the  onerrornotimplementedexception  wrapper from 1.x and applies it to the  subscribe()  methods that don t define an  onerror  handler.;;0;2x: reintroduce onerrornotimplementedexception for 0-1 argument subscribe();this pr reintroduces the `onerrornotimplementedexception` wrapper from 1x and applies it to the `subscribe()` methods that dont define an `onerror` handlerthe errors are still routed to the `rxjavapluginsonerror` handler but now wrapped with `onerrornotimplementedexception`this should help with cases where the developer forgot to add the handler and distinguish such unhandled errors from other undeliverable errors due to lifecycle limitations;# coverage: 9551% || (messing with codecov settings had to reopen this to trigger a webhook of theirs) || i couldnt get travis re-execute the job likely due to the problems they are facing right now (even though they claim its only macosx builds) || so for the application usage it makes sense to re-throw everything of instance of `onerrornotimplementedexception` and to log everything else?my app became quite unstable with rxjava 2 because im silently swallowing errors and cant distinguish between my errors and errors thrown after i unsubscribedreally looking forward for this change if it does what i think it does! || if you are using `subscribe()` or `subscribe(consumer)` and the sequence runs into an error the error handler will receive an `onerrornotimplementedexception(originalerror)` ||;;;;1;1;2x: reintroduce onerrornotimplementedexception for 0-1 arg subscribe();
5043;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add parallel hooks to rxjavaplugins  add missing params validation;this pr adds an  onassembly  hook for  parallelflowable  operators and adds the missing parameter validation to some parallel operators.;;0;2x: add parallel hooks to rxjavaplugins add missing params validation;this pr adds an `onassembly` hook for `parallelflowable` operators and adds the missing parameter validation to some parallel operators; merging 5043  < ;;;;1;1;2x: add parallel hooks to rxjavaplugins add missing params validation;
"5047;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: document and test amb subscription ordering.;refs #5044.;;5044.0;2x: document and test amb subscription ordering;refs #5044;""once wording and tests are approved ill port to 1x as well || hmm i seem to be fighting the cool documentation checker which is being a bit too clever in this instance im using the word """"subscription"""" at the beginning of a sentence which it thinks means `subscription` the type ill figure out a wording tweak to make it end up as a lowercase """"subscription"""" || also with regard to signal types i figure the other tests cover those already so in these cases were just guarding against ordering changes || yes lowercase it as `subscription` is interpreted as the reference to the type ||  merging 5047  "";declare subscription order for amb and ambwith in documentation;`amb()` should declare that it subscribes to the supplied observables in the order of the iterable/array `ambwith()` should declare that it subscribes to the host observable before the supplied other observablethis allows consumers to explicitly rely on this ordering and a deviation from it to be a bug;i can send a pr for this i just wanted to make sure that the subscription order is something that we want to put into the public api in theory a perfectly acceptable implementation of `ambwith` _could_ be `amb(other this)` (but thatd be bad!) || this ordered subscribe is implied what makes you want this to be explicitly defined? || we have code whose behavior depends on it it basically doesbehaviorsubjectambwith(just(sentinel)) to ensure a value is alwayssynchronously emitted downstream upon subscribe would the subscriptionorder of this (or amb) change wed never see the subject value when it wasseton thu feb 2 2017 2:09 am david karnok <notifications@githubcom> wrote:> this ordered subscribe is implied what makes you want this to be> explicitly defined?>> > you are receiving this because you authored the thread> reply to this email directly view it on github> < or mute the thread> < > || this looks like you need `behaviorsubjectcreatedefault(sentinel)` (or `create(sentinel)` to make sure you have something to start with when subscribinggenerally i dont think such ordering guarantee should explicitly be declared on `amb` || that was a contrived example so your suggestion wont work in practice isee no reason to omit ordering guarantees around subscription since thebehavior in the synchronous case relies on it also it would be completelyillogical to have any ordering but the obvious one that already exists sothis really isnt a commitment of any challengeon thu feb 2 2017 10:07 am david karnok <notifications@githubcom> wrote:> this looks like you need behaviorsubjectcreatedefault(sentinel) (or> create(sentinel) to make sure you have something to start with when> subscribing>> generally i dont think such ordering guarantee should explicitly be> declared on amb>> > you are receiving this because you authored the thread> reply to this email directly view it on github> < or mute the thread> < > || okay then but dont forget to add unit tests that verify the order is actually held by the implementation (in case of another complete rewrite for 3x) 5 base types x 3 `amb` types  15 tests || essentially docs should (more) explicitly state that:`assertthat(amb(just(1) just(2))toblocking()single())isequalto(1)` || closing via #5047 ||;1;0;document and test amb subscription ordering;"
"5048;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: improve the behaviorsubject java doc;- the second example didn t explain what happened with  default .;;0;1x: improve the behaviorsubject java doc;""- the second example didnt explain what happened with """"default""""- the first line is copied from the 2x documentation its more clear""; merging 5048 ;;;;1;1;""improve the behaviorsubject java doc- the second example didnt explain what happened with """"default""""- the first line is copied from the 2x documentation its more clear"";"
5049;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;use bounded wildcards for errorhandler (5045);adding bound wildcards for error handler - 5045;;5045.0;use bounded wildcards for errorhandler (5045);adding bound wildcards for error handler - 5045; merging 5049 ;2x: rxjavapluginget/setxxx generics?;for unit tests i frequently bump into the restrictiveness of ```javarxjavapluginsseterrorhandler(consumer<throwable> handler)```i would like the signature to be ```javarxjavapluginsseterrorhandler(consumer<? super throwable> handler)```there are many more methods in `rxjavaplugins` that could support lower and upper bounded wildcards can i make these changes?;seterrorhandler: yes others would bring trouble i think || i gave it a shot:  the generics seems to work so farbut of course i dont know about any side effects possible problems ||;1;0;add test to ensure signature;
"5051;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;feature/#4876 nonnull annotations;issue: #4876;;4876.0;feature/#4876 nonnull annotations;""issue: #4876starting to add @nonnull and @nullable annotationsi decided to add a compileonly dependency to findbugs:jsr305 artifactwe could also use """"ioreactivexannotationsnonnull"""" which already exists but there is no """"ioreactivexannotationsnullable"""" annotation which is at least as important in my experiencesince these are only annotations it is no problem when the class files are missing at compile time (jls 9612 retention)i have started to add annotations in the scheduler and rxjavapluginsthe test rxjavaplugins contains some invalid checks using null (lines 1353 and following)this pull request is work in progress and should be discussedquestions so far:- use jsr305 (compileonly) or existing annotation in ioreactivex?- (if not using jsr305): use own @nullable annotation or try to get one added to """"ioreactivex""""? or skip these completely (which misses the point of the static code analysis)- why has there been tests calling the rxjavapluginson*scheduler with null arguments? can these be removed securely?"";maybe it wasnt well articulated but based on #5023 i thought we try with just the functional interfaces and come back later if it was not enough> i decided to add a compileonly dependency to findbugs:jsr305 artifactwe rather use our own annotations as most tools allow customizing what annotations to considerexpect futher comments inline || thanks for the feedback i will improve the pull request further ||;2x: add @nonnull annotation for function/predicate/etc;one of the larger tasks when transitioning from 1 to 2 is removing the use of null right now theres no automated way to do it but if we had `@nonnull` then wed be able to use static analysis to find where were returning null when we shouldnt beim not sure the best way to go about it - if we should include jsr305 use java 8s nonnull create our own or something else;""we cant do external dependencies like jsr305 and i cant find `@nonnull` or `@notnull` in java 8s public api we could introduce our own if your tools support custom annotations for this purpose || it looks like java 8 doesnt actually include it - its part of a checker framework more details [here]( im specifically targeting intellijs """"constant conditions & expressions"""" inspection and it looks like you can tell intellij about which annotations should be considered non-null / nullable so it would work if rxjava had its own `@nonnull` annotation included with the library (as long as developers are willing to do a little configuration on their end to accept it)the only downside to not using jsr305 is that we cant use something like `@parametersarenonnullbydefault` which would be less verboseif people are on board with this i could start implementing this (but its a lot of busywork so i dont want to bother unless people want it) || looks like there is an interest for new annotations #4878 so it this has to be coordinated with that im not sure about adding `@nonnull` to the functional interfaces though as it may add internal noise to rxjava we could however annotate parameters and return types of the base reactive classes || hmm im most concerned about the functional interfaces actually those are the ones where the app may accidentally crash during execution unexpectedlyheres a contrived example:```javavoid main() {    observablejust(""""dan"""")        map(new function<string string>() {            @override            public string apply(string s) throws exception {                return usuallydependablemethod(s)            }        })        subscribe()}string usuallydependablemethod(string name) {    return (mathrandom() < 95) ? """"hello """" + name : null}```i can imagine a lot of circumstances where coders dont even realize that `usuallydependablemethod()` could sometimes return null (when its not such an obvious problem) thats where static analysis would really help out || another +1 reason for this would be that kotlin automatically changes variables to not null as a language feature if they are annotated with `@nonnull` from jsr 305 along with the intellij and android equivalents  kotlin users using rxjava would have the benefit of knowing that their values in something like `onnext()` are not null@akarnokd can you give a reason for not being able to pull in jsr 305 or some equivalent? just curious || historically rxjava is kept to a minimum dependency: 0 in v1 and 1 in v2 || i agree @dlew - in a larger code base its pretty easy to run into issues like this and theres no way to catch them until runtimeif its annotated a handful of static analysis tools and ides can leverage this at compile time (even if its a custom annotation within the library) || i have created a pull request with some changes: || closing via #5051 & #5055 let us know if further annotations are necessary || i recently had an issue where a null list<t> was accidentally passed into `observablefromiterable()` unfortunately that bug made it to production but it would have been caught if the parameters are annotated @akarnokd @dlew i believe it would be worth it add nullability annotations every where `objecthelperrequirenonnull(object message)` is used to guard executionthis would be a massive change and it will definitely break compilation in some kotlin code bases mine included || recent intellij infers most nullability annotations for me in java:( in kotlin but it doesnt post a warning (see [kotlin]( || thanks for the quick reply i havent been able to get intellij to infer nullability annotations ive put together a [quick example of my problem]( post you linked seems to address the problem of consuming java types in kotlin rather than here where kotlin types are consumed by java rxjavas `ioreactivexannotationsnonnull` is [compatible]( with the kotlins compiler as such will cause a compiler error if a nullable kotlin type is passed into a `@nonnull` java parameteri apologize if this level of kotlin support is outside of the scope of this project  || > rather than here where kotlin types are consumed by javai thought writing in kotlin requires one to explicitly forfeit non-nullness have you been using this particular nullable `list` source elsewhere where it being `null` conveys additional information?> i apologize if this level of kotlin support is outside of the scope of this projectwe could add the `@nonnull` annotations but for the sake of any other library out there id also prefer intellij had the same nullness warning in a kotlin file (officially) that is already available for java || > have you been using this particular nullable list source elsewhere where it being null conveys additional information?the project was recently converted from rxjava 1x -> 2x and from java to kotlin in a short time span and this bug went unnoticed as far as i can tell `null` does not convey additional information in the stream > i thought writing in kotlin requires one to explicitly forfeit non-nullness its not necessarily the case if java types are correctly annotated   || @akarnokd is there any reason why return type of `function` interface is not annotated with `@nonnull`? `bifunction` and `function3` - `function9` return types are annotated with `@nonnull` does it break some contract? || nulls that cant end up in a sequence are allowed for example in `groupby` key selector and `distinct` selector || > nulls that cant end up in a sequence are allowed for example in groupby key selector and distinct selectorwhat do you think about creating annotation `@returnsnonnull` and annotate all `function` interface usages where the nullable value is not allowed? unfortunately it will require changes in static analysis tools another option is to create `nonnullfunction` interface with `@nonnull` return type but imho breaking api to fix this isnt worth it || java 6 doesnt allow annotating type arguments that way youd need to break binary compatibility to introduce all combinations of possible nullness to the interfaces and use sites || "";1;0;javadoc for nonnull/nullable annotations;"
5054;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add nullable annotation to simple queue (5053);as explained in  simplequeue might return null.;;5053.0;2x: add nullable annotation to simple queue (5053);as explained in  simplequeue might return nullto document this behavior a nullable annotation has been added; merging 5054 ;2x: spsclinkedarrayqueue#poll returns null;ioreactivexinternalqueuespsclinkedarrayqueue#poll returns nullioreactivexinternalfuseablesimplequeue#poll is not documented or annotated therefore i do not know whether returning null is allowed but i strongly suspect this is not the caseif simplequeue#poll might return null at least ioreactivexinternaloperatorsflowableflowablegroupjoingroupjoinsubscription#drain needs to be ;simplequeue may return null indicating an empty queue> if simplequeue#poll might return null at least ioreactivexinternaloperatorsflowableflowablegroupjoingroupjoinsubscription#drain needs to be you mean l238? due to the bi-offer if the first call to poll is not null the second one is guaranteed to be non null you have a false positive there || yes that is the line ok is a false positivei will add some annotations to simplequeue to avoid confusion ||  ||;1;0;add nullable annotation to simple queue (5053);
"5055;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: feature/#4876 more null checks;i have added some more null checks to help the static code analysis.;;4876.0;2x: feature/#4876 more null checks;i have added some more null checks to help the static code analysisi think i have also  one possible npe in newthreadworker; merging 5055 ;2x: add @nonnull annotation for function/predicate/etc;one of the larger tasks when transitioning from 1 to 2 is removing the use of null right now theres no automated way to do it but if we had `@nonnull` then wed be able to use static analysis to find where were returning null when we shouldnt beim not sure the best way to go about it - if we should include jsr305 use java 8s nonnull create our own or something else;""we cant do external dependencies like jsr305 and i cant find `@nonnull` or `@notnull` in java 8s public api we could introduce our own if your tools support custom annotations for this purpose || it looks like java 8 doesnt actually include it - its part of a checker framework more details [here]( im specifically targeting intellijs """"constant conditions & expressions"""" inspection and it looks like you can tell intellij about which annotations should be considered non-null / nullable so it would work if rxjava had its own `@nonnull` annotation included with the library (as long as developers are willing to do a little configuration on their end to accept it)the only downside to not using jsr305 is that we cant use something like `@parametersarenonnullbydefault` which would be less verboseif people are on board with this i could start implementing this (but its a lot of busywork so i dont want to bother unless people want it) || looks like there is an interest for new annotations #4878 so it this has to be coordinated with that im not sure about adding `@nonnull` to the functional interfaces though as it may add internal noise to rxjava we could however annotate parameters and return types of the base reactive classes || hmm im most concerned about the functional interfaces actually those are the ones where the app may accidentally crash during execution unexpectedlyheres a contrived example:```javavoid main() {    observablejust(""""dan"""")        map(new function<string string>() {            @override            public string apply(string s) throws exception {                return usuallydependablemethod(s)            }        })        subscribe()}string usuallydependablemethod(string name) {    return (mathrandom() < 95) ? """"hello """" + name : null}```i can imagine a lot of circumstances where coders dont even realize that `usuallydependablemethod()` could sometimes return null (when its not such an obvious problem) thats where static analysis would really help out || another +1 reason for this would be that kotlin automatically changes variables to not null as a language feature if they are annotated with `@nonnull` from jsr 305 along with the intellij and android equivalents  kotlin users using rxjava would have the benefit of knowing that their values in something like `onnext()` are not null@akarnokd can you give a reason for not being able to pull in jsr 305 or some equivalent? just curious || historically rxjava is kept to a minimum dependency: 0 in v1 and 1 in v2 || i agree @dlew - in a larger code base its pretty easy to run into issues like this and theres no way to catch them until runtimeif its annotated a handful of static analysis tools and ides can leverage this at compile time (even if its a custom annotation within the library) || i have created a pull request with some changes: || closing via #5051 & #5055 let us know if further annotations are necessary || i recently had an issue where a null list<t> was accidentally passed into `observablefromiterable()` unfortunately that bug made it to production but it would have been caught if the parameters are annotated @akarnokd @dlew i believe it would be worth it add nullability annotations every where `objecthelperrequirenonnull(object message)` is used to guard executionthis would be a massive change and it will definitely break compilation in some kotlin code bases mine included || recent intellij infers most nullability annotations for me in java:( in kotlin but it doesnt post a warning (see [kotlin]( || thanks for the quick reply i havent been able to get intellij to infer nullability annotations ive put together a [quick example of my problem]( post you linked seems to address the problem of consuming java types in kotlin rather than here where kotlin types are consumed by java rxjavas `ioreactivexannotationsnonnull` is [compatible]( with the kotlins compiler as such will cause a compiler error if a nullable kotlin type is passed into a `@nonnull` java parameteri apologize if this level of kotlin support is outside of the scope of this project  || > rather than here where kotlin types are consumed by javai thought writing in kotlin requires one to explicitly forfeit non-nullness have you been using this particular nullable `list` source elsewhere where it being `null` conveys additional information?> i apologize if this level of kotlin support is outside of the scope of this projectwe could add the `@nonnull` annotations but for the sake of any other library out there id also prefer intellij had the same nullness warning in a kotlin file (officially) that is already available for java || > have you been using this particular nullable list source elsewhere where it being null conveys additional information?the project was recently converted from rxjava 1x -> 2x and from java to kotlin in a short time span and this bug went unnoticed as far as i can tell `null` does not convey additional information in the stream > i thought writing in kotlin requires one to explicitly forfeit non-nullness its not necessarily the case if java types are correctly annotated   || @akarnokd is there any reason why return type of `function` interface is not annotated with `@nonnull`? `bifunction` and `function3` - `function9` return types are annotated with `@nonnull` does it break some contract? || nulls that cant end up in a sequence are allowed for example in `groupby` key selector and `distinct` selector || > nulls that cant end up in a sequence are allowed for example in groupby key selector and distinct selectorwhat do you think about creating annotation `@returnsnonnull` and annotate all `function` interface usages where the nullable value is not allowed? unfortunately it will require changes in static analysis tools another option is to create `nonnullfunction` interface with `@nonnull` return type but imho breaking api to fix this isnt worth it || java 6 doesnt allow annotating type arguments that way youd need to break binary compatibility to introduce all combinations of possible nullness to the interfaces and use sites || "";1;0;add comment for test case;"
5056;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: document (internal) simplequeue;the interface was missing javadoc on its methods.;;0;2x: document (internal) simplequeue;the interface was missing javadoc on its methods; merging 5056 ;;;;1;1;2x: document (internal) simplequeue;
5058;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;feature/#5045 more generics in rxjavaplugins;i widened the bounds for the functions. looks good for me.;;5045.0;feature/#5045 more generics in rxjavaplugins;i widened the bounds for the functions looks good for merelated to #5045;looks like this needs rebasing im sorrry im trying to merge your prs in proper order but multiple recent prs change the same file(s) || yeah no problem rebasing isnt too difficult -) ||  import and rebased || looks like there is a [compilation error]( with the changes || uups fixed it (at least i hope) ||  merging 5058  - ;2x: rxjavapluginget/setxxx generics?;for unit tests i frequently bump into the restrictiveness of ```javarxjavapluginsseterrorhandler(consumer<throwable> handler)```i would like the signature to be ```javarxjavapluginsseterrorhandler(consumer<? super throwable> handler)```there are many more methods in `rxjavaplugins` that could support lower and upper bounded wildcards can i make these changes?;seterrorhandler: yes others would bring trouble i think || i gave it a shot:  the generics seems to work so farbut of course i dont know about any side effects possible problems ||;1;0;use wildcard import for ioreactivex;
5064;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix replay() cancel/dispose npe;this pr fixes both  flowable.replay()  and  observable.replay()  throwing a  nullpointerexception  if the connection is disconnect before the upstream calls  onsubscribe  on the connection being established.;;5060.0;2x: fix replay() cancel/dispose npe;this pr fixes both `flowablereplay()` and `observablereplay()` throwing a `nullpointerexception` if the connection is disconnect before the upstream calls `onsubscribe` on the connection being established in practice this requires an async cancellation to happen through `refcount()unsubscribeon()` for example the validation tests simulate this by not calling `onsubscribe` until the synchronous connect/disconnect happensreported in #5060;;2x: npe at observablereplayreplayobserverdispose();stack trace below shows a crash that i unfortunately cant reproduce currently ive checked the source for `observablereplayreplayobserver` and it looks like this can only happen if its being disposed before being subscribed which sounds odd to me? what might be relevant is that `unsubscribeon()` is used on the observable```javalangnullpointerexception: attempt to invoke interface method void ioreactivexdisposablesdisposabledispose() on a null object reference    at ioreactivexinternaloperatorsobservableobservablereplay$replayobserverdispose(observablereplayjava:361)    at ioreactivexdisposablescompositedisposabledispose(compositedisposablejava:216)    at ioreactivexdisposablescompositedisposabledispose(compositedisposablejava:79)    at ioreactivexinternaloperatorsobservableobservablerefcount$2run(observablerefcountjava:126)    at ioreactivexdisposablesrunnabledisposableondisposed(runnabledisposablejava:28)    at ioreactivexdisposablesrunnabledisposableondisposed(runnabledisposablejava:18)    at ioreactivexdisposablesreferencedisposabledispose(referencedisposablejava:42)    at ioreactivexinternaloperatorsobservableobservablerefcount$connectionobserverdispose(observablerefcountjava:181)    at ioreactivexinternaldisposablesdisposablehelpersetonce(disposablehelperjava:79)    at ioreactivexinternaloperatorsobservableobservablesubscribeon$subscribeonobserveronsubscribe(observablesubscribeonjava:58)    at ioreactivexinternaloperatorsobservableobservablerefcountdosubscribe(observablerefcountjava:113)    at ioreactivexinternaloperatorsobservableobservablerefcount$1accept(observablerefcountjava:98)    at ioreactivexinternaloperatorsobservableobservablerefcount$1accept(observablerefcountjava:92)    at ioreactivexinternaloperatorsobservableobservablereplayconnect(observablereplayjava:305)    at ioreactivexinternaloperatorsobservableobservablerefcountsubscribeactual(observablerefcountjava:68)    at ioreactivexobservablesubscribe(observablejava:10514)    at ioreactivexinternaloperatorsobservableobservablesubscribeon$1run(observablesubscribeonjava:39)    at ioreactivexscheduler$1run(schedulerjava:134)    at ioreactivexinternalschedulersscheduledrunnablerun(scheduledrunnablejava:59)    at ioreactivexinternalschedulersscheduledrunnablecall(scheduledrunnablejava:51)    at javautilconcurrentfuturetaskrun(futuretaskjava:237)    at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:272)    at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1133)    at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:607)    at javalangthreadrun(threadjava:761)```;thanks for reporting this is a bug what happens is that the asnyc dispose happens before the chain of onsubscribe call reaches the operator the same happens inside `flowablereplay` ill post a fix shortly || see #5064 || closing via #5064 ||;1;0;2x: fix replay() cancel/dispose npe;
5069;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: compatibility fixes (jdk 9 & intellij 2017.1 eap);1. when the project is checked out into a directory that is not exactly  */rxjava/  (i.e.   /rxjavasomething/ ) the source-code locator in the unit tests failed with a  nullpointerexception . the locator is now relaxed to expect  /rxjava  prefix.;;0;2x: compatibility fixes (jdk 9 & intellij 20171 eap);1 when the project is checked out into a directory that is not exactly `*/rxjava/` (ie `/rxjavasomething/`) the source-code locator in the unit tests failed with a `nullpointerexception` the locator is now relaxed to expect `/rxjava` prefix2 running the unit tests from intellij 20171 eap the `exceptionteststeststackoverflowwouldoccur` failed with `assertionerror` because the final stack depth was exactly the constant value (800) the check now uses the correct `>` as the dual of the recursion condition of `<`; merging 5069 ;;;;1;1;2x: compatibility fixes (jdk 9 & intellij 20171 eap);
5075;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: cancel upstream first  dispose worker last;this pr makes sure the  scheduler.worker  is disposed only after;;0;2x: cancel upstream first dispose worker last;this pr makes sure the `schedulerworker` is disposed only after  - disposing/cancelling the upstream  - emitting terminal eventsthis may help with situations when the worker-dispose interrupts a thread that is blocked and the interruptedexception handler checks for the stream to be disposed so the exception can be safely ignored (and thus not end up in the rxjavapluginsonerror handler to crash the app)related: #4863; merging 5075  - ;;;;1;1;merge branch 2x into workerdisposelater;
5076;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2x: removed documentation leftover;that wrongly states that the error will be swallowed.;;0;2x: removed documentation leftover;that wrongly states that the error will be swallowedas discussed in #5036;;;;;1;1;removed documentation leftoverthat wrongly states that the error will be swallowed;
5080;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: wrap undeliverable errors;this pr adds the  undeliverableexception  and  protocolviolationexception . the former wraps exceptions that happen beyond the lifecycle of a flow and the latter is added to distinguish validation bugs.;;0;2x: wrap undeliverable errors;this pr adds the `undeliverableexception` and `protocolviolationexception` the former wraps exceptions that happen beyond the lifecycle of a flow and the latter is added to distinguish validation bugsthe `rxjavapluginsonerror` wraps errors into `undeliverableexception` unless `rxjavapluginsisbug()` returns true when the `throwable` is relayed to the (default) handlerhaving the `undeliverableexception` should help with understanding the source of a crash and by having its own stack trace help locating the offending positions (for example a missed `isdisposed()` check in a 3rd party library); merging 5080 will **not impact** coverage  - ;;;;1;1;add compositeexception to isbug add test for isbug;
5086;1;0;0;0;0;1;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: deprecate create()  add alternatives;looks like  create()  won t go away unless we get the ide mark it someway  such as being deprecated.;;4253.0;1x: deprecate create() add alternatives;looks like `create()` wont go away unless we get the ide mark it someway such as being deprecatedthis pr deprecates `create()` and adds `unsafecreate` for internal use and deprecate-renames `fromemitter` to `create(action1 backpressuremode)`there was an earlier attempt at deprecating `create` #4253 but it was not followed up this pr executes what i suggested in one of the [comments](https://githubcom/reactivex/rxjava/pull/4253#issuecomment-235913860); merging 5086  - ;1x: deprecate observablecreate();finally we have `observablefromasync()` and its time to prevent users from using `observablecreate()`;dont makes all legitimate uses now show up as warnings including all rxjava! || but we have to its too dangerous and people keep using it in tutorials for **beginners**! @jakewharton is trying to teach them all not to do so (:+1:) but `@deprecate` is a much more efficient and better way to do it> makes all legitimate uses now show up as warningspretty sure most of them dont support backpressure -> `legitimate  false`! ||   4253 of `observablecreate()` are you sure they all correctly handle backpressure errors and unsubscription?recently we had to handle backpressure with `observablecreate()` in our library storio same was done in sqlbrite and retrofit and this is because maintainers of those libraries were aware of mbe and how to handle it others may not have required level of understanding to correctly use `observablecreate()` (i try to avoid it as much as possible)  || still you dont just deprecate something and leave the fallout to other maintainer(s)instead of just deprecating `create` this is what id do:- refactor-rename `create` to `build` in the entire project -> keeps all our use places intact no suppressing needed- copy the `build` method back to `create`- mark `create` as deprecated add pointers to the alternative methods in the javadoc || that sounds better to me i was thinking about package private method inside `observable` like `createinternal()` + `rxinternalcreateobservable()` if it would be required to completely hide it from users (and deprecate `observablecreate()`)does it sound good to you @akarnokd?> if so should not synconsubscribe & asynconsubscribe be mentioned too?up to @akarnokd || just making it package-private does not work we have accesses from other packages that require the create feature it means wed have to dump them into the main `rx` all their tests with `internal` now you have a publicly accessible class and just switched `observablecreate` with `internalcreateobservable` java 6s visibility rules are simply not powerful enough to hide `create` || so after discussing that in twitter looks like our steps could be:1 teach users to use `fromasync()` in their apps but not in libraries yet because its `@experimental`2 collect feedback3 stabilise `fromasync()` and promote it to `@beta` or stable4 deprecate `create()`regarding hiding it i think `internalcreate()` or `unsafecreate()` will do the workif that sounds good to you ill close this pr and start working on things from list || that sounds good || > regarding hiding it i think internalcreate() or unsafecreate() will do the workdeprecating `create` seems like  a good idea to get users to consider what theyre doing but the `create` functionality still needs to be part of the public api `unsafecreate` may be a useful name to make people think twice about itre `fromasync` teaching one outstanding issue with it was request batching @akarnokd submitted an operator that we can use for that (`rebatchrequests`)  and i suspect it should be covered as part of the  documentation of `fromasync` usage  ||;1;0;1x: deprecate create() add alternatives;
"5087;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: correct marble diagram dimensions;this fixes part of #4535  as requested in #5067.;;5067.0;2x: correct marble diagram dimensions;""this fixes part of #4535 as requested in #5067these changes were generated using the following script:```sh#!/usr/bin/env bashfind  -name *java -print0 \  | xargs -0 grep ^\s*\* \  | grep -op  \  | sort -u \  | while read -r i do      echo """"updating ${i}""""      # gather image details      data""""$(identify <(curl -f -l -s """"${i}""""))""""      # extract the images true width and height      width""""$(echo """"${data}"""" | grep -op (?<png )\d+)""""      height""""$(echo """"${data}"""" | grep -op png \d+x\d+ | grep -op (?<x)\d+)""""      # determine the images scaled height assuming a width of 640 pixels      new_height""""$(echo scale100 s""""${width}"""" / 640 scale0 """"${height}"""" / s | bc)""""      # update all `<img/>` tags referencing the image      find  -name *java -print0 \        | xargs -0 perl -i -p -e s<img( (width|height)""""[^""""]*"""")* src""""\q""""${i}""""\e""""<img width""""640"""" height""""""""${new_height}"""""""" src""""""""${i}""""""""g    done```"";(note that i assumed that its okay to just fix the width of all images at 640px that seemed to be the prevailing style) || great scripting job! || thanks! :) since the change only touches javadoc i assume the travis ci job failure is spurious/unrelated? otherwise ill need a pointer on how to correct the situation || the failure is due to time sensitive tests failing on an overloaded ci ill try to resolve it separately dont worry about it ||  merging 5087 ;documetation points to some nonexistent marble diagrams;""noticed this while reading some javadoc in the context of a 126 -> 205 upgrade i wrote the following script to list all javadoc-referenced pngs which do not yield an  200 response when resolved:```sh#!/usr/bin/env bashfind  -name *java -print0 \  | xargs -0 grep ^\s*\* \  | grep -op  \  | sort -u \  | while read -r i do      curl -l -o /dev/null -s -w """"%{ ${i}\n"""" """"${i}""""    done \  | grep -v ^200```and then applied it to the `2x` branch (rev 0a2610ef6ddfdcdce1e4fecf3434848390e9c6f4) the output is:```404                 https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleflatmapmaybepng```"";thanks ill draw them next week || completabletoobservablepng( || note that the images inside the javadoc may be skewed let me know if youd like to post a pr that fixes the width and height constants for these || @akarnokd thanks for generating these images as for your fixing the dimensions i filed pr #5087 for that let me know whether thats what you intended ||;1;0;""correct marble diagram dimensionsthis fixes part of #4535these changes were generated using the following script:```sh#!/usr/bin/env bashfind  -name *java -print0 \  | xargs -0 grep ^\s*\* \  | grep -op  \  | sort -u \  | while read -r i do      echo """"updating ${i}""""      # gather image details      data""""$(identify <(curl -f -l -s """"${i}""""))""""      # extract the images true width and height      width""""$(echo """"${data}"""" | grep -op (?<png )\d+)""""      height""""$(echo """"${data}"""" | grep -op png \d+x\d+ | grep -op (?<x)\d+)""""      # determine the images scaled height assuming a width of 640 pixels      new_height""""$(echo scale100 s""""${width}"""" / 640 scale0 """"${height}"""" / s | bc)""""      # update all `<img/>` tags referencing the image      find  -name *java -print0 \        | xargs -0 perl -i -p -e s<img( (width|height)""""[^""""]*"""")* src""""\q""""${i}""""\e""""<img width""""640"""" height""""""""${new_height}"""""""" src""""""""${i}""""""""g    done```"";"
5088;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix ci load sensitive blockingnexttests  xflatmaptest;this pr updates  testnobufferingorblockingofsequence  with;;0;2x: fix ci load sensitive blockingnexttests xflatmaptest;this pr updates `testnobufferingorblockingofsequence` with  - retry up to 3 times with an exponential backoff as the test is time sensitive and travis ci load sensitive  - uses `schedulerssingle()` as the helper thread and manages resource cleanup properly  - both `flowable` and `observable` variantsupdate: looks like `xflatmaptest` is still flaky added changes here to try fixing it as well; merging 5088 ;;;;1;1;2x: fix ci load sensitive blockingnexttests retry with backoff;
5090;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix scan(seed  f) to emit accumulated values asap;for performance reasons  the  scan  delayed the emission of accumulated items by one which worked well with sources that pushed new items frequently.;;5089.0;2x: fix scan(seed f) to emit accumulated values asap;for performance reasons the `scan` delayed the emission of accumulated items by one which worked well with sources that pushed new items frequently unfortunately if the source stopped emitting (without completion) the very last accumulated item was stuck and no way to get it out of `scan` i considered this type of use being rare but apparently i was wrongthe pr changes `scan` to emit accumulated items including the initial seed as soon as there is request for it the operator now uses a stable-prefetch queue-drain found throughout other operators such as `observeon` remark: sadly request trickery such as capturing the first `request` call emitting the seed and then requesting n - 1 doesnt work because if the `request()` call itself happens from another thread and the source is empty the `onnext` and `oncomplete` could run concurrentlyreported in #5089;;204 flowablescanseed introduces delay;hi guys! im using `flowablescan(seed)` to accumulate values of infinite sequence(stream of updates from server that comes not so often) the problem is that whenever flowablescanseed receives new value it publishes previous one i guess its not a problem with a finite sequence(at completion all values will be published anyway) but with infinite seq the last value is held until next comesi wrote test case to demonstrate the issue```    @test    public void testscanwithseedemitsallitemsoninfinitesequence() {        flowableconcat(flowablejust(1 2 3) flowable<integer>never())scan(0 sum)                test(4)                assertvalues(0 1 3 6)    }```here seed+3 values are expected but since sequence is infinite last value never comesi dont have much experience with rx so cant provide you with a patch sorry );scan was changed to have less overhead than before at the cost of delaying the upstream values by one step this works if the source keeps emitting frequently enough but as you demonstrated if there is nothing to push more the operator just stopsill create a pr that doesnt delay items shortly || closing via #5090 ||;1;0;2x: fix scan(seed f) to emit accumulated values asap;
5091;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: create+subscribeon avoid same-pool deadlock;this pr allows to fix the same-pool deadlock that may happen with  create()  (formerly  fromemitter ) and  subscribeon  as  subscribeon  by default schedules the requests behind a running emitter and thus the internal request amount may not get updated  leading to unnecessary dataloss.;;4735.0;1x: create+subscribeon avoid same-pool deadlock;this pr allows to fix the same-pool deadlock that may happen with `create()` (formerly `fromemitter`) and `subscribeon` as `subscribeon` by default schedules the requests behind a running emitter and thus the internal request amount may not get updated leading to unnecessary datalosssee #4735in the update if `subscribeon` detects its upstream is `onsubscribecreate` it no longer reschedules requests for it for other non-immediate cases a new overload allows specifying the `requeston` parameter that should be `false` if there is a `create(action1 backpressurestrategy)` in the sequence upstream;;fromemitter same-pool deadlock;this affects both 1x and 2xthere is a question on [stackoverflow]( where the example program hangs after it delivered the default buffersize elements until the `fromemitter` source completesthe problem is that `subscribeon` schedules the downstreams replenishing `request` on the same thread that is busy/sleeping and has no opportunity to update its internal requested amount we had similar problems with `onbackpressureblock` which had to be droppedwe could introduce a `subscribeon` mode in which it doesnt reschedule the `request` from downstream but it will confuse some and make wonder others;this was resolved in 2x by making sure a `subscribeon` after `create` doesnt reschedule downstream requests || i think im running into this problem as well `fromemitter` suddenly stops emitting `onnext` items whereas the emitter itself is still being calledi was using a single-thread-scheduler for the emitter so i thought (from your explanation) that moving to a threadpool would resolve the problem it apparently does not for my case im probably misunderstanding what is going on behind the scenesdo you have any suggestions on how to workaround this issue (without moving to 2x) || @bobvanderlinden yes use the none policy and apply `onbackpressurexxx` *after* `subscribeon` || @akarnokd that works like a charm! thanks a lot! || closing via #5091 for 1x  and #4770 for 2x ||;1;0;1x: create+subscribeon avoid same-pool deadlock;
"5092;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: add single.merge(obs)  obs.flatmapsingle & flatmapcompletable;this pr adds specialized operators for merging  single  and  completable  sources:;;4988.0;1x: add singlemerge(obs) obsflatmapsingle & flatmapcompletable;""this pr adds specialized operators for merging `single` and `completable` sources:  - `singlemerge(observable<single<t>>)` + `maxconcurrency` overload  - `singlemergedelayerror(observable<single<t>>)` + `maxconcurrency` overload  - `observableflatmapsingle(func1<t single<r>>)` + `delayerrors` + `delayerrors maxconcurrency` overloads  - `observableflatmapcompletable(func1<t completable>)` + `delayerrors` + `delayerrors maxconcurrency` overloadsall of these return `observable`this replaces #4988*sidenote: for some time now contributor(s) from certain party tend to contribute low quality or inadequate code and """"disappear"""" pretty quickly i cant be sure this is just lazyness or a deliberate and elaborate scheme to extract free work out of me for their own partys benefit but it is annoying as hell*""; merging 5092 ;1x: merging an observable of singles;the addition of a `observable<single<t>> -> observable<t>` to round out the basic api of `rxsingle` i need this for doing a flat scan of sorts```singlemerge(eventsscan(singlejust(seed) (statesingle event) -> {    return statesingleflatmap((state) -> {        return statewrite(event)    })cache()}))```;  4988 is optimized || > if we got rid of the maxconcurrent overloadsyou may not want to have a million outstanding `single`-based network request limiting flatmaps concurrency is expected here where backpressure helps naturally || any progress on this? || closing via #5092 ||;1;0;1x: add singlemerge(obs) obsflatmapsingle & flatmapcompletable;"
5093;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add doafterterminate callback to the single type.;as mentioned in [this stackoverflow question](  doafterterminate() is currently missing in rxjava2. there s no strong reason for that  so this pr adds support for it.;;0;2x: add doafterterminate callback to the single type;as mentioned in [this stackoverflow question]( doafterterminate() is currently missing in rxjava2 theres no strong reason for that so this pr adds support for it; merging 5093 ;;;;1;1;mark the doafterterminate() experimental since 206;
"5101;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix maybe.concat() subscribe-after-cancel  verify others;this pr fixes  maybe.concatx  subscribing to the next source when the downstream cancelled the  flowable  sequence from its  onnext . this resulted in executing the subscription side-effects of the source to be immediately cancelled when it called  onsubscribe  on concat s  maybeobserver .;;5100.0;2x: fix maybeconcat() subscribe-after-cancel verify others;this pr fixes `maybeconcatx` subscribing to the next source when the downstream cancelled the `flowable` sequence from its `onnext` this resulted in executing the subscription side-effects of the source to be immediately cancelled when it called `onsubscribe` on concats `maybeobserver`in addition tests were added to verify the other types dont have this kind of a problemrelated #5100;;maybe concat with firstelement still call second maybe although the first emit value;""hi im relatively new to rxjavai tried rxjava 206 (previously 205) to check if it still produces the same resulthere my code (still using java 6)```maybe<string> m1  maybecreate(new maybeonsubscribe<string>() {    @override public void subscribe(maybeemitter<string> e) throws exception {        systemoutprintln(""""m1 called"""")        eonsuccess(""""m1"""")    }})maybe<string> m2  maybecreate(new maybeonsubscribe<string>() {    @override public void subscribe(maybeemitter<string> e) throws exception {        systemoutprintln(""""m2 called"""")        eonsuccess(""""m2"""")    }})disposable subscribe  maybeconcat(m1 m2)        firstelement()        subscribe(new consumer<string>() {            @override public void accept(string t) throws exception {                systemoutprintln(t)            }        })```the output :m1 calledm1m2 calledis it correct or not? because while using observable the second observable is not called when the first one already emit valuethanks"";hi and thanks for reporting this is a bug in the underlying `concat` operator that doesnt expect a cancellation (happening due to `firstelement`) after emitting an item and happily subscribes to the next source triggering subscription side-effects but actually cancelling out that new source immediatelyill post a fix shortly || closing via #5101temporary workaround: add `maybeempty()` between the sources to absorb the extra subscription ||;1;0;2x: fix maybeconcat() subscribe-after-cancel verify others;"
5102;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: added missing @nonnull attribute to function7.;this pull request adds the missing @nonnull attribute to function7. on pull request #5023  function7 was missing from the updates.;;0;2x: added missing @nonnull attribute to function7;this pull request adds the missing @nonnull attribute to function7 on pull request #5023 function7 was missing from the updates; merging 5102 ;;;;1;1;added missing @nonnull attribute to function7;
5103;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix doonsubscribe signalling undeliv.exception instead of just onerror;this pr fixes the issue reported on [stackoverflow]( where crashing the lambda in  flowable.doonsubscribe  calls the  rxjavaplugins.onerror   which crashes the app and prevents calling the  emptysubscription.error  on android. (desktop prints to the console and delivers the error normally.);;0;2x: fix doonsubscribe signalling undelivexception instead of just onerror;this pr fixes the issue reported on [stackoverflow]( where crashing the lambda in `flowabledoonsubscribe` calls the `rxjavapluginsonerror` which crashes the app and prevents calling the `emptysubscriptionerror` on android (desktop prints to the console and delivers the error normally)the bug was present in the `flowable` `observable` and `completable` all 5 base types received the respective unit test to ensure correct behavior; merging 5103  - ;;;;1;1;2x: fix doonsubscribe signalling undelivexception instead of onerror;
"5106;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix window(time  size) not completing windows on timeout;this pr fixes the operators  flowable.window(time  size)  and  observable.window(time  size)  to complete the current window if the time elapses before the size limit is reached.;;5104.0;2x: fix window(time size) not completing windows on timeout;this pr fixes the operators `flowablewindow(time size)` and `observablewindow(time size)` to complete the current window if the time elapses before the size limit is reachedreported in #5104; merging 5106 ;2x : window(timespan unit count) always emit empty observable if not reach max count;""this code will print nothing all the time```javapublishsubject<string> vehicletofetch  publishsubjectcreate()        vehicletofetch                delay(2timeunitseconds)                window(10 timeunitseconds 5)                observeon(schedulersio())                subscribe(w-> wtolist()subscribe(ws-> {                    wsforeach(v -> {                        systemoutprintln(stringformat(""""%s %d"""" v threadcurrentthread()getid()))                        vehicletofetchonnext(v)                    })                }))        observablejust(""""v1""""""""v2""""""""v3""""""""v4"""")                subscribe(v->{                    vehicletofetchonnext(v)                })```i am using rxjava:206"";""there are two problems with your code:- you are using `tolist` which requires a finite stream since you dont call `oncomplete` on `vehicletofetch` the sequence above wont print anything- you are probably not waiting long enough to see the results the default rxjava schedulers are daemon threads and when the """"main"""" thread ends the whole application stops```javapublishsubject<string> vehicletofetch  publishsubjectcreate()vehicletofetch        delay(2timeunitseconds)        window(10 timeunitseconds 5)        observeon(schedulersio())        subscribe(w-> wtolist()subscribe(ws-> {            wsforeach(v -> {                systemoutprintln(stringformat(""""%s %d"""" v threadcurrentthread()getid()))                vehicletofetchonnext(v)            })        }))observablejust(""""v1""""""""v2""""""""v3""""""""v4"""")subscribe(vehicletofetch)threadsleep(3000)``` || @akarnokd thanks  i am calling `tolist()` on a window observable not on `vehicletofetch` there is print if i change ` window(10 timeunitseconds 5)` to `window(10 timeunitseconds 4)`i am using a `countdownlatch`(not show in code) to wait a long time || yes because the window with limit 4 will call `oncomplete` for you on the window that `tolist()` consumes with 5 there is noone to call `oncomplete` if you had a """"v5"""" in that case youd see the printout again || why did it not call `oncomplete` when the timeout is reached?  does not this method mean either timeout or max count is reach will emit a window?  || oh i see it now there is a bug in the operator that doesnt complete the old window if a new one is due to the timeout ill post a fix for it || closing via #5106 || it  worked after upgrade to 207  but after three times timeout there is no timeout anymore || do you have a new unit test for it? || you can use the same code  it will block after three new window emitted || odd ill look into it again || found a couple of remaining issues see pr #5213 the example works with it properly for me || "";1;0;2x: fix window(time size) not completing windows on timeout;"
"5112;1;0;0;1;0;1;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: flowable as a publisher to be fully rs compliant;this pr performs the changes suggested in #5110.;;5110.0;2x: flowable as a publisher to be fully rs compliant;""this pr performs the changes suggested in #5110 - introduce `flowablesubscriber` with extra textual specification on its relaxed nature - `flowablesubscribe(subscriber)` checks for `flowablesubscriber` and if not found it wraps the incoming rs `subscriber` into a `strictsubscriber` that follows the rs spec to the letter at any cost - introduce `flowablesubscribe(flowablesubscribe)` that most internal operators will use - change `abstractflowablewithupstream` to accept `flowable` as a source update operators - some operators were useful with raw `publisher` input these were duplicated on their outer containing type but use the same internal `flowablesubscriber` - removed """"cheat"""" from the tck tests adjusted timeout on `delay` - replaced most `implements subscriber` with `implements flowablesubscriber` - replaced most `new subscriber` with `new flowablesubscriber` in tests the rest is required for testing the strictness itself - `strict()` is now an identity operator with suggested scheduled removalperformance impact estimation- most primary use of a `flowable` should go through `subscribe(flowablesubscribe)` and thus no overhead change- where the api mandated `publisher` as input providing a `flowable` will have an `instanceof` check at subscription time and routed to `subscribe(flowablesubscriber) if the consumer is part of rxjava 2 itself"";okay lets go from here in the unlikely case the spec becomes more forgiving the undo is just to remove cast/wrapping from flowablesubscribe and everything works the same as `flowablesubscriber` is an interface ||;2x: reactive-streams compliance;""there is an [ongoing effort]( to clarify the reasons behind the [reactive-streams]( rules in the hopes that the rules could be relaxed without too much compatibility problems i brought up the case that we had to introduce the `strict()` operator to pass the tck tests the problematic rules are 13 and 39 that impose such requirements that add overhead to sequencesthis sparked a [separate discussion]( about the it was a good idea rxjava 2 exposes itself with the reactive-streams interfaces instead of hiding it behind a converter / exposure layer which decoupling allows - in theory - violating the exact rules as long as such violations are not visible by the consumeri doubt i could convince the maintainers of the specification (other than @smaldini) it is worth taking the relaxations even at the expense of temporary incompatibility in case vendors dont relax their particular implementationsrxjava 2 works with or without the """"reactive-streams compliant"""" badge yet as a """"brand"""" it is still advisable to have that badge### suggested api changesensuring conformance is a matter of applying the `strictsubscriber` wrapper to the incoming `subscriber` in `flowablesubscribe` unfortunately this slows down everything as there is only one way to consume a `flowable` through `subscribe(subscriber)` (the overloads all delegate to it)to get the speed back a new instance method would be introduced that all internal operators would use then on instead of `subscribe` rxjava 1 has an extra entry point `unsafesubscribe` to sidestep `safesubscriber` thus there is precedence for such alternate entry pointthe method could be called `subscribe` as well that takes a `flowablesubscriber extends subscriber` `flowablesubscriber`s textual definition can then weaken rules 13 and 39 inherited existing operators would then implement `flowablesubscriber` in place of `subscriber`i think all of this would be binary compatible change since only `flowable` would get an extra methodsuggestions welcome"";is `flowablesubscriber` a public type just like the non-rs observers?ive been following the discussion too and i think this is a reasonable action to take || yes `ioreactivexflowablesubscriber` i dont think hiding it in `internal` is necessary im currently preparing a pr to demonstrate the changes || closing via #5112 ||;1;0;2x: flowable as a publisher to be fully rs compliant;"
5114;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix observable.combinelatest to dispose eagerly;this pr fixes  observable.combinelatest  to dispose the sources outside the serialization loop  just like  flowable.combinelatest  does. this allows cancellation even if the serialization loop is busy/blocking inside an  onnext  emission.;;5111.0;2x: fix observablecombinelatest to dispose eagerly;this pr fixes `observablecombinelatest` to dispose the sources outside the serialization loop just like `flowablecombinelatest` does this allows cancellation even if the serialization loop is busy/blocking inside an `onnext` emissionin addition a unit test was added to `flowablecombinelatest` as wellreported in #5111; merging 5114  - ;2x: disposal of observablecombinelatests observers?;when a observablecombinelatest is disposed is there any particular reason why it does not dispose all of its observers? im seeing `getandincrement()` be non-zero and that observer is not receiving any more events so a memory leak is causedhttps://githubcom/reactivex/rxjava/blob/2x/src/main/java/io/reactivex/internal/operators/observable/observablecombinelatestjava#l128;if there is no ongoing onnext that should dispose the sources does your downstream block for any reason on onnext? || `flowable` is implemented with an eager cancellation so i consider this to be a bug ill post a fix shortly || closing via #5114 || @akarnokd thanks for the quick turnaround! would this also apply to [observablezip]( as well? here is [flowablezip]( cancel() || indeed would you like to submit a pr? || will do ||;1;0;2x: fix obscombinelatest to dispose eagerly;
5115;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: benchmark the new strict/interop mode;benchmark the overhead of the strict/interop mode.;;0;2x: benchmark the new strict/interop mode;benchmark the overhead of the strict/interop modei5 6440hq windows 10 x64 java 8u121( numbers are consistent with my expectations this mobile processor is roughly equivalent to i7 4770 desktop where the cost model is: 1 atomic increment per item equals to roughly 130 mops/s upper limit 2 atomic increment per item is roughly 60 mops/s upper limit since the interop mode requires at minimum two atomic increments 54 mops/s is a reasonable value to get; merging 5115  - ;;;;1;1;consider cpu usage;
5117;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add parallelflowable.sequentialdelayerror;this pr adds the  sequentialdelayerror  operator to  parallelflowable  that allows awaiting all  rails  in a parallel flow to terminate normally or with the (composite) exception of the failed rail(s).;;5108.0;2x: add parallelflowablesequentialdelayerror;this pr adds the `sequentialdelayerror` operator to `parallelflowable` that allows awaiting all rails in a parallel flow to terminate normally or with the (composite) exception of the failed rail(s)to enable this the `flowableparallel()` operators behavior regarding rail cancellation had to be changed in v205 if any of the rails cancelled (maybe due to a failure maybe due to an end consumer cancelling the entire parallel flow) the input `flowable` was cancelled this pr alters this by requiring all rails to cancel before cancelling the input `flowable` the change permits one or multiple rails to fail and let others progress in case the new `sequentialdelayerror` is applied as a terminal operator the original `sequential()` operator still cancels all rails if one of them fails (triggering the cancellation of the input `flowable`)note that this change may still drop and never process elements in the internal queues of the operators in the parallel flow (because the parallel processing is not implemented with work-stealing that could pick up elements from a dead queue) in order to get as many elements processed as possible it is recommended to reduce the default prefetch on the `runon` operator to a reasonable tradeoff value (between throughput and fault tolerance)**edit**updated the pr to make sure `parallel()` ignores cancelled rails when it dispatches itemsrelated: #5108; merging 5117  - ;parallelflowable sequential and exception management;hiim stuck on a problem which might or might not be an issue on the current version of the `parallelflowable` or if it is a desired behaviour its not specified anywhere in the documentationin a few words im having issues propagating errors from a `parallelflowable` to a single `flowable` (when calling `sequential()`)what i would expect is that any error generated during the execution of operators on the `parallelflowable` would be propagated to the subscriber on the flowablewhat really happens is that the exception is not propagated and its thrown even if its a checked exceptionhere is a code example:```javaflowablejust(request1 request2)                parallel() // parallel execution is needed                runon(schedulersio())                map(request -> requestexecute()) // execute() can throw an exception                sequential()                tolist()                observeon(androidschedulersmainthread())                subscribe(this::success this::failure)````failure(exception)` is not called and the exception is actually thrownive also tried this and the exception is still not propagated to the sequential flowable:```javaflowablejust(request1 request2)                parallel() // parallel execution is needed                runon(schedulersio())                flatmap(request -> {                    try {                        return flowablejust(requestexecute())                    } catch (exception e) {                        return flowableerror(e)                    }                }                sequential()```im using version 205 of rxjava on androidthank you for your help;the underlying problem is that `sequential` can only allow one `onerror` if multiple rails fail one gets through and the others get sent to `rxjavapluginsonerror`on one hand this is a general property of rxjava 2 and requires you to setup a [global error handler]( based on what you consider fatal and what noton the other hand the internals of the parallel operators dont leave much option currently if a rail fails it cancels the upstream rail  (which cancels the original flowable in the chain) and emits an onerror when the error reaches the `sequential` operator the operator cancels the rest of the railsfor a workaround i suggest you switch back to a traditional parallel execution:```javaflowable<t> a  flowablejust(request1)subscribeon(schedulerscomputation())map()flowable<t> b  flowablejust(request2)subscribeon(schedulerscomputation())map()flowable<t> c  flowablemergearraydelayerror(a b)```i need more time to figure out a better way to support your failure mode || thank you @akarnokd for the super fast turnaround on this!ill go with `flowablemergearraydelayerror()` for now since it seems to behave as expected and i look forward to check out the new solution with `parallelflowable`in general when it comes to parallel computations there are three common scenarios to handle a failure and it would be good if developers were able to choose among all of them:- make all the computations fail when one of them fails- notify all successful computations until the failure then fail all the others- notify all successful computations before and after the failed computation || see #5202im closing this issue due to inactivity if you have further input on the issue dont hesitate to reopen this issue or post a new one ||;1;0;merge branch 2x into parallelmultierror;
5119;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: improve coverage  remove unused code;this pr adds coverage to some low-coverage classes and removes unused code.;;0;2x: improve coverage remove unused code;this pr adds coverage to some low-coverage classes and removes unused code in addition the `xflatmaptest` now retries each test up to 3 times with exponential backoff since they are the most sensitive to travis ci fluctuations; merging 5119 ;;;;1;1;2x: improve coverage remove unused code;
5121;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix observable.zip to dispose eagerly;this pr fixes  observable.zip  to dispose the sources outside the serialization loop  just like  flowable.zip  does. this allows cancellation even if the serialization loop is busy/blocking inside an  onnext  emission.;;5111.0;2x: fix observablezip to dispose eagerly;this pr fixes `observablezip` to dispose the sources outside the serialization loop just like `flowablezip` does this allows cancellation even if the serialization loop is busy/blocking inside an `onnext` emissionin addition a unit test was added to `observablezip` as wellreported in #5111; merging 5121  - ;2x: disposal of observablecombinelatests observers?;when a observablecombinelatest is disposed is there any particular reason why it does not dispose all of its observers? im seeing `getandincrement()` be non-zero and that observer is not receiving any more events so a memory leak is causedhttps://githubcom/reactivex/rxjava/blob/2x/src/main/java/io/reactivex/internal/operators/observable/observablecombinelatestjava#l128;if there is no ongoing onnext that should dispose the sources does your downstream block for any reason on onnext? || `flowable` is implemented with an eager cancellation so i consider this to be a bug ill post a fix shortly || closing via #5114 || @akarnokd thanks for the quick turnaround! would this also apply to [observablezip]( as well? here is [flowablezip]( cancel() || indeed would you like to submit a pr? || will do ||;1;0;2x: fix observablezip to dispose eagerly;
"5127;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: update javadoc of flatmap() overloads;this pr rewords the javadoc of  flowable.flatmap()  overloads to correctly express their behavior regarding backpressure towards their upstream. in 2.x  only  merge()  operators are unbounded-in by default   flatmap s are by default bounded by  buffersize()  or the  maxconcurrency  parameter.;;5126.0;2x: update javadoc of flatmap() overloads;this pr rewords the javadoc of `flowableflatmap()` overloads to correctly express their behavior regarding backpressure towards their upstream in 2x only `merge()` operators are unbounded-in by default `flatmap`s are by default bounded  buffersize()` or the `maxconcurrency` parameterin addition one of the `flatmap` overload still had `resultselector` instead of the common `combiner` parameter name as far as i know there are no language-specific libraries targeting 2x yet where in the language the actual parameter names are also part of the signature and changing them counts as an incompatible changerelated #5126; merging 5127  - ;2x flowableflatmap maxconcurrency should be unbounded unless it is restricted;""when more than 128 publishers that not all emit events causes miss of any further message that would be sent by subsequent publishers this is due to the underlying implementation defaults to buffersize() which is 128  to  > the outer publisher is consumed in unbounded modeexample to replicate the issue: (assumes that publishers is greater than 128 and that none of the first 128 publishers are emitting any message):```public flowable<mytype> foo() {      return publishersflatmap(publisher -> {        return publisher            subscribeto(""""bar"""")            doonsubscribe(s -> systemoutprintln(s))            doonerror(t -> systemoutprintln(t))            map(myclass::someoperation)            takeuntil(publisheronclose()toflowable())     })}```at the moment the work around is to use the overloaded flatmap to set manually set maxconcurrency to be unbounded"";hi and thanks for reporting flatmap(function) should be bounded and the javadoc is wrong due to copy-paste error from merge() which is unbounded || the reason it was never bounded in v1 is that it causes these types of hidden system hangs that are very hard to debug this seems like a dangerous behavior to have changed  || yes you have to unbound `flowableflatmap` manually for your use case as it defaults to a  number of active inner `publisher`s at once this is a typical behavior for in-sequence operators that have an n:m relation between the input and output because `flowable` is the backpressure-enabled no-overflow base reactive typeif you need unbounded behavior consider using `observable` in v1 there was a *theoretical* problem when the same bounding on `merge` was attempted: gui scenarios may merge more than 128 sources at once and bounding merge that late in the life of v1 could have caused unexpected hangs indeedthe javadoc has been fixed by and closing via #5127 ||;1;0;2x: update javadoc of flatmap() overloads;"
5133;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix flatmap not cancelling the upstream eagerly;this pr fixes the lack of eager cancellation when flatmapping sources and not stopping the upstream if the inner source fails.;;5132.0;2x: fix flatmap not cancelling the upstream eagerly;this pr fixes the lack of eager cancellation when flatmapping sources and not stopping the upstream if the inner source failsunit tests were added to verify `single` (in case it receives a dedicated implementation one day as currently it delegates to `flowable`) `flowable` and `observable`reported in #5132; merging 5133 ;2x v206 singlemerge produce undeliverableerror [question];sorry for code in kotlin```    @test fun singlemergetest() {        val illegalaccesserror  illegalaccesserror()        singlemerge<string>(listof(                singleerror(illegalaccesserror)                singleerror(illegalaccesserror)                singleerror(illegalaccesserror)        ))test()await()asserterror(illegalaccesserror)    }    @test fun observablemergetest() {        val illegalaccesserror  illegalaccesserror()        observablemerge<string>(listof(                observableerror(illegalaccesserror)                observableerror(illegalaccesserror)                observableerror(illegalaccesserror)        ))test()await()asserterror(illegalaccesserror)    }```first test produces `undeliverableerror` after execution but second one completes successfully without errors is it expected behaviour or a bug?;thanks for reporting this is indeed an inconsistency between `observable` and the `flowable`-based merges not stopping immediately when one of the inner sources fails and subscribing to the next inner source in synchronous mode || closing via #5133 ||;1;0;2x: fix flatmap not cancelling the upstream eagerly;
5136;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix repeatwhen and retrywhen signatures;adjust the  repeatwhen  and  retrywhen  signatures to accept  publisher<?>  on  single  and  completable   matching  flowable  s signature.;;5135.0;2x: fix repeatwhen and retrywhen signatures;adjust the `repeatwhen` and `retrywhen` signatures to accept `publisher<?>` on `single` and `completable` matching `flowable`s signaturereported in #5135;   no coverage uploaded for pull request base (`2x@2a4b18e`) [click here to learn what that means]( `n/a````                                  2x    #5136   +/-   ##  coverage       ?   9581%             complexity     ?     5601             files          ?      620  ?    39820     ?     5599             hits           ?    38154             misses         ?      672             partials       ?      994```| [impacted files]( | coverage  | complexity  | ||---|---|---|---|| [src/main/java/io/reactivex/flowablejava]( | `100% <> ()` | `522 <> (?)` | || [src/main/java/io/reactivex/singlejava]( | `9929% <> ()` | `131 <> (?)` | || [src/main/java/io/reactivex/completablejava]( | `100% <> ()` | `112 <> (?)` | |------[continue to review full report at codecov]( **legend** - [click here to learn more]( `  absolute <relative> (impact)` `  not affected` `?  missing data`> ( last update [2a4b18ed7bd221]( read the [comment docs]( ||;retrywhen method signature for with completable and single;when i attempt to use `retrywhen` to delay a retry with `completable` or `single` i receive an _incompatible types_ error as demonstrated in the following code:                        completableerror(new runtimeexception())                    retrywhen(new function<flowable<throwable> publisher<object>>() {                        @override                        public publisher<object> apply(@ioreactivexannotationsnonnull flowable<throwable> source) throws exception {                            return sourcedelay(5 timeunitseconds) // <- incompatible type error                        }                    })                        singleerror(new runtimeexception())                    retrywhen(new function<flowable<throwable> publisher<object>>() {                        @override                        public publisher<object> apply(@ioreactivexannotationsnonnull flowable<throwable> source) throws exception {                            return sourcedelay(5 timeunitseconds) // <- incompatible type error                        }                    })however there are no issues with `observable` or `flowable`:            observableerror(new runtimeexception())                    retrywhen(new function<observable<throwable> observablesource<?>>() {                        @override                        public observablesource<?> apply(@ioreactivexannotationsnonnull observable<throwable> source) throws exception {                            return sourcedelay(5 timeunitseconds)                        }                    })            flowableerror(new runtimeexception())                    retrywhen(new function<flowable<throwable> publisher<?>>() {                        @override                        public publisher<?> apply(@ioreactivexannotationsnonnull flowable<throwable> source) throws exception {                            return sourcedelay(5 timeunitseconds)                        }                    })looks like there is an issue with the return types for `apply`?;@akarnokd sorry i accidentally submitted the issue without my description  now  this isnt a crosspost but appears to be a bug || you have the wrong return type argument in the first case either change it to `?` or `throwable` || @akarnokd  arent the `completable` `runwith` function argument and return types incompatible?    public final completable retrywhen(function<? super flowable<throwable> ? extends publisher<object>> handler) so the following `retrywith` lambda:        completableerror(new runtimeexception())                retrywhen(throwableflowable -> throwableflowabledelay(5 timeunitseconds) produces the error:    bad return type in lambda expression: flowable<throwable> cannot be converted to publisher<object> || thanks i see he issue now indeed the completable and single signature for retrywhen is different from the others `repeatwhen` is also off would you like to submit a pr? || sure i can do that  question:  should the function return type be `publisher<?>` or `completablesource<?>` /  `singlesource<?>` ?   `flowable` and `observable` differ in this regard || id like to encourage you to think about that a bit || two hints:- youd want to retry multiple times- youd want to avoid classcastexception on existing operator users || closing via #5136 || @akarnokd i tried to use:    retrywhen(errors -> errorsflatmap(error -> observabletimer(30 timeunitseconds)))on a `transformer` for a ` single` and i am getting this error:>error: incompatible types: cannot infer type-variable(s) r (argument mismatch bad return type in lambda expression observable cannot be converted to publisher) where rt are type-variables: r extends object declared in method flatmap(function>) t extends object declared in class flowableand the squiggly lines below error -> observabletimer(30 timeunitseconds) say:> no instance(s) of type variable(s) r exist so that observable conforms to publisherwhat am i doing wrong? is this bug fixed? || using `flowabletimer` instead fixes this is this something only related to `single`? because [this tutorial]( uses `observabletimer` with no issues || > what am i doing wrong?please check the signatures of operators so that you are using the right types:  because this tutorial uses observabletimer with no issuesthat tutorial predates rxjava 2> is this something only related to single`retrywhen` and `repeatwhen` use `publisher` as the redo signal by design so that we can leverage backpressure to only ask for one such redo signal at a time with `observable` there is a chance a handler would simply dump a lot of signals at once and the operators may behaved unexpectedly || also do not cross post questions:  || i thought about posting here the stackoverflow link but many people just ignore links i am glad you arent one of those thank you very much for the explanation!  ||;1;0;2x: fix repeatwhen and retrywhen signatures;
5137;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add testsubscriber.withtag;this pr adds the method  withtag  to the  testbaseconsumer  that allows setting a textual tag which is then appended to the assertion failure s message:;;0;2x: add testsubscriberwithtag;this pr adds the method `withtag` to the `testbaseconsumer` that allows setting a textual tag which is then appended to the assertion failures message:```failure message (latch  1 values  0 errors  0 completions  0 tag  x: 5 y: 7)```use case for example is to add the parameters of the current flow to help identify what settings caused the failure this comes up with unit tests that have some form of (nested) loop(s) to verify multiple parameter ranges (it is often much easier than trying to work out junit rules and such); merging 5137  - ;;;;1;1;2x: add testsubscriberwithtag;
"5140;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix timed replay-like components replaying outdated items;the timed versions of  flowable.replay()    replayprocessor    observable.replay()  and  replaysubject  all replay outdated items to new subscribers and through the  getvalues()  and  size()  state-peeking methods  similar to issue #3917 resolved via #4023.;;3917.0;2x: fix timed replay-like components replaying outdated items;the timed versions of `flowablereplay()` `replayprocessor` `observablereplay()` and `replaysubject` all replay outdated items to new subscribers and through the `getvalues()` and `size()` state-peeking methods similar to issue #3917 resolved via #4023the fix includes a node-walk for new subscribers that skips old entries some unit tests werent logically considering the emission pattern (ie items timed out shouldnt appear) and have been  as wellreported in #5139; merging 5140  - ;replay(buffersize time timeunit) not working - truncate should be called with replay?;""the buffer only gets truncated when a new item is added so any subscribers will always receive that last emission even if its older than the time-limit ```    observable<long> retrofit  observableinterval(2l 2l timeunitseconds)take(10)    connectableobservable<long> connectableretrofit    connectableretrofit  retrofitreplay(1 5 timeunitseconds)    systemoutprintln(""""subscribing a"""")    connectableretrofitsubscribe(new action1<long>() {        @override        public void call(long along) {            systemoutprintln(""""subscriber! a  """" + along)        }    })    systemoutprintln(""""connecting!"""")    connectableretrofitconnect()    threadsleep(10000l)    systemoutprintln(""""subscribing b"""")    connectableretrofitsubscribe(new action1<long>() {        @override        public void call(long along) {            systemoutprintln(""""subscriber! b  """" + along)        }    })    threadsleep(30000l)    systemoutprintln(""""subscribing c"""")    connectableretrofitsubscribe(new action1<long>() {        @override        public void call(long along) {            systemoutprintln(""""subscriber! c  """" + along)        }    })````here subscriber c is subbing after 30 secs so youd expect the buffer to have truncated the last value since the time-limit is 5 secsthis is the output: > subscribing a> connecting!> subscriber! a  0> subscriber! a  1> subscriber! a  2> subscriber! a  3> subscriber! a  4> subscribing b> subscriber! b  4> subscriber! a  5> subscriber! b  5> subscriber! a  6> subscriber! b  6> subscriber! a  7> subscriber! b  7> subscriber! a  8> subscriber! b  8> subscriber! a  9> subscriber! b  9> subscribing c> subscriber! c  9"";true replay starts from the current head which is only moved forward  onnext` ive been thinking about rewriting `replaysubject` to support backpressure in that structure when the child subscriber picks up [the head]( we can skip old entries right therequestion is do we want this behavior change and whether the current behavior is expected by unit tests? || good point i think the current behavior is a conflict with the method description/purpose so id say change if not at least an update to the documentation maybe deprecate the current one? being new to rx i spent quite a while trying to figure out why this wasnt working  || also could you recommend a workaround to achieve that behavior? basically i wanted to do something like replay a network call within a specific time and if it came out empty id repeat the call || you can timestamp values before it reaches the replaysubject then use skipwhile(n -> ntimestamp < now - maxage)otherwise see #3918 for an updated replaysubject where stale data is skipped on subscription || sorry i completely forgot about this ill post an pr to replay() and see what it takes to skip old entries || see #4023 for a proposed fix for `replay()` itself || closing via #4023 ||;1;0;2x: fix timed replay-like components replaying outdated items;"
"5140;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix timed replay-like components replaying outdated items;the timed versions of  flowable.replay()    replayprocessor    observable.replay()  and  replaysubject  all replay outdated items to new subscribers and through the  getvalues()  and  size()  state-peeking methods  similar to issue #3917 resolved via #4023.;;5139.0;2x: fix timed replay-like components replaying outdated items;the timed versions of `flowablereplay()` `replayprocessor` `observablereplay()` and `replaysubject` all replay outdated items to new subscribers and through the `getvalues()` and `size()` state-peeking methods similar to issue #3917 resolved via #4023the fix includes a node-walk for new subscribers that skips old entries some unit tests werent logically considering the emission pattern (ie items timed out shouldnt appear) and have been  as wellreported in #5139; merging 5140  - ;2x: replay() seems to be still replaying old data for late subscribers;"" - using rxjava 206it seems [this issue]( is still present in rxjava 2 when late subscribers `subscribe()` to a source with `replay(time unit)` that has already expired the source still emits the """"expired emission"""" if `onnext()` is not calledposted this originally on [stackoverflow]( but im now referencing it here because it seems to be an issue with the library"";hi and thanks for reporting indeed this is a bug that was not resolved in 2x:```javaioreactivexschedulerstestscheduler scheduler  new ioreactivexschedulerstestscheduler()        ioreactivexobservable<integer> source  ioreactivexobservablejust(3)                replay(2 timeunitseconds scheduler)                autoconnect()sourcetest()assertresult(3)sourcetest()assertresult(3)scheduleradvancetimeby(3 timeunitseconds)sourcetest()assertresult()```the timed versions of `flowablereplay()` `replayprocessor` `observablereplay()` and `replaysubject` are all affected and appears to be partially broken in 1x:```javarxschedulerstestscheduler scheduler  new rxschedulerstestscheduler()        rxobservable<integer> source  rxobservablejust(1)                replay(2 timeunitseconds scheduler)                autoconnect()sourcetest()assertresult(1)sourcetest()assertresult(1)scheduleradvancetimeby(3 timeunitseconds)sourcetest()assertresult()```fails on the last line with `not completed!`ill post the fixes for the respective versions shortly || closing via #5140 & #5141 ||;1;0;2x: fix timed replay-like components replaying outdated items;"
"5141;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: fix timed replay() not terminating when all items timeout;the timed  replay()  operator didn t terminate a late subscriber if all the items timed out in the meantime.;;5139.0;1x: fix timed replay() not terminating when all items timeout;the timed `replay()` operator didnt terminate a late subscriber if all the items timed out in the meantimerelated: #5139;;2x: replay() seems to be still replaying old data for late subscribers;"" - using rxjava 206it seems [this issue]( is still present in rxjava 2 when late subscribers `subscribe()` to a source with `replay(time unit)` that has already expired the source still emits the """"expired emission"""" if `onnext()` is not calledposted this originally on [stackoverflow]( but im now referencing it here because it seems to be an issue with the library"";hi and thanks for reporting indeed this is a bug that was not resolved in 2x:```javaioreactivexschedulerstestscheduler scheduler  new ioreactivexschedulerstestscheduler()        ioreactivexobservable<integer> source  ioreactivexobservablejust(3)                replay(2 timeunitseconds scheduler)                autoconnect()sourcetest()assertresult(3)sourcetest()assertresult(3)scheduleradvancetimeby(3 timeunitseconds)sourcetest()assertresult()```the timed versions of `flowablereplay()` `replayprocessor` `observablereplay()` and `replaysubject` are all affected and appears to be partially broken in 1x:```javarxschedulerstestscheduler scheduler  new rxschedulerstestscheduler()        rxobservable<integer> source  rxobservablejust(1)                replay(2 timeunitseconds scheduler)                autoconnect()sourcetest()assertresult(1)sourcetest()assertresult(1)scheduleradvancetimeby(3 timeunitseconds)sourcetest()assertresult()```fails on the last line with `not completed!`ill post the fixes for the respective versions shortly || closing via #5140 & #5141 ||;1;0;1x: fix timed replay() not terminating when all items timeout;"
5146;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: add unsubscribeon to single type (#5138);5138;;5138.0;1x: add unsubscribeon to single type (#5138);5138 add unsubscribeon to single type; merging 5146 ;1x: unsubscribeon for single?;rxjava version: v127although single may be unsubscribed on a different thread than subscribed one there seems to be no `unsubscribedon` operator for singleit would be nice if there is a `single#unsubscribeon`i currently convert to observable and use subscribeon/unsubscribeon methods for observable and then convert back to single;pr welcome || closing via #5146 ||;1;0;add unsubscribeon to single type (#5138);
5153;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: java 9 compatibility fixes (march 3);java 9 has changed its overload resolution algorithm and things that resolved unambiguously in java 8 no longer resolve:;;0;2x: java 9 compatibility fixes (march 3);java 9 has changed its overload resolution algorithm and things that resolved unambiguously in java 8 no longer resolve:```javaflowable<? extends t> source  sourcesubscribe(new flowablesubscriber<t>() {  })```with the code above javac 8 eclipse and intellij 2017 eap picks `flowablesubscribe(flowablesubscriber<? super t> s)` as expected however javac 9 finds it ambiguous with `flowablesubscribe(subscriber<? super t> s)` despite intellij 2017 eap not indicating any error and still jumping to the right method via ctrl+clickthe problem may come from the `? extends t` part of the declaration having just `flowable<t>` compiles properly with javac9luckily we dont need `? extends t` and this pr changes the internal signatures of the affected components; merging 5153 ;;;;1;1;2x: java 9 compatibility fixes (march 3);
5155;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: improve basetestconsumer with awaitcount & timeout;this pr enhances the timeout detection and reporting of the  testsubscriber / testobserver  base class  basetestconsumer :;;0;2x: improve basetestconsumer with awaitcount & timeout;this pr enhances the timeout detection and reporting of the `testsubscriber`/`testobserver` base class `basetestconsumer`:   - `awaitcount(int atleast [ runnable waitstrategy [ timeout]])`: wait until at least the given amount of onnext events have been observed or the upstream terminated  - enhance `awaitx` methods to set a `timeout` flag  - show the `timeout!` string in the assertion failures set by the `awaitx` methods  - show the `disposed!` string in the assertion failures if the consumer has been cancelled/disposed  - `asserttimeout` and `assertnotimeout` to assert explicitly after an `awaitx` method  - `istimeout` and `cleartimeout` to check and clear the flag statusin addition the internal array that collects the items has been replaced with a new custom `list` implementation: `volatilesizearraylist` that makes sure `size()` is a volatile read and happens before the committing the size in another thread due to `add()` (in theory one shouldnt cast `values()` unconditionally to `arraylist` anyway); merging 5155  - ;;;;1;1;improve diff coverage;
"5156;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add @nonnull to the methods of emitter;this pr is a part of #4876;;4876.0;add @nonnull to the methods of emitter;this pr is a part of #4876 this pr adds `@nonnull` annotation to some methods of `emitter` so that the users of rxjava migrating from 1x to 2x can easily know passing null to the methods will cause npe;sorry ive just noticed there is #5151 related to this pr ||  merging 5156 ;2x: add @nonnull annotation for function/predicate/etc;one of the larger tasks when transitioning from 1 to 2 is removing the use of null right now theres no automated way to do it but if we had `@nonnull` then wed be able to use static analysis to find where were returning null when we shouldnt beim not sure the best way to go about it - if we should include jsr305 use java 8s nonnull create our own or something else;""we cant do external dependencies like jsr305 and i cant find `@nonnull` or `@notnull` in java 8s public api we could introduce our own if your tools support custom annotations for this purpose || it looks like java 8 doesnt actually include it - its part of a checker framework more details [here]( im specifically targeting intellijs """"constant conditions & expressions"""" inspection and it looks like you can tell intellij about which annotations should be considered non-null / nullable so it would work if rxjava had its own `@nonnull` annotation included with the library (as long as developers are willing to do a little configuration on their end to accept it)the only downside to not using jsr305 is that we cant use something like `@parametersarenonnullbydefault` which would be less verboseif people are on board with this i could start implementing this (but its a lot of busywork so i dont want to bother unless people want it) || looks like there is an interest for new annotations #4878 so it this has to be coordinated with that im not sure about adding `@nonnull` to the functional interfaces though as it may add internal noise to rxjava we could however annotate parameters and return types of the base reactive classes || hmm im most concerned about the functional interfaces actually those are the ones where the app may accidentally crash during execution unexpectedlyheres a contrived example:```javavoid main() {    observablejust(""""dan"""")        map(new function<string string>() {            @override            public string apply(string s) throws exception {                return usuallydependablemethod(s)            }        })        subscribe()}string usuallydependablemethod(string name) {    return (mathrandom() < 95) ? """"hello """" + name : null}```i can imagine a lot of circumstances where coders dont even realize that `usuallydependablemethod()` could sometimes return null (when its not such an obvious problem) thats where static analysis would really help out || another +1 reason for this would be that kotlin automatically changes variables to not null as a language feature if they are annotated with `@nonnull` from jsr 305 along with the intellij and android equivalents  kotlin users using rxjava would have the benefit of knowing that their values in something like `onnext()` are not null@akarnokd can you give a reason for not being able to pull in jsr 305 or some equivalent? just curious || historically rxjava is kept to a minimum dependency: 0 in v1 and 1 in v2 || i agree @dlew - in a larger code base its pretty easy to run into issues like this and theres no way to catch them until runtimeif its annotated a handful of static analysis tools and ides can leverage this at compile time (even if its a custom annotation within the library) || i have created a pull request with some changes: || closing via #5051 & #5055 let us know if further annotations are necessary || i recently had an issue where a null list<t> was accidentally passed into `observablefromiterable()` unfortunately that bug made it to production but it would have been caught if the parameters are annotated @akarnokd @dlew i believe it would be worth it add nullability annotations every where `objecthelperrequirenonnull(object message)` is used to guard executionthis would be a massive change and it will definitely break compilation in some kotlin code bases mine included || recent intellij infers most nullability annotations for me in java:( in kotlin but it doesnt post a warning (see [kotlin]( || thanks for the quick reply i havent been able to get intellij to infer nullability annotations ive put together a [quick example of my problem]( post you linked seems to address the problem of consuming java types in kotlin rather than here where kotlin types are consumed by java rxjavas `ioreactivexannotationsnonnull` is [compatible]( with the kotlins compiler as such will cause a compiler error if a nullable kotlin type is passed into a `@nonnull` java parameteri apologize if this level of kotlin support is outside of the scope of this project  || > rather than here where kotlin types are consumed by javai thought writing in kotlin requires one to explicitly forfeit non-nullness have you been using this particular nullable `list` source elsewhere where it being `null` conveys additional information?> i apologize if this level of kotlin support is outside of the scope of this projectwe could add the `@nonnull` annotations but for the sake of any other library out there id also prefer intellij had the same nullness warning in a kotlin file (officially) that is already available for java || > have you been using this particular nullable list source elsewhere where it being null conveys additional information?the project was recently converted from rxjava 1x -> 2x and from java to kotlin in a short time span and this bug went unnoticed as far as i can tell `null` does not convey additional information in the stream > i thought writing in kotlin requires one to explicitly forfeit non-nullness its not necessarily the case if java types are correctly annotated   || @akarnokd is there any reason why return type of `function` interface is not annotated with `@nonnull`? `bifunction` and `function3` - `function9` return types are annotated with `@nonnull` does it break some contract? || nulls that cant end up in a sequence are allowed for example in `groupby` key selector and `distinct` selector || > nulls that cant end up in a sequence are allowed for example in groupby key selector and distinct selectorwhat do you think about creating annotation `@returnsnonnull` and annotate all `function` interface usages where the nullable value is not allowed? unfortunately it will require changes in static analysis tools another option is to create `nonnullfunction` interface with `@nonnull` return type but imho breaking api to fix this isnt worth it || java 6 doesnt allow annotating type arguments that way youd need to break binary compatibility to introduce all combinations of possible nullness to the interfaces and use sites || "";1;0;add @nonnull to the methods of emitter;"
5161;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add observable.switchmapsingle and switchmapsingledelayerror;this is a new operator discussed in #4853. the issue refers to a goodly number of new operators which i ll do bit by bit as my time allows and to ensure review is not too daunting.;;4853.0;2x: add observableswitchmapsingle and switchmapsingledelayerror;this is a new operator discussed in #4853 the issue refers to a goodly number of new operators which ill do bit by bit as my time allows and to ensure review is not too daunting;updated with suggested changes || unrelated ci failure```ioreactivexparallelparallelflowabletest > parallelismandprefetchasync failed    javalangassertionerror: value counts differ expected: 1048576 actual: 814189 (latch  1 values  814189 errors  0 completions  0 timeout! disposed!)        at ioreactivexobserversbasetestconsumerfail(basetestconsumerjava:163)        at ioreactivexobserversbasetestconsumerassertvaluecount(basetestconsumerjava:462)        at ioreactivexparallelparallelflowabletestparallelismandprefetchasync(parallelflowabletestjava:741)``` || > unrelated ci failuretracking via #5154 could be due to low timeout settings and travis overload just rerun the build next time i did it just now ||  merging 5161 ;2x: switchmapsingle and switchmapcompletable;heythe addition of `flatmapsingle`/`flatmapcompletable` made the usage of `single` and `completable` way nicer in rxjava 2do you consider adding `switchmapsingle`/`switchmapcompletable` to rxjava 2 as well?cheers;you mean 1x? i have no plans for that and i dont want to keep 1x alive for too long id like to stop enhancing 1x in 6 months and enter it into a bugfix-only mode otherwise 3rd party libraries may delay their upgrade way longer || he wants `switchmapsingle` and `switchmapcompletable` for rxjava 2 just like there is `flatmapsingle` and `flatmapcompletable` || @vanniktech exactly || ah right no plans for extending any other xmap operator || but then `concatmap` also needs the variants in order to be consistent to be honest i forgot about those when proposing `flatmapsingle / flatmapcompletable / flatmapmaybe` initially - #4667 and then theres also `maybe` plus `observable` and `flowable` are able of mapping so its easily another 12 methods- observableswitchmapsingle- observableswitchmapmaybe- observableswitchmapcompletable- observableconcatmapsingle- observableconcatmapmaybe- observableconcatmapcompletable- flowableswitchmapsingle- flowableswitchmapmaybe- flowableswitchmapcompletable- flowableconcatmapsingle- flowableconcatmapmaybe- flowableconcatmapcompletable || if it is not on the roadmap because you dont want to add any more xmap operators then i understandbut if it is due to lack of the time would you consider accepting contributions on the topic? || sure but these operators are not easy || yes i know those are one of the hardest still i will at least have a look and see if i can deliver a prcheers! || any progress on this? || im happy to have a look at this one if @tomaszpolanski doesnt have time at the moment || @davidmoten it would be great! my available time now is pretty limited  || so the list of new operators is quite big currently:* observableswitchmapsingle* observableswitchmapmaybe* observableswitchmapcompletable* observableconcatmapsingle* observableconcatmapmaybe* observableconcatmapcompletable* flowableswitchmapsingle* flowableswitchmapmaybe* flowableswitchmapcompletable* flowableconcatmapsingle* flowableconcatmapmaybe* flowableconcatmapcompletablei imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by one an example would be `observableswitchmapsingle`:```javapublic final <r> observable<r> switchmapsingle(    final function<? super t ? extends singlesource<? extends r>> mapper) {        function<? super t observable<r>> mapper2  t ->             {                singlesource<? extends r> source  mapperapply(t)                single<? extends r> single                if (source instanceof single) {                    single  (single<? extends r>) source                } else {                    single  singleunsafecreate(source)                }               return (observable<r>) singletoobservable()            }        return switchmap(mapper2 buffersize())    }```this is just to demo the idea i wouldnt use an anonymous class and lambdas are just used for readability@akarnokd any interest in this? || > i imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by oneindeed> an example would beif you do this there is an unwritten guideline that the main base types should have no (anonymous) inner classes it helped me a lot before not having to deal with flowable$1$2 and similar entries the go-to place for these are in `ioreactivexinternaloperatorsflowableflowableinternalhelper` and its respective variants> any interest in this?im more interested in the direct implementations but at least the overall usefullness of the api extension could be vetted || >if you do this there is an unwritten guideline that the main base types should have no (anonymous) inner classes it helped me a lot before not having to deal with flowable$1$2 and similar entries the go-to place for these are in ioreactivexinternaloperatorsflowableflowableinternalhelper and its respective variantsyep no problems ive appreciated consistent naming of non-anon classes inside operators for debugging purposes and code searches too>im more interested in the direct implementations but at least the overall usefullness of the api extension could be vettedsure ill proceed with prs with unit tests for the new operators and im happy to have a stab at dedicated operators after that || what is expected behaviour for `observableswitchmapmaybe` and `observableswitchmapcompletable`? i can try to take care of it but i am not convinced what that method should return || in the mean time would it be correct to assume that an acceptable workaround for this is as follows?: **toobservable()**```upstreamconcatmap {        someobservable()collect{}toobservable()    }``` || @feresr probably yes at this moment in few places inside my code i have this type of stucture it is very weird and uncessesery code but it is understandable@akarnokd what do you think about method switchmapcompletable which emit object or maybe some enum? on the other hand we can we can swallow information about stream and do not emit anything || @marcinsus i dont fully understand your question use `switchmapcompletable()andthen(single)` to emit something after the switch completed || the problem he talks about is that switchmapcompletable does not exist switchmapsingle returns an observable of the single typeso technically switchmapcompletable should return void (which it cant because that has no instance) so he asks if the signature should rather expose some `enum nothing` or just an `object` || an `observableswitchmapcompletable` should return `completable` || you are right as `flatmapcompletable` returns a `completable`but now i find it weird that `observableflatmapsingle<t>`returns an `observable<t>`but `observableflatmapcompletable` returns an `completable` || a stream of 5 elements flatmapd to a stream of a single element still results in a stream of 5 elements || im working on implementing `concatmapcompletable` across the reactive typesim wondering if the library should also have implementations of`concatmapdelayerrorcompletable` `concatmapeagercompletable` `concatmapeagerdelayerrorcompletable`? || `concatmapeagercompletable` is indistinguishable from `flatmapcompletable` because all sources run concurrently and their only output is a terminal event no items have to be buffered until their turn also the `maxconcurrency  1` gets you `concatmapcompletable` behavior || ahh yes that makes sense  so is there any reason to implement `concatmapcompletable` at all?  if so do you want it to just use flatmapcompletable() internally or should there be a new direct implementation (what ive been working on)? || actually `observableflatmapcompletable` doesnt have `maxconcurrency` overload thus there might be a reason to implement `concatmapcompletable` || ok ill keep at it then ||  anything ever come of this?  || #5161 and #5649 added some operators || so there are plans to implement the other operators but not in any particular timeframe? || the listed operators can simply expressed with the existing default operators and `toobservable`/`toflowable` in the lambda parameters unfortunately very few people could or are willing to write them in an optimized and inlined fashion - which would add more value to the library than a simple lambda-rewriting function imagine you have to write a proper javadoc with a marble diargram and several hundred lines of unit tests to validate and cover a new operator with some 3 lines of code kotlins extension methods really shine in allowing interested parties to define such convenience functions locally to their project and not boomeranging such features through the rxjava library the issue is left open in case somebody really wants to take the time and effort to contribute but as the core developer im not particularly interested myself in tackling these types of operators || closing via #5870 #5871 #5872 #5873 #5875 ||;1;0;add observableswitchmapsingle;
"5163;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: single.subscribe() to report isdisposed() true on success/error;the  consumersingleobserver  didn t report  isdisposed  consistently with its state.;;5160.0;2x: singlesubscribe() to report isdisposed() true on success/error;the `consumersingleobserver` didnt report `isdisposed` consistently with its statereported in #5160; merging 5163  - ;2x: disposable returned from singlesubscribe() is not disposed after terminal event;""when using singlesubscribe(onsuccess onerror)  the returned disposable is not disposed after terminal event however  for observable flowable maybe and completable  the results are all disposedhere is the test code: ```java@testpublic void testdisposable() throws exception {	disposable disposable	disposable  singlejust(1)subscribe(		next -> systemoutprintln(""""single success"""")		error -> systemoutprintln(""""single error"""")	)	systemoutprintln(""""single disposed: """" + disposableisdisposed())	disposable  observablejust(1)subscribe(		next -> systemoutprintln(""""observable next"""")		error -> systemoutprintln(""""observable error"""")		() -> systemoutprintln(""""observable complete"""")	)	systemoutprintln(""""observable disposed: """" + disposableisdisposed())}```output:```single successsingle disposed: falseobservable nextobservable completeobservable disposed: true```i found the disposeable not lazyset to disposed in  consumersingleobserver compared with lambdaobserver is this a bug or there are some special reasons to do this?```javaconsumersingleobserver@overridepublic void onsuccess(t value) {	try {		onsuccessaccept(value)	} catch (throwable ex) {		exceptionsthrowiffatal(ex)		rxjavapluginsonerror(ex)	}}``````javalambdaobserver@overridepublic void oncomplete() {	if (!isdisposed()) {		lazyset(disposablehelperdisposed)		try {			oncompleterun()		} catch (throwable e) {			exceptionsthrowiffatal(e)			rxjavapluginsonerror(e)		}	}}```rxjava 206"";thanks for reporting it looks like a simple oversight since the tests pass when i add the `lazyset`s see #5163 || closing via #5163 || helloi am unable to understand the conclusion here is disposable supposed to be auto-disposed for single? i wrote some code and i see it is not disposed is it the right behavior? || this issue has been closed and the fix has been available for a year now what test did you write against which version? || sorry i have been testing it wrong my bad! thanks for quick response though :) ||;1;0;2x: singlesubscribe() to report isdisposed() true on success/error;"
5170;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix lambdaobserver not cancelling the upstream;the  lambdaobserver  didn t cancel the upstream when its  onsubscribe  and  onnext  callbacks crashed. also reported on the mailing list:;;0;2x: fix lambdaobserver not cancelling the upstream;the `lambdaobserver` didnt cancel the upstream when its `onsubscribe` and `onnext` callbacks crashed also reported on the mailing list:> dave smith: when i am using an operator in observable that calls subscribe (foreach as a example) and the onnext function throws an exception the underlying class (lambdaobserver) marks the subscription disposed but does not notify upstream that is is disposed what is the reason for this?the `lambdasubscriber` was working correctly both received unit tests to ensure the correct behavior; merging 5170  < ;;;;1;1;2x: fix lambdaobserver not cancelling the upstream;
"5174;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: wip removes anonymous inner classes.;this is a wip. since the changes are big  an incremental review and pr was recommended by @akarnokd;;5150.0;2x: wip removes anonymous inner classes;this is a wip since the changes are big an incremental review and pr was recommended by @akarnokd  - removes them  from flowable/observable/operators- issue 5150](https://githubcom/reactivex/rxjava/issues/5150); merging 5174 ;2x: eliminate all anyonymous inner classes;currently mostly the base reactive classes have been cleared of anonymous inner classes still many stacktraces contain `someclass$1$2` that makes it difficult to figure out what that exact component was without having an ide openi dont know if ides allow searching for anonymous inner classes and/or highlight them like warnings thus the a reasonable way would be to scan the build directory for files containing the `$` patternin addition if there is an agreement a new style-validation unit test could be added that does the same scanning at unit test time (ignoring `someclasstest`s) and warning/failing the build if any of such files was foundpr welcome;""intellij has """"search structurally"""" function with predefined search for anonymous classes (`search structurally` -> `copy existing template` -> `anonymous classes`)also its possible to create inspection from search see `preferences` -> `editor` -> `inspections` -> `general` -> `structural search inspection` || thanks it shows about 115 places under `src/main/java` || hey guys the issue is tagged with """"pr welcome"""" so `i started working on it and removed all of them getting test errors due to naming violations early feedback is appreciated  || hi and thanks for tackling this see #5159 where i can comment on specific issues || looks like there are a bunch of copy-paste errors and the test hangs due to some unexpected code changes i suggest you start over piece by piece and verifying after each java file the tests still pass || done || "";1;0;cleanups in operators;"
5176;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix private field access  few generics problems;this pr fixes some private field accessor problems introduced by #5174 as well as a couple of generics warnings.;;0;2x: fix private field access few generics problems;this pr fixes some private field accessor problems introduced by #5174 as well as a couple of generics warningsnote that in intellij there is a j2me inspection for private access checks between parent and inner classes; merging 5176 ;;;;1;1;2x: fix private field access few generics problems;
"5177;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;removes all anonymous inner classes;this is a what left to complete [this one]( :;;5150.0;removes all anonymous inner classes;this is a what left to complete [this one]( :  - removes all aics  - issue 5150](https://githubcom/reactivex/rxjava/issues/5150);@sleimanjneidi whats the motivation behind making this change? || @naturalwarren to improve stack-traces and to reduce the footprint   || > @naturalwarren to improve stack-traces and to reduce the footprintmakes sense thanks for filling me in!  ||  merging 5177 ;2x: eliminate all anyonymous inner classes;currently mostly the base reactive classes have been cleared of anonymous inner classes still many stacktraces contain `someclass$1$2` that makes it difficult to figure out what that exact component was without having an ide openi dont know if ides allow searching for anonymous inner classes and/or highlight them like warnings thus the a reasonable way would be to scan the build directory for files containing the `$` patternin addition if there is an agreement a new style-validation unit test could be added that does the same scanning at unit test time (ignoring `someclasstest`s) and warning/failing the build if any of such files was foundpr welcome;""intellij has """"search structurally"""" function with predefined search for anonymous classes (`search structurally` -> `copy existing template` -> `anonymous classes`)also its possible to create inspection from search see `preferences` -> `editor` -> `inspections` -> `general` -> `structural search inspection` || thanks it shows about 115 places under `src/main/java` || hey guys the issue is tagged with """"pr welcome"""" so `i started working on it and removed all of them getting test errors due to naming violations early feedback is appreciated  || hi and thanks for tackling this see #5159 where i can comment on specific issues || looks like there are a bunch of copy-paste errors and the test hangs due to some unexpected code changes i suggest you start over piece by piece and verifying after each java file the tests still pass || done || "";1;0;removes all anonymous inner classes;"
5182;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix replay().refcount() leaking items between connections;this pr updates  observable.replay()  and  flowable.replay()  **for 2.x** to not leak items between reconnections when run with  .refcount() . the  replay()  operator is designed to hold onto the buffer even after its completion so late subscribers can still receive the cached data. only a new  connect()  clears this data which may or may not happen. since  refcount  ensures that there won t be any latecommers to an already completed connection (because it also drops its current subscribers on termination or when reaching zero)  the  replay()  can be reset to an empty state.;;5172.0;2x: fix replay()refcount() leaking items between connections;this pr updates `observablereplay()` and `flowablereplay()` **for 2x** to not leak items between reconnections when run with `refcount()` the `replay()` operator is designed to hold onto the buffer even after its completion so late subscribers can still receive the cached data only a new `connect()` clears this data which may or may not happen since `refcount` ensures that there wont be any latecommers to an already completed connection (because it also drops its current subscribers on termination or when reaching zero) the `replay()` can be reset to an empty staterelated: #5172 #5181; merging 5182 ;127: replay(1)refcount() keeps latest value in memory even after everyone unsubscribes;code sample:```javapublic class mainactivity extends appcompatactivity {    private observable<object> testobservable    @override    protected void oncreate(bundle savedinstancestate) {        superoncreate(savedinstancestate)        testobservable  observablefromcallable(new callable<object>() {            @override            public object call() throws exception {                return new verybigobject()            }        })        replay(1)        refcount()        //first subscription - callable and creation of verybigobject will be called        subscription subscription1  testobservablesubscribe()        //second subscription - cached value in operatorreplay in onnext        subscription subscription2  testobservablesubscribe()        //first unsubscribe - cached value still in operatorreplay as we have at least 1 subscriber for refcount        subscription1unsubscribe()        //second unsubscribe - there are no subscribers so my guess is that there should be no cached value in operatorreplay        //as no one needs that object        subscription2unsubscribe()        //but after everyone unsubscribe there is a reference to verybigobject    }    public static class verybigobject {        //its very big    }}```problem: if im storing in field any observable that contains replay(1)refcount() then this field will store hard reference to that latest value stored in replay buffer even if there are no subscriptions to that replay this value takes memory and it is not good but maybe its as-design also i think that this bug is actual for any replay(***) of any observables chain that have such operatorwhy am i sad: usually i use such construction to not calculate or get from disc some shared single-instance object so if there are at least one subscriber so that object is calculating on subscribe and other subscribers wont call calculation on subscribe but take already calculated value reference to verybigobject        from `mainactivity` - this (root) object        from `testobservable (observable)` - field of mainactivity object stores observable with replay        from `onsubscribe (onsubscriberefcount)` - field of testobservable stores refcount()        from `source (operatorreplay)` - field of onsubscriberefcount stores connectableobservable of replay()         from `current (atomicreference)` - reference to current subscriber it is only changing to not-null in connect() of operatorreplay         from `value (operatorreplay$replaysubscriber)` - value of atomicreference         from `buffer (operatorreplay$sizeboundreplaybuffer)` - linked list of replay values with limit1 after everyone unsubscribe it has size2 index2         from `value (operatorreplay$node)` - head node of linked list - its own node value (not from atomicreference field) is null         from `value (operatorreplay$node)` - next element of linked list from head - it stores verybigobject         from `value (verybigobject)` - latest value of replay(1) before everyone unsubscribe;try with `onterminatedetach` before the `replay()` || @akarnokd `onterminatedetach` not helping :(- without detach it is `singledelayedproducer` in `producer` field of `operatorreplay$replaysubscriber` and it have reference to `operatorreplay$replaysubscriber` in `child` field- with detach it is `onsubscribedetach$detachproducer` in `producer` field and there is no reference from that but there is still reference from `value->current->source->onsubscribe->testobservable`i mean i think problem is that on creation before someone subscribed there was `null` value of `operatorreplay->current` but after everyone unsubscribed `operatorreplay` didnt back to initial state with `null` in that field so it continue holding reference to  `operatorreplay$replaysubscriber` that was created on first subscription and in `operatorreplay$replaysubscriber` there is a buffer with leaked objectsif it could help there are heap hprof files: (look for class `testactivitiesmainactivity$verybigobject`)- heap with `onterminatedetach`:  heap without `onterminatedetach`:  few comments about `onterminatedetach` - i saw it in discussion  beforeand my opinion that `onterminatedetach` wont help in described situation because on subscription of `replay()` it should subscribe to previous observable so it should be stored in `source` and if it is `observablejust(millionvalues)` then it should store `millionvalues` to emit them to subscribersand i think if someone dont want to store it in memory then they could just use`observablefromcallable(()->observablejust(millionvalues))switchmap(justobservable->justobservable)last()replay()` or use`observableswitchonnext(observablefromcallable(()->observablejust(millionvalues)))last()replay()` || i see could you do a final test: use `onterminatedetach()` after `refcount()` as well (so 2 of them total) and make sure the `subscription`s are nulled out before you take a heap dump? || code and 4 dumps: line 30 (1_before_first_subscribe) line 32 (2_after_second_subscribe) line 34 (3_after_second_unsubscribe) and 4_after_on_create || in number 4 all i see is a small heap with barely anything in it:( || dont think that profiler thinks that it is a problem until ill put `byte[1000000]` or something like that inside `verybigobject`but problem is that in number 4 there is strong reference to `verybigobject` and in number 1 there is no such reference![title]( || see #5181 for the fix || closing via #5181 & #5182 || thanks  :d sry for late response ||;1;0;2x: fix replay()refcount() leaking items between connections;
5183;1;0;0;1;0;1;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: test to disallow anonymous inner classes;this pr adds an unit test that scans the compiled .class files for anonymous inner classes naming (i.e.  dollar sign followed by a number). since all the main  test and perf classes end up in the same place  the test has exceptions for file names containing  perf  or  test .;;0;2x: test to disallow anonymous inner classes;this pr adds an unit test that scans the compiled class files for anonymous inner classes naming (ie dollar sign followed by a number) since all the main test and perf classes end up in the same place the test has exceptions for file names containing `perf` or `test`the pr also fixes a few checkstyle warnings from #5177 and fixes a couple classes from tests that dont have the word `test` in their name and thus were detected; merging 5183 ;;;;1;1;2x: test to disallow anonymous inner classes;
5184;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add offer() method to publish & behavior processors;this pr adds the  boolean offer(t item)  method to  publishprocessor  and  behaviorprocessor  to prevent  missingbackpressureexception  when one of the  subscriber s is not ready to receive element by indicating a false return value. the sender can then retry the offer with any wait strategy it choses.;;0;2x: add offer() method to publish & behavior processors;this pr adds the `boolean offer(t item)` method to `publishprocessor` and `behaviorprocessor` to prevent `missingbackpressureexception` when one of the `subscriber`s is not ready to receive element by indicating a false return value the sender can then retry the offer with any wait strategy it chosesin addition this pr adds reactive-streams publisher tck checks to verify `asyncprocessor` `behaviorprocessor` `publishprocessor` `replayprocessor` and `unicastprocessor` as being `publisher`s unfortunately the tck cant verify them as `processors because the tck has certain expectations about how a `processor` should behave (namely: expects fail-fast refcount-like nature); merging 5184 ;;;;1;1;sleep instead of yield;
5187;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: reflection-based parameter validator & fixes;this pr adds a reflection-based parameter validator to check the base reactive classes for proper parameter validation: null checks and argument ranges. the problems detected are fixed as well.;;0;2x: reflection-based parameter validator & fixes;this pr adds a reflection-based parameter validator to check the base reactive classes for proper parameter validation: null checks and argument ranges the problems detected are  as well; merging 5187  this because there are a couple of inbound api changes from other contributors and having this in place avoids conflicts ||;;;;1;1;2x: reflection-based parameter validator & fixes;
"5188;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix flatmap emitting the terminal exception indicator on cancel;this pr fixes the case when  flowable.flatmap  and  observable.flatmap  would emit the  exceptionhelper.terminted  indicator exception to downstream due to emission-cancellation race.;;0;2x: fix flatmap emitting the terminal exception indicator on cancel;this pr fixes the case when `flowableflatmap` and `observableflatmap` would emit the `exceptionhelperterminted` indicator exception to downstream due to emission-cancellation racereported on [stackoverflow](http://stackoverflowcom/questions/42580195/what-is-the-meaning-of-no-further-exceptions);"" merging 5188  "";;;;1;1;2x: fix flatmap emitting the terminal exception indicator on cancel;"
5189;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix concatmapeager should accept 0 for prefetch;fixes a bug that  flowable.concatmapeager(mapper   maxconcurrency   prefetch) and observable.concatmapeager(mapper   maxconcurrency   prefetch) operators will not accept 0 and negative numbers.;;5185.0;2x: fix concatmapeager should accept 0 for prefetch;fixes a bug that  flowableconcatmapeager(mapper  maxconcurrency  prefetch) and observableconcatmapeager(mapper  maxconcurrency  prefetch) operators will not accept 0 and negative numbersreported in #5185;i believe a 0 breaks the internals of the operator and -1 has the completely opposite effect taking more memory || i am sorry with the wrong fixis it only necessary to modify the document? || > is it only necessary to modify the document?yes please modify only the javadoc || thank you! also i think that the test case name is wrong so i modifed it ||  merging 5189 ;2x concatmapeager should accept 0 for prefetch;the documentation for `concatmapeager` states:```java@param prefetch hints about the number of expected source sequence values```which leads me to assume that the following code should work:```javaobservablefromiterable(somecollection)    concatmapeager(this::performtask 5 somecollectionsize())```but it will fail if the collection is empty either the documentation should be updated to reflect that 0 is not a valid value or it should accept 0 (and perhaps set it to a default value internally);looks like there is a missing validation there as well pr welcome plus the parameter document should read something like:`hints about the number of expected values from each inner observablesource` || on a second look this is not a bug in the operator but perhaps the underdocumentation prefetch of 0 or negative has no meaning and if you think there wont be any value use 1 as the prefetch amount || closing via #5189 ||;1;0;merge branch 2x into concatmapeagerusedefault;
5191;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;correct java doc for refcount() return type. v2.0.7;java doc for  connectableobservable.refcount()  says  it returns a  flowable   but it should be  observable;;0;correct java doc for refcount() return type v207;java doc for `connectableobservablerefcount()` says  it returns a `flowable` but it should be `observable`; merging 5191 ;;;;1;1;correct java doc for refcount() return type;
"5195;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: unicastsubject fail-fast and delay-error behavior;this pr adds support for delay-error behavior to  unicastsubject  with methods  unicastsubject<t> create(boolean delayerror)    unicastsubject<t> create(int capacityhint  action0 onterminated  boolean delayerror) . behavior of existing factory methods was not changed  and is fail-fast.;;5165.0;1x: unicastsubject fail-fast and delay-error behavior;this pr adds support for delay-error behavior to `unicastsubject` with methods `unicastsubject<t> create(boolean delayerror)` `unicastsubject<t> create(int capacityhint action0 onterminated boolean delayerror)` behavior of existing factory methods was not changed and is fail-fastrelates to #5165; merging 5195 ;1x: unicastsubject does not replay onnext calls made prior to subscription if onerror is also called prior to subscription;""im using rxjava 125 consider this code:```java    unicastsubject<string> s  unicastsubjectcreate()    sonnext(""""1"""")    sonnext(""""2"""")    sonerror(new exception(""""uh oh""""))    ssubscribe(systemout::println systemout::println)```this outputs  uh ohhowever the same code using rxjava 207 version of `unicastsubject` outputs  uh ohwhich is the behavior i expected from 1x"";""hi in rxjava 1x the unicastsubject is fail-fast and in 2x it is delay-error currently there is no option for the other mode in either major version || @akarnokd ah i see thanks for the clarification is that documented somewhere that im missing? the unicastsubject docs for 1x gave me the impression that all events will get replayed once its subscribed to regardless of whether or not theres an error event i also didnt find it mentioned in the """"whats different in 20"""" wikialso i noticed you added the """"pr welcome"""" label - are you looking for prs that add a way to optionally (and not by default) switch to the currently unsupported mode for each major version? meaning add a way to delay-error on 1x and/or a way to fail-fast on 2x || > i also didnt find it mentioned in the """"whats different in 20"""" wikithis change was likely simply overlooked> added the """"pr welcome"""" labelyes keep the current defaults in each version and add two factory methods:```javapublic static <t> unicastsubject<t> create(boolean delayerror) {    // }public static <t> unicastsubject<t> create(int buffersize         runnable onterminate boolean delayerror) {    // }``` || @akarnokd got it  closing via #5195 #5217 and #5226 || "";1;0;cache delayerror field in local variable;"
5196;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add a few more @nullable & @nonnull annotations to public interfaces;- adds the @nullable & @nonnull annotations to;;0;2x: add a few more @nullable & @nonnull annotations to public interfaces;- adds the @nullable & @nonnull annotations to  - emitters  - observer  - onsubscribe  - operator  - source  - transformerfor observable maybe single completable & flowable; merging 5196 ;;;;1;1;2x: add a few more @nullable & @nonnull annotations to public interfaces;
5197;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add paralleltransformer interface  params-validation;this pr adds the  paralleltransformer  interface to match the other  xtransformer  interfaces  adds  @nonnull  annotations to the  parallelflowable  operators and adds the  parallelflowable  class to the parameter validator test set.;;0;2x: add paralleltransformer interface params-validation;this pr adds the `paralleltransformer` interface to match the other `xtransformer` interfaces adds `@nonnull` annotations to the `parallelflowable` operators and adds the `parallelflowable` class to the parameter validator test set; merging 5197 ;;;;1;1;add explicit requirenonnull calls;
5199;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: increase timeout on parallel & completable tests;this pr increases the timeout on  completabletest  test methods and on  parallelflowabletest.parallelismandprefetchasync .;;5154.0;2x: increase timeout on parallel & completable tests;this pr increases the timeout on `completabletest` test methods and on `parallelflowabletestparallelismandprefetchasync`related: #5154 #5179; merging 5199 ;2x: parallelflowabletest > parallelismandprefetchasync failed;```ioreactivexparallelparallelflowabletest > parallelismandprefetchasync failed    javalangassertionerror: value counts differ expected: 1048576 actual: 619054 (latch  1 values  619054 errors  0 completions  0)        at ioreactivexobserversbasetestconsumerfail(basetestconsumerjava:146)        at ioreactivexobserversbasetestconsumerassertvaluecount(basetestconsumerjava:443)        at ioreactivexparallelparallelflowabletestparallelismandprefetchasync(parallelflowabletestjava:741)```could be due to timeout on an overworked container instancealso the `basetestconsumer` may be extended to:  - print the cancellation status which `awaitdone` sets  - make `awaitdone` add an `onerror` (requires synchronising the errors list) or a separate timeout flag that gets also printed;closing via #5199 ||;1;0;2x: increase timeout on parallel & completable tests;
5199;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: increase timeout on parallel & completable tests;this pr increases the timeout on  completabletest  test methods and on  parallelflowabletest.parallelismandprefetchasync .;;5179.0;2x: increase timeout on parallel & completable tests;this pr increases the timeout on `completabletest` test methods and on `parallelflowabletestparallelismandprefetchasync`related: #5154 #5179; merging 5199 ;2x: ioreactivexcompletablecompletabletest > doonerrornoerror failed;```ioreactivexcompletablecompletabletest > doonerrornoerror failed    orgjunitrunnersmodeltesttimedoutexception: test timed out after 1000 milliseconds```;closing via #5199 ||;1;0;2x: increase timeout on parallel & completable tests;
5202;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add resilient versions of parallel map()  filter() & doonnext();this pr adds 2 new overloads to  parallelflowable  operators  map    filter  and  doonnext  to enable per item error handling in case the main function fails with some exception.;;5128.0;2x: add resilient versions of parallel map() filter() & doonnext();this pr adds 2 new overloads to `parallelflowable` operators `map` `filter` and `doonnext` to enable per item error handling in case the main function fails with some exception```javaflowablerange(0 2)parallel(1)map(v -> 1 / v parallelfailurehandlingskip)sequential()test()assertresult(1)```the new `parallelfailurehandling` has some default enumeration values to handle the common cases in addition the `bifunction` overload allows bounded retries and/or conditional handling of failuresrelated: #5128; merging 5202 ;2x: resilience in the parallel() operators;when the architecture of the `parallel()` subsystem was designed the goal was to provide means for efficient parallel computations over recovering from failures in any or most of the parallel rails in it this resulted fail-fast implementation and little to no means (beyond `flatmap`) to prevent the death of the whole parallel computation due to a single failing componentadding the usual `onerrorresumenext` or `retry` doesnt work because the core driver `parallel()` cant support resubscription on its individual rails and even if a failure behind a `runon` almost certainly would drop any unprocessed elements in its queuethe given toolset `parallelflowable` already gives the opportunity to include resilience at the cost of overhead: `flatmap` and/or `concatmap` as with the traditional flows the inner `flowable`s to these can have all sorts of operators not available on `parallel()` itself and are confined to the particular rail thus `retry()`/`onerrorresumenext` can be applied on a per item basis:```javaflowablerange(1 100)parallel(20)runon(schedulersio())concatmap(index -> apigetimage(index)onerrorresumenext(flowablejust(notavailableimage)))sequential()observeon(guithread)subscribe()```on the other hand parallel-`map`/`doonnext` (among others) dont offer any ignore/resume option out of box and unless the developer applies `try-catch` to prevent crashing the railto enable finer gained control in this situation i propose the following overloads:- `enum failurehandling`: stop error skip retry- `map(function<t r> failurehandling)`- `map(function<t r> function<throwable failurehandling>)`- `filter(predicate<t> failurehandling)`- `filter(predicate<t> function<throwable failurehandling>)`- `doonnext(action<t> failurehandling)`- `doonnext(action<t> function<throwable failurehandling>)`they should cover the the cases where the `function` hosts a blocking call (if there was a need for timed backoff the `concatmap` approach is still available)thoughts?;closing via #5202 ||;1;0;2x: add resilient versions of parallel map() filter() & doonnext();
5207;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: prevent tasks to self interrupt on the standard schedulers;task wrappers of the various schedulers and modes (direct & worker) were able to get cancelled via interruption from the same thread they were running.;;5203.0;2x: prevent tasks to self interrupt on the standard schedulers;task wrappers of the various schedulers and modes (direct & worker) were able to get cancelled via interruption from the same thread they were runningrelated #5203; merging 5207 ;is delaysubscription() interrupts the thread immediately as expected?;i ran the below test code with rxjava 207 and got a failure which succeeded with rxjava 1x```java    final testobserver<boolean> observer  testobservercreate()    observable<boolean>create(emitter -> {      emitteronnext(threadinterrupted())      emitteroncomplete()    })        delaysubscription(100 timeunitmicroseconds)        subscribe(observer)    observerawaitterminalevent()    observerassertvalue(false)  }```if i put `subscribeon()` before `delaysubscription()` it does not faili am not sure if it is as expected so want to know if it is the expected behaviourhere is some background of my issue: i am using rxjava 207 with retrofit 220 and it seems retrofit (precisely speaking okio which is being used in ok throws an error when the thread is interrupted while it tries to read the  response i am trying to delay the  call to achieve something like debounce() with delaysubscription() operator and encountered this issue i have a workaround so just want to know if it is the expected behaviourthank you for your support in advance;this is an unexpected side-effect of cancelling the delay timer inside the `delaysubscription` operator ill post a fix for it shortly || see #5207 || thank you for your prompt work on this waiting for the next release including this fix || closing via #5207 ||;1;0;2x: prevent tasks to self interrupt on the standard schedulers;
5208;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix images of firstelement  flattenasx  flatmapiterable;this pr links in the new images from #5130 for previously misleading marble diagrams of the operators.;;5130.0;2x: fix images of firstelement flattenasx flatmapiterable;this pr links in the new images from #5130 for previously misleading marble diagrams of the operators; merging 5208 ;2x: incorrect images;this is a container for identifying and tracking fixes to outdated or incorrent marble diagrams  -  [singleflattenasflowable]( refers to flatmapiterable no reordering of colors  -  [singleflattenasobservable]( refers to flatmapiterable no reordering of colors  -  [flowableflatmapiterable]( + 4 no reordering of colors  -  [observableflatmapiterable]( + 2 no reordering of colors  -  [flowablefirstelement()]( indicate cancellation after the first element shift marbles so the 2nd element doesnt imply the completion like in `singleorerror`  -  [observablefirstelement()]( indicate cancellation after the first element shift marbles so the 2nd element doesnt imply the completion like in `singleorerror`;( || ![image]( || ![image]( || closing i think its better to track new findings and their fixes in separate issues ||;1;0;+unicastsubject +unicastprocessor;
5209;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: add marble diagram to unicastsubject  fix javadoc;this pr fixes a missing javadoc entry for  <t>  in  unicastsubject  and adds a marble diagram to the class itself:;;0;1x: add marble diagram to unicastsubject fix javadoc;this pr fixes a missing javadoc entry for `<t>` in `unicastsubject` and adds a marble diagram to the class itself:(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/unicastsubjectv1png); merging 5209 ;;;;1;1;1x: add marble diagram to unicastsubject fix javadoc;
5210;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: better documentation on the abstract consumer classes;this pr improves the documentation of the abstract consumer classes such as  disposablesubscriber    resourcesubscriber  and their counterparts for the other base reactive types.;;5148.0;2x: better documentation on the abstract consumer classes;this pr improves the documentation of the abstract consumer classes such as `disposablesubscriber` `resourcesubscriber` and their counterparts for the other base reactive typesit contains a lot of copy-paste so please read through all of the text in case the text was not properly adapted to the abstract class at handrelated: #5148; merging 5210 ;2x: improve documentation of the default consumer types;describe their single-use nature explicitly mention `onstart` explicitly mention `dispose` or `cancel` maybe add code examples  -  `disposablesubscriber`  -  `disposablecompletableobserver`  -  `disposablemaybeobserver`  -  `disposablesingleobserver`  -  `disposableobserver`  -  `resourcesubscriber` (also remove mention of `asyncobserver`)  -  `resourcecompletableobserver`  -  `resourcemaybeobserver`  -  `resourcesingleobserver`  -  `resourceobserver`;see #5210 || closing via #5210 ||;1;0;2x: better documentation on the abstract consumer classes;
"5213;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix window() with time+size emission problems;the  window()  operator overload with time and size bound didn t work correctly when some windows were terminated by the timeout and others by the size. this pr fixes:;;5104.0;2x: fix window() with time+size emission problems;the `window()` operator overload with time and size bound didnt work correctly when some windows were terminated by the timeout and others by the size this pr fixes:  - the case when the operator restarts the time windows when the size bound is reached  - leaking of the worker  - the item counter not reset to zero when the time bound is reached  - periodic window bound stopped working after the first windowrelated #5104 (again); merging 5213 ;2x : window(timespan unit count) always emit empty observable if not reach max count;""this code will print nothing all the time```javapublishsubject<string> vehicletofetch  publishsubjectcreate()        vehicletofetch                delay(2timeunitseconds)                window(10 timeunitseconds 5)                observeon(schedulersio())                subscribe(w-> wtolist()subscribe(ws-> {                    wsforeach(v -> {                        systemoutprintln(stringformat(""""%s %d"""" v threadcurrentthread()getid()))                        vehicletofetchonnext(v)                    })                }))        observablejust(""""v1""""""""v2""""""""v3""""""""v4"""")                subscribe(v->{                    vehicletofetchonnext(v)                })```i am using rxjava:206"";""there are two problems with your code:- you are using `tolist` which requires a finite stream since you dont call `oncomplete` on `vehicletofetch` the sequence above wont print anything- you are probably not waiting long enough to see the results the default rxjava schedulers are daemon threads and when the """"main"""" thread ends the whole application stops```javapublishsubject<string> vehicletofetch  publishsubjectcreate()vehicletofetch        delay(2timeunitseconds)        window(10 timeunitseconds 5)        observeon(schedulersio())        subscribe(w-> wtolist()subscribe(ws-> {            wsforeach(v -> {                systemoutprintln(stringformat(""""%s %d"""" v threadcurrentthread()getid()))                vehicletofetchonnext(v)            })        }))observablejust(""""v1""""""""v2""""""""v3""""""""v4"""")subscribe(vehicletofetch)threadsleep(3000)``` || @akarnokd thanks  i am calling `tolist()` on a window observable not on `vehicletofetch` there is print if i change ` window(10 timeunitseconds 5)` to `window(10 timeunitseconds 4)`i am using a `countdownlatch`(not show in code) to wait a long time || yes because the window with limit 4 will call `oncomplete` for you on the window that `tolist()` consumes with 5 there is noone to call `oncomplete` if you had a """"v5"""" in that case youd see the printout again || why did it not call `oncomplete` when the timeout is reached?  does not this method mean either timeout or max count is reach will emit a window?  || oh i see it now there is a bug in the operator that doesnt complete the old window if a new one is due to the timeout ill post a fix for it || closing via #5106 || it  worked after upgrade to 207  but after three times timeout there is no timeout anymore || do you have a new unit test for it? || you can use the same code  it will block after three new window emitted || odd ill look into it again || found a couple of remaining issues see pr #5213 the example works with it properly for me || "";1;0;2x: fix window() with time+size emission problems;"
"5217;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;[2.x] unicastsubject fail fast support;this pr adds support for fail-fast behavior to  unicastsubject  with methods  unicastsubject<t> create(boolean delayerror)    unicastsubject<t> create(int capacityhint  runnable onterminated  boolean delayerror) .  relates to #5165;;5165.0;[2x] unicastsubject fail fast support;this pr adds support for fail-fast behavior to `unicastsubject` with methods `unicastsubject<t> create(boolean delayerror)` `unicastsubject<t> create(int capacityhint runnable onterminated boolean delayerror)`  relates to #5165; merging 5217 ;1x: unicastsubject does not replay onnext calls made prior to subscription if onerror is also called prior to subscription;""im using rxjava 125 consider this code:```java    unicastsubject<string> s  unicastsubjectcreate()    sonnext(""""1"""")    sonnext(""""2"""")    sonerror(new exception(""""uh oh""""))    ssubscribe(systemout::println systemout::println)```this outputs  uh ohhowever the same code using rxjava 207 version of `unicastsubject` outputs  uh ohwhich is the behavior i expected from 1x"";""hi in rxjava 1x the unicastsubject is fail-fast and in 2x it is delay-error currently there is no option for the other mode in either major version || @akarnokd ah i see thanks for the clarification is that documented somewhere that im missing? the unicastsubject docs for 1x gave me the impression that all events will get replayed once its subscribed to regardless of whether or not theres an error event i also didnt find it mentioned in the """"whats different in 20"""" wikialso i noticed you added the """"pr welcome"""" label - are you looking for prs that add a way to optionally (and not by default) switch to the currently unsupported mode for each major version? meaning add a way to delay-error on 1x and/or a way to fail-fast on 2x || > i also didnt find it mentioned in the """"whats different in 20"""" wikithis change was likely simply overlooked> added the """"pr welcome"""" labelyes keep the current defaults in each version and add two factory methods:```javapublic static <t> unicastsubject<t> create(boolean delayerror) {    // }public static <t> unicastsubject<t> create(int buffersize         runnable onterminate boolean delayerror) {    // }``` || @akarnokd got it  closing via #5195 #5217 and #5226 || "";1;0;follow up: add @since for new methods;"
5222;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: cleanup based on intellij 2017.1 inspections;this pr is the result of running intellij inspections on the code:;;0;2x: cleanup based on intellij 20171 inspections;this pr is the result of running intellij inspections on the code:  - replace `unsubscribe` with `cancel` and `dispose` in the main classes to better match the 2x terminology  - write out a couple of local variables  - remove unnecessary `return` and `continue` statements  - remove unnecessary variable writes  - remove unnecessary and unused fields  - add `final` to some fields  - fix typos; merging 5222 ;;;;1;1;restore indexed for-loop and make other loops indexed as well;
5223;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: improve the documentation of schedulers utility class.;this pr improves the javadoc of the  io.reactivex.schedulers.schedulers  utility class plus adds a missing  schedulersupport  constant for the  single()  scheduler.;;5145.0;2x: improve the documentation of schedulers utility class;this pr improves the javadoc of the `ioreactivexschedulersschedulers` utility class plus adds a missing `schedulersupport` constant for the `single()` schedulerlet me know if something needs further explanation (or some new case needs explanation)related: #5145; merging 5223 ;2x: improve ioreactivexschedulersschedulers documentation;-  better explain each scheduler type  -  repeat system parameters for each scheduler type  -  remove mentions of schedulerlifecycle  -  explain how `from` handles `executor` `executorservice` and `scheduledexecutorservice`  -  explain getting back to the current thread requires a blocking scheduler  -  mention the `schedulersupport` annotations;see #5223 || closing via #5223 ||;1;0;2x: improve the documentation of schedulers utility class;
"5225;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: fix completable.onerrorresumenext unsubscribe not propagated;the  completable.onerrorresumenext  did not properly propagate the downstream  unsubscribe()  call to upstream.;;5224.0;1x: fix completableonerrorresumenext unsubscribe not propagated;the `completableonerrorresumenext` did not properly propagate the downstream `unsubscribe()` call to upstreamreported in #5224; merging 5225 ;129: completable not unsubscribe with onerrorresumenext;""i have completable that contains `merge` or `andthen` then i add `onerrorresumenext` into sequence in this case if we unsubscribe the whole `subscription` when `com1` is not completed yet then `com2` wont be unsubscribedcode sample:```java        completable com1  completable                fromaction(() -> {                    try {                        threadsleep(3000)                    } catch (interruptedexception e) {                        eprintstacktrace()                    }                    logd(tag """"c1"""")                })                doonsubscribe(s1 -> logd(tag """"com1 subscribe""""))                doonunsubscribe(() -> logd(tag """"com1 unsubscribe""""))        completable com2  completable                fromaction(() -> {                    try {                        threadsleep(6000)                    } catch (interruptedexception e) {                        eprintstacktrace()                    }                    logd(tag """"c2"""")                })                doonsubscribe(s2 -> logd(tag """"com2 subscribe""""))                doonunsubscribe(() -> logd(tag """"com2 unsubscribe""""))        subscription subscription                 completablemerge(                        com1                        com2                )                        subscribeon(schedulersfrom(executorsnewsinglethreadexecutor()))                        onerrorresumenext(throwable ->                                completable                                        fromaction(() -> logd(tag """"error happened""""))                        )                        doonsubscribe(s -> logd(tag """"subscribe""""))                        doonunsubscribe(() -> logd(tag """"unsubscribe""""))                        subscribe(                                () -> logd(tag """"oncomplete """")                                throwable -> logd(tag """"onerror """" + throwable)                        )        completable                fromaction(() -> {                    subscriptionunsubscribe()                    logd(tag""""whole subscription unsubscribe"""")                })                delay(2 timeunitseconds)                subscribe()```result:```d: subscribed: com1 subscribed: whole subscription unsubscribed: c1d: com2 subscribed: c2d: oncomplete ```case without operator `onerrorresumenext` :```d: subscribed: com1 subscribed: unsubscribed: com1 unsubscribed: whole subscription unsubscribed: c1```"";closing via #5225 ||;1;0;1x: fix completableonerrorresumenext unsubscribe not propagated;"
"5226;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x unicastprocessor fail-fast support;this pr adds support for fail-fast behavior to  unicastprocessor  with methods  unicastprocessor<t> create(boolean delayerror)    unicastprocessor<t> create(int capacityhint  runnable onterminated  boolean delayerror) . relates to #5165  #5217;;5165.0;2x unicastprocessor fail-fast support;this pr adds support for fail-fast behavior to `unicastprocessor` with methods `unicastprocessor<t> create(boolean delayerror)` `unicastprocessor<t> create(int capacityhint runnable onterminated boolean delayerror)` relates to #5165 #5217; merging 5226 ;1x: unicastsubject does not replay onnext calls made prior to subscription if onerror is also called prior to subscription;""im using rxjava 125 consider this code:```java    unicastsubject<string> s  unicastsubjectcreate()    sonnext(""""1"""")    sonnext(""""2"""")    sonerror(new exception(""""uh oh""""))    ssubscribe(systemout::println systemout::println)```this outputs  uh ohhowever the same code using rxjava 207 version of `unicastsubject` outputs  uh ohwhich is the behavior i expected from 1x"";""hi in rxjava 1x the unicastsubject is fail-fast and in 2x it is delay-error currently there is no option for the other mode in either major version || @akarnokd ah i see thanks for the clarification is that documented somewhere that im missing? the unicastsubject docs for 1x gave me the impression that all events will get replayed once its subscribed to regardless of whether or not theres an error event i also didnt find it mentioned in the """"whats different in 20"""" wikialso i noticed you added the """"pr welcome"""" label - are you looking for prs that add a way to optionally (and not by default) switch to the currently unsupported mode for each major version? meaning add a way to delay-error on 1x and/or a way to fail-fast on 2x || > i also didnt find it mentioned in the """"whats different in 20"""" wikithis change was likely simply overlooked> added the """"pr welcome"""" labelyes keep the current defaults in each version and add two factory methods:```javapublic static <t> unicastsubject<t> create(boolean delayerror) {    // }public static <t> unicastsubject<t> create(int buffersize         runnable onterminate boolean delayerror) {    // }``` || @akarnokd got it  closing via #5195 #5217 and #5226 || "";1;0;follow-up: remove constructor add onterminate non-null checks to factory methods  typo;"
"5230;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix wrong comments in functions.java function3 -> bifunction;i m using this library in my company(kakaobank in korea) and interested in this library.. so i read whole code these days. i feel really thanks for all people who make awesome library and i just wanted to contribute this library.;;0;2x: fix wrong comments in functionsjava function3 -> bifunction;im using this library in my company(kakaobank in korea) and interested in this library so i read whole code these days i feel really thanks for all people who make awesome library and i just wanted to contribute this library; merging 5230  < ;;;;1;1;""add @suppresswarnings({""""unchecked"""" """"rawtypes""""}) into functions fail test"";"
5231;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;add timeunit null check test case in timed;1. it s about timed.java test case that is null check timeunit parameter.;;0;add timeunit null check test case in timed;1 its about timedjava test case that is null check timeunit parameter2 formatting in basicintqueuedisposable3 add testcase blockingiterablenegativebuffersizefail for blockingiterable4 modify blockingmultiobserver fields modfier; merging 5231 ;;;;1;1;remove no need annotation and variable;
5240;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix callbackcompletableobserver calling onerror  resourcex wording;this pr contains the fix for incorrect call of the  onerror  handler within  callbackcompletableobserver.oncomplete()  reported in [5099]( as well as wording fixes to the  resourcex  javadoc.;;0;2x: fix callbackcompletableobserver calling onerror resourcex wording;this pr contains the fix for incorrect call of the `onerror` handler within `callbackcompletableobserveroncomplete()` reported in [5099]( as well as wording fixes to the `resourcex` javadoc; merging 5240 ;;;;1;1;2x: fix callbackcompletableobserver calling onerror resourcex wording;
5247;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix flowable.tolist() onnext/cancel race;this pr fixes the  nullpointerexception  that can happen because  cancel  nulls out the value and  onnext  simply dereferences that value in  flowabletolist .;;5246.0;2x: fix flowabletolist() onnext/cancel race;this pr fixes the `nullpointerexception` that can happen because `cancel` nulls out the value and `onnext` simply dereferences that value in `flowabletolist`reported in #5246; merging 5247 ;2x: nullpointerexception in flowabletolist$tolistsubscriberonnext;notices few of this crashes is there any way to find from where they are coming?```fatal exception: javalangnullpointerexception: attempt to invoke interface method boolean javautilcollectionadd(javalangobject) on a null object reference       at ioreactivexinternaloperatorsflowableflowabletolist$tolistsubscriberonnext(flowabletolistjava:71)       at ioreactivexinternaloperatorsflowableflowablefilter$filtersubscribertryonnext(flowablefilterjava:73)       at ioreactivexinternaloperatorsflowableflowablefilter$filtersubscriberonnext(flowablefilterjava:51)       at ioreactivexinternaloperatorsflowableflowableconcatmap$concatmapimmediateinnernext(flowableconcatmapjava:215)       at ioreactivexinternaloperatorsflowableflowableconcatmap$concatmapinneronnext(flowableconcatmapjava:592)       at ioreactivexinternaloperatorsflowableflowablefromiterable$iteratorsubscriptionfastpath(flowablefromiterablejava:181)       at ioreactivexinternaloperatorsflowableflowablefromiterable$baserangesubscriptionrequest(flowablefromiterablejava:123)       at ioreactivexinternalsubscriptionssubscriptionarbitersetsubscription(subscriptionarbiterjava:96)       at ioreactivexinternaloperatorsflowableflowableconcatmap$concatmapinneronsubscribe(flowableconcatmapjava:585)       at ioreactivexinternaloperatorsflowableflowablefromiterablesubscribe(flowablefromiterablejava:69)       at ioreactivexinternaloperatorsflowableflowablefromiterablesubscribeactual(flowablefromiterablejava:47)       at ioreactivexflowablesubscribe(flowablejava:12901)       at ioreactivexinternaloperatorsflowableflowableconcatmap$concatmapimmediatedrain(flowableconcatmapjava:343)       at ioreactivexinternaloperatorsflowableflowableconcatmap$baseconcatmapsubscriberonnext(flowableconcatmapjava:158)       at ioreactivexinternaloperatorsflowableflowablesubscribeon$subscribeonsubscriberonnext(flowablesubscribeonjava:97)       at ioreactivexinternalsubscriptionsdeferredscalarsubscriptioncomplete(deferredscalarsubscriptionjava:133)       at ioreactivexinternaloperatorsflowableflowablefromcallablesubscribeactual(flowablefromcallablejava:44)       at ioreactivexflowablesubscribe(flowablejava:12901)       at ioreactivexinternaloperatorsflowableflowablesubscribeon$subscribeonsubscriberrun(flowablesubscribeonjava:82)       at ioreactivexinternalschedulersscheduledrunnablerun(scheduledrunnablejava:59)       at ioreactivexinternalschedulersscheduledrunnablecall(scheduledrunnablejava:51)       at javautilconcurrentfuturetaskrun(futuretaskjava:237)       at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:272)       at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1133)       at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:607)       at javalangthreadrun(threadjava:761)```;what version are you using? could you share some code? || version 206this is one of the examples```        flowable<list<team>> networktask  networkgetuiclient()getteams()                onerrorreturn(throwable -> new arraylist<>())                concatmap(flowable::fromiterable)                filter(team -> isvalid(team))                tolist()toflowable()``` || id guess `networkgetuiclient()getteams()` is a custom `publisher` of some sorts because that particular exception can only happen if there is an `onnext` after an `oncomplete` or `onerror` it would  be great if you could write a standalone unit test that reproduces the problem || behind ```networkgetuiclient()getteams()``` and every other network call is retrofit beside that we have few database calls wraped in ```flowablefromcallable(db::getteams)``` and no other custom ```publisher```we see bug happening in production but we cant reproduce it and stacktrace dont give to much informations from where is coming from (network api have ~50 endpoints)only thing that we know is that bug is affecting really small number of sessions || there is a small race window between an `onnext()` and a `cancel()` that could cause this ill post a fix for this || closing via #5247 ||;1;0;2x: fix flowabletolist() onnext/cancel race;
5250;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;defer creation of the timeoutexception when using the single.timeout() operator;use a defer instead of simply  other = single.error(new timeoutexception())  since instantiating an exception will cause the current stack trace to be inspected and that overhead should only be incurred when a timeout actually happens.;;0;defer creation of the timeoutexception when using the singletimeout() operator;use a defer instead of simply `other  singleerror(new timeoutexception())` since instantiating an exception will cause the current stack trace to be inspected and that overhead should only be incurred when a timeout actually happensi caught this problem as i was investigating unusually high cpu usage in one of the systems i operate when measuring the impact of this change in a real world situation that makes only moderate use of this operator i observed a *11%* reduction in cpu usage;please let me know if there is anything about this pr that needs to change in order to get this fix merged as the performance improvement seems to be reasonably significant  || is this also a problem without `timeout()` operators on other stream types? and also what about 2x? ||  merging 5250 ;;;;1;1;fix formatting;
5251;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;more nullability annotations;added nullability annotations to:;;0;more nullability annotations;added nullability annotations to:- disposables- observersand some others; merging 5251  < ;;;;1;1;changes based on akarnokds 2nd review;
5255;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;add nullpointerexception comments and objecthelper test code.;:);;0;add nullpointerexception comments and objecthelper test code;:); merging 5255  < ;;;;1;1;add test code for objecthelperjava;
5256;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix flatmapiterable appearing to be empty when fused;the wrong logical expression in the  isempty()  method made  flatmapiterable  complete earlier  even if data was available in the current iterable.;;0;2x: fix flatmapiterable appearing to be empty when fused;the wrong logical expression in the `isempty()` method made `flatmapiterable` complete earlier even if data was available in the current iterablesomewhat related:  (different logical bug in the same method); merging 5256 ;;;;1;1;2x: fix flatmapiterable appearing to be empty when fused;
5257;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove @nonnull annotations in biconsumer method parameter;this pr is part of https://github.com/reactivex/rxjava/issues/5216;;0;remove @nonnull annotations in biconsumer method parameter;this pr is part of  pr remove @nonnull annotations from ```biconsumer``` method parameters theres no sense use these annotations in ```single``` context because in this case ```biconsumer``` always brings you a null parameter; merging 5257 ;;;;1;1;remove @nonnull annotations in biconsumer;
"5258;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x use intellij ide friendly assertion failure message;the  assertitem  failure message pattern in  testsubscriber  does not match any of the regex patterns defined by intellij to show  <click to see difference>  link.;;5249.0;1x use intellij ide friendly assertion failure message;""the `assertitem` failure message pattern in `testsubscriber` does not match any of the regex patterns defined by intellij to show `<click to see difference>` link ![before]( changing the """"_expected to be_"""" to """"_expected:_"""" the pattern is recognised by intellij and the helpful link is presented![after]( original idea from #5249 was to use the """"_expected:<> but was:<>_"""" pattern used in junit but it is not picked up on its own by intellij the assertionerror must extend from junits comparisonfailure to get it recognised this however requires dependency on junit![junit]( in the end the fix is just a very simple change in the message""; merging 5258 ;1x 2x use ide friendly assertion failed statements;""currently the assertitem prints by the following statements focus on """"_expected to be_""private void assertitem(t expected int i) {        t actual  valuesget(i)        if (expected  null) {            // check for null equality            if (actual ! null) {                assertionerror(""""value at index: """" + i + """" expected to be [null] but was: ["""" + actual + """"]\n"""")            }        } else if (!expectedequals(actual)) {            assertionerror(""""value at index: """" + i                    + """" expected to be ["""" + expected + """"] ("""" + expectedgetclass()getsimplename()                    + """") but was: ["""" + actual + """"] ("""" + (actual ! null ? actualgetclass()getsimplename() : """"null"""") + """")\n"""")        }    }```however it does not match any of the intellij assertion regex patterns thus making it very difficult to visually compare expected and actual values we forked `assertitem()` using one of the following patterns from [this]( and could immediately see the `<click to see difference>` link in the ide"";""pr welcome || @mtiidla is 2x also affected? || @akarnokd could you please choose the most pleasing pattern from the intellij class i linked to? if you dont have any preference then i would go with expected_but_was_pattern as junit4 is using it `""""expected:<"""" + expected + """"> but was:<"""" + actual + """">""""`@vanniktech the output is different but also not recognized for example the following code:`observablejust(""""test"""")test()assertvalue(""""test"""")`produces: _expected: test (class: string) actual: test (class: string)_ and there is no link presented by intellij to compare the output (i have also edited the issue title with 2x) || the junit pattern is fine with me || "";1;0;fix test subscriber test case;"
5268;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: remove commented out code in ioscheduler;removes some code that was commented out in  ioscheduler . those lines were last edited in 2 years ago  so i assume they should be safe to delete.;;0;2x: remove commented out code in ioscheduler;removes some code that was commented out in `ioscheduler` those lines were last edited in 2 years ago so i assume they should be safe to delete; merging 5268 ;;;;1;1;remove commented out code from ioscheduler;
5271;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: enable link to external jdk  fix schedulers style;this pr enables the generated javadoc to  {@link }  to jdk classes properly (current 2.0.8 doc [shows them]( as plain text). i m linking to the v7 docs because v6 is ugly.;;0;2x: enable link to external jdk fix schedulers style;this pr enables the generated javadoc to `{@link }` to jdk classes properly (current 208 doc [shows them]( as plain text) im linking to the v7 docs because v6 is uglyin addition ive  the style of the `schedulers` documentation by separating the **supported system properties** properly into a new paragraph; merging 5271 ;;;;1;1;2x: enable link to external jdk fix schedulers style;
"5277;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: single.subscribe(biconsumer) consistent isdisposed;fixes the  single.subscribe(biconsumer)  to report  isdisposed  when terminating.;;5276.0;2x: singlesubscribe(biconsumer) consistent isdisposed;fixes the `singlesubscribe(biconsumer)` to report `isdisposed` when terminatingreported in #5276; merging 5277 ;singles disposable is not disposing;""i noticed that ```disposable``` returned from ```single::subscribe(final biconsumer<? super t ? super throwable> oncallback)``` returns ```false``` from ```disposable::isdisposed``` even after ```oncallback``` was called version of rxjava is 208 code sample:````import ioreactivexsingleimport ioreactivexdisposablesdisposableimport ioreactivexschedulersschedulersfun main(args: array<string>) {    var disposable: disposable?  null    disposable  singlejust(34)            subscribeon(schedulerscomputation())            observeon(schedulersio())            subscribe { item throwable ->                println(""""1 ${disposable?isdisposed}"""")            }    println(""""2 ${disposable?isdisposed}"""")    threadsleep(1000)    println(""""3 ${disposable?isdisposed}"""")}````output is:````2 false1 false3 false````"";thanks for reporting this is indeed an inconsistency with other methods see #5277 for the fix || closing via #5277 ||;1;0;2x: singlesubscribe(biconsumer) consistent isdisposed;"
5281;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: behaviorprocessor & subject terminate-subscribe race;this pr fixes the race condition in  behaviorprocessor  and  behaviorsubject  when  oncomplete()  or  onerror()  is called concurrently with  subscribe  and the consumer throws a  nullpointerexception  instead of relaying the terminal event.;;0;2x: behaviorprocessor & subject terminate-subscribe race;this pr fixes the race condition in `behaviorprocessor` and `behaviorsubject` when `oncomplete()` or `onerror()` is called concurrently with `subscribe` and the consumer throws a `nullpointerexception` instead of relaying the terminal eventthe fix involves having a separate `terminalevent` atomic field cas-ing in the actual or marker `throwable` and reading that field in `subscribe`; merging 5281 ;;;;1;1;use assertfailure;
5286;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: cleanup for text and javadoc 04/15;this pr;;0;2x: cleanup for text and javadoc 04/15;this pr - fixes a couple of documentation and message copy-paste errors-  flowableflatteniterable not checking for null returned  iterator::next()`- replace `publisher` with the appropriate name; merging 5286 ;;;;1;1;2x: cleanup for text and javadoc 04/15;
5287;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix flowable.flatmapmaybe/single maxconcurrency not requesting more;this pr fixes  flowable.flatmapmaybe  and  flowable.flatmapsingle  not replenishing from the upstream when they complete/error per inner source.;;0;2x: fix flowableflatmapmaybe/single maxconcurrency not requesting more;this pr fixes `flowableflatmapmaybe` and `flowableflatmapsingle` not replenishing from the upstream when they complete/error per inner source; merging 5287 ;;;;1;1;2x: fix flowableflatmapmaybe/single maxconcurrency not requesting more;
5288;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add/remove empty lines in connectableobservable and observable;**edit:**;;0;2x: add/remove empty lines in connectableobservable and observable;**edit:**this pr adds a newline to `connectableobservable` and removes one excess empty line from `observable`; merging 5288  < ;;;;1;1;less line of space;
"5296;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;improve doondispose javadoc;sorry for the earlier pr #5295 :/;;5283.0;improve doondispose javadoc;sorry for the earlier pr #5295 :/ this addresses the javadoc issues discussed in #5283- removes the note in `observabledoondispose` which claims its action would be called on terminal events- slightly adjusts the javadocs of the `maybe`/`single`/`completable` variants- adds `@throws` note to some `observable`/`single`/`maybe` `doondispose` as it was present in the `completable` variant; merging 5296 ;subscription not disposed after oncomplete with rxjava 2x;helloi am not sure this is an issue i would rather say this is a questioni have noticed a different behavior between rxjava 1x and rxjava 2xwhen an observable is completed with rxjava 1x subscriptions get unsubscribed:```behaviorsubject<object> subject  behaviorsubjectcreate()subscription subscription  subjectsubscribe()subjectoncompleted()systemoutprintln(subscriptionisunsubscribed()) // display true```however with rxjava2 the subscription is not disposed when the observable is completed:```disposable subscription  null@testpublic void test() {    behaviorsubject subject  behaviorsubjectcreate()    observer<? super string> observer  new observer<string>() {                public void onsubscribe(disposable d) {            subscription  d        }            }        subjectsubscribe(observer)    subjectoncomplete()    systemoutprintln(subscriptionisdisposed())  // display false}```is it a wanted behavior? if so is this behavior documented somewhere?thanks a lot for your help;""generally if you dont dispose a disposable received via `onsubscribe` it may or may not report itself as disposed the lambda version of the `subscribe()` does report itself disposed when it  calls the lambda for a terminal eventin practice there shouldnt be any reason to call `isdisposed` outside an operator or `create` method because it assumes synchronous termination or worse it is the reactive version of `futureget()`in the reactive world you react to termination via the appropriate onxxx method compose in the continuation or simply side-effect via `dofinally`*sidenote: one of the smaller but ever growing regret of mine is that i let `isdisposed` into the api because i knew that will eventually trigger a bunch of inconsistency bug reports and correcting them adds more overhead im glad the reactive-streams specification opted for no `iscancelled` method* || thanks a lot for your """"reactivity"""" and your explanations!i agree that *iscancelled* is less misleading i have the feeling that i am not the only being confused:    || related question: `observabledoondispose()` javadoc mentions the following:`""""note that terminal events trigger the action unless the {@code observablesource} is subscribed to via {@code unsafesubscribe()}""""`is this still true or should `dofinally()`/`doonterminate()` be the preferred option? || thats no longer true the preferred operator is `dofinally` as it covers `onerror` `oncomplete` and `dispose` as wellwould you like to post a pr that removes that note? if so please check the other base types for the equivalent operator as there might be copy-pasted all over the place || okay thanks for clarifying i can update the javadoc note later today || "";1;0;add @throws mentions to doondisposed javadocs;"
"5296;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;improve doondispose javadoc;sorry for the earlier pr #5295 :/;;5295.0;improve doondispose javadoc;sorry for the earlier pr #5295 :/ this addresses the javadoc issues discussed in #5283- removes the note in `observabledoondispose` which claims its action would be called on terminal events- slightly adjusts the javadocs of the `maybe`/`single`/`completable` variants- adds `@throws` note to some `observable`/`single`/`maybe` `doondispose` as it was present in the `completable` variant; merging 5296 ;xmr/do on dispose javadoc;""thank you for contributing to rxjava before pressing the """"create pull request"""" button please consider the following points:  -  please give a description about what and why you are contributing even if its trivial  -  please include the issue list number(s) or other pr numbers in the description if you are contributing in response to those  -  please include a reasonable set of unit tests if you contribute new code or change an existing one if you contribute an operator (if applicable) please make sure you have tests for working with an `empty` `just` `range` of values as well as an `error` source with and/or without backpressure and see if unsubscription/cancellation propagates correctly""; merging 5295  < ;1;0;add @throws mentions to doondisposed javadocs;"
5297;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix javadoc image for single#flatmapobservable;[ single.flatmapobservable.png ]( should be used for  single#flatmapobservable  instead of [ single.flatmap.png ](https://raw.github.com/wiki/reactivex/rxjava/images/rx-operators/single.flatmap.png).;;0;fix javadoc image for single#flatmapobservable;[`singleflatmapobservablepng`]( should be used for `single#flatmapobservable` instead of [`singleflatmappng`](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleflatmappng); merging 5297 ;;;;1;1;fix javadoc image for single#flatmapobservable`singleflatmapobservablepng` should be used for `single#flatmapobservable` instead of `singleflatmappng`;
"5301;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: more detailed no-multi-subscribe with std consumers error message;this pr changes the  disposable already set!  and  subscription already set!  messages on the standard consumer classes ( disposablesubscriber    disposableobserver   etc.) to something more meaningful:;;0;2x: more detailed no-multi-subscribe with std consumers error message;""this pr changes the """"disposable already set!"""" and """"subscription already set!"""" messages on the standard consumer classes (`disposablesubscriber` `disposableobserver` etc) to something more meaningful:""""it is not allowed to subscribe with a(n) `<class name>` multiple times please create a fresh instance of `<class name>` and subscribe that to the target source instead""""where `<class name>` is a placeholder for the `getclass()getname()` of the subclass of those consumer types it should clearly state to avoid subscribing with them multiple times as well as printing the full class name to indicate the problem is with the use of the implementor class and not with the abstract rxjava classinspired by [this stackoverflow]( question one of many such questionsfor the internal operators the original error message stays because when they appear that is still likely due to an implementation bug (or a misbehaving user-created custom implementation)""; merging 5301 ;;;;1;1;improve coverage of the new content;"
5302;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add single.unsubscribeon();this pr adds the  single.unsubscribeon()  operator.;;5300.0;2x: add singleunsubscribeon();this pr adds the `singleunsubscribeon()` operatorrelated: #5300; merging 5302 ;2x single unsubscribeon missing;also in order to match 2x naming convertions that operator should be named `disposeon`;indeed that operator is missing from `single` and available on the other types would you like to convert closest `maybeunsubscribeon` over to it in a pr?it is called `unsubscribeon` for historical reasons and - to pair up with `subscribeon`- to have the same name across the types instead of `disposeon` and `cancelon``unsubscribeon` is the name of (concept of) the operation whereas `dooncancel` and `doondispose` represent the signal types and appropriate method names within the api and as such were adjusted || thanks for fast feedback and explanationabout pr: yes i can do ithowever im not too experienced programmer and cant promise anything about code quality and time || oh i understand a certain code quality is expected here plus rxjava 209 is scheduled to be released tomorrow ill do the pr then in a few hours || looks not too complicated can you give me 2-3 hours?  || ive done it for exercise see if you can do it yourself and compare it against #5302 to verify your approach ||  done it same way but without testing (oh its hardest thing to prove that my code works as expected) ||;1;0;fix experimental marker location;
5304;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;correct documented return type of single#flatmapobservable function argument;the argument of  single#flatmapobservable  clearly states that it is expecting a  function  which returns an  observablesource  but the documentation contradicts that.;;0;correct documented return type of single#flatmapobservable function argument;the argument of `single#flatmapobservable` clearly states that it is expecting a `function` which returns an `observablesource` but the documentation contradicts that;  merging 5304 ;;;;1;1;correct documented return type of single#flatmapobservable function argument;
5306;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: change observablesource.defer to observable.defer in observable.scan() documentation.;- changes  observablesource.defer  to  observable.defer();;0;2x: change observablesourcedefer to observabledefer in observablescan() documentation;- changes `observablesourcedefer` to `observabledefer()`; merging 5306 ;;;;1;1;2x: change observablesourcedefer to observabledefer in observablescan() documentation;
5307;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: apply promotions for v2.1;this pr applies the promotions listed in #5243.;;5243.0;2x: apply promotions for v21;this pr applies the promotions listed in #5243suggested review strategy:- check if the `@experimental` annotation has been removed or turned into `@beta`- check if the `<p>history: 20x` matches the original value of the updated `@since 20x`; merging 5307 ;21 api promotions;planned release date: **april 29 2017**### experimental to standard- `checkreturnvalue` (since 202)- `schedulerwhen()` (since 201)- `completablesubject` (since 205)- `maybesubject` (since 205)- `singlesubject` (since 205)- `testsubscriberrequestmore()` (since 201)#### `completable`- `cache()` (since 204)- `dofinally()` (since 201)- `hide()` (since 205)#### `flowable`- `doafternext()` (since 201)- `dofinally()` (since 201)- `sample()` with emitlast option (since 205)#### `maybe`- `doaftersuccess()` (since 201)- `dofinally()` (since 201)- `flatmapsingleelement()` (since 202)#### `observable`- `doafternext()` (since 201)- `dofinally()` (since 201)- `sample()` with emitlast option (since 205)#### `single`- `doaftersuccess()` (since 201)- `doafterterminate()` (since 206)- `dofinally()` (since 201)#### `basetestconsumer`- `assertnever()` (since 205) 2 overloads- `assertnotimeout()` (since 207)- `asserttimeout()` (since 207)- `awaitcount()` (since 207) 3 overloads- `cleartimeout()` (since 207)- `istimeout()` (since 207)- `testwaitstrategy` (since 207)- `withtag()` (since 207)#### `rxjavaplugins`- `createcomputationscheduler()` (since 205)- `createioscheduler()` (since 205)- `createnewthreadscheduler()` (since 205)- `createsinglescheduler()` (since 205)- `getonbeforeblocking()` (since 205)- `isfailonblockingscheduler()` (since 205)- `onbeforeblocking` (since 205)- `setfailonblockingscheduler()` (since 205)- `setonbeforeblocking()` (since 205)### beta to standardthere are no components marked with `@beta` in the 20x version additions### experimental to beta- `flowablesubscriber` (since 207)- `flowableparallel()` (since 205) 3 overloads- `flowablesubscribe(flowablesubscriber)` (since 207)- `onerrornotimplementedexception` (since 206)- `protocolviolationexception` (since 206)- `undeliverableexception` (since 206)- `parallelflowable` (since 205)- `rxjavapluginsgetonparallelassembly()` (since 206)- `rxjavapluginsonassembly(parallelflowable)` (since 206)- `rxjavapluginssetonparallelassembly()` (since 206)### leave as is- `observableswitchmapsingle()` (since 208 - experimental)- `observableswitchmapsingledelayerror()` (since 208 - experimental)- `parallelfailurehandling` (since 208 - experimental)- `parallelflowabledoonnext(consumer parallelfailurehandling)` (since 208 - experimental)- `parallelflowablemap(consumer parallelfailurehandling)` (since 208 - experimental)-` parallelflowablefilter(consumer parallelfailurehandling)` (since 208 - experimental)- `paralleltransformer` (since 208 - experimental)- `behaviorprocessoroffer()` (since 208 - experimental)- `publishprocessoroffer()` (since 208 - experimental)- `unicastprocessorcreate(boolean)` (since 208 -experimental) 2 overloads of fail-fast mode- `unicastsubjectcreate(boolean)` (since 208 -experimental) 2 overloads of fail-fast mode- `singleunsubscribeon(scheduler)` (since 209 - experimental)### remove`flowablestrict()` (since 205 deprecated in 207);what about the `@checkreturnvalue` annotation? right now its experimental || thanks added to the experimental -> standard section || id like to define what should happen with the `@since` tags and the old version number:- the standard promotions will be updated to `@since 21`- the experimental-beta promotions will be updated to `@since 21 - beta`- the previous version value will be moved into just before the first param or return tag:```java/** * the operator  * <p>history: 206 - experimental * @param x  * @since 21 */@checkreturnvaluepublic final flowable<r> operator()```this small addendum should help quickly pinpoint when certain features were added and were promoted without the need to scan through release logs commits and prs || closing via #5307 ||;1;0;2x: apply promotions for v21;
5309;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix javadoc of flowable.toobservable;the  flowable.toobservable()  javadoc was referring to  publisher  instead of  observable .;;0;2x: fix javadoc of flowabletoobservable;the `flowabletoobservable()` javadoc was referring to `publisher` instead of `observable`; merging 5309 ;;;;1;1;2x: fix javadoc of flowabletoobservable;
5310;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: improve coverage of some classes (no functional changes);improve the coverage of some classes  plus re-add the unit test that validates the  strictsubscriber .;;0;2x: improve coverage of some classes (no functional changes);improve the coverage of some classes plus re-add the unit test that validates the `strictsubscriber`only test changes no functional changes; merging 5310 ;;;;1;1;2x: improve coverage of some classes (no functional changes);
5318;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: apply api promotions for 1.3;this pr applies the api promotions of #5201.;;5201.0;1x: apply api promotions for 13;this pr applies the api promotions of #5201note that `singleunsubscribeon` remainded experimental and `observablefromemitter` was removedwhere the experimental version was available it was moved up as `<p>history: 1xy - experimental` similar to how 2x versioning/promotions happensuggested review strategy:- verify `@experimental` and `@beta` annotations are removed from the method and from javadoc- verify `@since 13` is present; merging 5318 ;13 api promotions;planned release date for 13: **may 1st 2017**### promote `experimental` to stable:- `rxexceptionsassemblystacktraceexception`- `rxfunctionscancellable`- `rxinternalobserversassertablesubscriberobservable`- `rxinternaloperatorsflatmapcompletable`- `rxinternaloperatorsflatmapsingle`- `rxinternalschedulersschedulerwhen`- `rxinternalutilbackpressuredrainmanager`- `rxinternalutilblockingutils` (the class and its single method)- `rxcompletablefromemitter()`- `rxcompletabletest()`- `rxcompletableemitter`- `rxcompletablesubscriber`- `rxemitter`- `rxschedulerwhen()`- `rxsingleemitter`- `rxsinglefromemitter`- `rxsinglemerge(observable<single<t>>)` (2 overloads)- `rxsinglemergedelayerror(observable<single<t>>)` (2 overloads)- `rxsinglecache()`- `rxsingleto()`- `rxsingledooneach()`- `rxsingledoonsuccess()`- `rxsingletest()`- `rxobserversassertablesubscriber`- `rxobserversasynccompletablesubscriber`- `rxobserverssafecompletablesubscriber`- `rxobserverstestsubscribergetcompletions()`- `rxobserverstestsubscriberawaitvaluecount()`- `rxobserverstestsubscriberassertvaluesandclear()`- `rxschedulersschedulersreset()`- `rxpluginsrxjavacompletableexecutionhook`- `rxpluginsrxjavahooks`- `rxpluginsrxjavapluginsreset()`- `rxpluginsrxjavapluginsgetcompletableexecutionhook()`- `rxpluginsrxjavapluginsregistercompletableexecutionhook()`- `rxpluginsrxjavaschedulershookcreatecomputationscheduler()` (2 overloads)- `rxpluginsrxjavaschedulershookcreateioscheduler()` (2 overloads)- `rxpluginsrxjavaschedulershookcreatenewthreadscheduler()` (2 overloads)- `rxsubjectsunicastsubject`- `rxobservablecreate(action1<emitter<t>> emitterbackpressurestrategy)`- `rxobservableunsafecreate()`- `rxobservableto()`- `rxobservablezip(observable funcn)`- `rxobservableflatmapcompletable()` (3 overloads)- `rxobservableflatmapsingle()` (3 overloads)- `rxobservablegroupby(func1 func1 func1<action1<k> map<k object>>)`- `rxobservableonterminatedetach()`- `rxobservablerebatchrequests()`- `rxobservablesubscribeon(scheduler boolean)`- `rxobservablesorted()`- `rxobservablesorted(func2)`- `rxobservablewithlatestfrom()` (10 overloads)- `rxobservabletest()` (2 overloads)### promote `beta` to stable:- `rxobservableblockingobservablesubscribe()` (6 overloads)- `rxexceptionscompositeexception(throwable)`- `rxexceptionsexceptionsthroworreport()` (4 overloads)- `rxbackpressureoverflow`- `rxsingleonerrorresumenext()` (3 overloads)- `rxsingletocompletable()`- `rxsingledoonerror()`- `rxsingledoonsubscribe()`- `rxsingledelay()` (2 overloads)- `rxsingledefer()`- `rxsingledoonunsubscribe()`- `rxsingledoafterterminate()`- `rxsingleflatmapcompletable()`- `rxsinglelift()`- `rxsingletoblocking()`- `rxsingleusing()` (2 overloads)- `rxsingledelaysubscription(observable)`- `rxpluginsrxjavaerrorhandlerhandleonnextvaluerendering()`- `rxpluginsrxjavaerrorhandlerrender()`- `rxsinglesblockingsingle`- `rxobservabletocompletable()`- `rxobservableconcatdelayerror()` (10 overloads)- `rxobservablemergedelayerror()`- `rxobservableswitchonnextdelayerror()`- `rxobservableusing(func0 func1 action1 boolean)`- `rxobservableconcatmapdelayerror()`- `rxobservabledelaysubscription(observable)`- `rxobservabledistinctuntilchanged(func2)`- `rxobservableconcateager()` (12 overloads)- `rxobservableconcatmapeager()` (3 overloads)- `rxobservableonbackpressurebuffer(long action0 backpressureoverflowstrategy)`- `rxobservableswitchmapdelayerror()`- `rxobservabletosortedlist(int)`- `rxobservabletosortedlist(func2 int)`- `rxobservablessynconsubscribecreatesinglestate()` (2 overloads)- `rxobservablessynconsubscribecreatestateful()` (2 overloads)- `rxobservablessynconsubscribecreatestateless()` (2 overloads)- `rxcompletable`### promote `experimental` to `beta`- `rxobservableasynconsubscribe` (+ 7 of its factory methods)- `rxobservablecreate(asynconsubscribe<s t>)`### leave as is- `rxsingleunsubscribeon` (since 128)### remove `experimental`- `rxobservablefromemitter()`;closing via #5318 ||;1;0;fix typos;
5324;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;mark volatilesizearraylist as randomaccess list;this is needed for generic functions to select appropriate algorithm when searching etc.;;0;mark volatilesizearraylist as randomaccess list;this is needed for generic functions to select appropriate algorithm when searching etcdetails are in randomaccess interface javadoc; merging 5324 ;;;;1;1;mark volatilesizearraylist as randomaccess list;
5343;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix javadoc for maybe.tosingle;the javadoc for the  maybe.tosingle()  overload that accepts a  defaultvalue  incorrectly states that it will convert an empty  maybe  into a  single  that signals  nosuchelementexception  (likely copied from the version of  maybe.tosingle()  that does not accept a default value).;;0;fix javadoc for maybetosingle;the javadoc for the `maybetosingle()` overload that accepts a `defaultvalue` incorrectly states that it will convert an empty `maybe` into a `single` that signals `nosuchelementexception` (likely copied from the version of `maybetosingle()` that does not accept a default value)this change updates the javadoc to indicate that the returned `single` will emit `defaultvalue` if called on an empty `maybe`relevant existing test: https://githubcom/reactivex/rxjava/blob/8819cc933e26449751535bc48ba2f10852c9b96d/src/test/java/io/reactivex/maybe/maybetestjava#l2730; merging 5343 ;;;;1;1;fix javadoc for maybetosingle;
5344;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add tryonerror to create/xemitter api;this pr adds the  tryonerror  method to the various  emitter  types used in the  create  operators that allows the developer to avoid the  undeliverableexception  in case a cancellation is racing with the emission of an error. the return value indicates a success of the delivery  in case of  false   the developer can decide to log/drop the specific error if that makes sense for him/her.;;0;2x: add tryonerror to create/xemitter api;this pr adds the `tryonerror` method to the various `emitter` types used in the `create` operators that allows the developer to avoid the `undeliverableexception` in case a cancellation is racing with the emission of an error the return value indicates a success of the delivery in case of `false` the developer can decide to log/drop the specific error if that makes sense for him/her; merging 5344 ;;;;1;1;fix indentation;
5347;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix javadoc of functionx;fix the mistake for   functionx  javadoc;;0;2x: fix javadoc of functionx;fix the mistake for  `functionx` javadoc; merging 5347 ;;;;1;1;fix javadoc for functionx;
5351;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: update some marbles of observable;update/fix to a couple of marble diagrams in  observable :;;0;2x: update some marbles of observable;update/fix to a couple of marble diagrams in `observable`:- `singleorerror`: [reuse existing]( `combinelatestdelayerror`: [reuse existing]( `concatarrayeager`: [new diagram]( `erro`r: [new diagrams]( `fromfuture`: [new diagrams]( `fromiterable`: [new diagram](https://githubcom/reactivex/rxjava/issues/5319#issuecomment-302054967); merging 5351 ;;;;1;1;2x: update some marbles of observable;
5354;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix typo in error message.;when  basetestconsumer  receives fewer items than expected  the error shown has a typo. replaced *fever* with *fewer*.;;0;2x: fix typo in error message;when `basetestconsumer` receives fewer items than expected the error shown has a typo replaced *fever* with *fewer*;you are supposed to replace the intro text with the description of your pr || done thank you for the info ||  merging 5354 ;;;;1;1;2x: fix typo in error message;
"5367;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: make sure interval+trampoline can be stopped;this pr fixes the case where a  trampoline  scheduler is used with the  interval  or  intervalrange  operator  the periodic emissions can t be cancelled properly. the synchronous and blocking nature of the periodic schedule is that the  disposable  is never connected with the downstream and the  interval  stays in a drain-sleep loop per emission indefinitely.;;0;2x: make sure interval+trampoline can be stopped;""this pr fixes the case where a `trampoline` scheduler is used with the `interval` or `intervalrange` operator the periodic emissions cant be cancelled properly the synchronous and blocking nature of the periodic schedule is that the `disposable` is never connected with the downstream and the `interval` stays in a drain-sleep loop per emission indefinitelythis pr changes the operators to use the `worker` of a trampoline scheduler that is available before the drain-sleep loop thus a downstream cancellation can stop the loop any other """"async"""" scheduler will still use the direct periodic scheduling facilityin addition the trampoline loop has been  to check for the worker `disposed` state in the inner loop""; merging 5367 ;;;;1;1;2x: make sure interval+trampoline can be stopped;"
"5378;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: make singlemap not allow map function return null;found code like below can works;;0;2x: make singlemap not allow map function return null;""found code like below can works```singlejust(""""1234"""")map(s -> null)              subscribe(s -> {                  systemoutprintln(s)              })```because single#just not allow null so prevent mapper return null""; merging 5378 ;;;;1;1;2x: make singlemap not allow map function return null;"
5379;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add missing null checks on values returned by user functions;this pr adds null checks to places where it was missing.;;0;2x: add missing null checks on values returned by user functions;this pr adds null checks to places where it was missingin addition the `xmapnotification` operators now report a composite exception of the original `throwable` and the error thrown by the function that should return the continuation sourcealso  `testsubscriber`/`testobserver` not cancelling the sequence if the fused poll crashed; merging 5379 ;;;;1;1;2x: add missing null checks on values returned by user functions;
5383;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fixed javadoc for singleflatmapiterableobservable.;fixed javadoc for  singleflatmapiterableobservable .;;0; javadoc for singleflatmapiterableobservable; javadoc for `singleflatmapiterableobservable`; merging 5383  < ;;;;1;1; javadoc for singleflatmapiterableobservable;
5386;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add subscribeon overload to avoid same-pool deadlock with create;this pr adds an overload to  subscribeon  that exposes the existing feature to optionally request on the same scheduler where the subscription happened. this is necessary to avoid same-pool deadlock when the upstream contains  create  logic that blocks the emission thread  preventing any scheduled request to get through and leading to excess buffering or dropping data excessively. by not scheduling the request  it can directly update the emitter s request tracking and let the emitter continue.;;0;2x: add subscribeon overload to avoid same-pool deadlock with create;this pr adds an overload to `subscribeon` that exposes the existing feature to optionally request on the same scheduler where the subscription happened this is necessary to avoid same-pool deadlock when the upstream contains `create` logic that blocks the emission thread preventing any scheduled request to get through and leading to excess buffering or dropping data excessively by not scheduling the request it can directly update the emitters request tracking and let the emitter continueformerly the existing `subscribeon` automatically disabled scheduling the requests if the immediate upstream was a `flowablecreate` however if there were operators between `create` and `subscribeon` (as often happening on android with composing the schedulers at the end of the chain) the `subscribeon` operator run in scheduled request mode by default this change allows specifying this behavior through the new overload and thus distance between the `create` and `subscribeon` operators no longer matters(note that 1x already has this overload); merging 5386 ;;;;1;1;2x: add subscribeon overload to avoid same-pool deadlock with create;
5391;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;changed minimum value of rx2.buffer-size to 1;before the minimum value you could set with the system variable  rx2.buffer-size  was 16. with this commit  that is changed to 1.;;0;changed minimum value of rx2buffer-size to 1;before the minimum value you could set with the system variable `rx2buffer-size` was 16 with this commit that is changed to 1; merging 5391 ;;;;1;1;changed minimum value of rx2buffer-size to 1before the minimum value you could set with the system variable `rx2buffer-size` was 16 with this commit that is changed to 1;
5403;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix documentation of single.doafterterminate.;fix the copy-paste error in the javadoc of  single.doafterteminate  mentioning  doaftersuccess .;;0;2x: fix documentation of singledoafterterminate;fix the copy-paste error in the javadoc of `singledoafterteminate` mentioning `doaftersuccess`;ive updated the prs description please next time dont leave the welcome message in thereotherwise   merging 5403  < ;;;;1;1;fix documentation;
5405;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;defaultobserver javadoc example fix;the example in the javadoc of  defaultobserver  is not compiling   defaultobserver  is not a  disposable .;;0;defaultobserver javadoc example fix;the example in the javadoc of `defaultobserver` is not compiling `defaultobserver` is not a `disposable` this pr updates the javadoc to provide a compiling example; merging 5405 ;;;;1;1;defaultobserver javadoc fix: use subscribe remove disposable code;
5406;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix javadoc for observable.reduce() and observable.reducewith();the sample code given in the javadoc for  observable.reduce()  isn t compiling  since the function returns a  single .;;0;fix javadoc for observablereduce() and observablereducewith();the sample code given in the javadoc for `observablereduce()` isnt compiling since the function returns a `single` this pr changes it to a compiling example it also updates the javadoc for `reducewith()` to better match its actual behaviour*remark*im not sure whether the sample code for `reduce()` is needed at all the problem that it addresses might be solved better by using `reducewith()` imho*update*- similar changes applied to `flowablereduce()` and `flowablereducewith()`;could you also fix flowables javadoc? || @akarnokd donewhat do you think about referring to `reducewith()` instead of giving the example that uses `defer()`?   || the `defer` example should stay but you can add `@see` and a 3rd example || updated according to the feedback || great! ||    no coverage uploaded for pull request base (`2x@c11f715`) [click here to learn what that means]( `n/a`(                                  2x    #5406   +/-   ##  coverage       ?   9619%             complexity     ?     5789             files          ?      630  ?    41197     ?     5728             hits           ?    39629             misses         ?      605             partials       ?      963```| [impacted files]( | coverage  | complexity  | ||---|---|---|---|| [src/main/java/io/reactivex/observablejava]( | `100% <> ()` | `506 <0> (?)` | || [src/main/java/io/reactivex/flowablejava]( | `100% <> ()` | `523 <0> (?)` | |------[continue to review full report at codecov]( **legend** - [click here to learn more]( `  absolute <relative> (impact)` `  not affected` `?  missing data`> ( last update [c11f7156757548]( read the [comment docs]( ||;;;;1;1;add @see reducewith() to reduce();
5407;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;defaultsubscriber javadoc sample fix;the example in the javadoc of  defaultsubscriber  is not compiling   defaultsubscriber  is not a  disposable .;;0;defaultsubscriber javadoc sample fix;the example in the javadoc of `defaultsubscriber` is not compiling `defaultsubscriber` is not a `disposable` this pr updates the javadoc to provide a compiling examplefix is similar to #5405 for `defaultobserver`;   no coverage uploaded for pull request base (`2x@c11f715`) [click here to learn what that means]( `n/a`(                                  2x    #5407   +/-   ##  coverage       ?   9616%             complexity     ?     5785             files          ?      630  ?    41197     ?     5728             hits           ?    39618             misses         ?      620             partials       ?      959```| [impacted files]( | coverage  | complexity  | ||---|---|---|---|| [va/io/reactivex/subscribers/defaultsubscriberjava]( | `100% <> ()` | `7 <0> (?)` | |------[continue to review full report at codecov]( **legend** - [click here to learn more]( `  absolute <relative> (impact)` `  not affected` `?  missing data`> ( last update [c11f715f0e70bc]( read the [comment docs]( ||;;;;1;1;fix: remove assignment;
5409;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;#5382 corrected single.delay documentation;corrected single.delay documentation that says that success or error signals will be delayed by the specified amount  but in fact errors are not delayed  only successes.;;5382.0;#5382 corrected singledelay documentation;corrected singledelay documentation that says that success or error signals will be delayed by the specified amount but in fact errors are not delayed only successes;;2x singledelay documentation and implementation inconsistent;the documentation for singledelay says that success or error signals will be delayed by the specified amount but in fact errors are not delayed only successes i have no opinion on which one should be correct - i ran into it when mocking out the response for an incomplete backend to test a loading/error ui eg `singleerror()delay(3 timeunitseconds)` and found that my errors never had a delay it seems that observable has both options with a version of the method that has a boolean flag `delayerror`https://githubcom/reactivex/rxjava/blob/2x/src/main/java/io/reactivex/singlejava#l1636https://githubcom/reactivex/rxjava/blob/2x/src/main/java/io/reactivex/internal/operators/single/singledelayjava#l66;indeed there is no option for that in `single` and `maybe` would you like to submit a pr? || @akarnokd : ive submitted my first pr fixing this ->  kindly review and advice  closing via #5409 ||;1;0;#5382 corrected singledelay documentationcorrected singledelay documentation that says that success or error signals will be delayed by the specified amount but in fact errors are not delayed only successes;
5413;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add empty source clauses to javadocs of combinelatest operators ;accepting unspecified number of sources. this commit 5412;;0;2x: add empty source clauses to javadocs of combinelatest operators ;accepting unspecified number of sources this commit 5412;are you going to update this pr based on the feedback? || argh totally forgot about it sorry i will update it ||;;;;1;1;2x: add empty source clauses to javadocs of combinelatest operators accepting unspecified number of sources this commit 5412;
5415;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix doonnext failure not triggering doonerror when fused;this pr fixes an issue when in a fused chain of  doonnext  and  doonerror  the  doonnext  function fails  the  doonerror  consumer is not called.;;0;2x: fix doonnext failure not triggering doonerror when fused;this pr fixes an issue when in a fused chain of `doonnext` and `doonerror` the `doonnext` function fails the `doonerror` consumer is not calledoriginally reported in reactor-core: https://githubcom/reactor/reactor-core/issues/664; merging 5415 ;;;;1;1;remove whitespace;
"5419;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix periodic scheduling with negative period causing iae;this pr adds unit tests to verify the  scheduler.scheduleperiodicallydirect  and  scheduler.worker.scheduleperiodically  works with non-positive period as required by the javadoc.;;5416.0;2x: fix periodic scheduling with negative period causing iae;this pr adds unit tests to verify the `schedulerscheduleperiodicallydirect` and `schedulerworkerscheduleperiodically` works with non-positive period as required by the javadoc the `computation` and `single` schedulers were not working properly and the underlying `scheduledexecutorservice` crashed with `illegalargumentexception` thus these are now  with custom handler for the `period < 0l` casesrelated: #5416;;2x: scheduleperiodically with non-positive period;""currently the `scheduler` and `worker` api allows for non-positive periods on periodically scheduling but the underlying `scheduledexecutorservice`s dont the javadoc doesnt specify any restrictions on period unlike `initialdelay` or `delay` where a non-positive value is considered to be an """"execute without delay""""in theory the default periodic logic could handle the case by executing such periodic tasks without any delay but im not certain the behavior is actually desiredrelated stackoverflow question:  the tw options i see are as follows:1 throw iae with non-positive periods with the related operators and require the scheduler/worker api to do the same2 allow 0 period and introduce workarounds inside the scheduler/worker implementationsi prefer option 1 as nobody seem to have encountered this specific issue before that would have rendered the code inoperable anyway due to a crash similar to the so case"";it looks like the `schedulerworkerscheduleperiodically` javadoc does specify the behavior for non-positive values:>          * note to implementors: non-positive {@code initialtime} and {@code period} should be regarded as>          * non-delayed scheduling of the first and any subsequent executions>          * @param period>          *            the time interval to wait each time in between executing the action non-positive values>          *            indicate no delay between repeated schedulesso in the case of the linked stackoverflow question its `newthreadworker` not following the contract specified by the javadoc in addition there is the question whether the contract for `schedulerscheduleperiodicallydirect` should be the same as `schdulerworkerscheduleperiodically`the question then becomes either changing the contract for option 1 or more extensive testing of existing schedulers for option 2 || thanks for your findings if it says in the javadoc then the schedulers should honor it ill prepare a pr that fixes and checks for such behavior || closing via #5419 ||;1;0;merge branch 2x into schedulerperiodnonpositive;"
5421;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: attempt to fix a few time-sensitive tests.;as of lately  the travis ci runs much slower than usual and causes some time-sensitive tests to fail for some reason. this pr tries to figure out why this happens.;;0;2x: attempt to fix a few time-sensitive tests;as of lately the travis ci runs much slower than usual and causes some time-sensitive tests to fail for some reason this pr tries to figure out why this happens; merging 5421  < ;;;;1;1;add more time to a merge test always cancel;
5422;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: more eager cancellation in flatmapx;the flatmapx tests kept failing because there was a race between the cancellation and the disposing of their inner set: the cancel may have interrupted the test wait and ended up in the inner subscribe before  set.isdisposed()  would become true in the  dispose()  call of the operator that run on the main thread. the change adds/uses a boolean field that gets set first and is checked before the inner are subscribed.;;0;2x: more eager cancellation in flatmapx;the flatmapx tests kept failing because there was a race between the cancellation and the disposing of their inner set: the cancel may have interrupted the test wait and ended up in the inner subscribe before `setisdisposed()` would become true in the `dispose()` call of the operator that run on the main thread the change adds/uses a boolean field that gets set first and is checked before the inner are subscribed; merging 5422 ;;;;1;1;add more eager check to observableflatmapx;
5427;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix buffer(time  maxsize) duplicating buffers on time-size race;the pr fixes both the time+maxsize bound  buffer  operators of  flowable  and  observable . the logic didn t properly mutually exclude the timer action and the  onnext  action  resulting in probabilistic emission of the same buffer twice.;;5426.0;2x: fix buffer(time maxsize) duplicating buffers on time-size race;the pr fixes both the time+maxsize bound `buffer` operators of `flowable` and `observable` the logic didnt properly mutually exclude the timer action and the `onnext` action resulting in probabilistic emission of the same buffer twicereported in #5426; merging 5427 ;[210] buffer(timespan unit count) emits duplicated items;the following code:```import ioreactivexobservableimport orgjunittestimport javautilconcurrenttimeunitpublic class buffertest {    @test    public void testbuffer() {        observablerange(0 10)                map(n -> {                    threadsleep(100)                    return n                })                buffer(1 timeunitseconds 5)                subscribe(systemout::println)    }}```is expected to print something like:[0 1 2 3 4][5 6 7 8][9]but try to run it several times and you can see that sometimes it prints out:[0 1 2 3 4][5 6 7 8 9][5 6 7 8 9]where one of the bunches is duplicated;thanks for reporting this is a bug in both `observable` and `flowable` operators ill post a fix shortly || closing via #5427 ||;1;0;2x: fix buffer(time maxsize) duplicating buffers on time-size race;
5432;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix/clarify the observable class  javadoc;this pr rewords the javadoc of the  observable  class a bit and adds a couple of extra clarifying sentences.;;0;2x: fix/clarify the observable class javadoc;this pr rewords the javadoc of the `observable` class a bit and adds a couple of extra clarifying sentences; merging 5432 ;;;;1;1;extends -> implements;
5434;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix time bounded replaysubject getvalue() inconsistency with getvalues() on old items;see https://github.com/reactivex/rxjava/issues/5433.;;0;2x: fix time bounded replaysubject getvalue() inconsistency with getvalues() on old items;see https://githubcom/reactivex/rxjava/issues/5433; merging 5434 ;;;;1;1;roll-back auto-formatted imports;
5437;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;1.x: testsubscriber::assertvaluesandclear should reset valuecount;during the time between calling  assertvaluesandclear  and providing the next  onnext  event  the  valuecount  is inconsistent with the size of the internal  values  list.;;0;1x: testsubscriber::assertvaluesandclear should reset valuecount;during the time between calling `assertvaluesandclear` and providing the next `onnext` event the `valuecount` is inconsistent with the size of the internal `values` list; merging 5437 ;;;;1;1;1x: testsubscriber::assertvaluesandclear should reset valuecount;
"5440;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: concat to report isdisposed consistently with termination;this pr makes sure the  disposable  of a  concat  operator reports  true  when the sequence terminates.;;543.0;2x: concat to report isdisposed consistently with termination;this pr makes sure the `disposable` of a `concat` operator reports `true` when the sequence terminatesreported in #5439; merging 5440 ;support creating observable from androids sensor;very early pr to get some guidance over api testing style and error handling;""#476  this needs to be rebased as it conflicts with other changes committed@mttkay can you weigh in on this? || you should not need a subject just observablecreate (whenever you think you need a subject think again)to handle @mironov-nsk remark i would pass in a function from sensorevent to t you use that function to project the event to whatever you want to push into the stream```public static observable<float> fromsensor(sensormanager sensormanager int type int rate) {}```would become``` public static <t> observable<t> fromsensor(sensormanager sensormanager int type int rate func1<sensorevent t> selector) {}``` || @mttkay when a user subscribes an observable he may forget to unsubscribe it which may be a resource leak issue in android i propose the following helper class to help users manage the subscriptions related to a contextso the user can simply unsubscribe all of the subscriptions at the onstop method``` javapublic class androidsubscriptions {    private static map<context compositesubscription> contextsubscriptions  new hashmap<context compositesubscription>()    public static synchronized void add(context context            subscription subscription) {        compositesubscription parentsubscription  contextsubscriptions                get(context)        if (parentsubscription  null) {            parentsubscription  new compositesubscription()            contextsubscriptionsput(context parentsubscription)        }        parentsubscriptionadd(subscription)    }    public static synchronized void unsubscribe(context context) {        compositesubscription parentsubscription  contextsubscriptions                get(context)        if (parentsubscription ! null) {            parentsubscriptionunsubscribe()            contextsubscriptionsremove(context)        }    }}```here i use static methods because i want to use  `androidsubscriptionsadd` like the following codes:``` javapublic class operationobservefromandroidsensor {    public static observable<float> observefromandroidsensor(            final context context final sensormanager sensormanager int type            final int rate) {        final sensor sensor  sensormanagergetdefaultsensor(type)        if (sensor  null)            throw new illegalargumentexception(""""unsupported sensor type"""")        return observablecreate(new onsubscribefunc<float>() {            @override            public subscription onsubscribe(                    final observer<? super float> observer) {                final sensoreventlistener listener  new sensoreventlistener() {                    @override                    public void onsensorchanged(sensorevent event) {                        observeronnext(arrayscopyof(eventvalues                                eventvalueslength))                    }                    @override                    public void onaccuracychanged(sensor sensor int accuracy) {                        // todo                    }                }                sensormanagerregisterlistener(listener sensor rate)                subscription subscription  subscriptionscreate(new action0() {                    @override                    public void call() {                        sensormanagerunregisterlistener(listener)                    }                })                androidsubscriptionsadd(context subscription)                return subscription            }        })    }}```whats your opinion? || im not sure i understand what problem this solves where do you release the composite subscription for a context? the wrapped subscriptions while mapped to the same context might have completely unrelated life cycles too moreover keeping strong references to context in a global unsynchronized shared object is a bit of a red flag ||  the composite subscription for a context will be unsubscribed in activityonstop (or ondestroy?) method like:```    @override    protected void onstop() {        androidsubscriptionsunsubscribe(this)        superonstop()    }``` || basically i want to collect all of the subscriptions related to a context when the context is going to be destroyed we can call `androidsubscriptionsunsubscribe(context)` to subscribe them  || i see what you mean why not have the composite subscription as a memberfield in your activity class? thats what we do in our app i still dontsee a case here for a shared static field in the library itselfon thu dec 12 2013 at 10:20 am shixiong zhu notifications@githubcomwrote:> basically i want to collect all of the subscriptions related to a> context when the context is going to be destroyed we can call> androidsubscriptionsunsubscribe(context) to subscribe them> > > reply to this email directly or view it on github  || @mttkay youre right i gave up this idea as i could not find any elegant way i agree that managing the subscriptions is the apps job || since this can no longer be merged can you close this and re-create a new one once the code is ready? || closing out as it cant be merged and has been 15+ days since involvement  please re-submit a new pr when this is ready || "";1;0;2x: concat to report isdisposed consistently with termination;"
5441;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix periodic scheduler purging config not honored;the  schedulerpoolfactory  did not act properly on the system properties setup.;;0;2x: fix periodic scheduler purging config not honored;the `schedulerpoolfactory` did not act properly on the system properties setupreported on stackoverflow: https://stackoverflowcom/q/44717193/61158; merging 5441 ;;;;1;1;2x: fix periodic scheduler purging config not honored;
5444;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2x: fix wording in async and publish processors javadoc.;seams that these are some leftovers from the 1.x -> 2.x refactoring.;;0;2x: fix wording in async and publish processors javadoc;seams that these are some leftovers from the 1x -> 2x refactoring; merging 5444 ;;;;1;1;2x: fix wording in async and publish processors javadoc;
"5447;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove @nonnull annotation in consumer method parameter;this 5442;;5442.0;remove @nonnull annotation in consumer method parameter;this 5442;""this should be safe to merge see the discussion in #5216 ||  merging 5447  "";2x: consumer contract is violated when using doonevent;the following code showcases the problem:```javacompletablecomplete()  doonevent(t -> {})````t` in this case is annotated with `@nonnull` but it will be `null` since the completable completesthis is a real pain in kotlin since the following code crashes in runtime:```kotlincompletablecomplete()  doonevent {}```;""biconsumer is also violated when using `single#subscribe` either value or throwable will be null || removing the annotation from `consumer` may affect all other places where it is not-null can you override the annotation somehow at the call site?@sakuna63 [biconsumer]( doesnt have the annotations || i just stumbled upon this while using kotlin too however i wonder how a function argument annotated with `@nonnull` can ever be `null`? even in java this should be problematic as the contract is broken || maybe rxkotlin has/could have workarounds for these /cc @thomasnield || sorry i read old source code the annotations have already been removed at  || this was introduced with #5023 || > removing the annotation from consumer may affect all other places where it is not-null can you override the annotation somehow at the call site?@akarnokd if theres just one call that passes `null` to the function then *imho* the argument must be annotated with `@nullable` and not `@nonnull` whats the point of `@nonnull` when it can be `null`? || @akarnokd no the problem cannot be remidied in kotlin which completely prevents the usage of that operator in kotlin removing the annotation wont make it nullable though it would just mean that we dont know the nullability status which is the case too why is it important to keep it? i see very little harm in removing it and as @svenjacobs said the contract is broken in java too if i were to null check it in java i would probably get lint warning telling me to remove the null checkideally there should be multiple interfaces like @rharter suggested in the issue for bifunction || if you can think you can resolve this with minimal changes pr welcome || by the way this issue emerged with the release of kotlin 113 although `@nonnull` has already been added months ago it seems that the compiler/runtime library of kotlin 113 became stricter in regards to nullability || ah that explains why i just recently starting having problems || huh i thought implementing `consumer` interface manually with correct nullability will help:```kotlincompletable        fromcallable {  }        doonevent(object : consumer<throwable> {            override fun accept(t: throwable?) { // error: accept overrides nothing                println(""""event: $t"""")            }        })        subscribe()```but kotlin compiler (113-eap34) does not even let such code to compile so there is probably no clear way to solve this in kotlin without using java code || is `doonevent` the only operator that needs a `consumer` that accepts nullable data? if so why remove `@nonnull` which is fairly useful annotation for most of the other operators? why not have a different lets say `consumer2` specifically for doonevent and such operators? || "";1;0;remove @nonnull annotation in consumer method parameterthis 5442;"
"5449;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove the @nonnull annotation from function;as per per the discussion in #5447;;544.0;remove the @nonnull annotation from function;as per per the discussion in #5447; merging 5449 ;replaysubject emits items received after onerror;""this snippet``` scala    val sub  replaysubject[int]()    subonnext(1)    subonnext(2)    subonerror(new exception(""""kabloooy!"""")) // gets moved to after onnext(3)    subonnext(3)    subsubscribe(      n > println(""""sub1: """" + n)      e > println(""""sub1: """" + egetmessage)      () > println(""""sub1: completed"""")    )    println(""""done"""")```outputs```sub1: 1sub1: 2sub1: 3sub1: kabloooy!done```but i would expect```sub1: 1sub1: 2sub1: kabloooy!done```since items received after onerror should not be emitted by replaysubject(thank you dragisa krsmanovic for pointing this out)"";ben and i hacked on subjects earlier this week all subjects are/were in pretty bad shape but well fix it  || replaysubject is the one i didnt touch i refactored publish/behavior/async ill put replay on my todo || i think this is a trivial fix``` java    @override    public void onnext(t args)    {        synchronized (subscriptions) {            if (isdone) {                return            }            historyadd(args)            for (observer<? super t> observer : new arraylist<observer<? super t>>(subscriptionsvalues())) {                observeronnext(args)            }        }    }``` || we should also make sure no additionalon errorsare propagatedsent from my ipad> on nov 30 2013 at 4:52 am akarnokd notifications@githubcom wrote:> > i think this is a trivial fix> > ```> @override> public void onnext(t args)> {>     synchronized (subscriptions) {>         if (isdone) {>             return>         }>         historyadd(args)>         for (observer<? super t> observer : new arraylist<observer<? super t>>(subscriptionsvalues())) {>             observeronnext(args)>         }>     }> }> ```> > > reply to this email directly or view it on github ||;1;0;remove the @nonnull annotation from functionas per per the discussion in #5447;"
5454;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: replace duplicate calling method setaccessible on the same object in functionstest class.;i would like to add unit tests to my project and decided to watch tests in this repository. during reviewing testing class <code>functionstest</code> i watch duplicated calling method <code>setaccessible(true)</code> at the same object.;;0;2x: replace duplicate calling method setaccessible on the same object in functionstest class;i would like to add unit tests to my project and decided to watch tests in this repository during reviewing testing class <code>functionstest</code> i watch duplicated calling method <code>setaccessible(true)</code> at the same object; merging 5454 ;;;;1;1;[ref] replace duplicate calling method setaccessible on the same object;
"5457;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: see if sudo required results in consistent & faster build times;i asked the travis support about the slow build times of lately and they suggested i try  sudo:required  to have an isolated build vm instead of the shared container-based one. i ll rerun this pr a couple of times to see the effects.;;0;2x: see if sudo required results in consistent & faster build times;i asked the travis support about the slow build times of lately and they suggested i try `sudo:required` to have an isolated build vm instead of the shared container-based one ill rerun this pr a couple of times to see the effects;"" merging 5457  "";;;;1;1;merge branch 2x into akarnokd-patch-1;"
5460;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix javadoc mistakes and some style;this pr fixes most javadoc errors discovered from rxjava 3 preview s javadoc generator (doclint enabled).;;0;2x: fix javadoc mistakes and some style;this pr fixes most javadoc errors discovered from rxjava 3 previews javadoc generator (doclint enabled) (i was unable to make gradle in rxjava 2 to report the same errors regardless of source level and underlying java 8 runtime locally)changes include:- fix closing tag of `<dt>` in `<dl>`s- fix `<td>` to `<dt>` in `<dl>`s- replace `>` in `<code>` blocks with `&gt`  (as it is forbidden in doclint of java 8)- replace `<` in `<code>` blocks with `&lt`- add source code checker for the previous mistakes- remove `initialseed` mentions from `scan` operators that take a `seedsupplier` and remove the deferred example as well- switch the order of `<code><pre>` to `<pre><code>`- a couple of end-sentence punctuation; merging 5460 ;;;;1;1;2x: fix javadoc mistakes and some style;
5462;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;refactoring singleschedulertest;hi;;0;refactoring singleschedulertest;hii refactored `singleschedulertest` now it extends `abstractschedulertests` so redundant tests (with duplicated code) could be removed in favor of abstract tests now thanks to the abstract test class `singlescheduler` has 21 unit tests instead of just 7 this approach is consistent with the test classes for other schedulersregardspiotr; merging 5462 ;;;;1;1;refactoring singleschedulertest now it extends abstractschedulertests so redundant tests could be removed in favor of abstract tests;
5465;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix wording of tolist  fix a/an in subscribeon;this pr;;0;2x: fix wording of tolist fix a/an in subscribeon;this pr- fixes the wording of `tolist()` putting emphasis of the need for finite sources and removes a misleading/incorrect sentence about unstoppability- corrects a/an spelling errors in `subscribeon`- removes the mention of `toblocking` from the `tofuture` javadoc; merging 5465 ;;;;1;1;2x: fix wording of tolist fix a/an in subscribeon;
5466;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: flowabletimeouttimed - replace atomicreference with mutable field;as per discussion in #5461. the timer fields in the subscriber classes in [flowabletimeouttimed]( are  atomicreference s but this is not required as the fields are accessed synchronously.;;5461.0;2x: flowabletimeouttimed - replace atomicreference with mutable field;as per discussion in #5461 the timer fields in the subscriber classes in [flowabletimeouttimed]( are `atomicreference`s but this is not required as the fields are accessed synchronouslythe `timer` field in `timeouttimedothersubscriber` did require an `atomicreference` because of the dispose call [here]( but this call is not required if we just call `workerdispose()`no unit test additionsps 9321 unit tests in rxjava 2x! an outrageous amount of work thanks @akarnokd (and other contributors)!; merging 5466 ;2x: flowabletimeouttimed enhancement;im debugging a production problem where a timeout did not fire so having a close look at `flowabletimeouttimed` i notice in `timeouttimedsubscriber` that multiple terminal events can be emitted to the downstream subscriber in race between the scheduled timeout runnable and the `onerror` and `oncomplete` methods the volatile `done` flag doesnt provide complete protection unless we turn it into an `atomicboolean` and use `compareandset` the other thing i notice is that the `timer` field is accessed synchronously (only via `onsubscribe` and `onnext`) so rather than an `atomicreference` can be a mutable fieldi can make pr if you think these are valid;the `onnext` method would need protection as well || see [flowabletimeouttimed:51]( || ah good thanks and the `timer` field doesnt need to be `atomicreference`?btw prod problem was external api not defined properly so all good || you mean [this]( and [this]( || yepon tue 4 jul 2017 20:06 david karnok <notifications@githubcom> wrote:> you mean this> < and this> < ?>> > you are receiving this because you authored the thread> reply to this email directly view it on github> < or mute the thread> < > || yeah doesnt really need atomicreference in its current algorithm || ill fix || btw there is [a more modern algorithm]( for this operator that doesnt need an additional layer of serialization || closing via #5466 ||;1;0;use a mutable field in flowabletimeouttimed instead of an atomicreference;
"5467;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: removing commented code from tests;hi;;0;2x: removing commented code from tests;hiin this pr im removing commented code from tests as its generally considered as bad practicepart of this code is even not available in the current rxjava api it does not resolve all of the issues like that but only part of them i didnt want to create pr with more changes because it will be harder to review rest of the similar issues could be resolved in the future prsregardspiotr;"" merging 5467  "";;;;1;1;removing commented code from tests;"
5471;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: increase timeout of some tests;increase timeouts of tests that started failing due to slower ci.;;0;1x: increase timeout of some tests;increase timeouts of tests that started failing due to slower ci; merging 5471 ;;;;1;1;retry testnobufferingorblockingofsequence multiple times;
5486;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: small note on maybe.defaultifempty regarding tosingle;ths pr replaces #5485 regarding the issue of #5480 because our javadoc validation did not allow that type of wording (i.e.  mentioning  single  when the method signature is not related to it).;;5480.0;2x: small note on maybedefaultifempty regarding tosingle;ths pr replaces #5485 regarding the issue of #5480 because our javadoc validation did not allow that type of wording (ie mentioning `single` when the method signature is not related to it); merging 5486 ;suggest maybe#tosingle in maybe#defaultifempty documentation;looking at  i was surprised to find it didnt return `single` searching in closed issues found the answer:  perhaps documentation could be improved by explicitly mentioning `tosingle` as an alternative?;pr welcome || closing via #5486 ||;1;0;2x: small note on maybedefaultifempty regarding tosingle;
5486;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: small note on maybe.defaultifempty regarding tosingle;ths pr replaces #5485 regarding the issue of #5480 because our javadoc validation did not allow that type of wording (i.e.  mentioning  single  when the method signature is not related to it).;;5485.0;2x: small note on maybedefaultifempty regarding tosingle;ths pr replaces #5485 regarding the issue of #5480 because our javadoc validation did not allow that type of wording (ie mentioning `single` when the method signature is not related to it); merging 5486 ;update maybe#defaultifempty javadoc (#5480);adds a link to javadoc for `maybe#defaultifempty` method which has a surprising return type (#5480 #5417);forgot about the javadoc wording guards i posted #5486 that includes your sentences and an updated validator ||;1;0;2x: small note on maybedefaultifempty regarding tosingle;
5493;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix replayprocessor backpressure and notificationlite emission bug;this pr upgrades the replaying algorithms of the  replayprocessor  to the standard queue-drain and as an added effect  fixes a request-emission race where the internal  notificationlite.complete  could be emitted to the consumers.;;0;2x: fix replayprocessor backpressure and notificationlite emission bug;this pr upgrades the replaying algorithms of the `replayprocessor` to the standard queue-drain and as an added effect fixes a request-emission race where the internal `notificationlitecomplete` could be emitted to the consumers; merging 5493 ;;;;1;1;restore coverage;
5494;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;flowablewithlatestfrom forgets request;the following scenario did not work with flowablewithlatestfrom:;;0;flowablewithlatestfrom forgets request;the following scenario did not work with flowablewithlatestfrom:flowable<?> result  sourcecombinewithlatest(other somecombiner)- client subscribe to the result stream- source stream emits- other stream emits- source stream emitsexpected result: result stream emits the combined eventactual result: result stream does not emit anything;nice find and im a bit baffled as [flowablewithlatestfrommany]( does not have this flaw ||  merging 5494 ;;;;1;1;revert import change;
5495;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: make withlatestfrom conditional subscriber  test cold consumption;this pr adjusts #5494 by converting the  withlatestfrom  operators into conditional subscribers and adds unit tests that verify a cold source is consumed fully if there is no event(s) from the other source(s).;;0;2x: make withlatestfrom conditional subscriber test cold consumption;this pr adjusts #5494 by converting the `withlatestfrom` operators into conditional subscribers and adds unit tests that verify a cold source is consumed fully if there is no event(s) from the other source(s)(also there was a missing space before the bracked and the new unit test name had the `test` prefix); merging 5495 ;;;;1;1;cleanup internal logic improve coverage;
5507;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix spsclaq nepotism  flowablerefcounttest.testrefcountasync flaky;this pr fixes the so-called gc nepotism (see #3794) in  spsclinkedarrayqueue  by not nulling out the previous buffer s next pointer upon switching buffers in the  peek() / poll()  methods.;;3794.0;2x: fix spsclaq nepotism flowablerefcounttesttestrefcountasync flaky;this pr fixes the so-called gc nepotism (see #3794) in `spsclinkedarrayqueue` by not nulling out the previous buffers next pointer upon switching buffers in the `peek()`/`poll()` methodsin addition the flowablerefcounttesttestrefcountasync has been reworked to be more forgiving towards unexpected delays due to system load (reported in #5506); merging 5507 ;gc nepotism in linked data structures;there [was a post]( just recently by @nitsanw warning about the problem called gc nepotismthis affects our older copies of the jctools queues `mpsclinkedqueue` and `spsclinkedarrayqueue` there is an issue #1735 about shading which would fix it but that could happen in any time even after some more small version changesin addition the issue affects both the bounded versions of `replay()` and `replaysubject` the problem there is that individual subscribers could be at any point in the linked-node sequence we cant just null out links when the operators move their head forward (trimming)it might be possible to null out the right node by scanning the known child subscribers and chosing the earliest node any of them knows about unfortunately this also requires back-references between nodes as well as node indexing taking extra time and extra concurrency considerations;closing as mostly resolved where it was possible ||;1;0;2x: fix spsclaq nepotism flowablerefcounttesttestrefcountasync flaky;
5507;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix spsclaq nepotism  flowablerefcounttest.testrefcountasync flaky;this pr fixes the so-called gc nepotism (see #3794) in  spsclinkedarrayqueue  by not nulling out the previous buffer s next pointer upon switching buffers in the  peek() / poll()  methods.;;5506.0;2x: fix spsclaq nepotism flowablerefcounttesttestrefcountasync flaky;this pr fixes the so-called gc nepotism (see #3794) in `spsclinkedarrayqueue` by not nulling out the previous buffers next pointer upon switching buffers in the `peek()`/`poll()` methodsin addition the flowablerefcounttesttestrefcountasync has been reworked to be more forgiving towards unexpected delays due to system load (reported in #5506); merging 5507 ;2x: flowablerefcounttest causing build failure;im getting a 50/50 success rate on building 2x here is the test result:```javalangassertionerror: expected:<12> but was:<11>	at orgjunitassertfail(assertjava:88)	at orgjunitassertfailnotequals(assertjava:834)	at orgjunitassertassertequals(assertjava:645)	at orgjunitassertassertequals(assertjava:631)	at ioreactivexinternaloperatorsflowableflowablerefcounttesttestrefcountasync(flowablerefcounttestjava:83)	at sunreflectnativemethodaccessorimplinvoke0(native method)	at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:498)	at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:50)	at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:12)	at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:47)	at orgjunitinternalrunnersstatementsinvokemethodevaluate(invokemethodjava:17)	at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:325)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:78)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:57)	at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)	at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)	at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)	at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)	at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)	at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)	at orggradleapiinternaltaskstestingjunitjunittestclassexecuterruntestclass(junittestclassexecuterjava:114)	at orggradleapiinternaltaskstestingjunitjunittestclassexecuterexecute(junittestclassexecuterjava:57)	at orggradleapiinternaltaskstestingjunitjunittestclassprocessorprocesstestclass(junittestclassprocessorjava:66)	at orggradleapiinternaltaskstestingsuitetestclassprocessorprocesstestclass(suitetestclassprocessorjava:51)	at sunreflectgeneratedmethodaccessor10invoke(unknown source)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:498)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:35)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:24)	at orggradleinternaldispatchcontextclassloaderdispatchdispatch(contextclassloaderdispatchjava:32)	at orggradleinternaldispatchproxydispatchadapter$dispatchinginvocationhandlerinvoke(proxydispatchadapterjava:93)	at comsunproxy$proxy2processtestclass(unknown source)	at orggradleapiinternaltaskstestingworkertestworkerprocesstestclass(testworkerjava:109)	at sunreflectgeneratedmethodaccessor9invoke(unknown source)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:498)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:35)	at orggradleinternaldispatchreflectiondispatchdispatch(reflectiondispatchjava:24)	at orggradleinternalremoteinternalhubmessagehub$handlerrun(messagehubjava:377)	at orggradleinternalconcurrentexecutorpolicy$catchandrecordfailuresonexecute(executorpolicyjava:54)	at orggradleinternalconcurrentstoppableexecutorimpl$1run(stoppableexecutorimpljava:40)	at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1142)	at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:617)	at javalangthreadrun(threadjava:748)```;it is a flaky test and is quite sensitive to system load due to that 52 millisecond wait maybe it would be possible to sleep-loop over a `nextcountget()  receivedcountget() && nextcountget()  10` condition || closing via #5507 ||;1;0;2x: fix spsclaq nepotism flowablerefcounttesttestrefcountasync flaky;
5511;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove unnecessary generic type parameters for delaysubscription methods in single;i was running into an issue with using the  delaysubscription(long time  timeunit unit)  while testing a  single  and i saw that the  u  generic type parameter was there unnecessarily. i believe this is only a kotlin specific issue as i tried playing around in java and there was no inference error upon compilation. to get it to compile for kotlin  i would need to specify the generic type parameter and it didn t matter what i set it to as  any  was a valid option:  .delaysubscription<any>(5  timeunit.seconds) . i also went through  flowable    observable   and  maybe  and saw that the generics were missing for the time-specific  delaysubscription  methods so i believe they should be removed from  single  as well to help keep things consistent and remove this compilation error for future kotlin users.;;0;remove unnecessary generic type parameters for delaysubscription methods in single;i was running into an issue with using the `delaysubscription(long time timeunit unit)` while testing a `single` and i saw that the `u` generic type parameter was there unnecessarily i believe this is only a kotlin specific issue as i tried playing around in java and there was no inference error upon compilation to get it to compile for kotlin i would need to specify the generic type parameter and it didnt matter what i set it to as `any` was a valid option: `delaysubscription<any>(5 timeunitseconds)` i also went through `flowable` `observable` and `maybe` and saw that the generics were missing for the time-specific `delaysubscription` methods so i believe they should be removed from `single` as well to help keep things consistent and remove this compilation error for future kotlin users![kotlin_error](https://user-imagesentcom/1130517/28450952-83ad8468-6db8-11e7-841e-85be4ddf0c26png); merging 5511 ;;;;1;1;remove unnecessary generic type parameters for delaysubscription methods in single;
5517;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add missing null check to fused observable.fromcallable;there was a missing null check on the fusion path in  observablefromcallable  which meant the consumer considered the source to be empty. (the  flowablefromcallable  was okay.);;0;2x: add missing null check to fused observablefromcallable;there was a missing null check on the fusion path in `observablefromcallable` which meant the consumer considered the source to be empty (the `flowablefromcallable` was okay)discovered on stackoverflow:  test mirrored and updated to verify both `flowable` and `observable` versions; merging 5517 ;;;;1;1;2x: add missing null check to fused observablefromcallable;
5524;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add/update observable marbles (07/30);this pr updates the marbles of the following  observable  operators:;;5319.0;2x: add/update observable marbles (07/30);this pr updates the marbles of the following `observable` operators:- `just` ([image]( by @leonardortlima - `rangelong` ([image]( by @leonardortlima - `startwith` ([image]( by @leonardortlima - `startwitharray` ([image]( by @leonardortlima - `sorted` ([image]( by @leonardortlima see #5319; merging 5524 ;2x: observable missing or incorrect images (tracking issue);-  [observablesingleorerror()]( there is no default value and an empty source should result in an error-  `observablecombinelatestdelayerror(observablesource function)`: missing diagram-  `observablecombinelatestdelayerror(function int observablesource)`: missing diagram-  `observableconcatarrayeager`: missing diagram-  `observableerror`: should include the x in the operator body indicating it as being the parameter/return value-  `observablefromfuture`: the operator name in the box-  `observablefromiterable`: the operator name in the box-  `observablefrompublisher`: missing diagram-  `observablejust`: the element should be a parameter inside the box such outside elements imply a subject type external push-  `observablejust(t t)` +7: optionally tailor the diagram to the actual number of arguments plus move the constant values inside the box- [x] `observablerangelong`: the operator name in the box- [x] `observableswitchonnextdelayerror`: the operator name in the box indicator of an error getting delayed- [x] `observableziparray`: indicate there is a function instead of implying the output is an array containing one element from each source- [x] `observablezipiterable`: the operator name in the box- [x] `observableall`: example of a false result- [x] `observableambwith`: the operator name in the box- [x] `observableblockingfirst`: missing diagram- [x] `observableblockingforeach`: the operator name in the box- [x] `observableblockingiterable`: the operator name in the box indicate that blocking may happen for each element- [x] `observableblockinglast`: the operator name in the box- [x] `observableblockinglast(t)`: the operator name in the box indicate default in the box fix labels- [x] `observableblockinglatest`: missing diagram- [x] `observableblockingmostrecent`: the operator name in the box- [x] `observableblockingnext`: the operator name in the box- [x] `observableblockingsingle`: the operator name in the box- [x] `observableblockingsingle(t)`: the operator name in the box indicate default in the box fix labels- [x] `observabletofuture()`: the operator name in the box indicate multi-value empty and error behavior- [x] `observableblockingsubscribe`: missing diagram- [x] `observablecachewithinitialcapacity`: the operator name in the box- [x] `observablecollectinto`: the operator name in the box indicate the shared collection- [x] `observableconcatmapcompletable`: missing diagram- [x] `observableconcatmapdelayerror`: missing diagram- [x] `observableconcatmapeager`: missing diagram- [x] `observableconcatmapeagerdelayerror`: missing diagram- [x] `observableconcatmapiterable`: missing diagram- [x] `observabledoafternext`: missing diagram- [x] `observabledofinally`: missing diagram- [x] `observabledoondispose`: the operator name in the box- [x] `observabledooncomplete`: indicate that the events pass through and the star is execute before the oncomplete to downstream- [x] `observabledoonerror`: indicate that the events pass through and the star is execute before the onerror to downstream- [x] `observabledoonlifecycle`: change unsubscribe to dispose- [x] `observabledoonnext`: indicate that the events pass through and the star is execute before the onnext to downstream- [x] `observabledoonterminate`: indicate that the events pass through and the star is execute before the onerror or oncomplete to downstream- [x] `observableelementat(long)`: example of empty source- [x] `observableelementat(long t)`: example of empty source- [x] `observableelementatorerror(long)`: example of empty source- [x] `observablefirstelement`: diagram is stretched- [x] `observablefirstorerror`: the operator name in the box- [x] `observableflatmap(function boolean int)`: missing diagram- [x] `observableflatmap(function boolean int int)`: missing diagram- [x] `observableflatmap(function function callable int)`: missing diagram- [x] `observableflatmap(function int)`: missing diagram- [x] `observableflatmap(function bifunction boolean int)`: missing diagram- [x] `observableflatmap(function bifunction boolean int int)`: missing diagram- [x] `observableflatmap(function bifunction int)`: missing diagram- [x] `observableflatmapcompletable()`: missing diagram- [x] `observableflatmapiterable(function)`: diagram looks stretched- [x] `observableforeach()`: missing diagram- [x] `observableforeachwhile()`: missing diagram- [x] `observablehide()`: missing diagram - not sure how to represent this- [x] `observablelastorerror()`: operator name in the box error case example- [x] `observableonerrorreturn()`: indicate that the value is the result of a function call- [x] `observableonerrorreturnitem()`: operator name in the box- [x] `observableonterminatedetach`: missing diagram- [x] `observablepublish(function)`: there is no connect call may need extensive redrawing- [x] `observablereducewith()`: operator name in the box- [x] `observablerepeat()` + overloads: indicate fresh subscriptions happen not caching- [x] `observablerepeatuntil`: operator name in the box indicate fresh subscriptions- [x] `observablereplay()` + overloads: remove publish- [x] `observablereplay(function )` overloads: may need extensive redrawing- [x] `observableretry(long)` indicate limited retry effect- [x] `observableretry(predicate)` indicate predicate effect show it in the box- [x] `observableretry(long predicate)` indicate predicate show them in the box- [x] `observableretryuntil`: operator name in the box show booleansupplier- [x] `observableshare()`: fix labels with unsubscribe- [x] `observablesingleelement`: example with empty source- [x] `observablesorted`: missing diagram- [x] `observablestartwith(t)`: have a single item as start value- [x] `observablestartwitharray(t)`: operator name- [x] `observablesubscribe` + overloads: missing diagram- [x] [observableswitchmapsingle]( inner sources should have 1 item- [x] `observableswitchmapdelayerror` + indicate the error case- [x] `observabletolist(callable)`: indicate the custom collection somehow?- [x] `observabletoflowable()`: missing diagram- [x] `observableunsubscribeon()`: missing diagram- [x] `observablezipwith()` + overloads: the diagram is in line with some text and appears pushed to the right- [x] `observabletest()`: missing diagram can this be represented as diagram?;prs welcome the most easy ones are those that require alignment/displayed size corrections || hi david id love to help what would i use to edit the diagrams? || if you are on mac and you own omnigraffle there is a file for **all** traditional diagrams: using excel 2007+ on windows to draw the newer diagrams and have a file [here]( you can use as basis for newer diagrams i dont know if the open office variants could open this file or not googles viewer certainly doesnt show the drawingsi suppose as a last resort you can draw in the open-office variants as well and post the pngs in this issue uploading it requires access to the wiki git of rxjava the target rendering is 640 pixels wide and as long as it needs to bethe process is as follows:- draw diagram(s)- upload to git- modify javadoc locally to point to the raw usercontent- verify and fix alignment/stretching- commit pr to rxjava itself || is it `switchmapsingle` need a new diagram too? singleresource cant emit 2 items || yes ill add it to the list above || ## concatarrayeager( || ## error![image]( || ## fromfuture![image]( || ## fromiterable![image]( || another option is to use free open-source multi-platform inkscape templates here: || **startwith(t)**![startwith t]( || **startwitharray(t)**![startwitharray]( || thanks could you make sure the operator box has its contents centered? || sure going to edit them || **sorted()**is it okay to add numbers to the marbles?![sorted]( || in this case yes because it also demonstrates the self-comparable nature required (changing the order of colors is unlikely to convey the sorting aspect) for most of the other operators the matching up of the color should be enough || not sure how you do these images could you add shadows to the marbles the time arrows and the vertical complete indicators? || im using @davidmotens template going to edit them to add the shadows  || sorted(): it would be better that the source marbles are at the beginning and the output is only happening after oncomplete:```---5--3--1--4--2--|--------------[            sorted()           ]---------------------1-2-3-4-5-|-``` || added shadows and edited the `sorted()` operator || **just(t)**![just]( || **rangelong()**![rangelong]( || thanks @leonardortlima ! the first 5 images is added via #5524 || just noticed that `singlefilter` and `maybefilter` are also incorrect they seem to be copied from `observablefilter` || quite possibly the other base reactive classes have copy-paste diagrams this issue tracks the fixes of `observable` but if you want i can open issues for the other classes individually || ![just(2)]( || from #5668:![singleelement]( || ### zipiterable![zipiterable]( ambwith![ambwith]( blockingforeach![blockingforeach]( blockingiterable![blockingiterable]( blockinglast![blockinglast]( blockingmostrecent![blockingmostrecent]( blockingnext![blockingnext]( blockingsingle![blockingsingle]( cachewithinitialcapacity![cachecwithinitialcapacity]( || ### all![cachecwithinitialcapacity]( frompublisher![cachecwithinitialcapacity]( ziparray![cachecwithinitialcapacity]( || ### blockingfirst![blockingfirst]( tofuture![tofuture]( blockingsubscribe![blockingsubscribe]( collectinto![collectinto]( dooncomplete![dooncomplete]( doonerror![doonerror]( doonlifecycle![doonlifecycle]( doonnext![doonnext]( || ### concatmapcompletable![concatmapcompletable]( concatmapdelayerror![concatmapdelayerror]( concatmapeager![concatmapeager]( concatmapeagerdelayerror![concatmapeagerdelayerror]( concatmapiterable![concatmapiterable]( doafternext![doafternext]( dofinally![dofinally]( || ### doonterminate![doonterminate]( elementat![elementat]( elementatorerror![elementatorerror]( firstorerror![firstorerror]( flatmap![flatmap]( || ![flatmapcompletable]( || ![lastorerror]( f)](  ![replay(int long timeunit)]( long timeunit scheduler)]( scheduler)]( timeunit)]( timeunit scheduler)]( || ![no arguments]( scheduler]( scheduler]( time]( time scheduler]( || ![retry(int)]( predicate)]( || ![tolist(callable)]( ||;1;0;2x: add/update observable marbles (07/30);
5541;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix flaky maybefromcallabletest.noerrorloss;the  maybefromcallabletest.noerrorloss  failed occasionally because the  await  didn t throw  interruptedexception  as expected.;;0;2x: fix flaky maybefromcallabletestnoerrorloss;the `maybefromcallabletestnoerrorloss` failed occasionally because the `await` didnt throw `interruptedexception` as expected the reason for this is that if the main `tocancel()` and the subsequent `cdl2countdown()` happened just before `await()` was called the `await` didnt even look at the threads interrupt status but returned immediately as there was nothing to wait forthe fix just removes that `cdl2countdown` and adds a regular timeout to the inner `await`*(detected while verifying rxjava 2 against jdk 9b181)*; merging 5541 ;;;;1;1;fix the same error in 2 other maybe tests;
5552;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;[typo] update schedulers.java;just a typo i came across while reading the javadocs.;;0;[typo] update schedulersjava;just a typo i came across while reading the javadocs; merging 5552 ;;;;1;1;update schedulersjava;
"5560;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix obs.combinelatestdelayerror sync initial error not emitting;this pr fixes the case reported in #5558 where a synchronous first  non-empty source triggered an error completion immediately instead of giving a chance to the other sources to form combinations.;;5558.0;2x: fix obscombinelatestdelayerror sync initial error not emitting;this pr fixes the case reported in #5558 where a synchronous first non-empty source triggered an error completion immediately instead of giving a chance to the other sources to form combinationsthe fix also includes:- initialization of the `combineobserver`s now happen in the constructor- the `atomicreference<disposable>` of the inner observers are now inlined into `combineobserver`- cleaned up drain logic- unit tests verifying `flowablecombinelatest` (no changes required there); merging 5560 ;2x - combinelatestdelayerror throwing error before subscribing other observables;""i am working on a piece of code where i basically have a cached value which i want to combine with other data and update from the networkmy thought was using combinelatestdelayerror and magic would happen! except when the network is down even though i have valid values in both my observables i only end up getting the errori narrowed it down to a simple test case:```java    @test    public void combinelatestdelayerrorfailure() {        final int result  observablecombinelatestdelayerror(                arraysaslist(                        observablejust(41)concatwith(observableerror(new exception(""""failure"""")))                        observablejust(1)delay(1 timeunitseconds)                )                ints -> ((int) ints[0]) + ((int) ints[1])        )blockingfirst()        assertthat(result)isequalto(42)    }```it always throws the exceptionthere is one point in the documentation about the calls being synchronous though it is not clear to me how i could make changes to my observables to avoid that situation "";thanks for reporting this is a bug with the operator not properly considering the `delayerror` setting in this synchronous situation i cant give you a simple workaround you could try and materialize the failing source and the combiner function could throw it via `exceptionswraporthrow()`ill post a fix for the operator shortly || closing via #5560 || thanks @akarnokd ill wait for the next release to have this ! ||;1;0;remove unused method;"
5568;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add assertvaluesonly to basetestconsumer.;adds  assertvaluesonly  that asserts that the testobserver/testsubscriber received only the specified values in the specified order without terminating.;;5555.0;2x: add assertvaluesonly to basetestconsumer;adds `assertvaluesonly` that asserts that the testobserver/testsubscriber received only the specified values in the specified order without terminating5555; merging 5568 ;2x: baseobserverassertonlyvalues(t);id like to introduce `assertonlyvalues` to the `baseobserver` its the counterpart to `assertresult(t)` which does almost the same except for the fact that the type hasnt completed yetim open if anyone has a better function name internally itd delegate to:```java  assertvalues(values)      assertnoerrors()      assertnotcomplete()      assertsubscribed()```;assertresult will eventually fail so assertvalues was generally enough when there is a bug you can apply the other methods on a case by case basis || > assertresult will eventually fail so assertvalues was generally enoughalthough `assertvalues` does not check for errors nor itll fail when the stream does complete basically with that method i want to test that the stream will stay alive and not terminate || you can write this utility method in a class:```javapublic static <t u extends basetestconsumer<t>> assertvaluesonly(u ts t values) {    return tsassertvalues(values)assertnoerrors()assertnotcomplete()assertsubscribed()}```and intellij will happily staticly import it || i tend to agree with @vanniktech on this feature-request>when there is a bug you can apply the other methods on a case by case basisits usually too late because code was shipped>you can write this utility method in a class:for sure im also pretty sure @vanniktech uses kotlin so he could add extension functionnot a fan of naming though but i see the pattern `assertonlyvalues()` should fit test api design || > for sure im also pretty sure @vanniktech uses kotlin so he could add extension functionthats what im doing right now however i still think a lot of other people could benefit from this and the cost of adding this is really low> not a fan of naming though but i see the pattern assertonlyvalues() should fit test api designopen for any better name || okay lets add it id name it `assertvaluesonly` so it should show up right after `assertvalues` in code completion ||;1;0;address comments;
5578;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add nullpointerexception comment;add comments in single.java;;0;add nullpointerexception comment;add comments in singlejava; merging 5578 ;;;;1;1;add nullpointerexception comment;
5582;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;implement maybe.switchifempty(single);adds  maybe.switchifempty(single)   4544.;;4544.0;implement maybeswitchifempty(single);adds `maybeswitchifempty(single)` 4544; merging 5582 ;maybeswitchifempty(single) method;it would be nice to see a method like this:public class maybe<t> {  public single<t> switchifempty(single<t> single)}semantically if you switchifempty to a single from a maybe then it becomes a single as you are guaranteed either an error or a value  it would just make it less verbose than doing this:maybeswitchifempty(singletomaybe())tosingle();done || im closing this issue due to inactivity if you have further input on the issue dont hesitate to reopen this issue or post a new one ||;1;0;add experimental annotation;
5586;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix single.timeout unnecessary dispose calls;this pr fixes the unnecessary  dispose  call towards the main source when the source terminates and reworks the internals to use less allocation and indirection.;;0;2x: fix singletimeout unnecessary dispose calls;this pr fixes the unnecessary `dispose` call towards the main source when the source terminates and reworks the internals to use less allocation and indirection; merging 5586 ;;;;1;1;route to rxjavapluginsonerror;
"5590;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;implement lambdaconsumerintrospection;5569  and allows you to introspect if the resulting observer has missing error consumption and subsequently supplies a default (throwing) one.;;5569.0;implement lambdaconsumerintrospection;5569 and allows you to introspect if the resulting observer has missing error consumption and subsequently supplies a default (throwing) one;""wasnt sure how youd want to do the naming can work on adding some tests if this looks good wanted to get something up for api review early || the naming is fine with me ||  merging 5590  "";2x: strawman proposal for uncaught exception configuration;this is a strawman example/proposal for configurable uncaught exception handling in rxjavaplugins this is in ref to #5234the two options are to defer to current threads handler (the current implementation and remains the default) and an optional `throw` option that wraps the throwable into an `uncaughtrxjavaexception` for developers to watch for separately (and rethrowing which requires some sort of `runtimeexception` wrapping)if the proposal is agreeable/after api design is in place i can add tests; merging 5569 ;1;0;update tests and flip implementation logic to match naming;"
"5594;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix assertvaluesequence reversed error message;the error message/variable names in  testbaseconsumer.assertvaluesequence  was reversed: if more items were expected  it said  fewer  and vice versa.;;0;2x: fix assertvaluesequence reversed error message;""the error message/variable names in `testbaseconsumerassertvaluesequence` was reversed: if more items were expected it said """"fewer"""" and vice versa""; merging 5594 ;;;;1;1;adjust according to the feedback;"
"5600;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;updating javadoc with correct return types;a small pr with updated javadoc  mentioned in the issue #5595 (thanks to @roblewis for reporting it).;;5595.0;updating javadoc with correct return types;a small pr with updated javadoc mentioned in the issue #5595 (thanks to @roblewis for reporting it)updated documentation about return types where `observable` was incorrectly mentioned instead of `single`;the `flowable` variants [are okay]( ||  merging 5600 ;""2x: documentation error in observable for """"any"""" operator"";in v2 javadoc for `observable` it is stated (in at least 2 places) that the `any()` operator returns an `observable` this appears to be wrong: it returns a `single` (which is stated correctly in other places) the corresponding entry in the `flowable` docs appears to be correct;yes there are a couple of such mistakes ie `all` is wrong as well would you like to submit a pr? || tbh i dont know enough about github to feel comfortable with creating/submitting prs sorry  || perhaps someone else can pick it up pr welcome || closing via #5600 || got another one for you: in observable its stated that isempty() returns an observable when its actually a singleon sep 14 2017 at 07:24 am david karnok <notifications@githubcom> wrote:closed #5595you are receiving this because you authored the threadreply to this email directly view it on github or mute the thread || covered by #5600 ||;1;0;updating javadoc with correct return types;"
"5602;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: workaround for chm.keyset bad type with java 8 compiler;this pr fixes the problem that  concurrenthashmap::keyset   when compiled on jdk 8  adds the  keysetview  type in the bytecode which is not available in jdk 7 and before. the change forces the offending place to use the the standard  map::keyset  which returns a standard  set .;;0;1x: workaround for chmkeyset bad type with java 8 compiler;this pr fixes the problem that `concurrenthashmap::keyset` when compiled on jdk 8 adds the `keysetview` type in the bytecode which is not available in jdk 7 and before the change forces the offending place to use the the standard `map::keyset` which returns a standard `set`;""please give me some time to run test scenario that failed before as a sanity check || added commenti assume if the pr is verified by @artem-zinnatullin we should release 132 asap || mkay looks like travis [stuck]( build is in the queue for an hour@akarnokd can you stop/start or retrigger it? || there is quite a backlog piled up on travis may not clear before i go to sleep  || ok you might want to check """"concurrent jobs"""" related options in build settings on travis || its not our single job but an overall ~400 started by other projects:( ||  merging 5602  "";;;;1;1;1x: workaround for chmkeyset bad type with java 8 compiler;"
"5609;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix observable.concatmapeager queueing of source items;this pr fixes the wrong queue type in  observable.concatmapeager  to be the  spsclinkedarrayqueue  instead of the  spscarrayqueue  (the latter basically ignored items from the main source when it got full - a remnant from its bounded  flowable  cousin). unit tests added that ensure both  flowable  and  observable  variants work properly.;;5608.0;2x: fix observableconcatmapeager queueing of source items;this pr fixes the wrong queue type in `observableconcatmapeager` to be the `spsclinkedarrayqueue` instead of the `spscarrayqueue` (the latter basically ignored items from the main source when it got full - a remnant from its bounded `flowable` cousin) unit tests added that ensure both `flowable` and `observable` variants work properlyreported in: #5608; merging 5609 ;213 observable#concatmapeager queue size issue;""helloive got some issues with concatmapeager prefetch value it seems that concatmapeager stops before the end of the observablehere is a small example showing the issue : ```javaobservablerange(1 100000)        buffer(10)        concatmapeager(value -> observablejust(value)                subscribeon(schedulersio())                doonnext(it -> threadsleep(threadlocalrandomcurrent()nextlong(10 100)))            6 4)        blockingsubscribe(it -> systemoutprintln(""""received : """" + it))```this small code is supposed to write list of ints till 100000 it stops before finishingthe code doesnt work for the default concatmapeager function either (prefetch  128)"";thanks for reporting  in #5609 || closing via #5609 ||;1;0;2x: fix observableconcatmapeager queueing of source items;"
5615;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add missing license headers;fixlicenseheaders  is currently failing when run locally (it s skipped on ci).;;0;2x: add missing license headers;`fixlicenseheaders` is currently failing when run locally (its skipped on ci); merging 5615 ;;;;1;1;add missing license headers;
5616;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add single.delay overload that delays errors;much like #5382  i discovered when trying to fake a slow/flaky backend that  single.delay  doesn t delay errors.;;5382.0;2x: add singledelay overload that delays errors;much like #5382 i discovered when trying to fake a slow/flaky backend that `singledelay` doesnt delay errorsthis pr adds an overload that does bringing `singledelay` in line with `observabledelay` it also corrects the javadoc for existing overloads (#5409 only updated 1/2); merging 5616 ;2x singledelay documentation and implementation inconsistent;the documentation for singledelay says that success or error signals will be delayed by the specified amount but in fact errors are not delayed only successes i have no opinion on which one should be correct - i ran into it when mocking out the response for an incomplete backend to test a loading/error ui eg `singleerror()delay(3 timeunitseconds)` and found that my errors never had a delay it seems that observable has both options with a version of the method that has a boolean flag `delayerror`https://githubcom/reactivex/rxjava/blob/2x/src/main/java/io/reactivex/singlejava#l1636https://githubcom/reactivex/rxjava/blob/2x/src/main/java/io/reactivex/internal/operators/single/singledelayjava#l66;indeed there is no option for that in `single` and `maybe` would you like to submit a pr? || @akarnokd : ive submitted my first pr fixing this ->  kindly review and advice  closing via #5409 ||;1;0;2x: add singledelay overload that delays errors;
5617;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix observable.delay & flowable.delay javadoc;error notifications can be delayed when using the overloads with a  delayerror  parameter.;;0;2x: fix observabledelay & flowabledelay javadoc;error notifications can be delayed when using the overloads with a `delayerror` parameter; merging 5617 ;;;;1;1;2x: fix observabledelay & flowabledelay javadoc;
"5623;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix incorrect error message at subscriptionhelper.setonce;i found an incorrect error message at  subscriptionhelper.setonce .;;0;2x: fix incorrect error message at subscriptionhelpersetonce;""i found an incorrect error message at `subscriptionhelpersetonce`the error message should mention that the second argument `subscription s` is null but the error message says `""""d is null""""`""; merging 5623  < ;;;;1;1;2x: fix incorrect error message at subscriptionhelpersetonce;"
5624;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add onterminatedetach to single and completable;this pr adds the  onterminatedetach  operator to  single  and  completable . it was available on  flowable    observable  and  maybe  already.;;0;2x: add onterminatedetach to single and completable;this pr adds the `onterminatedetach` operator to `single` and `completable` it was available on `flowable` `observable` and `maybe` alreadyplus:- fixes the javadoc for `maybeonterminatedetach`- adds unit tests for verifying terminal events do release references with `maybe` as welltheir non-existence came up on [stackoverflow]( out the downstreams `actual` references were not cleared in `maybe` after all updated the pr to ensure that in all 3 of them and improved coverage; merging 5624 ;;;;1;1;improve coverage fix lack of nulling out the downstream;
5633;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;upgrade to gradle 4.2.1  remove nebula plugin dependency;this pr upgrades the gradle runtime to 4.2 (which supports java 9) and gets rid of the  rxjava-nebula  plugin. its two features  publishing a snapshot and publishing a release has been manually implemented in  build.gradle  based on some [online examples] and [rxandroid s]( variant.;;0;upgrade to gradle 421 remove nebula plugin dependency;this pr upgrades the gradle runtime to 42 (which supports java 9) and gets rid of the `rxjava-nebula` plugin its two features publishing a snapshot and publishing a release has been manually implemented in `buildgradle` based on some [online examples] and [rxandroids]( variantthe snapshot publication [works]( and to test the release we may have to burn a couple of version tags from 21xthe pr also renamed the `perf` directory into `jmh` because the replacement jmh plugin expects those files there; merging 5633 ;;;;1;1;2x: upgrade to gradle 42 remove nebula custom rls;
"5637;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fixing javadoc warnings;minor fixes for warnings reported by  javadoc  tool  mentioned in #5634;;5634.0;2x: fixing javadoc warnings;minor fixes for warnings reported  javadoc` tool mentioned in #5634;nice could you also fix this:```:javadoc/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observers/resourcemaybeobserverjava  error: bad use of > *     subscribewith(new resourcemaybeobserver&ltinteger>() { ``` || sure amended!  ||  merging 5637 ;2x: javadoc errors;""the `javadoc` tool in java 8 is more strict and reports a couple of tag errors in the current build these should be easy to fix pr welcome:```:javadoc/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  error: text not allowed in <ul> element     *     to signal the overflow to the producer</li>j                                                       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  error: self-closing element not allowed     * <p/>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  warning: empty <p> tag     * <p/>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/processors/behaviorprocessorjava  warning: empty <p> tag * <p>   ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/processors/publishprocessorjava  warning: empty <p> tag * <p>   ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/processors/replayprocessorjava  warning: empty <p> tag * <p>   ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/subscribers/defaultsubscriberjava  error: bad use of > *     subscribe(new defaultsubscriber&ltinteger>() {                                                  ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/subscribers/disposablesubscriberjava  error: bad use of > *     subscribewith(new disposablesubscriber&ltinteger>() {                                                         ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/subscribers/resourcesubscriberjava  error: bad use of > *     subscribewith(new resourcesubscriber&ltinteger>() {                                                       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/subscribers/resourcesubscriberjava  error: bad use of > *                 scheduledirect(() -> systemoutprintln(""""time!"""")                                       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/subjects/subjectjava  error: semicolon missing     * &see {@link #hascomplete()}       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observablejava  error: self-closing element not allowed     * <p/>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observablejava  warning: empty <p> tag     * <p/>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/subjects/behaviorsubjectjava  warning: empty <p> tag * <p>   ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/completablejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/maybejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/maybejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/maybejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/maybejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/maybejava  error: self-closing element not allowed     * <p/>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/maybejava  warning: empty <p> tag     * <p/>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/maybejava  error: self-closing element not allowed     * <p/>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/maybejava  warning: empty <p> tag     * <p/>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/subjects/publishsubjectjava  warning: empty <p> tag * <p>   ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/subjects/replaysubjectjava  warning: empty <p> tag * <p>   ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/singlejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/singlejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/singlejava  warning: empty <p> tag     * <p>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/singlejava  error: self-closing element not allowed     * <p/>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/singlejava  error: self-closing element not allowed     * <p/>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/singlejava  error: self-closing element not allowed     * <p/>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/singlejava  error: self-closing element not allowed     * <p/>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/singlejava  error: self-closing element not allowed     * <p/>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/singlejava  error: self-closing element not allowed     * <p/>       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/schedulerjava  error: bad use of >     * scheduler limitscheduler  schedulerscomputation()when(workers -> {                                                                         ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/schedulerjava  error: bad use of >     * scheduler limitscheduler  schedulerscomputation()when(workers -> {                                                                         ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/schedulerjava  error: bad use of >     * scheduler slowscheduler  schedulerscomputation()when(workers -> {                                                                        ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/schedulerjava  error: bad use of >     *  return completableconcat(workersmap(actions -> {                                                       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observers/defaultobserverjava  error: bad use of > *     subscribe(new defaultobserver&ltinteger>() {                                                ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observers/disposablecompletableobserverjava  error: bad use of > *     subscribewith(new disposablemaybeobserver&ltinteger>() {                                                            ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observers/disposablemaybeobserverjava  error: bad use of > *     subscribewith(new disposablemaybeobserver&ltinteger>() {                                                            ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observers/disposableobserverjava  error: bad use of > *     subscribewith(new disposableobserver&ltinteger>() {                                                       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observers/disposablesingleobserverjava  error: bad use of > *     subscribewith(new disposablesingleobserver&ltinteger>() {                                                             ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observers/resourcecompletableobserverjava  error: bad use of > *                 scheduledirect(() -> systemoutprintln(""""time!"""")                                       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observers/resourcemaybeobserverjava  error: bad use of > *     subscribewith(new resourcemaybeobserver&ltinteger>() {                                                          ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observers/resourcemaybeobserverjava  error: bad use of > *                 scheduledirect(() -> systemoutprintln(""""time!"""")                                       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observers/resourceobserverjava  error: bad use of > *     subscribewith(new resourceobserver&ltinteger>() {                                                     ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observers/resourceobserverjava  error: bad use of > *                 scheduledirect(() -> systemoutprintln(""""time!"""")                                       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observers/resourcesingleobserverjava  error: bad use of > *     subscribewith(new resourcesingleobserver&ltinteger>() {                                                           ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observers/resourcesingleobserverjava  error: bad use of > *                 scheduledirect(() -> systemoutprintln(""""time!"""")                                       ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/package-infojava  error: unexpected end tag: </p> * </p> ```"";closing via #5637 || its still open ||;1;0;fixing javadoc warnings;"
"5640;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: additional warnings for frompublisher();this pr adds javadoc warnings for  frompublisher  as people still try to implement a source through it and fail to follow the specification like this:;;0;2x: additional warnings for frompublisher();this pr adds javadoc warnings for `frompublisher` as people still try to implement a source through it and fail to follow the specification like this:```java// dont do this!flowablefrompublisher((subscriber<integer> s) -> sonnext(1))```even though `publisher` is a single abstract method (sam) type it is almost never reasonable to write a source with it that doesnt require a per-subscriber state the example above fails to setup backpressure properly and it didnt call `sonsubscribe()` for that causing `nullpointerexception` whenever the `subscription` would be needed (ie for cancellation and requesting) by the downstream operator`maybe` doesnt have `frompublisher`; merging 5640 ;;;;1;1;""add """"that is"""" to the sentences"";"
5647;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix subscribewith documentation examples;this pr improves a documentation of  subscribewith  functions in  single    maybe    completable  by making sure examples are compilable (by using classes which implement  disposable ).;;5642.0;2x: fix subscribewith documentation examples;this pr improves a documentation of `subscribewith` functions in `single` `maybe` `completable` by making sure examples are compilable (by using classes which implement `disposable`)this should  #5642 in that issue @akarnokd approved my idea to use `disposablemaybeobserver` in the example but as i looked in other classes i noticed that `observablesubscribewith()` documentation uses a `resourceobserver` (which implements `disposable`) so i thought that this is the way to go in all other top-classes?if you think that this is not the case and instead all of them should be switched to use `disposable*observer` in their examples let me know i will do it in this way theni think that all those example should use similar classes;`resourcexobserver` is generally not necessary so `disposablexobserver` should be in the docs ||  merging 5647 ;maybesubscribewith() has incorrect documentation;`maybesubscribewith()` [documentation ]( suggests that it returns a `disposable` and contains this example (translated to kotlin):```kotlin    val source  maybejust(1)    val composite  compositedisposable()    val ms  object : maybeobserver<int> {      //     }    compositeadd(sourcesubscribewith(ms))```this code does not compile because `maybeobserver` does not implement `disposable`should the documentation suggest to use `disposablemaybeobserver` here?if yes i can submit a pr;yes `disposablemaybeobserver` should be there pr welcome || closing as pr got ;1;0;2x: fix subscribewith documentation examples;
5649;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x add concatmapcompletable() to observable;add  concatmapcompletable()  to  observable  as discussed in #4853;;4853.0;2x add concatmapcompletable() to observable;add `concatmapcompletable()` to `observable` as discussed in #4853i didnt think it made sense in other reactive typescode is mostly a copy of `observableconcatmap`  let me know if there is a better style of code to base this off instead  it also does not have the option to delay errors as concatmap() does not sure if that is needed; merging 5649 ;2x: switchmapsingle and switchmapcompletable;heythe addition of `flatmapsingle`/`flatmapcompletable` made the usage of `single` and `completable` way nicer in rxjava 2do you consider adding `switchmapsingle`/`switchmapcompletable` to rxjava 2 as well?cheers;you mean 1x? i have no plans for that and i dont want to keep 1x alive for too long id like to stop enhancing 1x in 6 months and enter it into a bugfix-only mode otherwise 3rd party libraries may delay their upgrade way longer || he wants `switchmapsingle` and `switchmapcompletable` for rxjava 2 just like there is `flatmapsingle` and `flatmapcompletable` || @vanniktech exactly || ah right no plans for extending any other xmap operator || but then `concatmap` also needs the variants in order to be consistent to be honest i forgot about those when proposing `flatmapsingle / flatmapcompletable / flatmapmaybe` initially - #4667 and then theres also `maybe` plus `observable` and `flowable` are able of mapping so its easily another 12 methods- observableswitchmapsingle- observableswitchmapmaybe- observableswitchmapcompletable- observableconcatmapsingle- observableconcatmapmaybe- observableconcatmapcompletable- flowableswitchmapsingle- flowableswitchmapmaybe- flowableswitchmapcompletable- flowableconcatmapsingle- flowableconcatmapmaybe- flowableconcatmapcompletable || if it is not on the roadmap because you dont want to add any more xmap operators then i understandbut if it is due to lack of the time would you consider accepting contributions on the topic? || sure but these operators are not easy || yes i know those are one of the hardest still i will at least have a look and see if i can deliver a prcheers! || any progress on this? || im happy to have a look at this one if @tomaszpolanski doesnt have time at the moment || @davidmoten it would be great! my available time now is pretty limited  || so the list of new operators is quite big currently:* observableswitchmapsingle* observableswitchmapmaybe* observableswitchmapcompletable* observableconcatmapsingle* observableconcatmapmaybe* observableconcatmapcompletable* flowableswitchmapsingle* flowableswitchmapmaybe* flowableswitchmapcompletable* flowableconcatmapsingle* flowableconcatmapmaybe* flowableconcatmapcompletablei imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by one an example would be `observableswitchmapsingle`:```javapublic final <r> observable<r> switchmapsingle(    final function<? super t ? extends singlesource<? extends r>> mapper) {        function<? super t observable<r>> mapper2  t ->             {                singlesource<? extends r> source  mapperapply(t)                single<? extends r> single                if (source instanceof single) {                    single  (single<? extends r>) source                } else {                    single  singleunsafecreate(source)                }               return (observable<r>) singletoobservable()            }        return switchmap(mapper2 buffersize())    }```this is just to demo the idea i wouldnt use an anonymous class and lambdas are just used for readability@akarnokd any interest in this? || > i imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by oneindeed> an example would beif you do this there is an unwritten guideline that the main base types should have no (anonymous) inner classes it helped me a lot before not having to deal with flowable$1$2 and similar entries the go-to place for these are in `ioreactivexinternaloperatorsflowableflowableinternalhelper` and its respective variants> any interest in this?im more interested in the direct implementations but at least the overall usefullness of the api extension could be vetted || >if you do this there is an unwritten guideline that the main base types should have no (anonymous) inner classes it helped me a lot before not having to deal with flowable$1$2 and similar entries the go-to place for these are in ioreactivexinternaloperatorsflowableflowableinternalhelper and its respective variantsyep no problems ive appreciated consistent naming of non-anon classes inside operators for debugging purposes and code searches too>im more interested in the direct implementations but at least the overall usefullness of the api extension could be vettedsure ill proceed with prs with unit tests for the new operators and im happy to have a stab at dedicated operators after that || what is expected behaviour for `observableswitchmapmaybe` and `observableswitchmapcompletable`? i can try to take care of it but i am not convinced what that method should return || in the mean time would it be correct to assume that an acceptable workaround for this is as follows?: **toobservable()**```upstreamconcatmap {        someobservable()collect{}toobservable()    }``` || @feresr probably yes at this moment in few places inside my code i have this type of stucture it is very weird and uncessesery code but it is understandable@akarnokd what do you think about method switchmapcompletable which emit object or maybe some enum? on the other hand we can we can swallow information about stream and do not emit anything || @marcinsus i dont fully understand your question use `switchmapcompletable()andthen(single)` to emit something after the switch completed || the problem he talks about is that switchmapcompletable does not exist switchmapsingle returns an observable of the single typeso technically switchmapcompletable should return void (which it cant because that has no instance) so he asks if the signature should rather expose some `enum nothing` or just an `object` || an `observableswitchmapcompletable` should return `completable` || you are right as `flatmapcompletable` returns a `completable`but now i find it weird that `observableflatmapsingle<t>`returns an `observable<t>`but `observableflatmapcompletable` returns an `completable` || a stream of 5 elements flatmapd to a stream of a single element still results in a stream of 5 elements || im working on implementing `concatmapcompletable` across the reactive typesim wondering if the library should also have implementations of`concatmapdelayerrorcompletable` `concatmapeagercompletable` `concatmapeagerdelayerrorcompletable`? || `concatmapeagercompletable` is indistinguishable from `flatmapcompletable` because all sources run concurrently and their only output is a terminal event no items have to be buffered until their turn also the `maxconcurrency  1` gets you `concatmapcompletable` behavior || ahh yes that makes sense  so is there any reason to implement `concatmapcompletable` at all?  if so do you want it to just use flatmapcompletable() internally or should there be a new direct implementation (what ive been working on)? || actually `observableflatmapcompletable` doesnt have `maxconcurrency` overload thus there might be a reason to implement `concatmapcompletable` || ok ill keep at it then ||  anything ever come of this?  || #5161 and #5649 added some operators || so there are plans to implement the other operators but not in any particular timeframe? || the listed operators can simply expressed with the existing default operators and `toobservable`/`toflowable` in the lambda parameters unfortunately very few people could or are willing to write them in an optimized and inlined fashion - which would add more value to the library than a simple lambda-rewriting function imagine you have to write a proper javadoc with a marble diargram and several hundred lines of unit tests to validate and cover a new operator with some 3 lines of code kotlins extension methods really shine in allowing interested parties to define such convenience functions locally to their project and not boomeranging such features through the rxjava library the issue is left open in case somebody really wants to take the time and effort to contribute but as the core developer im not particularly interested myself in tackling these types of operators || closing via #5870 #5871 #5872 #5873 #5875 ||;1;0;add experimental annotation and change prefetch to capacityhint;
5651;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: update obs.just(2..10) & switchonnextdelayerror marbles;this pr updates the marble diagrams of the 2..10 argument  observable.just()  and two overloads of  observable.switchonnextdelayerror .;;0;2x: update obsjust(210) & switchonnextdelayerror marbles;this pr updates the marble diagrams of the 210 argument `observablejust()` and two overloads of `observableswitchonnextdelayerror`images in [issue 5319](https://githubcom/reactivex/rxjava/issues/5319#issuecomment-335124895); merging 5651 ;;;;1;1;2x: update obsjust(29) & switchonnextdelayerror marbles;
5652;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: inline disposability in obs.concatmap(completable);the inner  observer  type and the  sequentialdisposable  of the  concatmap  and  concatmapcompletable  can be combined into a single instance  saving on indirection and allocation.;;0;2x: inline disposability in obsconcatmap(completable);the inner `observer` type and the `sequentialdisposable` of the `concatmap` and `concatmapcompletable` can be combined into a single instance saving on indirection and allocation(ive noticed this when reviewing #5649); merging 5652 ;;;;1;1;2x: inline disposability in obsconcatmap(completable);
"5660;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: fix timeout (timed  selector) unsubscribe bug;this pr fixes an unsubscribe bug somewhere in the timed  timeout  operator reported in #5657 by implementing it in a algorithmically fresh manner.;;5657.0;1x: fix timeout (timed selector) unsubscribe bug;this pr fixes an unsubscribe bug somewhere in the timed `timeout` operator reported in #5657 by implementing it in a algorithmically fresh manner; merging 5660 ;rxjava 13 -- timeout not unsubscribing from original observable;""version -- 130 (did not see any release notes in the subsequent 13x releases about this)not sure if this is the expected behavior or not but when i use the operator:```timeout(long timeout timeunit timeunit observable<? extends t> other)```it seems that if the timeout occurs and we switch to mirroring the `other` observable the operator does not unsubscribe from the original observable  based on the documentation i was expecting that this would essentially execute a """"switch"""" like behavior which would result in the original observable being unsubscribedhere is some code that demonstrates what im seeing:```        subject<long long> subject  publishsubjectcreate()        observable<long> initialobservable  subjectshare()map(value -> {            systemoutprintln(""""received value """" + value)            return value        })        observable<long> timeoutobservable  initialobservablemap(value -> {           systemoutprintln(""""timeout received value """" + value)           return value        })        testsubscriber<long> subscriber  new testsubscriber<>()        initialobservabletimeout(1 timeunitseconds timeoutobservable)subscribe(subscriber)        subjectonnext(5l)        threadsleep(1500)        subjectonnext(10l)        subjectoncompleted()        subscriberawaitterminalevent()        subscriberassertnoerrors()        subscriberassertvalues(5l 10l)```here is the output:```received value 5received value 10received value 10timeout received value 10```i was only expecting one `received value 10`"";inserting `thisunsubscribe()` before line 200 in `operatortimeoutbase` gives me the behavior i was expecting  of course im not enough of an rxjava internals expert to know what other less desirable side effects this might have (though naively it seems that once the timeout subscriber marks itself as terminated it pretty much gets out of the way) || thanks for reporting this seems to be a bug somewhere in that operator which i cant pinpoint the 1x architecture is awkward see #5660 for the proposed fix || closing via #5660 ||;1;0;fix timeout(selector) variant;"
5661;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: improve flowable.timeout();this pr improves the internal overhead of the  flowable.timeout  operator (its 2 timed and 2 selector-based versions) to use the adapted [indexed atomic state transition approach](http://akarnokd.blogspot.hu/2017/09/java-9-flow-api-timing-out-events.html).;;0;2x: improve flowabletimeout();this pr improves the internal overhead of the `flowabletimeout` operator (its 2 timed and 2 selector-based versions) to use the adapted [indexed atomic state transition approach]( addition there was a race condition and potential event loss in `testscheduler`: - `peek()` could return `null` if the task was removed from the queue (via disposing it) between the `isempty()` check and `peek()` itself - in addition if the task was disposed between the `peek` and `remove` the `remove` could remove the new head of the queue which is no longer what `peek` saw and results in tasks being dropped; merging 5661 ;;;;1;1;dont read the volatile twice;
5668;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix a misleading documentation of observable.singleelement();this pr improves the documentation of  observable.singleelement()   as mentioned in  https://github.com/reactivex/rxjava/issues/5317.;;0;fix a misleading documentation of observablesingleelement();this pr improves the documentation of `observablesingleelement()` as mentioned in   appropriate unit test to verify the `empty` behaviour already exist (`observablesingletest testsinglewithempty()`) i just added one more check there to make it very explicit that an error is not thrownas a side note im attaching an updated marble diagram for the method that includes all 3 states of the resulting maybe (empty success error) i believe this is listed in https://githubcom/reactivex/rxjava/issues/5319![singleelement](https://user-imagesentcom/4089934/31583261-a6da996a-b18f-11e7-8682-dffa647c7e4apng); merging 5668  < ;;;;1;1;update the marble diagram of observablesingleelement();
5669;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix publishprocessor cancel/emission overflow bug;this pr should fix the bug that caused the test failure in #5545.;;5545.0;2x: fix publishprocessor cancel/emission overflow bug;this pr should fix the bug that caused the test failure in #5545the bug manifested itself when a cancellation was happening the same time a request 1 was being fulfilled since the same request accounting was used for cancellation indicator if the cancel happened between the `onnext()`s `get()` check and `decrementandget` this `decrementandget` decremented longmin_value unconditionally which lead to a state that would appear the subscriber still can receive events a concurrent `offer` which saves the current array of registered `subscriber`s then would emit an item and overflow the `subscriber`the fix is to use the cancellation-aware `backpressurehelperproducedcancel()` utilityunit test were added to verify the correct behavior on both `publishprocessor` and `behaviorprocessor` (the latter uses different cancellation mechanism via a dedicated field); merging 5669 ;2x: publishprocessoraspublishertcktest failed;> ioreactivextckpublishprocessoraspublishertcktest failed>    javalangassertionerror: publisher signalled [16] elements which is more than the signalled demand: 15 > expected [true] but found [false]probably due to one of the resource leaks in the 100 tck;closing as tck 101 seems to have resolved this type of problem || it has reoccurred:  || closing via #5669 ||;1;0;2x: fix publishprocessor cancel/emission overflow bug;
"5673;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: coverage  add singletoflowabletest;add  singletoflowabletest  to cover toflowable with test.;;0;2x: coverage add singletoflowabletest;""add """"singletoflowabletest"""" to cover toflowable with test"";"" merging 5673  "";;;;1;1;2x: coverage add singletoflowabletest;"
5675;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add publishprocessor jmh perf comparison;this pr adds a perf class to measure the overhead of request management inside  publishprocessor  and a comparison with  publishsubject .;;0;2x: add publishprocessor jmh perf comparison;this pr adds a perf class to measure the overhead of request management inside `publishprocessor` and a comparison with `publishsubject`note that running jmh with rxjava under windows is currently not possible because gradle adds so many of its own jar dependencies that the resulting command line classpath exceeds the 32k limitresults with 215 release (separate gradle project windows 7 i7 4790 java 8u144)( bounded benchmark indicates a 4x the throughput for some reason i dont understand yet; merging 5675 ;;;;1;1;2x: add publishprocessor jmh perf comparison;
"5677;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: make parallel() a fusion-async-boundary;the  parallel()  supports front-fusion but since the operator is almost always followed by the separate  runon  operator  the parallel version of the  observeon  operator  such front-fusion should be considered a  boundary -type fusion just like with  observeon .;;5676.0;2x: make parallel() a fusion-async-boundary;the `parallel()` supports front-fusion but since the operator is almost always followed by the separate `runon` operator the parallel version of the `observeon` operator such front-fusion should be considered a `boundary`-type fusion just like with `observeon` a `requestfusion` with `boundary` tells the upstream operator(s) that when fused their actions would be executed behind an async boundary and possibly on an unwanted thread operators such as `map` and `doonnext` who are generally expected to be thread-confined can then refuse to fuse restoring the traditional queue hopping behavior (`source -> queue -> op -> queue -> op -> queue -> consumer`)reported in #5676/cc @smaldini & @simonbasle; merging 5677  < ;observeon on flowablerangelong does not emit values on provided scheduler;""operators fusion  in rxjava 2 is a really nice feature but i have found a case when an implementation of flowablerangelong (and i assume there is similar behavior in neighbor standard flowables) fused together with operator observeon() breaks the semantics of the operator observeon()basically no emissions from flowablerangelong flowable is done on the scheduler provided in observeon() but rather on the thread which calls request() in the chainhere is the code snipped which reproduces the issue```javaimport ioreactivexflowableimport ioreactivexflowablesubscriberimport ioreactivexpluginsrxjavapluginsimport ioreactivexschedulersschedulersimport orgreactivestreamssubscriptionpublic class rxjavafusetest {    public static void main(string args) {        flowablesubscriber sequentialsubscriber  new flowablesubscriber() {            private subscription s            @override            public void onsubscribe(subscription s) {                thiss  s                thissrequest(1)            }            @override            public void onnext(object x) {                srequest(1)            }            @override            public void onerror(throwable e) {                eprintstacktrace()                systemexit(0)            }            @override            public void oncomplete() {                systemoutprintln(""""completed"""")                systemexit(0)            }        }        flowablerangelong(0 10)                observeon(rxjavapluginscreatesinglescheduler(r -> new thread(r """"producer"""")) false 1)                doonnext(along -> {                    systemoutprintln(along + """" emitting on """" + threadcurrentthread()getname())                })                parallel(2 1)                runon(schedulerscomputation() 1)                doonnext(along -> systemoutprintln(along + """" processing on """" + threadcurrentthread()getname()))                sequential()                subscribe(sequentialsubscriber)    }}```output is as follows:```0 emitting on main0 processing on rxcomputationthreadpool-11 emitting on main2 emitting on main1 processing on rxcomputationthreadpool-22 processing on rxcomputationthreadpool-13 emitting on main4 emitting on main3 processing on rxcomputationthreadpool-25 emitting on rxcomputationthreadpool-25 processing on rxcomputationthreadpool-24 processing on rxcomputationthreadpool-16 emitting on rxcomputationthreadpool-27 emitting on rxcomputationthreadpool-26 processing on rxcomputationthreadpool-27 processing on rxcomputationthreadpool-18 emitting on rxcomputationthreadpool-29 emitting on rxcomputationthreadpool-28 processing on rxcomputationthreadpool-29 processing on rxcomputationthreadpool-1completed```maybe i dont get something and have not read documentation carefully enough but to me it looks like the fusion between operators breaks semantics of observeonmoreover while digging in the source code of related classes in rxjava i have found suspicious code in the flowablerangelongbaserangesubscriptionpoll() method: its potentially can be called from different threads but field """"index"""" is not guarded anyhow from contended access so can produce wrong values if instructions reordering or caching is in place on a processor"";""forgot to mention: its about latest release 215 and i cant reproduce it  without going parallel() || hion one hand using `observeon` to pin such source to a particular thread is not the right operator if you use `subscribeon` the correct emission thread is encountered in `doonnext`on the other hand preventing fusion via `hide()` before `parallel` can get the desired thread confinement effect ill post a fix to `parallel` indicating it is expected to be an async boundary so thread-sensitive operators such as `doonnext` wont fuse || aha that makes sense thanks for the clarification! || see #5677 for the fix || many thanks for your quick reaction!does it make any sense what i have written at the bottom of my original message about possible memory visibility issues with flowablerangelongbaserangesubscriptionindex field being modified in poll()? or poll() is supposed to be called in a sync mode only? || the `queuesubscription` interface [defines]( the access mode `poll` is called in a sequential manner so index update is not a problemclosing via #5677 || yes it does but it doesnot say it cannot be called from different threads so isnt it essential to add volatile keyword to it? || the term """"sequential manner"""" means that if multiple threads would call `poll` they have to take turns and do such calls in a non-overlapping manner ensuring visibility of changes `poll` made in `observeon` the `poll` is called from the guaranteed one thread at once drain loops || well but java memory model has quite specific memory visibility guarantees and without volatile keyword instruction reordering and caching can lead to inconsistent state of index variable vidible to other thread calling it right after another yes with correct behavior of observeon its not an issue at all bit in other rare cases it could be isnt it? in fact i am noy using flowablerange in production code and used it to give an example and its the way i learn rxjava 2 after couple of years living with version 1 :) || the parent queue interface was designed after the single-producer-single-consumer queues like those in jctools there the requirement is that `poll` is called from a single thread at a time and the fused """"queues"""" must honor this requirement since `index` in fused mode is only updated from within `poll` and poll is serialized by a pair of full barrier atomic add operations any change to index will be written back into memory before an atomic decrement and read from it after the atomic increment of the drain loop it works just the same as the non-fused `request` execution where the atomic transition from 0 to n is guaranteed to happen only to one thread and the atomic transition attempt from n back to 0 will enable a subsequent thread to do the 0 to n transition again when doing the 0 to n transition the next operation is to read the index and when doing n to 0 the prior operation is to write back the index the full barriers of the atomics will make sure the change to index is visible to the next threadon rare cases such as the `testsubscriber` `poll` is called from within `onnext` and `onnext` is required by the reactive-streams spec to be serialized the very same manner as `poll` requires it || i do appreciate your detailed explanationsi think i need to learn deeper memory barrier behavior for java volatiles and cache coherency protocolsi was convinced that writing volatile variable leads to invalidation of corresponding individual cache lines and forbidding certain instruction reordering which not necessarily means ensuring volatile writes to other locally used non-volatile variables so each of them has to be marked as volatile to ensure inter-thread visibility guarantees || "";1;0;2x: make parallel() a fusion-async-boundary;"
5680;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: more observable marble fixes (10/18);update several  observable  marble diagrams. images can be viewed [here](https://github.com/reactivex/rxjava/issues/5319#issuecomment-337563753).;;0;2x: more observable marble fixes (10/18);update several `observable` marble diagrams images can be viewed [here]( `zipiterable`- `ambwith`- `blockingforeach`- `blockingiterable`- `blockinglast`- `blockinglast(t)`- `blockingmostrecent`- `blockingnext`- `blockingsingle`- `blockingsingle(t)`- `cachewithinitialcapacity`; merging 5680 ;;;;1;1;2x: more observable marble fixes (10/18);
5683;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add tck test for limit();this pr adds a reactive-streams tck test for  limit()  .;;0;2x: add tck test for limit();this pr adds a reactive-streams tck test for `limit()`; merging 5683 ;;;;1;1;2x: add tck test for limit();
5695;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix completable.concat to use replace (don t dispose old);completable.andthen    concat(iterable)  and  concatarray()  disposed the previous  disposable  when receiving the new  disposable  from the next source which could lead to interruption.  concat(publisher)  already uses  replace  instead of  update .;;0;2x: fix completableconcat to use replace (dont dispose old);`completableandthen` `concat(iterable)` and `concatarray()` disposed the previous `disposable` when receiving the new `disposable` from the next source which could lead to interruption `concat(publisher)` already uses `replace` instead of `update`there is a peculiar interplay between `subscribeon` `observeon` and the trampoline in `concat` which can trigger such an interruption: the task of the `observeon` is cancelled with `mayinterruptifrunning  true` because the `dispose` call chain shuts down the worker of the `observeon` from the `subscribeon`s threadreported in #5694; merging 5695 ;;;;1;1;remove comments from original issue report;
"5696;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: fix completable.concat to use replace (don t dispose old);fixes the same bug as with the 2.x  completable.andthen  and  completable.concat .;;5694.0;1x: fix completableconcat to use replace (dont dispose old);fixes the same bug as with the 2x `completableandthen` and `completableconcat`see #5694 & #5695; merging 5696 ;observeon unsubscribes child observables/interrupts the thread;""hithe following test shows the use of `observeon` in an observable chain interrupts the thread cancelling child observables    import orgjunittest    import rxcompletable    import rxschedulersschedulers    import javautilconcurrentcountdownlatch    public class interrupttest {        @test        public void testinterrupt() throws interruptedexception {           final int count  1000           countdownlatch latch  new countdownlatch(count)            for (int i  0 i < count i++) {                completablecomplete()                    subscribeon(schedulersio())                    observeon(schedulersio()) // the problem does not occur if you comment out this line                    andthen(completablefromaction(() -> {                        try {                            threadsleep(3000)                        } catch (interruptedexception e) {                            systemoutprintln(""""interrupted!"""") // this is output periodically                        }                    }))                    subscribe(() -> latchcountdown())            }            latchawait()            testinterrupt()        }    }the sleep is interrupted periodically printing """"interrupted!"""" while the test is running the problem does not occur when the `observeon` line is commented outweve tested this in rxjava 132 and 216 with the same results"";`andthen` and `concat` dispose the previous sources - which is unnecessary on its own - and thus a particular timing may cause the worker of the io `scheduler` to be disposed while it is serving the second `completable` || fix in #5695 || hi @akarnokd thanks for the fast response is there any chance we can get this  in 1x as well? || yes but it may take an additional week to have it released besides we would like to encourage people to switch to v2 as its only 6 months till rxjava 1x end-of-life || closing via #5696 ||;1;0;remove original issue comments;"
5705;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: moved tests to fromcallabletest from fromcompletabletest;5698. there was a test class named  observablefromcompletabletest  which actually was targeting  observablefromcallabletest . this was most likely just a naming issue. copied all tests from  observablefromcompletabletest  to  observablefromcallabletest  and deleted the former class.;;5698.0;2x: moved tests to fromcallabletest from fromcompletabletest;5698 there was a test class named `observablefromcompletabletest` which actually was targeting `observablefromcallabletest` this was most likely just a naming issue copied all tests from `observablefromcompletabletest` to `observablefromcallabletest` and deleted the former class; merging 5705 ;2x: improper class name of observablefromcompletabletest;the class `ioreactivexinternaloperatorsobservableobservablefromcompletabletest` only tests `observablefromcallable` why the class name is **completable**?;probably just a misnamed test file would you like to fix it? || because there already had a class `ioreactivexinternaloperatorsobservableobservablefromcallabletest`so what the new name you recommend?or just merge the test cases into `observablefromcallabletest`? || just copy over the test methods ||;1;0;moved tests to fromcallabletest from fromcompletabletest;
"5706;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove mentions of main thread from schedulers.single() javadoc.;to avoid confusion.;;0;remove mentions of main thread from schedulerssingle() javadoc;""to avoid confusion one could think that `single()` can be used to execute code on """"main"""" thread""; merging 5706 ;;;;1;1;remove mentions of main thread from schedulerssingle() javadoc;"
5709;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: improve javadocs of flatmapsingle and flatmapmaybe;clarify that  flatmapsingle  and  flatmapmaybe  merge in no particular order and fix the copy-paste error from  flatmapcompletable  as they have values to merge  not just waiting.;;0;2x: improve javadocs of flatmapsingle and flatmapmaybe;clarify that `flatmapsingle` and `flatmapmaybe` merge in no particular order and fix the copy-paste error from `flatmapcompletable` as they have values to merge not just waitingrelated: [stackoverflow question](https://stackoverflowcom/questions/47176437/rxjava-2-observable-flatmapsingle-clarification); merging 5709  < ;;;;1;1;2x: improve javadocs of flatmapsingle and flatmapmaybe;
5713;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: basetestconsumer values() and errors() thread-safety clarifications;this pr adds clarifications to the  basetestconsumer.values()  and  basetestconsumer.errors()  method in regard to accessing elements while the upstream is still actively emitting events.;;0;2x: basetestconsumer values() and errors() thread-safety clarifications;this pr adds clarifications to the `basetestconsumervalues()` and `basetestconsumererrors()` method in regard to accessing elements while the upstream is still actively emitting eventsrelated discussion: #5712; merging 5713  < ;;;;1;1;2x: basetestconsumer values() and errors() thread-safety clarifications;
5715;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: distinguish between sync and async dispose in scheduledrunnable;this pr adds logic to distinguish between synchronous and asynchronous dispose calls when  setfuture  is executing. it should prevent interrupting the currently running task body if it requested cancellation indirectly before the  setfuture  was executed by the thread which scheduled the task.;;0;2x: distinguish between sync and async dispose in scheduledrunnable;this pr adds logic to distinguish between synchronous and asynchronous dispose calls when `setfuture` is executing it should prevent interrupting the currently running task body if it requested cancellation indirectly before the `setfuture` was executed by the thread which scheduled the task5711; merging 5715 ;;;;1;1;add test case for the parent-done reordered check;
5717;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: javadocs: add period to custom scheduler use sentences;there were missing  .  from sentences in the operator javadocs detailing certain overloads use custom  scheduler s.;;0;2x: javadocs: add period to custom scheduler use sentences;there were missing `` from sentences in the operator javadocs detailing certain overloads use custom `scheduler`s; merging 5717 ;;;;1;1;2x: javadocs: add period to custom scheduler use sentences;
"5718;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add a sentence to documentation of take() operator.;#5716;;5716.0;2x: add a sentence to documentation of take() operator;#5716; merging 5718 ;oncomplete() is not getting called on the specified scheduler;""when i use `observabletake(time timeunitseconds)` if the result observable stops due to timeout `oncomplete()` callback gets called on `computation` thread  not the one that ive specified with `observeon()`here is a sample code:```observablejust(""""one"""" """"two"""")        observeon(schedulersio())        take(0 timeunitseconds)        subscribe(new observer<string>() {            @override public void onsubscribe(disposable d) {                systemoutprintln(""""onsubscribe() thread: """" + threadcurrentthread()getname())            }            @override public void onnext(string s) {                systemoutprintln(""""onnext() thread: """" + threadcurrentthread()getname())            }            @override public void onerror(throwable e) {                systemoutprintln(""""onerror() thread: """" + threadcurrentthread()getname())            }            @override public void oncomplete() {                systemoutprintln(""""oncomplete thread: """" + threadcurrentthread()getname())            }        })```and as the result youll get `oncomplete thread: rxcomputationthreadpool-1`if its required for all callback methods to run on the specified thread per reactive specifications this would be a bug and it happens on both rxjava 1x and 2x"";`observeon` lasts until the next async operator in this case [take]( you can [specify]( the scheduler where `take` will time out alternatively you can swap `take` and `observeon` so events will end up on the desired thread || yeah i looked into the code and figured whats causing that however i believe this is kinda inconsistent behavior (and probably wrong) since all `onnext()` calls are running on the specified scheduler and all of the sudden `oncomplete()` runs on another threadat least we should have this behavior documented its not known that `take()` **might** change thread for some callbacks! (`onerror` is also possible to run on `computation`) || i also looked into the source code and figured why this is happening here is my quick (and probably naive!) fix that i did to just test my idea about the source of this issuei added an `if` to `observabletake()````public final observable<t> take(long time timeunit unit) {  if (this instanceof observableobserveon)     return takeuntil(timer(time unit))observeon(((observableobserveon) this)scheduler)  else     return takeuntil(timer(time unit))}``` || the operator behaves and expected if the upstream completes before the time runs out those events will be delivered on the upstreams thread if there is a timeout which is scheduled by a different scheduler the  terminal event will be delivered on that other thread if you want to ensure events are delivered on the desired thread apply `observeon` just before thatif you want you can create a pr wich add a clause to the relevant operators javadoc (in both `observable` and `flowable` which explicitly states the completion triggered by the timeout may come from a different thread (depending on the scheduler used) than the items came from || alright ill add it to doc || closing via #5718 and #5719 ||;1;0;rephrase java doc for take() method;"
"5719;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;1.x: add a sentence to documentation of take() operator;#5716;;5716.0;1x: add a sentence to documentation of take() operator;#5716; merging 5719 ;oncomplete() is not getting called on the specified scheduler;""when i use `observabletake(time timeunitseconds)` if the result observable stops due to timeout `oncomplete()` callback gets called on `computation` thread  not the one that ive specified with `observeon()`here is a sample code:```observablejust(""""one"""" """"two"""")        observeon(schedulersio())        take(0 timeunitseconds)        subscribe(new observer<string>() {            @override public void onsubscribe(disposable d) {                systemoutprintln(""""onsubscribe() thread: """" + threadcurrentthread()getname())            }            @override public void onnext(string s) {                systemoutprintln(""""onnext() thread: """" + threadcurrentthread()getname())            }            @override public void onerror(throwable e) {                systemoutprintln(""""onerror() thread: """" + threadcurrentthread()getname())            }            @override public void oncomplete() {                systemoutprintln(""""oncomplete thread: """" + threadcurrentthread()getname())            }        })```and as the result youll get `oncomplete thread: rxcomputationthreadpool-1`if its required for all callback methods to run on the specified thread per reactive specifications this would be a bug and it happens on both rxjava 1x and 2x"";`observeon` lasts until the next async operator in this case [take]( you can [specify]( the scheduler where `take` will time out alternatively you can swap `take` and `observeon` so events will end up on the desired thread || yeah i looked into the code and figured whats causing that however i believe this is kinda inconsistent behavior (and probably wrong) since all `onnext()` calls are running on the specified scheduler and all of the sudden `oncomplete()` runs on another threadat least we should have this behavior documented its not known that `take()` **might** change thread for some callbacks! (`onerror` is also possible to run on `computation`) || i also looked into the source code and figured why this is happening here is my quick (and probably naive!) fix that i did to just test my idea about the source of this issuei added an `if` to `observabletake()````public final observable<t> take(long time timeunit unit) {  if (this instanceof observableobserveon)     return takeuntil(timer(time unit))observeon(((observableobserveon) this)scheduler)  else     return takeuntil(timer(time unit))}``` || the operator behaves and expected if the upstream completes before the time runs out those events will be delivered on the upstreams thread if there is a timeout which is scheduled by a different scheduler the  terminal event will be delivered on that other thread if you want to ensure events are delivered on the desired thread apply `observeon` just before thatif you want you can create a pr wich add a clause to the relevant operators javadoc (in both `observable` and `flowable` which explicitly states the completion triggered by the timeout may come from a different thread (depending on the scheduler used) than the items came from || alright ill add it to doc || closing via #5718 and #5719 ||;1;0;rephrase java doc for take() method;"
"5721;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x : rename variable name  subject  to  processor  for exact expression;rename variable name  subject  to  processor  in processor pacakage;;0;""2x : rename variable name """"subject"""" to """"processor"""" for exact expression"";""rename variable name """"subject"""" to """"processor"""" in processor pacakage""; merging 5721 ;;;;1;1;""2x : rename variable name """"subject"""" to """"processor"""" for exact expression"";"
5723;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove duplicate nullity check line from observable.tomap();small cleanup to remove duplicate nullity check line from  observable#tomap;;0;remove duplicate nullity check line from observabletomap();small cleanup to remove duplicate nullity check line from `observable#tomap`; merging 5723 ;;;;1;1;remove duplicate nullity check line;
"5729;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: implement as();this implement  as()  support as discussed in #5654;;5654.0;2x: implement as();this implement `as()` support as discussed in #5654i took the opportunity to try to standardize the docs and tests for it (which vary a little bit across implementations of `to()`)related: #5654;""let me know if you want to add more tests some usages of `to()` were mixed in other tests and wasnt sure if they were specifically targeting testing it || im not sure i understand the remaining ci errors as the parameters have the nonnull annotation || some style checks failed:  add `as` to `parallelflowable`please add a unit test that has a converter class which combines all interfaces and is applied to the 6 types of sources || could you explain what the style checks fix is? i didnt quite understand the message in the log || parallelflowable - 8adb583started on more converter tests in `convertertest` in c1f26ee composite converter test is in there only thing im stuck on is the `genericssignaturetest` tests (borrowed from `transformerstest`) currently they dont compile but im not sure what the goal is (or if it even makes sense to match the checks `transformerstest` does) let me know what you think || you have to extend the `paramvalidationcheckertest` with instances of your new converter types put something like the following into l562```javadefaultvaluesput(observableconverterclass new observableconverter() {    @override public object apply(observable o) { return o }})``` || as for [these]( you are using the wrong generic types~~`observableconverter<a<t ?> b<t>>` is applied to `observable<integer>` in the test where `integer` is unrelated to `a<t ?>`~~i overlooked the test using `a` ill check code locally || the wildcard definition in those compile errors and the wrong `<integer>` parameter confuses the compiler i suggest going raw-types with these converters and using `suppresswarnings({""""unchecked"""" """"rawtypes""""})` on the problematic tests || posted a [patch]( for your pr ||  merging 5729  "";3x: proposal: `observableconverter` interface and friends;for the `compose()` operators `observabletransformer` was introduced to allow for classes to implement multiple transformer interfaces for composite implementations id like to propose doing the same for the `to()` operator by introducing `observableconverter` (and corresponding ones for others)  this would allow for composite converters as wellif youre open to this i can contribute a pr!;""that would break binary compatibility and otherwise `to(function<? super observable<t> r>)` isnt that much of a type mess as `lift` or `compose` is || this would be an alternative to not a replacement for im not sure what type mess means the larger issue is that you cant have something implement `function` multiple times with different generics || a `to` overload will lead to type ambiguity when one writes `to(f -> somefunc(f))` || ah good point would you be against a different name? like `convertto`? or would this be more of an rxjava 30 discussion? || yes 3x api cleanup can include this type of change i otherwise always have separate converters for the base reactive classes/cc @jakewharton @vanniktech @artem-zinnatullin  || i remember we had the discussion about `to()` already in 200-rc days the closed i could find is -  - if i recall correctly it was decided to not change the `to` operator i dont have a strong opinion about changing it in 3x though || in general id like rxjava to have as less interfaces as possible especially if generic ones like `function` can be used insteadbut java limitations kinda force us to have them here so im ok if 3x will have dedicated `*converter` interfaces || retagged as 3x || id like to lean on this for a 2x consideration again seeing as 3x discussion seems to be settling on """"not necessary anytime soon"""" proposal to protect against ambiguity would be to add a new `convert` or `convertto` method which retains the semantics while introducing the new interfaces to allow for compositionthe old `to()` methods could optionally be deprecated too to avoid confusion || project reactor chose the `as()` [naming]( its short which i like and could be added without deprecating `to````javapublic <r> r as(observableconverter<t r> converter)public <r> r as(flowableconverter<t r> converter)public <r> r as(singleconverter<t r> converter)public <r> r as(maybeconverter<t r> converter)public <r> r as(completableconverter<r> converter)``` || i like it! should i send a pr? || sure || done in #5729 || this has to be still resolved in 3x where i suggest having only `to()` with the custom interfaces just introduced || sounds good || hi guys i have a concern which related to this ticket here is my code:  ```    inline fun <reified t> withschedulers(subscribeon: scheduler observeon: scheduler): t {        when (t::class) {            flowabletransformer::class -> return flowabletransformer<any any> {                itsubscribeon(subscribeon)observeon(observeon)            } as t            observabletransformer::class -> return observabletransformer<any any> {                itsubscribeon(subscribeon)observeon(observeon)            } as t            singletransformer::class -> return singletransformer<any any> {                itsubscribeon(subscribeon)observeon(observeon)            } as t            completabletransformer::class -> return completabletransformer {                itsubscribeon(subscribeon)observeon(observeon)            } as t            maybetransformer::class -> return maybetransformer<any any> {                itsubscribeon(subscribeon)observeon(observeon)            } as t        }        throw illegalargumentexception(""""not a valid transformer type"""")    }```are there any ways to reduce the boilerplate code? or any better approaches to achieve this? or just write 5 functions for 5 types something like `to` operator above? closing via #6514 || "";1;0;use test() helpers;"
5734;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: rxjavaplugins unwraprunnable;hi;;0;2x: rxjavaplugins unwraprunnable;hirxjava2 version: [216]it is reference to https://githubcom/reactivex/rxjava/issues/5733; merging 5734 ;;;;1;1;2x: rxjavaplugins unwraprunnable;
5738;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix javadoc for connectableflowable and others;some javadoc fixes for connectableflowable  groupedflowable and flowableautoconnect;;0;2x: fix javadoc for connectableflowable and others;some javadoc fixes for connectableflowable groupedflowable and flowableautoconnect; ;;;;1;1;correct javadoc for connectableflowable groupedflowable flowableautoconnect;
5740;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: marbles for observable all  frompublisher  ziparray;this pr adds a marble diagram to  frompublisher  and updates the marbles of  all  and  ziparray  inside  observable .;;5319.0;2x: marbles for observable all frompublisher ziparray;this pr adds a marble diagram to `frompublisher` and updates the marbles of `all` and `ziparray` inside `observable`the images can be seen in [this comment]( of #5319; merging 5740 ;2x: observable missing or incorrect images (tracking issue);-  [observablesingleorerror()]( there is no default value and an empty source should result in an error-  `observablecombinelatestdelayerror(observablesource function)`: missing diagram-  `observablecombinelatestdelayerror(function int observablesource)`: missing diagram-  `observableconcatarrayeager`: missing diagram-  `observableerror`: should include the x in the operator body indicating it as being the parameter/return value-  `observablefromfuture`: the operator name in the box-  `observablefromiterable`: the operator name in the box-  `observablefrompublisher`: missing diagram-  `observablejust`: the element should be a parameter inside the box such outside elements imply a subject type external push-  `observablejust(t t)` +7: optionally tailor the diagram to the actual number of arguments plus move the constant values inside the box- [x] `observablerangelong`: the operator name in the box- [x] `observableswitchonnextdelayerror`: the operator name in the box indicator of an error getting delayed- [x] `observableziparray`: indicate there is a function instead of implying the output is an array containing one element from each source- [x] `observablezipiterable`: the operator name in the box- [x] `observableall`: example of a false result- [x] `observableambwith`: the operator name in the box- [x] `observableblockingfirst`: missing diagram- [x] `observableblockingforeach`: the operator name in the box- [x] `observableblockingiterable`: the operator name in the box indicate that blocking may happen for each element- [x] `observableblockinglast`: the operator name in the box- [x] `observableblockinglast(t)`: the operator name in the box indicate default in the box fix labels- [x] `observableblockinglatest`: missing diagram- [x] `observableblockingmostrecent`: the operator name in the box- [x] `observableblockingnext`: the operator name in the box- [x] `observableblockingsingle`: the operator name in the box- [x] `observableblockingsingle(t)`: the operator name in the box indicate default in the box fix labels- [x] `observabletofuture()`: the operator name in the box indicate multi-value empty and error behavior- [x] `observableblockingsubscribe`: missing diagram- [x] `observablecachewithinitialcapacity`: the operator name in the box- [x] `observablecollectinto`: the operator name in the box indicate the shared collection- [x] `observableconcatmapcompletable`: missing diagram- [x] `observableconcatmapdelayerror`: missing diagram- [x] `observableconcatmapeager`: missing diagram- [x] `observableconcatmapeagerdelayerror`: missing diagram- [x] `observableconcatmapiterable`: missing diagram- [x] `observabledoafternext`: missing diagram- [x] `observabledofinally`: missing diagram- [x] `observabledoondispose`: the operator name in the box- [x] `observabledooncomplete`: indicate that the events pass through and the star is execute before the oncomplete to downstream- [x] `observabledoonerror`: indicate that the events pass through and the star is execute before the onerror to downstream- [x] `observabledoonlifecycle`: change unsubscribe to dispose- [x] `observabledoonnext`: indicate that the events pass through and the star is execute before the onnext to downstream- [x] `observabledoonterminate`: indicate that the events pass through and the star is execute before the onerror or oncomplete to downstream- [x] `observableelementat(long)`: example of empty source- [x] `observableelementat(long t)`: example of empty source- [x] `observableelementatorerror(long)`: example of empty source- [x] `observablefirstelement`: diagram is stretched- [x] `observablefirstorerror`: the operator name in the box- [x] `observableflatmap(function boolean int)`: missing diagram- [x] `observableflatmap(function boolean int int)`: missing diagram- [x] `observableflatmap(function function callable int)`: missing diagram- [x] `observableflatmap(function int)`: missing diagram- [x] `observableflatmap(function bifunction boolean int)`: missing diagram- [x] `observableflatmap(function bifunction boolean int int)`: missing diagram- [x] `observableflatmap(function bifunction int)`: missing diagram- [x] `observableflatmapcompletable()`: missing diagram- [x] `observableflatmapiterable(function)`: diagram looks stretched- [x] `observableforeach()`: missing diagram- [x] `observableforeachwhile()`: missing diagram- [x] `observablehide()`: missing diagram - not sure how to represent this- [x] `observablelastorerror()`: operator name in the box error case example- [x] `observableonerrorreturn()`: indicate that the value is the result of a function call- [x] `observableonerrorreturnitem()`: operator name in the box- [x] `observableonterminatedetach`: missing diagram- [x] `observablepublish(function)`: there is no connect call may need extensive redrawing- [x] `observablereducewith()`: operator name in the box- [x] `observablerepeat()` + overloads: indicate fresh subscriptions happen not caching- [x] `observablerepeatuntil`: operator name in the box indicate fresh subscriptions- [x] `observablereplay()` + overloads: remove publish- [x] `observablereplay(function )` overloads: may need extensive redrawing- [x] `observableretry(long)` indicate limited retry effect- [x] `observableretry(predicate)` indicate predicate effect show it in the box- [x] `observableretry(long predicate)` indicate predicate show them in the box- [x] `observableretryuntil`: operator name in the box show booleansupplier- [x] `observableshare()`: fix labels with unsubscribe- [x] `observablesingleelement`: example with empty source- [x] `observablesorted`: missing diagram- [x] `observablestartwith(t)`: have a single item as start value- [x] `observablestartwitharray(t)`: operator name- [x] `observablesubscribe` + overloads: missing diagram- [x] [observableswitchmapsingle]( inner sources should have 1 item- [x] `observableswitchmapdelayerror` + indicate the error case- [x] `observabletolist(callable)`: indicate the custom collection somehow?- [x] `observabletoflowable()`: missing diagram- [x] `observableunsubscribeon()`: missing diagram- [x] `observablezipwith()` + overloads: the diagram is in line with some text and appears pushed to the right- [x] `observabletest()`: missing diagram can this be represented as diagram?;prs welcome the most easy ones are those that require alignment/displayed size corrections || hi david id love to help what would i use to edit the diagrams? || if you are on mac and you own omnigraffle there is a file for **all** traditional diagrams: using excel 2007+ on windows to draw the newer diagrams and have a file [here]( you can use as basis for newer diagrams i dont know if the open office variants could open this file or not googles viewer certainly doesnt show the drawingsi suppose as a last resort you can draw in the open-office variants as well and post the pngs in this issue uploading it requires access to the wiki git of rxjava the target rendering is 640 pixels wide and as long as it needs to bethe process is as follows:- draw diagram(s)- upload to git- modify javadoc locally to point to the raw usercontent- verify and fix alignment/stretching- commit pr to rxjava itself || is it `switchmapsingle` need a new diagram too? singleresource cant emit 2 items || yes ill add it to the list above || ## concatarrayeager( || ## error![image]( || ## fromfuture![image]( || ## fromiterable![image]( || another option is to use free open-source multi-platform inkscape templates here: || **startwith(t)**![startwith t]( || **startwitharray(t)**![startwitharray]( || thanks could you make sure the operator box has its contents centered? || sure going to edit them || **sorted()**is it okay to add numbers to the marbles?![sorted]( || in this case yes because it also demonstrates the self-comparable nature required (changing the order of colors is unlikely to convey the sorting aspect) for most of the other operators the matching up of the color should be enough || not sure how you do these images could you add shadows to the marbles the time arrows and the vertical complete indicators? || im using @davidmotens template going to edit them to add the shadows  || sorted(): it would be better that the source marbles are at the beginning and the output is only happening after oncomplete:```---5--3--1--4--2--|--------------[            sorted()           ]---------------------1-2-3-4-5-|-``` || added shadows and edited the `sorted()` operator || **just(t)**![just]( || **rangelong()**![rangelong]( || thanks @leonardortlima ! the first 5 images is added via #5524 || just noticed that `singlefilter` and `maybefilter` are also incorrect they seem to be copied from `observablefilter` || quite possibly the other base reactive classes have copy-paste diagrams this issue tracks the fixes of `observable` but if you want i can open issues for the other classes individually || ![just(2)]( || from #5668:![singleelement]( || ### zipiterable![zipiterable]( ambwith![ambwith]( blockingforeach![blockingforeach]( blockingiterable![blockingiterable]( blockinglast![blockinglast]( blockingmostrecent![blockingmostrecent]( blockingnext![blockingnext]( blockingsingle![blockingsingle]( cachewithinitialcapacity![cachecwithinitialcapacity]( || ### all![cachecwithinitialcapacity]( frompublisher![cachecwithinitialcapacity]( ziparray![cachecwithinitialcapacity]( || ### blockingfirst![blockingfirst]( tofuture![tofuture]( blockingsubscribe![blockingsubscribe]( collectinto![collectinto]( dooncomplete![dooncomplete]( doonerror![doonerror]( doonlifecycle![doonlifecycle]( doonnext![doonnext]( || ### concatmapcompletable![concatmapcompletable]( concatmapdelayerror![concatmapdelayerror]( concatmapeager![concatmapeager]( concatmapeagerdelayerror![concatmapeagerdelayerror]( concatmapiterable![concatmapiterable]( doafternext![doafternext]( dofinally![dofinally]( || ### doonterminate![doonterminate]( elementat![elementat]( elementatorerror![elementatorerror]( firstorerror![firstorerror]( flatmap![flatmap]( || ![flatmapcompletable]( || ![lastorerror]( f)](  ![replay(int long timeunit)]( long timeunit scheduler)]( scheduler)]( timeunit)]( timeunit scheduler)]( || ![no arguments]( scheduler]( scheduler]( time]( time scheduler]( || ![retry(int)]( predicate)]( || ![tolist(callable)]( ||;1;0;2x: marbles for observable all frompublisher ziparray;
5741;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: internal api to get distinct workers from some schedulers;this pr adds an internal interface  schedulermultiworkersupport  that allows retrieving multiple workers from a  scheduler  that implements this interface.;;0;2x: internal api to get distinct workers from some schedulers;this pr adds an internal interface `schedulermultiworkersupport` that allows retrieving multiple workers from a `scheduler` that implements this interfacethe standard `schedulergetworker()` can be invoked as many times as necessary but specific implementations such as the `computation()` `scheduler` and the [`parallelscheduler`]( is not guaranteed to return workers that are backed by distinct single-threaded thread pools this does not effect other scheduler types because: - they are single threaded (`single()`) or dont use threads at all (`trampoline()`) and - already hand out distinct workers (`io()` `newthread()`)such worker reuse can happen when in a highly concurrent application typical tasks are mixed with parallel tasks and both pull out workers from these `scheduler`s if this is happens it is possible there will be duplicate threads used by the parallel operations and thus not utilize the originally intended parallelism levelby implementing this suggested interface a batch-retrieval can be supported by the `scheduler`s and they can make sure the caller gets as many distinct thread-pool as possible if more workers are requested than the `scheduler`s parallelism the workers are handed out in round-robin fashion similar to the standard `createworker()`why a callback instead of returning an array? - even if both require an allocation to set up there is no need to have all workers visible at once- simply less memory usage and- avoids looping twice: once for filling in the array and once for using the elements of the array; merging 5741 ;;;;1;1;2x: api to get distinct workers from some schedulers;
5743;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: check isdisposed before emitting in singlefromcallable;previously singlefromcallable did not check if the subscriber was;;5742.0;2x: check isdisposed before emitting in singlefromcallable;previously singlefromcallable did not check if the subscriber wasunsubscribed before emitting onsuccess or onerror this fixes thatbehavior and adds tests to singlefromcallable completablefromcallableand maybefromcallable5742; merging 5743 ;2x: singlefromcallable doesnt check isdisposed before calling onerror or onsuccess;i was investigating a bug and i noticed that `singlefromcallable` doesnt check `isdisposed()` before calling `onerror` or `onsuccess` when comparing it to `observablefromcallable`should it be checking `isdisposed()`? if not why not? or is this a bug?my code example where im getting this error is android based:i have a homepresenter with this code:```void setactivity(activity activity) {	timberd(homepresenter attachactivity)	thisactivity  activity}``````void onstart() {	timberd(homepresenter onstart)	disposablesadd(apigetemail()		subscribeon(schedulersio())		observeon(androidschedulersmainthread())		subscribe(email -> {			timberd(email was %s email)			activitysetemail(email)		})	)``````void onstop() {	timberd(homepresenter onstop)	disposablesclear()	activity  null}```in the logs i see:```lifecycle onstart homeactivityhomepresenter attachactivityhomepresenter onstartlifecycle onstop homeactivityhomepresenter onstopemail was foo@barcomnullpointerexception: attempt to invoke virtual method activitysetemail(string) on null object reference```it seems the subscription to the observable was cleared before the `onsuccess` method was calledor maybe im missing something else completely anyways thanks for the help :);indeed it is inconsistent with the other operators would you like to submit a pr? the [`maybefromcallable`]( should give a hint about the proper implementationotherwise the npe is due to the line `activitysetemail(email)` where `activity` is null even if `isdisposed` would have been considered there is a race between completion of the source and stopping the activity thus you may end up with null `activity` anyway ||;1;0;check isdisposed before emitting in singlefromcallablepreviously singlefromcallable did not check if the subscriber wasunsubscribed before emitting onsuccess or onerror this fixes thatbehavior and adds tests to singlefromcallable completablefromcallableand maybefromcallable5742;
5745;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add/update observable marbles 11/28;this pr adds or updates mable diagrams of  observable :;;5319.0;2x: add/update observable marbles 11/28;this pr adds or updates mable diagrams of `observable`:- [`blockingfirst`]( [`blockingfirst` with default]( [`tofuture`]( [`blockingsubscribe` no arguments]( [`blockingsubscribe` with 1 argument]( [`blockingsubscribe` with 2 arguments]( [`blockingsubscribe` with 3 arguments]( [`collectinto`]( [`dooncomplete`]( [`doonerror`]( [`doonlifecycle`]( [`doonnext`]( [`doondispose`]( #5319: [comment](https://githubcom/reactivex/rxjava/issues/5319#issuecomment-347482919); merging 5745  < ;2x: observable missing or incorrect images (tracking issue);-  [observablesingleorerror()]( there is no default value and an empty source should result in an error-  `observablecombinelatestdelayerror(observablesource function)`: missing diagram-  `observablecombinelatestdelayerror(function int observablesource)`: missing diagram-  `observableconcatarrayeager`: missing diagram-  `observableerror`: should include the x in the operator body indicating it as being the parameter/return value-  `observablefromfuture`: the operator name in the box-  `observablefromiterable`: the operator name in the box-  `observablefrompublisher`: missing diagram-  `observablejust`: the element should be a parameter inside the box such outside elements imply a subject type external push-  `observablejust(t t)` +7: optionally tailor the diagram to the actual number of arguments plus move the constant values inside the box- [x] `observablerangelong`: the operator name in the box- [x] `observableswitchonnextdelayerror`: the operator name in the box indicator of an error getting delayed- [x] `observableziparray`: indicate there is a function instead of implying the output is an array containing one element from each source- [x] `observablezipiterable`: the operator name in the box- [x] `observableall`: example of a false result- [x] `observableambwith`: the operator name in the box- [x] `observableblockingfirst`: missing diagram- [x] `observableblockingforeach`: the operator name in the box- [x] `observableblockingiterable`: the operator name in the box indicate that blocking may happen for each element- [x] `observableblockinglast`: the operator name in the box- [x] `observableblockinglast(t)`: the operator name in the box indicate default in the box fix labels- [x] `observableblockinglatest`: missing diagram- [x] `observableblockingmostrecent`: the operator name in the box- [x] `observableblockingnext`: the operator name in the box- [x] `observableblockingsingle`: the operator name in the box- [x] `observableblockingsingle(t)`: the operator name in the box indicate default in the box fix labels- [x] `observabletofuture()`: the operator name in the box indicate multi-value empty and error behavior- [x] `observableblockingsubscribe`: missing diagram- [x] `observablecachewithinitialcapacity`: the operator name in the box- [x] `observablecollectinto`: the operator name in the box indicate the shared collection- [x] `observableconcatmapcompletable`: missing diagram- [x] `observableconcatmapdelayerror`: missing diagram- [x] `observableconcatmapeager`: missing diagram- [x] `observableconcatmapeagerdelayerror`: missing diagram- [x] `observableconcatmapiterable`: missing diagram- [x] `observabledoafternext`: missing diagram- [x] `observabledofinally`: missing diagram- [x] `observabledoondispose`: the operator name in the box- [x] `observabledooncomplete`: indicate that the events pass through and the star is execute before the oncomplete to downstream- [x] `observabledoonerror`: indicate that the events pass through and the star is execute before the onerror to downstream- [x] `observabledoonlifecycle`: change unsubscribe to dispose- [x] `observabledoonnext`: indicate that the events pass through and the star is execute before the onnext to downstream- [x] `observabledoonterminate`: indicate that the events pass through and the star is execute before the onerror or oncomplete to downstream- [x] `observableelementat(long)`: example of empty source- [x] `observableelementat(long t)`: example of empty source- [x] `observableelementatorerror(long)`: example of empty source- [x] `observablefirstelement`: diagram is stretched- [x] `observablefirstorerror`: the operator name in the box- [x] `observableflatmap(function boolean int)`: missing diagram- [x] `observableflatmap(function boolean int int)`: missing diagram- [x] `observableflatmap(function function callable int)`: missing diagram- [x] `observableflatmap(function int)`: missing diagram- [x] `observableflatmap(function bifunction boolean int)`: missing diagram- [x] `observableflatmap(function bifunction boolean int int)`: missing diagram- [x] `observableflatmap(function bifunction int)`: missing diagram- [x] `observableflatmapcompletable()`: missing diagram- [x] `observableflatmapiterable(function)`: diagram looks stretched- [x] `observableforeach()`: missing diagram- [x] `observableforeachwhile()`: missing diagram- [x] `observablehide()`: missing diagram - not sure how to represent this- [x] `observablelastorerror()`: operator name in the box error case example- [x] `observableonerrorreturn()`: indicate that the value is the result of a function call- [x] `observableonerrorreturnitem()`: operator name in the box- [x] `observableonterminatedetach`: missing diagram- [x] `observablepublish(function)`: there is no connect call may need extensive redrawing- [x] `observablereducewith()`: operator name in the box- [x] `observablerepeat()` + overloads: indicate fresh subscriptions happen not caching- [x] `observablerepeatuntil`: operator name in the box indicate fresh subscriptions- [x] `observablereplay()` + overloads: remove publish- [x] `observablereplay(function )` overloads: may need extensive redrawing- [x] `observableretry(long)` indicate limited retry effect- [x] `observableretry(predicate)` indicate predicate effect show it in the box- [x] `observableretry(long predicate)` indicate predicate show them in the box- [x] `observableretryuntil`: operator name in the box show booleansupplier- [x] `observableshare()`: fix labels with unsubscribe- [x] `observablesingleelement`: example with empty source- [x] `observablesorted`: missing diagram- [x] `observablestartwith(t)`: have a single item as start value- [x] `observablestartwitharray(t)`: operator name- [x] `observablesubscribe` + overloads: missing diagram- [x] [observableswitchmapsingle]( inner sources should have 1 item- [x] `observableswitchmapdelayerror` + indicate the error case- [x] `observabletolist(callable)`: indicate the custom collection somehow?- [x] `observabletoflowable()`: missing diagram- [x] `observableunsubscribeon()`: missing diagram- [x] `observablezipwith()` + overloads: the diagram is in line with some text and appears pushed to the right- [x] `observabletest()`: missing diagram can this be represented as diagram?;prs welcome the most easy ones are those that require alignment/displayed size corrections || hi david id love to help what would i use to edit the diagrams? || if you are on mac and you own omnigraffle there is a file for **all** traditional diagrams: using excel 2007+ on windows to draw the newer diagrams and have a file [here]( you can use as basis for newer diagrams i dont know if the open office variants could open this file or not googles viewer certainly doesnt show the drawingsi suppose as a last resort you can draw in the open-office variants as well and post the pngs in this issue uploading it requires access to the wiki git of rxjava the target rendering is 640 pixels wide and as long as it needs to bethe process is as follows:- draw diagram(s)- upload to git- modify javadoc locally to point to the raw usercontent- verify and fix alignment/stretching- commit pr to rxjava itself || is it `switchmapsingle` need a new diagram too? singleresource cant emit 2 items || yes ill add it to the list above || ## concatarrayeager( || ## error![image]( || ## fromfuture![image]( || ## fromiterable![image]( || another option is to use free open-source multi-platform inkscape templates here: || **startwith(t)**![startwith t]( || **startwitharray(t)**![startwitharray]( || thanks could you make sure the operator box has its contents centered? || sure going to edit them || **sorted()**is it okay to add numbers to the marbles?![sorted]( || in this case yes because it also demonstrates the self-comparable nature required (changing the order of colors is unlikely to convey the sorting aspect) for most of the other operators the matching up of the color should be enough || not sure how you do these images could you add shadows to the marbles the time arrows and the vertical complete indicators? || im using @davidmotens template going to edit them to add the shadows  || sorted(): it would be better that the source marbles are at the beginning and the output is only happening after oncomplete:```---5--3--1--4--2--|--------------[            sorted()           ]---------------------1-2-3-4-5-|-``` || added shadows and edited the `sorted()` operator || **just(t)**![just]( || **rangelong()**![rangelong]( || thanks @leonardortlima ! the first 5 images is added via #5524 || just noticed that `singlefilter` and `maybefilter` are also incorrect they seem to be copied from `observablefilter` || quite possibly the other base reactive classes have copy-paste diagrams this issue tracks the fixes of `observable` but if you want i can open issues for the other classes individually || ![just(2)]( || from #5668:![singleelement]( || ### zipiterable![zipiterable]( ambwith![ambwith]( blockingforeach![blockingforeach]( blockingiterable![blockingiterable]( blockinglast![blockinglast]( blockingmostrecent![blockingmostrecent]( blockingnext![blockingnext]( blockingsingle![blockingsingle]( cachewithinitialcapacity![cachecwithinitialcapacity]( || ### all![cachecwithinitialcapacity]( frompublisher![cachecwithinitialcapacity]( ziparray![cachecwithinitialcapacity]( || ### blockingfirst![blockingfirst]( tofuture![tofuture]( blockingsubscribe![blockingsubscribe]( collectinto![collectinto]( dooncomplete![dooncomplete]( doonerror![doonerror]( doonlifecycle![doonlifecycle]( doonnext![doonnext]( || ### concatmapcompletable![concatmapcompletable]( concatmapdelayerror![concatmapdelayerror]( concatmapeager![concatmapeager]( concatmapeagerdelayerror![concatmapeagerdelayerror]( concatmapiterable![concatmapiterable]( doafternext![doafternext]( dofinally![dofinally]( || ### doonterminate![doonterminate]( elementat![elementat]( elementatorerror![elementatorerror]( firstorerror![firstorerror]( flatmap![flatmap]( || ![flatmapcompletable]( || ![lastorerror]( f)](  ![replay(int long timeunit)]( long timeunit scheduler)]( scheduler)]( timeunit)]( timeunit scheduler)]( || ![no arguments]( scheduler]( scheduler]( time]( time scheduler]( || ![retry(int)]( predicate)]( || ![tolist(callable)]( ||;1;0;2x: add/update observable marbles 11/28;
5746;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: improve wording and links in package-infos + remove unused imports;this pr is to improve the wording of a few  package-info.java  javadocs and removes two unused imports.;;0;2x: improve wording and links in package-infos + remove unused imports;this pr is to improve the wording of a few `package-infojava` javadocs and removes two unused imports; merging 5746 ;;;;1;1;remove unused imports;
5747;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix trampolinescheduler not calling rxjavaplugins.onschedule()  add tests for all schedulers.;noticed during figuring out how #5734 works.;;0;2x: fix trampolinescheduler not calling rxjavapluginsonschedule() add tests for all schedulers;noticed during figuring out how #5734 works; merging 5747 ;;;;1;1;2x: fix trampolinescheduler not calling rxjavapluginsonschedule() add tests for all schedulers;
"5748;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: check runnable == null in *scheduler.schedule*().;to enforce  @notnull  guarantee for the pr #5734  see  https://github.com/reactivex/rxjava/pull/5734/files#r153951238;;0;2x: check runnable  null in *schedulerschedule*();to enforce `@notnull` guarantee for the pr #5734 see  https://githubcom/reactivex/rxjava/pull/5734/files#r153951238; merging 5748 ;;;;1;1;""sudo """"run is null"""""";"
5753;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add retry(times  predicate) to single & completable and verify behavior across them and maybe.;- add retry(times  predicate) to single & completable (maybe had it already) which just forwards to flowable for now;;0;2x: add retry(times predicate) to single & completable and verify behavior across them and maybe;- add retry(times predicate) to single & completable (maybe had it already) which just forwards to flowable for now- verify behavior across the three reactive typeshappy to get better testing names;given youve added this to the 22 milestone should i update the `@since` to `220` then? || there is going to be a couple of 21x till then i dont want to release 220 until the marbles get  ||  merging 5753 ;;;;1;1;fix copy pasta mistake;
5755;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add marbles for observable (12/06);this pr adds some missing marbles to  observable :;;5319.0;2x: add marbles for observable (12/06);this pr adds some missing marbles to `observable`:- [concatmapcompletable]( [concatmapdelayerror]( [concatmapeager]( [concatmapeagerdelayerror]( [concatmapiterable]( [doafternext]( [dofinally]( in #5319 images in [comment](https://githubcom/reactivex/rxjava/issues/5319#issuecomment-349595094); merging 5755 ;2x: observable missing or incorrect images (tracking issue);-  [observablesingleorerror()]( there is no default value and an empty source should result in an error-  `observablecombinelatestdelayerror(observablesource function)`: missing diagram-  `observablecombinelatestdelayerror(function int observablesource)`: missing diagram-  `observableconcatarrayeager`: missing diagram-  `observableerror`: should include the x in the operator body indicating it as being the parameter/return value-  `observablefromfuture`: the operator name in the box-  `observablefromiterable`: the operator name in the box-  `observablefrompublisher`: missing diagram-  `observablejust`: the element should be a parameter inside the box such outside elements imply a subject type external push-  `observablejust(t t)` +7: optionally tailor the diagram to the actual number of arguments plus move the constant values inside the box- [x] `observablerangelong`: the operator name in the box- [x] `observableswitchonnextdelayerror`: the operator name in the box indicator of an error getting delayed- [x] `observableziparray`: indicate there is a function instead of implying the output is an array containing one element from each source- [x] `observablezipiterable`: the operator name in the box- [x] `observableall`: example of a false result- [x] `observableambwith`: the operator name in the box- [x] `observableblockingfirst`: missing diagram- [x] `observableblockingforeach`: the operator name in the box- [x] `observableblockingiterable`: the operator name in the box indicate that blocking may happen for each element- [x] `observableblockinglast`: the operator name in the box- [x] `observableblockinglast(t)`: the operator name in the box indicate default in the box fix labels- [x] `observableblockinglatest`: missing diagram- [x] `observableblockingmostrecent`: the operator name in the box- [x] `observableblockingnext`: the operator name in the box- [x] `observableblockingsingle`: the operator name in the box- [x] `observableblockingsingle(t)`: the operator name in the box indicate default in the box fix labels- [x] `observabletofuture()`: the operator name in the box indicate multi-value empty and error behavior- [x] `observableblockingsubscribe`: missing diagram- [x] `observablecachewithinitialcapacity`: the operator name in the box- [x] `observablecollectinto`: the operator name in the box indicate the shared collection- [x] `observableconcatmapcompletable`: missing diagram- [x] `observableconcatmapdelayerror`: missing diagram- [x] `observableconcatmapeager`: missing diagram- [x] `observableconcatmapeagerdelayerror`: missing diagram- [x] `observableconcatmapiterable`: missing diagram- [x] `observabledoafternext`: missing diagram- [x] `observabledofinally`: missing diagram- [x] `observabledoondispose`: the operator name in the box- [x] `observabledooncomplete`: indicate that the events pass through and the star is execute before the oncomplete to downstream- [x] `observabledoonerror`: indicate that the events pass through and the star is execute before the onerror to downstream- [x] `observabledoonlifecycle`: change unsubscribe to dispose- [x] `observabledoonnext`: indicate that the events pass through and the star is execute before the onnext to downstream- [x] `observabledoonterminate`: indicate that the events pass through and the star is execute before the onerror or oncomplete to downstream- [x] `observableelementat(long)`: example of empty source- [x] `observableelementat(long t)`: example of empty source- [x] `observableelementatorerror(long)`: example of empty source- [x] `observablefirstelement`: diagram is stretched- [x] `observablefirstorerror`: the operator name in the box- [x] `observableflatmap(function boolean int)`: missing diagram- [x] `observableflatmap(function boolean int int)`: missing diagram- [x] `observableflatmap(function function callable int)`: missing diagram- [x] `observableflatmap(function int)`: missing diagram- [x] `observableflatmap(function bifunction boolean int)`: missing diagram- [x] `observableflatmap(function bifunction boolean int int)`: missing diagram- [x] `observableflatmap(function bifunction int)`: missing diagram- [x] `observableflatmapcompletable()`: missing diagram- [x] `observableflatmapiterable(function)`: diagram looks stretched- [x] `observableforeach()`: missing diagram- [x] `observableforeachwhile()`: missing diagram- [x] `observablehide()`: missing diagram - not sure how to represent this- [x] `observablelastorerror()`: operator name in the box error case example- [x] `observableonerrorreturn()`: indicate that the value is the result of a function call- [x] `observableonerrorreturnitem()`: operator name in the box- [x] `observableonterminatedetach`: missing diagram- [x] `observablepublish(function)`: there is no connect call may need extensive redrawing- [x] `observablereducewith()`: operator name in the box- [x] `observablerepeat()` + overloads: indicate fresh subscriptions happen not caching- [x] `observablerepeatuntil`: operator name in the box indicate fresh subscriptions- [x] `observablereplay()` + overloads: remove publish- [x] `observablereplay(function )` overloads: may need extensive redrawing- [x] `observableretry(long)` indicate limited retry effect- [x] `observableretry(predicate)` indicate predicate effect show it in the box- [x] `observableretry(long predicate)` indicate predicate show them in the box- [x] `observableretryuntil`: operator name in the box show booleansupplier- [x] `observableshare()`: fix labels with unsubscribe- [x] `observablesingleelement`: example with empty source- [x] `observablesorted`: missing diagram- [x] `observablestartwith(t)`: have a single item as start value- [x] `observablestartwitharray(t)`: operator name- [x] `observablesubscribe` + overloads: missing diagram- [x] [observableswitchmapsingle]( inner sources should have 1 item- [x] `observableswitchmapdelayerror` + indicate the error case- [x] `observabletolist(callable)`: indicate the custom collection somehow?- [x] `observabletoflowable()`: missing diagram- [x] `observableunsubscribeon()`: missing diagram- [x] `observablezipwith()` + overloads: the diagram is in line with some text and appears pushed to the right- [x] `observabletest()`: missing diagram can this be represented as diagram?;prs welcome the most easy ones are those that require alignment/displayed size corrections || hi david id love to help what would i use to edit the diagrams? || if you are on mac and you own omnigraffle there is a file for **all** traditional diagrams: using excel 2007+ on windows to draw the newer diagrams and have a file [here]( you can use as basis for newer diagrams i dont know if the open office variants could open this file or not googles viewer certainly doesnt show the drawingsi suppose as a last resort you can draw in the open-office variants as well and post the pngs in this issue uploading it requires access to the wiki git of rxjava the target rendering is 640 pixels wide and as long as it needs to bethe process is as follows:- draw diagram(s)- upload to git- modify javadoc locally to point to the raw usercontent- verify and fix alignment/stretching- commit pr to rxjava itself || is it `switchmapsingle` need a new diagram too? singleresource cant emit 2 items || yes ill add it to the list above || ## concatarrayeager( || ## error![image]( || ## fromfuture![image]( || ## fromiterable![image]( || another option is to use free open-source multi-platform inkscape templates here: || **startwith(t)**![startwith t]( || **startwitharray(t)**![startwitharray]( || thanks could you make sure the operator box has its contents centered? || sure going to edit them || **sorted()**is it okay to add numbers to the marbles?![sorted]( || in this case yes because it also demonstrates the self-comparable nature required (changing the order of colors is unlikely to convey the sorting aspect) for most of the other operators the matching up of the color should be enough || not sure how you do these images could you add shadows to the marbles the time arrows and the vertical complete indicators? || im using @davidmotens template going to edit them to add the shadows  || sorted(): it would be better that the source marbles are at the beginning and the output is only happening after oncomplete:```---5--3--1--4--2--|--------------[            sorted()           ]---------------------1-2-3-4-5-|-``` || added shadows and edited the `sorted()` operator || **just(t)**![just]( || **rangelong()**![rangelong]( || thanks @leonardortlima ! the first 5 images is added via #5524 || just noticed that `singlefilter` and `maybefilter` are also incorrect they seem to be copied from `observablefilter` || quite possibly the other base reactive classes have copy-paste diagrams this issue tracks the fixes of `observable` but if you want i can open issues for the other classes individually || ![just(2)]( || from #5668:![singleelement]( || ### zipiterable![zipiterable]( ambwith![ambwith]( blockingforeach![blockingforeach]( blockingiterable![blockingiterable]( blockinglast![blockinglast]( blockingmostrecent![blockingmostrecent]( blockingnext![blockingnext]( blockingsingle![blockingsingle]( cachewithinitialcapacity![cachecwithinitialcapacity]( || ### all![cachecwithinitialcapacity]( frompublisher![cachecwithinitialcapacity]( ziparray![cachecwithinitialcapacity]( || ### blockingfirst![blockingfirst]( tofuture![tofuture]( blockingsubscribe![blockingsubscribe]( collectinto![collectinto]( dooncomplete![dooncomplete]( doonerror![doonerror]( doonlifecycle![doonlifecycle]( doonnext![doonnext]( || ### concatmapcompletable![concatmapcompletable]( concatmapdelayerror![concatmapdelayerror]( concatmapeager![concatmapeager]( concatmapeagerdelayerror![concatmapeagerdelayerror]( concatmapiterable![concatmapiterable]( doafternext![doafternext]( dofinally![dofinally]( || ### doonterminate![doonterminate]( elementat![elementat]( elementatorerror![elementatorerror]( firstorerror![firstorerror]( flatmap![flatmap]( || ![flatmapcompletable]( || ![lastorerror]( f)](  ![replay(int long timeunit)]( long timeunit scheduler)]( scheduler)]( timeunit)]( timeunit scheduler)]( || ![no arguments]( scheduler]( scheduler]( time]( time scheduler]( || ![retry(int)]( predicate)]( || ![tolist(callable)]( ||;1;0;2x: add marbles for observable (12/06);
5756;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: improve autoconnect() javadoc + add its marble;this pr improves the javadoc of  connectableobservable.autoconnect()  and  connectableflowable.autoconnect()  operators and adds the respective marble diagrams:;;0;2x: improve autoconnect() javadoc + add its marble;this pr improves the javadoc of `connectableobservableautoconnect()` and `connectableflowableautoconnect()` operators and adds the respective marble diagrams:![autoconnect](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/autoconnectopng)![autoconnect](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/autoconnectfpng);;;;;1;1;2x: improve autoconnect() javadoc + add its marble;
5758;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add a couple of @see to completable;this pr adds a couple of  @see  cross references to  completable  javadoc.;;0;2x: add a couple of @see to completable;this pr adds a couple of `@see` cross references to `completable` javadoc; merging 5758 ;;;;1;1;enable @see in javadocwording verifier;
5759;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: marble additions and updates (12/11);this pr adds or updates mable diagrams of  observable :;;0;2x: marble additions and updates (12/11);this pr adds or updates mable diagrams of `observable`:- [doonterminate]( [elementat]( [elementat]( with default- [elementatorerror]( [firstorerror]( [flatmap]( with error delayed- [flatmap]( with maximum concurrencyrelated: https://githubcom/reactivex/rxjava/issues/5319#issuecomment-350682783; merging 5759 ;;;;1;1;2x: marble additions and updates (12/11);
5760;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: subject npe fixes  add unicastprocessor tck;this pr adds the  subject.refcount()  and  flowableprocessor.refcount()  that capture the upstream s  disposable / subscription  and disposes/cancels them if the number of  observer s/ subscriber s decreases to zero. the reactive-streams tck and thus other implementations may expect such behavior from a  processor  implementation and this wrapper is required to pass the tck tests.;;0;2x: subject npe fixes add unicastprocessor tck;this pr adds the `subjectrefcount()` and `flowableprocessorrefcount()` that capture the upstreams `disposable`/`subscription` and disposes/cancels them if the number of `observer`s/`subscriber`s decreases to zero the reactive-streams tck and thus other implementations may expect such behavior from a `processor` implementation and this wrapper is required to pass the tck testswhile implementing the tck tests it turned out the `null`-handling of the `subject`s and `flowableprocessor`s were not following the reactive-streams specification they have to throw a `nullpointerexception` immediately and not turn them into npes for the downstream these classes and the tests have been  as well their error messages have been uniformed too; merging 5760 ;;;;1;1;improve style;
5761;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix timed exact buffer calling cancel unnecessarily;this pr removes the unnnecessary  cancel / dispose  call from the exact-boundary timed  buffer()  operators in  observable  and  flowable  when the upstream completes normally.;;0;2x: fix timed exact buffer calling cancel unnecessarily;this pr removes the unnnecessary `cancel`/`dispose` call from the exact-boundary timed `buffer()` operators in `observable` and `flowable` when the upstream completes normallyoriginally appeared in a [stackoverflow question](https://stackoverflowcom/questions/47772415/rxjava2-completing-a-cold-source-flowable-explicitly); merging 5761  < ;;;;1;1;2x: fix timed exact buffer calling cancel unnecessarily;
5766;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;rename interface parameters;#5762;;5762.0;rename interface parameters;#5762 signed-off-by: shaishavgandhi05 <shaishgandhi@gmailcom>; merging 5766 ;use descriptive names in interfaces;every time i implement one of these interfaces i rename e to emitter this is repetitive and can be avoided with renaming the param in the interface```javapublic interface singleonsubscribe<t> {    /**     * called for each singleobserver that subscribes     * @param e the safe emitter instance never null     * @throws exception on error     */    void subscribe(@nonnull singleemitter<t> e) throws exception}```this would be in line with naming in other interfaces such as:```javapublic interface completableconverter<r> {    /**     * applies a function to the upstream completable and returns a converted value of type {@code r}     *     * @param upstream the upstream completable instance     * @return the converted value     */    @nonnull    r apply(@nonnull completable upstream)}```i am happy to do it myself if you approve;why dont you use lambdas where you can specify the name of the parameter?```javasinglecreate(emitter -> { emitteronsuccess(1) })```besides im not sure renaming the parameter wouldnt cause trouble with jvm languages where such change breaks existing code || not for kotlin named arguments are only supported from kotlin compiled code where the metadata annotation is present  || android studio autogenerates the following with lambdas:singlecreate(e -> ) which i repetitively rename to singlecreate(emitter -> ) || i think not many languages have upgraded their adapters to v2 yet (or will ever) so lets change it and see whos complaining || closing via #5766 ||;1;0;rename interface parameterssigned-off-by: shaishavgandhi05 <shaishgandhi@gmailcom>;
"5773;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: improve javadoc of retrywhen() operators;this pr improves the javadoc of the  retrywhen  operators in the 5 base classes  adds example to handling an asynchronous source with delay where an early  oncomplete  may cause unexpected terminations otherwise.;;5772.0;2x: improve javadoc of retrywhen() operators;this pr improves the javadoc of the `retrywhen` operators in the 5 base classes adds example to handling an asynchronous source with delay where an early `oncomplete` may cause unexpected terminations otherwiserelated: #5772; merging 5773 ;race condition with retrywhen()?;here in this [sample project]( you can see that singleretrywhen() produces inconsistent results depending on timing:- retrywhen() test method gets one less retry than expected- retrywhenwithdelay() test method works as expectedmy suspicion is that when we do not add a time delay oncomplete is called immediately after the last onnext() call and immediately terminates the stream with nosuchelementexception;""in some sense there is a race condition with your retry flow when an error is signalled there should be a single response `onnext|onerror|oncomplete` from the transformation however with a `range()` youll have an `onnext` directly followed  oncomplete` which is interpreted by the operator as indication for stopping the entire sequence now if the upstream is synchronous this will have only effect after the last retry if the upstream is asynchronous youll get a non-deterministic cutoff  || yeah i think i understand what you are saying for us this behaviour of retrywhen() lead to a very difficult to understand bug we spent about 3 days on it until we understood that this is how retrywhen() behavesthe bug we had is that our stream would fail with undeliverableexception due to this behaviour it fails on every last retry cycle i suspect what happens is that the last onevent() call triggers the last retry cycle and then steam is immediately terminated when our code tries to emit in the last retry cycle the stream is already terminated and we fail with undeliverableexceptionit was so painful to understand it :) || as a temporary workaround to this problem we have to add this to our code```                if (emitterisdisposed()) {                    return                }``` || there exist a builder for `retrywhen` in [rxjava2-extras]( assuming your retry patterns can be expressed by itill post a javadoc clarification regarding the operator shortly || i appreciate the suggestion to add javadoc i do believe though that this may be a bit too complex to be expressed in javadoc so that every user clearly understand what situation they may get themselves into ideally api should protect the user from getting themselves into a muddle :) not sure if we can achieve that here but i suggest that we at least try || @akarnokd but as i see in the doc you say:```if the upstream to +     * the operator is asynchronous signalling onnext followed by oncomplete immediately may +     * result in the sequence to be completed immediately similarly if this inner +     * {@code publisher} signals {@code onerror} or {@code oncomplete} while the upstream is +     * active the sequence is terminated with the same signal immediately```in our case the problem was that the sequence was not terminated in time it signaled onerror and then another call to the upstream would happen (upstream is async) i dont feel the new docs mention this may be i dont understand it  || please provide a minimal and standalone unit test that reproduces your problem || @akarnokd [sample project]( 10 22531 17681-17704/comnmp90rxjava_retry d/mainactivity: request12-22 10 23353 17681-17704/comnmp90rxjava_retry d/mainactivity: retry12-22 10 26357 17681-17704/comnmp90rxjava_retry d/mainactivity: request12-22 10 26579 17681-17704/comnmp90rxjava_retry d/mainactivity: retry12-22 10 29580 17681-17704/comnmp90rxjava_retry d/mainactivity: request12-22 10 29788 17681-17704/comnmp90rxjava_retry d/mainactivity: retry12-22 10 30790 17681-17722/comnmp90rxjava_retry d/mainactivity: zip complete12-22 10 30793 17681-17681/comnmp90rxjava_retry e/mainactivity: onerror:                                                                 javautilnosuchelementexception12-22 10 32789 17681-17704/comnmp90rxjava_retry d/mainactivity: request```the problem is the last call to request after nosuchelementexception :+1: any help is much appreciated || dont zip with a range() see the new async example in #5773 || so the fix would be```java              retrywhen(throwableflowable -> {                    atomicinteger counter  new atomicinteger()                    return throwableflowable                            takewhile(e -> countergetandincrement() < 3)                            flatmap(err -> {                                if (err instanceof ioexception) {                                    logd(tag """"retry"""")                                    return flowabletimer(1l timeunitseconds)                                } else {                                    loge(tag """"error"""" err)                                    return flowableerror(err)                                }                            })dooncomplete(() -> logd(tag """"zip complete""""))                })```which actually does the job ```12-22 10 31823 19057-19075/comnmp90rxjava_retry d/mainactivity: request12-22 10 32674 19057-19075/comnmp90rxjava_retry d/mainactivity: retry12-22 10 35679 19057-19075/comnmp90rxjava_retry d/mainactivity: request12-22 10 35943 19057-19075/comnmp90rxjava_retry d/mainactivity: retry12-22 10 38946 19057-19075/comnmp90rxjava_retry d/mainactivity: request12-22 10 39189 19057-19075/comnmp90rxjava_retry d/mainactivity: retry12-22 10 42191 19057-19075/comnmp90rxjava_retry d/mainactivity: request12-22 10 42408 19057-19075/comnmp90rxjava_retry d/mainactivity: zip complete12-22 10 42412 19057-19057/comnmp90rxjava_retry e/mainactivity: onerror:                                                                       javautilnosuchelementexception```thank you i used `flowablerange` because i think i saw it as an example on stackoverflow     || closing via #5773 || "";1;0;fix example termination logic proper blockingx();"
5778;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: improve behaviorprocessor javadoc;a [stackoverflow]( question prompted me to look at  behaviorprocessor  to find it quite lacking of a detailed javadoc. this pr adds sentences and examples (i could think of) to it that explain the available features and behavior of this  processor  implementation.;;0;2x: improve behaviorprocessor javadoc;a [stackoverflow]( question prompted me to look at `behaviorprocessor` to find it quite lacking of a detailed javadoc this pr adds sentences and examples (i could think of) to it that explain the available features and behavior of this `processor` implementationif the sentences are reviewed the `behaviorsubject` will be updated with the applicable information (ie everything minus backpressure related sentences); merging 5778 ;;;;1;1;use &gt in the first example;
5780;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: improve behaviorsubject javadoc + related clarifications;this pr adds detailed behavior and feature description to the  behaviorsubject  javadoc.;;0;2x: improve behaviorsubject javadoc + related clarifications;this pr adds detailed behavior and feature description to the `behaviorsubject` javadocin addition small mistakes in the `behaviorprocessor` javadoc have also been  and both received an extra section: `error handling` that points at the global error handler for undeliverable errors due to this link the `rxjavapluginsonerror` javadoc has been also expanded; merging 5780 ;;;;1;1;fix grammar add wiki link;
"5781;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: describe merge() error handling.;this pr adds some clarifications about how  merge  handles (multiple) errors in a new *error handling* section in its  <dl>  javadoc entry.;;5779.0;2x: describe merge() error handling;this pr adds some clarifications about how `merge` handles (multiple) errors in a new *error handling* section in its `<dl>` javadoc entrythere exist several dozen variants of `merge` in the various base classes that could also include such javadoc addition once the wording has been reviewed the other places will receive a separate prrelated: #5779 #5780; merging 5781 ;2x: inconsistent behavior on throwing undeliverableexception in observablemerge;""library version: 217as stated in [rxjava2 error handling]( no `throwable` should be silently swallowed in 2x `throwable`s that cannot be delivered to a disposed downstream get redirected to `rxjavaplugins` errorhandlerhowever `observablemerge` operator does not behave consistently in this case:- if two different `publishsubject`s are merged and emit `onerror` one after the other the second exception **does not get delivered** to `rxjavaplugins` errorhandler- if one `publishsubject` get merged with itself (after being filtered for example which i expect to be a common scenario) and it emit single onerror the exception emitted **gets delivered** to both onerror and `rxjavaplugins` errorhandlerthe snippet below```javapublic class mergeerrorsexample {    public static void main(string args) {        rxjavapluginsseterrorhandler((error) ->                printerror(""""rxjavapluginserrorhandler"""" error)        )        mergetwodifferentobservablesdoesnotthrowundeliverable()        mergesameobservablethrowsundeliverable()        mergesameobservablewithpublishthrowsundeliverable()    }    static void mergetwodifferentobservablesdoesnotthrowundeliverable() {        systemoutprintln(""""merge two different publishsubjects does not throw undeliverableexception"""")        publishsubject<object> ps1  publishsubjectcreate()        publishsubject<object> ps2  publishsubjectcreate()        observablemerge(ps1 ps2)subscribe(                (next) -> systemoutprintln(""""onnext """" + next)                (error) -> printerror(""""onerror"""" error)                () -> systemoutprintln(""""oncomplete"""")        )        ps1onerror(new runtimeexception(""""ps1 exception""""))        ps2onerror(new runtimeexception(""""ps2 exception""""))        systemoutprintln()    }    static void mergesameobservablethrowsundeliverable() {        systemoutprintln(""""merge same publishsubject throws undeliverableexception"""")        publishsubject<boolean> ps1  publishsubjectcreate()        observablemerge(                ps1filter((condition) -> condition)                ps1filter((condition) -> !condition)        )subscribe(                (next) -> systemoutprintln(""""onnext """" + next)                (error) -> printerror(""""onerror"""" error)                () -> systemoutprintln(""""oncomplete"""")        )        ps1onerror(new runtimeexception(""""ps1 exception""""))        systemoutprintln()    }    static void mergesameobservablewithpublishthrowsundeliverable() {        systemoutprintln(""""merge same observable with publish() throws undeliverableexception"""")        observable<boolean> o1  observableerror(new runtimeexception(""""o1 exception""""))        o1publish((observable) ->                observablemerge(                        observablefilter((condition) -> condition)                        observablefilter((condition) -> !condition)                )        )subscribe(                (next) -> systemoutprintln(""""onnext """" + next)                (error) -> printerror(""""onerror"""" error)                () -> systemoutprintln(""""oncomplete"""")        )        systemoutprintln()    }    private static void printerror(string message throwable t) {        systemoutprintln(message + """": ["""" + tgetclass()getsimplename() + """"] """" + tgetmessage())    }}```produces ```merge two different publishsubjects does not throw undeliverableexceptiononerror: [runtimeexception] ps1 exceptionmerge same publishsubject throws undeliverableexceptiononerror: [runtimeexception] ps1 exceptionrxjavapluginserrorhandler: [undeliverableexception] javalangruntimeexception: ps1 exceptionmerge same observable with publish() throws undeliverableexceptiononerror: [runtimeexception] o1 exceptionrxjavapluginserrorhandler: [undeliverableexception] javalangruntimeexception: o1 exception```im still not sure which of the options is correct as """"splitting"""" an `observable` and then merging it back seems to be a common pattern which will always cause an `undeliverableexception` in `rxjavaplugins` errorhandler in case of onerror `observablemergedelayerrors` is an option for """"split-merge"""" pattern but the user of it has to make sure he does not swallow an exception on one of the paths or the exception will not be delivered to the downstream at allwhat do you think would be the correct behavior here?do you think it is possible to make `observablemerge` not redirect an error to `rxjavaplugins` errorhandler in case of """"split-merge"""" pattern?"";""hi here are the explanations:- mergetwodifferentobservablesdoesnotthrowundeliverablethe second `publishsubject` gets unsubscribed before you call `onerror` thus there is no `observer` at that moment to receive an error a `subject` cant know if it will never be subscribed again thus signalling an undeliverable error is likely too much- mergesameobservablethrowsundeliverablewhen the `publishsubject` emits an error it uses the last snapshot of available `observer`s and tries to emit the error to them here the second `observer` gets unsubscribed during the emission loop and therefore the error gets routed to the plugin error handler- mergesameobservablewithpublishthrowsundeliverable`publish()` operates with the same snapshot-emission logic as `publishsubject` and the same effect applies> do you think it is possible to make observablemerge not redirect an error to rxjavaplugins errorhandler in case of """"split-merge"""" pattern?no thats why `mergedelayerror` exists which will get you all errors in a composite the other option is to not let the errors reach merge if you want only the very first error and ignore the rest you could use some additional logic:```javapublic static <t> observable<t> mergefirsterroronly(observable<t> sources) {    return observabledefer(() -> {        atomicboolean once  new atomicboolean()        publishsubject<void> errorsubject  publishsubjectcreate()        for (int i  0 i < sourceslength i++) {            sources[i]  sources[i]onerrorresumenext(e -> {                if (oncecompareandset(false true)) {                    errorsubjectonerror(e)                }                return observableempty()            })        }        return observablemerge(sources)takeuntil(errorsubject)    })}``` || hi @akarnokdthanks for the detailed explanation!`mergedelayerror` is indeed what we ended up withi now see that it is expected implementation-wise however from """"rxjava-user"""" point of view i did not expect that something as simple as ```java        o1publish((observable) ->                observablemerge(                        observablefilter((condition) -> condition)                        observablefilter((condition) -> !condition)                )        )```would crash on android (if no custom plugin error handler is installed) i would rather expect `merge` to behave similar to your `mergefirsterroronly` implementationdo you think it is worth mentioning in the documentation of `merge` operator at least? || see #5780 and #5781 for the proposed javadoc improvements || closing via #5786 || hi @akarnokd !after some usage of the suggested mergefirsterroronly we found that it still produces an undeliverableexception to the rxjavaplugins errorhandler if called from multiple threads below in the complete test that reproduces it:```javapackage comtestimport ioreactivexobservableimport ioreactivexobservablesourceimport ioreactivexdisposablesdisposableimport ioreactivexfunctionsconsumerimport ioreactivexfunctionsfunctionimport ioreactivexpluginsrxjavapluginsimport ioreactivexschedulersschedulersimport ioreactivexsubjectspublishsubjectimport orgassertjcoreapiassertionsimport orgjunittestimport javautilarraylistimport javautilarraysimport javautillistimport javautilconcurrentcallableimport javautilconcurrentatomicatomicbooleanpublic class mergefirsterroronlytest {    @test    public void mergefirsterroronlywithconcurrentusage() {        final list<throwable> undeliverableexceptions  new arraylist<>()        rxjavapluginsseterrorhandler(new consumer<throwable>() {            @override            public void accept(throwable throwable) {                undeliverableexceptionsadd(throwable)            }        })        for (int i  0 i < 10000 ++i) {            publishsubject<string> subject1  publishsubjectcreate()            publishsubject<string> subject2  publishsubjectcreate()            disposable disposable  observables                    mergefirsterroronly(                            subject1observeon(schedulersio())                            subject2observeon(schedulersio())                    )                    subscribe(                            new consumer<string>() {                                @override                                public void accept(string s) {                                    // do nothing                                }                            }                            new consumer<throwable>() {                                @override                                public void accept(throwable throwable) {                                    // do nothing                                }                            }                    )            subject1onerror(new exception(""""exception 1""""))            subject2onerror(new exception(""""exception 2""""))            disposabledispose()        }        if (!undeliverableexceptionsisempty()) {            undeliverableexceptionsget(0)printstacktrace()        }        assertionsassertthat(undeliverableexceptions)isempty()        rxjavapluginsreset()    }}class observables {    public static <t> observable<t> mergefirsterroronly(final observable<t> sources) {        return observabledefer(new callable<observablesource<? extends t>>() {            @override            public observablesource<? extends t> call() {                final atomicboolean once  new atomicboolean()                final publishsubject<void> errorsubject  publishsubjectcreate()                for (int i  0 i < sourceslength i++) {                    sources[i]  sources[i]onerrorresumenext(new function<throwable observablesource<? extends t>>() {                        @override                        public observablesource<? extends t> apply(throwable e) {                            if (oncecompareandset(false true)) {                                errorsubjectonerror(e)                            }                            return observableempty()                        }                    })                }                return observablemerge(arraysaslist(sources))takeuntil(errorsubject)            }        })    }}```the above fails with results similar to```javalangassertionerror: expecting empty but was:<[ioreactivexexceptionsundeliverableexception: javalangexception: exception 2    ioreactivexexceptionsundeliverableexception: javalangexception: exception 2]>	at comtestmergefirsterroronlytestmergefirsterroronlywithconcurrentusage(mergefirsterroronlytestjava:68)```the exception itself looks like  ```ioreactivexexceptionsundeliverableexception: javalangexception: exception 2	at ioreactivexpluginsrxjavapluginsonerror(rxjavapluginsjava:367)	at ioreactivexsubjectspublishsubject$publishdisposableonerror(publishsubjectjava:315)	at ioreactivexsubjectspublishsubjectonerror(publishsubjectjava:245)	at comtestmergefirsterroronlytestmergefirsterroronlywithconcurrentusage(mergefirsterroronlytestjava:59)```for now i dont see a way to solve the issue completely using the current rxjava 2 api looks like the publish subject itself is missing something similar to `tryonerror` wdyt? || something like```javapublic final class publishsubject<t> extends subject<t> {        public void tryonerror(throwable t) {        objecthelperrequirenonnull(t """"onerror called with null null values are generally not allowed in 2x operators and sources"""")        if (subscribersget()  terminated) {            rxjavapluginsonerror(t)            return        }        error  t        for (publishdisposable<t> s : subscribersgetandset(terminated)) {            stryonerror(t)        }    }    static final class publishdisposable<t> extends atomicboolean implements disposable {        public void tryonerror(throwable t) {            if (!get()) {                actualonerror(t)            }        }    }}```i can submit a pr if youre ok with the proposalstill i totally understand that i might be missing some deeper implications of such change so please advise || if you cancel a `publishsubject` while it is about to emit an error the global error handler is involved your racing test runs into this case this property is described in [the javadoc]( implication of a `tryonerror` is that it reports false when the error was not delivered but when there are more than one source it is unclear what the result should be if some have not received the error || also looks like you are in control of those `subject`s in that case dont error each individual subject but use a separate one:```javapublishsubject ps1  publishsubjectcreate()publishsubject ps2  publishsubjectcreate()atomicboolean once  new atomicboolean()publishsubject error  publishsubjectcreate()observablemerge(ps1 ps2)takeuntil(error)if (oncecompareandset(false true)) {    erroronerror(new runtimeexception())}```this way the merge cancelling the non-failing `ps1` and `ps2` wont signal error to the global handler || ok thanks i see the point will indeed try to route errors from all streams to a single `publishsubject`s onerror call guarded  atomicboolean` || "";1;0;2x: describe merge() error handling;"
5781;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: describe merge() error handling.;this pr adds some clarifications about how  merge  handles (multiple) errors in a new *error handling* section in its  <dl>  javadoc entry.;;578.0;2x: describe merge() error handling;this pr adds some clarifications about how `merge` handles (multiple) errors in a new *error handling* section in its `<dl>` javadoc entrythere exist several dozen variants of `merge` in the various base classes that could also include such javadoc addition once the wording has been reviewed the other places will receive a separate prrelated: #5779 #5780; merging 5781 ;a bug in apply(u:>unit) method of subscription companion object  w;hich may cause multiple invocations of u in a multithreaded multi-unsubscribe situationthreads may be pre-empted after evaluation of condition (!unsubscribedget()) which may result in two or more threads executing the consequent block more than once a code that relies on single evaluation of u will fail if that case happens;#518  this was  by @headinthebox and can be seen here:  you @ugur-zongur for contributing! ||;1;0;2x: describe merge() error handling;
"5783;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix javadoc wording of onterminatedetach;a missing  nulls  word from  flowable.onterminatedetach  and  observable.onterminatedetach  javadoc. the other types have this word already.;;5782.0;2x: fix javadoc wording of onterminatedetach;a missing `nulls` word from `flowableonterminatedetach` and `observableonterminatedetach` javadoc the other types have this word alreadyrelated: #5782; merging 5783 ;documentation error?;""what does this mean in the [description]( of `onterminatedetach`? returns:an observable which out references to the upstream producer and downstream subscriber if the sequence is terminated or downstream unsubscribesmy guess: """"nulls"""" belongs between """"which"""" and """"out"""""";yes the word `nulls` out is missing there and also from`flowable` and `observable` in v2 ill post a fix to v2 and you are welcome to post a fix for v1 if you want || closing via #5783 ||;1;0;2x: fix javadoc wording of onterminatedetach;"
5785;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: update maybe doon{success error complete} javadoc;this pr updates the javadoc of the  maybe.doonsuccess    maybe.doonerror  and  maybe.dooncomplete  marble diagrams and adds an explicit sentence about mutually exclusive events.;;0;2x: update maybe doon{successerrorcomplete} javadoc;this pr updates the javadoc of the `maybedoonsuccess` `maybedoonerror` and `maybedooncomplete` marble diagrams and adds an explicit sentence about mutually exclusive events![doonsuccess](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/doonsuccessmpng)-----![doonerror](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/doonerrormpng)-----![dooncomplete](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/dooncompletempng); merging 5785 ;;;;1;1;2x: update maybe doon{successerrorcomplete} javadoc;
"5786;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add error handling section to merge() operator docs;this pr adds the **error handling** javadoc section to the other  merge  operators throughout the base reactive classes.;;0;2x: add error handling section to merge() operator docs;this pr adds the **error handling** javadoc section to the other `merge` operators throughout the base reactive classesnote though that the following `mergedelayerror` methods dont exist yet:- `maybemergedelayerror(publisher int)`- `singlemergedelayerror(*)` (`*` all variants of their respective `merge` methods are missing)these can be added in a separate pr and dont require implementing new operators but to configure existing ones with `delayerror  true`; merging 5786 ;;;;1;1;""change to """"undeliverableexception errors"""""";"
5790;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: improve request accounting overhead in retry/repeat;this pr improves the request accounting overhead in the  retry  and  repeat  operators.;;0;2x: improve request accounting overhead in retry/repeat;this pr improves the request accounting overhead in the `retry` and `repeat` operatorspreviously every individual `onnext` invocation signaled a an item production which had a lot of overhead since the `subscriptionarbiter` has to serialize invocations of `setsubscription` `request` and `produced` the improved algorithm counts the `onnext` calls in a field and calls `produced` once with the total count before subscribing to the upstream againother small changes:- rename inner class to `retrysubscriber` (sloppy copy-paste)- add `iscancelled()` check to `repeatuntil` subscription loop which was somehow missing; merging 5790 ;;;;1;1;test repeatuntil cancelled case;
5792;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix flatmap inner fused poll crash not cancelling the upstream;this pr fixes the lack of upstream  cancel()  call when an inner  fused source s  queue.poll()  crashes in a non-delayed error mode.;;579.0;2x: fix flatmap inner fused poll crash not cancelling the upstream;this pr fixes the lack of upstream `cancel()` call when an inner fused sources `queuepoll()` crashes in a non-delayed error modeunit tests were added to verify `observableflatmap` `flowableflatmapiterable` and `observableflatmapiterable` as well  5791; merging 5792 ;crlf issues :-(;cannot believe that it is 2013 and we are still having crlf changesi guess that @akarnokd is using windows and i have trouble with crlf in asyncjava and friends;yes im on windows and using netbeans 74 with default git settings i thought all this line ending is automatically managed by github or the repo [as specified here]( the question is should i create a pr with  crlf or will this be handled on the repo level? || ill play with those github settings to see if i can resolve it there ||;1;0;verify observableflatmapiterable;
5795;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: more marbles 01/08-a;this pr adds 5 marble diagrams to  observable :;;0;2x: more marbles 01/08-a;this pr adds 5 marble diagrams to `observable`:- `flatmapcompletable` (2 overloads)- `foreach`- `foreachwhile`- `hide`images in https://githubcom/reactivex/rxjava/issues/5319#issuecomment-355932289; merging 5795 ;;;;1;1;2x: more marbles 01/08-a;
5797;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: observable marble fixes 01/08-b;this pr adds and updates marbles of the following  observable  operators:;;0;2x: observable marble fixes 01/08-b;this pr adds and updates marbles of the following `observable` operators:- [lastorerror]( [onerrorreturn]( [onerrorreturnitem]( [onterminatedetach]( [publish(function)]( [reduce(seed f)]( [reducewith]( [repeat()]( [repeat(long)]( [repeatuntil]( [replay()]( [replay(int)](  - [replay(int long timeunit)]( [replay(int long timeunit scheduler)]( [replay(int scheduler)]( [replay(long timeunit)]( [replay(long timeunit scheduler)]( [replay(scheduler)]( in https://githubcom/reactivex/rxjava/issues/5319#issuecomment-355986927;i think theres a markdown error in your list || pressed some unexpected keyboard shortcut that created the pr prematurely updated ||  merging 5797 ;;;;1;1;2x: observable marble fixes 01/08-b;
5798;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: observable.replay(function  ) marble fixes;this pr updates the marble diagrams of the 8  observable.replay()  overload that take a  function  and various other parameters:;;0;2x: observablereplay(function ) marble fixes;this pr updates the marble diagrams of the 8 `observablereplay()` overload that take a `function` and various other parameters:- [no arguments]( [scheduler]( [buffersize]( [buffersize scheduler]( [time]( [time scheduler]( [buffersize time]( [buffersize time scheduler]( in https://githubcom/reactivex/rxjava/issues/5319#issuecomment-356286139; merging 5798 ;;;;1;1;2x: observablereplay(function ) marble fixes;
"5799;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add missing {maybe|single}.mergedelayerror variants;this pr adds  mergedelayerror  overloads to  maybe  and  single   the infrastructure was there from the beginning but the  delayerrors == true  settings were not exposed publicly.;;0;2x: add missing {maybe|single}mergedelayerror variants;this pr adds `mergedelayerror` overloads to `maybe` and `single` the infrastructure was there from the beginning but the `delayerrors  true` settings were not exposed publicly- `maybemergedelayerror(publisher int)`- `singlemergedelayerror(iterable)`- `singlemergedelayerror(publisher)`- `singlemergedelayerror(singlesource singlesource)`- `singlemergedelayerror(singlesource singlesource singlesource)`- `singlemergedelayerror(singlesource singlesource singlesource singlesource)`; merging 5799  < ;;;;1;1;""in javadoc use """"a singlesource to be merged"""""";"
"5802;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: improved xsubject javadocs;this pr adds more detailed javadoc descriptions to the various  xsubject  types.;;0;2x: improved xsubject javadocs;this pr adds more detailed javadoc descriptions to the various `xsubject` typessome of them are missing a marble diagram which will be created (or found) in a separate pr after this prthe `package-infojava` has been extended as well; merging 5802 ;;;;1;1;""remove """"still"""""";"
5804;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: more observable marbles  01/10-a;more marbles for  observable :;;0;2x: more observable marbles 01/10-a;more marbles for `observable`:- [retry(int)]( [retry(bifunction)]( [retry(predicate)]( [retry(int predicate)]( [retryuntil(booleansupplier)]( [share]( [switchmapsingle]( [switchmapsingledelayerror]( in https://githubcom/reactivex/rxjava/issues/5319#issuecomment-356560596; merging 5804 ;;;;1;1;2x: more observable marbles 01/10-a;
5805;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: final planned observable marble additions/fixes;this is the final part of the  observable  marble fixes and additions as planned in #5319.;;5319.0;2x: final planned observable marble additions/fixes;this is the final part of the `observable` marble fixes and additions as planned in #5319- [tolist(callable)]( [toflowable(buffer)]( [toflowable(drop)]( [toflowable(latest)]( [toflowable(error)]( [toflowable(missing)]( [unsubscribeon](  position and spacing of the marbles in the `zipwith` overloads (no image change)images in https://githubcom/reactivex/rxjava/issues/5319#issuecomment-356630375; merging 5805 ;2x: observable missing or incorrect images (tracking issue);-  [observablesingleorerror()]( there is no default value and an empty source should result in an error-  `observablecombinelatestdelayerror(observablesource function)`: missing diagram-  `observablecombinelatestdelayerror(function int observablesource)`: missing diagram-  `observableconcatarrayeager`: missing diagram-  `observableerror`: should include the x in the operator body indicating it as being the parameter/return value-  `observablefromfuture`: the operator name in the box-  `observablefromiterable`: the operator name in the box-  `observablefrompublisher`: missing diagram-  `observablejust`: the element should be a parameter inside the box such outside elements imply a subject type external push-  `observablejust(t t)` +7: optionally tailor the diagram to the actual number of arguments plus move the constant values inside the box- [x] `observablerangelong`: the operator name in the box- [x] `observableswitchonnextdelayerror`: the operator name in the box indicator of an error getting delayed- [x] `observableziparray`: indicate there is a function instead of implying the output is an array containing one element from each source- [x] `observablezipiterable`: the operator name in the box- [x] `observableall`: example of a false result- [x] `observableambwith`: the operator name in the box- [x] `observableblockingfirst`: missing diagram- [x] `observableblockingforeach`: the operator name in the box- [x] `observableblockingiterable`: the operator name in the box indicate that blocking may happen for each element- [x] `observableblockinglast`: the operator name in the box- [x] `observableblockinglast(t)`: the operator name in the box indicate default in the box fix labels- [x] `observableblockinglatest`: missing diagram- [x] `observableblockingmostrecent`: the operator name in the box- [x] `observableblockingnext`: the operator name in the box- [x] `observableblockingsingle`: the operator name in the box- [x] `observableblockingsingle(t)`: the operator name in the box indicate default in the box fix labels- [x] `observabletofuture()`: the operator name in the box indicate multi-value empty and error behavior- [x] `observableblockingsubscribe`: missing diagram- [x] `observablecachewithinitialcapacity`: the operator name in the box- [x] `observablecollectinto`: the operator name in the box indicate the shared collection- [x] `observableconcatmapcompletable`: missing diagram- [x] `observableconcatmapdelayerror`: missing diagram- [x] `observableconcatmapeager`: missing diagram- [x] `observableconcatmapeagerdelayerror`: missing diagram- [x] `observableconcatmapiterable`: missing diagram- [x] `observabledoafternext`: missing diagram- [x] `observabledofinally`: missing diagram- [x] `observabledoondispose`: the operator name in the box- [x] `observabledooncomplete`: indicate that the events pass through and the star is execute before the oncomplete to downstream- [x] `observabledoonerror`: indicate that the events pass through and the star is execute before the onerror to downstream- [x] `observabledoonlifecycle`: change unsubscribe to dispose- [x] `observabledoonnext`: indicate that the events pass through and the star is execute before the onnext to downstream- [x] `observabledoonterminate`: indicate that the events pass through and the star is execute before the onerror or oncomplete to downstream- [x] `observableelementat(long)`: example of empty source- [x] `observableelementat(long t)`: example of empty source- [x] `observableelementatorerror(long)`: example of empty source- [x] `observablefirstelement`: diagram is stretched- [x] `observablefirstorerror`: the operator name in the box- [x] `observableflatmap(function boolean int)`: missing diagram- [x] `observableflatmap(function boolean int int)`: missing diagram- [x] `observableflatmap(function function callable int)`: missing diagram- [x] `observableflatmap(function int)`: missing diagram- [x] `observableflatmap(function bifunction boolean int)`: missing diagram- [x] `observableflatmap(function bifunction boolean int int)`: missing diagram- [x] `observableflatmap(function bifunction int)`: missing diagram- [x] `observableflatmapcompletable()`: missing diagram- [x] `observableflatmapiterable(function)`: diagram looks stretched- [x] `observableforeach()`: missing diagram- [x] `observableforeachwhile()`: missing diagram- [x] `observablehide()`: missing diagram - not sure how to represent this- [x] `observablelastorerror()`: operator name in the box error case example- [x] `observableonerrorreturn()`: indicate that the value is the result of a function call- [x] `observableonerrorreturnitem()`: operator name in the box- [x] `observableonterminatedetach`: missing diagram- [x] `observablepublish(function)`: there is no connect call may need extensive redrawing- [x] `observablereducewith()`: operator name in the box- [x] `observablerepeat()` + overloads: indicate fresh subscriptions happen not caching- [x] `observablerepeatuntil`: operator name in the box indicate fresh subscriptions- [x] `observablereplay()` + overloads: remove publish- [x] `observablereplay(function )` overloads: may need extensive redrawing- [x] `observableretry(long)` indicate limited retry effect- [x] `observableretry(predicate)` indicate predicate effect show it in the box- [x] `observableretry(long predicate)` indicate predicate show them in the box- [x] `observableretryuntil`: operator name in the box show booleansupplier- [x] `observableshare()`: fix labels with unsubscribe- [x] `observablesingleelement`: example with empty source- [x] `observablesorted`: missing diagram- [x] `observablestartwith(t)`: have a single item as start value- [x] `observablestartwitharray(t)`: operator name- [x] `observablesubscribe` + overloads: missing diagram- [x] [observableswitchmapsingle]( inner sources should have 1 item- [x] `observableswitchmapdelayerror` + indicate the error case- [x] `observabletolist(callable)`: indicate the custom collection somehow?- [x] `observabletoflowable()`: missing diagram- [x] `observableunsubscribeon()`: missing diagram- [x] `observablezipwith()` + overloads: the diagram is in line with some text and appears pushed to the right- [x] `observabletest()`: missing diagram can this be represented as diagram?;prs welcome the most easy ones are those that require alignment/displayed size corrections || hi david id love to help what would i use to edit the diagrams? || if you are on mac and you own omnigraffle there is a file for **all** traditional diagrams: using excel 2007+ on windows to draw the newer diagrams and have a file [here]( you can use as basis for newer diagrams i dont know if the open office variants could open this file or not googles viewer certainly doesnt show the drawingsi suppose as a last resort you can draw in the open-office variants as well and post the pngs in this issue uploading it requires access to the wiki git of rxjava the target rendering is 640 pixels wide and as long as it needs to bethe process is as follows:- draw diagram(s)- upload to git- modify javadoc locally to point to the raw usercontent- verify and fix alignment/stretching- commit pr to rxjava itself || is it `switchmapsingle` need a new diagram too? singleresource cant emit 2 items || yes ill add it to the list above || ## concatarrayeager( || ## error![image]( || ## fromfuture![image]( || ## fromiterable![image]( || another option is to use free open-source multi-platform inkscape templates here: || **startwith(t)**![startwith t]( || **startwitharray(t)**![startwitharray]( || thanks could you make sure the operator box has its contents centered? || sure going to edit them || **sorted()**is it okay to add numbers to the marbles?![sorted]( || in this case yes because it also demonstrates the self-comparable nature required (changing the order of colors is unlikely to convey the sorting aspect) for most of the other operators the matching up of the color should be enough || not sure how you do these images could you add shadows to the marbles the time arrows and the vertical complete indicators? || im using @davidmotens template going to edit them to add the shadows  || sorted(): it would be better that the source marbles are at the beginning and the output is only happening after oncomplete:```---5--3--1--4--2--|--------------[            sorted()           ]---------------------1-2-3-4-5-|-``` || added shadows and edited the `sorted()` operator || **just(t)**![just]( || **rangelong()**![rangelong]( || thanks @leonardortlima ! the first 5 images is added via #5524 || just noticed that `singlefilter` and `maybefilter` are also incorrect they seem to be copied from `observablefilter` || quite possibly the other base reactive classes have copy-paste diagrams this issue tracks the fixes of `observable` but if you want i can open issues for the other classes individually || ![just(2)]( || from #5668:![singleelement]( || ### zipiterable![zipiterable]( ambwith![ambwith]( blockingforeach![blockingforeach]( blockingiterable![blockingiterable]( blockinglast![blockinglast]( blockingmostrecent![blockingmostrecent]( blockingnext![blockingnext]( blockingsingle![blockingsingle]( cachewithinitialcapacity![cachecwithinitialcapacity]( || ### all![cachecwithinitialcapacity]( frompublisher![cachecwithinitialcapacity]( ziparray![cachecwithinitialcapacity]( || ### blockingfirst![blockingfirst]( tofuture![tofuture]( blockingsubscribe![blockingsubscribe]( collectinto![collectinto]( dooncomplete![dooncomplete]( doonerror![doonerror]( doonlifecycle![doonlifecycle]( doonnext![doonnext]( || ### concatmapcompletable![concatmapcompletable]( concatmapdelayerror![concatmapdelayerror]( concatmapeager![concatmapeager]( concatmapeagerdelayerror![concatmapeagerdelayerror]( concatmapiterable![concatmapiterable]( doafternext![doafternext]( dofinally![dofinally]( || ### doonterminate![doonterminate]( elementat![elementat]( elementatorerror![elementatorerror]( firstorerror![firstorerror]( flatmap![flatmap]( || ![flatmapcompletable]( || ![lastorerror]( f)](  ![replay(int long timeunit)]( long timeunit scheduler)]( scheduler)]( timeunit)]( timeunit scheduler)]( || ![no arguments]( scheduler]( scheduler]( time]( time scheduler]( || ![retry(int)]( predicate)]( || ![tolist(callable)]( ||;1;0;2x: final planned observable marble additions/fixes;
5811;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix buffer(open  close) not disposing indicators properly;the pr fixes the resource management in the  buffer  operator that uses other reactive sources to indicate when a buffer starts and ends. both  flowable  and  observable  implementations had to be fixed.;;580.0;2x: fix buffer(open close) not disposing indicators properly;the pr fixes the resource management in the `buffer` operator that uses other reactive sources to indicate when a buffer starts and ends both `flowable` and `observable` implementations had to be fixes: #5809;@akarnokd let me know if i understand the spirit of this pr on `flowablebufferboundary`:1 avoids keeping reference to / tracking buffers in subscribers other than the main2 cancel source on open subscriber completion (if it completes and the last buffers close publisher has completed subscribers will have size 0 and we can safely cancel upstream as no new buffer will open at this point)3 in main distinguish a open subscriber error from a close subscriber error (due to 1 the later needs associated buffer cleanup)is that correct/exhaustive? || > avoids keeping reference to / tracking buffers in subscribers other than the mainyes> cancel source on open subscriber completion (if it completes and the last buffers close publisher has completed subscribers will have size 0 and we can safely cancel upstream as no new buffer will open at this pointyes> in main distinguish a open subscriber error from a close subscriber error (due to 1 the later needs associated buffer cleanupno if the `openerror` or `closeerror` is fired both should cancel the main source cancel the subscribers other than themselves clean the buffer and then report the error they could be converted into a common method of `boundserror(disposable d throwable ex)` ||  merging 5811 ;crlf fixes;issue #579in case the manual mode is chosen;#519  i added the gitattributes file in this commit:  and then let git renormalize itself as per  ||;1;0;fix nits;
5816;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add subject and processor marbles;this pr adds the missing marble diagrams to the various  subject  and  processor  implementations:;;0;2x: add subject and processor marbles;this pr adds the missing marble diagrams to the various `subject` and `processor` implementations:### asyncsubject![asyncsubject]( publishsubject![publishsubject]( replaysubject![replaysubject1]( completablesubject![completablesubject]( singlesubject![singlesubject]( maybesubject![maybesubject]( asyncprocessor![asyncprocessor]( publishprocessor![publishprocessor]( replayprocessor![replayprocessor1](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/replayprocessorupng)![replayprocessor2](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/replayprocessoruepng)![replayprocessor3](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/replayprocessornpng)![replayprocessor4](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/replayprocessortpng)![replayprocessor5](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/replayprocessorntpng); merging 5816 ;;;;1;1;2x: add subject and processor marbles;
"5820;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;1.x: plugin lookup workaround for system.properties access restrictions;the pr adds a  try-catch  around the system property lookup inside the  rxjavaplugins  in case a security manager prevents reading arbitrary property entries.;;5819.0;1x: plugin lookup workaround for systemproperties access restrictions;the pr adds a `try-catch` around the system property lookup inside the `rxjavaplugins` in case a security manager prevents reading arbitrary property entriesthis mainly affects the `rxjavaplugin[index]class` lookup which were introduced due to the 31 character key limit on androidhowever when running in a container such as tomcat a security manager may prevent reading these type of pre entries (where `[index]` cant be known upfront) crashing the initialization**update**:the `systemgetproperties()` can also fail therefore retrieving the properties has been factored out into a separate method that returns an empty properties5819; merging 5820 ;rxjavapluginsjava should not be reading all system properties;hii am working on 134 version of rxjava jar and there are certain methods where rxjavapluginsjava is trying to read all the system properties while getting hooks not all companies give access to their system properties on server for example we use tomcat and have catalina policy which restricts to properties mentioned there due to this i am getting access denied exceptionsi propose 2 solutions:1 remove systemgetproperties() and it should be able to read only properties which are required to get the hooks2 provide an implementation via application property which doesnt look for implementation at alli am okay with either solution please help;""it was a long time ago and im not sure we know what keys to look for hence the full enumeration besides v1 is nearly eol so please consider upgrading to rxjava 2 which shouldnt have this problem || it came to my thought that but we are not using rxjava dependency directly this is being referenced as a compile dependency from spring-cloud-starter-hystrix jar if rxjava 2x is backward compatible i can use it but it looks like there are quite a few enhancements || workaround posted in #5820 i assume the exception happens in the `entryset` iteration and not in the `clone` line right? || no they actually happen in the following methods of rxjavapluginsgeterrorhandler()getobservableexecutionhook()getsingleexecutionhook()getcompletableexecutionhook()getschedulershook()these methods are being currently called as default implementations if custom handlers/hooks are not available these methods search for """"all system properties"""" first to look for implementation class defined in system property instead of looking for certain system properties || please post the full stacktrace of the exception you are getting || ```25-jan-2018 03 55941 severe [localhost-startstop-1] orgapachecatalinacorecontainerbaseaddchildinternal containerbaseaddchild: start  failed to start component [standardengine[catalina]standardhost[localhost]standardcontext[/xxx]]        at orgapachecatalinautillifecyclebasestart(lifecyclebasejava:167)        at orgapachecatalinacorecontainerbaseaddchildinternal(containerbasejava:752)        at orgapachecatalinacorecontainerbaseaccess$000(containerbasejava:129)        at orgapachecatalinacorecontainerbase$privilegedaddchildrun(containerbasejava:150)        at orgapachecatalinacorecontainerbase$privilegedaddchildrun(containerbasejava:140)        at javasecurityaccesscontrollerdoprivileged(native method)        at orgapachecatalinacorecontainerbaseaddchild(containerbasejava:726)        at orgapachecatalinacorestandardhostaddchild(standardhostjava:734)        at orgapachecatalinastartuphostconfigdeploywar(hostconfigjava:986)        at orgapachecatalinastartuphostconfig$deploywarrun(hostconfigjava:1857)        at javautilconcurrentexecutors$runnableadaptercall(executorsjava:511)        at javautilconcurrentfuturetaskrun(futuretaskjava:266)        at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1149)        at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:624)        at javalangthreadrun(threadjava:748)caused by: orgspringframeworkbeansfactoryunsatisfieddependencyexception: error creating bean with name documentationpluginsbootstrapper defined in url [jar /d:/dev/apache-tomcat-8524/temp/0-contestgateway/web-inf/lib/springfox-spring-web-280j!/springfox/documentation/spring/web/plugins/documentationpluginsbootstrapperclass]: unsatisfied dependency expressed through constructor parameter 1 nested exception is orgspringframeworkbeansfactoryunsatisfieddependencyexception: error creating beanth name webmvcrequesthandlerprovider defined in url [jar /d:/dev/apache-tomcat-8524/temp/0-contestgateway/web-inf/lib/springfox-spring-web-280jar!/springfox/documentation/spring/web/plugins/webmvcrequesthandlerproviderclass]: unsatisfied dependey expressed through constructor parameter 1 nested exception is orgspringframeworkbeansfactorybeancreationexception: error creating bean with name endpointhandlermapping defined in class path resource [org/springframework/boot/actuate/autoconfigure/enointwebmvcmanagementcontextconfigurationclass]: bean instantiation via factory method failed nested exception is orgspringframeworkbeansbeaninstantiationexception: failed to instantiate [orgspringframeworkbootactuateendpointmvcendpointhandlermappi]: factory method endpointhandlermapping threw exception nested exception is orgspringframeworkbeansfactorybeancreationexception: error creating bean with name mvcendpoints defined in class path resource [org/springframework/boot/actuate/autoconfigu/endpointwebmvcmanagementcontextconfigurationclass]: invocation of init method failed nested exception is orgspringframeworkbeansfactorybeancreationexception: error creating bean with name hystrixstreamendpoint defined in class path resource [org/sprgframework/cloud/netflix/hystrix/hystrixcircuitbreakerconfiguration$hystrixwebconfigurationclass]: invocation of init method failed nested exception is javalangexceptionininitializererror        at orgspringframeworkbeansfactorysupportconstructorresolvercreateargumentarray(constructorresolverjava:749)        at orgspringframeworkbeansfactorysupportconstructorresolverautowireconstructor(constructorresolverjava:189)        at orgspringframeworkbeansfactorysupportabstractautowirecapablebeanfactoryautowireconstructor(abstractautowirecapablebeanfactoryjava:1193)        at orgspringframeworkbeansfactorysupportabstractautowirecapablebeanfactorycreatebeaninstance(abstractautowirecapablebeanfactoryjava:1095)        at orgspringframeworkbeansfactorysupportabstractautowirecapablebeanfactorydocreatebean(abstractautowirecapablebeanfactoryjava:513)        at orgspringframeworkbeansfactorysupportabstractautowirecapablebeanfactorycreatebean(abstractautowirecapablebeanfactoryjava:483)        at orgspringframeworkbeansfactorysupportabstractbeanfactory$1getobject(abstractbeanfactoryjava:306)        at orgspringframeworkbeansfactorysupportdefaultsingletonbeanregistrygetsingleton(defaultsingletonbeanregistryjava:230)        at orgspringframeworkbeansfactorysupportabstractbeanfactorydogetbean(abstractbeanfactoryjava:302)        at orgspringframeworkbeansfactorysupportabstractbeanfactorygetbean(abstractbeanfactoryjava:197)        at orgspringframeworkbeansfactorysupportdefaultlistablebeanfactorypreinstantiatesingletons(defaultlistablebeanfactoryjava:761)        at orgspringframeworkcontextsupportabstractapplicationcontextfinishbeanfactoryinitialization(abstractapplicationcontextjava:867)        at orgspringframeworkcontextsupportabstractapplicationcontextrefresh(abstractapplicationcontextjava:543)        at orgspringframeworkbootcontextembeddedembeddedwebapplicationcontextrefresh(embeddedwebapplicationcontextjava:122)        at orgspringframeworkbootspringapplicationrefresh(springapplicationjava:693)        at orgspringframeworkbootspringapplicationrefreshcontext(springapplicationjava:360)        at orgspringframeworkbootspringapplicationrun(springapplicationjava:303)        at orgspringframeworkbootwebsupportspringbootservletinitializerrun(springbootservletinitializerjava:154)        at orgspringframeworkbootwebsupportspringbootservletinitializercreaterootapplicationcontext(springbootservletinitializerjava:134)        at orgspringframeworkbootwebsupportspringbootservletinitializeronstartup(springbootservletinitializerjava:87)        at orgspringframeworkwebspringservletcontainerinitializeronstartup(springservletcontainerinitializerjava:169)        at orgapachecatalinacorestandardcontextstartinternal(standardcontextjava:5196)        at orgapachecatalinautillifecyclebasestart(lifecyclebasejava:150)         14 morecaused by: orgspringframeworkbeansfactoryunsatisfieddependencyexception: error creating bean with name webmvcrequesthandlerprovider defined in url [jar /d:/dev/apache-tomcat-8524/temp/0-contestgateway/web-inf/lib/springfox-spring-web-280jar!/ringfox/documentation/spring/web/plugins/webmvcrequesthandlerproviderclass]: unsatisfied dependency expressed through constructor parameter 1 nested exception is orgspringframeworkbeansfactorybeancreationexception: error creating bean with name endpoihandlermapping defined in class path resource [org/springframework/boot/actuate/autoconfigure/endpointwebmvcmanagementcontextconfigurationclass]: bean instantiation via factory method failed nested exception is orgspringframeworkbeansbeaninstantiationeeption: failed to instantiate [orgspringframeworkbootactuateendpointmvcendpointhandlermapping]: factory method endpointhandlermapping threw exception nested exception is orgspringframeworkbeansfactorybeancreationexception: error creating bean winame mvcendpoints defined in class path resource [org/springframework/boot/actuate/autoconfigure/endpointwebmvcmanagementcontextconfigurationclass]: invocation of init method failed nested exception is orgspringframeworkbeansfactorybeancreationexcepon: error creating bean with name hystrixstreamendpoint defined in class path resource [org/springframework/cloud/netflix/hystrix/hystrixcircuitbreakerconfiguration$hystrixwebconfigurationclass]: invocation of init method failed nested exception is javangexceptionininitializererror        at orgspringframeworkbeansfactorysupportconstructorresolvercreateargumentarray(constructorresolverjava:749)        at orgspringframeworkbeansfactorysupportconstructorresolverautowireconstructor(constructorresolverjava:189)        at orgspringframeworkbeansfactorysupportabstractautowirecapablebeanfactoryautowireconstructor(abstractautowirecapablebeanfactoryjava:1193)        at orgspringframeworkbeansfactorysupportabstractautowirecapablebeanfactorycreatebeaninstance(abstractautowirecapablebeanfactoryjava:1095)        at orgspringframeworkbeansfactorysupportabstractautowirecapablebeanfactorydocreatebean(abstractautowirecapablebeanfactoryjava:513)        at orgspringframeworkbeansfactorysupportabstractautowirecapablebeanfactorycreatebean(abstractautowirecapablebeanfactoryjava:483)        at orgspringframeworkbeansfactorysupportabstractbeanfactory$1getobject(abstractbeanfactoryjava:306)        at orgspringframeworkbeansfactorysupportdefaultsingletonbeanregistrygetsingleton(defaultsingletonbeanregistryjava:230)        at orgspringframeworkbeansfactorysupportabstractbeanfactorydogetbean(abstractbeanfactoryjava:302)        at orgspringframeworkbeansfactorysupportabstractbeanfactorygetbean(abstractbeanfactoryjava:202)        at orgspringframeworkbeansfactoryconfigdependencydescriptorresolvecandidate(dependencydescriptorjava:208)        at orgspringframeworkbeansfactorysupportdefaultlistablebeanfactoryaddcandidateentry(defaultlistablebeanfactoryjava:1316)        at orgspringframeworkbeansfactorysupportdefaultlistablebeanfactoryfindautowirecandidates(defaultlistablebeanfactoryjava:1282)        at orgspringframeworkbeansfactorysupportdefaultlistablebeanfactoryresolvemultiplebeans(defaultlistablebeanfactoryjava:1180)        at orgspringframeworkbeansfactorysupportdefaultlistablebeanfactorydoresolvedependency(defaultlistablebeanfactoryjava:1096)        at orgspringframeworkbeansfactorysupportdefaultlistablebeanfactoryresolvedependency(defaultlistablebeanfactoryjava:1066)        at orgspringframeworkbeansfactorysupportconstructorresolverresolveautowiredargument(constructorresolverjava:835)        at orgspringframeworkbeansfactorysupportconstructorresolvercreateargumentarray(constructorresolverjava:741)         36 morecaused by: orgspringframeworkbeansfactorybeancreationexception: error creating bean with name endpointhandlermapping defined in class path resource [org/springframework/boot/actuate/autoconfigure/endpointwebmvcmanagementcontextconfigurationclass]: beainstantiation via factory method failed nested exception is orgspringframeworkbeansbeaninstantiationexception: failed to instantiate [orgspringframeworkbootactuateendpointmvcendpointhandlermapping]: factory method endpointhandlermapping threw exction nested exception is orgspringframeworkbeansfactorybeancreationexception: error creating bean with name mvcendpoints defined in class path resource [org/springframework/boot/actuate/autoconfigure/endpointwebmvcmanagementcontextconfigurationclass]invocation of init method failed nested exception is orgspringframeworkbeansfactorybeancreationexception: error creating bean with name hystrixstreamendpoint defined in class path resource [org/springframework/cloud/netflix/hystrix/hystrixcircuitbreakconfiguration$hystrixwebconfigurationclass]: invocation of init method failed nested exception is javalangexceptionininitializererror        at orgspringframeworkbeansfactorysupportconstructorresolverinstantiateusingfactorymethod(constructorresolverjava:599)        at orgspringframeworkbeansfactorysupportabstractautowirecapablebeanfactoryinstantiateusingfactorymethod(abstractautowirecapablebeanfactoryjava:1173)        at orgspringframeworkbeansfactorysupportabstractautowirecapablebeanfactorycreatebeaninstance(abstractautowirecapablebeanfactoryjava:1067)        at orgspringframeworkbeansfactorysupportabstractautowirecapablebeanfactorydocreatebean(abstractautowirecapablebeanfactoryjava:513)        at orgspringframeworkbeansfactorysupportabstractautowirecapablebeanfactorycreatebean(abstractautowirecapablebeanfactoryjava:483)        at orgspringframeworkbeansfactorysupportabstractbeanfactory$1getobject(abstractbeanfactoryjava:306)        at orgspringframeworkbeansfactorysupportdefaultsingletonbeanregistrygetsingleton(defaultsingletonbeanregistryjava:230)        at orgspringframeworkbeansfactorysupportabstractbeanfactorydogetbean(abstractbeanfactoryjava:302)        at orgspringframeworkbeansfactorysupportabstractbeanfactorygetbean(abstractbeanfactoryjava:202)        at orgspringframeworkbeansfactoryconfigdependencydescriptorresolvecandidate(dependencydescriptorjava:208)        at orgspringframeworkbeansfactorysupportdefaultlistablebeanfactoryaddcandidateentry(defaultlistablebeanfactoryjava:1316)        at orgspringframeworkbeansfactorysupportdefaultlistablebeanfactoryfindautowirecandidates(defaultlistablebeanfactoryjava:1282)        at orgspringframeworkbeansfactorysupportdefaultlistablebeanfactoryresolvemultiplebeans(defaultlistablebeanfactoryjava:1180)        at orgspringframeworkbeansfactorysupportdefaultlistablebeanfactorydoresolvedependency(defaultlistablebeanfactoryjava:1096)        at orgspringframeworkbeansfactorysupportdefaultlistablebeanfactoryresolvedependency(defaultlistablebeanfactoryjava:1066)        at orgspringframeworkbeansfactorysupportconstructorresolverresolveautowiredargument(constructorresolverjava:835)        at orgspringframeworkbeansfactorysupportconstructorresolvercreateargumentarray(constructorresolverjava:741)         53 morecaused by: orgspringframeworkbeansbeaninstantiationexception: failed to instantiate [orgspringframeworkbootactuateendpointmvcendpointhandlermapping]: factory method endpointhandlermapping threw exception nested exception is orgspringframeworkbesfactorybeancreationexception: error creating bean with name mvcendpoints defined in class path resource [org/springframework/boot/actuate/autoconfigure/endpointwebmvcmanagementcontextconfigurationclass]: invocation of init method failed nested exceptiis orgspringframeworkbeansfactorybeancreationexception: error creating bean with name hystrixstreamendpoint defined in class path resource [org/springframework/cloud/netflix/hystrix/hystrixcircuitbreakerconfiguration$hystrixwebconfigurationclass]: incation of init method failed nested exception is javalangexceptionininitializererror        at orgspringframeworkbeansfactorysupportsimpleinstantiationstrategyinstantiate(simpleinstantiationstrategyjava:189)        at orgspringframeworkbeansfactorysupportconstructorresolver$3run(constructorresolverjava:582)        at javasecurityaccesscontrollerdoprivileged(native method)        at orgspringframeworkbeansfactorysupportconstructorresolverinstantiateusingfactorymethod(constructorresolverjava:579)         69 morecaused by: orgspringframeworkbeansfactorybeancreationexception: error creating bean with name mvcendpoints defined in class path resource [org/springframework/boot/actuate/autoconfigure/endpointwebmvcmanagementcontextconfigurationclass]: invocation ofnit method failed nested exception is orgspringframeworkbeansfactorybeancreationexception: error creating bean with name hystrixstreamendpoint defined in class path resource [org/springframework/cloud/netflix/hystrix/hystrixcircuitbreakerconfigurationystrixwebconfigurationclass]: invocation of init method failed nested exception is javalangexceptionininitializererror        at orgspringframeworkbeansfactorysupportabstractautowirecapablebeanfactoryinitializebean(abstractautowirecapablebeanfactoryjava:1628)        at orgspringframeworkbeansfactorysupportabstractautowirecapablebeanfactorydocreatebean(abstractautowirecapablebeanfactoryjava:555)        at orgspringframeworkbeansfactorysupportabstractautowirecapablebeanfactorycreatebean(abstractautowirecapablebeanfactoryjava:483)        at orgspringframeworkbeansfactorysupportabstractbeanfactory$1getobject(abstractbeanfactoryjava:306)        at orgspringframeworkbeansfactorysupportdefaultsingletonbeanregistrygetsingleton(defaultsingletonbeanregistryjava:230)        at orgspringframeworkbeansfactorysupportabstractbeanfactorydogetbean(abstractbeanfactoryjava:302)        at orgspringframeworkbeansfactorysupportabstractbeanfactorygetbean(abstractbeanfactoryjava:197)        at orgspringframeworkcontextannotationconfigurationclassenhancer$beanmethodinterceptorobtainbeaninstancefromfactory(configurationclassenhancerjava:389)        at orgspringframeworkcontextannotationconfigurationclassenhancer$beanmethodinterceptorintercept(configurationclassenhancerjava:361)        at orgspringframeworkbootactuateautoconfigureendpointwebmvcmanagementcontextconfiguration$$enhancerbyspringcglib$$f0fb20abmvcendpoints(<generated>)        at orgspringframeworkbootactuateautoconfigureendpointwebmvcmanagementcontextconfigurationendpointhandlermapping(endpointwebmvcmanagementcontextconfigurationjava:100)        at orgspringframeworkbootactuateautoconfigureendpointwebmvcmanagementcontextconfiguration$$enhancerbyspringcglib$$f0fb20abcglib$endpointhandlermapping$0(<generated>)        at orgspringframeworkbootactuateautoconfigureendpointwebmvcmanagementcontextconfiguration$$enhancerbyspringcglib$$f0fb20ab$$fastclassbyspringcglib$$950684einvoke(<generated>)        at orgspringframeworkcglibproxymethodproxyinvokesuper(methodproxyjava:228)        at orgspringframeworkcontextannotationconfigurationclassenhancer$beanmethodinterceptorintercept(configurationclassenhancerjava:358)        at orgspringframeworkbootactuateautoconfigureendpointwebmvcmanagementcontextconfiguration$$enhancerbyspringcglib$$f0fb20abendpointhandlermapping(<generated>)        at sunreflectnativemethodaccessorimplinvoke0(native method)        at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)        at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)        at javalangreflectmethodinvoke(methodjava:498)        at orgspringframeworkbeansfactorysupportsimpleinstantiationstrategyinstantiate(simpleinstantiationstrategyjava:162)         72 morecaused by: orgspringframeworkbeansfactorybeancreationexception: error creating bean with name hystrixstreamendpoint defined in class path resource [org/springframework/cloud/netflix/hystrix/hystrixcircuitbreakerconfiguration$hystrixwebconfigurationcla]: invocation of init method failed nested exception is javalangexceptionininitializererror        at orgspringframeworkbeansfactorysupportabstractautowirecapablebeanfactoryinitializebean(abstractautowirecapablebeanfactoryjava:1628)        at orgspringframeworkbeansfactorysupportabstractautowirecapablebeanfactorydocreatebean(abstractautowirecapablebeanfactoryjava:555)        at orgspringframeworkbeansfactorysupportabstractautowirecapablebeanfactorycreatebean(abstractautowirecapablebeanfactoryjava:483)        at orgspringframeworkbeansfactorysupportabstractbeanfactory$1getobject(abstractbeanfactoryjava:306)        at orgspringframeworkbeansfactorysupportdefaultsingletonbeanregistrygetsingleton(defaultsingletonbeanregistryjava:230)        at orgspringframeworkbeansfactorysupportabstractbeanfactorydogetbean(abstractbeanfactoryjava:302)        at orgspringframeworkbeansfactorysupportabstractbeanfactorygetbean(abstractbeanfactoryjava:202)        at orgspringframeworkbeansfactorysupportdefaultlistablebeanfactorygetbeansoftype(defaultlistablebeanfactoryjava:519)        at orgspringframeworkbeansfactorysupportdefaultlistablebeanfactorygetbeansoftype(defaultlistablebeanfactoryjava:508)        at orgspringframeworkcontextsupportabstractapplicationcontextgetbeansoftype(abstractapplicationcontextjava:1188)        at orgspringframeworkbeansfactorybeanfactoryutilsbeansoftypeincludingancestors(beanfactoryutilsjava:261)        at orgspringframeworkbootactuateendpointmvcmvcendpointsafterpropertiesset(mvcendpointsjava:58)        at orgspringframeworkbeansfactorysupportabstractautowirecapablebeanfactory$6run(abstractautowirecapablebeanfactoryjava:1677)        at javasecurityaccesscontrollerdoprivileged(native method)        at orgspringframeworkbeansfactorysupportabstractautowirecapablebeanfactoryinvokeinitmethods(abstractautowirecapablebeanfactoryjava:1674)        at orgspringframeworkbeansfactorysupportabstractautowirecapablebeanfactoryinitializebean(abstractautowirecapablebeanfactoryjava:1624)         92 morecaused by: javalangexceptionininitializererror        at comnetflixhystrixcontribmetricseventstreamhystrixmetricsstreamservlet<init>(hystrixmetricsstreamservletjava:59)        at sunreflectnativeconstructoraccessorimplnewinstance0(native method)        at sunreflectnativeconstructoraccessorimplnewinstance(nativeconstructoraccessorimpljava:62)        at sunreflectdelegatingconstructoraccessorimplnewinstance(delegatingconstructoraccessorimpljava:45)        at javalangreflectconstructornewinstance(constructorjava:423)        at javalangclassnewinstance(classjava:442)        at orgspringframeworkwebservletmvcservletwrappingcontrollerafterpropertiesset(servletwrappingcontrollerjava:144)        at orgspringframeworkcloudnetflixendpointservletwrappingendpointafterpropertiesset(servletwrappingendpointjava:50)        at orgspringframeworkbeansfactorysupportabstractautowirecapablebeanfactory$6run(abstractautowirecapablebeanfactoryjava:1677)        at javasecurityaccesscontrollerdoprivileged(native method)        at orgspringframeworkbeansfactorysupportabstractautowirecapablebeanfactoryinvokeinitmethods(abstractautowirecapablebeanfactoryjava:1674)        at orgspringframeworkbeansfactorysupportabstractautowirecapablebeanfactoryinitializebean(abstractautowirecapablebeanfactoryjava:1624)         107 morecaused by: javasecurityaccesscontrolexception: access denied (""""javautilpropertypermission"""" """"*"""" """"readwrite"""")        at javasecurityaccesscontrolcontextcheckpermission(accesscontrolcontextjava:472)        at javasecurityaccesscontrollercheckpermission(accesscontrollerjava:884)        at javalangsecuritymanagercheckpermission(securitymanagerjava:549)        at javalangsecuritymanagercheckpropertiesaccess(securitymanagerjava:1262)        at javalangsystemgetproperties(systemjava:630)        at rxpluginsrxjavapluginsgetschedulershook(rxjavapluginsjava:345)        at rxschedulersschedulers<init>(schedulersjava:57)        at rxschedulersschedulersgetinstance(schedulersjava:46)        at rxschedulersschedulerscomputation(schedulersjava:123)        at rxobservableinterval(observablejava:2070)        at comnetflixhystrixmetricconsumerhystrixdashboardstream<init>(hystrixdashboardstreamjava:41)        at comnetflixhystrixmetricconsumerhystrixdashboardstream<clinit>(hystrixdashboardstreamjava:69)         119 more``` || updated the pr || thank you so much for your quick response and fix || closing via #5820 || "";1;0;systemgetproperties() can also throw securityexception;"
5824;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: improve the wording of the share() javadocs;this pr improves the wording of the  flowable.share()  and  observable.share()  operators and fixes a javadoc link display mistake:;;0;2x: improve the wording of the share() javadocs;this pr improves the wording of the `flowableshare()` and `observableshare()` operators and fixes a javadoc link display mistake:(https://user-imagesentcom/1269832/35439076-7a9816c4-0299-11e8-97ca-462238c6489fpng); ;;;;1;1;fix typo;
5826;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix o.blockingiterable(int) & add o.blockinglatest marbles;this pr fixes the  observable.blockingiterable(int)  marble by using the  blockingiterable  redone earlier.;;0;2x: fix oblockingiterable(int) & add oblockinglatest marbles;this pr fixes the `observableblockingiterable(int)` marble by using the `blockingiterable` redone earlierin addition the pr adds a marble diagram to `observableblockinglatest`:![blockinglatest](https://githubcom/reactivex/rxjava/wiki/images/rx-operators/blockinglatestopng); merging 5826 ;;;;1;1;2x: fix oblockingiterable(int) & add oblockinglatest marbles;
5828;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: document replay(n) emission retention caveat;adds javadocs indicating a caveat regarding size-bounded replay operators  subjects  and processors. see #5827 for details.;;5827.0;2x: document replay(n) emission retention caveat;adds javadocs indicating a caveat regarding size-bounded replay operators subjects and processors see #5827 for details; merging 5828 ;replay(1) retains second-to-last emitted item;version:  `2x`: `219`when using `observablereplay(1)` the second-to-last object emitted by the upstream observable is retained by the internal buffer i would expect only the last object to be retained and this is especially problematic if the objects are large such as an android `bitmap` or `activity`sample code:```kotlinval subject  behaviorsubjectcreate<int>()subjectonnext(1)subjectonnext(2)subjectonnext(3)val replay  subjectreplay(1)replayconnect()assertassertequals(listof(3) replaytest()values())subjectonnext(4)assertassertequals(listof(4) replaytest()values())subjectonnext(5)// replaycurrentvaluebuffervaluevalue contains 4assertassertequals(listof(5) replaytest()values())```;thats an unfortunate effect of the linked structure in `replay` and the facts that 1) discontinuity is not allowed and 2) observers subscribing concurrently should start somewherethats why the `head` references a `node` instance where the actual value is behind the `next` link this way observers can pick the head `node` and when the time is right for them start walking the links thus a `replay(1)` will have two nodes with a previous node and one with the cached value nulling out the previous node doesnt work as `replay` cant know there isnt a late consumer still walking the links from a much earlier nodeif there wasnt any initial empty `node` observers would have to keep check somehow when the first items `node` gets created unfortunately this potentially concurrent activity may lead to lost initial items for some observersthe third option would be reference counting nodes which is very expensive and complicatedif you need to cache the very latest simply keep using the `behaviorsubject` || thanks for the explanation i suspected along those linesif a fix isnt viable i think this is worth documenting as its counter-intuitive || pr welcome || there could be a less expensive approach by creating a fresh head node with link to the next cached item this should allow late observers to capture the head node and follow the next links and the head would no longer reference the previous item:```java        void trim() {            if (size > maxsize) {                size--                node<object> h  headget()                node<object> n  new node<object>(null)                nlazyset(hget())                head  n            }        }```the drawback is that there is now two nodes allocated per upstream itemnote that there are 2 base type replays 1 subject 1 processor and 2 bounded replay modes a total of 8 algorithms to adjust or document || closing via #5828 ||;1;0;2x: document size-bounded replay emission retention caveat (#5827);
5830;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: reword the just() operator and reference other typical alternatives;this pr updates the  flowable.just  and  observable.just  javadocs to clarify its behavior  namely it re-emits a constant reference and does not compute it. in addition  links to the other typical source operators are added. the redundant sentence about  just  were removed as well.;;0;2x: reword the just() operator and reference other typical alternatives;this pr updates the `flowablejust` and `observablejust` javadocs to clarify its behavior namely it re-emits a constant reference and does not compute it in addition links to the other typical source operators are added the redundant sentence about `just` were removed as well;;;;;1;1;fix a/an;
5833;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix observable.switchmap main onerror not disposing the current inner source;the  observable.switchmap  had bad logic in its main  onerror  handler which didn t dispose the current inner  observable .;;5832.0;2x: fix observableswitchmap main onerror not disposing the current inner source;the `observableswitchmap` had bad logic in its main `onerror` handler which didnt dispose the current inner `observable`the `flowable` version didnt have this logic error both variants received an unit test to verify the correct behavior5832; merging 5833 ;2x observable onerror does not dispose switchmaps inner observablesource;hi im facing an issue with observables switchmap/switchmapsingle where the inner source does not get disposed if the upstream emits an error happens on both version 216 and 219 is this the expected behavior?observable version does not dispose the inner source```                observable                create(e -> {                    eonnext(true)                    eonerror(new throwable())                })                switchmap(__ -> observable                        timer(500l timeunitmilliseconds)                        doonnext(systemout::println))                subscribe(__->{} __->{})        threadsleep(1000l)```while the flowable version does dispose the inner source```                flowable                create(e -> {                    eonnext(true)                    eonerror(new throwable())                } backpressurestrategybuffer)                switchmap(__ -> flowable                        timer(500l timeunitmilliseconds)                        doonnext(systemout::println))                subscribe(__->{} __->{})        threadsleep(1000l)```;thanks for reporting this is a bug in the `observableswitchmap` implementation fix posted in #5833 ||;1;0;fix error-error race test;
5834;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix copy-paste errors in singlesubject javadoc;the  singlesubject  javadoc was derived from the  maybesubject  javadoc and thus some mentions of  oncomplete  remained in there. this pr fixes copy-paste errors.;;0;2x: fix copy-paste errors in singlesubject javadoc;the `singlesubject` javadoc was derived from the `maybesubject` javadoc and thus some mentions of `oncomplete` remained in there this pr fixes copy-paste errors; merging 5834 ;;;;1;1;2x: fix copy-paste errors in singlesubject javadoc;
5837;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: detail distinct() & distinctuntilchanged() in javadoc;the pr clarifies the comparison and retention behavior of the  distinct  and  distinctuntilchanged  operators (in both  flowable  and  observable ).;;0;2x: detail distinct() & distinctuntilchanged() in javadoc;the pr clarifies the comparison and retention behavior of the `distinct` and `distinctuntilchanged` operators (in both `flowable` and `observable`); merging 5837  < ;;;;1;1;address feedback;
5838;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;added nullability annotation for rxjavaplugins.oncompletableassembly;just annotation that didn t exist;;0;added nullability annotation for rxjavapluginsoncompletableassembly;just annotation that didnt exist; merging 5838 ;;;;1;1;added nullability annotation for completable assembly;
5841;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: improve javadoc of xobserver types.;this pr improves the javadoc of the 4 rxjava main consumer types:;;0;2x: improve javadoc of xobserver types;this pr improves the javadoc of the 4 rxjava main consumer types:- `observer`- `singleobserver`- `maybeobserver`- `completableobserver`; merging 5841 ;;;;1;1;add more explanation about throwing exceptions;
5843;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: expand the javadocs of the scheduler api;this pr adds more details to the  scheduler  and  worker  api  rewords some older sentences and fixes a few mistakes in others.;;0;2x: expand the javadocs of the scheduler api;this pr adds more details to the `scheduler` and `worker` api rewords some older sentences and fixes a few mistakes in othersin addition the wording of the `schedulerrunnableintrospection` felt a bit clumsy and has been updated as well; merging 5843  < ;;;;1;1;fix typo and grammar;
5844;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: explain the properties of the xemitter interfaces in detail;this pr explains the properties of the 5 specifc  emitter  types in more details:;;0;2x: explain the properties of the xemitter interfaces in detail;this pr explains the properties of the 5 specifc `emitter` types in more details:- error handling- resource handling- concurrent use aspects- the difference between `disposable` and `cancellable` resource handling- terminal state effects; merging 5844  < ;;;;1;1;2x: explain the properties of the xemitter interfaces in detail;
5845;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add efficient concatwith(single|maybe|completable) overloads;this pr adds specialized overloads to the  concatwith  operator in  flowable  and  observable .;;5350.0;2x: add efficient concatwith(single|maybe|completable) overloads;this pr adds specialized overloads to the `concatwith` operator in `flowable` and `observable`if accepted the marbles will be updated in a separate prrelated: #5350; merging 5845 ;rxjava 2: observableconcatwith variants for single completable & maybe;how do you guys feel about `concatwith` variants that take `single` `completable` and `maybe` for now they could internally just use `toobservable()` and then maybe later receive custom implementations;another nice addition would be the `mergewith()` as well given that this has received some upvotes would you consider adding those methods? || use kotlin? || im doing that right now however having custom implementations could improve performance since certain shortcuts can be taken for instance knowing that single can only emit once or error once unlike `observable` / `flowable` variants || this can be closed now with #5845 & #5847  ||;1;0;change local variable names;
5847;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add efficient mergewith(single|maybe|completable) overloads.;this pr adds specialized overloads to the  mergewith  operator in  flowable  and  observable .;;5350.0;2x: add efficient mergewith(single|maybe|completable) overloads;this pr adds specialized overloads to the `mergewith` operator in `flowable` and `observable`if accepted the marbles will be updated in a separate prrelated: #5350; merging 5847 ;rxjava 2: observableconcatwith variants for single completable & maybe;how do you guys feel about `concatwith` variants that take `single` `completable` and `maybe` for now they could internally just use `toobservable()` and then maybe later receive custom implementations;another nice addition would be the `mergewith()` as well given that this has received some upvotes would you consider adding those methods? || use kotlin? || im doing that right now however having custom implementations could improve performance since certain shortcuts can be taken for instance knowing that single can only emit once or error once unlike `observable` / `flowable` variants || this can be closed now with #5845 & #5847  ||;1;0;merge branch 2x into mergewith_0_1_types;
5848;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: improve the wording of the maybe.fromcallable javadoc;this pr improves the wording and details of the  maybe.fromcallable  operator s javadoc.;;0;2x: improve the wording of the maybefromcallable javadoc;this pr improves the wording and details of the `maybefromcallable` operators javadoc; merging 5848 ;;;;1;1;2x: improve the wording of the maybefromcallable javadoc;
"5856;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add finite requirement to various collector operators javadoc;add notes to the following operators to state their sources has to be finite. it has been already done to  tolist  in #5465.;;0;2x: add finite requirement to various collector operators javadoc;add notes to the following operators to state their sources has to be finite it has been already done to `tolist` in #5465- `collect`- `collectinto`- `reduce`- `reducewith`- `tomap`- `tomultimap`- `tosortedlist`; merging 5856 ;;;;1;1;""updated wording to """"accumulator object"""""";"
5857;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: unify race test loop counts and invocations;this pr replaces the individual race-test loop counts with global constants and removes the unnecessary custom  scheduler  value from the invocations of  testhelper.race() .;;0;2x: unify race test loop counts and invocations;this pr replaces the individual race-test loop counts with global constants and removes the unnecessary custom `scheduler` value from the invocations of `testhelperrace()`the default loop count is now 2500 and should elimitate the +/- 01% coverage fluctuations; merging 5857 ;;;;1;1;2x: unify race test loop counts and invocations;
5858;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: remove unnecessary comment from observable.timeinterval(timeunit);;;0;2x: remove unnecessary comment from observabletimeinterval(timeunit);;@akarnokd ive checked its ok ||  merging 5858 ;;;;1;1;remove unnecessary comment from observabletimeinterval(timeunit);
"5860;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: flowable.groupby add overload with evicting map factory;as per discussion in #5763  this pr adds an overload for  flowable.groupby  that specifies an  evictingmapfactory .;;5763.0;2x: flowablegroupby add overload with evicting map factory;as per discussion in #5763 this pr adds an overload for `flowablegroupby` that specifies an `evictingmapfactory` an example of usage taken from the new javadoc:```javafunction<consumer<object> map<integer object>> evictingmapfactory     notify ->       cachebuilder         newbuilder()          maximumsize(3)         removallistener(entry -> {               try {                  // emit the value not the key!                  notifyaccept(entrygetvalue())              } catch (exception e) {                  throw new runtimeexception(e)              }            })         <integer object> build()         asmap()          // emit 1000 items but ensure that the // internal map never has more than 3 items in it            flowable   range(1 1000)   // note that number of keys is 10   groupby(x -> x % 10 x-> x true 16 evictingmapfactory)   flatmap(g -> g)   foreach(systemout::println)```note that i based this operator on the 1x version which i think may have a bug that goes as far as the signature of that method the eviction consumer should not be given a key but rather the value from the map ill pursue the 1x issue after dealing with this; merging 5860 ;2x -- group by custom map variant;""we are using release 217as is noted in the """"whats different"""" page the variant of `groupby` that accepts a custom map factory is not currently part of the 2x api  we were relying on this to implement """"eviction"""" of groups that havent been seen for a """"long time"""" (where """"long"""" is user specified)  our system maintains flowable instances for its entire lifetime (which is hopefully weeks/months) so it is important to be able to reclaim resources as we goanyway -- my questions are -- are the plans to bring this back?  is there a suggested alternative for implementing the disposal of groups after a period of inactivity?  any guidance would be appreciated"";it was a community contribution which was not ported to 2x by the original author you can timeout groups and switch to an empty flow:```javasourcegroupby(v -> key(v))map(g -> gtimeout(5 timeunitminutes observableempty())flatmap(g -> /* the usual group processing */)``` || thanks that should work nicely || i was author of that contribution to 1x #3931 using `timeout` was discussed but it had problems in particular you can lose emissions if @akarnokd is in favour i can investigate adapting the `groupby` operator to use a map factory again || yes pr welcome || @davidmoten thanks for the info re: timeout dropping emissions  we have essentially the same use case that you describe in #3931 so something that avoids that issue for rx2 would be great || just looking at the pr now @akarnokd do you have any advice for optimizing the rxjava 2x compile experience in eclipse (latest)? i just waited 5 min 40s for the project to compile after modifying some code and this happens frequently ps just realized im not using the eclipse gradle plugin for the project in eclipse but rather running `/gradlew eclipse` and importing as an eclipse project what do you do @akarnokd? || none the bug has been reported and hopefully we get it backported to 47 || ok you still using eclipse for dev on rxjava? || yes i just do something else for 10 minutes while eclipse is compiling after that as long as you dont touch the main classes its okay || eclipse slow compilation bug: || im using intellij and it works without any problems also android studio picks rxjava up correctly  || thanks @vanniktech i might switch to that for rxjava contributions || closing via #5860 || woohoo! slow compilation of rxjava 2x is  in eclipse 473 ||;1;0;2x: groupby add overload with evicting map factory;"
5861;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix javadoc warnings  links to the jdk types;the definition of multiple external links was wrong in  build.gradle  where the  options.links()  is actually defined as  string  and multiple calls are not additional. this made the generated javadoc not have links to the jdk types. the fix now properly uses the varargs of the method. in addition  somehow the plain    still wouldn t generate the proper links probably because they are redirected to    for which the javadoc tool is not prepared.;;0;2x: fix javadoc warnings links to the jdk types;the definition of multiple external links was wrong in `buildgradle` where the `optionslinks()` is actually defined as `string` and multiple calls are not additional this made the generated javadoc not have links to the jdk types the fix now properly uses the varargs of the method in addition somehow the plain ` still wouldnt generate the proper links probably because they are redirected to ` for which the javadoc tool is not preparedin addition 4 dangling `<p>` tags were showing up as warnings and have been removed; merging 5861 ;;;;1;1;2x: fix javadoc warnings links to the jdk types;
"5863;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: expand the documentation of the flowable.lift() operator;this pr expands the documentation of the  flowable.lift()  operator used for inserting custom operators into flows in a functional and fluent fashion.;;5862.0;2x: expand the documentation of the flowablelift() operator;this pr expands the documentation of the `flowablelift()` operator used for inserting custom operators into flows in a functional and fluent fashionthe other reactive base classes feature similar `lift()` operators for which the text can be adapted and contributed in a separate pr once the content of this pr is stabilized by review feedbackrelated: #5862; merging 5863 ;step-by-step guide for writing a custom operator?;""ive been trying with limited success to understand the discussion of creating custom 2x operators i think i get the section """"operator by extending a base reactive class"""" but what would really help for the """"operator targeting lift()"""" discussion is a _complete design-through-usage_ example of creating an operator is this possible? suggestion: a simple operator that transforms its input type perhaps something like `countcharacters()` that would accept a `string` and emit an `integer` with the number of characters in the `string` if possible versions with and without backpressure would be extra helpful "";""this shouldnt be of any difficulty because the two modes are only a straighforward transformation away:you write the operator:```javafinal class someop<t> implements flowablesubscriber<t> subscription {   // etc}```optionally turn it into a liftable expression:```javaflowableoperator<t t> op  downstream -> new someop<>(downstream params)flowablerange(1 5)lift(op)subscribe(systemout::println)```or turn it into a transformer:```javaflowabletransformer<t t> ft  upstream -> new flowable<t>() {    @override public void subscribeactual(subscriber<? super t> downstream) {        upstreamsubscribe(new someop<>(downstream params))    }}flowablerange(1 5)compose(ft)subscribe(systemout::println)```or use lifting and a transformer:```javaflowabletransformer<t t> ft2  upstream -> updstreamlift(op) flowablerange(1 5)compose(ft2)subscribe(systemout::println)``` || you could also read [my blog]( and study the rxjava source code || thanks i will certainly study but sometimes you know theres just no substitute for a fully worked-out example a large part of my problem is that the documentation of `lift()` is essentially incomprehensible to me (its remarkable that the javadoc literally begins with a warning to the reader against trying to understand it!) and this just isnt much help: > lifts a function to the current publisher and returns a new publisher that when subscribed to will pass the values of the current publisher through the operator function> in other words this allows chaining subscribers together on a publisher for acting on the values within the publisher could someone please try to explain in simple terms what `lift()` actually does and how to use it? final question: once i have created an operator how do i """"insert"""" it into the `flowable` or other class so that i can reference it like the built-in operators?  || `lift()` allows you to access the downstreams `subscriber` during the subscription phase and provide a new `subscriber` that will be used in the subscription process going furhter upstream generally this new `subscriber` will wrap the downstreams `subscriber` and forwards the `onnext` `onerror` and `oncomplete` events directly or according to the emission pattern this so-called operators business logic needs in addition such operator can intercept the flow control calls of `cancel` and `request` that would have travelled upstream and perform additional actions depending on the same business logic needs the difficulty is to express such business logic properly these can be so different that for example knowing how `map` can be implemented wont help you implement `observeon`> its remarkable that the javadoc literally begins with a warning to the reader against trying to understand it!no it warns the user about the complexities of using it and then suggests using existing operators such as `map` for your `countcharacters()`: `map(string -> stringlength())`> i have created an operator how do i """"insert"""" it into the flowable or other class so that i can reference it like the built-in operators?you cant add a new operator to `flowable` or the other base classes from the outside of rxjava as the java language lacks the features to do so youd need extension methods which is available in kotlin for exampletherefore you either write `flowabletransformer`s or `flowableoperator`s and use `compose` and `lift` respectively to use your custom operator in a sequence the [rxjava 2 extensions]( project demonstrates a lot of custom operators and their usageas a final note i dont suggest you write operators if you are just learning rxjava the target platform the java language or programming itself || please see pr #5863 for the suggested expansion of the javadoc of `lift` || closing via #5863 || "";1;0;2x: expand the documentation of the flowablelift() operator;"
5865;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: improve the javadoc of the other lift() operators;improve the javadoc of the  {observable | maybe | single | completable}.lift()  operator  adapting the text from #5863.;;0;2x: improve the javadoc of the other lift() operators;improve the javadoc of the `{observable | maybe | single | completable}lift()` operator adapting the text from #5863; merging 5865 ;;;;1;1;2x: improve the javadoc of the other lift() operators;
5867;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: enhance test for groupby with evicting map factory;enhance  flowablegroupbytest.singlethreadevictinghashmap  so that it actually evicts and be a bit defensive by supporting  putall  and  clear  properly. no change to  src/main/java .;;0;2x: enhance test for groupby with evicting map factory;enhance `flowablegroupbytestsinglethreadevictinghashmap` so that it actually evicts and be a bit defensive by supporting `putall` and `clear` properly no change to `src/main/java`; merging 5867  < ;;;;1;1;enhance test for groupby with evicting map factory;
5870;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add flowable.switchmapcompletable{delayerror} operator;this pr adds the  flowable.switchmapcompletable  and  flowable.switchmapcompletabledelayerror  operators as requested by #4853.;;4853.0;2x: add flowableswitchmapcompletable{delayerror} operator;this pr adds the `flowableswitchmapcompletable` and `flowableswitchmapcompletabledelayerror` operators as requested by #4853the associated new marbles are:![switchmapcompletable](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/switchmapcompletablefpng)![switchmapcompletabledelayerror](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/switchmapcompletabledelayerrorfpng); merging 5870 ;2x: switchmapsingle and switchmapcompletable;heythe addition of `flatmapsingle`/`flatmapcompletable` made the usage of `single` and `completable` way nicer in rxjava 2do you consider adding `switchmapsingle`/`switchmapcompletable` to rxjava 2 as well?cheers;you mean 1x? i have no plans for that and i dont want to keep 1x alive for too long id like to stop enhancing 1x in 6 months and enter it into a bugfix-only mode otherwise 3rd party libraries may delay their upgrade way longer || he wants `switchmapsingle` and `switchmapcompletable` for rxjava 2 just like there is `flatmapsingle` and `flatmapcompletable` || @vanniktech exactly || ah right no plans for extending any other xmap operator || but then `concatmap` also needs the variants in order to be consistent to be honest i forgot about those when proposing `flatmapsingle / flatmapcompletable / flatmapmaybe` initially - #4667 and then theres also `maybe` plus `observable` and `flowable` are able of mapping so its easily another 12 methods- observableswitchmapsingle- observableswitchmapmaybe- observableswitchmapcompletable- observableconcatmapsingle- observableconcatmapmaybe- observableconcatmapcompletable- flowableswitchmapsingle- flowableswitchmapmaybe- flowableswitchmapcompletable- flowableconcatmapsingle- flowableconcatmapmaybe- flowableconcatmapcompletable || if it is not on the roadmap because you dont want to add any more xmap operators then i understandbut if it is due to lack of the time would you consider accepting contributions on the topic? || sure but these operators are not easy || yes i know those are one of the hardest still i will at least have a look and see if i can deliver a prcheers! || any progress on this? || im happy to have a look at this one if @tomaszpolanski doesnt have time at the moment || @davidmoten it would be great! my available time now is pretty limited  || so the list of new operators is quite big currently:* observableswitchmapsingle* observableswitchmapmaybe* observableswitchmapcompletable* observableconcatmapsingle* observableconcatmapmaybe* observableconcatmapcompletable* flowableswitchmapsingle* flowableswitchmapmaybe* flowableswitchmapcompletable* flowableconcatmapsingle* flowableconcatmapmaybe* flowableconcatmapcompletablei imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by one an example would be `observableswitchmapsingle`:```javapublic final <r> observable<r> switchmapsingle(    final function<? super t ? extends singlesource<? extends r>> mapper) {        function<? super t observable<r>> mapper2  t ->             {                singlesource<? extends r> source  mapperapply(t)                single<? extends r> single                if (source instanceof single) {                    single  (single<? extends r>) source                } else {                    single  singleunsafecreate(source)                }               return (observable<r>) singletoobservable()            }        return switchmap(mapper2 buffersize())    }```this is just to demo the idea i wouldnt use an anonymous class and lambdas are just used for readability@akarnokd any interest in this? || > i imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by oneindeed> an example would beif you do this there is an unwritten guideline that the main base types should have no (anonymous) inner classes it helped me a lot before not having to deal with flowable$1$2 and similar entries the go-to place for these are in `ioreactivexinternaloperatorsflowableflowableinternalhelper` and its respective variants> any interest in this?im more interested in the direct implementations but at least the overall usefullness of the api extension could be vetted || >if you do this there is an unwritten guideline that the main base types should have no (anonymous) inner classes it helped me a lot before not having to deal with flowable$1$2 and similar entries the go-to place for these are in ioreactivexinternaloperatorsflowableflowableinternalhelper and its respective variantsyep no problems ive appreciated consistent naming of non-anon classes inside operators for debugging purposes and code searches too>im more interested in the direct implementations but at least the overall usefullness of the api extension could be vettedsure ill proceed with prs with unit tests for the new operators and im happy to have a stab at dedicated operators after that || what is expected behaviour for `observableswitchmapmaybe` and `observableswitchmapcompletable`? i can try to take care of it but i am not convinced what that method should return || in the mean time would it be correct to assume that an acceptable workaround for this is as follows?: **toobservable()**```upstreamconcatmap {        someobservable()collect{}toobservable()    }``` || @feresr probably yes at this moment in few places inside my code i have this type of stucture it is very weird and uncessesery code but it is understandable@akarnokd what do you think about method switchmapcompletable which emit object or maybe some enum? on the other hand we can we can swallow information about stream and do not emit anything || @marcinsus i dont fully understand your question use `switchmapcompletable()andthen(single)` to emit something after the switch completed || the problem he talks about is that switchmapcompletable does not exist switchmapsingle returns an observable of the single typeso technically switchmapcompletable should return void (which it cant because that has no instance) so he asks if the signature should rather expose some `enum nothing` or just an `object` || an `observableswitchmapcompletable` should return `completable` || you are right as `flatmapcompletable` returns a `completable`but now i find it weird that `observableflatmapsingle<t>`returns an `observable<t>`but `observableflatmapcompletable` returns an `completable` || a stream of 5 elements flatmapd to a stream of a single element still results in a stream of 5 elements || im working on implementing `concatmapcompletable` across the reactive typesim wondering if the library should also have implementations of`concatmapdelayerrorcompletable` `concatmapeagercompletable` `concatmapeagerdelayerrorcompletable`? || `concatmapeagercompletable` is indistinguishable from `flatmapcompletable` because all sources run concurrently and their only output is a terminal event no items have to be buffered until their turn also the `maxconcurrency  1` gets you `concatmapcompletable` behavior || ahh yes that makes sense  so is there any reason to implement `concatmapcompletable` at all?  if so do you want it to just use flatmapcompletable() internally or should there be a new direct implementation (what ive been working on)? || actually `observableflatmapcompletable` doesnt have `maxconcurrency` overload thus there might be a reason to implement `concatmapcompletable` || ok ill keep at it then ||  anything ever come of this?  || #5161 and #5649 added some operators || so there are plans to implement the other operators but not in any particular timeframe? || the listed operators can simply expressed with the existing default operators and `toobservable`/`toflowable` in the lambda parameters unfortunately very few people could or are willing to write them in an optimized and inlined fashion - which would add more value to the library than a simple lambda-rewriting function imagine you have to write a proper javadoc with a marble diargram and several hundred lines of unit tests to validate and cover a new operator with some 3 lines of code kotlins extension methods really shine in allowing interested parties to define such convenience functions locally to their project and not boomeranging such features through the rxjava library the issue is left open in case somebody really wants to take the time and effort to contribute but as the core developer im not particularly interested myself in tackling these types of operators || closing via #5870 #5871 #5872 #5873 #5875 ||;1;0;2x: add flowableswitchmapcompletable{delayerror} operator;
5871;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add flowable.concatmapcompletable{delayerror} operator;this pr adds the  flowable.concatmapcompletable  and  flowable.concatmapcompletabledelayerror  operators as requested by #4853.;;4853.0;2x: add flowableconcatmapcompletable{delayerror} operator;this pr adds the `flowableconcatmapcompletable` and `flowableconcatmapcompletabledelayerror` operators as requested by #4853the marbles will be updated in a separate pr; merging 5871 ;2x: switchmapsingle and switchmapcompletable;heythe addition of `flatmapsingle`/`flatmapcompletable` made the usage of `single` and `completable` way nicer in rxjava 2do you consider adding `switchmapsingle`/`switchmapcompletable` to rxjava 2 as well?cheers;you mean 1x? i have no plans for that and i dont want to keep 1x alive for too long id like to stop enhancing 1x in 6 months and enter it into a bugfix-only mode otherwise 3rd party libraries may delay their upgrade way longer || he wants `switchmapsingle` and `switchmapcompletable` for rxjava 2 just like there is `flatmapsingle` and `flatmapcompletable` || @vanniktech exactly || ah right no plans for extending any other xmap operator || but then `concatmap` also needs the variants in order to be consistent to be honest i forgot about those when proposing `flatmapsingle / flatmapcompletable / flatmapmaybe` initially - #4667 and then theres also `maybe` plus `observable` and `flowable` are able of mapping so its easily another 12 methods- observableswitchmapsingle- observableswitchmapmaybe- observableswitchmapcompletable- observableconcatmapsingle- observableconcatmapmaybe- observableconcatmapcompletable- flowableswitchmapsingle- flowableswitchmapmaybe- flowableswitchmapcompletable- flowableconcatmapsingle- flowableconcatmapmaybe- flowableconcatmapcompletable || if it is not on the roadmap because you dont want to add any more xmap operators then i understandbut if it is due to lack of the time would you consider accepting contributions on the topic? || sure but these operators are not easy || yes i know those are one of the hardest still i will at least have a look and see if i can deliver a prcheers! || any progress on this? || im happy to have a look at this one if @tomaszpolanski doesnt have time at the moment || @davidmoten it would be great! my available time now is pretty limited  || so the list of new operators is quite big currently:* observableswitchmapsingle* observableswitchmapmaybe* observableswitchmapcompletable* observableconcatmapsingle* observableconcatmapmaybe* observableconcatmapcompletable* flowableswitchmapsingle* flowableswitchmapmaybe* flowableswitchmapcompletable* flowableconcatmapsingle* flowableconcatmapmaybe* flowableconcatmapcompletablei imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by one an example would be `observableswitchmapsingle`:```javapublic final <r> observable<r> switchmapsingle(    final function<? super t ? extends singlesource<? extends r>> mapper) {        function<? super t observable<r>> mapper2  t ->             {                singlesource<? extends r> source  mapperapply(t)                single<? extends r> single                if (source instanceof single) {                    single  (single<? extends r>) source                } else {                    single  singleunsafecreate(source)                }               return (observable<r>) singletoobservable()            }        return switchmap(mapper2 buffersize())    }```this is just to demo the idea i wouldnt use an anonymous class and lambdas are just used for readability@akarnokd any interest in this? || > i imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by oneindeed> an example would beif you do this there is an unwritten guideline that the main base types should have no (anonymous) inner classes it helped me a lot before not having to deal with flowable$1$2 and similar entries the go-to place for these are in `ioreactivexinternaloperatorsflowableflowableinternalhelper` and its respective variants> any interest in this?im more interested in the direct implementations but at least the overall usefullness of the api extension could be vetted || >if you do this there is an unwritten guideline that the main base types should have no (anonymous) inner classes it helped me a lot before not having to deal with flowable$1$2 and similar entries the go-to place for these are in ioreactivexinternaloperatorsflowableflowableinternalhelper and its respective variantsyep no problems ive appreciated consistent naming of non-anon classes inside operators for debugging purposes and code searches too>im more interested in the direct implementations but at least the overall usefullness of the api extension could be vettedsure ill proceed with prs with unit tests for the new operators and im happy to have a stab at dedicated operators after that || what is expected behaviour for `observableswitchmapmaybe` and `observableswitchmapcompletable`? i can try to take care of it but i am not convinced what that method should return || in the mean time would it be correct to assume that an acceptable workaround for this is as follows?: **toobservable()**```upstreamconcatmap {        someobservable()collect{}toobservable()    }``` || @feresr probably yes at this moment in few places inside my code i have this type of stucture it is very weird and uncessesery code but it is understandable@akarnokd what do you think about method switchmapcompletable which emit object or maybe some enum? on the other hand we can we can swallow information about stream and do not emit anything || @marcinsus i dont fully understand your question use `switchmapcompletable()andthen(single)` to emit something after the switch completed || the problem he talks about is that switchmapcompletable does not exist switchmapsingle returns an observable of the single typeso technically switchmapcompletable should return void (which it cant because that has no instance) so he asks if the signature should rather expose some `enum nothing` or just an `object` || an `observableswitchmapcompletable` should return `completable` || you are right as `flatmapcompletable` returns a `completable`but now i find it weird that `observableflatmapsingle<t>`returns an `observable<t>`but `observableflatmapcompletable` returns an `completable` || a stream of 5 elements flatmapd to a stream of a single element still results in a stream of 5 elements || im working on implementing `concatmapcompletable` across the reactive typesim wondering if the library should also have implementations of`concatmapdelayerrorcompletable` `concatmapeagercompletable` `concatmapeagerdelayerrorcompletable`? || `concatmapeagercompletable` is indistinguishable from `flatmapcompletable` because all sources run concurrently and their only output is a terminal event no items have to be buffered until their turn also the `maxconcurrency  1` gets you `concatmapcompletable` behavior || ahh yes that makes sense  so is there any reason to implement `concatmapcompletable` at all?  if so do you want it to just use flatmapcompletable() internally or should there be a new direct implementation (what ive been working on)? || actually `observableflatmapcompletable` doesnt have `maxconcurrency` overload thus there might be a reason to implement `concatmapcompletable` || ok ill keep at it then ||  anything ever come of this?  || #5161 and #5649 added some operators || so there are plans to implement the other operators but not in any particular timeframe? || the listed operators can simply expressed with the existing default operators and `toobservable`/`toflowable` in the lambda parameters unfortunately very few people could or are willing to write them in an optimized and inlined fashion - which would add more value to the library than a simple lambda-rewriting function imagine you have to write a proper javadoc with a marble diargram and several hundred lines of unit tests to validate and cover a new operator with some 3 lines of code kotlins extension methods really shine in allowing interested parties to define such convenience functions locally to their project and not boomeranging such features through the rxjava library the issue is left open in case somebody really wants to take the time and effort to contribute but as the core developer im not particularly interested myself in tackling these types of operators || closing via #5870 #5871 #5872 #5873 #5875 ||;1;0;2x: add flowableconcatmapcompletable{delayerror} operator;
5872;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add flowable.concatmap{maybe single}{delayerror} operators;this pr adds operators that allow concatenating a mapped sequence of  maybe s or  single s  with or without delaying their errors:;;4853.0;2x: add flowableconcatmap{maybesingle}{delayerror} operators;this pr adds operators that allow concatenating a mapped sequence of `maybe`s or `single`s with or without delaying their errors:- `concatmapmaybe` (+1 overload with prefetch)- `concatmapmaybedelayerror` (+2 overloads with error mode and prefetch)- `concatmapsingle` (+1 overload with prefetch)- `concatmapsingledelayerror` (+2 overloads with error mode and prefetch)they are in the same pr as the `single` variants implementation is practically the `maybe` implementation minus the `oncomplete` casetheir marbles will be updated in a separate proriginally requested in #4853; merging 5872 ;2x: switchmapsingle and switchmapcompletable;heythe addition of `flatmapsingle`/`flatmapcompletable` made the usage of `single` and `completable` way nicer in rxjava 2do you consider adding `switchmapsingle`/`switchmapcompletable` to rxjava 2 as well?cheers;you mean 1x? i have no plans for that and i dont want to keep 1x alive for too long id like to stop enhancing 1x in 6 months and enter it into a bugfix-only mode otherwise 3rd party libraries may delay their upgrade way longer || he wants `switchmapsingle` and `switchmapcompletable` for rxjava 2 just like there is `flatmapsingle` and `flatmapcompletable` || @vanniktech exactly || ah right no plans for extending any other xmap operator || but then `concatmap` also needs the variants in order to be consistent to be honest i forgot about those when proposing `flatmapsingle / flatmapcompletable / flatmapmaybe` initially - #4667 and then theres also `maybe` plus `observable` and `flowable` are able of mapping so its easily another 12 methods- observableswitchmapsingle- observableswitchmapmaybe- observableswitchmapcompletable- observableconcatmapsingle- observableconcatmapmaybe- observableconcatmapcompletable- flowableswitchmapsingle- flowableswitchmapmaybe- flowableswitchmapcompletable- flowableconcatmapsingle- flowableconcatmapmaybe- flowableconcatmapcompletable || if it is not on the roadmap because you dont want to add any more xmap operators then i understandbut if it is due to lack of the time would you consider accepting contributions on the topic? || sure but these operators are not easy || yes i know those are one of the hardest still i will at least have a look and see if i can deliver a prcheers! || any progress on this? || im happy to have a look at this one if @tomaszpolanski doesnt have time at the moment || @davidmoten it would be great! my available time now is pretty limited  || so the list of new operators is quite big currently:* observableswitchmapsingle* observableswitchmapmaybe* observableswitchmapcompletable* observableconcatmapsingle* observableconcatmapmaybe* observableconcatmapcompletable* flowableswitchmapsingle* flowableswitchmapmaybe* flowableswitchmapcompletable* flowableconcatmapsingle* flowableconcatmapmaybe* flowableconcatmapcompletablei imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by one an example would be `observableswitchmapsingle`:```javapublic final <r> observable<r> switchmapsingle(    final function<? super t ? extends singlesource<? extends r>> mapper) {        function<? super t observable<r>> mapper2  t ->             {                singlesource<? extends r> source  mapperapply(t)                single<? extends r> single                if (source instanceof single) {                    single  (single<? extends r>) source                } else {                    single  singleunsafecreate(source)                }               return (observable<r>) singletoobservable()            }        return switchmap(mapper2 buffersize())    }```this is just to demo the idea i wouldnt use an anonymous class and lambdas are just used for readability@akarnokd any interest in this? || > i imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by oneindeed> an example would beif you do this there is an unwritten guideline that the main base types should have no (anonymous) inner classes it helped me a lot before not having to deal with flowable$1$2 and similar entries the go-to place for these are in `ioreactivexinternaloperatorsflowableflowableinternalhelper` and its respective variants> any interest in this?im more interested in the direct implementations but at least the overall usefullness of the api extension could be vetted || >if you do this there is an unwritten guideline that the main base types should have no (anonymous) inner classes it helped me a lot before not having to deal with flowable$1$2 and similar entries the go-to place for these are in ioreactivexinternaloperatorsflowableflowableinternalhelper and its respective variantsyep no problems ive appreciated consistent naming of non-anon classes inside operators for debugging purposes and code searches too>im more interested in the direct implementations but at least the overall usefullness of the api extension could be vettedsure ill proceed with prs with unit tests for the new operators and im happy to have a stab at dedicated operators after that || what is expected behaviour for `observableswitchmapmaybe` and `observableswitchmapcompletable`? i can try to take care of it but i am not convinced what that method should return || in the mean time would it be correct to assume that an acceptable workaround for this is as follows?: **toobservable()**```upstreamconcatmap {        someobservable()collect{}toobservable()    }``` || @feresr probably yes at this moment in few places inside my code i have this type of stucture it is very weird and uncessesery code but it is understandable@akarnokd what do you think about method switchmapcompletable which emit object or maybe some enum? on the other hand we can we can swallow information about stream and do not emit anything || @marcinsus i dont fully understand your question use `switchmapcompletable()andthen(single)` to emit something after the switch completed || the problem he talks about is that switchmapcompletable does not exist switchmapsingle returns an observable of the single typeso technically switchmapcompletable should return void (which it cant because that has no instance) so he asks if the signature should rather expose some `enum nothing` or just an `object` || an `observableswitchmapcompletable` should return `completable` || you are right as `flatmapcompletable` returns a `completable`but now i find it weird that `observableflatmapsingle<t>`returns an `observable<t>`but `observableflatmapcompletable` returns an `completable` || a stream of 5 elements flatmapd to a stream of a single element still results in a stream of 5 elements || im working on implementing `concatmapcompletable` across the reactive typesim wondering if the library should also have implementations of`concatmapdelayerrorcompletable` `concatmapeagercompletable` `concatmapeagerdelayerrorcompletable`? || `concatmapeagercompletable` is indistinguishable from `flatmapcompletable` because all sources run concurrently and their only output is a terminal event no items have to be buffered until their turn also the `maxconcurrency  1` gets you `concatmapcompletable` behavior || ahh yes that makes sense  so is there any reason to implement `concatmapcompletable` at all?  if so do you want it to just use flatmapcompletable() internally or should there be a new direct implementation (what ive been working on)? || actually `observableflatmapcompletable` doesnt have `maxconcurrency` overload thus there might be a reason to implement `concatmapcompletable` || ok ill keep at it then ||  anything ever come of this?  || #5161 and #5649 added some operators || so there are plans to implement the other operators but not in any particular timeframe? || the listed operators can simply expressed with the existing default operators and `toobservable`/`toflowable` in the lambda parameters unfortunately very few people could or are willing to write them in an optimized and inlined fashion - which would add more value to the library than a simple lambda-rewriting function imagine you have to write a proper javadoc with a marble diargram and several hundred lines of unit tests to validate and cover a new operator with some 3 lines of code kotlins extension methods really shine in allowing interested parties to define such convenience functions locally to their project and not boomeranging such features through the rxjava library the issue is left open in case somebody really wants to take the time and effort to contribute but as the core developer im not particularly interested myself in tackling these types of operators || closing via #5870 #5871 #5872 #5873 #5875 ||;1;0;fix the javadoc wording of concatmapsingle;
5873;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add flowable.switchmap{maybe single}{delayerror} operators;this pr adds  flowable  operators that allow switching between a mapped sequence of  maybe s or  single s  with or without delaying their errors:;;4853.0;2x: add flowableswitchmap{maybesingle}{delayerror} operators;this pr adds `flowable` operators that allow switching between a mapped sequence of `maybe`s or `single`s with or without delaying their errors:- `switchmapmaybe`- `switchmapmaybedelayerror`- `switchmapsingle`- `switchmapsingledelayerror`they are in the same pr as the `single` variants implementation is practically the `maybe` implementation minus the `oncomplete` casetheir marbles will be updated in a separate proriginally requested in #4853; merging 5873 ;2x: switchmapsingle and switchmapcompletable;heythe addition of `flatmapsingle`/`flatmapcompletable` made the usage of `single` and `completable` way nicer in rxjava 2do you consider adding `switchmapsingle`/`switchmapcompletable` to rxjava 2 as well?cheers;you mean 1x? i have no plans for that and i dont want to keep 1x alive for too long id like to stop enhancing 1x in 6 months and enter it into a bugfix-only mode otherwise 3rd party libraries may delay their upgrade way longer || he wants `switchmapsingle` and `switchmapcompletable` for rxjava 2 just like there is `flatmapsingle` and `flatmapcompletable` || @vanniktech exactly || ah right no plans for extending any other xmap operator || but then `concatmap` also needs the variants in order to be consistent to be honest i forgot about those when proposing `flatmapsingle / flatmapcompletable / flatmapmaybe` initially - #4667 and then theres also `maybe` plus `observable` and `flowable` are able of mapping so its easily another 12 methods- observableswitchmapsingle- observableswitchmapmaybe- observableswitchmapcompletable- observableconcatmapsingle- observableconcatmapmaybe- observableconcatmapcompletable- flowableswitchmapsingle- flowableswitchmapmaybe- flowableswitchmapcompletable- flowableconcatmapsingle- flowableconcatmapmaybe- flowableconcatmapcompletable || if it is not on the roadmap because you dont want to add any more xmap operators then i understandbut if it is due to lack of the time would you consider accepting contributions on the topic? || sure but these operators are not easy || yes i know those are one of the hardest still i will at least have a look and see if i can deliver a prcheers! || any progress on this? || im happy to have a look at this one if @tomaszpolanski doesnt have time at the moment || @davidmoten it would be great! my available time now is pretty limited  || so the list of new operators is quite big currently:* observableswitchmapsingle* observableswitchmapmaybe* observableswitchmapcompletable* observableconcatmapsingle* observableconcatmapmaybe* observableconcatmapcompletable* flowableswitchmapsingle* flowableswitchmapmaybe* flowableswitchmapcompletable* flowableconcatmapsingle* flowableconcatmapmaybe* flowableconcatmapcompletablei imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by one an example would be `observableswitchmapsingle`:```javapublic final <r> observable<r> switchmapsingle(    final function<? super t ? extends singlesource<? extends r>> mapper) {        function<? super t observable<r>> mapper2  t ->             {                singlesource<? extends r> source  mapperapply(t)                single<? extends r> single                if (source instanceof single) {                    single  (single<? extends r>) source                } else {                    single  singleunsafecreate(source)                }               return (observable<r>) singletoobservable()            }        return switchmap(mapper2 buffersize())    }```this is just to demo the idea i wouldnt use an anonymous class and lambdas are just used for readability@akarnokd any interest in this? || > i imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by oneindeed> an example would beif you do this there is an unwritten guideline that the main base types should have no (anonymous) inner classes it helped me a lot before not having to deal with flowable$1$2 and similar entries the go-to place for these are in `ioreactivexinternaloperatorsflowableflowableinternalhelper` and its respective variants> any interest in this?im more interested in the direct implementations but at least the overall usefullness of the api extension could be vetted || >if you do this there is an unwritten guideline that the main base types should have no (anonymous) inner classes it helped me a lot before not having to deal with flowable$1$2 and similar entries the go-to place for these are in ioreactivexinternaloperatorsflowableflowableinternalhelper and its respective variantsyep no problems ive appreciated consistent naming of non-anon classes inside operators for debugging purposes and code searches too>im more interested in the direct implementations but at least the overall usefullness of the api extension could be vettedsure ill proceed with prs with unit tests for the new operators and im happy to have a stab at dedicated operators after that || what is expected behaviour for `observableswitchmapmaybe` and `observableswitchmapcompletable`? i can try to take care of it but i am not convinced what that method should return || in the mean time would it be correct to assume that an acceptable workaround for this is as follows?: **toobservable()**```upstreamconcatmap {        someobservable()collect{}toobservable()    }``` || @feresr probably yes at this moment in few places inside my code i have this type of stucture it is very weird and uncessesery code but it is understandable@akarnokd what do you think about method switchmapcompletable which emit object or maybe some enum? on the other hand we can we can swallow information about stream and do not emit anything || @marcinsus i dont fully understand your question use `switchmapcompletable()andthen(single)` to emit something after the switch completed || the problem he talks about is that switchmapcompletable does not exist switchmapsingle returns an observable of the single typeso technically switchmapcompletable should return void (which it cant because that has no instance) so he asks if the signature should rather expose some `enum nothing` or just an `object` || an `observableswitchmapcompletable` should return `completable` || you are right as `flatmapcompletable` returns a `completable`but now i find it weird that `observableflatmapsingle<t>`returns an `observable<t>`but `observableflatmapcompletable` returns an `completable` || a stream of 5 elements flatmapd to a stream of a single element still results in a stream of 5 elements || im working on implementing `concatmapcompletable` across the reactive typesim wondering if the library should also have implementations of`concatmapdelayerrorcompletable` `concatmapeagercompletable` `concatmapeagerdelayerrorcompletable`? || `concatmapeagercompletable` is indistinguishable from `flatmapcompletable` because all sources run concurrently and their only output is a terminal event no items have to be buffered until their turn also the `maxconcurrency  1` gets you `concatmapcompletable` behavior || ahh yes that makes sense  so is there any reason to implement `concatmapcompletable` at all?  if so do you want it to just use flatmapcompletable() internally or should there be a new direct implementation (what ive been working on)? || actually `observableflatmapcompletable` doesnt have `maxconcurrency` overload thus there might be a reason to implement `concatmapcompletable` || ok ill keep at it then ||  anything ever come of this?  || #5161 and #5649 added some operators || so there are plans to implement the other operators but not in any particular timeframe? || the listed operators can simply expressed with the existing default operators and `toobservable`/`toflowable` in the lambda parameters unfortunately very few people could or are willing to write them in an optimized and inlined fashion - which would add more value to the library than a simple lambda-rewriting function imagine you have to write a proper javadoc with a marble diargram and several hundred lines of unit tests to validate and cover a new operator with some 3 lines of code kotlins extension methods really shine in allowing interested parties to define such convenience functions locally to their project and not boomeranging such features through the rxjava library the issue is left open in case somebody really wants to take the time and effort to contribute but as the core developer im not particularly interested myself in tackling these types of operators || closing via #5870 #5871 #5872 #5873 #5875 ||;1;0;2x: add flowableswitchmap{maybesingle}{delayerror} operators;
5875;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add observable switchmapx and concatmapx operators;this pr ports the various  switchmapx  and  concatmapx  operators from #5870  #5871  #5872 and #5873 to  observable :;;4853.0;2x: add observable switchmapx and concatmapx operators;this pr ports the various `switchmapx` and `concatmapx` operators from #5870 #5871 #5872 and #5873 to `observable`:- `concatmapcompletable` (replaced by the common implementation)- `concatmapcompletabledelayerror`- `concatmapmaybe`- `concatmapmaybedelayerror`- `concatmapsingle`- `concatmapsingledelayerror`- `switchmapcompletable`- `switchmapcompletabledelayerror`- `switchmapmaybe`- `switchmapmaybedelayerror`- `switchmapsingle` (dedicated implementation)- `switchmapsingledelayerror` (dedicated implementation)this pr concludes the requested set of operators in #4853marbles will be updated/adjusted in a separate pr; merging 5875 ;2x: switchmapsingle and switchmapcompletable;heythe addition of `flatmapsingle`/`flatmapcompletable` made the usage of `single` and `completable` way nicer in rxjava 2do you consider adding `switchmapsingle`/`switchmapcompletable` to rxjava 2 as well?cheers;you mean 1x? i have no plans for that and i dont want to keep 1x alive for too long id like to stop enhancing 1x in 6 months and enter it into a bugfix-only mode otherwise 3rd party libraries may delay their upgrade way longer || he wants `switchmapsingle` and `switchmapcompletable` for rxjava 2 just like there is `flatmapsingle` and `flatmapcompletable` || @vanniktech exactly || ah right no plans for extending any other xmap operator || but then `concatmap` also needs the variants in order to be consistent to be honest i forgot about those when proposing `flatmapsingle / flatmapcompletable / flatmapmaybe` initially - #4667 and then theres also `maybe` plus `observable` and `flowable` are able of mapping so its easily another 12 methods- observableswitchmapsingle- observableswitchmapmaybe- observableswitchmapcompletable- observableconcatmapsingle- observableconcatmapmaybe- observableconcatmapcompletable- flowableswitchmapsingle- flowableswitchmapmaybe- flowableswitchmapcompletable- flowableconcatmapsingle- flowableconcatmapmaybe- flowableconcatmapcompletable || if it is not on the roadmap because you dont want to add any more xmap operators then i understandbut if it is due to lack of the time would you consider accepting contributions on the topic? || sure but these operators are not easy || yes i know those are one of the hardest still i will at least have a look and see if i can deliver a prcheers! || any progress on this? || im happy to have a look at this one if @tomaszpolanski doesnt have time at the moment || @davidmoten it would be great! my available time now is pretty limited  || so the list of new operators is quite big currently:* observableswitchmapsingle* observableswitchmapmaybe* observableswitchmapcompletable* observableconcatmapsingle* observableconcatmapmaybe* observableconcatmapcompletable* flowableswitchmapsingle* flowableswitchmapmaybe* flowableswitchmapcompletable* flowableconcatmapsingle* flowableconcatmapmaybe* flowableconcatmapcompletablei imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by one an example would be `observableswitchmapsingle`:```javapublic final <r> observable<r> switchmapsingle(    final function<? super t ? extends singlesource<? extends r>> mapper) {        function<? super t observable<r>> mapper2  t ->             {                singlesource<? extends r> source  mapperapply(t)                single<? extends r> single                if (source instanceof single) {                    single  (single<? extends r>) source                } else {                    single  singleunsafecreate(source)                }               return (observable<r>) singletoobservable()            }        return switchmap(mapper2 buffersize())    }```this is just to demo the idea i wouldnt use an anonymous class and lambdas are just used for readability@akarnokd any interest in this? || > i imagine we can add support for all of these operators straight away using composition and write dedicated operators later one by oneindeed> an example would beif you do this there is an unwritten guideline that the main base types should have no (anonymous) inner classes it helped me a lot before not having to deal with flowable$1$2 and similar entries the go-to place for these are in `ioreactivexinternaloperatorsflowableflowableinternalhelper` and its respective variants> any interest in this?im more interested in the direct implementations but at least the overall usefullness of the api extension could be vetted || >if you do this there is an unwritten guideline that the main base types should have no (anonymous) inner classes it helped me a lot before not having to deal with flowable$1$2 and similar entries the go-to place for these are in ioreactivexinternaloperatorsflowableflowableinternalhelper and its respective variantsyep no problems ive appreciated consistent naming of non-anon classes inside operators for debugging purposes and code searches too>im more interested in the direct implementations but at least the overall usefullness of the api extension could be vettedsure ill proceed with prs with unit tests for the new operators and im happy to have a stab at dedicated operators after that || what is expected behaviour for `observableswitchmapmaybe` and `observableswitchmapcompletable`? i can try to take care of it but i am not convinced what that method should return || in the mean time would it be correct to assume that an acceptable workaround for this is as follows?: **toobservable()**```upstreamconcatmap {        someobservable()collect{}toobservable()    }``` || @feresr probably yes at this moment in few places inside my code i have this type of stucture it is very weird and uncessesery code but it is understandable@akarnokd what do you think about method switchmapcompletable which emit object or maybe some enum? on the other hand we can we can swallow information about stream and do not emit anything || @marcinsus i dont fully understand your question use `switchmapcompletable()andthen(single)` to emit something after the switch completed || the problem he talks about is that switchmapcompletable does not exist switchmapsingle returns an observable of the single typeso technically switchmapcompletable should return void (which it cant because that has no instance) so he asks if the signature should rather expose some `enum nothing` or just an `object` || an `observableswitchmapcompletable` should return `completable` || you are right as `flatmapcompletable` returns a `completable`but now i find it weird that `observableflatmapsingle<t>`returns an `observable<t>`but `observableflatmapcompletable` returns an `completable` || a stream of 5 elements flatmapd to a stream of a single element still results in a stream of 5 elements || im working on implementing `concatmapcompletable` across the reactive typesim wondering if the library should also have implementations of`concatmapdelayerrorcompletable` `concatmapeagercompletable` `concatmapeagerdelayerrorcompletable`? || `concatmapeagercompletable` is indistinguishable from `flatmapcompletable` because all sources run concurrently and their only output is a terminal event no items have to be buffered until their turn also the `maxconcurrency  1` gets you `concatmapcompletable` behavior || ahh yes that makes sense  so is there any reason to implement `concatmapcompletable` at all?  if so do you want it to just use flatmapcompletable() internally or should there be a new direct implementation (what ive been working on)? || actually `observableflatmapcompletable` doesnt have `maxconcurrency` overload thus there might be a reason to implement `concatmapcompletable` || ok ill keep at it then ||  anything ever come of this?  || #5161 and #5649 added some operators || so there are plans to implement the other operators but not in any particular timeframe? || the listed operators can simply expressed with the existing default operators and `toobservable`/`toflowable` in the lambda parameters unfortunately very few people could or are willing to write them in an optimized and inlined fashion - which would add more value to the library than a simple lambda-rewriting function imagine you have to write a proper javadoc with a marble diargram and several hundred lines of unit tests to validate and cover a new operator with some 3 lines of code kotlins extension methods really shine in allowing interested parties to define such convenience functions locally to their project and not boomeranging such features through the rxjava library the issue is left open in case somebody really wants to take the time and effort to contribute but as the core developer im not particularly interested myself in tackling these types of operators || closing via #5870 #5871 #5872 #5873 #5875 ||;1;0;rename local variables to match their datatype better;
"5876;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add note about nosuchelementexception to single.zip().;;;0;2x: add note about nosuchelementexception to singlezip();;""this may be a desirable documentation enhancement the other `zip` operators all around would you like to do them as well in this or another pr? || yep ill check other rx types to update that for some types like `observable` its fine since they can just signal completion on empty inputwill post comment with update in any case :) ||  merging 5876  "";;;;1;1;address code review comments;"
5883;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: improve coverage and fix small mistakes/untaken paths in operators;this pr improves the coverage of rxjava while adjusting some code paths and fixing other types of smaller bugs.;;0;2x: improve coverage and fix small mistakes/untaken paths in operators;this pr improves the coverage of rxjava while adjusting some code paths and fixing other types of smaller bugs- fix `maybemerge(publisher)` to define a 1 element buffer only- fix `maybemergedelayerror(publisher)` to use the dedicated `flowableflatmappublisher` similar to the plain `merge()`- in `flowableflatmap` checking for empty or cancelled arrays in `removeinner()` can be replaced with a length check- make sure in `flowablereduce(seed f)` the terminal events cant be called a second time if the reducer crashes- turn the `flowablereplaymulticastpublisher` into a `flowable` and rename it to `multicastflowable`- fix `flowablewindowboundary` not cancelling the upstream on a missing backpressure case causing `nullpointerexception`- remove unused override of `accept()` in `flowablewindowboundary`- remove the ineffective done flag from `operatorwindowboundaryopensubscriber`- replace the timer cass with the `replace()` call in `flowablewindowtimed`- remove the unused `repeatwhen` `errormapperfilter` and `retrywhen` components from `observableinternalhelper`- make sure the value is cleared at most once in `observablereduceseedsingle`- simplify `observablewindowboundaryselector`s inner consumers `onnext` handling- simplify `flowablewindowboundaryselector`s inner consumers `onnext` handling- inline the finally actions in `instantperiodictaskcall()`- fix `instantperiodictasksetfirst` and `setrest` to return from the loop when the task has been cancelled to prevent excess looping and overwriting the `cancelled` indicator- inline the finally actions in `scheduleddirectperiodictaskcall()`- slight adjustment of crash propagation in the `schedulerwhen` constructor- in `behaviorprocessor` checking for empty or cancelled arrays in `remove()` can be replaced with a length check- in `behaviorsubject` checking for empty or cancelled arrays in `remove()` can be replaced with a length check; merging 5883 ;;;;1;1;2x: improve coverage and fix small mistakes/untaken paths in operators;
5886;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: upgrade the algorithm of observable.timeout(time|selector) operators;this pr improves the algorithms of the  observable.timeout(time)  and  observable.timeout(selector)  operators to match their  flowable  counterparts implemented in #5661.;;5882.0;2x: upgrade the algorithm of observabletimeout(time|selector) operators;this pr improves the algorithms of the `observabletimeout(time)` and `observabletimeout(selector)` operators to match their `flowable` counterparts implemented in #5661in addition coverage of the `flowable` counterparts have been improved by synchronizing the unit testsnote that they were the last users of `observerfullarbiter` and `fullarbiterobserver` which are now removedcloses #5882; merging 5886 ;update the algorithm observabletimeout(time) & timeout(selector);update the `observabletimeout(time)` and the `observabletimeout(selectors)` operators to the more modern atomic index tracking algorithm and get rid of `observerfullarbiter` and `fullarbiterobserver`their `flowable` counterparts have been updated in #5661;;1;0;2x: upgrade the algo of observabletimeout(time|selector) operators;
5887;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix window(observable|callable) upstream handling;this pr fixes the upstream handling in  observable.window(observablesource)  and  observable.window(callable<observablesource>)  operators to make sure if both the main output and the inner windows have been disposed  the upstream is also disposed.;;5881.0;2x: fix window(observable|callable) upstream handling;this pr fixes the upstream handling in `observablewindow(observablesource)` and `observablewindow(callable<observablesource>)` operators to make sure if both the main output and the inner windows have been disposed the upstream is also disposed5881*remark:*there are a couple of `w ! null` checks showing up as partially covered in theory with the right interleaving `w` can become `null` but unfortunately the usual `testhelperrace()` testing is unlikely to trigger that case there would be a higher chance with 3 threads (one disposing one completing the main and one completing the inner window) but the current ci is effectively 15 - 2 cores/threads that tend to not produce a thorough interleaving; merging 5887 ;incorrect upstream management in window(observable) and window(callable);while working on coverage improvements ive noticed `flowablewindow(publisher<b>)` and `flowablewindow(callable<publisher<b>>)` (plus their `observable` counterpart) manage the upstream incorrectly as they dont cancel it when both the main output and the current window have been cancelled;;1;0;2x: fix window(observable|callable) upstream handling;
5888;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix flowable.window(publisher|callable) upstream handling;this pr fixes the upstream handling in  flowable.window(publisher)  and  flowable.window(callable<publisher>)  operators to make sure if both the main output and the inner windows have been cancelled  the upstream is also cancelled.;;5881.0;2x: fix flowablewindow(publisher|callable) upstream handling;this pr fixes the upstream handling in `flowablewindow(publisher)` and `flowablewindow(callable<publisher>)` operators to make sure if both the main output and the inner windows have been cancelled the upstream is also cancelledrelated: #5887 #5881in addition the jacoco code coverage has been updated to 080 mainly due to the [automatic filtering of difficult-to-impossible code paths](https://githubcom/jacoco/jacoco/releases/tag/v080); merging 5888 ;incorrect upstream management in window(observable) and window(callable);while working on coverage improvements ive noticed `flowablewindow(publisher<b>)` and `flowablewindow(callable<publisher<b>>)` (plus their `observable` counterpart) manage the upstream incorrectly as they dont cancel it when both the main output and the current window have been cancelled;;1;0;2x: fix flowablewindow(publisher|callable) upstream handling;
5889;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: cleanup  coverage and related component fixes;this pr improves the coverage of various components and contains the following additional fixes:;;0;2x: cleanup coverage and related component fixes;this pr improves the coverage of various components and contains the following additional fixes:- remove a very unlikely cancellation check in `flowableconcatmapeager`- improve backpressure tracking in `flowablepublishmulticast` to avoid atomic decrement per items emitted (part of `publish(function)`)- improve check for empty or terminated state in `flowablepublishmulticast` by using the array length- `unicastprocessor` termination to use a one-step `getandset`- `behaviorsubject` termination to use a one-step `getandset`- remove impossible try-finally in `behaviorsubjectsetcurrent` as the body could never crash; merging 5889 ;;;;1;1;2x: cleanup coverage and related component fixes;
5890;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;added nullable annotations to subjects;adding nullable annotations to subjects. the  throwable  and  getvalue  methods are annotated with nullable.;;0;added nullable annotations to subjects;adding nullable annotations to subjects the `throwable` and `getvalue` methods are annotated with nullablequick question about styling - in some places javadocs has trailing whitespaces but it is absent in other places is there a styling policy around that? intellij is removing the trailed whitespace automatically; merging 5890 ;;;;1;1;added nullable annotations to subjects;
5891;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: improve coverage & related cleanup 03/05;improve the coverage of various components  fix impossible paths and other fixes. see the comments attached to the code changes.;;0;2x: improve coverage & related cleanup 03/05;improve the coverage of various components fix impossible paths and other fixes see the comments attached to the code changes;updated with some additional cleanup and fix to `observableskip` lacking a validation ||  merging 5891 ;;;;1;1;fix camelcase local variable naming errors in tests;
5892;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix the extra retention problem in replaysubject;in the bounded buffers of  replaysubject   the head reference may retain one extra item when the trimming happens. nulling out this reference is not possible at this point because old consumers may be still walking through the underlying linked list of nodes. however  replacing a head with the same next pointer (which is always not null if value is not null) but no value will eventually let the value get gcd. this cleanup doesn t happen on every  onnext  because it doubles the node allocation and thus the overhead.;;0;2x: fix the extra retention problem in replaysubject;in the bounded buffers of `replaysubject` the head reference may retain one extra item when the trimming happens nulling out this reference is not possible at this point because old consumers may be still walking through the underlying linked list of nodes however replacing a head with the same next pointer (which is always not null if value is not null) but no value will eventually let the value get gcd this cleanup doesnt happen on every `onnext` because it doubles the node allocation and thus the overheadthis pr modifies the code so that terminal events do perform this head swapping and introduces the `replaysubjectcleanupbuffer()` method to allow the user to perform the head swapping while the `replaysubject` is not yet terminated and the cleanup is neededif this type of change is accepted the `replayprocessor` can also be refitted for the `replay()` operators the terminal cleanup can be implemented but the on demand cleanup cant as there is no api surface for its internal buffer available; merging 5892 ;;;;1;1;cover the already-trimmed case;
"5893;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix flowable.publish(-|function) subscriber swap possible data loss;this pr fixes an avoidable dataloss in the following subscriber-swap scenario with the  publish()  and  publish(function<flowable  publisher>) .;;0;2x: fix flowablepublish(-|function) subscriber swap possible data loss;""this pr fixes an avoidable dataloss in the following subscriber-swap scenario with the `publish()` and `publish(function<flowable publisher>)`when an `onnext` changes the current array of subscribers (an existing consumer cancelled or a new one arrived) the change detection is delayed and items may get dropped even though a fresh consumer could take those valuesthe algorithms were updated to fix this case as well as the emission tracking in `flowablemulticastprocessor`: a global `emitted` value is not good here after all (subscribers joining late would indicate an incorrect aggregate demand and get overflown)one of the advanced uses of `publish(function)` is to implement consumption mode changes by having a mode cancel the subscription to the shared `flowable` and synchronously subscribe a new consumer with a different behavior the discovery of this shortcoming was due to a special transformation pattern: apply a transformer if the source is not empty and in this case deliver all items of it```javaflowabletransformer<t u> transformer  sourcepublish(shared ->   // lets see if there is at least 1 source item   sharedtake(1)   // if there is one item stop this phase and keep the item   concatmap(first ->       // given the very first item apply the transformation       // on the """"original"""" sequence by reattaching the first       // item to the rest of the source       transformerapply(sharedstartwith(first))   ))subscribe(/*  */)```""; merging 5893 ;;;;1;1;2x: fix publish(-|function) subscriber swap possible data loss;"
5895;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix buffer() documentation to correctly describe onerror behaviour;5894. i just copied the sentence from the fixed docs in 1.x and updated to use observablesource/publisher naming.;;5894.0;fix buffer() documentation to correctly describe onerror behaviour;5894 i just copied the sentence from the  docs in 1x and updated to use observablesource/publisher naming; merging 5895 ;2x: buffer documentation incorrect for onerror behaviour;the documentation for most `buffer` operators reads as follows:> when the source observablesource completes or encounters an error the resulting observablesource emits the current buffer and propagates the notification from the source observablesourcethis is incorrect none of the `buffer` operators emit their buffer before propagating an error:```@overridepublic void onerror(throwable t) {    buffer  null    actualonerror(t)}```note that this documentation was  in 1x in #3561 (this is effectively a duplicate of issue #3560);;1;0;update boundary buffer documentation to change source -> suppliedthe word source is incorrect here since the buffer is emittedwhenever the supplied publisher emits an item;
5897;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: clarify dematerialize() and terminal items/signals;specify in both  flowable  and  observable  that a terminal notification item or a regular terminal signal ends the flow.;;0;2x: clarify dematerialize() and terminal items/signals;specify in both `flowable` and `observable` that a terminal notification item or a regular terminal signal ends the flowfixes: #5261; merging 5897 ;;;;1;1;2x: clarify dematerialize() and terminal items/signals;
5898;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix excess item retention in the other replay components;this is a follow-up pr to #5892 in order to avoid item retention in the head node. for the  replayprocessor   the cleanup can be triggered with  cleanupbuffer . for the  replay()  operators  such trigger is not possible. however  the terminal events will perform the cleanup internally at least.;;0;2x: fix excess item retention in the other replay components;this is a follow-up pr to #5892 in order to avoid item retention in the head node for the `replayprocessor` the cleanup can be triggered with `cleanupbuffer` for the `replay()` operators such trigger is not possible however the terminal events will perform the cleanup internally at least; merging 5898 ;;;;1;1;2x: fix excess item retention in the other replay components;
5900;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix observable.flatmap scalar maxconcurrency overflow;since  observable  is not backpressured  the  flatmap  of it has to manage the buffering of inner sources so that only a limited number of them are active at the same time. however  when most outstanding inner sources were scalar ( just()  is such a source) but the drain loop was busy  the operator overflow its bounded scalar queue (as it is supposed to be holding at most maxconcurrency scalar items)  causing an  illegalstateexception .;;0;2x: fix observableflatmap scalar maxconcurrency overflow;since `observable` is not backpressured the `flatmap` of it has to manage the buffering of inner sources so that only a limited number of them are active at the same time however when most outstanding inner sources were scalar (`just()` is such a source) but the drain loop was busy the operator overflow its bounded scalar queue (as it is supposed to be holding at most maxconcurrency scalar items) causing an `illegalstateexception`the pr fixes this corner case by making sure the `tryscalaremit` returns false if it had to queue up the scalar which in turn prevents the next inner source to be subscribed to until the queued item is cleared in addition the terminal state check has to include the buffer holding the remaining inner sources: being done having an empty scalar queue and having no active inner observers is just not enough`flowableflatmap` is not affected as it uses backpressure to ensure only a limited number of sources or scalars are mapped inoriginally reported in the chat of this [stackoverflow question]( fatal exception: rxcachedthreadscheduler-1 process: comhackerligirl pid: 6030 javalangillegalstateexception: scalar queue full?! at ioreactivexinternaloperatorsobservableobservableflatmap$mergeobservertryemitscalar(observableflatmapjava:250) at ioreactivexinternaloperatorsobservableobservableflatmap$mergeobserversubscribeinner(observableflatmapjava:146) at ioreactivexinternaloperatorsobservableobservableflatmap$mergeobserverdrainloop(observableflatmapjava:475) at ioreactivexinternaloperatorsobservableobservableflatmap$mergeobserverdrain(observableflatmapjava:323) at ioreactivexinternaloperatorsobservableobservableflatmap$innerobserveroncomplete(observableflatmapjava:579) at ioreactivexinternalobserversbasicfuseableobserveroncomplete(basicfuseableobserverjava:119) at ioreactivexinternaloperatorsobservableobservablesubscribeon$subscribeonobserveroncomplete(observablesubscribeonjava:68) at retrofit2adapterrxjava2bodyobservable$bodyobserveroncomplete(bodyobservablejava:66) at retrofit2adapterrxjava2callexecuteobservablesubscribeactual(callexecuteobservablejava:47)at ioreactivexobservablesubscribe(observablejava:11442) at retrofit2adapterrxjava2bodyobservablesubscribeactual(bodyobservablejava:34) at ioreactivexobservablesubscribe(observablejava:11442) at ioreactivexinternaloperatorsobservableobservablesubscribeon$subscribetaskrun(observablesubscribeonjava:96) at ioreactivexscheduler$disposetaskrun(schedulerjava:571) at ioreactivexinternalschedulersscheduledrunnablerun(scheduledrunnablejava:66) at ioreactivexinternalschedulersscheduledrunnablecall(scheduledrunnablejava:57) at javautilconcurrentfuturetaskrun(futuretaskjava:237) at javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:269) at javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1113) at javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:588) at javalangthreadrun(threadjava:818)```; merging 5900 ;;;;1;1;2x: fix observableflatmap scalar maxconcurrency overflow;
5902;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: perf measure of flowable flatmap & flatmapcompletable;this pr adds two benchmarks that measure the synchronous and asynchronous behavior of  flowable.flatmap  and  flowable.flatmapcompletable  when both are run with a  completable  source.;;0;2x: perf measure of flowable flatmap & flatmapcompletable;this pr adds two benchmarks that measure the synchronous and asynchronous behavior of `flowableflatmap` and `flowableflatmapcompletable` when both are run with a `completable` sourceapart from the `item  1` case which is due to lack of scalar optimizations with `flatmapcompletable` the `flatmapcompletable` is faster by a good margin:( say the asynchronous use is slightly faster in general with `flatmapcompletable`:![image]( this pr started out as an attempt to optimize the inner consumer tracking in `flatmapcompletable` when the `maxconcurrency` is non-default by using a special containers for 18 instead of the `compositedisposable` unfortunately this made it slightly slower in general (pr column):![image]( async benchmark is within +/- 3% most of the time and generally inconclusive![image]( additional test method was added to verify the new tracking classes which is left as an additional mean to verify `flatmapcompletable`s behavior in general;  ill get to it in the regular coverage improvements ||;;;;1;1;2x: perf measure of flowable flatmap & flatmapcompletable;
5904;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix flowable.singleorerror().toflowable() not signalling nosuchelementexception;when a  singleorerror  is followed by  toflowable()   the assembly process switches the  flowable->single  operator into a  flowable->flowable  operator implementing the  singleorerror  behavior (saving the back-and-forth type conversion). the backing implementation was shared with  singleelement  and as such  did not properly handle the  orerror  case for an empty source. the pr fixes the lack of  nosuchelementexception  in this case.;;5903.0;2x: fix flowablesingleorerror()toflowable() not signalling nosuchelementexception;when a `singleorerror` is followed  toflowable()` the assembly process switches the `flowable->single` operator into a `flowable->flowable` operator implementing the `singleorerror` behavior (saving the back-and-forth type conversion) the backing implementation was shared with `singleelement` and as such did not properly handle the `orerror` case for an empty source the pr fixes the lack of `nosuchelementexception` in this case5903the `observable` variant doesnt have such optimization but the test has been converted to make sure `observable` is verified for this aspect in case the optimization is implemented with it in the future; merging 5904 ;flowablesingleorerror() does not signal an exception if followed by flatmappublisher;the following code demonstrates the expected behavior of flowablesingleorerror() (as i understand it):```flowableempty()    singleorerror()    blockingget() // nosuchelementexception is thrown as expected```    however if singleorerror() is immediately followed by singleflatmappublisher() the exception is lost:```flowableempty()    singleorerror()    flatmappublisher(flowable::just)    blockingsubscribe() // no exception is thrown```    strangely if anything is done between flowablesingleorerror() and singleflatmappublisher() the exception is thrown as expected:```flowableempty()    singleorerror()    map(x -> x)    flatmappublisher(flowable::just)    blockingsubscribe() // nosuchelementexception is thrown as expected```    this is with rxjava 2110 and reactive streams 102;thanks for reporting and sharing code to reproduce the issue the bug is in `singleorerror` triggered by a conversion back to `toflowable` fix posted in #5904 ||;1;0;2x: fix flowablesingleorerror()toflowable() not signalling nsee;
5905;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: coverage improvements  logical fixes and cleanups 03/08;this pr fixes a couple of logical errors and cleans up some other components as well as improves the coverage of some classes. see the change comments below about the relevant details.;;0;2x: coverage improvements logical fixes and cleanups 03/08;this pr fixes a couple of logical errors and cleans up some other components as well as improves the coverage of some classes see the change comments below about the relevant details;changes explained ||  merging 5905 ;;;;1;1;2x: coverage improvements logical fixes and cleanups 03/08;
5906;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add public constructor for testscheduler that takes the time.;- adds a time constructor to testscheduler;;590.0;2x: add public constructor for testscheduler that takes the time;- adds a time constructor to testscheduler- should i make it experimental or will it just be stable?5901; merging 5906  < ;serialsubscription is missing isunsubscribed;public class serialsubscription implements subscription {    @override    public void unsubscribe() {}}    public void setsubscription(final subscription subscription) {}      public subscription getsubscription() {}}http://msdnmicrosoftcom/en-us/library/systemreactivedisposablesserialdisposable_properties(vvs103)aspx; in  ||;1;0;wording;
5907;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: cleanup test local variable names;add an unit test that scans the unit test files for common local variable misnaming due to copy-pasting between the types  such as:;;0;2x: cleanup test local variable names;add an unit test that scans the unit test files for common local variable misnaming due to copy-pasting between the types such as:- `testobserver ts` <-> `testsubscriber to`- `publishsubject pp` <-> `publishprocessor ps`see the new `checklocalvariablesintests` for other patterns described with a regexp; merging 5907 ;;;;1;1;check for observable c;
5910;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: improve coverage  fix operator logic 03/12;improve coverage of rxjava internal components. see the change explanation as comments below.;;0;2x: improve coverage fix operator logic 03/12;improve coverage of rxjava internal components see the change explanation as comments below;done with the explanations ||  merging 5910 ;;;;1;1;2x: improve coverage fix operator logic 03/12;
5914;1;0;0;0;0;1;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: benchmark x-map-z operators;this pr adds jmh benchmarks to measure operators mapping onto other types  such as  flatmapcompletable    concatmapsingle   etc. in addition  two new benchmarks were added to measure the  flatmapiterable  performance in additional situations.;;0;2x: benchmark x-map-z operators;this pr adds jmh benchmarks to measure operators mapping onto other types such as `flatmapcompletable` `concatmapsingle` etc in addition two new benchmarks were added to measure the `flatmapiterable` performance in additional situations#### baseline resultsi7 4770k windows 7 x64 java 8u162[jmh compare gui]( workspace file: [xmapz_wsxml]( first diagram compares the dedicated plain (same inner type as the outer type) and conversion-based flows:( switchmap-based `observable` operators look like they could use some optimizations overall `count  1` is not optimized with the dedicated versionsfrom the `observable`s perspective:![image]( like the `concatmapx` operators could use some optimizationsthe `flatmapiterable` measures are as follows:![image]( `flowable` version seem to be considerably slower probably not explainable due to backpressure overhead;   no coverage uploaded for pull request base (`2x@90bca55`) [click here to learn what that means]( `n/a`(                                  2x    #5914   +/-   ##  coverage       ?   9819%             complexity     ?     5996             files          ?      655  ?    43927     ?     6084             hits           ?    43134             misses         ?      242             partials       ?      551```------[continue to review full report at codecov]( **legend** - [click here to learn more]( `  absolute <relative> (impact)` `  not affected` `?  missing data`> ( last update [90bca552cc8e7c]( read the [comment docs]( ||;;;;1;1;2x: benchmark x-map-z operators;
5915;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: optimize observableconcatmapcompletable;this pr reduces the overhead in the  observable.concatmapcompletable  operator by:;;0;2x: optimize observableconcatmapcompletable;this pr reduces the overhead in the `observableconcatmapcompletable` operator by:- adding front-queue fusion to eliminate queue allocations (although this didnt improve the performance beyond a +/- 3% noise)- moving the `error` and `errormode` fields into local variables saving on the mandatory volatile re-read of other fields- adding a scalar shortcut in case the upstream is known to be 0-1#### benchmark comparison:i7 4770k windows 7 x64 java 8u162the pr improves the dedicated case considerably:( it is now better across the board compared to a `toflowable` conversion and the main `concatmap`:![image](https://user-imagesentcom/1269832/37437618-7490a244-27ee-11e8-99de-cb20d5828555png); merging 5915 ;;;;1;1;2x: optimize observableconcatmapcompletable;
5918;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: improve the scalar source performance of observable.(concat|switch)mapx;this pr adds scalar source optimizations to  observable  operators:;;0;2x: improve the scalar source performance of observable(concat|switch)mapx;this pr adds scalar source optimizations to `observable` operators:- `concatmapcompletable`- `concatmapsingle`- `concatmapmaybe`- `switchmapcompletable`- `switchmapsingle`- `switchmapmaybe`#### benchmarki7 4770k windows 7 x64 java 8u162the baseline is taken from #5914 the target is to be faster than using the plain `concatmap` or `switchmap` with a `toobservable` conversion the apparent shortcomings of longer `concatmapmaybe` and `concatmapsingle` will be addressed in a subsequent pr(https://user-imagesentcom/1269832/37457267-c41bb4a4-2841-11e8-87a4-3951514a7f8fpng); merging 5918 ;;;;1;1;2x: improve the scalar source perf of obs(concat|switch)mapx;
5919;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add fusion support to observableswitchmap inner source;this pr improves the performance of the  observable.switchmap  operator by adding fusion support as well as upgrading the  completable  and  single  conversion to  observable  to be fuseable. the pr also fixes an error in the  deferredscalardisposable  implementation as the protocol requires calling with  null .;;0;2x: add fusion support to observableswitchmap inner source;this pr improves the performance of the `observableswitchmap` operator by adding fusion support as well as upgrading the `completable` and `single` conversion to `observable` to be fuseable the pr also fixes an error in the `deferredscalardisposable` implementation as the protocol requires calling with `null`the plain (`observableswitchmap(observable)`) conversion has promising performance improvements:( conversion `observableswitchmap(maybetoobservable)` has promising performance improvements:![image]( conversion `observableswitchmap(completabletoobservable)` is also promising but there is a 11% loss in the scalar case for some reason:![image]( the conversion  `observableswitchmap(singletoobservable)` got a bigger hit for the scalar case 21% loss but the rest are impressive:![image](https://user-imagesentcom/1269832/37464636-41ea983e-2859-11e8-9258-6c1c85ee8347png);i dont know why those losses appeared the change to `observercompletableobserver` has only structural change but no code path change the `singletoobservableobserver` now supports fusion which means longer code path on a success value ||  merging 5919  < ;;;;1;1;2x: add fusion (perf++) to observableswitchmap inner source;
5923;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix javadoc warnings of buffer(publisher|callable);text is not allowed between  <dl>  and its child tags.;;5916.0;2x: fix javadoc warnings of buffer(publisher|callable);text is not allowed between `<dl>` and its child tags5916; merging 5923  < ;2x: javadoc syntax error;```:javadoc/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  error: text not allowed in <dl> element     * <dl>           ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/flowablejava  error: text not allowed in <dl> element     * <dl>           ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observablejava  error: text not allowed in <dl> element     * <dl>           ^/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/observablejava  error: text not allowed in <dl> element     * <dl>```;is there any way to fail the build when those errors / warnings are present? || there is a property for it in [buildgradle]( id leave it on not failing though ||;1;0;2x: fix javadoc warnings of buffer(publisher|callable);
5924;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: update single.flatmappublisher marble;renamed the operator in the box. for #5788.;;5788.0;2x: update singleflatmappublisher marble;renamed the operator in the box for #5788![flatmappublisher](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleflatmappublisherpng); ;3x: single incorrect or missing images (tracking issue);-  `amb`: missing diagram-  `ambarray`: missing diagram-  `concat(arg)`: missing diagram-  `concat(s1s4)`: add 3rd and 4th source indicate backpressure-  `concatarray`: missing diagram-  `concatarrayeager`: missing diagram-  `concateager`: missing diagram-  `create`: missing diagram-  `defer`: missing diagram-  `error(callable)`: missing diagram- [x] `error(throwable)`: indicate error in the box- [x] `fromcallable`: missing diagram- [x] `frompublisher`: missing diagram- [x] `fromobservable`: missing diagram- [x] `merge`: missing diagram- [x] `merge(singlesource<singlesource<t>>)`: indicate main element is a `singlesource`- [x] `merge(s1s4)`: add 3rd and 4th source indicate backpressure- [x] `mergedelayerror`: iterable/publisher missing diagrams s2s3s4 wrong diagrams- [x] `never`: missing diagram- [x] `timer`: missing diagram- [x] `equals`: missing diagram- [x] `unsafecreate`: missing diagram- [x] `using`: missing diagram- [x] `wrap`: missing diagram- [x] `ambwith`: missing diagram- [x] `as`: missing diagram- [x] `hide`: missing diagram- [x] `compose`: missing diagram- [x] `cache`: missing diagram- [x] `cast`: missing diagram- [x] `delay`: missing diagram- [x] `delaysubscription`: missing diagram- [x] `dematerialize`: missing diagram- [x] `doaftersuccess`: missing diagram- [x] `doafterterminate`: indicate error case- [x] `dofinally`: missing diagram- [x] `doonsubscibe`: missing diagram- [x] `doonsuccess`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonerror`: missing diagram- [x] `doondispose`: missing diagram- [x] `filter`: one source item indicate both true and false outcomes- [x] `flatmappublisher`: operator name- [x] `blockingget`: missing diagram- [x] `lift`: missing diagram- [x] `contains`: missing diagram- [x] `mergewith`: indicate backpressure- [x] `onerrorreturn`: indicate item is the result of a function call with the original error- [x] `onerrorreturnitem`: use the previous `onerrorreturn` diagram change name in box- [x] `onerrorresumenext`: diagram should have one item and no complete marker- [x] `onerrorresumewith`: operator name- [x] `onterminatedetach`: missing diagram- [x] `repeat`: missing diagram- [x] `repeatwhen`: missing diagram- [x] `repeatuntil`: missing diagram- [x] `retry`: missing diagram- [x] `retrywhen`: missing diagram- [x] `subscribe`: missing diagram- [x] `subscribewith`: missing diagram?- [x] `takeuntil`: fix item count in main and other sources indicate all other signal types- [x] `timeout`: missing diagram- [x] `to`: missing diagram- [x] `tocompletable`: diagram is stretched- [x] `toflowable`: operator name in box indicate backpressure- [x] `tofuture`: indicate future remove the blocking text- [x] `tomaybe`: operator name in box indicate both outcomes with proper signal types- [x] `unsubscribeon`: missing diagram- [x] `test`: missing diagram?;i see most marbles in the javadoc live under this folder:  ` are other locations accepted - eg can i upload it in google drive for example and open a pr with the updated path in the javadoc directly? heres a few i created:![single_dofinally]( || images have to be hosted by the project besides google drive tends to change the service terms and images may become inaccessible (ive lost resource location this way in another project) about your images:- `dofinally`:   - error should be a red x  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here- `doondispose`  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here  - `unsubscribe` should be `dispose`- `doonsubscribe`  - the star should be in between the operator box and the bottom timeline- `doonsuccess`: ok || updated images from #5987 now in the repository:![dofinally]( || how are these made? are there any written guidelines? i can try making some when i have time || there is a mac only omnigraffle im on windows and i use excel shapes and arrows || @aarjavp  i used [this template]( as a staring point its for **inkscape** software which worked nicely on my mac || hi all can you please tell me is this marble acceptable for the `filter` operator?as i havent contributed to this project so far i would like to take it easy and slow :) let me know what should i change so that i have a reference for future marbles![filter]( || not really there is no | in single please have a look at diagrams above:  || @akarnokd can we update this issue please? its getting a bit messy and hard to follow what has been completed || @umfsimke it has been only you lately that worked on this ||;1;0;2x: update singleflatmappublisher marble;
5925;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add @nullable annotations to processors;add  @nullable  annotations to processors.;;0;add @nullable annotations to processors;add `@nullable` annotations to processors updated our project to use 2111 and discovered theres this pr  which added `@nullable` annotations to subjects thought might as well add `@nullable` to processors; merging 5925 ;;;;1;1;add @nullable annotations to processors;
5928;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix concatmapsingle & concatmapmaybe dispose-cleanup crash;this pr fixes the accidental logical mistake in the  cancel / dispose  logic of the new  concatmapsingle  and  concatmapmaybe  operators of both  flowable  and  observable  where the internal queue cleanup should happen in a serialized fashion only  which is the state when the work-in-progress counter changes from 0 to 1 ensured by a  ==  check.;;592.0;2x: fix concatmapsingle & concatmapmaybe dispose-cleanup crash;this pr fixes the accidental logical mistake in the `cancel`/`dispose` logic of the new `concatmapsingle` and `concatmapmaybe` operators of both `flowable` and `observable` where the internal queue cleanup should happen in a serialized fashion only which is the state when the work-in-progress counter changes from 0 to 1 ensured by a `` check5927;this is severe enough to release **2112** as a hotfix version asap although the mistakes are in the newly introduced operators ive done a quick search for this pattern and doesnt happen in older code luckily also this is on the dispose path and doesnt really the performance in the normal operation mode (ie when data is allowed to flow through till the end without cancellation) ||  merging 5928 ;serialsubscription and singleassignementsubscription naming subscriptions in general;serialsubscription hasprivate static final subscription unsubscribed  new subscription() {singleassignmentsubscription hasprivate static final subscription sentinel  new subscription() {for the same purposealso these use lockfree implementations the other subscriptions use locksperhaps someone can go over all subscriptions and implement them in the same style and using the same naming conventions;i have to rebase my subscription changes anyway so ill do the renaming to unsubscribed_sentinel || i may help again to use lock free strategy in other subscription implementations || @akarnod you should be able to have serialsubscription inherit from multipleassignmentsubscription the difference is that the latter unsubscribes when swapping in a new subscription i think that would show the intent better and make the code more maintanablein fact i think multipleassignmentsubscription itself can inherit from booleansubscription || i dont know i can create many prs for all kinds of variants but at the end @benjchristensen has to decide id rather avoid look-and-feel development ||;1;0;2x: fix concatmapsingle & concatmapmaybe dispose-cleanup crash;
5930;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add @nonnull annotations to create methods of subjects and processors;i am annotating *subject s and *processor s create methods with @nonnull annotations to remove compiler s nullability warnings when calling the methods from kotlin language.;;0;add @nonnull annotations to create methods of subjects and processors;i am annotating *subjects and *processors create methods with @nonnull annotations to remove compilers nullability warnings when calling the methods from kotlin language; merging 5930 ;;;;1;1;add @nonnull annotations to create methods of subjects and processors;
5936;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix completable.tomaybe() @return javadoc.;current javadoc:;;0;2x: fix completabletomaybe() @return javadoc;current javadoc:```java@return a {@link maybe} that emits a single item t or an error```but in reality converting `maybe` to `completable` should never emit `item t`; merging 5936 ;;;;1;1;fix completabletomaybe() @return javadoc;
"5940;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: allow @schedulersupport on constructors.;motivation behind this is having a class which takes multiple constructor parameters where one can be a scheduler with a default and a custom overload. in both cases i d want to slam  @schedulersupport  on it so it can be handled properly by static analysis as well.;;0;2x: allow @schedulersupport on constructors;motivation behind this is having a class which takes multiple constructor parameters where one can be a scheduler with a default and a custom overload in both cases id want to slam `@schedulersupport` on it so it can be handled properly by static analysis as well;"" merging 5940  <  "";;;;1;1;2x: also allow @schedulersupport on constructors;"
5942;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;removed terminated check in onnext;terminated  is an empty array  so iterating over it would be harmless. the cost of the check is probably minuscule  but it was imposed on the common case where the subject is not terminated. in essence  it was optimizing for misuse of the api.;;0;removed terminated check in onnext;`terminated` is an empty array so iterating over it would be harmless the cost of the check is probably minuscule but it was imposed on the common case where the subject is not terminated in essence it was optimizing for misuse of the api; merging 5942 ;;;;1;1;removed unnecessary terminated check;
"5947;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix groupby cancellation with evicting map factory;5933.;;5933.0;2x: fix groupby cancellation with evicting map factory;5933when the outer stream is cancelled there may be evicted groups present in the queue to be completedive added code to complete the evicted groups in the `cancel` method as suggested by @akarnokd to protect against a race condition where the evictionaction is called just after the evicted groups are completed in `cancel` ive added a `cancelled` check to `evictionaction` however i am concerned about a race that ill place in the comments on the code below; merging 5947 ;2x -- groupby with evicting map -- seeing inconsistent behavior when eviction occurs;""i am using version 2111  im seeing what i believe to be a bug in the groupby operator when configured to use an evicting map  here is a test that demonstrates what im seeing:```java    private static class testticker extends ticker {        long tick  0        @override        public long read() {            return tick        }    }        @test    public void testgroupbyeviction() {        flowableprocessor<integer> source  publishprocessorcreate()        testsubscriber<integer> subscriber1  new testsubscriber<>()        testticker testticker  new testticker()        function<consumer<object> map<object object>> mapfactory  action -> {            return cachebuildernewbuilder()                    expireafteraccess(5 timeunitseconds)                    removallistener(notification -> {                        try {                            actionaccept(notificationgetvalue())                        } catch (exception ex) {                            throw new runtimeexception(ex)                        }                    })ticker(testticker)build()asmap()        }        final list<string> list  collectionssynchronizedlist(new arraylist<string>())        flowable<integer> stream  sourcedooncancel(() -> listadd(""""source canceled""""))                groupby(v -> v functionsidentity() false flowablebuffersize() mapfactory)                flatmap(group -> {            return group                    dooncomplete(() -> listadd(""""group completed""""))                    dooncancel(() -> listadd(""""group canceled""""))        })        streamdooncancel(() -> listadd(""""outer group by canceled""""))subscribe(subscriber1)                // send 3 in the same group and wait for them to be seen        sourceonnext(1)        sourceonnext(1)        sourceonnext(1)        subscriber1awaitcount(3)                // advance time far enough to evict the group        // note -- comment this line out to make the test """"pass""""        testtickertick  timeunitsecondstonanos(6)                // send more data in the group (triggering eviction and recreation)        sourceonnext(1)        sourceonnext(1)        // wait for the last 2 and then cancel the subscription        subscriber1awaitcount(5)        subscriber1cancel()        // observe the result  note that right now the result differs depending on whether eviction occurred or        // not  the observed sequence in that case is:  group completed outer group by canceled group canceled        // the addition of the """"group completed"""" is actually fine but the fact that the cancel doesnt reach the        // source seems like a bug  commenting out the setting of """"tick"""" above will produce the """"expected"""" sequence        assertequals(arraysaslist(                // """"group completed"""" -- this is here when eviction occurs                """"outer group by canceled""""                 """"group canceled""""                """"source canceled""""  // this is *not* here when eviction occurs        ) list)    }```as you can see from this when a group eviction occurs and the root subscription is canceled the cancel dose not propagate beyond the `groupby` (it does when there is no eviction)  i think the reason for this is that after the eviction processing (line 188 of flowablegroupby) the groupcount is 3 when i believe it should be 2)  this leads the groupby to conclude that there are 2 active groups when the cancel occurs when in fact there is only one  this doesnt happen when there is no eviction (you can see this by commenting out the line that updates """"tick"""")"";yes looks like eviction only happens when an upstream item is coming down i think the same eviction logic could be run in `cancel()` as well:```java        @override        public void cancel() {            // cancelling the main source means we dont want any more groups            // but running groups still require new values            if (cancelledcompareandset(false true)) {                if (evictedgroups ! null) {                    groupedunicast<k v> evictedgroup                    while ((evictedgroup  evictedgroupspoll()) ! null) {                        evictedgrouponcomplete()                    }                }                if (groupcountdecrementandget()  0) {                    scancel()                }            }        }```/cc @davidmoten  || thanks for the report ill fix tomorrow || sorry for the delay ill try to tackle this in the coming weeks ||;1;0;2x fix group-by eviction so that source is cancelled and reduce volatile reads (#5933);"
"5948;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix observable javadoc (#5944);* replace  dooncancel  by  doondispose  in observable javadoc;;5944.0;fix observable javadoc (#5944);""* replace `dooncancel`  doondispose` in observable javadocthank you for contributing to rxjava before pressing the """"create pull request"""" button please consider the following points:  -  please give a description about what and why you are contributing even if its trivialreplace `dooncancel`  doondispose` in observable javadoc  -  please include the issue list number(s) or other pr numbers in the description if you are contributing in response to those#5944  -  please include a reasonable set of unit tests if you contribute new code or change an existing one if you contribute an operator (if applicable) please make sure you have tests for working with an `empty` `just` `range` of values as well as an `error` source with and/or without backpressure and see if unsubscription/cancellation propagates correctlyjavadoc only""; merging 5948 ;canceling an observable in rxjava 2x;""**observablefromfuture**s javadoc says """"unlike 1x cancelling the observable wont cancel the future if necessary one can use composition to achieve the cancellation effect: futureobservablesourcedooncancel(() -> futurecancel(true))""""flowable has this method and it works as expected like this:```    disposable disposable  flowablefromfuture(response schedulersio())      dooncancel(() -> responsecancel(true))      subscribe()```but observable seems to lack **dooncancel** method doesnt it?tested rxjavas version is 2110"";its equivalent is doondispose a copy-paste error pr welcome || hellodoes someone work on this topic? i would like to start contributing can i do it? || @romanwuattier you can start working on this || closing via #5948 ||;1;0;fix observable javadoc (#5944)* replace `dooncancel`  doondispose`;"
5951;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: blockingx javadoc to mention wrapping of checked exceptions;this pr adds an **error handling** section to various  blockingx  operators to specify checked exceptions from their source will be wrapped into  runtimeexception s.;;0;2x: blockingx javadoc to mention wrapping of checked exceptions;this pr adds an **error handling** section to various `blockingx` operators to specify checked exceptions from their source will be wrapped into `runtimeexception`s; merging 5951 ;;;;1;1;2x: blockingx javadoc to mention wrapping of checked exc;
5952;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;appendonlylinkedarraylist#foreachwhile is not breaking iteration properly;appendonlylinkedarraylist#foreachwhile(nonthrowingpredicate)  was  break -ing from inner loop instead of  return -ing when predicate returned  true .;;0;appendonlylinkedarraylist#foreachwhile is not breaking iteration properly;`appendonlylinkedarraylist#foreachwhile(nonthrowingpredicate)` was `break`-ing from inner loop instead of `return`-ing when predicate returned `true`this caused iteration to continue with items from the next array bucket; merging 5952 ;;;;1;1; conditional iteration breaking;
5957;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add single.ignoreelement  deprecate tocompletable;rename-deprecate  single.tocompletable  to  ignoreelement  to be in line with the same operator in the other classes and also indicate more clearly in the method name that it ignores the element.;;0;2x: add singleignoreelement deprecate tocompletable;rename-deprecate `singletocompletable` to `ignoreelement` to be in line with the same operator in the other classes and also indicate more clearly in the method name that it ignores the elementin addition the marbles have been updated on both `single` and `maybe` of this operator(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleignoreelementpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeignoreelementpng); merging 5957 ;;;;1;1;have singleignoreelement standard from the start;
5959;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix some grammar mistakes;this pr fixes a bunch of typos (in many files) and grammar mistakes in  flowable  (based on grammarly checks).;;0;2x: fix some grammar mistakes;this pr fixes a bunch of typos (in many files) and grammar mistakes in `flowable` (based on grammarly checks)the pr also fixes the `javadocwording` checks to start from the beginning of the methods javadoc as well as checking for cross-line a/an typos;fyi i was using [this]( little program to extract and scrape the javadoc split it into multiple files and feed them one by one to [grammarlys]( desktop app unfortunately only basic mistakes are highlighted and other more complicated errors (such as passive misuse wording) require paid services ||  merging 5959  < ;;;;1;1;fix additional a/an mistakes;
5966;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: workaround for objects.requirenonnull inserted by javac;for some reason  when compiling rxjava with java 9 or 10 and target 8  there is an implicit  objects.requirenonnull  added by the compiler to  us.new x  which makes animalsniffer detect a non-java 6 api usage. interestingly  this does not happen with:;;0;2x: workaround for objectsrequirenonnull inserted by javac;for some reason when compiling rxjava with java 9 or 10 and target 8 there is an implicit `objectsrequirenonnull` added by the compiler to `usnew x` which makes animalsniffer detect a non-java 6 api usage interestingly this does not happen with:- java 8 target 6 - java 8 target 8 - java 9 target 6 - java 9 target 9 - java 10 target 6 - java 10 target 9- java 10 target 10or animalsniffer doesnt detect it for non-8 targets somehow i know that the latest animalsniffer doesnt work with (some?) java 9 class files but it doesnt explain why the fully supported java 8 target 8 does not trigger this error but java 9 target 8 doesi have reported this anomaly as a potential javac bugthe build matrices and outcomes for rxjava 2 can be found here: https://travis-ciorg/akarnokd/rxjava2_9/builds; merging 5966 ;;;;1;1;2x: workaround for objectsrequirenonnull inserted by javac;
5972;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix observable.concatmapsingle dropping upstream items;the internal queue of  observable.concatmapsingle  was incorrectly the bounded one from its  flowable  counterpart  causing it to drop upstream items if the current  single  was delayed. the right queue for  observable s is the  spsclinkedarrayqueue .;;5971.0;2x: fix observableconcatmapsingle dropping upstream items;the internal queue of `observableconcatmapsingle` was incorrectly the bounded one from its `flowable` counterpart causing it to drop upstream items if the current `single` was delayed the right queue for `observable`s is the `spsclinkedarrayqueue`added unit tests to both `concatmapsingle` and `concatmapmaybe` to verify the correct behaviorfixes: #5971; merging 5972 ;concatmapsingle ignores some onnext events;**version used: 2112**i have a collection of interfaces they all define a method fetching a collection of items: `single<list<integer>> fetchitems()` some of them perform local computations others a network call when concatening using `concatmapsingle` some of the singles are not subscribed at allhere is a test i do think should pass a network call is faked here using a timer if the timer is replaced with `singlejust` instead the test is passing```java@testpublic void test() {  testscheduler testscheduler  new testscheduler()  final single<list<integer>> first  singletimer(2 timeunitseconds testscheduler)map(u -> arraysaslist(1 2 3))  final single<list<integer>> second  singlejust(collectionsemptylist())  final single<list<integer>> third  singlejust(collectionssingletonlist(4))  final single<list<integer>> fourth  singlejust(collectionssingletonlist(5))  single<list<integer>> subject  observable    fromiterable(arraysaslist(first second third fourth))    concatmapsingle(single -> single)    reduce(new arraylist<>() (seed items) -> {      seedaddall(items)      return seed    })    testobserver<list<integer>> testobserver  subjecttest()    testscheduleradvancetimeby(2 timeunitseconds)    testobserverassertvalue(list -> listequals(arraysaslist(1 2 3 4 5)))     // 5 is currently missing  fourth was never subscribed in the first place}```*it is my first issue on this repo feel free to edit my pr if i am not respecting the contribution guidelines*;hi and thanks for reporting this is a bug in the `concatmapsingle` operator ill post a fix shortly || fix in #5972 || thanks appreciate it! ||;1;0;2x: fix observableconcatmapsingle dropping upstream items;
5975;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix refcount() connect/subscribe/cancel deadlock;this pr fixes a deadlock issue with the  refcount  operator when a subscription leads to a blocking execution while the lock is being held  preventing other subscription or cancellation from executing on other threads.;;0;2x: fix refcount() connect/subscribe/cancel deadlock;this pr fixes a deadlock issue with the `refcount` operator when a subscription leads to a blocking execution while the lock is being held preventing other subscription or cancellation from executing on other threadsthe bug was discovered as the cause of a reported hang on [the google groups]( [code]( has been developed in the extensions project where the operator has [more features]( the overloads supporting these features can be added in a separate enhancement pr; merging 5975 ;;;;1;1;fix termination cleanup;
"5976;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;adding eager concats to single;- adding concateager operator for singles covering:;;0;adding eager concats to single;- adding concateager operator for singles covering:   concateager(publisher<? extends singlesource<? extends t>> sources)   concateager(iterable<? extends singlesource<? extends t>> sources)   concatarrayeager(singlesource<? extends t> sources)  - issue:  - added tests for both methods i wasnt sure if i should add tests covering just a single element in the vararg list and respectively an iterable with a single element any thoughts on this?;first of all there is no reason keep the welcome text in the description> added tests for both methods i wasnt sure if i should add tests covering just a single element in the vararg list and respectively an iterable with a single element any thoughts on this?since this operator relies on `flowableconcatmapeager` there is no need for too much testing only ensuring that the `singleconcateager` is implemented and `single` remains ;;;;1;1;""fixing javadoc """"maybe sources"""" -> """"maybesources"""""";"
"5977;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: maybe/single javadoc  annotation cleanup;the pr cleans up some wording around  single source  and  maybe source   plus removes some unnecessary annotations.;;0;2x: maybe/single javadoc annotation cleanup;""the pr cleans up some wording around """"single source"""" and """"maybe source"""" plus removes some unnecessary annotations""; merging 5977 ;;;;1;1;2x: maybe/single javadoc annotation cleanup;"
5978;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix flowable.take to route post-cancel errors to rxjavaplugins.onerror;this pr makes sure errors emitted by the upstream just after the  flowable.take  has received the specified amount of items get routed to  rxjavaplugins.onerror .;;0;2x: fix flowabletake to route post-cancel errors to rxjavapluginsonerror;this pr makes sure errors emitted by the upstream just after the `flowabletake` has received the specified amount of items get routed to `rxjavapluginsonerror``observabletake()` and `flowablelimit()` were already doing this added unit tests to verify the behavior across the board; merging 5978 ;;;;1;1;2x: flowabletake to route post-cancel errors to plugin error handler;
"5979;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add throttlelatest operator;this pr adds the  throttlelatest  operator to  observable  and  flowable   also known as  conflate  (#4856): it is a combination of  throttlefirst  and  sample  whereby frequent items are sampled but the first item outside the sampling window will be emitted immediately:;;4856.0;2x: add throttlelatest operator;this pr adds the `throttlelatest` operator to `observable` and `flowable` also known as `conflate` (#4856): it is a combination of `throttlefirst` and `sample` whereby frequent items are sampled but the first item outside the sampling window will be emitted immediately:![throttlelatest]( #4856replaces: #5968; merging 5979 ;conflate operator;rxjava should have conflate operator i see we have sample debounce etc but actually they are not equivalent to conflate  conflate operator should behave as sample if updates are faster than the given interval but if updates stops and new update comes after a long period it should push immediately instead of waiting for sampling period;""is the behavior your after equivalent to zip(stream interval())? i toowant such an operator and i was about to file an issue tomorrow it finallyhit my three separate use cases bar for wanting it to be first partyon tue nov 15 2016 7:06 pm majormud notifications@githubcom wrote:> rxjava should have conflate operator i see we have sample debounce etc> but actually they are not equivalent to conflate > > conflate operator should behave as sample if updates are faster than the> given interval but if updates stops and new update comes after a long> period it should push immediately instead of waiting for sampling period> > > you are receiving this because you are subscribed to this thread> reply to this email directly view it on github>  or mute the thread>   || not sure how would you achieve with zip sample at timeout out interval if source is emitting too fast but if source is slower than the timeout interval emit right away oooooo --->-->-->-->-->-->-->-->----x-------x-------------x  || is `throttlefirst` closer to what you are looking for?!( || throttlefirst drops events i believe this doesnt want that its like """"atmost"""" every x intervalon tue nov 15 2016 8:25 pm george campbell notifications@githubcomwrote:> is throttlefirst closer to what you are looking for?> >  > > you are receiving this because you commented> > reply to this email directly view it on github>  or mute the thread>   || throttlelast/sample is what i want if source is publishing too fast but then publish the item right away dont wait for the sample timeout if it was published slower than then timeout interval took stab at this   || how about this?( || for my case i would need green before the blues if thats not conflateill file a separate issueon tue nov 15 2016 8:43 pm george campbell notifications@githubcomwrote:> how about this?> [image: image]>  > > you are receiving this because you commented> > reply to this email directly view it on github>  or mute the thread>   || i was being lazy about the timing of the end of yellows timeout and cyans arrival i was mostly trying to highlight that this is `throttlefirstandlastbutnotlastifitisthesameasthefirst`- red is not emitted twice- blue is emitted at the end of cyans interval || red should output at the end of first period green at the end of 2nd period dark blue at the end of 3rd period  not at the start of period as shown how to generate diagram probably can explain that way better  || was i misinterpreting this statement?> publish the item right away dont wait for the sample timeoutthat seems to conflict with> red should output at the end of first periodthe diagram source file is an omnigraffle in the wiki repo ` the file is `images/rx-operatorsgraffle` || ![image]( || if i understand correctly you need a throttlefirst but instead of dropping the incoming values in the period youd want to keep the latest and emit it immediately once the period ends starting a new period what should happen if there is an active period plus a latest element is waiting and the main source completes? || emit the last one emitted before oncomplete yes want to throttle first but if there is inactivity more than the throttle periodwhen source emits emit right away bcos we already waited more than the throttle periodsso in my diagram yellow is emitted right away even though it falls between the throttle period because it wait one full throttle period before  || i think this operator should go into [rxjava-extras]( as it seems to address the needs of a small set of developers only and possibly introduce confusion with `throttlefirst` im sure @davidmoten and i will accept such operator if contributed || yes makes sense happy to contribute any guidelines please share advise  || just clone the respective repo create a new branch pick a package (`huakarnokdrxjava2operators` for rxjava2extensions `comgithubdavidmotenrxinternaloperators` for rxjava-extras) write the operator create the pull request and we will review it || i cloned created a local branch conflateoperator try to push get error  remote: permission to akarnokd/rxjava2extensionsgit denied to mrudangitfatal: unable to access  the requested url returned error: 403 || push to your own repository || pushed to  || now if you go to my repo you should see the create pr option || @mrudangit in your latest drawing shouldnt green be emitted (immediately) and then dark-blue and light-blue and then purple (delayed)? || yes it can be looked that way also to convey intent i did that way but yes the first one should be output immediately and the delay as per interval  || did you mean this operator & behavior: [observableconflatejava]( || nice as per test looks what it should do  will take it to spin is it with rxjava2 ? || rxjava 1x || ive been looking for a non-lagging rate-limiting operator like the one described here for a while now and couldnt find it so after some collaboration with our in-house experts (including @jakewharton and @loganj) we came up with a `compose`-transformer (tested with rxjava 123):```public static <t> transformer<t t> adaptivesample(long time timeunit unit scheduler scheduler) {  return source -> source      publish(shared -> concat(          sharedtake(1)          sharedsample(time unit scheduler))          repeatwhen(a -> shareddebounce(time unit scheduler)))}```this must be the most natural rate-limiting operator because at any given moment of time its as close to the source observable as possible given the restriction of the rate-limiting time period for example (time period  4 chars):```source: -1-2-3-45------6-7-8-output: -1---3---5-----6---8-```notice how it emits immediately after a period of quiet and then continues to sample while source is emitting at high rate thus there is no unnecessary lag as it """"adapts"""" the sampling to the source hence the nameit could be used to rate-limit ui updates of an """"unread message count"""" or to limit frequency of metadata refresh requests to server basically its what most people expect when they start looking at `sample` `throttle` `throttlefirst` and similar operators which unfortunately do not work too well in real-world scenarios@mrudangit - could you try it and see if it works for you? || @valeriyo  looks good in testing noticed one thing if i have more than 1 subscribers they are not getting same values some get one published before etc  in conflation done on publish side all the subscribers should get the same conflated output  @akarnokd  i am not able to compile in java 8 / intellij   || @mrudangit what is the compilers error message? || i see oddly eclipse didnt complain i have updated the gist || i get this error error:(45 17) java: name clash: call(rxsubscriber<? super t>) in comxxx overrides a method whose erasure is the same as another method yet neither overrides the other  first method:  call(t) in rxfunctionsfunc1  second method: call(t) in rxfunctionsaction1 || im closing this issue due to inactivity if you have further input on the issue dont hesitate to reopen this issue or post a new one || i built my 3rd instance of this for a project (next time im stealing davids gist!) it seems to come up a lot when building uis you want to be notified immediately and then no frequently than x unless more than x has passed in which case the next notification should be immediate this is especially true as we have a lot of sources for ui which emit synchronously upon subscribe and then connect to some asynchronously updating sourcesometimes i just compromise and do a `take(1)` and `throttlelast` merged despite it slowing down the async dataim all for keeping rxjava small theres plenty of custom one-off custom or composite operators ive had to build that i wouldnt want in the main lib this one seems like it could make the cut for general applicability i was able to find 2 other people in 10 minutes who had written versions of this (aside from the two others in this thread and me)im not sure how we would determine whether or not something like this makes the cut for me it can be thought of as a variant of existing operators rather than something wildly new it cant be created as a composite operator with acceptibly-low overhead (valeriys solution works but it allocates quite a bit) and the use case seems non-rare (based on a small sample no pun intended)would love to hear what others think || hi @jakewhartonthanks for bringing this issue back to life :)in my opinion none of the built-in throttling operators are usable """"as is"""" for many common tasks (including updating ui):  * `throttlefirst` has no latency but loses trailing items  * `throttlelast` has latency and its lossy wrt very last item  * `sample` has latency  * `debounce` has latency and suffers from """"starvation""""the middle two operators also maintain a """"ticking"""" timer which would wake up and re-schedule each and every interval even if there is nothing to emit hence wasteful with bursty streams of eventsfor these reasons my opinion is that it would be way better to have one rate-limiting operator which works (no latency not lossy no starvation no unnecessary ticking timer) than have 4+ flawed ones )heck it took me weeks if not months to 1) realize that none of the built-in operators do what i want 2) formulate the desired behavior 3) search for solution online give up then consult implement and test - it shouldnt be so difficult!by the way here is the revised version without `repeatwhen` (per #5414):```public static <t> transformer<t t> adaptivesample(long time timeunit unit scheduler scheduler) {  return source -> source      publish(shared -> shared          debounce(time unit scheduler)          map(a -> 0)          startwith(0)          switchmap(a -> concat(sharedtake(1) sharedsample(time unit scheduler))))}```regarding naming im not sure that """"conflate"""" is a good name its short but it doesnt convey the meaning well enough maybe """"ratelimit"""" or """"naturalsample"""" something more easily understandable?thanks for reading || this is a bit old issue and i cant remember the exact pattern expected here i guess we can add this to rxjava for discoverability id name it `throttleandsample` so it appears along with the other `throttlex` operators || "";1;0;2x: add throttlelatest operator;"
5981;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: improve javadocs of the subscribeactual methods;the pr improves the wording of the abstract  subscribeactual  method across the base reactive types.;;0;2x: improve javadocs of the subscribeactual methods;the pr improves the wording of the abstract `subscribeactual` method across the base reactive types; merging 5981 ;;;;1;1;2x: improve javadocs of the subscribeactual methods;
5982;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: deprecate getvalues() in subjects/processors;this pr deprecates the  getvalues()  and  getvalues(t)  methods in  asyncsubject    behaviorsubject    asyncprocessor  and  behaviorprocessor .;;0;2x: deprecate getvalues() in subjects/processors;this pr deprecates the `getvalues()` and `getvalues(t)` methods in `asyncsubject` `behaviorsubject` `asyncprocessor` and `behaviorprocessor`these methods were remnants of an early 2x api design where `subject` itself had these methods for the sake of `replaysubject`  and `serializedsubject` and thus every other subject type had to implement them the listed subjects and processors above have at most one value accessible via `getvalue()` which can then be assigned to an array index manually if needed; merging 5982 ;;;;1;1;2x: deprecate getvalues() in subjects/processors;
5984;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add blockingsubscribe javadoc clarifications;this pr adds some clarifications to the  blockingsubscribe  methods on  flowable  and  observable .;;0;2x: add blockingsubscribe javadoc clarifications;this pr adds some clarifications to the `blockingsubscribe` methods on `flowable` and `observable`; merging 5984  < ;;;;1;1;2x: add blockingsubscribe javadoc clarifications;
5985;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: small cleanups in the scheduler class;- remove  @nonnull  from a primitive type;;0;2x: small cleanups in the scheduler class;- remove `@nonnull` from a primitive type- make the package-private `periodicdirecttask` final- add `@nonnull` to other fields; merging 5985 ;;;;1;1;2x: cleanup in the scheduler class;
5986;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add refcount with count & disconnect timeout;this pr exposes the additional  refcount  operation modes from #5975:;;0;2x: add refcount with count & disconnect timeout;this pr exposes the additional `refcount` operation modes from #5975:- connect only when the specified number of `subscriber`s/`observer`s have subscribed- disconnect when the given amount of time elapsed since the very last `subscriber`/`observer` cancelled/disposed- the combination of bothin addition the original `refcount` received extra javadocs details; merging 5986 ;;;;1;1;ensure coverage;
5987;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add marble diagrams to a few single.doonx methods.;this should tick a few tasks from this issue: https://github.com/reactivex/rxjava/issues/5788.;;0;add marble diagrams to a few singledoonx methods;this should tick a few tasks from this issue:  urls are a bit ugly as theyre from the uploads in the issue im happy to update the urls with different ones if theres a better place to upload the diagrams;thanks for the pr there are a couple of things to be changed on the diagrams once done ill upload them into this repo and provide you with the proper urls so you can update this pr || sure will get these  tonight :) || hope these are better:![single_dofinally]( ||  merging 5987 ;;;;1;1;use correct marble diagram urls for couple of singledoonxx methods;
5991;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix switchmap to indicate boundary fusion;fix  flowable.switchmap  and  observable.switchmap  to request for boundary fusion in order to prevent a thread-confined but otherwise fusion-capable sub-sequence from running on the unintended thread.;;0;2x: fix switchmap to indicate boundary fusion;fix `flowableswitchmap` and `observableswitchmap` to request for boundary fusion in order to prevent a thread-confined but otherwise fusion-capable sub-sequence from running on the unintended threadfixes: #5990; merging 5991  < ;;;;1;1;2x: fix switchmap to indicate boundary fusion;
5992;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;observable s javadoc cleanup;the sample code in the observable javadoc erroneously uses  onnext(integer t)  for a  disposableobserver<string>;;0;observables javadoc cleanup;the sample code in the observable javadoc erroneously uses `onnext(integer t)` for a `disposableobserver<string>`this has been corrected to be `onnext(string t)`; merging 5992 ;;;;1;1;observable javadoc cleanupthe sample code in the observable javadoc erroneously uses onnext(integer t) for a disposableobserver<string>this has been corrected to be onnext(string t);
"5995;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;implement  tostring  method for some emitters;when use  .create  method it s unclear why  emitter  is null (if call  tostring  or observe object via debugger).;;0;implement tostring method for some emitters;when use `create` method its unclear why `emitter` is null (if call `tostring` or observe object via debugger);"" merging 5995  "";;;;1;1;add test for tostring method of serializedemitter;"
6002;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add multicastprocessor;this pr adds the  multicastprocessor  from the [extensions project]( to be a standard processor option.;;0;2x: add multicastprocessor;this pr adds the `multicastprocessor` from the [extensions project]( to be a standard processor optionthis type of processor fills the gap of having a backpressure-coordinating processor type as `publishprocessor` doesnt coordinate backpressure on its own and `flowablepublish()` often cant be used because the upstream may not yet exist when the dowstream consumers are setup![multicastprocessor]( mp  flowablerange(1 10)    subscribewith(multicastprocessorcreate())mptest()assertresult(1 2 3 4 5 6 7 8 9 10)// --------------------multicastprocessor<integer> mp2  multicastprocessorcreate(4)mp2start()asserttrue(mp2offer(1))asserttrue(mp2offer(2))asserttrue(mp2offer(3))asserttrue(mp2offer(4))assertfalse(mp2offer(5))mp2oncomplete()mp2test()assertresult(1 2 3 4)```resolves: #5999; merging 6002 ;;;;1;1;address review feedback;
6010;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add assertvaluesetonly and assertvaluesequenceonly to testobserver + testsubscriber;this basically copies the behavior of  assertvaluesonly  to the  assertvalueset  and  assertvaluesequence  equivalent methods.;;0;2x: add assertvaluesetonly and assertvaluesequenceonly to testobserver + testsubscriber;this basically copies the behavior of `assertvaluesonly` to the `assertvalueset` and `assertvaluesequence` equivalent methodscoped the tests exactly from `assertvaluesonly` and adjusted them with the new added methods; merging 6010 ;;;;1;1;lowercase;
"6014;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix & prevent null checks on primitives;this pr removes the accidental null checks on primitives in two  observable  methods and adds a trap method to  objecthelper  to both highlight and fail the tests in case the null checks are still attempted. the method is marked as deprecated so it will also show up in (eclipse s) problems window.;;601.0;2x: fix & prevent null checks on primitives;this pr removes the accidental null checks on primitives in two `observable` methods and adds a trap method to `objecthelper` to both highlight and fail the tests in case the null checks are still attempted the method is marked as deprecated so it will also show up in (eclipses) problems windowreplaces #6012 6013; merging 6014 ;version 0160 release candidate;""following are the changes and release notes for 0160 since so much has changed for this release i want to give people a chance to review and try the code before releasingchanges:---### version 0160 ([maven central]( [pull 516]( rxjava-string module with stringobservable- [pull 533]( operator: toasync- [pull 535]( fix compilation errors due to referencing the android support library directly- [pull 545](  zip issue with infinite streams- [pull 539]( zipping a finite and an infinite observable- [pull 541]( operator: skipuntil- [pull 537]( add scala adapters for dooneach operator- [pull 560]( add type variances for dooneach actions- [pull 562]( scala adaptor improvements- [pull 563]( operator: groupbyuntil- [pull 561]( revised approach to creating observables in scala- [pull 565]( operator: groupjoin v2- [pull 567]( operator: timestamp with scheduler- [pull 568]( use lock free strategy for several subscription implementations- [pull 571]( operator: sample with observable v2- [pull 572]( multiple subscriptions to observeon- [pull 573]( removed opening and closing historical artifacts- [pull 575]( operator: sequenceequal reimplementation- [pull 587]( operator: longcount- [pull 586]( fix concat to allow multiple observers- [pull 598]( new scala bindings- [pull 596]( fix for buffer not stopping when unsubscribed- [pull 576]( operators: timer and delay- [pull 593]( lock-free subscriptions- [pull 599]( refactor rxconcurrency to rxschedulers- [pull 600]( bugfix: replay subject- [pull 594]( operator: start- [pull 604]( stringobservablejoin- [pull 609]( operation: timer- [pull 612]( operation: replay (overloads)- [pull 628]( bugfix: mergedelayerror synchronization- [pull 602]( bugfix: observeon subscription leak- [pull 631]( make newthreadscheduler create daemon threads- [pull 651]( subjects refactor - non-blocking common abstraction performance- [pull 661]( subscriptions rewrite- [pull 520]( bugfix: blocking/non-blocking `first`- [pull 621]( scala: serialsubscription & from- [pull 626]( bolatest fixed: bonext bomostrecent botoiterable- [pull 633]( bugfix: null in tolist operator- [pull 635]( conditional operators- [pull 638]( operations: delaysubscription takelast w/ time takelastbuffer- [pull 659]( missing fixes from the subject rewrite- [pull 688]( fix safeobserver handling of oncomplete errors- [pull 690]( fixed scala bindings- [pull 693]( kotlin m62- [pull 689]( removed observerbase- [pull 664]( operation: asobservable- [pull 697]( operations: skip skiplast take with time- [pull 698]( operations: average sum- [pull 699]( operation: repeat- [pull 701]( operation: collect- [pull 707]( module: rxjava-async-util- [pull 708]( bugfix: combinelatest- [pull 712]( fix scheduler memory leaks- [pull 714]( module: rxjava-computation-expressions- [pull 715]( add missing type hint to clojure example- [pull 717]( scala: added connectableobservable- [pull 723]( deprecate multiple arity from- [pull 724]( revert use of currentthreadscheduler for observablefrom- [pull 725]( simpler computation/io naming for schedulers- [pull 727]( immediatescheduler optimization for toobservableiterable---- this release includes breaking changes to scala bindings details are below- the `rxconcurrency` package has been renamed to `rxschedulers` existing classes still remain in `rxconcurrency` but are deprecated use of `rxconcurrency` should be migrated to `rxschedulers` as these deprecated classes will be removed in a future release- refactor of subjects and subscriptions to non-blocking implementations- many bug fixes new operators and behavior changes to match rxnet- deprecation of some operators due to renaming or eliminating duplicates- new modules: rxjava-string rxjava-async-util and rxjava-computation-expressions for operators deemed not applicable to the core library---### scala release notes---this release of the rxscala bindings builds on the previous 015 release to make the rx bindings for scalainclude all rx types in particular this release focuses on fleshing out the bindings for the `subject` and `scheduler`types as well as aligning the constructor functions for `observable` with those in the rxjavaexpect to see ongoing additions to make the scala binding match the equivalent underlying java apias well as minor changes in the existing api as we keep fine-tuning the experience on our way to a v10 release## observerin this release we have made the `asjavaobserver` property in `observable[t]`as well the the factory method in thecompanion object that takes an `rxobserver` private to the scala bindings package thus properly hiding irrelevantimplementation details from the user-facing api the `observer[t]` trait now looks like a clean native scala type:``` scalatrait observer[-t] {  def onnext(value: t): unit  def onerror(error: throwable): unit  def oncompleted(): unit}object observer {}```to create an instance of a specific `observer` say  `observer[sensorevent]` in user code you can create a new instanceof the `observer` trait by implementing any of the methods that you care about:``` scala   val printobserver  new observer[sensorevent] {      override def onnext(value: sensorevent): unit  {valuetostring}   }``` or you can use one of the overloads of the companion `observer` object by passing in implementations of the `onnext` `onerror` or `oncompleted` methodsnote that typically you do not need to create an `observer` since all of the methods that accept an `observer[t]`(for instance `subscribe`) usually come with overloads that accept the individual methods`onnext` `onerror` and `oncompleted` and will automatically create an `observer` for you under the coverswhile _technically_ it is a breaking change make the `asjavaobserver` property private you should probably not havetouched `asjavaobserver` in the first place if you really feel you need to access the underlying `rxobserver`call `tojava`## observablejust like for `observer` the `observable` trait now also hides its `asjavaobservable` property and makes the constructorfunction in the companion object that takes an `rxobservable` private (but leaves the companion object itself public)again while _technically_ this is a breaking change this should not have any influence on user code``` scalatrait observable[+t] {    def subscribe(observer: observer[t]): subscription  {}    def apply(observer: observer[t]): subscription  {}    }object observable {   def create[t](func: observer[t] > subscription): observable[t]  {}   }```the major changes in `observable` are wrt to the factory methods where too libral use of overloading of the `apply`method hindered type inference and made scala code look unnecessarily different than that in other language bindingsall factory methods now have their own name corresponding to the java and net operators(plus overloads that take a `scheduler`)- `def from[t](future: future[t]): observable[t]`- `def from[t](iterable: iterable[t]): observable[t]`- `def error[t](exception: throwable): observable[t]`- `def empty[t]: observable[t]`- `def items[t](items: t*): observable[t]- extension method on `toobservable: observable[t]` on `list[t]`in the _pre-release_ of this version we expose both `apply` and `create` for the mother of all creation functionswe would like to solicit feedback which of these two names is preferred(or both but there is a high probability that only one will be chosen)- `def apply[t](subscribe: observer[t]>subscription): observable[t]`- `def create[t](subscribe: observer[t] > subscription): observable[t]`## subjectthe `subject` trait now also hides the underlying java `asjavasubject: rxsubjectssubject[_ >: t _<: t]`and takes only a single _invariant_ type parameter `t` all existing implementations of `subject` are parametrizedby a single type and this reflects that reality``` scalatrait subject[t] extends observable[t] with observer[t] {}object subject {   def apply(): subject[t]  {}}```for each kind of subject there is a class with a private constructor and a companion object that you should useto create a new kind of subject the subjects that are available are:- `asyncsubject[t]()`- `behaviorsubject[t](value)`- `subject[t]()`- `replaysubject[t]()`the latter is still missing various overloads  whichyou can expect to appear once they are added to the underlying rxjava implementationcompared with release 0151 the breaking changes in `subject` for this release aremaking `asjavasubject` private and collapsing its type parameters neither of these should cause troubleand renaming `publishsubject` to `subject`## schedulersthe biggest breaking change compared to the 0151 release is giving `scheduler` the same structure as the other typesthe trait itself remains unchanged except that we made the underlying java representation hidden as aboveas part of this reshuffling the scheduler package has been renamed from `rxlangscalaconcurrency`to `rxlangscalaschedulers` there is a high probability that this package renaming will also happen in rxjava``` scalatrait scheduler {}```in the previous release you created schedulers by selecting them from the `schedulers` objectas in `schedulersimmediate` or `schedulersnewthread` where each would return an instance of the `scheduler` traithowever several of the scheduler implementations have additional methods such as the `testscheduler`which already deviated from the patternin this release we changed this to make scheduler more like `subject` and provide a family of schedulersthat you create using their factory function:- `currentthreadscheduler()`- `executorscheduler(executor)`- `immediatescheduler()`- `newthreadscheduler()`- `scheduledexecutorservicescheduler(scheduledexecutorservice)`- `testscheduler()`- `threadpoolforcomputationscheduler()`- `threadpoolforioscheduler()`in the future we expect that this list will grow further with new schedulers as they are imported from net( make your code compile in the new release you will have to change all occurrences of `schedulersxxx`into `xxxscheduler()` and import `rxlangscalaschedulers` instead of `rxlangscalaschedulers`## subscriptionsthe `subscription` trait in scala now has `isunsubscribed` as a member effectively collapsing the old `subscription`and `booleansubscription` and the latter has been removed from the public surface pending a bug fix in rxjava`serialsubscription` implements its own `isunsubscribed```` scalatrait subscription {  def unsubscribe(): unit  {  }  def isunsubscribed: boolean  }object subscription {}``` to create a `subscription` use one of the following factory methods:- `subscription{}` `subscription()`- `compositesubscription(subscriptions)`- `multipleassignmentsubscription()`- `serialsubscription()`    in case you do feel tempted to call `new subscription{}` directly make sure you wire up `isunsubscribed`  and `unsubscribe()` properly but for all practical purposes you should just use one of the factory methods## notificationsall underlying wrapped `java` types in the `notification` trait are made private like all previous types the companionobjects of `notification` now have both constructor (`apply`) and extractor (`unapply`) functions:``` scalaobject notification {}trait notification[+t] {   override def equals(that: any): boolean  {}   override def hashcode(): int  {}   def apply[r](onnext: t>r onerror: throwable>r oncompleted: ()>r): r  {}}```the nested companion objects of `notification` now have both constructor (`apply`) and extractor (`unapply`) functions:``` scalaobject notification {   object onnext { def apply(){} def unapply(){} }   object onerror { def apply(){} def unapply(){} }   object oncompleted { def apply(){} def unapply(){} }}```to construct a `notification` you import `rxlangscalanotification_` and use `onnext(""""hello"""")`or `onerror(new exception(""""oops!""""))` or `oncompleted()`to pattern match on a notification you create a partial function like so: `case notificationonnext(v) > {  v  }`or you use the `apply` function to pass in functions for each possibilitythere are no breaking changes for notifications## java interop helperssince the scala traits _wrap_ the underlying java types yoo may occasionally will have to wrap an unwrapbetween the two representations the `javaconversion` object provides helper functions of the form `tojavaxxx` and`toscalaxxx` for this purpose properly hiding how precisely the wrapped types are storednote the (un)wrap conversions are defined as implicits in scala but in the unlikely event that you do need thembe kind to the reader of your code and call them explicitly``` scalaobject javaconversions {  import languageimplicitconversions  implicit def tojavanotification[t](s: notification[t]): rxnotification[_ <: t]  {}  implicit def toscalanotification[t](s: rxnotification[_ <: t]): notification[t]  {}  implicit def tojavasubscription(s: subscription): rxsubscription  {}  implicit def toscalasubscription(s: rxsubscription): subscription  {}  implicit def scalaschedulertojavascheduler(s: scheduler): rxscheduler  {}  implicit def javaschedulertoscalascheduler(s: rxscheduler): scheduler  {}  implicit def tojavaobserver[t](s: observer[t]): rxobserver[_ >: t]  {}  implicit def toscalaobserver[t](s: rxobserver[_ >: t]): observer[t]  {}  implicit def tojavaobservable[t](s: observable[t]): rxobservable[_ <: t]  {}  implicit def toscalaobservable[t](observable: rxobservable[_ <: t]): observable[t]  {}}```"";items of discussion or that i would like to resolve before releasing:-  `replaysubject` has a different style from other `subject` implementations im not tied to either approach nor am i sure that the idea of an `abstractsubject` was the right way to go -  im not convinced that `subject` implementations have correct thread-safety or concurrency behavior for example we synchronize on subscriptions but not event emission and im not sure whether that means were vulnerable to losing events or not-  yet more `observeon` fixes/tweaks are needed -  id like to eliminate the `rxutil` dumping ground  -  put exceptions into `rxexceptions` or `rxutilexceptions`?  -  put functions into `rxfunctions` or `rxutilfunctions`?  -  where does range go? timeinterval? timestamped? perhaps in `rxobservables`?  -  why is timestamped not camelcase whereas timeinterval is?-  should abstractsubject be public? i think it should be package private particularly as i dont necessarily agree with the approach (even though i wrote it)-  for consistency should we have `rxoperators` with classes named `operatorxyz` or `rxoperations` and classes named `operationxyz`?-  observerbase needs to be package private or moved into a non-advertised package like `rxoperators` || > why is timestamped not camelcase whereas timeinterval is?because `timestamp` is a single word like `javasqltimestamp`? || observeon fixes:  || > because timestamp is a single word like javasqltimestamp?i guess youre right never mind :-) || ive looked at the `subject` implementations and they seem to be incorrect due to the following reasons:- the `abstractsubject` allows the concurrent execution of onnext and onerror/oncompleted calls ie the emitnotification doesnt lock on `subscription_lock`- `publishsubject` `asyncsubject` and `behaviorsubject` seem to overwrite the last notification value even after the termination condition as the call `statecurrentvalueset(new notification<t>())` is always executed in the subjects onxxx methods regardless of the state new subscribers may observe various states when subscribing || > the abstractsubject allows the concurrent execution of onnext and onerror/oncompleted callsall of rx allows this as it is up to the provider to obey the contract and not call them concurrently that is why we dont  synchronize everything in rx for performance reasons || rx design guideline 68> 68 avoid serializing operators> > as all rx operators are bound to guideline 67 operators can safely assume that their inputs are serialized adding too much synchronization would clutter the code and can lead to performance degradation> > if an observable sequence is not following the rx contract (see chapter 0) it is up to the developer writing the end-user application to fix the observable sequence by calling the synchronize operator at the first place the developer gets a hold of the observable sequence this way the scope of additional synchronization is limited to where it is neededdue to this a `subject` implementation should not need to synchronize `onnext`/`oncompleted`/`onerror` calls they do need to handle `subscribe`/`unsubscribe` concurrent access it is however tricky to achieve both of these since we want to ensure we dont have race-conditions in observers subscribing and seeing the correct view of events that said we dont want to add unnecessary synchronizationfor example on `publishsubject` it is completely fine during a concurrent race between `onnext` and `subscribe` that it may or may not get that `onnext` event thats the nature of concurrently subscribing to a hot `observable` we dont want to pay the overhead of synchronization on `onnext` just so that occasional `subscribe` events can occur || /cc @akarnokd @headinthebox @zsxwing i am ready to release 0160 after running it on a netflix api production canary to assert performance and functionality of the core operators schedulers etc (at least of what we use not new operators)im blocked on a build issue that i cant solve until tomorrow at the office so will release sometime tuesday hopefully ||;1;0;2x: fix & prevent null checks on primitives;"
6014;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix & prevent null checks on primitives;this pr removes the accidental null checks on primitives in two  observable  methods and adds a trap method to  objecthelper  to both highlight and fail the tests in case the null checks are still attempted. the method is marked as deprecated so it will also show up in (eclipse s) problems window.;;6012.0;2x: fix & prevent null checks on primitives;this pr removes the accidental null checks on primitives in two `observable` methods and adds a trap method to `objecthelper` to both highlight and fail the tests in case the null checks are still attempted the method is marked as deprecated so it will also show up in (eclipses) problems windowreplaces #6012 6013; merging 6014 ;stops integer boxing via null checks in observableconcateager;replaces with verifypositive as in other similar methodsthis seems to be a trivial change and makes this more consistent with other areas of the code let me know if it needs its own issue or any specific tests given the methods only accept primitive ints and passing a null integer would throw a runtime exception im not sure theres anything needed outside of the already present testing; merging 6012 ;1;0;2x: fix & prevent null checks on primitives;
6017;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: benchmark (0..1).flatmap  andthen & flattenas performance;this pr adds jmh benchmarks to measure the overhead of  {single|maybe}.flatmap{publisher|observable}    {single|maybe}.flattenas{flowable|observable}  and  completable.andthen({publisher|observable}) .;;0;2x: benchmark (01)flatmap andthen & flattenas performance;this pr adds jmh benchmarks to measure the overhead of `{single|maybe}flatmap{publisher|observable}` `{single|maybe}flattenas{flowable|observable}` and `completableandthen({publisher|observable})`### results on i7 4770k windows 7 x64 java 8u172 jmh 120 (larger is better):#### comparing based on the final output type( should be generally lower overhead yet some cases it has more overhead#### comparing what to flatten(**flatmaphide**  without fusion **flatmap**  reactive source **flattenas**  list source)![image]( **hide** case is expected to have the most overhead yet the two reactive classes have uneven boosts with a supposedly fuseable cases:![image]( comparing based on source type![image]( and `maybe` should be practically the same here yet in some cases `maybe` is quite worse also `completable` should effectively win over the others on each line-------plenty of optimization opportunities; merging 6017 ;;;;1;1;2x: benchmark (01)flatmap and flattenas performance;
"6019;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix single.takeuntil  maybe.takeuntil dispose behavior;fix the dispose behavior of the  single.takeuntil  and  maybe.takeuntil  operators.;;601.0;2x: fix singletakeuntil maybetakeuntil dispose behavior;fix the dispose behavior of the `singletakeuntil` and `maybetakeuntil` operatorstests were also added to the other 3 `takeuntil` variants (for `completable` it is delegated to `amb`)fixes: #6018; merging 6019  < ;version 0160 release candidate;""following are the changes and release notes for 0160 since so much has changed for this release i want to give people a chance to review and try the code before releasingchanges:---### version 0160 ([maven central]( [pull 516]( rxjava-string module with stringobservable- [pull 533]( operator: toasync- [pull 535]( fix compilation errors due to referencing the android support library directly- [pull 545](  zip issue with infinite streams- [pull 539]( zipping a finite and an infinite observable- [pull 541]( operator: skipuntil- [pull 537]( add scala adapters for dooneach operator- [pull 560]( add type variances for dooneach actions- [pull 562]( scala adaptor improvements- [pull 563]( operator: groupbyuntil- [pull 561]( revised approach to creating observables in scala- [pull 565]( operator: groupjoin v2- [pull 567]( operator: timestamp with scheduler- [pull 568]( use lock free strategy for several subscription implementations- [pull 571]( operator: sample with observable v2- [pull 572]( multiple subscriptions to observeon- [pull 573]( removed opening and closing historical artifacts- [pull 575]( operator: sequenceequal reimplementation- [pull 587]( operator: longcount- [pull 586]( fix concat to allow multiple observers- [pull 598]( new scala bindings- [pull 596]( fix for buffer not stopping when unsubscribed- [pull 576]( operators: timer and delay- [pull 593]( lock-free subscriptions- [pull 599]( refactor rxconcurrency to rxschedulers- [pull 600]( bugfix: replay subject- [pull 594]( operator: start- [pull 604]( stringobservablejoin- [pull 609]( operation: timer- [pull 612]( operation: replay (overloads)- [pull 628]( bugfix: mergedelayerror synchronization- [pull 602]( bugfix: observeon subscription leak- [pull 631]( make newthreadscheduler create daemon threads- [pull 651]( subjects refactor - non-blocking common abstraction performance- [pull 661]( subscriptions rewrite- [pull 520]( bugfix: blocking/non-blocking `first`- [pull 621]( scala: serialsubscription & from- [pull 626]( bolatest fixed: bonext bomostrecent botoiterable- [pull 633]( bugfix: null in tolist operator- [pull 635]( conditional operators- [pull 638]( operations: delaysubscription takelast w/ time takelastbuffer- [pull 659]( missing fixes from the subject rewrite- [pull 688]( fix safeobserver handling of oncomplete errors- [pull 690]( fixed scala bindings- [pull 693]( kotlin m62- [pull 689]( removed observerbase- [pull 664]( operation: asobservable- [pull 697]( operations: skip skiplast take with time- [pull 698]( operations: average sum- [pull 699]( operation: repeat- [pull 701]( operation: collect- [pull 707]( module: rxjava-async-util- [pull 708]( bugfix: combinelatest- [pull 712]( fix scheduler memory leaks- [pull 714]( module: rxjava-computation-expressions- [pull 715]( add missing type hint to clojure example- [pull 717]( scala: added connectableobservable- [pull 723]( deprecate multiple arity from- [pull 724]( revert use of currentthreadscheduler for observablefrom- [pull 725]( simpler computation/io naming for schedulers- [pull 727]( immediatescheduler optimization for toobservableiterable---- this release includes breaking changes to scala bindings details are below- the `rxconcurrency` package has been renamed to `rxschedulers` existing classes still remain in `rxconcurrency` but are deprecated use of `rxconcurrency` should be migrated to `rxschedulers` as these deprecated classes will be removed in a future release- refactor of subjects and subscriptions to non-blocking implementations- many bug fixes new operators and behavior changes to match rxnet- deprecation of some operators due to renaming or eliminating duplicates- new modules: rxjava-string rxjava-async-util and rxjava-computation-expressions for operators deemed not applicable to the core library---### scala release notes---this release of the rxscala bindings builds on the previous 015 release to make the rx bindings for scalainclude all rx types in particular this release focuses on fleshing out the bindings for the `subject` and `scheduler`types as well as aligning the constructor functions for `observable` with those in the rxjavaexpect to see ongoing additions to make the scala binding match the equivalent underlying java apias well as minor changes in the existing api as we keep fine-tuning the experience on our way to a v10 release## observerin this release we have made the `asjavaobserver` property in `observable[t]`as well the the factory method in thecompanion object that takes an `rxobserver` private to the scala bindings package thus properly hiding irrelevantimplementation details from the user-facing api the `observer[t]` trait now looks like a clean native scala type:``` scalatrait observer[-t] {  def onnext(value: t): unit  def onerror(error: throwable): unit  def oncompleted(): unit}object observer {}```to create an instance of a specific `observer` say  `observer[sensorevent]` in user code you can create a new instanceof the `observer` trait by implementing any of the methods that you care about:``` scala   val printobserver  new observer[sensorevent] {      override def onnext(value: sensorevent): unit  {valuetostring}   }``` or you can use one of the overloads of the companion `observer` object by passing in implementations of the `onnext` `onerror` or `oncompleted` methodsnote that typically you do not need to create an `observer` since all of the methods that accept an `observer[t]`(for instance `subscribe`) usually come with overloads that accept the individual methods`onnext` `onerror` and `oncompleted` and will automatically create an `observer` for you under the coverswhile _technically_ it is a breaking change make the `asjavaobserver` property private you should probably not havetouched `asjavaobserver` in the first place if you really feel you need to access the underlying `rxobserver`call `tojava`## observablejust like for `observer` the `observable` trait now also hides its `asjavaobservable` property and makes the constructorfunction in the companion object that takes an `rxobservable` private (but leaves the companion object itself public)again while _technically_ this is a breaking change this should not have any influence on user code``` scalatrait observable[+t] {    def subscribe(observer: observer[t]): subscription  {}    def apply(observer: observer[t]): subscription  {}    }object observable {   def create[t](func: observer[t] > subscription): observable[t]  {}   }```the major changes in `observable` are wrt to the factory methods where too libral use of overloading of the `apply`method hindered type inference and made scala code look unnecessarily different than that in other language bindingsall factory methods now have their own name corresponding to the java and net operators(plus overloads that take a `scheduler`)- `def from[t](future: future[t]): observable[t]`- `def from[t](iterable: iterable[t]): observable[t]`- `def error[t](exception: throwable): observable[t]`- `def empty[t]: observable[t]`- `def items[t](items: t*): observable[t]- extension method on `toobservable: observable[t]` on `list[t]`in the _pre-release_ of this version we expose both `apply` and `create` for the mother of all creation functionswe would like to solicit feedback which of these two names is preferred(or both but there is a high probability that only one will be chosen)- `def apply[t](subscribe: observer[t]>subscription): observable[t]`- `def create[t](subscribe: observer[t] > subscription): observable[t]`## subjectthe `subject` trait now also hides the underlying java `asjavasubject: rxsubjectssubject[_ >: t _<: t]`and takes only a single _invariant_ type parameter `t` all existing implementations of `subject` are parametrizedby a single type and this reflects that reality``` scalatrait subject[t] extends observable[t] with observer[t] {}object subject {   def apply(): subject[t]  {}}```for each kind of subject there is a class with a private constructor and a companion object that you should useto create a new kind of subject the subjects that are available are:- `asyncsubject[t]()`- `behaviorsubject[t](value)`- `subject[t]()`- `replaysubject[t]()`the latter is still missing various overloads  whichyou can expect to appear once they are added to the underlying rxjava implementationcompared with release 0151 the breaking changes in `subject` for this release aremaking `asjavasubject` private and collapsing its type parameters neither of these should cause troubleand renaming `publishsubject` to `subject`## schedulersthe biggest breaking change compared to the 0151 release is giving `scheduler` the same structure as the other typesthe trait itself remains unchanged except that we made the underlying java representation hidden as aboveas part of this reshuffling the scheduler package has been renamed from `rxlangscalaconcurrency`to `rxlangscalaschedulers` there is a high probability that this package renaming will also happen in rxjava``` scalatrait scheduler {}```in the previous release you created schedulers by selecting them from the `schedulers` objectas in `schedulersimmediate` or `schedulersnewthread` where each would return an instance of the `scheduler` traithowever several of the scheduler implementations have additional methods such as the `testscheduler`which already deviated from the patternin this release we changed this to make scheduler more like `subject` and provide a family of schedulersthat you create using their factory function:- `currentthreadscheduler()`- `executorscheduler(executor)`- `immediatescheduler()`- `newthreadscheduler()`- `scheduledexecutorservicescheduler(scheduledexecutorservice)`- `testscheduler()`- `threadpoolforcomputationscheduler()`- `threadpoolforioscheduler()`in the future we expect that this list will grow further with new schedulers as they are imported from net( make your code compile in the new release you will have to change all occurrences of `schedulersxxx`into `xxxscheduler()` and import `rxlangscalaschedulers` instead of `rxlangscalaschedulers`## subscriptionsthe `subscription` trait in scala now has `isunsubscribed` as a member effectively collapsing the old `subscription`and `booleansubscription` and the latter has been removed from the public surface pending a bug fix in rxjava`serialsubscription` implements its own `isunsubscribed```` scalatrait subscription {  def unsubscribe(): unit  {  }  def isunsubscribed: boolean  }object subscription {}``` to create a `subscription` use one of the following factory methods:- `subscription{}` `subscription()`- `compositesubscription(subscriptions)`- `multipleassignmentsubscription()`- `serialsubscription()`    in case you do feel tempted to call `new subscription{}` directly make sure you wire up `isunsubscribed`  and `unsubscribe()` properly but for all practical purposes you should just use one of the factory methods## notificationsall underlying wrapped `java` types in the `notification` trait are made private like all previous types the companionobjects of `notification` now have both constructor (`apply`) and extractor (`unapply`) functions:``` scalaobject notification {}trait notification[+t] {   override def equals(that: any): boolean  {}   override def hashcode(): int  {}   def apply[r](onnext: t>r onerror: throwable>r oncompleted: ()>r): r  {}}```the nested companion objects of `notification` now have both constructor (`apply`) and extractor (`unapply`) functions:``` scalaobject notification {   object onnext { def apply(){} def unapply(){} }   object onerror { def apply(){} def unapply(){} }   object oncompleted { def apply(){} def unapply(){} }}```to construct a `notification` you import `rxlangscalanotification_` and use `onnext(""""hello"""")`or `onerror(new exception(""""oops!""""))` or `oncompleted()`to pattern match on a notification you create a partial function like so: `case notificationonnext(v) > {  v  }`or you use the `apply` function to pass in functions for each possibilitythere are no breaking changes for notifications## java interop helperssince the scala traits _wrap_ the underlying java types yoo may occasionally will have to wrap an unwrapbetween the two representations the `javaconversion` object provides helper functions of the form `tojavaxxx` and`toscalaxxx` for this purpose properly hiding how precisely the wrapped types are storednote the (un)wrap conversions are defined as implicits in scala but in the unlikely event that you do need thembe kind to the reader of your code and call them explicitly``` scalaobject javaconversions {  import languageimplicitconversions  implicit def tojavanotification[t](s: notification[t]): rxnotification[_ <: t]  {}  implicit def toscalanotification[t](s: rxnotification[_ <: t]): notification[t]  {}  implicit def tojavasubscription(s: subscription): rxsubscription  {}  implicit def toscalasubscription(s: rxsubscription): subscription  {}  implicit def scalaschedulertojavascheduler(s: scheduler): rxscheduler  {}  implicit def javaschedulertoscalascheduler(s: rxscheduler): scheduler  {}  implicit def tojavaobserver[t](s: observer[t]): rxobserver[_ >: t]  {}  implicit def toscalaobserver[t](s: rxobserver[_ >: t]): observer[t]  {}  implicit def tojavaobservable[t](s: observable[t]): rxobservable[_ <: t]  {}  implicit def toscalaobservable[t](observable: rxobservable[_ <: t]): observable[t]  {}}```"";items of discussion or that i would like to resolve before releasing:-  `replaysubject` has a different style from other `subject` implementations im not tied to either approach nor am i sure that the idea of an `abstractsubject` was the right way to go -  im not convinced that `subject` implementations have correct thread-safety or concurrency behavior for example we synchronize on subscriptions but not event emission and im not sure whether that means were vulnerable to losing events or not-  yet more `observeon` fixes/tweaks are needed -  id like to eliminate the `rxutil` dumping ground  -  put exceptions into `rxexceptions` or `rxutilexceptions`?  -  put functions into `rxfunctions` or `rxutilfunctions`?  -  where does range go? timeinterval? timestamped? perhaps in `rxobservables`?  -  why is timestamped not camelcase whereas timeinterval is?-  should abstractsubject be public? i think it should be package private particularly as i dont necessarily agree with the approach (even though i wrote it)-  for consistency should we have `rxoperators` with classes named `operatorxyz` or `rxoperations` and classes named `operationxyz`?-  observerbase needs to be package private or moved into a non-advertised package like `rxoperators` || > why is timestamped not camelcase whereas timeinterval is?because `timestamp` is a single word like `javasqltimestamp`? || observeon fixes:  || > because timestamp is a single word like javasqltimestamp?i guess youre right never mind :-) || ive looked at the `subject` implementations and they seem to be incorrect due to the following reasons:- the `abstractsubject` allows the concurrent execution of onnext and onerror/oncompleted calls ie the emitnotification doesnt lock on `subscription_lock`- `publishsubject` `asyncsubject` and `behaviorsubject` seem to overwrite the last notification value even after the termination condition as the call `statecurrentvalueset(new notification<t>())` is always executed in the subjects onxxx methods regardless of the state new subscribers may observe various states when subscribing || > the abstractsubject allows the concurrent execution of onnext and onerror/oncompleted callsall of rx allows this as it is up to the provider to obey the contract and not call them concurrently that is why we dont  synchronize everything in rx for performance reasons || rx design guideline 68> 68 avoid serializing operators> > as all rx operators are bound to guideline 67 operators can safely assume that their inputs are serialized adding too much synchronization would clutter the code and can lead to performance degradation> > if an observable sequence is not following the rx contract (see chapter 0) it is up to the developer writing the end-user application to fix the observable sequence by calling the synchronize operator at the first place the developer gets a hold of the observable sequence this way the scope of additional synchronization is limited to where it is neededdue to this a `subject` implementation should not need to synchronize `onnext`/`oncompleted`/`onerror` calls they do need to handle `subscribe`/`unsubscribe` concurrent access it is however tricky to achieve both of these since we want to ensure we dont have race-conditions in observers subscribing and seeing the correct view of events that said we dont want to add unnecessary synchronizationfor example on `publishsubject` it is completely fine during a concurrent race between `onnext` and `subscribe` that it may or may not get that `onnext` event thats the nature of concurrently subscribing to a hot `observable` we dont want to pay the overhead of synchronization on `onnext` just so that occasional `subscribe` events can occur || /cc @akarnokd @headinthebox @zsxwing i am ready to release 0160 after running it on a netflix api production canary to assert performance and functionality of the core operators schedulers etc (at least of what we use not new operators)im blocked on a build issue that i cant solve until tomorrow at the office so will release sometime tuesday hopefully ||;1;0;2x: fix singletakeuntil maybetakeuntil dispose behavior;"
"6021;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: single.flatmappublisher full implementation;see discussion in #6015.;;601.0;2x: singleflatmappublisher full implementation;see discussion in #6015resolves: #6015; merging 6021  < ;version 0160 release candidate;""following are the changes and release notes for 0160 since so much has changed for this release i want to give people a chance to review and try the code before releasingchanges:---### version 0160 ([maven central]( [pull 516]( rxjava-string module with stringobservable- [pull 533]( operator: toasync- [pull 535]( fix compilation errors due to referencing the android support library directly- [pull 545](  zip issue with infinite streams- [pull 539]( zipping a finite and an infinite observable- [pull 541]( operator: skipuntil- [pull 537]( add scala adapters for dooneach operator- [pull 560]( add type variances for dooneach actions- [pull 562]( scala adaptor improvements- [pull 563]( operator: groupbyuntil- [pull 561]( revised approach to creating observables in scala- [pull 565]( operator: groupjoin v2- [pull 567]( operator: timestamp with scheduler- [pull 568]( use lock free strategy for several subscription implementations- [pull 571]( operator: sample with observable v2- [pull 572]( multiple subscriptions to observeon- [pull 573]( removed opening and closing historical artifacts- [pull 575]( operator: sequenceequal reimplementation- [pull 587]( operator: longcount- [pull 586]( fix concat to allow multiple observers- [pull 598]( new scala bindings- [pull 596]( fix for buffer not stopping when unsubscribed- [pull 576]( operators: timer and delay- [pull 593]( lock-free subscriptions- [pull 599]( refactor rxconcurrency to rxschedulers- [pull 600]( bugfix: replay subject- [pull 594]( operator: start- [pull 604]( stringobservablejoin- [pull 609]( operation: timer- [pull 612]( operation: replay (overloads)- [pull 628]( bugfix: mergedelayerror synchronization- [pull 602]( bugfix: observeon subscription leak- [pull 631]( make newthreadscheduler create daemon threads- [pull 651]( subjects refactor - non-blocking common abstraction performance- [pull 661]( subscriptions rewrite- [pull 520]( bugfix: blocking/non-blocking `first`- [pull 621]( scala: serialsubscription & from- [pull 626]( bolatest fixed: bonext bomostrecent botoiterable- [pull 633]( bugfix: null in tolist operator- [pull 635]( conditional operators- [pull 638]( operations: delaysubscription takelast w/ time takelastbuffer- [pull 659]( missing fixes from the subject rewrite- [pull 688]( fix safeobserver handling of oncomplete errors- [pull 690]( fixed scala bindings- [pull 693]( kotlin m62- [pull 689]( removed observerbase- [pull 664]( operation: asobservable- [pull 697]( operations: skip skiplast take with time- [pull 698]( operations: average sum- [pull 699]( operation: repeat- [pull 701]( operation: collect- [pull 707]( module: rxjava-async-util- [pull 708]( bugfix: combinelatest- [pull 712]( fix scheduler memory leaks- [pull 714]( module: rxjava-computation-expressions- [pull 715]( add missing type hint to clojure example- [pull 717]( scala: added connectableobservable- [pull 723]( deprecate multiple arity from- [pull 724]( revert use of currentthreadscheduler for observablefrom- [pull 725]( simpler computation/io naming for schedulers- [pull 727]( immediatescheduler optimization for toobservableiterable---- this release includes breaking changes to scala bindings details are below- the `rxconcurrency` package has been renamed to `rxschedulers` existing classes still remain in `rxconcurrency` but are deprecated use of `rxconcurrency` should be migrated to `rxschedulers` as these deprecated classes will be removed in a future release- refactor of subjects and subscriptions to non-blocking implementations- many bug fixes new operators and behavior changes to match rxnet- deprecation of some operators due to renaming or eliminating duplicates- new modules: rxjava-string rxjava-async-util and rxjava-computation-expressions for operators deemed not applicable to the core library---### scala release notes---this release of the rxscala bindings builds on the previous 015 release to make the rx bindings for scalainclude all rx types in particular this release focuses on fleshing out the bindings for the `subject` and `scheduler`types as well as aligning the constructor functions for `observable` with those in the rxjavaexpect to see ongoing additions to make the scala binding match the equivalent underlying java apias well as minor changes in the existing api as we keep fine-tuning the experience on our way to a v10 release## observerin this release we have made the `asjavaobserver` property in `observable[t]`as well the the factory method in thecompanion object that takes an `rxobserver` private to the scala bindings package thus properly hiding irrelevantimplementation details from the user-facing api the `observer[t]` trait now looks like a clean native scala type:``` scalatrait observer[-t] {  def onnext(value: t): unit  def onerror(error: throwable): unit  def oncompleted(): unit}object observer {}```to create an instance of a specific `observer` say  `observer[sensorevent]` in user code you can create a new instanceof the `observer` trait by implementing any of the methods that you care about:``` scala   val printobserver  new observer[sensorevent] {      override def onnext(value: sensorevent): unit  {valuetostring}   }``` or you can use one of the overloads of the companion `observer` object by passing in implementations of the `onnext` `onerror` or `oncompleted` methodsnote that typically you do not need to create an `observer` since all of the methods that accept an `observer[t]`(for instance `subscribe`) usually come with overloads that accept the individual methods`onnext` `onerror` and `oncompleted` and will automatically create an `observer` for you under the coverswhile _technically_ it is a breaking change make the `asjavaobserver` property private you should probably not havetouched `asjavaobserver` in the first place if you really feel you need to access the underlying `rxobserver`call `tojava`## observablejust like for `observer` the `observable` trait now also hides its `asjavaobservable` property and makes the constructorfunction in the companion object that takes an `rxobservable` private (but leaves the companion object itself public)again while _technically_ this is a breaking change this should not have any influence on user code``` scalatrait observable[+t] {    def subscribe(observer: observer[t]): subscription  {}    def apply(observer: observer[t]): subscription  {}    }object observable {   def create[t](func: observer[t] > subscription): observable[t]  {}   }```the major changes in `observable` are wrt to the factory methods where too libral use of overloading of the `apply`method hindered type inference and made scala code look unnecessarily different than that in other language bindingsall factory methods now have their own name corresponding to the java and net operators(plus overloads that take a `scheduler`)- `def from[t](future: future[t]): observable[t]`- `def from[t](iterable: iterable[t]): observable[t]`- `def error[t](exception: throwable): observable[t]`- `def empty[t]: observable[t]`- `def items[t](items: t*): observable[t]- extension method on `toobservable: observable[t]` on `list[t]`in the _pre-release_ of this version we expose both `apply` and `create` for the mother of all creation functionswe would like to solicit feedback which of these two names is preferred(or both but there is a high probability that only one will be chosen)- `def apply[t](subscribe: observer[t]>subscription): observable[t]`- `def create[t](subscribe: observer[t] > subscription): observable[t]`## subjectthe `subject` trait now also hides the underlying java `asjavasubject: rxsubjectssubject[_ >: t _<: t]`and takes only a single _invariant_ type parameter `t` all existing implementations of `subject` are parametrizedby a single type and this reflects that reality``` scalatrait subject[t] extends observable[t] with observer[t] {}object subject {   def apply(): subject[t]  {}}```for each kind of subject there is a class with a private constructor and a companion object that you should useto create a new kind of subject the subjects that are available are:- `asyncsubject[t]()`- `behaviorsubject[t](value)`- `subject[t]()`- `replaysubject[t]()`the latter is still missing various overloads  whichyou can expect to appear once they are added to the underlying rxjava implementationcompared with release 0151 the breaking changes in `subject` for this release aremaking `asjavasubject` private and collapsing its type parameters neither of these should cause troubleand renaming `publishsubject` to `subject`## schedulersthe biggest breaking change compared to the 0151 release is giving `scheduler` the same structure as the other typesthe trait itself remains unchanged except that we made the underlying java representation hidden as aboveas part of this reshuffling the scheduler package has been renamed from `rxlangscalaconcurrency`to `rxlangscalaschedulers` there is a high probability that this package renaming will also happen in rxjava``` scalatrait scheduler {}```in the previous release you created schedulers by selecting them from the `schedulers` objectas in `schedulersimmediate` or `schedulersnewthread` where each would return an instance of the `scheduler` traithowever several of the scheduler implementations have additional methods such as the `testscheduler`which already deviated from the patternin this release we changed this to make scheduler more like `subject` and provide a family of schedulersthat you create using their factory function:- `currentthreadscheduler()`- `executorscheduler(executor)`- `immediatescheduler()`- `newthreadscheduler()`- `scheduledexecutorservicescheduler(scheduledexecutorservice)`- `testscheduler()`- `threadpoolforcomputationscheduler()`- `threadpoolforioscheduler()`in the future we expect that this list will grow further with new schedulers as they are imported from net( make your code compile in the new release you will have to change all occurrences of `schedulersxxx`into `xxxscheduler()` and import `rxlangscalaschedulers` instead of `rxlangscalaschedulers`## subscriptionsthe `subscription` trait in scala now has `isunsubscribed` as a member effectively collapsing the old `subscription`and `booleansubscription` and the latter has been removed from the public surface pending a bug fix in rxjava`serialsubscription` implements its own `isunsubscribed```` scalatrait subscription {  def unsubscribe(): unit  {  }  def isunsubscribed: boolean  }object subscription {}``` to create a `subscription` use one of the following factory methods:- `subscription{}` `subscription()`- `compositesubscription(subscriptions)`- `multipleassignmentsubscription()`- `serialsubscription()`    in case you do feel tempted to call `new subscription{}` directly make sure you wire up `isunsubscribed`  and `unsubscribe()` properly but for all practical purposes you should just use one of the factory methods## notificationsall underlying wrapped `java` types in the `notification` trait are made private like all previous types the companionobjects of `notification` now have both constructor (`apply`) and extractor (`unapply`) functions:``` scalaobject notification {}trait notification[+t] {   override def equals(that: any): boolean  {}   override def hashcode(): int  {}   def apply[r](onnext: t>r onerror: throwable>r oncompleted: ()>r): r  {}}```the nested companion objects of `notification` now have both constructor (`apply`) and extractor (`unapply`) functions:``` scalaobject notification {   object onnext { def apply(){} def unapply(){} }   object onerror { def apply(){} def unapply(){} }   object oncompleted { def apply(){} def unapply(){} }}```to construct a `notification` you import `rxlangscalanotification_` and use `onnext(""""hello"""")`or `onerror(new exception(""""oops!""""))` or `oncompleted()`to pattern match on a notification you create a partial function like so: `case notificationonnext(v) > {  v  }`or you use the `apply` function to pass in functions for each possibilitythere are no breaking changes for notifications## java interop helperssince the scala traits _wrap_ the underlying java types yoo may occasionally will have to wrap an unwrapbetween the two representations the `javaconversion` object provides helper functions of the form `tojavaxxx` and`toscalaxxx` for this purpose properly hiding how precisely the wrapped types are storednote the (un)wrap conversions are defined as implicits in scala but in the unlikely event that you do need thembe kind to the reader of your code and call them explicitly``` scalaobject javaconversions {  import languageimplicitconversions  implicit def tojavanotification[t](s: notification[t]): rxnotification[_ <: t]  {}  implicit def toscalanotification[t](s: rxnotification[_ <: t]): notification[t]  {}  implicit def tojavasubscription(s: subscription): rxsubscription  {}  implicit def toscalasubscription(s: rxsubscription): subscription  {}  implicit def scalaschedulertojavascheduler(s: scheduler): rxscheduler  {}  implicit def javaschedulertoscalascheduler(s: rxscheduler): scheduler  {}  implicit def tojavaobserver[t](s: observer[t]): rxobserver[_ >: t]  {}  implicit def toscalaobserver[t](s: rxobserver[_ >: t]): observer[t]  {}  implicit def tojavaobservable[t](s: observable[t]): rxobservable[_ <: t]  {}  implicit def toscalaobservable[t](observable: rxobservable[_ <: t]): observable[t]  {}}```"";items of discussion or that i would like to resolve before releasing:-  `replaysubject` has a different style from other `subject` implementations im not tied to either approach nor am i sure that the idea of an `abstractsubject` was the right way to go -  im not convinced that `subject` implementations have correct thread-safety or concurrency behavior for example we synchronize on subscriptions but not event emission and im not sure whether that means were vulnerable to losing events or not-  yet more `observeon` fixes/tweaks are needed -  id like to eliminate the `rxutil` dumping ground  -  put exceptions into `rxexceptions` or `rxutilexceptions`?  -  put functions into `rxfunctions` or `rxutilfunctions`?  -  where does range go? timeinterval? timestamped? perhaps in `rxobservables`?  -  why is timestamped not camelcase whereas timeinterval is?-  should abstractsubject be public? i think it should be package private particularly as i dont necessarily agree with the approach (even though i wrote it)-  for consistency should we have `rxoperators` with classes named `operatorxyz` or `rxoperations` and classes named `operationxyz`?-  observerbase needs to be package private or moved into a non-advertised package like `rxoperators` || > why is timestamped not camelcase whereas timeinterval is?because `timestamp` is a single word like `javasqltimestamp`? || observeon fixes:  || > because timestamp is a single word like javasqltimestamp?i guess youre right never mind :-) || ive looked at the `subject` implementations and they seem to be incorrect due to the following reasons:- the `abstractsubject` allows the concurrent execution of onnext and onerror/oncompleted calls ie the emitnotification doesnt lock on `subscription_lock`- `publishsubject` `asyncsubject` and `behaviorsubject` seem to overwrite the last notification value even after the termination condition as the call `statecurrentvalueset(new notification<t>())` is always executed in the subjects onxxx methods regardless of the state new subscribers may observe various states when subscribing || > the abstractsubject allows the concurrent execution of onnext and onerror/oncompleted callsall of rx allows this as it is up to the provider to obey the contract and not call them concurrently that is why we dont  synchronize everything in rx for performance reasons || rx design guideline 68> 68 avoid serializing operators> > as all rx operators are bound to guideline 67 operators can safely assume that their inputs are serialized adding too much synchronization would clutter the code and can lead to performance degradation> > if an observable sequence is not following the rx contract (see chapter 0) it is up to the developer writing the end-user application to fix the observable sequence by calling the synchronize operator at the first place the developer gets a hold of the observable sequence this way the scope of additional synchronization is limited to where it is neededdue to this a `subject` implementation should not need to synchronize `onnext`/`oncompleted`/`onerror` calls they do need to handle `subscribe`/`unsubscribe` concurrent access it is however tricky to achieve both of these since we want to ensure we dont have race-conditions in observers subscribing and seeing the correct view of events that said we dont want to add unnecessary synchronizationfor example on `publishsubject` it is completely fine during a concurrent race between `onnext` and `subscribe` that it may or may not get that `onnext` event thats the nature of concurrently subscribing to a hot `observable` we dont want to pay the overhead of synchronization on `onnext` just so that occasional `subscribe` events can occur || /cc @akarnokd @headinthebox @zsxwing i am ready to release 0160 after running it on a netflix api production canary to assert performance and functionality of the core operators schedulers etc (at least of what we use not new operators)im blocked on a build issue that i cant solve until tomorrow at the office so will release sometime tuesday hopefully ||;1;0;2x: add full implementation for singleflatmappublisher so doesnt batch requests (#6015);"
6021;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: single.flatmappublisher full implementation;see discussion in #6015.;;6015.0;2x: singleflatmappublisher full implementation;see discussion in #6015resolves: #6015; merging 6021  < ;singleflatmappublisher full implementation;i noticed `singleflatmappublisher` is implemented as `toflowable()flatmappublisher()` which subjects the one flowable to batched requests id like to have requests go straight through to the one flowable can i contribute this operator?the operator at the moment is at  without fusion i can add more tests fusion (transitive as per `dooneach`) and follow the projectss naming and visibility conventions;sure || in case you havent started yet you may want to wait for #6017 so the changes can be benchmarked || thats brilliant  a question about fusion i notice that `timeout(long timeunit)` doesnt support fusion and i suspect the operator im writing is similar the problem is that a subscription is handed to downstream while the single emission is being calculated and the resultant mapped flowable is unknown just after the subscription is handed to downstream (via `onsubscribe`) `requestfusion` is called but of course at that point the fusion characteristics of the mapped flowable is unknown and `queuefuseablenone` is returned should i chase fusion for this operator? any suggestions?  || fusion wont work here due to the delayed subscription to the flowable dont bother with it || righto ta ||;1;0;2x: add full implementation for singleflatmappublisher so doesnt batch requests (#6015);
6022;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add tck for multicastprocessor & {0..1}.flatmappublisher;this pr adds reactive streams tck tests to:;;0;2x: add tck for multicastprocessor & {01}flatmappublisher;this pr adds reactive streams tck tests to:- `multicastprocessor` (both externally and internally refcounted`- `singleflatmappublisher`- `maybeflatmappublisher`- `completableandthen(publisher)`; merging 6022 ;;;;1;1;2x: add tck for multicastprocessor & {01}flatmappublisher;
6023;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: more time to behaviorprocessor & interval tck tests;this pr increases the timeout of the reactive streams tck tests targeting  behaviorprocessor  and  interval()  from 25ms to 50ms to have some slack on travis-ci.;;0;2x: more time to behaviorprocessor & interval tck tests;this pr increases the timeout of the reactive streams tck tests targeting `behaviorprocessor` and `interval()` from 25ms to 50ms to have some slack on travis-ci; merging 6023 ;;;;1;1;2x: more time to behaviorprocessor & interval tck tests;
6024;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: dedicated {single|maybe}.flatmap{publisher|observable} & andthen(observable|publisher) implementations;this pr implements the following operators directly instead of conversions between base types:;;0;2x: dedicated {single|maybe}flatmap{publisher|observable} & andthen(observable|publisher) implementations;this pr implements the following operators directly instead of conversions between base types:- `singleflatmapobservable`- `maybeflatmapobservable`- `maybeflatmappublisher`- `completableandthen(observable)`- `completableandthen(publisher)`the `singleflatmappublisher` was reimplemented in #6021 already;benchmark comparison with baseline: (i7 4770k windows 7 x64 java 8u172 jmh 120):( that 3 cases with slightly degraded throughput (probably windows related) these are nice improvementscomparing `maybe` and `single` flattening:![image]( should be practically the same there is also a slight performance drop for `count1 flatmaphide publisher` which is likely due to the backpressure inside `flowablejust()` ||  merging 6024  < ;;;;1;1;fix local variable name;
6026;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;fix flowable.blockingsubscribe is unbounded and can lead to oome;create and bound new  blockingsubscribe  overloads to  buffersize .;;5988.0;fix flowableblockingsubscribe is unbounded and can lead to oome;create and bound new `blockingsubscribe` overloads to `buffersize`* create new overloads with `buffersize`* create a `boundedconsumer`* create a `boundedsubsciber`close: #5988; merging 6026 ;2x: flowableblockingsubscribe(lambdas) is unbounded and can lead to oome;i cant remember why but `flowableblockingsubscribe(consumer)` uses unbounded requests which can lead to `outofmemoryerror` in both synchronous and asynchronous scenariosthe problem was raised in [this stackoverflow question]( and apart from the obvious solutions having such unbounded operator over an asynchronous boundary can be a problem regardlesspossible resolutions:- **behavior change**: bound it to `buffersize()` in 2x- (and/or) introduce overload(s) with `prefetch` but leave the existing ones unboundedalternatively this could be deferred until 3x without worrying of the behavior change;`flowableblockingsubscribe(consumer)` is using `functionsmaxrequestsubscription()` which could lead to `outofmemoryerror` is it the issue?in that case i suggest to:* keep existing `flowableblockingsubscribe(consumer)` unbounded* deprecate existing `flowableblockingsubscribe(consumer)`* introduce new overloads with `buffersize()` and `prefetch`wdyt? can i work on this? || create a new overload:`blockingsubscribe(consumer<? super t> onnext consumer<? super throwable> onerror action oncomplete int buffersize)`have a dedicated implementation servicing it and leave the other overloads unbounded ||;1;0;fix flowableblockingsubscribe is unbounded and can lead to oome;
6028;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: improve observable.takeuntil;this pr upgrades the  observable.takeuntil  to a newer algorithm (the  flowable  version is up-to-date).;;0;2x: improve observabletakeuntil;this pr upgrades the `observabletakeuntil` to a newer algorithm (the `flowable` version is up-to-date)some unit test remnants from the v1 era were upgraded too as the new algorithm no longer disposes the source or other if they terminate on their own (the reactive streams specification doesnt allow that anyway); || algorithm of the operator itself seems unchanged only event serialization and disposing is different right?i assume `halfserializer` is faster than `serializedobserver` because its non-blocking but if you happen to have benchmark results id be happy to check them out :) (i might need something like this in [domic]( anyway  pr state is stuck ill close & reopen this ||  merging 6028 ;;;;1;1;2x: improve observabletakeuntil;
6029;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: upgrade to gradle 4.3.1  add takeuntilperf;the jmh plugin 0.4.4 has some shortcomings that prevent the execution of unit tests on windows 10 (and on some very restricted linuxes). version 0.4.5 has been fixed in this regard but it also requires gradle 4.3.x. unfortunately  there are no newer versions to the jmh plugin so this is likely as far as we can go with versions.;;0;2x: upgrade to gradle 431 add takeuntilperf;the jmh plugin 044 has some shortcomings that prevent the execution of unit tests on windows 10 (and on some very restricted linuxes) version 045 has been  in this regard but it also requires gradle 43x unfortunately there are no newer versions to the jmh plugin so this is likely as far as we can go with versionsive also added a new benchmark to measure the overhead in `takeuntil` here are the results:i7 4790 windows 10 x64 java 8u172 jmh 120:```benchmark                        mode  cnt         score       error  unitstakeuntilperfflowable          thrpt    5    341933112   13328573  ops/stakeuntilperfflowable:items    thrpt    5  21128765548  677544832  ops/stakeuntilperfobservable        thrpt    5    366931108    8202644  ops/stakeuntilperfobservable:items  thrpt    5  10733841643  112853358  ops/s```the `observable` here uses an older algorithms & structure and is generally relaying half the items under the same time amonut than the `flowable` version pr #6028  can then be evaluated with this benchmark; merging 6029 ;;;;1;1;2x: upgrade to gradle 431 add takeuntilperf;
6030;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix multicastprocessor javadoc warnings;add two missing  &gt   tags to avoid the javadoc tool warnings.;;0;2x: fix multicastprocessor javadoc warnings;add two missing `&gt` tags to avoid the javadoc tool warnings; merging 6030 ;;;;1;1;2x: fix multicastprocessor javadoc warnings;
6031;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: inline compositedisposable javadoc;normally  overriding a method will reuse the javadoc unless specified directly on the new method. unfortunately  when the base type is part of a javadoc exclude  such as everything below  **/internal   the documentation is not copied and public facing methods have no html documentation:;;0;2x: inline compositedisposable javadoc;normally overriding a method will reuse the javadoc unless specified directly on the new method unfortunately when the base type is part of a javadoc exclude such as everything below `**/internal` the documentation is not copied and public facing methods have no html documentation:( pr copies the javadoc of the internal `disposablecontainer` onto `compositedisposable` so it shows up properly:![image]( ides still show the documentation correctly; merging 6031 ;;;;1;1;2x: inline compositedisposable javadoc;
"6036;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix disposed lambdaobserver onerror to route to global error handler;fix the behaviour of lambdaobserver when disposed to route to the global error handler;;6025.0;2x: fix disposed lambdaobserver onerror to route to global error handler;fix the behaviour of lambdaobserver when disposed to route to the global error handler6025; merging 6036 ;2x: error handling - exception swallowed after explicit dispose();""library verision : 217the following code will silently swallow thrown exception without signalling to rxplugins ```        val subject  publishsubjectcreate<unit>()        var disposable: disposable?  null        disposable  subjectsubscribe(                {                    disposable?dispose()                    throw exception(""""test"""")                }        )        subjectonnext(unit)```the same applies to behavioursubject *processor but not singlesubject or observablejust (range etc ) though sections about error handling are almost equal in [publishsubject]( and [singlesubject]( reason seems to be located in [lambdaobserver]( which doesnt signal onerror if is disposed alreadyis it expected behaviour?"";indeed it does not the tradeoff here is that your code explicitly indicated it doesnt want to handle further events yet there would be no opportunity to have `onerror` not signal to the global error handlerim open for discussion || as for me the exception should still be thrown somewhere as the code is still executed and doing something wrong so if `dispose()` is requested and `onerror` can not be called - it seems to me that this corresponds 2x error handling philosophy when the error falls directly into global handler || well other implementations do route to the global error handler so for the sake of consistency this should be  pr welcome ||;1;0;2x: fix disposed lambdaobserver onerror to route to global error handler;"
6042;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix multicastprocessor javadoc comment;fix wrong javadoc comment of multicastprocessor.;;0;fix multicastprocessor javadoc comment;fix wrong javadoc comment of multicastprocessor i think `#create(boolean)` is an optional refcount behavior; merging 6042 ;;;;1;1;fix multicastprocessor javadoc comment;
6045;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix check that would always be false;checking  blockingsubscriber.terminated  ( new object() ) against  o  would always be false since  o  is a publisher. since  v  comes from the queue this is presumably the variable that should be checked.;;0;fix check that would always be false;checking `blockingsubscriberterminated` (`new object()`) against `o` would always be false since `o` is a publisher since `v` comes from the queue this is presumably the variable that should be checkedhowever the check might even be redundant with this change since that variable can only appear in the queue after the subscriber has been cancelled i am not familiar enough with the memory model to say whether the object appearing in the queue implies the cancelled subscriber is visible; merging 6045 ;;;;1;1;fix check that would always be falsechecking `blockingsubscriberterminated` (`new object()`) against `o` would always be false since `o` is a publisher since `v` comes from the queue this is presumably the variable that should be checkedhowever the check might even be redundant with this change since that variable can only appear in the queue after the subscriber has been cancelled i am not familiar enough with the memory model to say whether the object appearing in the queue implies the cancelled subscriber is visible;
"6049;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;make it explicit that throttlewithtimout is an alias of debounce;the documentation implies that these two methods are somewhat different. fixing that confusion  as discussed in #6043:;;6043.0;make it explicit that throttlewithtimout is an alias of debounce;the documentation implies that these two methods are somewhat different fixing that confusion as discussed in #6043:- made the descriptions of these methods the same- mentioned that it is an alias in the first paragraphs of `throttlewithtimeout` javadoc comments- removed the links to third-party websites;build warnings: please avoid dangling `<p>` tags:  ||  merging 6049 ;2x: observablethrottlewithtimeout is confusing;""the documentation for `observablethrottlewithtimeout()` implies that its different from `debounce()` and invites to read about the differences:> information on debounce vs throttle:> <a href"""" and throttle: visual explanation</a></li>> <a href"""" javascript methods</a></li>> <a href"""" - dont spam your server: debounce and throttle</a></li>of these links the first one isnt available anymore and the last two are about jslooking at the methods implementation it becomes clear that in rxjava its not different from `debounce` in any way:```java@checkreturnvalue@schedulersupport(schedulersupportcomputation)public final observable<t> throttlewithtimeout(long timeout timeunit unit) {    return debounce(timeout unit)}```do we really need both methods? if yes could the documentation say explicitly that they are synonyms? could these links to third-party websites be removed?"";yes it is an alias so it can be more easily discovered along the `throttle` methods `debounce` is a traditional reactivex naming and we kept it for historical reasonsyou can update the javadocs (on both `flowable` and `observable` if you want pr welcome || @akarnokd thanks for the clarification will open a pr soon :) || closing via #6049 ||;1;0; marble images;"
6052;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;#5980 made subscribeactual protected;### proposal;;5980.0;#5980 made subscribeactual protected;### proposalchanged `subscribeactual` from `public` to `protected` as described in #5980### how i testedran tests locally please let me know if i missed part of the contributing guidelines  fixes: #5980;/cc @vanniktech @artem-zinnatullin @davidmoten strictly speaking this is technically a breaking change on something that shouldnt be in use at all by external developers im fine with this change for 2115 ||  merging 6052 ;2x: subscribeactual() accidental public;looks like the following `protected void subscribeactual()` implementations have unintentionally become public:- [`publishsubject`]( [`publishprocessor`]( is no reason to call `subscribeactual` from outside of rxjava however making these `protected` counts as a breaking change however it should be extremely unlikey somebody was actually using these methods directythe question is: do we take the risk and fix the visibility in 2x or it has to wait for 3x?note that many operators are also having this method as public but those are not really accessible from the outside;in this case id consider making the fix with version 22 || i dont know if this is still relevant but i opened a pr for it let me know if it helps ||;1;0;#5980 made subscribeactual protected;
6053;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add maybe marble diagrams 06/21/a;resolved the following diagrams of #5806:;;5806.0;2x: add maybe marble diagrams 06/21/a;resolved the following diagrams of #5806:#### amb: missing diagram( ambarray: missing diagram![image]( concat(iterable): missing diagram![image]( concat(publisher): missing diagram![image]( concat(publisher int): missing diagram![image]( concatarray: missing diagram![image]( concatarraydelayerror: indicate error delayed 1 marble per source![image]( concatarrayeager: missing diagram![image]( concatdelayerror(iterable): missing diagram![image]( concatdelayerror(publisher): missing diagram![image]( concateager(iterable): missing diagram![image]( concateager(publisher): missing diagram![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeconcateagerppng); merging 6053 ;3x: maybe incorrect or missing marbles (tracking issue);-  `amb`: missing diagram-  `ambarray`: missing diagram-  `concat(iterable)`: missing diagram-  `concat(publisher)`: missing diagram-  `concat(publisher int)`: missing diagram-  `concatarray`: missing diagram-  `concatarraydelayerror`: indicate error delayed 1 marble per source-  `concatarrayeager`: missing diagram-  `concatdelayerror(iterable)`: missing diagram-  `concatdelayerror(publisher)`: missing diagram- [x] `concatdelayerror(publisher int)`: fix overlap/misalignment inside the operator box- [x] `concateager(iterable)`: missing diagram- [x] `concateager(publisher)`: missing diagram- [x] `create`: missing diagram- [x] `defer`: missing diagram- [x] `error(callable)`: indicate callable returns the error- [x] `fromaction`: missing diagram- [x] `fromcompletable`: missing diagram- [x] `fromsingle`: missing diagram- [x] `fromcallable`: missing diagram- [x] `fromfuture(future)`: operator name in the box indicate future is the parameter- [x] `fromfuture(future long timeunit)`: operator name in the box indicate future is the parameter indicate timeout- [x] `fromrunnable`: missing diagram- [x] `merge(iterable)`: missing diagram- [x] `merge(publisher)`: missing diagram- [x] `merge(publisher int)`: missing diagram- [x] `mergearray`: missing diagram- [x] `mergearraydelayerror`: one marble per maybe source- [x] `mergedelayerror(iterable)`: one marble per maybe source- [x] `mergedelayerror(publisher)`: one marble per maybe source- [x] `mergedelayerror(maybe maybe )`: one marble per maybe source- [x] `sequenceequal` + 1: result should be `single`- [x] `timer` + 1: result should be maybe- [x] `using` + 1: rework to indicate the created maybe- [x] `wrap`: missing marble- [x] `zip(iterable)`: one marble per maybe source result should be maybe- [x] `zip(maybe maybe )` + 8: one marble per maybe source result should be maybe- [x] `ziparray`: one marble per maybe source result should be maybe- [x] `ambwith`: one marble per maybe source result should be maybe- [x] ~~`as`: missing diagram~~ operator removed- [x] `blockingget` + 1: missing diagram- [x] `cache`: one marble per maybe source result should be maybe- [x] `cast`: missing diagram- [x] `compose`: missing diagram- [x] `concatmap`: indicate maybe target indicate empty source- [x] `concatwith`: one marble per maybe source result should be maybe operator name indicate other is a parameter- [x] `contains`: one marble per maybe source result should be single empty case- [x] `count`: one marble per maybe operator name result should be single empty case- [x] `defaultifempty`: non-empty case result should be maybe- [x] `delay(time)` + 3: one marble per maybe source result should be maybe- [x] `delay(publisher)`: one marble per maybe one signal by the publisher empty publisher case- [x] `delaysubscription(publisher)`: missing diagram- [x] `delaysubscription(time)` + 1: one marble per maybe source result should be maybe- [x] `doaftersuccess`: missing diagram- [x] `doafterterminate`: operator name one marble per maybe result should be maybe- [x] `dofinally`: missing diagram- [x] `doondispose`: missing diagram- [x] `dooncomplete`: one marble per maybe result should be maybe- [x] `doonerror`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonsubscribe`: missing diagram- [x] `doonsuccess`: missing diagram- [x] `doonterminate`: one marble per maybe result should be maybe- [x] `filter`: one marble per maybe result should be maybe- [x] `flatmap(function function callable)`: one marble per maybe result should be maybe- [x] `flatmap(function bifunction)`: one marble per maybe result should be maybe- [x] `flatmapobservable`: should be mapped into an observable- [x] `flatmappublisher`: indicate backpressure- [x] `flatmapsingle`: indicate empty maybe results in error- [x] `flatmapsingleelement`: operator name indicate empty maybe- [x] `flatmapcompletable`: indicate empty maybe- [x] `hide`: missing diagram- [x] `ignoreelement`: operator name one marble per maybe result should be maybe- [x] `isempty`: result should be single- [x] `mergewith`: operator name one marble per maybe indicate backpressure- [x] `oftype`: one marble per maybe- [x] `onerrorcomplete` + 1: missing diagram- [x] `onerrorresumenext`: one marble per maybe result should be maybe- [x] `onerrorresumewith`: one marble per maybe result should be maybe- [x] `onerrorreturn`: one marble per maybe result should be maybe indicate callback- [x] `onerrorreturnitem`: operator name one marble per maybe result should be maybe indicate normal outcome- [x] ~~`onexceptionresumenext`: operator takes a maybe source directly~~ operator removed- [x] `onterminatedetach`: missing diagram- [x] `repeat` + 1: one marble per source indicate backpressure indicate repeat conditions- [x] `repeatuntil`: operator name repeat condition indicate backpressure- [x] `repeatwhen`: one marble per maybe indicate backpressure- [x] `retry` + 2: one marble per maybe result should be maybe indicate repeat conditions- [x] `retry(int predicate)`: missing diagram- [x] `retry(predicate)`: missing diagram- [x] `retryuntil`: missing diagram- [x] `retrywhen`: one marble per maybe output should be maybe- [x] `switchifempty` + 1: improve diagrams indicate argument type- [x] `takeuntil` + 1: one marble per maybe output should be maybe- [x] `timeout` + 3: one marble per maybe output should be maybe- [x] `timeout(maybesource)`: missing diagram- [x] `timeout(maybesource maybesource)`: missing diagram- [x] `timeout(publisher)`: missing diagram- [x] `timeout(publisher maybesource)`: missing diagram- [x] `to`: missing diagram- [x] `toflowable`: missing diagram- [x] `toobservable`: missing diagram- [x] `tosingle` + 1: missing diagram- [x] `unsubscribeon`: missing diagram- [x] `zipwith`: one marble per maybe output should be maybe;here is the excel file i draw the diagrams in:  ||;1;0;2x: add maybe marble diagrams 06/21/a;
6054;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: expand {x}processor javadocs by syncing with {x}subject docs;this pr expands and adapts the javadocs of  asyncprocessor    behaviorprocessor    publishprocessor    replayprocessor  and  unicastprocessor  with the details of their already documented  subject  variants.;;0;2x: expand {x}processor javadocs by syncing with {x}subject docs;this pr expands and adapts the javadocs of `asyncprocessor` `behaviorprocessor` `publishprocessor` `replayprocessor` and `unicastprocessor` with the details of their already documented `subject` variantsin addition some wording has been  with `unicastsubject` as it was refering to plural `observer`s in some sentences even though it only supports onesince the basis of this expansion is copy-paste please read through the changes carefully to verify the terminology and described behavior matches whats usually expected from `flowable`s/`flowableprocessor`s (ie subjects dont have to deal with backpressure and thus nothing much to elaborate on that in a subject doc); merging 6054  < ;;;;1;1;fix javadoc warnings;
6057;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: use different wording on blockingforeach() javadocs;change the wording on the  blockingforeach()  method to clarify it runs the  consumer  on the current thread. since there is no onerror callback  the extra sentence about the error behavior was removed. there is an error handling section already that explains it properly.;;0;2x: use different wording on blockingforeach() javadocs;change the wording on the `blockingforeach()` method to clarify it runs the `consumer` on the current thread since there is no onerror callback the extra sentence about the error behavior was removed there is an error handling section already that explains it properly; merging 6057 ;;;;1;1;2x: use different wording on blockingforeach() javadocs;
"6060;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix concatmap{single|maybe} null emission on dispose race;this pr fixes a bug in all 4 specialized  concatmap  implementation that allows  null  to be emitted when the success signal of the inner source races with the dispose signal of the sequence.;;605.0;2x: fix concatmap{single|maybe} null emission on dispose race;this pr fixes a bug in all 4 specialized `concatmap` implementation that allows `null` to be emitted when the success signal of the inner source races with the dispose signal of the sequencelikely fixes: #6059;a very similar thing happened in #5927 just after a release but this bug was there between 2111 and 2114  ||  merging 6060 ;subjects reimplemented;reimplemented all 4 kinds of subjects with the following properties:- the `onnext` `onerror` and `oncompleted` are fully thread safe against subscription and unsubscription- a terminated subject wont accept any new events `asyncsubject` `publishsubject` and `behaviorsubject` will re-emit just the very first exception when an observer subscribes to them- emitting events to subscribed observers is done while holding the state lock   - in rxnet when an event is received the list of observers is retrieved while holding the lock then outside the lock the list is traversed and the events are propagated to the observers note however if an observer unsubscribes right after the unlock and before the event propagation it will still appear in the list and will receive the event imo this is an undesired behavior  - the drawback of my solution is that it might be possible to deadlock the subjects ie when an observer deliberately passes the source subject to another thread (which sends an event to the subject) and waits for its completion- added the `notificationacceptsafe` which will capture the exception of the `onnext` and propagate it through the `onerror` its return value indicates if the observer can still be used after (ie no terminal event was delivered)- added the reusable state classes to `abstractsubject` although none of the subjects use this class any more- there is an `unsubscribetester` class which seems to be out-of-place can this be moved into the test directory?;""#542  holding the lock while dispatching events (ie executing arbitrary code) seems pretty dangerous in my experience ive always ended up regretting it when i did this || """" in rxnet when an event is received the list of observers is retrieved while holding the lock then outside the lock the list is traversed and the events are propagated to the observers note however if an observer unsubscribes right after the unlock and before the event propagation it will still appear in the list and will receive the event imo this is an undesired behavior """"unsubscribing does a """"best effort"""" dont hold the lock || @akarnokd thanks for this  @headinthebox and i are reviewing and will end up with some merged/refactored form so this specific pr wont be  no problem || based on this discussion ive tried my hand in pull request  appreciate your review || sure || closing as we ended up doing this in  you very much for the work on this and the significant performance gains you helped achieve! || "";1;0;2x: fix concatmap{single|maybe} null emission on dispose race;"
6066;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix links for single class;* change observable.html to single.html;;0;fix links for single class;* change observablehtml to singlehtml* delete completablehtml link which doesnt exist; merging 6066 ;;;;1;1;fix links for single class* change observablehtml to singlehtml* delete completablehtml link which doesnt exist;
6074;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add marble diagram to the single.never method;first of all  i m extremely grateful to open my first pr for rxjava. i hope that i ll be able to tick more of the marbles from #5788 but for now this should tick off the  never  operator.;;5788.0;add marble diagram to the singlenever method;first of all im extremely grateful to open my first pr for rxjava i hope that ill be able to tick more of the marbles from #5788 but for now this should tick off the `never` operatorplease let me know if i need to change anything on the diagram itself if not please send me url when you upload image within the project so i can change url for the marble in the pr; merging 6074 ;3x: single incorrect or missing images (tracking issue);-  `amb`: missing diagram-  `ambarray`: missing diagram-  `concat(arg)`: missing diagram-  `concat(s1s4)`: add 3rd and 4th source indicate backpressure-  `concatarray`: missing diagram-  `concatarrayeager`: missing diagram-  `concateager`: missing diagram-  `create`: missing diagram-  `defer`: missing diagram-  `error(callable)`: missing diagram- [x] `error(throwable)`: indicate error in the box- [x] `fromcallable`: missing diagram- [x] `frompublisher`: missing diagram- [x] `fromobservable`: missing diagram- [x] `merge`: missing diagram- [x] `merge(singlesource<singlesource<t>>)`: indicate main element is a `singlesource`- [x] `merge(s1s4)`: add 3rd and 4th source indicate backpressure- [x] `mergedelayerror`: iterable/publisher missing diagrams s2s3s4 wrong diagrams- [x] `never`: missing diagram- [x] `timer`: missing diagram- [x] `equals`: missing diagram- [x] `unsafecreate`: missing diagram- [x] `using`: missing diagram- [x] `wrap`: missing diagram- [x] `ambwith`: missing diagram- [x] `as`: missing diagram- [x] `hide`: missing diagram- [x] `compose`: missing diagram- [x] `cache`: missing diagram- [x] `cast`: missing diagram- [x] `delay`: missing diagram- [x] `delaysubscription`: missing diagram- [x] `dematerialize`: missing diagram- [x] `doaftersuccess`: missing diagram- [x] `doafterterminate`: indicate error case- [x] `dofinally`: missing diagram- [x] `doonsubscibe`: missing diagram- [x] `doonsuccess`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonerror`: missing diagram- [x] `doondispose`: missing diagram- [x] `filter`: one source item indicate both true and false outcomes- [x] `flatmappublisher`: operator name- [x] `blockingget`: missing diagram- [x] `lift`: missing diagram- [x] `contains`: missing diagram- [x] `mergewith`: indicate backpressure- [x] `onerrorreturn`: indicate item is the result of a function call with the original error- [x] `onerrorreturnitem`: use the previous `onerrorreturn` diagram change name in box- [x] `onerrorresumenext`: diagram should have one item and no complete marker- [x] `onerrorresumewith`: operator name- [x] `onterminatedetach`: missing diagram- [x] `repeat`: missing diagram- [x] `repeatwhen`: missing diagram- [x] `repeatuntil`: missing diagram- [x] `retry`: missing diagram- [x] `retrywhen`: missing diagram- [x] `subscribe`: missing diagram- [x] `subscribewith`: missing diagram?- [x] `takeuntil`: fix item count in main and other sources indicate all other signal types- [x] `timeout`: missing diagram- [x] `to`: missing diagram- [x] `tocompletable`: diagram is stretched- [x] `toflowable`: operator name in box indicate backpressure- [x] `tofuture`: indicate future remove the blocking text- [x] `tomaybe`: operator name in box indicate both outcomes with proper signal types- [x] `unsubscribeon`: missing diagram- [x] `test`: missing diagram?;i see most marbles in the javadoc live under this folder:  ` are other locations accepted - eg can i upload it in google drive for example and open a pr with the updated path in the javadoc directly? heres a few i created:![single_dofinally]( || images have to be hosted by the project besides google drive tends to change the service terms and images may become inaccessible (ive lost resource location this way in another project) about your images:- `dofinally`:   - error should be a red x  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here- `doondispose`  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here  - `unsubscribe` should be `dispose`- `doonsubscribe`  - the star should be in between the operator box and the bottom timeline- `doonsuccess`: ok || updated images from #5987 now in the repository:![dofinally]( || how are these made? are there any written guidelines? i can try making some when i have time || there is a mac only omnigraffle im on windows and i use excel shapes and arrows || @aarjavp  i used [this template]( as a staring point its for **inkscape** software which worked nicely on my mac || hi all can you please tell me is this marble acceptable for the `filter` operator?as i havent contributed to this project so far i would like to take it easy and slow :) let me know what should i change so that i have a reference for future marbles![filter]( || not really there is no | in single please have a look at diagrams above:  || @akarnokd can we update this issue please? its getting a bit messy and hard to follow what has been completed || @umfsimke it has been only you lately that worked on this ||;1;0;use correct marble diagram url for singlenever method;
6075;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add marble diagram to the single.filter method;hopefully this should tick off the  filter  operator in #5788;;5788.0;add marble diagram to the singlefilter method;hopefully this should tick off the `filter` operator in #5788please let me know if i need to change anything on the diagram itself if not please send me url when you upload image within the project so i can change url for the marble in the pralthough i had a doubt and wanted to double check operator `filter` returns `maybe` which essentially will call `onsuccess` or `oncomplete` by running junit tests i could observe that this is a behavior but if i use `testobserver` then both `assertvalue()` and `assertcomplete()` are invoked when there are elements that satisfy `filter` condition; merging 6075 ;3x: single incorrect or missing images (tracking issue);-  `amb`: missing diagram-  `ambarray`: missing diagram-  `concat(arg)`: missing diagram-  `concat(s1s4)`: add 3rd and 4th source indicate backpressure-  `concatarray`: missing diagram-  `concatarrayeager`: missing diagram-  `concateager`: missing diagram-  `create`: missing diagram-  `defer`: missing diagram-  `error(callable)`: missing diagram- [x] `error(throwable)`: indicate error in the box- [x] `fromcallable`: missing diagram- [x] `frompublisher`: missing diagram- [x] `fromobservable`: missing diagram- [x] `merge`: missing diagram- [x] `merge(singlesource<singlesource<t>>)`: indicate main element is a `singlesource`- [x] `merge(s1s4)`: add 3rd and 4th source indicate backpressure- [x] `mergedelayerror`: iterable/publisher missing diagrams s2s3s4 wrong diagrams- [x] `never`: missing diagram- [x] `timer`: missing diagram- [x] `equals`: missing diagram- [x] `unsafecreate`: missing diagram- [x] `using`: missing diagram- [x] `wrap`: missing diagram- [x] `ambwith`: missing diagram- [x] `as`: missing diagram- [x] `hide`: missing diagram- [x] `compose`: missing diagram- [x] `cache`: missing diagram- [x] `cast`: missing diagram- [x] `delay`: missing diagram- [x] `delaysubscription`: missing diagram- [x] `dematerialize`: missing diagram- [x] `doaftersuccess`: missing diagram- [x] `doafterterminate`: indicate error case- [x] `dofinally`: missing diagram- [x] `doonsubscibe`: missing diagram- [x] `doonsuccess`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonerror`: missing diagram- [x] `doondispose`: missing diagram- [x] `filter`: one source item indicate both true and false outcomes- [x] `flatmappublisher`: operator name- [x] `blockingget`: missing diagram- [x] `lift`: missing diagram- [x] `contains`: missing diagram- [x] `mergewith`: indicate backpressure- [x] `onerrorreturn`: indicate item is the result of a function call with the original error- [x] `onerrorreturnitem`: use the previous `onerrorreturn` diagram change name in box- [x] `onerrorresumenext`: diagram should have one item and no complete marker- [x] `onerrorresumewith`: operator name- [x] `onterminatedetach`: missing diagram- [x] `repeat`: missing diagram- [x] `repeatwhen`: missing diagram- [x] `repeatuntil`: missing diagram- [x] `retry`: missing diagram- [x] `retrywhen`: missing diagram- [x] `subscribe`: missing diagram- [x] `subscribewith`: missing diagram?- [x] `takeuntil`: fix item count in main and other sources indicate all other signal types- [x] `timeout`: missing diagram- [x] `to`: missing diagram- [x] `tocompletable`: diagram is stretched- [x] `toflowable`: operator name in box indicate backpressure- [x] `tofuture`: indicate future remove the blocking text- [x] `tomaybe`: operator name in box indicate both outcomes with proper signal types- [x] `unsubscribeon`: missing diagram- [x] `test`: missing diagram?;i see most marbles in the javadoc live under this folder:  ` are other locations accepted - eg can i upload it in google drive for example and open a pr with the updated path in the javadoc directly? heres a few i created:![single_dofinally]( || images have to be hosted by the project besides google drive tends to change the service terms and images may become inaccessible (ive lost resource location this way in another project) about your images:- `dofinally`:   - error should be a red x  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here- `doondispose`  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here  - `unsubscribe` should be `dispose`- `doonsubscribe`  - the star should be in between the operator box and the bottom timeline- `doonsuccess`: ok || updated images from #5987 now in the repository:![dofinally]( || how are these made? are there any written guidelines? i can try making some when i have time || there is a mac only omnigraffle im on windows and i use excel shapes and arrows || @aarjavp  i used [this template]( as a staring point its for **inkscape** software which worked nicely on my mac || hi all can you please tell me is this marble acceptable for the `filter` operator?as i havent contributed to this project so far i would like to take it easy and slow :) let me know what should i change so that i have a reference for future marbles![filter]( || not really there is no | in single please have a look at diagrams above:  || @akarnokd can we update this issue please? its getting a bit messy and hard to follow what has been completed || @umfsimke it has been only you lately that worked on this ||;1;0;use correct marble diagram url for singlefilter method;
6076;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add marble diagrams to the single.delay method;here are marbles for  delay  operator in #5788;;5788.0;add marble diagrams to the singledelay method;here are marbles for `delay` operator in #5788please let me know if i need to change anything on the diagram itself if not please send me url when you upload image within the project so i can change url for the marble in the pr; merging 6076  < ;3x: single incorrect or missing images (tracking issue);-  `amb`: missing diagram-  `ambarray`: missing diagram-  `concat(arg)`: missing diagram-  `concat(s1s4)`: add 3rd and 4th source indicate backpressure-  `concatarray`: missing diagram-  `concatarrayeager`: missing diagram-  `concateager`: missing diagram-  `create`: missing diagram-  `defer`: missing diagram-  `error(callable)`: missing diagram- [x] `error(throwable)`: indicate error in the box- [x] `fromcallable`: missing diagram- [x] `frompublisher`: missing diagram- [x] `fromobservable`: missing diagram- [x] `merge`: missing diagram- [x] `merge(singlesource<singlesource<t>>)`: indicate main element is a `singlesource`- [x] `merge(s1s4)`: add 3rd and 4th source indicate backpressure- [x] `mergedelayerror`: iterable/publisher missing diagrams s2s3s4 wrong diagrams- [x] `never`: missing diagram- [x] `timer`: missing diagram- [x] `equals`: missing diagram- [x] `unsafecreate`: missing diagram- [x] `using`: missing diagram- [x] `wrap`: missing diagram- [x] `ambwith`: missing diagram- [x] `as`: missing diagram- [x] `hide`: missing diagram- [x] `compose`: missing diagram- [x] `cache`: missing diagram- [x] `cast`: missing diagram- [x] `delay`: missing diagram- [x] `delaysubscription`: missing diagram- [x] `dematerialize`: missing diagram- [x] `doaftersuccess`: missing diagram- [x] `doafterterminate`: indicate error case- [x] `dofinally`: missing diagram- [x] `doonsubscibe`: missing diagram- [x] `doonsuccess`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonerror`: missing diagram- [x] `doondispose`: missing diagram- [x] `filter`: one source item indicate both true and false outcomes- [x] `flatmappublisher`: operator name- [x] `blockingget`: missing diagram- [x] `lift`: missing diagram- [x] `contains`: missing diagram- [x] `mergewith`: indicate backpressure- [x] `onerrorreturn`: indicate item is the result of a function call with the original error- [x] `onerrorreturnitem`: use the previous `onerrorreturn` diagram change name in box- [x] `onerrorresumenext`: diagram should have one item and no complete marker- [x] `onerrorresumewith`: operator name- [x] `onterminatedetach`: missing diagram- [x] `repeat`: missing diagram- [x] `repeatwhen`: missing diagram- [x] `repeatuntil`: missing diagram- [x] `retry`: missing diagram- [x] `retrywhen`: missing diagram- [x] `subscribe`: missing diagram- [x] `subscribewith`: missing diagram?- [x] `takeuntil`: fix item count in main and other sources indicate all other signal types- [x] `timeout`: missing diagram- [x] `to`: missing diagram- [x] `tocompletable`: diagram is stretched- [x] `toflowable`: operator name in box indicate backpressure- [x] `tofuture`: indicate future remove the blocking text- [x] `tomaybe`: operator name in box indicate both outcomes with proper signal types- [x] `unsubscribeon`: missing diagram- [x] `test`: missing diagram?;i see most marbles in the javadoc live under this folder:  ` are other locations accepted - eg can i upload it in google drive for example and open a pr with the updated path in the javadoc directly? heres a few i created:![single_dofinally]( || images have to be hosted by the project besides google drive tends to change the service terms and images may become inaccessible (ive lost resource location this way in another project) about your images:- `dofinally`:   - error should be a red x  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here- `doondispose`  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here  - `unsubscribe` should be `dispose`- `doonsubscribe`  - the star should be in between the operator box and the bottom timeline- `doonsuccess`: ok || updated images from #5987 now in the repository:![dofinally]( || how are these made? are there any written guidelines? i can try making some when i have time || there is a mac only omnigraffle im on windows and i use excel shapes and arrows || @aarjavp  i used [this template]( as a staring point its for **inkscape** software which worked nicely on my mac || hi all can you please tell me is this marble acceptable for the `filter` operator?as i havent contributed to this project so far i would like to take it easy and slow :) let me know what should i change so that i have a reference for future marbles![filter]( || not really there is no | in single please have a look at diagrams above:  || @akarnokd can we update this issue please? its getting a bit messy and hard to follow what has been completed || @umfsimke it has been only you lately that worked on this ||;1;0;use correct marble diagram urls for singledelay methods;
6077;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add marble diagram for single.hide operator;this should complete  hide  operator in #5788;;5788.0;add marble diagram for singlehide operator;this should complete `hide` operator in #5788please let me know if i need to change anything on the diagram itself if not please send me url when you upload image within the project so i can change url for the marble in the pralthough i wasnt sure if i should represent somehow that `disposable` is hidden as well if so can you please tell me how to represent that on marble?; merging 6077  < ;3x: single incorrect or missing images (tracking issue);-  `amb`: missing diagram-  `ambarray`: missing diagram-  `concat(arg)`: missing diagram-  `concat(s1s4)`: add 3rd and 4th source indicate backpressure-  `concatarray`: missing diagram-  `concatarrayeager`: missing diagram-  `concateager`: missing diagram-  `create`: missing diagram-  `defer`: missing diagram-  `error(callable)`: missing diagram- [x] `error(throwable)`: indicate error in the box- [x] `fromcallable`: missing diagram- [x] `frompublisher`: missing diagram- [x] `fromobservable`: missing diagram- [x] `merge`: missing diagram- [x] `merge(singlesource<singlesource<t>>)`: indicate main element is a `singlesource`- [x] `merge(s1s4)`: add 3rd and 4th source indicate backpressure- [x] `mergedelayerror`: iterable/publisher missing diagrams s2s3s4 wrong diagrams- [x] `never`: missing diagram- [x] `timer`: missing diagram- [x] `equals`: missing diagram- [x] `unsafecreate`: missing diagram- [x] `using`: missing diagram- [x] `wrap`: missing diagram- [x] `ambwith`: missing diagram- [x] `as`: missing diagram- [x] `hide`: missing diagram- [x] `compose`: missing diagram- [x] `cache`: missing diagram- [x] `cast`: missing diagram- [x] `delay`: missing diagram- [x] `delaysubscription`: missing diagram- [x] `dematerialize`: missing diagram- [x] `doaftersuccess`: missing diagram- [x] `doafterterminate`: indicate error case- [x] `dofinally`: missing diagram- [x] `doonsubscibe`: missing diagram- [x] `doonsuccess`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonerror`: missing diagram- [x] `doondispose`: missing diagram- [x] `filter`: one source item indicate both true and false outcomes- [x] `flatmappublisher`: operator name- [x] `blockingget`: missing diagram- [x] `lift`: missing diagram- [x] `contains`: missing diagram- [x] `mergewith`: indicate backpressure- [x] `onerrorreturn`: indicate item is the result of a function call with the original error- [x] `onerrorreturnitem`: use the previous `onerrorreturn` diagram change name in box- [x] `onerrorresumenext`: diagram should have one item and no complete marker- [x] `onerrorresumewith`: operator name- [x] `onterminatedetach`: missing diagram- [x] `repeat`: missing diagram- [x] `repeatwhen`: missing diagram- [x] `repeatuntil`: missing diagram- [x] `retry`: missing diagram- [x] `retrywhen`: missing diagram- [x] `subscribe`: missing diagram- [x] `subscribewith`: missing diagram?- [x] `takeuntil`: fix item count in main and other sources indicate all other signal types- [x] `timeout`: missing diagram- [x] `to`: missing diagram- [x] `tocompletable`: diagram is stretched- [x] `toflowable`: operator name in box indicate backpressure- [x] `tofuture`: indicate future remove the blocking text- [x] `tomaybe`: operator name in box indicate both outcomes with proper signal types- [x] `unsubscribeon`: missing diagram- [x] `test`: missing diagram?;i see most marbles in the javadoc live under this folder:  ` are other locations accepted - eg can i upload it in google drive for example and open a pr with the updated path in the javadoc directly? heres a few i created:![single_dofinally]( || images have to be hosted by the project besides google drive tends to change the service terms and images may become inaccessible (ive lost resource location this way in another project) about your images:- `dofinally`:   - error should be a red x  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here- `doondispose`  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here  - `unsubscribe` should be `dispose`- `doonsubscribe`  - the star should be in between the operator box and the bottom timeline- `doonsuccess`: ok || updated images from #5987 now in the repository:![dofinally]( || how are these made? are there any written guidelines? i can try making some when i have time || there is a mac only omnigraffle im on windows and i use excel shapes and arrows || @aarjavp  i used [this template]( as a staring point its for **inkscape** software which worked nicely on my mac || hi all can you please tell me is this marble acceptable for the `filter` operator?as i havent contributed to this project so far i would like to take it easy and slow :) let me know what should i change so that i have a reference for future marbles![filter]( || not really there is no | in single please have a look at diagrams above:  || @akarnokd can we update this issue please? its getting a bit messy and hard to follow what has been completed || @umfsimke it has been only you lately that worked on this ||;1;0;use correct marble diagram url for singlehide method;
6078;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add maybe.hide() marble diagram;add marble to  maybe.hide() :;;0;2x: add maybehide() marble diagram;add marble to `maybehide()`:(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybehidepng); merging 6078  < ;;;;1;1;2x: add maybehide() marble diagram;
6079;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add completable.takeuntil(completable) operator;this pr adds the missing dedicated  takeuntil  operator to  completable .;;3708.0;2x: add completabletakeuntil(completable) operator;this pr adds the missing dedicated `takeuntil` operator to `completable`( the same effect could be achieved via the `ambwith` but there are two benefits of a dedicated operator:- easier to discover based on the `takeuntil` operator in other types- more direct implementation unlike `ambwith` which is built upon an n-ary `amb` operator with additional overheadthere was a feature request in #3708 some time ago but apparently the issue got closed off after `singletakeuntil` was implemented; merging 6079 ;single and completable takeuntil();in reading the original pr for `single` i saw ben was ok with adding a `takeuntil(single/observable)` operator for `single` later i was wondering if this was still the plan and if you would be open to contributions on this front same with `completable`one caveat that ive thought of is that theres a potentially conflicting contact with `single` and `takeuntil()` in the sense that `takeuntil()` calls `oncompleted()` in observables but `single`s will actually go to `onerror()` if `oncompleted()` is called before any events are emitted (and by extension `onsuccess()`) not sure what the clear path would be but it seems like `single`s would have to only unsubscribe and not propagate any notifications differing from `observable`s and likely `completable`s in this regard;`singletakeuntil` still has to emit an onsuccess or onerror you need to emit a `nosuchelementexception` from the other `singleonsuccess` unsubscribing the main and not emitting anything is bad because it keeps the subscribers hanging i dont think it is worth it`completabletakeuntil` is just `completableambwith(other)` || the completable makes sense for `single` do you think theres a feasible way to do a sort of takeuntil-like behavior where it completes/unsubscribes on the emission of another observable/single? im working on some lifecycle handling for android and a use case thats worked well in the past is to emit lifecycle events via behaviorsubject and then just `takeuntil(lifecyclesubjectfilter(e -> e  detach))` the idea is you want it to unsubscribe when the detach happens and perhaps out of convenience weve always been using the fact that takeuntil would call oncomplete and eventually cause it to unsubscribe  || it seems like forcing an onsuccess or onerror defeats the purpose of having a subscription that supports `unsubscribe` prior to that || the best you can do with `takeuntil` is to signal an error like `cancellationexception` similar to how `future` does || i see would that be something you guys would be open to as pr? or at least consider making `single#lift()` public since its still experimental? otherwise it doesnt seem like its possible in the current api could catch existing `nosuchelementexception`s but thered be no way to know if it was due to completion or cancellation alternatively would there be a simple way to potentially swallow that error upstream rather than force the subscriber to handle it? || we are open for prs || closing via #3712 || actually this just reminded me would we want `single` and `observable` overloads for `completable` or just use `amb` and call `tocompletable` on those when passing them in? || maybe submit a pr and lets see the opinions || will do though likely not until this weekend or next week ||;1;0;2x: add completabletakeuntil(completable) operator;
6080;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: improve class javadoc of single  maybe and completable;this pr expands the javadocs of  single    maybe  and  completable  where the latter also receives an explanation marble:;;0;2x: improve class javadoc of single maybe and completable;this pr expands the javadocs of `single` `maybe` and `completable` where the latter also receives an explanation marble:( let me know if there is any property worthy of mentioning in the class javadocs as well as please look out for copy-paste mistakes; merging 6080  < ;;;;1;1;2x: improve class javadoc of single maybe and completable;
6081;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add marble diagrams for single.repeat operators;here are marbles for  repeat    repeat(times)  and  repeatwhen  operator in #5788;;5788.0;add marble diagrams for singlerepeat operators;here are marbles for `repeat` `repeat(times)` and `repeatwhen` operator in #5788please let me know if i need to change anything on the diagram itself if not please send me url when you upload image within the project so i can change url for the marble in the pri intentionally added two diagrams for `repeatwhen` as i would say its interesting case that people should be aware of**edit:**here are marbles`repeat` operator:![repeat]( operator:![repeat with count]( operator:![repeatwhen](https://rawentcom/umfsimke/rxjava/images/images/repeatwhenpng); merging 6081 ;3x: single incorrect or missing images (tracking issue);-  `amb`: missing diagram-  `ambarray`: missing diagram-  `concat(arg)`: missing diagram-  `concat(s1s4)`: add 3rd and 4th source indicate backpressure-  `concatarray`: missing diagram-  `concatarrayeager`: missing diagram-  `concateager`: missing diagram-  `create`: missing diagram-  `defer`: missing diagram-  `error(callable)`: missing diagram- [x] `error(throwable)`: indicate error in the box- [x] `fromcallable`: missing diagram- [x] `frompublisher`: missing diagram- [x] `fromobservable`: missing diagram- [x] `merge`: missing diagram- [x] `merge(singlesource<singlesource<t>>)`: indicate main element is a `singlesource`- [x] `merge(s1s4)`: add 3rd and 4th source indicate backpressure- [x] `mergedelayerror`: iterable/publisher missing diagrams s2s3s4 wrong diagrams- [x] `never`: missing diagram- [x] `timer`: missing diagram- [x] `equals`: missing diagram- [x] `unsafecreate`: missing diagram- [x] `using`: missing diagram- [x] `wrap`: missing diagram- [x] `ambwith`: missing diagram- [x] `as`: missing diagram- [x] `hide`: missing diagram- [x] `compose`: missing diagram- [x] `cache`: missing diagram- [x] `cast`: missing diagram- [x] `delay`: missing diagram- [x] `delaysubscription`: missing diagram- [x] `dematerialize`: missing diagram- [x] `doaftersuccess`: missing diagram- [x] `doafterterminate`: indicate error case- [x] `dofinally`: missing diagram- [x] `doonsubscibe`: missing diagram- [x] `doonsuccess`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonerror`: missing diagram- [x] `doondispose`: missing diagram- [x] `filter`: one source item indicate both true and false outcomes- [x] `flatmappublisher`: operator name- [x] `blockingget`: missing diagram- [x] `lift`: missing diagram- [x] `contains`: missing diagram- [x] `mergewith`: indicate backpressure- [x] `onerrorreturn`: indicate item is the result of a function call with the original error- [x] `onerrorreturnitem`: use the previous `onerrorreturn` diagram change name in box- [x] `onerrorresumenext`: diagram should have one item and no complete marker- [x] `onerrorresumewith`: operator name- [x] `onterminatedetach`: missing diagram- [x] `repeat`: missing diagram- [x] `repeatwhen`: missing diagram- [x] `repeatuntil`: missing diagram- [x] `retry`: missing diagram- [x] `retrywhen`: missing diagram- [x] `subscribe`: missing diagram- [x] `subscribewith`: missing diagram?- [x] `takeuntil`: fix item count in main and other sources indicate all other signal types- [x] `timeout`: missing diagram- [x] `to`: missing diagram- [x] `tocompletable`: diagram is stretched- [x] `toflowable`: operator name in box indicate backpressure- [x] `tofuture`: indicate future remove the blocking text- [x] `tomaybe`: operator name in box indicate both outcomes with proper signal types- [x] `unsubscribeon`: missing diagram- [x] `test`: missing diagram?;i see most marbles in the javadoc live under this folder:  ` are other locations accepted - eg can i upload it in google drive for example and open a pr with the updated path in the javadoc directly? heres a few i created:![single_dofinally]( || images have to be hosted by the project besides google drive tends to change the service terms and images may become inaccessible (ive lost resource location this way in another project) about your images:- `dofinally`:   - error should be a red x  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here- `doondispose`  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here  - `unsubscribe` should be `dispose`- `doonsubscribe`  - the star should be in between the operator box and the bottom timeline- `doonsuccess`: ok || updated images from #5987 now in the repository:![dofinally]( || how are these made? are there any written guidelines? i can try making some when i have time || there is a mac only omnigraffle im on windows and i use excel shapes and arrows || @aarjavp  i used [this template]( as a staring point its for **inkscape** software which worked nicely on my mac || hi all can you please tell me is this marble acceptable for the `filter` operator?as i havent contributed to this project so far i would like to take it easy and slow :) let me know what should i change so that i have a reference for future marbles![filter]( || not really there is no | in single please have a look at diagrams above:  || @akarnokd can we update this issue please? its getting a bit messy and hard to follow what has been completed || @umfsimke it has been only you lately that worked on this ||;1;0;use correct marble diagram urls;
6083;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add completable marble diagrams (07/17a);this pr adds the following marble diagrams to  completable  operators (#5789):;;5789.0;2x: add completable marble diagrams (07/17a);this pr adds the following marble diagrams to `completable` operators (#5789):#### amb ambarray( complete![image]( concatarray concat![image]( defer![image]( error![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableerrorpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableerrorfpng); merging 6083 ;2x: completable missing or incorrect marbles (tracking issue);-  `ambarray`: missing diagram-  `amb`: missing diagram-  `complete`: missing diagram-  `concatarray`: missing diagram-  `concat`: missing diagram-  `create`: missing diaglam-  `unsafecreate`: missing diagram-  `defer`: missing diagram-  `error`: missing diagram-  `fromaction`: missing diagram- [x] `fromcallable`: missing diagram- [x] `fromfuture`: missing diagram- [x] `fromobservable`: missing diagram- [x] `frompublisher`: missing diagram- [x] `fromrunnable`: missing diagram- [x] `fromsingle`: missing diagram- [x] `mergearray`: missing diagram- [x] `merge`: missing diagram- [x] `mergearraydelayerror`: missing diagram- [x] `mergedelayerror`: missing diagram- [x] `never`: missing diagram- [x] `timer`: missing diagram- [x] `using`: missing diagram- [x] `wrap`: missing diagram- [x] `ambwith`: missing diagram- [x] `andthen`: missing diagram- [x] `as`: missing diagram- [x] `blockingawait`: missing diagram- [x] `blockingget`: missing diagram- [x] `cache`: missing diagram- [x] `compose`: missing diagram- [x] `concatwith`: missing diagram- [x] `delay`: missing diagram- [x] `dooncomplete`: missing diagram- [x] `doondispose`: missing diagram- [x] `doonerror`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonlifecycle`: missing diagram- [x] `doonsubscribe`: missing diagram- [x] `doonterminate`: missing diagram- [x] `doafterterminate`: missing diagram- [x] `dofinally`: missing diagram- [x] `lift`: missing diagram- [x] `mergewith`: missing diagram- [x] `observeon`: missing diagram- [x] `onerrorcomplete`: missing diagram- [x] `onerrorresumenext`: missing diagram- [x] `onterminatedetach`: missing diagram- [x] `repeat`: missing diagram- [x] `repeatuntil`: missing diagram- [x] `repeatwhen`: missing diagram- [x] `retry`: missing diagram- [x] `retrywhen`: missing diagram- [x] `startwith`: missing diagram- [x] `hide`: missing diagram- [x] `subscribe`: missing diagram- [x] `subscribewith`: missing diagram?- [x] `subscribeon`: missing diagram- [x] `timeout`: missing diagram- [x] `to`: missing diagram- [x] `toflowable`: missing diagram- [x] `tomaybe`: wrong operator name in box- [x] `toobservable`: use the old diagram of `tomaybe`- [x] `tosingle`: missing diagram- [x] `tosingledefault`: missing diagram- [x] `unsubscribeon`: missing diagram- [x] `test`: missing diagram;done ||;1;0;2x: add completable marble diagrams (07/17a);
6084;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add marble diagram for single.repeatuntil operator;here is marble for  repeatuntil  operator in #5788;;5788.0;add marble diagram for singlerepeatuntil operator;here is marble for `repeatuntil` operator in #5788![repeatuntil]( let me know if i need to change anything on the diagram itself if not please send me url when you upload image within the project so i can change url for the marble in the pr;` ||  merging 6084 ;3x: single incorrect or missing images (tracking issue);-  `amb`: missing diagram-  `ambarray`: missing diagram-  `concat(arg)`: missing diagram-  `concat(s1s4)`: add 3rd and 4th source indicate backpressure-  `concatarray`: missing diagram-  `concatarrayeager`: missing diagram-  `concateager`: missing diagram-  `create`: missing diagram-  `defer`: missing diagram-  `error(callable)`: missing diagram- [x] `error(throwable)`: indicate error in the box- [x] `fromcallable`: missing diagram- [x] `frompublisher`: missing diagram- [x] `fromobservable`: missing diagram- [x] `merge`: missing diagram- [x] `merge(singlesource<singlesource<t>>)`: indicate main element is a `singlesource`- [x] `merge(s1s4)`: add 3rd and 4th source indicate backpressure- [x] `mergedelayerror`: iterable/publisher missing diagrams s2s3s4 wrong diagrams- [x] `never`: missing diagram- [x] `timer`: missing diagram- [x] `equals`: missing diagram- [x] `unsafecreate`: missing diagram- [x] `using`: missing diagram- [x] `wrap`: missing diagram- [x] `ambwith`: missing diagram- [x] `as`: missing diagram- [x] `hide`: missing diagram- [x] `compose`: missing diagram- [x] `cache`: missing diagram- [x] `cast`: missing diagram- [x] `delay`: missing diagram- [x] `delaysubscription`: missing diagram- [x] `dematerialize`: missing diagram- [x] `doaftersuccess`: missing diagram- [x] `doafterterminate`: indicate error case- [x] `dofinally`: missing diagram- [x] `doonsubscibe`: missing diagram- [x] `doonsuccess`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonerror`: missing diagram- [x] `doondispose`: missing diagram- [x] `filter`: one source item indicate both true and false outcomes- [x] `flatmappublisher`: operator name- [x] `blockingget`: missing diagram- [x] `lift`: missing diagram- [x] `contains`: missing diagram- [x] `mergewith`: indicate backpressure- [x] `onerrorreturn`: indicate item is the result of a function call with the original error- [x] `onerrorreturnitem`: use the previous `onerrorreturn` diagram change name in box- [x] `onerrorresumenext`: diagram should have one item and no complete marker- [x] `onerrorresumewith`: operator name- [x] `onterminatedetach`: missing diagram- [x] `repeat`: missing diagram- [x] `repeatwhen`: missing diagram- [x] `repeatuntil`: missing diagram- [x] `retry`: missing diagram- [x] `retrywhen`: missing diagram- [x] `subscribe`: missing diagram- [x] `subscribewith`: missing diagram?- [x] `takeuntil`: fix item count in main and other sources indicate all other signal types- [x] `timeout`: missing diagram- [x] `to`: missing diagram- [x] `tocompletable`: diagram is stretched- [x] `toflowable`: operator name in box indicate backpressure- [x] `tofuture`: indicate future remove the blocking text- [x] `tomaybe`: operator name in box indicate both outcomes with proper signal types- [x] `unsubscribeon`: missing diagram- [x] `test`: missing diagram?;i see most marbles in the javadoc live under this folder:  ` are other locations accepted - eg can i upload it in google drive for example and open a pr with the updated path in the javadoc directly? heres a few i created:![single_dofinally]( || images have to be hosted by the project besides google drive tends to change the service terms and images may become inaccessible (ive lost resource location this way in another project) about your images:- `dofinally`:   - error should be a red x  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here- `doondispose`  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here  - `unsubscribe` should be `dispose`- `doonsubscribe`  - the star should be in between the operator box and the bottom timeline- `doonsuccess`: ok || updated images from #5987 now in the repository:![dofinally]( || how are these made? are there any written guidelines? i can try making some when i have time || there is a mac only omnigraffle im on windows and i use excel shapes and arrows || @aarjavp  i used [this template]( as a staring point its for **inkscape** software which worked nicely on my mac || hi all can you please tell me is this marble acceptable for the `filter` operator?as i havent contributed to this project so far i would like to take it easy and slow :) let me know what should i change so that i have a reference for future marbles![filter]( || not really there is no | in single please have a look at diagrams above:  || @akarnokd can we update this issue please? its getting a bit messy and hard to follow what has been completed || @umfsimke it has been only you lately that worked on this ||;1;0;use proper url for marble;
6085;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: more completable marbles (+18)  add completable.frommaybe;this pr adds marble diagrams (#5789) to the following operators as well as adds the missing  completable.frommaybe  operator ( fromx  of other types were already there  uses existing  maybe.ignoreelement  s underlying implementation).;;5789.0;2x: more completable marbles (+18) add completablefrommaybe;this pr adds marble diagrams (#5789) to the following operators as well as adds the missing `completablefrommaybe` operator (`fromx` of other types were already there uses existing `maybeignoreelement`s underlying implementation)#### fromaction( fromcallable![image]( fromfuture![image]( frommaybe![image]( fromobservable![image]( frompublisher![image]( fromsingle![image]( mergearray & mergearraydelayerror![image]( merge(both `iterable` and `publisher` variants)![image]( mergedelayerror(both `iterable` and `publisher` variants)![image]( never![image]( timer![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completabletimerpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completabletimerspng); merging 6085 ;2x: completable missing or incorrect marbles (tracking issue);-  `ambarray`: missing diagram-  `amb`: missing diagram-  `complete`: missing diagram-  `concatarray`: missing diagram-  `concat`: missing diagram-  `create`: missing diaglam-  `unsafecreate`: missing diagram-  `defer`: missing diagram-  `error`: missing diagram-  `fromaction`: missing diagram- [x] `fromcallable`: missing diagram- [x] `fromfuture`: missing diagram- [x] `fromobservable`: missing diagram- [x] `frompublisher`: missing diagram- [x] `fromrunnable`: missing diagram- [x] `fromsingle`: missing diagram- [x] `mergearray`: missing diagram- [x] `merge`: missing diagram- [x] `mergearraydelayerror`: missing diagram- [x] `mergedelayerror`: missing diagram- [x] `never`: missing diagram- [x] `timer`: missing diagram- [x] `using`: missing diagram- [x] `wrap`: missing diagram- [x] `ambwith`: missing diagram- [x] `andthen`: missing diagram- [x] `as`: missing diagram- [x] `blockingawait`: missing diagram- [x] `blockingget`: missing diagram- [x] `cache`: missing diagram- [x] `compose`: missing diagram- [x] `concatwith`: missing diagram- [x] `delay`: missing diagram- [x] `dooncomplete`: missing diagram- [x] `doondispose`: missing diagram- [x] `doonerror`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonlifecycle`: missing diagram- [x] `doonsubscribe`: missing diagram- [x] `doonterminate`: missing diagram- [x] `doafterterminate`: missing diagram- [x] `dofinally`: missing diagram- [x] `lift`: missing diagram- [x] `mergewith`: missing diagram- [x] `observeon`: missing diagram- [x] `onerrorcomplete`: missing diagram- [x] `onerrorresumenext`: missing diagram- [x] `onterminatedetach`: missing diagram- [x] `repeat`: missing diagram- [x] `repeatuntil`: missing diagram- [x] `repeatwhen`: missing diagram- [x] `retry`: missing diagram- [x] `retrywhen`: missing diagram- [x] `startwith`: missing diagram- [x] `hide`: missing diagram- [x] `subscribe`: missing diagram- [x] `subscribewith`: missing diagram?- [x] `subscribeon`: missing diagram- [x] `timeout`: missing diagram- [x] `to`: missing diagram- [x] `toflowable`: missing diagram- [x] `tomaybe`: wrong operator name in box- [x] `toobservable`: use the old diagram of `tomaybe`- [x] `tosingle`: missing diagram- [x] `tosingledefault`: missing diagram- [x] `unsubscribeon`: missing diagram- [x] `test`: missing diagram;done ||;1;0;2x: more completable marbles add cfrommaybe;
6086;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;single error operators marbles;here are marbles for #5788;;5788.0;single error operators marbles;here are marbles for #5788 for `error(callable)`![errorcallable]( `error(throwable)` only added error event to be red:![errorthrowable]( `onerrorreturn`![onerrorreturn]( `onerrorreturnitem`![onerrorreturnitem]( `onerrorresumenext(singlesource)`![onerrorresumenext]( `onerrorresumenext(function)`![onerrorresumenextfn](https://rawentcom/umfsimke/rxjava/images/images/onerrorresumenextwithfnpng);for the `onerrorx` please indicate the normal case via different marble (ie the usual split diagram)btw you can save yourself a commit if you follow the following naming in the javadocs:` `xxxx` is the name of the operator such as `error` and may contain argument indicator letters:- `s` is for `scheduler`s or `single`- `t` is for timed- `n` is for some numerical value- `f` is for function or `flowable`- `c` is for callable or `completable`- `p` is for `publisher`- `m` is for `maybe` or some other numerical valuethus the image naming of this pr will look like this:-` ||  merging 6086 ;3x: single incorrect or missing images (tracking issue);-  `amb`: missing diagram-  `ambarray`: missing diagram-  `concat(arg)`: missing diagram-  `concat(s1s4)`: add 3rd and 4th source indicate backpressure-  `concatarray`: missing diagram-  `concatarrayeager`: missing diagram-  `concateager`: missing diagram-  `create`: missing diagram-  `defer`: missing diagram-  `error(callable)`: missing diagram- [x] `error(throwable)`: indicate error in the box- [x] `fromcallable`: missing diagram- [x] `frompublisher`: missing diagram- [x] `fromobservable`: missing diagram- [x] `merge`: missing diagram- [x] `merge(singlesource<singlesource<t>>)`: indicate main element is a `singlesource`- [x] `merge(s1s4)`: add 3rd and 4th source indicate backpressure- [x] `mergedelayerror`: iterable/publisher missing diagrams s2s3s4 wrong diagrams- [x] `never`: missing diagram- [x] `timer`: missing diagram- [x] `equals`: missing diagram- [x] `unsafecreate`: missing diagram- [x] `using`: missing diagram- [x] `wrap`: missing diagram- [x] `ambwith`: missing diagram- [x] `as`: missing diagram- [x] `hide`: missing diagram- [x] `compose`: missing diagram- [x] `cache`: missing diagram- [x] `cast`: missing diagram- [x] `delay`: missing diagram- [x] `delaysubscription`: missing diagram- [x] `dematerialize`: missing diagram- [x] `doaftersuccess`: missing diagram- [x] `doafterterminate`: indicate error case- [x] `dofinally`: missing diagram- [x] `doonsubscibe`: missing diagram- [x] `doonsuccess`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonerror`: missing diagram- [x] `doondispose`: missing diagram- [x] `filter`: one source item indicate both true and false outcomes- [x] `flatmappublisher`: operator name- [x] `blockingget`: missing diagram- [x] `lift`: missing diagram- [x] `contains`: missing diagram- [x] `mergewith`: indicate backpressure- [x] `onerrorreturn`: indicate item is the result of a function call with the original error- [x] `onerrorreturnitem`: use the previous `onerrorreturn` diagram change name in box- [x] `onerrorresumenext`: diagram should have one item and no complete marker- [x] `onerrorresumewith`: operator name- [x] `onterminatedetach`: missing diagram- [x] `repeat`: missing diagram- [x] `repeatwhen`: missing diagram- [x] `repeatuntil`: missing diagram- [x] `retry`: missing diagram- [x] `retrywhen`: missing diagram- [x] `subscribe`: missing diagram- [x] `subscribewith`: missing diagram?- [x] `takeuntil`: fix item count in main and other sources indicate all other signal types- [x] `timeout`: missing diagram- [x] `to`: missing diagram- [x] `tocompletable`: diagram is stretched- [x] `toflowable`: operator name in box indicate backpressure- [x] `tofuture`: indicate future remove the blocking text- [x] `tomaybe`: operator name in box indicate both outcomes with proper signal types- [x] `unsubscribeon`: missing diagram- [x] `test`: missing diagram?;i see most marbles in the javadoc live under this folder:  ` are other locations accepted - eg can i upload it in google drive for example and open a pr with the updated path in the javadoc directly? heres a few i created:![single_dofinally]( || images have to be hosted by the project besides google drive tends to change the service terms and images may become inaccessible (ive lost resource location this way in another project) about your images:- `dofinally`:   - error should be a red x  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here- `doondispose`  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here  - `unsubscribe` should be `dispose`- `doonsubscribe`  - the star should be in between the operator box and the bottom timeline- `doonsuccess`: ok || updated images from #5987 now in the repository:![dofinally]( || how are these made? are there any written guidelines? i can try making some when i have time || there is a mac only omnigraffle im on windows and i use excel shapes and arrows || @aarjavp  i used [this template]( as a staring point its for **inkscape** software which worked nicely on my mac || hi all can you please tell me is this marble acceptable for the `filter` operator?as i havent contributed to this project so far i would like to take it easy and slow :) let me know what should i change so that i have a reference for future marbles![filter]( || not really there is no | in single please have a look at diagrams above:  || @akarnokd can we update this issue please? its getting a bit messy and hard to follow what has been completed || @umfsimke it has been only you lately that worked on this ||;1;0;use proper urls for marble diagrams;
6087;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add marbles for single.from operators;here are marbles for  fromcallable    frompublisher  and  fromobservable  operators from #5788;;5788.0;add marbles for singlefrom operators;here are marbles for `fromcallable` `frompublisher` and `fromobservable` operators from #5788 marble for `fromcallable`![fromcallable]( for `frompublisher`![frompublisher]( for `fromobservable`![fromobservable](https://rawentcom/umfsimke/rxjava/images/images/fromobservablepng); merging 6087 ;3x: single incorrect or missing images (tracking issue);-  `amb`: missing diagram-  `ambarray`: missing diagram-  `concat(arg)`: missing diagram-  `concat(s1s4)`: add 3rd and 4th source indicate backpressure-  `concatarray`: missing diagram-  `concatarrayeager`: missing diagram-  `concateager`: missing diagram-  `create`: missing diagram-  `defer`: missing diagram-  `error(callable)`: missing diagram- [x] `error(throwable)`: indicate error in the box- [x] `fromcallable`: missing diagram- [x] `frompublisher`: missing diagram- [x] `fromobservable`: missing diagram- [x] `merge`: missing diagram- [x] `merge(singlesource<singlesource<t>>)`: indicate main element is a `singlesource`- [x] `merge(s1s4)`: add 3rd and 4th source indicate backpressure- [x] `mergedelayerror`: iterable/publisher missing diagrams s2s3s4 wrong diagrams- [x] `never`: missing diagram- [x] `timer`: missing diagram- [x] `equals`: missing diagram- [x] `unsafecreate`: missing diagram- [x] `using`: missing diagram- [x] `wrap`: missing diagram- [x] `ambwith`: missing diagram- [x] `as`: missing diagram- [x] `hide`: missing diagram- [x] `compose`: missing diagram- [x] `cache`: missing diagram- [x] `cast`: missing diagram- [x] `delay`: missing diagram- [x] `delaysubscription`: missing diagram- [x] `dematerialize`: missing diagram- [x] `doaftersuccess`: missing diagram- [x] `doafterterminate`: indicate error case- [x] `dofinally`: missing diagram- [x] `doonsubscibe`: missing diagram- [x] `doonsuccess`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonerror`: missing diagram- [x] `doondispose`: missing diagram- [x] `filter`: one source item indicate both true and false outcomes- [x] `flatmappublisher`: operator name- [x] `blockingget`: missing diagram- [x] `lift`: missing diagram- [x] `contains`: missing diagram- [x] `mergewith`: indicate backpressure- [x] `onerrorreturn`: indicate item is the result of a function call with the original error- [x] `onerrorreturnitem`: use the previous `onerrorreturn` diagram change name in box- [x] `onerrorresumenext`: diagram should have one item and no complete marker- [x] `onerrorresumewith`: operator name- [x] `onterminatedetach`: missing diagram- [x] `repeat`: missing diagram- [x] `repeatwhen`: missing diagram- [x] `repeatuntil`: missing diagram- [x] `retry`: missing diagram- [x] `retrywhen`: missing diagram- [x] `subscribe`: missing diagram- [x] `subscribewith`: missing diagram?- [x] `takeuntil`: fix item count in main and other sources indicate all other signal types- [x] `timeout`: missing diagram- [x] `to`: missing diagram- [x] `tocompletable`: diagram is stretched- [x] `toflowable`: operator name in box indicate backpressure- [x] `tofuture`: indicate future remove the blocking text- [x] `tomaybe`: operator name in box indicate both outcomes with proper signal types- [x] `unsubscribeon`: missing diagram- [x] `test`: missing diagram?;i see most marbles in the javadoc live under this folder:  ` are other locations accepted - eg can i upload it in google drive for example and open a pr with the updated path in the javadoc directly? heres a few i created:![single_dofinally]( || images have to be hosted by the project besides google drive tends to change the service terms and images may become inaccessible (ive lost resource location this way in another project) about your images:- `dofinally`:   - error should be a red x  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here- `doondispose`  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here  - `unsubscribe` should be `dispose`- `doonsubscribe`  - the star should be in between the operator box and the bottom timeline- `doonsuccess`: ok || updated images from #5987 now in the repository:![dofinally]( || how are these made? are there any written guidelines? i can try making some when i have time || there is a mac only omnigraffle im on windows and i use excel shapes and arrows || @aarjavp  i used [this template]( as a staring point its for **inkscape** software which worked nicely on my mac || hi all can you please tell me is this marble acceptable for the `filter` operator?as i havent contributed to this project so far i would like to take it easy and slow :) let me know what should i change so that i have a reference for future marbles![filter]( || not really there is no | in single please have a look at diagrams above:  || @akarnokd can we update this issue please? its getting a bit messy and hard to follow what has been completed || @umfsimke it has been only you lately that worked on this ||;1;0;add marbles for singlefrom operators;
6090;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add missing completable marbles (+17  07/18a);this pr adds marble diagrams to various  completable  operators:;;0;2x: add missing completable marbles (+17 07/18a);this pr adds marble diagrams to various `completable` operators:#### wrap( using![image]( ambwith![image]( andthen![image]( as to![image]( compose![image]( cache![image]( blockingawait![image]( blockingget![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableblockinggetpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableblockinggettpng); merging 6090  < ;;;;1;1;2x: add missing completable marbles (07/18a);
6091;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add marbles for single.amb operators;here are operators for  amb  and  ambarray  from #5788;;5788.0;add marbles for singleamb operators;here are operators for `amb` and `ambarray` from #5788 marble for `amb`:![amb]( for `ambarray`:![ambarray](https://rawentcom/umfsimke/rxjava/images/images/ambarraypng); merging 6091 ;3x: single incorrect or missing images (tracking issue);-  `amb`: missing diagram-  `ambarray`: missing diagram-  `concat(arg)`: missing diagram-  `concat(s1s4)`: add 3rd and 4th source indicate backpressure-  `concatarray`: missing diagram-  `concatarrayeager`: missing diagram-  `concateager`: missing diagram-  `create`: missing diagram-  `defer`: missing diagram-  `error(callable)`: missing diagram- [x] `error(throwable)`: indicate error in the box- [x] `fromcallable`: missing diagram- [x] `frompublisher`: missing diagram- [x] `fromobservable`: missing diagram- [x] `merge`: missing diagram- [x] `merge(singlesource<singlesource<t>>)`: indicate main element is a `singlesource`- [x] `merge(s1s4)`: add 3rd and 4th source indicate backpressure- [x] `mergedelayerror`: iterable/publisher missing diagrams s2s3s4 wrong diagrams- [x] `never`: missing diagram- [x] `timer`: missing diagram- [x] `equals`: missing diagram- [x] `unsafecreate`: missing diagram- [x] `using`: missing diagram- [x] `wrap`: missing diagram- [x] `ambwith`: missing diagram- [x] `as`: missing diagram- [x] `hide`: missing diagram- [x] `compose`: missing diagram- [x] `cache`: missing diagram- [x] `cast`: missing diagram- [x] `delay`: missing diagram- [x] `delaysubscription`: missing diagram- [x] `dematerialize`: missing diagram- [x] `doaftersuccess`: missing diagram- [x] `doafterterminate`: indicate error case- [x] `dofinally`: missing diagram- [x] `doonsubscibe`: missing diagram- [x] `doonsuccess`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonerror`: missing diagram- [x] `doondispose`: missing diagram- [x] `filter`: one source item indicate both true and false outcomes- [x] `flatmappublisher`: operator name- [x] `blockingget`: missing diagram- [x] `lift`: missing diagram- [x] `contains`: missing diagram- [x] `mergewith`: indicate backpressure- [x] `onerrorreturn`: indicate item is the result of a function call with the original error- [x] `onerrorreturnitem`: use the previous `onerrorreturn` diagram change name in box- [x] `onerrorresumenext`: diagram should have one item and no complete marker- [x] `onerrorresumewith`: operator name- [x] `onterminatedetach`: missing diagram- [x] `repeat`: missing diagram- [x] `repeatwhen`: missing diagram- [x] `repeatuntil`: missing diagram- [x] `retry`: missing diagram- [x] `retrywhen`: missing diagram- [x] `subscribe`: missing diagram- [x] `subscribewith`: missing diagram?- [x] `takeuntil`: fix item count in main and other sources indicate all other signal types- [x] `timeout`: missing diagram- [x] `to`: missing diagram- [x] `tocompletable`: diagram is stretched- [x] `toflowable`: operator name in box indicate backpressure- [x] `tofuture`: indicate future remove the blocking text- [x] `tomaybe`: operator name in box indicate both outcomes with proper signal types- [x] `unsubscribeon`: missing diagram- [x] `test`: missing diagram?;i see most marbles in the javadoc live under this folder:  ` are other locations accepted - eg can i upload it in google drive for example and open a pr with the updated path in the javadoc directly? heres a few i created:![single_dofinally]( || images have to be hosted by the project besides google drive tends to change the service terms and images may become inaccessible (ive lost resource location this way in another project) about your images:- `dofinally`:   - error should be a red x  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here- `doondispose`  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here  - `unsubscribe` should be `dispose`- `doonsubscribe`  - the star should be in between the operator box and the bottom timeline- `doonsuccess`: ok || updated images from #5987 now in the repository:![dofinally]( || how are these made? are there any written guidelines? i can try making some when i have time || there is a mac only omnigraffle im on windows and i use excel shapes and arrows || @aarjavp  i used [this template]( as a staring point its for **inkscape** software which worked nicely on my mac || hi all can you please tell me is this marble acceptable for the `filter` operator?as i havent contributed to this project so far i would like to take it easy and slow :) let me know what should i change so that i have a reference for future marbles![filter]( || not really there is no | in single please have a look at diagrams above:  || @akarnokd can we update this issue please? its getting a bit messy and hard to follow what has been completed || @umfsimke it has been only you lately that worked on this ||;1;0;add marbles for singleamb operators;
6095;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add marbles for single.timer  single.defer and single.toxxx operators;here are marbles for  defer    timer(delay  unit)    timer(delay  unit  scheduler)    toflowable    tomaybe    tofuture  operators in #5788;;5788.0;add marbles for singletimer singledefer and singletoxxx operators;here are marbles for `defer` `timer(delay unit)` `timer(delay unit scheduler)` `toflowable` `tomaybe` `tofuture` operators in #5788 marble for `defer`:![defer]( for `timer(delay unit)`:![timer]( for `timer(delay unit scheduler)`:![timerscheduler]( for `tofuture` although for this one i believe we should add case when there is no event sent from single as there will be timeout exception thrown:![tofuture]( for `tomaybe`:![tomaybe]( for `toflowable` although here i didnt figured out what will happen if we request more than 1 event from flowable:![toflowable](https://rawentcom/umfsimke/rxjava/images/images/toflowablepng);defer: i would have drawn it with a curly brace listing the 3 options below each other please add the subscribe() indicators as welltofuture: i indicate future<t> with a 6-sided shape and indicate get() call and a return see completablefromfuture for an exampletoflowable: simply indicate request(n) any positive n has the same effect with this operator however an error is always pushed through even without a request just remove the request(1) from that side of the diagram ||  merging 6095  < ;3x: single incorrect or missing images (tracking issue);-  `amb`: missing diagram-  `ambarray`: missing diagram-  `concat(arg)`: missing diagram-  `concat(s1s4)`: add 3rd and 4th source indicate backpressure-  `concatarray`: missing diagram-  `concatarrayeager`: missing diagram-  `concateager`: missing diagram-  `create`: missing diagram-  `defer`: missing diagram-  `error(callable)`: missing diagram- [x] `error(throwable)`: indicate error in the box- [x] `fromcallable`: missing diagram- [x] `frompublisher`: missing diagram- [x] `fromobservable`: missing diagram- [x] `merge`: missing diagram- [x] `merge(singlesource<singlesource<t>>)`: indicate main element is a `singlesource`- [x] `merge(s1s4)`: add 3rd and 4th source indicate backpressure- [x] `mergedelayerror`: iterable/publisher missing diagrams s2s3s4 wrong diagrams- [x] `never`: missing diagram- [x] `timer`: missing diagram- [x] `equals`: missing diagram- [x] `unsafecreate`: missing diagram- [x] `using`: missing diagram- [x] `wrap`: missing diagram- [x] `ambwith`: missing diagram- [x] `as`: missing diagram- [x] `hide`: missing diagram- [x] `compose`: missing diagram- [x] `cache`: missing diagram- [x] `cast`: missing diagram- [x] `delay`: missing diagram- [x] `delaysubscription`: missing diagram- [x] `dematerialize`: missing diagram- [x] `doaftersuccess`: missing diagram- [x] `doafterterminate`: indicate error case- [x] `dofinally`: missing diagram- [x] `doonsubscibe`: missing diagram- [x] `doonsuccess`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonerror`: missing diagram- [x] `doondispose`: missing diagram- [x] `filter`: one source item indicate both true and false outcomes- [x] `flatmappublisher`: operator name- [x] `blockingget`: missing diagram- [x] `lift`: missing diagram- [x] `contains`: missing diagram- [x] `mergewith`: indicate backpressure- [x] `onerrorreturn`: indicate item is the result of a function call with the original error- [x] `onerrorreturnitem`: use the previous `onerrorreturn` diagram change name in box- [x] `onerrorresumenext`: diagram should have one item and no complete marker- [x] `onerrorresumewith`: operator name- [x] `onterminatedetach`: missing diagram- [x] `repeat`: missing diagram- [x] `repeatwhen`: missing diagram- [x] `repeatuntil`: missing diagram- [x] `retry`: missing diagram- [x] `retrywhen`: missing diagram- [x] `subscribe`: missing diagram- [x] `subscribewith`: missing diagram?- [x] `takeuntil`: fix item count in main and other sources indicate all other signal types- [x] `timeout`: missing diagram- [x] `to`: missing diagram- [x] `tocompletable`: diagram is stretched- [x] `toflowable`: operator name in box indicate backpressure- [x] `tofuture`: indicate future remove the blocking text- [x] `tomaybe`: operator name in box indicate both outcomes with proper signal types- [x] `unsubscribeon`: missing diagram- [x] `test`: missing diagram?;i see most marbles in the javadoc live under this folder:  ` are other locations accepted - eg can i upload it in google drive for example and open a pr with the updated path in the javadoc directly? heres a few i created:![single_dofinally]( || images have to be hosted by the project besides google drive tends to change the service terms and images may become inaccessible (ive lost resource location this way in another project) about your images:- `dofinally`:   - error should be a red x  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here- `doondispose`  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here  - `unsubscribe` should be `dispose`- `doonsubscribe`  - the star should be in between the operator box and the bottom timeline- `doonsuccess`: ok || updated images from #5987 now in the repository:![dofinally]( || how are these made? are there any written guidelines? i can try making some when i have time || there is a mac only omnigraffle im on windows and i use excel shapes and arrows || @aarjavp  i used [this template]( as a staring point its for **inkscape** software which worked nicely on my mac || hi all can you please tell me is this marble acceptable for the `filter` operator?as i havent contributed to this project so far i would like to take it easy and slow :) let me know what should i change so that i have a reference for future marbles![filter]( || not really there is no | in single please have a look at diagrams above:  || @akarnokd can we update this issue please? its getting a bit messy and hard to follow what has been completed || @umfsimke it has been only you lately that worked on this ||;1;0;correct image height for marbles;
6096;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: improve completable.delay operator internals;this pr improves the  completable.delay()  operator internals  reducing allocation and indirection.;;0;2x: improve completabledelay operator internals;this pr improves the `completabledelay()` operator internals reducing allocation and indirection; merging 6096  < ;;;;1;1;2x: improve completabledelay operator internals;
6097;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add missing completable marbles (+19  07/19a);this pr add even more missing marbles to  completable  (tracked by #5789):;;5789.0;2x: add missing completable marbles (+19 07/19a);this pr add even more missing marbles to `completable` (tracked by #5789):#### delay( doonx![image]( dofinally![image]( onerrorcomplete![image]( onerrorresumenext![image]( onterminatedetach![image]( mergewith![image]( concatwith![image]( observeon![image]( hide![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completablehidepng); merging 6097 ;2x: completable missing or incorrect marbles (tracking issue);-  `ambarray`: missing diagram-  `amb`: missing diagram-  `complete`: missing diagram-  `concatarray`: missing diagram-  `concat`: missing diagram-  `create`: missing diaglam-  `unsafecreate`: missing diagram-  `defer`: missing diagram-  `error`: missing diagram-  `fromaction`: missing diagram- [x] `fromcallable`: missing diagram- [x] `fromfuture`: missing diagram- [x] `fromobservable`: missing diagram- [x] `frompublisher`: missing diagram- [x] `fromrunnable`: missing diagram- [x] `fromsingle`: missing diagram- [x] `mergearray`: missing diagram- [x] `merge`: missing diagram- [x] `mergearraydelayerror`: missing diagram- [x] `mergedelayerror`: missing diagram- [x] `never`: missing diagram- [x] `timer`: missing diagram- [x] `using`: missing diagram- [x] `wrap`: missing diagram- [x] `ambwith`: missing diagram- [x] `andthen`: missing diagram- [x] `as`: missing diagram- [x] `blockingawait`: missing diagram- [x] `blockingget`: missing diagram- [x] `cache`: missing diagram- [x] `compose`: missing diagram- [x] `concatwith`: missing diagram- [x] `delay`: missing diagram- [x] `dooncomplete`: missing diagram- [x] `doondispose`: missing diagram- [x] `doonerror`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonlifecycle`: missing diagram- [x] `doonsubscribe`: missing diagram- [x] `doonterminate`: missing diagram- [x] `doafterterminate`: missing diagram- [x] `dofinally`: missing diagram- [x] `lift`: missing diagram- [x] `mergewith`: missing diagram- [x] `observeon`: missing diagram- [x] `onerrorcomplete`: missing diagram- [x] `onerrorresumenext`: missing diagram- [x] `onterminatedetach`: missing diagram- [x] `repeat`: missing diagram- [x] `repeatuntil`: missing diagram- [x] `repeatwhen`: missing diagram- [x] `retry`: missing diagram- [x] `retrywhen`: missing diagram- [x] `startwith`: missing diagram- [x] `hide`: missing diagram- [x] `subscribe`: missing diagram- [x] `subscribewith`: missing diagram?- [x] `subscribeon`: missing diagram- [x] `timeout`: missing diagram- [x] `to`: missing diagram- [x] `toflowable`: missing diagram- [x] `tomaybe`: wrong operator name in box- [x] `toobservable`: use the old diagram of `tomaybe`- [x] `tosingle`: missing diagram- [x] `tosingledefault`: missing diagram- [x] `unsubscribeon`: missing diagram- [x] `test`: missing diagram;done ||;1;0;2x: add missing completable marbles (+19 07/19a);
6098;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: several more completable marbles (7/19b);this pr adds a couple of more marble diagrams to  completable  (#5789):;;5789.0;2x: several more completable marbles (7/19b);this pr adds a couple of more marble diagrams to `completable` (#5789):#### subscribeon( unsubscribeon![image]( tosingle tosingledefault![image]( toflowable![image]( tomaybe![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completabletomaybepng); merging 6098 ;2x: completable missing or incorrect marbles (tracking issue);-  `ambarray`: missing diagram-  `amb`: missing diagram-  `complete`: missing diagram-  `concatarray`: missing diagram-  `concat`: missing diagram-  `create`: missing diaglam-  `unsafecreate`: missing diagram-  `defer`: missing diagram-  `error`: missing diagram-  `fromaction`: missing diagram- [x] `fromcallable`: missing diagram- [x] `fromfuture`: missing diagram- [x] `fromobservable`: missing diagram- [x] `frompublisher`: missing diagram- [x] `fromrunnable`: missing diagram- [x] `fromsingle`: missing diagram- [x] `mergearray`: missing diagram- [x] `merge`: missing diagram- [x] `mergearraydelayerror`: missing diagram- [x] `mergedelayerror`: missing diagram- [x] `never`: missing diagram- [x] `timer`: missing diagram- [x] `using`: missing diagram- [x] `wrap`: missing diagram- [x] `ambwith`: missing diagram- [x] `andthen`: missing diagram- [x] `as`: missing diagram- [x] `blockingawait`: missing diagram- [x] `blockingget`: missing diagram- [x] `cache`: missing diagram- [x] `compose`: missing diagram- [x] `concatwith`: missing diagram- [x] `delay`: missing diagram- [x] `dooncomplete`: missing diagram- [x] `doondispose`: missing diagram- [x] `doonerror`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonlifecycle`: missing diagram- [x] `doonsubscribe`: missing diagram- [x] `doonterminate`: missing diagram- [x] `doafterterminate`: missing diagram- [x] `dofinally`: missing diagram- [x] `lift`: missing diagram- [x] `mergewith`: missing diagram- [x] `observeon`: missing diagram- [x] `onerrorcomplete`: missing diagram- [x] `onerrorresumenext`: missing diagram- [x] `onterminatedetach`: missing diagram- [x] `repeat`: missing diagram- [x] `repeatuntil`: missing diagram- [x] `repeatwhen`: missing diagram- [x] `retry`: missing diagram- [x] `retrywhen`: missing diagram- [x] `startwith`: missing diagram- [x] `hide`: missing diagram- [x] `subscribe`: missing diagram- [x] `subscribewith`: missing diagram?- [x] `subscribeon`: missing diagram- [x] `timeout`: missing diagram- [x] `to`: missing diagram- [x] `toflowable`: missing diagram- [x] `tomaybe`: wrong operator name in box- [x] `toobservable`: use the old diagram of `tomaybe`- [x] `tosingle`: missing diagram- [x] `tosingledefault`: missing diagram- [x] `unsubscribeon`: missing diagram- [x] `test`: missing diagram;done ||;1;0;2x: several more completable marbles (7/19b);
"6099;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;update testhelper.java: trivial typo fix;thank you for contributing to rxjava. before pressing the  create pull request  button  please consider the following points:;;0;update testhelperjava: trivial typo fix;""thank you for contributing to rxjava before pressing the """"create pull request"""" button please consider the following points:  -  please give a description about what and why you are contributing even if its trivialjust a small typo fix i grepped for the same misspelling and it only appeared in this file  -  please include the issue list number(s) or other pr numbers in the description if you are contributing in response to thosen/a  -  please include a reasonable set of unit tests if you contribute new code or change an existing one if you contribute an operator (if applicable) please make sure you have tests for working with an `empty` `just` `range` of values as well as an `error` source with and/or without backpressure and see if unsubscription/cancellation propagates correctlyn/a""; merging 6099 ;;;;1;1;update testhelperjava: trivial typo fix;"
6101;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: final set of missing completable marbles (+26);this pr contains the final set of missing  completable  marbles (#5789):;;5789.0;2x: final set of missing completable marbles (+26);this pr contains the final set of missing `completable` marbles (#5789):#### repeat( repeatuntil![image]( repeatwhen![image]( retry![image]( retrywhen![image]( startwith![image]( timeout![image]( create![image]( unsafecreate![image]( lift![image]( subscribe![image]( subscribewith![image]( test![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completabletestpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completabletestbpng); merging 6101 ;2x: completable missing or incorrect marbles (tracking issue);-  `ambarray`: missing diagram-  `amb`: missing diagram-  `complete`: missing diagram-  `concatarray`: missing diagram-  `concat`: missing diagram-  `create`: missing diaglam-  `unsafecreate`: missing diagram-  `defer`: missing diagram-  `error`: missing diagram-  `fromaction`: missing diagram- [x] `fromcallable`: missing diagram- [x] `fromfuture`: missing diagram- [x] `fromobservable`: missing diagram- [x] `frompublisher`: missing diagram- [x] `fromrunnable`: missing diagram- [x] `fromsingle`: missing diagram- [x] `mergearray`: missing diagram- [x] `merge`: missing diagram- [x] `mergearraydelayerror`: missing diagram- [x] `mergedelayerror`: missing diagram- [x] `never`: missing diagram- [x] `timer`: missing diagram- [x] `using`: missing diagram- [x] `wrap`: missing diagram- [x] `ambwith`: missing diagram- [x] `andthen`: missing diagram- [x] `as`: missing diagram- [x] `blockingawait`: missing diagram- [x] `blockingget`: missing diagram- [x] `cache`: missing diagram- [x] `compose`: missing diagram- [x] `concatwith`: missing diagram- [x] `delay`: missing diagram- [x] `dooncomplete`: missing diagram- [x] `doondispose`: missing diagram- [x] `doonerror`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonlifecycle`: missing diagram- [x] `doonsubscribe`: missing diagram- [x] `doonterminate`: missing diagram- [x] `doafterterminate`: missing diagram- [x] `dofinally`: missing diagram- [x] `lift`: missing diagram- [x] `mergewith`: missing diagram- [x] `observeon`: missing diagram- [x] `onerrorcomplete`: missing diagram- [x] `onerrorresumenext`: missing diagram- [x] `onterminatedetach`: missing diagram- [x] `repeat`: missing diagram- [x] `repeatuntil`: missing diagram- [x] `repeatwhen`: missing diagram- [x] `retry`: missing diagram- [x] `retrywhen`: missing diagram- [x] `startwith`: missing diagram- [x] `hide`: missing diagram- [x] `subscribe`: missing diagram- [x] `subscribewith`: missing diagram?- [x] `subscribeon`: missing diagram- [x] `timeout`: missing diagram- [x] `to`: missing diagram- [x] `toflowable`: missing diagram- [x] `tomaybe`: wrong operator name in box- [x] `toobservable`: use the old diagram of `tomaybe`- [x] `tosingle`: missing diagram- [x] `tosingledefault`: missing diagram- [x] `unsubscribeon`: missing diagram- [x] `test`: missing diagram;done ||;1;0;2x: final set of missing completable marbles;
6103;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix completable mergex javadoc missing dt before dd;couple of the  <dt><b>error handling:</b></dt>  subheaders were missing from various  completable.mergex  operators in the javadocs.;;0;2x: fix completable mergex javadoc missing dt before dd;couple of the `<dt><b>error handling:</b></dt>` subheaders were missing from various `completablemergex` operators in the javadocs; merging 6103 ;;;;1;1;2x: fix completable mergex javadoc missing dt before dd;
6104;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fixing javadoc s code example of observable#lift.;code example in javadoc for observable#lift seems not compilable in 2.x.;;0;fixing javadocs code example of observable#lift;code example in javadoc for observable#lift seems not compilable in 2xalso parameter name of observableoperator#apply should be downstream i think; merging 6104  < ;;;;1;1;fixing javadocs code example of observable#lift;
6105;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.2: promote all experimental/beta api to standard;this pr promotes all  @experimental / @beta  apis to standard with version number **2.2**.;;0;22: promote all experimental/beta api to standard;this pr promotes all `@experimental`/`@beta` apis to standard with version number **22**(in addition it also fixes remnant markers from earlier promotions in internal files)### operators- **`flowable`**:   - `as`  - `blockingsubscribe( prefetch)` + 2  - `concatmapcompletable` + 1  - `concatmapcompletabledelayerror` + 2  - `concatmapmaybe` + 1  - `concatmapmaybedelayerror` + 2  - `concatmapsingle` + 1  - `concatmapsingledelayerror` + 2  - `concatwith` + 2  - `groupby( evictingmapfactory)`  - `limit`  - `mergewith` + 2  - `parallel` + 2  - `subscribe(flowablesubscriber)`  - `subscribeon( requeston)`  - `switchmapcompletable`  - `switchmapcompletabledelayerror`  - `switchmapmaybe`  - `switchmapmaybedelayerror`  - `switchmapsingle`  - `switchmapsingledelayerror`  - `throttlelatest` + 3  - **`observable`**:  - `as`  - `concatmapcompletable` + 1  - `concatmapcompletabledelayerror` + 2  - `concatmapmaybe` + 1  - `concatmapmaybedelayerror` + 2  - `concatmapsingle` + 1  - `concatmapsingledelayerror` + 2  - `concatwith` + 2  - `mergewith` + 2  - `switchmapcompletable`  - `switchmapcompletabledelayerror`  - `switchmapmaybe`  - `switchmapmaybedelayerror`  - `switchmapsingle`  - `switchmapsingledelayerror`  - `throttlelatest` + 3  - **`maybe`**:  - `mergedelayerror(publisher int)`  - `as`  - `switchifempty`- **`single`**:  - `mergedelayerror` + 4  - `as`  - `delay( delayerror)` + 1  - `onterminatedetach`  - `retry(long predicate)`  - `unsubscribeon`- **`completable`**:   - `frommaybe`  - `as`  - `onterminatedetach`  - `retry(long predicate)`  - `takeuntil`- **`connectableflowable`**:  - `refcount` + 4- **`connectableobservable`**:  - `refcount` + 4- **`parallelflowable`**:  - `as`  - `map(errorhandling)` + 1  - `filter(errorhandling)` + 1  - `doonnext(errorhandling)` + 1  - `sequentialdelayerror` + 1- **`testsubscriber`/`testobserver`** (**`basetestconsumer`**):  - `assertvalueat`  - `assertvaluesonly`  - `assertvaluesetonly`  - `assertvaluesequenceonly`- **`rxjavaplugins`**:  - `setonparallelassembly`  - `getonparallelassembly`  - `onassembly(parallelflowable)`- **`subject`s/`flowableprocessor`s**:  - `behaviorprocessoroffer`  - `publishprocessoroffer`   - `replayprocessorcleanupbuffer`  - `replaysubjectcleanupbuffer`  - `unicastprocessorcreate( delayerror)` + 1  - `unicastsubjectcreate( delayerror)` + 1### interfaces- `completableconverter`- `completableemitter`- `flowableconverter`- `flowableemitter`- `flowablesubscriber`- `maybeconverter`- `maybeemitter`- `observableconverter`- `observableemitter`- `singleconverter`- `singleemitter`- `lambdaconsumerintrospection`- `parallelflowableconverter`- `paralleltransformer`- `schedulerrunnableintrospection`### enums- `parallelfailurehandling`### classes- `onerrornotimplementedexception`- `protocolviolationexception`- `undeliverableexception`- `parallelflowable`- `multicastprocessor`### other components- `schedulersupportsingle`; merging 6105  < ;;;;1;1;2x: promote all experimental/beta api to standard;
"6119;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: test cleanup;this pr cleans up the tests:;;0;2x: test cleanup;this pr cleans up the tests:- reduce stacktrace printouts due to undeliverable errors and turn them into assertions instead- rename local variables & arguments of `subscriber`s from `o` and `observer` to the proper `subscriber`- rename local variables & arguments of `flowable`s from `o` and `observable` to the more appropriate `f` and `flowable`- add more naming tests to `checklocalvariablesintests` to support the previous two points;"" merging 6119  <  "";;;;1;1;more time to multicastprocessorrefcountedtcktest;"
6121;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: flowable.onerrorresumenext improvements;this pr improves the structure of the  onerrorresumenext  operator by inlining the subscription-arbiter and not updating the outstanding request amount one by one. the change reduces the per-item overhead  some indirection cost and the memory cost (+8 bytes for the field  -16/-28 bytes due to the inlined header+field);;0;2x: flowableonerrorresumenext improvements;this pr improves the structure of the `onerrorresumenext` operator by inlining the subscription-arbiter and not updating the outstanding request amount one by one the change reduces the per-item overhead some indirection cost and the memory cost (+8 bytes for the field -16/-28 bytes due to the inlined header+field)in addition the null-check has been inlined into the resume function call so that the crash will now include the original exception as well as the npe in a `compositeexception` just like almost all other cases throughout rxjava; merging 6121 ;;;;1;1;2x: flowableonerrorresumenext improvements;
6123;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: improve completable.onerrorresumenext internals;this pr improves the internals of the  completable.onerrorresumenext  operator:;;0;2x: improve completableonerrorresumenext internals;this pr improves the internals of the `completableonerrorresumenext` operator:- inline the `disposable` management- reuse the same instance for observing the fallback `completablesource`- report null return of the `errormapper` the same way as a crash via `compositeexception`- the exceptions in the composite should be in the order **original** -> **mapper exception**; merging 6123 ;;;;1;1;use objecthelper;
6129;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: cleaunp - rename fields to upstream and downstream;this pr cleans up the field namings and some local variable namings:;;0;2x: cleaunp - rename fields to upstream and downstream;this pr cleans up the field namings and some local variable namings:- use `upstream` for the connection `disposable` or `subscription` instead of `d` `s` etc including `atomicreference<*>` declarations- use `downstream` for the consumer field name in operators instead of `actual` for example- fix one-two letter abbreviated naming to match the type such as `disposable s` -> `disposable d` etcthe `checklocalvariablesintests` has been extended with the relevant regexp checks; merging 6129 ;;;;1;1;make links in maybeemittersetdisposable;
6137;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add marbles for single.concat operator;here are marbles for  concat(iterable)    concat(publisher)    concat(publisher  prefetch)    concat(observable)     concat(source1  source2)    concat(source1  source2  source3)    concat(source1  source2  source3  source4)  and  concatarray  operators that should close them at #5788 .;;5788.0;2x: add marbles for singleconcat operator;here are marbles for `concat(iterable)` `concat(publisher)` `concat(publisher prefetch)` `concat(observable)`  `concat(source1 source2)` `concat(source1 source2 source3)` `concat(source1 source2 source3 source4)` and `concatarray` operators that should close them at #5788 marble for `concat(iterable)`![concatiterable]( for `concat(publisher)`![concatpublisher]( for `concat(publisher prefetch)`![concatpublishern]( for `concat(observable)`![concatobservable]( for `concat(source1 source2)`![concat2]( for `concat(source1 source2 source3)`![concat3]( for `concat(source1 source2 source3 source4)`![concat4]( for `concatarray`![concatarray]( pay attention to file names in javadoc as i was not sure how to name `concat(iterable)` so ive added at the end `i` for `concat(observable)` ive added `o` for `concat(source1 source2 source3)` and `concat(source1 source2 source3 source4)` ive used `n` and `m` as they are numerical valuesalso is there an error in `concat(publisher)` and `concat(publisher prefetch)` with `request()` commands? i did used as a reference `completableconcat(publisher)` marble but i do not understand why do we have `request(1)` after first event as we already requested prefetching of multiple ones is it because others are still not produced?thanks; merging 6137 ;3x: single incorrect or missing images (tracking issue);-  `amb`: missing diagram-  `ambarray`: missing diagram-  `concat(arg)`: missing diagram-  `concat(s1s4)`: add 3rd and 4th source indicate backpressure-  `concatarray`: missing diagram-  `concatarrayeager`: missing diagram-  `concateager`: missing diagram-  `create`: missing diagram-  `defer`: missing diagram-  `error(callable)`: missing diagram- [x] `error(throwable)`: indicate error in the box- [x] `fromcallable`: missing diagram- [x] `frompublisher`: missing diagram- [x] `fromobservable`: missing diagram- [x] `merge`: missing diagram- [x] `merge(singlesource<singlesource<t>>)`: indicate main element is a `singlesource`- [x] `merge(s1s4)`: add 3rd and 4th source indicate backpressure- [x] `mergedelayerror`: iterable/publisher missing diagrams s2s3s4 wrong diagrams- [x] `never`: missing diagram- [x] `timer`: missing diagram- [x] `equals`: missing diagram- [x] `unsafecreate`: missing diagram- [x] `using`: missing diagram- [x] `wrap`: missing diagram- [x] `ambwith`: missing diagram- [x] `as`: missing diagram- [x] `hide`: missing diagram- [x] `compose`: missing diagram- [x] `cache`: missing diagram- [x] `cast`: missing diagram- [x] `delay`: missing diagram- [x] `delaysubscription`: missing diagram- [x] `dematerialize`: missing diagram- [x] `doaftersuccess`: missing diagram- [x] `doafterterminate`: indicate error case- [x] `dofinally`: missing diagram- [x] `doonsubscibe`: missing diagram- [x] `doonsuccess`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonerror`: missing diagram- [x] `doondispose`: missing diagram- [x] `filter`: one source item indicate both true and false outcomes- [x] `flatmappublisher`: operator name- [x] `blockingget`: missing diagram- [x] `lift`: missing diagram- [x] `contains`: missing diagram- [x] `mergewith`: indicate backpressure- [x] `onerrorreturn`: indicate item is the result of a function call with the original error- [x] `onerrorreturnitem`: use the previous `onerrorreturn` diagram change name in box- [x] `onerrorresumenext`: diagram should have one item and no complete marker- [x] `onerrorresumewith`: operator name- [x] `onterminatedetach`: missing diagram- [x] `repeat`: missing diagram- [x] `repeatwhen`: missing diagram- [x] `repeatuntil`: missing diagram- [x] `retry`: missing diagram- [x] `retrywhen`: missing diagram- [x] `subscribe`: missing diagram- [x] `subscribewith`: missing diagram?- [x] `takeuntil`: fix item count in main and other sources indicate all other signal types- [x] `timeout`: missing diagram- [x] `to`: missing diagram- [x] `tocompletable`: diagram is stretched- [x] `toflowable`: operator name in box indicate backpressure- [x] `tofuture`: indicate future remove the blocking text- [x] `tomaybe`: operator name in box indicate both outcomes with proper signal types- [x] `unsubscribeon`: missing diagram- [x] `test`: missing diagram?;i see most marbles in the javadoc live under this folder:  ` are other locations accepted - eg can i upload it in google drive for example and open a pr with the updated path in the javadoc directly? heres a few i created:![single_dofinally]( || images have to be hosted by the project besides google drive tends to change the service terms and images may become inaccessible (ive lost resource location this way in another project) about your images:- `dofinally`:   - error should be a red x  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here- `doondispose`  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here  - `unsubscribe` should be `dispose`- `doonsubscribe`  - the star should be in between the operator box and the bottom timeline- `doonsuccess`: ok || updated images from #5987 now in the repository:![dofinally]( || how are these made? are there any written guidelines? i can try making some when i have time || there is a mac only omnigraffle im on windows and i use excel shapes and arrows || @aarjavp  i used [this template]( as a staring point its for **inkscape** software which worked nicely on my mac || hi all can you please tell me is this marble acceptable for the `filter` operator?as i havent contributed to this project so far i would like to take it easy and slow :) let me know what should i change so that i have a reference for future marbles![filter]( || not really there is no | in single please have a look at diagrams above:  || @akarnokd can we update this issue please? its getting a bit messy and hard to follow what has been completed || @umfsimke it has been only you lately that worked on this ||;1;0;update singleconcat marbles height;
6141;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add marble diagrams for various single operators;here are marble diagrams for various single operators that will close some of the #5788;;5788.0;add marble diagrams for various single operators;here are marble diagrams for various single operators that will close some of the #5788 marble for `concateager(publisher)`![concateeagerp]( for `concateager(iterable)`![concateeageri]( for `create`![create]( for `ambwith`![ambwith]( for `equals`![equals]( for `merge(source1 source2)`![merge]( for `merge(source1 source2 source3)`![mergethree]( for `merge(source1 source2 source3 source4)`![mergefour]( for `merge(singlesource<singlesource>)`![mergesinglesource]( for `mergewith`![mergewith]( for `doafterterminate`![doafterterminate]( for `to`![to]( for `as`![as]( for `compose`![compose]( for `doaftersuccess`![doaftersuccess]( for `merge(publisher)`![mergepublisher]( for `merge(iterable)`![mergeiterable](https://rawentcom/umfsimke/rxjava/images/images/mergeiterablepng); merging 6141 ;3x: single incorrect or missing images (tracking issue);-  `amb`: missing diagram-  `ambarray`: missing diagram-  `concat(arg)`: missing diagram-  `concat(s1s4)`: add 3rd and 4th source indicate backpressure-  `concatarray`: missing diagram-  `concatarrayeager`: missing diagram-  `concateager`: missing diagram-  `create`: missing diagram-  `defer`: missing diagram-  `error(callable)`: missing diagram- [x] `error(throwable)`: indicate error in the box- [x] `fromcallable`: missing diagram- [x] `frompublisher`: missing diagram- [x] `fromobservable`: missing diagram- [x] `merge`: missing diagram- [x] `merge(singlesource<singlesource<t>>)`: indicate main element is a `singlesource`- [x] `merge(s1s4)`: add 3rd and 4th source indicate backpressure- [x] `mergedelayerror`: iterable/publisher missing diagrams s2s3s4 wrong diagrams- [x] `never`: missing diagram- [x] `timer`: missing diagram- [x] `equals`: missing diagram- [x] `unsafecreate`: missing diagram- [x] `using`: missing diagram- [x] `wrap`: missing diagram- [x] `ambwith`: missing diagram- [x] `as`: missing diagram- [x] `hide`: missing diagram- [x] `compose`: missing diagram- [x] `cache`: missing diagram- [x] `cast`: missing diagram- [x] `delay`: missing diagram- [x] `delaysubscription`: missing diagram- [x] `dematerialize`: missing diagram- [x] `doaftersuccess`: missing diagram- [x] `doafterterminate`: indicate error case- [x] `dofinally`: missing diagram- [x] `doonsubscibe`: missing diagram- [x] `doonsuccess`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonerror`: missing diagram- [x] `doondispose`: missing diagram- [x] `filter`: one source item indicate both true and false outcomes- [x] `flatmappublisher`: operator name- [x] `blockingget`: missing diagram- [x] `lift`: missing diagram- [x] `contains`: missing diagram- [x] `mergewith`: indicate backpressure- [x] `onerrorreturn`: indicate item is the result of a function call with the original error- [x] `onerrorreturnitem`: use the previous `onerrorreturn` diagram change name in box- [x] `onerrorresumenext`: diagram should have one item and no complete marker- [x] `onerrorresumewith`: operator name- [x] `onterminatedetach`: missing diagram- [x] `repeat`: missing diagram- [x] `repeatwhen`: missing diagram- [x] `repeatuntil`: missing diagram- [x] `retry`: missing diagram- [x] `retrywhen`: missing diagram- [x] `subscribe`: missing diagram- [x] `subscribewith`: missing diagram?- [x] `takeuntil`: fix item count in main and other sources indicate all other signal types- [x] `timeout`: missing diagram- [x] `to`: missing diagram- [x] `tocompletable`: diagram is stretched- [x] `toflowable`: operator name in box indicate backpressure- [x] `tofuture`: indicate future remove the blocking text- [x] `tomaybe`: operator name in box indicate both outcomes with proper signal types- [x] `unsubscribeon`: missing diagram- [x] `test`: missing diagram?;i see most marbles in the javadoc live under this folder:  ` are other locations accepted - eg can i upload it in google drive for example and open a pr with the updated path in the javadoc directly? heres a few i created:![single_dofinally]( || images have to be hosted by the project besides google drive tends to change the service terms and images may become inaccessible (ive lost resource location this way in another project) about your images:- `dofinally`:   - error should be a red x  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here- `doondispose`  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here  - `unsubscribe` should be `dispose`- `doonsubscribe`  - the star should be in between the operator box and the bottom timeline- `doonsuccess`: ok || updated images from #5987 now in the repository:![dofinally]( || how are these made? are there any written guidelines? i can try making some when i have time || there is a mac only omnigraffle im on windows and i use excel shapes and arrows || @aarjavp  i used [this template]( as a staring point its for **inkscape** software which worked nicely on my mac || hi all can you please tell me is this marble acceptable for the `filter` operator?as i havent contributed to this project so far i would like to take it easy and slow :) let me know what should i change so that i have a reference for future marbles![filter]( || not really there is no | in single please have a look at diagrams above:  || @akarnokd can we update this issue please? its getting a bit messy and hard to follow what has been completed || @umfsimke it has been only you lately that worked on this ||;1;0;add marble diagrams for various single operators;
"6143;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add concatarrayeagerdelayerror operator (expose feature);this pr exposes the existing  delayerror  capability of the  concatmapeager  operator as  concatarrayeagerdelayerror  for both  flowable  and  observable .;;6082.0;2x: add concatarrayeagerdelayerror operator (expose feature);this pr exposes the existing `delayerror` capability of the `concatmapeager` operator as `concatarrayeagerdelayerror` for both `flowable` and `observable`in addition the `concatarrayeager` and these new methods receive marble diagrams:#### observable( flowable![image]( #6082 *(sidenote: one of the validators had to be adjusted due to false positive it produced)*; merging 6143 ;concatarrayeagerdelayerror documented but missing? 216;on 2116 it is documented in the [wiki]( and on [readthedocs]( that `concatarrayeagerdelayerror` is new in rxjava 2 together with:- [`concatarray`]( [`concatarraydelayerror`]( [`concatarrayeager`]( are all there but `concatarrayeagerdelayerror` doesnt seem to be implemented:```kotlinobservableconcatarrayeagerdelayerror()```am i perhaps missing something?;looks like `concatarrayeagerdelayerror` has not been exposed so far:  || yes ive overlooked that mightve been because im on my laptop right now and its chugging along slowly on those large files on githubis the plan to expose this in the future? || no plans and there was no feature request for them it would require 6~8 new methods: `{flowable|observable}concatarrayeagerdelayerror([tilltheend[ maxconcurrency [ prefetch]]] sources)`and at least 2 diagrams per base class || im up for providing a pr if thats welcome thank you in advance for providing me with the methods that would need to be implemented i havent dabbled into the rxjava source but i guess i can figure it out what would i need to create the diagrams?looking at the [tests for concatarrayeager]( and [concatarraydelayerror]( i assume that i only have to implement the tests like `concatarraydelay` but for `concatarrayeagerdelayerror` || i draw them in excel but others use omnigraffle or inkscapeyou can try making a pr || small update i was on holiday and am currently studying for exams for another month so itll be more than a month till i can get to this unfortunately || ive done it and the necessary marbles in #6143 || too bad for me i was looking forward to it :(great to have it exposed now though ||;1;0;""change text to """"concatenates an array of"""""";"
6145;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix boundary fusion of concatmap and publish operator;this pr fixes the lack of boundary fusion marker in the  concatmap  and  publish  operators that can break the thread-confinement expectation when using  observeon  upstream and a thread-sensitive operator:;;614.0;2x: fix boundary fusion of concatmap and publish operator;this pr fixes the lack of boundary fusion marker in the `concatmap` and `publish` operators that can break the thread-confinement expectation when using `observeon` upstream and a thread-sensitive operator:```javasourceobserveon(scheduler)    map(/* some thread-sensitive operation */)    publish() // or concatmap```by default these operators may call `poll` from any of the participating threads which would otherwise dequeue `observeon` and execute `map` on that threadthe fix adds the necessary flag to both operators `onsubscribe` logic for a temporary workaround one should use `hide()` before such operators to make sure fusion doesnt happenfixes: #6144; merging 6145 ;merge delay error doesnt synchronize onnext calls;the merge operation passes calls to the actual observer through an instance of synchronizedobserver but merge delay error doesnt  this is causing overlapping calls to onnext and all sorts of concurrency bugs in our server;saw errors in those in my tests yesterday as well  ||  and ;1;0;2x: fix boundary fusion of concatmap and publish operator;
6150;1;0;0;0;0;1;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: cleanup newline separation  some field namings;this pr cleans up some source code style inconsistencies:;;0;2x: cleanup newline separation some field namings;this pr cleans up some source code style inconsistencies:- rename some atomic-subscription fields to `upstream` (left out from #6129)- make sure `@test` methods are separated by at most one empty newline- make sure a closing curly brace and an annotation is only followed by one empty newline- add a test that checks for the above; merging 6150 ;;;;1;1;fix missed two-empty-line cases;
"6152;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: clarify testobserver.assertvalueset in docs and via tests;clarify that  {testobserver|testsubscriber}.assertvalueset  checks for all received items to be in the provided set  but that set can contain additional elements that could have been received. unit tests have been added to demonstrate the expected behavior.;;6151.0;2x: clarify testobserverassertvalueset in docs and via tests;clarify that `{testobserver|testsubscriber}assertvalueset` checks for all received items to be in the provided set but that set can contain additional elements that could have been received unit tests have been added to demonstrate the expected behaviorresolves: #6151; merging 6152 ;`basetestconsumer#assertvalueset` doesnt verify that all listed values were received;""[`basetestconsumer#assertvalueset`]( is documented and implemented as:```java/** * assert that the testobserver/testsubscriber received only the specified values in any order * <p>this helps asserting when the order of the values is not guaranteed ie when merging * asynchronous streams * * @param expected the collection of values expected in any order * @return this */@suppresswarnings(""""unchecked"""")public final u assertvalueset(collection<? extends t> expected) {    if (expectedisempty()) {        assertnovalues()        return (u)this    }    for (t v : thisvalues) {        if (!expectedcontains(v)) {            throw fail(""""value not in the expected collection: """" + valueandclass(v))        }    }    return (u)this}```within our team we have several tests using `assertvalueset` each attempting to assert that _all_ of the listed values are emitted today we found out that `assertvalueset` verifies a weaker condition namely that no """"unexpected"""" values are emitted it does not verify that all listed values are emitted this took us by surprise if this is the intended behaviour perhaps the documentation could be clarified on this pointnb: the rxjava code base itself contains several tests using `assertvalueset` some of these also seem to assume the stronger interpretation (eg `flowableflatmapsingletest#normalasync`) while others would surely fail under the stronger semantics (eg`flowableflatmapsingletest#takeasync`)nb2: i do observe that (nearly?) all tests in the rxjava code base invoking `assertvalueset` involve some form of nondeterminism and a benefit of the current weaker semantics is that these tests are now less likely to fail on a system under heavy load still as-is `assertvalueset` also passes if _no_ values are emitted surely these tests wish to assert something more definitive?"";it is meant to assert received values are all in the collection you can make a stronger assumption by adding assertvaluecount ||;1;0;grammar;"
6155;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix marble of maybe.flatmap events to maybesource;fix the marble diagram of the event-mapping [ maybe.flatmap ]( operator:;;580.0;2x: fix marble of maybeflatmap events to maybesource;fix the marble diagram of the event-mapping [`maybeflatmap`]( operator:( in: #5806; merging 6155 ;crlf fixes;issue #579in case the manual mode is chosen;#519  i added the gitattributes file in this commit:  and then let git renormalize itself as per  ||;1;0;2x: fix marble of maybeflatmap events to maybesource;
6158;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: make flowable.fromcallable consistent with the other fromcallables;flowable.fromcallable  is one of [the oldest]( 2.x operators and was overlooked when the handling of beyond-cancellation error delivery  aka the undeliverable exception handling was implemented across rxjava. this pr resolves this shortcoming by making it consistent with its sibling implementations.;;0;2x: make flowablefromcallable consistent with the other fromcallables;`flowablefromcallable` is one of [the oldest]( 2x operators and was overlooked when the handling of beyond-cancellation error delivery aka the undeliverable exception handling was implemented across rxjava this pr resolves this shortcoming by making it consistent with its sibling implementationsresolves: #6156; merging 6158 ;;;;1;1;2x: make flowablefromcallable consitent with the other fromcallables;
6165;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;error handle on completable.fromcallable with rxjavaplugins;;;0;error handle on completablefromcallable with rxjavaplugins;; merging 6165 ;;;;1;1;error handle on completablefromcallable with rxjavaplugins;
6167;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: make observeon not let worker.dispose() called prematurely;some operators may call  dispose() / cancel  from  onerror / oncomplete  which could trigger a permature call to  worker.dispose()  that was about to happen anyway. this pr prevents this by moving the operator into its disposed/cancelled state before signaling the terminal event  thus a downstream  cancel() / dispose()  call won t trigger this premature cleanup.;;614.0;2x: make observeon not let workerdispose() called prematurely;some operators may call `dispose()`/`cancel` from `onerror`/`oncomplete` which could trigger a permature call to `workerdispose()` that was about to happen anyway this pr prevents this by moving the operator into its disposed/cancelled state before signaling the terminal event thus a downstream `cancel()`/`dispose()` call wont trigger this premature cleanupsuch premature cleanups may cause unwanted `schedulersio()` reuse in some scenariosrelated: #6146;there are 2 x 2 tests that were relying on a race that the previous behavior always allowed ive updated those tests to avoid the inherent termination-cancel race in them ||  merging 6167 ;merge delay error doesnt synchronize onnext calls;the merge operation passes calls to the actual observer through an instance of synchronizedobserver but merge delay error doesnt  this is causing overlapping calls to onnext and all sorts of concurrency bugs in our server;saw errors in those in my tests yesterday as well  ||  and ;1;0;merge in master;
6171;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add explanation text to undeliverable & onerrornotimplemented exs;this pr adds detailed error message to the  undeliverableexception  and  onerrornotimplementedexception  as they are the most common exception-related questions around.;;0;2x: add explanation text to undeliverable & onerrornotimplemented exs;this pr adds detailed error message to the `undeliverableexception` and `onerrornotimplementedexception` as they are the most common exception-related questions around#### undeliverableexception> the exception could not be delivered to the consumer because it has already canceled/disposed the flow or the exception has nowhere to go to begin with further reading:  | `<original exception message>`#### onerrornotimplementedexception> the onerror handler in the subscribe() method is not provided please specify it to avoid this type of exception further reading:  | `<original exception message>`;/cc @artem-zinnatullin @davidmoten  ||  merging 6171  < ;;;;1;1;reword onerrornotimplemented;
"6175;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: explain null observer/subscriber error reports in detail from rxjavaplugins;this pr is related to issue 6172](https://github.com/reactivex/rxjava/issues/6172).;;6172.0;2x: explain null observer/subscriber error reports in detail from rxjavaplugins;""this pr is related to issue 6172]( these changes all reactive types will emit detailed error message when `onsubscribe` hook installed using rxjavaplugins returns null `observer/subscriber`:**observable**> """"the rxjavapluginsonsubscribe hook returned a null observer please check the handler provided to rxjavapluginssetonobservablesubscribe for invalid null returns further reading:  the rxjavapluginsonsubscribe hook returned a null flowablesubscriber please check the handler provided to rxjavapluginssetonflowablesubscribe for invalid null returns further reading:  the rxjavapluginsonsubscribe hook returned a null singleobserver please check the handler provided to rxjavapluginssetonsinglesubscribe for invalid null returns further reading:  the rxjavapluginsonsubscribe hook returned a null maybeobserver please check the handler provided to rxjavapluginssetonmaybesubscribe for invalid null returns further reading:  the rxjavapluginsonsubscribe hook returned a null completableobserver please check the handler provided to rxjavapluginssetoncompletablesubscribe for invalid null returns further reading:  :** there was no null check on `observer` returned from `rxjavapluginsonsubscribe(this observer)` method call in `completable`s subscribe() method so ive added it in this pr is that fine? ""; merging 6175 ;2x: explain null plugin returns better;""when an `onsubscribe` hook is installed and returns a null consumer the current error report says:```javaobjecthelperrequirenonnull(observer """"plugin returned null observer"""")```at least an """"a"""" is missing but perhaps it would be better to word it more detailed:> """"the rxjavapluginsonsubscribe hook returned a null observer please check the handler provided to rxjavapluginssetonobservablesubscribe for invalid null returns further reading:  course all reactive types should be updated and adapted to the appropriate types and method names"";im inexperienced but i would be a happy to try and help with this issue  || closing via #6175 ||;1;0;2x: explain null observer/subscriber return errors from rxjavaplugins in detail;"
6182;1;0;0;0;0;1;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: cleanup multiple empty lines in sources;remove 2+ empty lines from the sources.;;0;2x: cleanup multiple empty lines in sources;remove 2+ empty lines from the sources; merging 6182 ;;;;1;1;2x: cleanup multiple empty lines in sources;
"6187;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix refcount termination-reconnect race;this pr modifies the  refcount  operator (in both  flowable  and  observable  types) to avoid certain termination-reconnection races.;;6185.0;2x: fix refcount termination-reconnect race;this pr modifies the `refcount` operator (in both `flowable` and `observable` types) to avoid certain termination-reconnection racesthe original race could happen when the refcounted source terminated at the same time as new observers arrived leaving those new observers hanging as they practically joined a dying connection and got possibly undercut by the `dispose` callthe change involve a new internal interface `resettableconnection` that will allow resetting the connection object inside the connectable source if it is equal to the connection object known by the initiator of the original `connect` call6185;"" merging 6187  "";possible concurrency issue with refcount()? (220);first i want to thank you for this wonderful library which i gladly use in many professional applications!while i was writing a component for one of our company applications i wrote a multithreaded stress test because the component itself introduces shared state sometimes the test failed of course i suspected my component to be the culprit after further investigation i could completely rule out my own component and still reproduce the problem i think there could be a problem with the `refcount()` operatorless words more code:the problem is reproducible with the following unit test (well at least as reproducible as a test in a multithreaded manner can be)```public void replayrefcountshallbethreadsafe() {        for (int i  0 i < 10000 i++) {            observable<object> observable  observablejust(new object())replay(1)refcount()            testobserver<object> observer1  observable                    subscribeon(schedulersio())                    test()            testobserver<object> observer2  observable                    subscribeon(schedulersio())                    test()            assertthat(observer1awaitterminalevent(5 timeunitseconds) is(true))            assertthat(observer2awaitterminalevent(5 timeunitseconds) is(true))        }}```as you can see i am repeating the logic 10000 times this (mostly) guarantees that the test fails on my environment one of the observers does not receive the completed event and therefore the `awaitterminalevent` times outon the other hand the following unit test where i manually `connect()` the `connectableobservable`  returned vom `replay(1)` passes:```public void replayshallbethreadsafe() {        for (int i  0 i < 10000 i++) {            connectableobservable<object> observable  observablejust(new object())replay(1)            disposable connection  observableconnect()            testobserver<object> observer1  observable                    subscribeon(schedulersio())                    test()            testobserver<object> observer2  observable                    subscribeon(schedulersio())                    test()            assertthat(observer1awaitterminalevent(5 timeunitseconds) is(true))            assertthat(observer2awaitterminalevent(5 timeunitseconds) is(true))            connectiondispose()        }}```please tell me if i am missing somethingversion: rxjava 220tests are junit tests with hamcrest assertionsthanks!;thanks for reporting it does seem like a reconnection race as one observer goes out while another comes in also present in the `flowable` version ill post a fix shortly || wow that is what i call a fast response! :)i am looking forward to the fix thank you if i can be of any help just tell me ||;1;0;update resettableconnectable interface and definitions;"
"6193;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add  error handling  java docs section to from callable & co;6179;;6179.0;""add """"error handling"""" java docs section to from callable & co"";6179added javadocs describing the regular and canceled/disposed behavior for- `observablefromcallable()`- `singlefromcallable()`- `maybefromaction()`- `completablefromcallable()`- `completablefromaction()`- `flowablefromcallable()`did not alter `maybefromcallable()` because the existing javadoc appears to be adequate;"" merging 6193  "";""add an """"error handling"""" javadocs section to fromcallable & co"";the operators of `fromcallable` `fromaction` and `fromrunnable` in the reactive classes could use an `<dt><b>error handling:</b></dt>` section in the javadocs describing the regular and canceled/disposed behavior> if the `{@link callable/action/runnable}` throws an exception/exception/unchecked exception the respective `{@link throwable}` is delivered to the downstream via `{@link subscriber/observer//#onerror()}` except when the downstream has canceled/disposed this `{@code flowable/observable/single/maybe/completable}` source in this latter case the throwable is delivered to the global error handler via `{@link rxjavaplugins#onerror(throwable)}` as `{@link ioreactivexexceptionsundeliverableexception undeliverableexception}`;;1;0;#6179 adding error handling javadocs to flowable#fromcallable();"
"6197;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;#6195 fix flowable.reduce(bifunction) javadoc;empty source does not signal nosuchelementexception.;;6195.0;#6195 fix flowablereduce(bifunction) javadoc;empty source does not signal nosuchelementexception6195; merging 6197 ;flowablereduce(bifunction) does not signal nosuchelementexception;""the javadocs of `flowablereduce(bifunction)` incorrectly mentions that an empty source results in a `nosuchelementexception` it returns a `maybe` thus an empty source will result in an empty `maybe` the `observablereduce(bifunction)` counterpart has the correct textthe """"if the source is empty a nosuchelementexception is signaled"""" should be removed"";;1;0;#6195 fix flowablereduce(bifunction) javadocempty source does not signal nosuchelementexception;"
6199;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix terminology of cancel/dispose in the javadocs;6196;;6196.0;fix terminology of cancel/dispose in the javadocs;6196changing terminology from cancel -> dispose wherever appropriate in the following classes:- `observablejava`- `singlejava`- `maybejava`- `completablejava`areas where i did _not_ change from cancel -> disposal include: - where the cancellation was in reference to a `flowable` `publisher` or a `future`- `test()` methods where the `testobserver` returned actually has a `cancel()` method; merging 6199 ;fix terminology of cancel/dispose in the javadocs;`flowable`s can be **canceled** and the other reactive types can be **disposed** change the javadocs of these latter types accordingly (via careful find/replace):-  observable-  single-  maybe-  completable(note: `flowable` is okay);;1;0;#6196 switching from subscribers to observers in `completablefromfuture()` javadoc;
6200;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: fix tofuture marbles and descriptions;this pr fixes the marble diagrams of  flowable.tofuture  and  observable.tofuture  to indicate:;;6198.0;2x: fix tofuture marbles and descriptions;this pr fixes the marble diagrams of `flowabletofuture` and `observabletofuture` to indicate:- multi-valued sources signal `indexoutofboundsexception`- source has to be finite for the `future` to terminate( #6198(also fixes the diagram for #5813); merging 6200 ;tofuture incorrect diagram/description;both `flowabletofuture` and `observabletofuture` describes the wrong behavior: if the source has more than one element the outcome is actually `indexoutofboundsexception`in addition the docs should mention the source has to terminate in order for the `future` to terminateplus the [marble]( should be updated to reflect the actual behavior (there is no dispose upon the first received item)(https://githubcom/reactivex/rxjava/wiki/images/rx-operators/tofutureopng);;1;0;adjust wording;
6205;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: assert instead of print undeliverable in some tests;set plugin error tracking in some tests to avoid printing out  undeliverableexceptions  (sometimes repeatedly in race tests) and assert the specific exception(s) instead.;;0;2x: assert instead of print undeliverable in some tests;set plugin error tracking in some tests to avoid printing out `undeliverableexceptions` (sometimes repeatedly in race tests) and assert the specific exception(s) instead; merging 6205  < ;;;;1;1;fix error count not guaranteed to be 4;
6220;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x javadocs: remove unnecessary  s  from connectableobservable;remove the unnecessary  s  from the javadocs of  connectableobservable.autoconnect .;;0;2x javadocs: remove unnecessary s from connectableobservable;remove the unnecessary s from the javadocs of `connectableobservableautoconnect`; merging 6220 ;;;;1;1;2x javadocs: remove unnecessary s from connectableobservable;
"6232;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: cleanup observable.flatmap drain logic;cleanup the drain logic of  observable.flatmap  by removing unnecessary loops and fixing the index management in case of a fused failure in one of the sources triggering another round over the same source unnecessarily.;;623.0;2x: cleanup observableflatmap drain logic;cleanup the drain logic of `observableflatmap` by removing unnecessary loops and fixing the index management in case of a fused failure in one of the sources triggering another round over the same source unnecessarilyresolves: #6231; merging 6232 ;clojure observable/from converts list to to an observable of a single (list) value;""im trying out the [clojure example code]( and the results seem wrongwith the following:``` clojure(defn hello  [& args]  (-> (observable/from args)    (subscribe (rx/action [v] (println (str """"hello """" v """"!""""))))))(hello """"ben"""" """"george"""")```i expected the observable to emit two distinct values """"ben"""" and """"george"""" before completing resulting in one line of output per namehowever the repl output is:``` clojurehello (""""ben"""" """"george"""")!```so it seems the entire `args` list is emitted as a single value tried 0151 as well as current master at 7ec374c clojure 151""; clojure(defn hello  [& args]  (-> (observable/from  (""""ben"""" """"george"""") )  hardcode the list    (subscribe (rx/action [v] (println (str """"hello """" v """"!""""))))))(hello """"ben"""" """"george"""")```works fine very strange || the clojure compiler has many versions of `observable/from` to choose from and here it picks the wrong one youll need to give it a hint:``` clojure(observable/from ^javalangiterable args)```that should do it || thanks that works not cool though its reasonable to expect it to just work || welcome to java interop with dynamic types || :) || "";1;0;2x: cleanup observableflatmap drain logic;"
"6234;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;add timeout and unit to timeoutexception message;this is a small enhancement to help with crash/log debugging.;;0;add timeout and unit to timeoutexception message;this is a small enhancement to help with crash/log debuggingright now often times you get a stacktrace that points only to rxjava:```javajavautilconcurrenttimeoutexception        atioreactivexinternaloperatorsflowableflowabletimeouttimed$timeoutsubscriberontimeout(flowabletimeouttimedjava:137)        atioreactivexinternaloperatorsflowableflowabletimeouttimed$timeouttaskrun(flowabletimeouttimedjava:169)        atioreactivexinternalschedulersscheduledrunnablerun(scheduledrunnablejava:66)        atioreactivexinternalschedulersscheduledrunnablecall(scheduledrunnablejava:57)        at javautilconcurrentfuturetaskrun(futuretaskjava:266)        atjavautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskaccess$201(scheduledthreadpoolexecutorjava:180)        atjavautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:293)        atjavautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1149)        atjavautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:624)        at javalangthreadrun(threadjava:748) ```adding `timeout` and `unit` values can help find related user code fasterim not advocating for particular message it can be something even shorter like `$timeout $unit` it can also be extracted in a method if you see value in that;""im for better error messages but im not convinced a timeout value is generally unique enough in a project that will allow you to locate the flow especially when the timeout value comes from configuration and thus it is not prevalent in the source codean alternative would be an overload on the operator with a string argument that would be passed onto the exception constructor tagging the particular source location ||  merging 6234  "";;;;1;1;new timeout message add tests;"
6236;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: adjust undeliverable & onerrornotimpl message to use full inner exception;with  undeliverableexception  and  onerrornotimplementedexception   the wrapped exception may not have a message and the top line simply contains an unhelpful  null :;;0;2x: adjust undeliverable & onerrornotimpl message to use full inner exception;with `undeliverableexception` and `onerrornotimplementedexception` the wrapped exception may not have a message and the top line simply contains an unhelpful `null`:    ioreactivexexceptionsundeliverableexception: the exception could not be delivered to the             consumer because it has already canceled/disposed the flow or the exception             has nowhere to go to begin with further reading:              | null        at ioreactivexpluginsrxjavapluginsonerror(rxjavapluginsjava:367)        at ioreactivexinternaloperatorsobservableobservablecreate$createemitter            onerror(observablecreatejava:73)        at ioreactivexinternaloperatorsobservableobservablecreate            subscribeactual(observablecreatejava:43)        at ioreactivexobservablesubscribe(observablejava:12090)     caused by: javaiointerruptedioexception this pr adds the full `tostring()` value of the wrapped exception to the main line this is also more useful when the user posting the stacktrace doesnt provide the `caused by:` part for some reason; merging 6236 ;;;;1;1;2x: adjust undeliverable & onerrornotimpl message to use full inner;
"6242;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;add delaysubscription() methods to completable #5081;since observable  single already have  delaysubscription()   but completable doesn t  i added these methods to the code.;;0;add delaysubscription() methods to completable #5081;since observable single already have `delaysubscription()` but completable doesnt i added these methods to the code;""please [fix the mistakes]( and add unit tests verifying these new methods || the code failed this test `paramvalidationcheckertest` > checkcompletable failedwhich should i better do:1 put `objecthelperverifypositive(delay """"delay"""")` into all new methods of mine or2 `return rxjavapluginsonassembly(new completabletimer(mathmax(delay 0l) unit scheduler))` inside timer()the first way looks more logical to me || neither update the test to permit any integer like the other `delaysubscription` implementations eg  || got it i will fix the tests what about `timer()` which way is correct: || you dont have to `max` the one in `observable` version is old and unnecessary || should i remove `max` then from `observable`?can i add `@since 23` to the new methods? || > should i remove max then from observable?sure> can i add @since 23 to the new methods?add `@since 223 - experimental` and `@experimental` ||  merging 6242  "";;;;1;1;remove mocked observer from delaysubscription() tests for completable;"
6244;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add nullable annotations for blocking methods in completable;;;0;add nullable annotations for blocking methods in completable;just add @nullable annotations to blockingget() methods in completable class; merging 6244  < ;;;;1;1;add nullable annotations for blocking methods in completable;
6252;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: expand and fix completable.delaysubscription tests;expand  fix and move the tests of #6242 into a dedicated test file.;;0;2x: expand and fix completabledelaysubscription tests;expand fix and move the tests of #6242 into a dedicated test file;   no coverage uploaded for pull request base (`2x@f78bd95`) [click here to learn what that means]( `n/a`(                                  2x    #6252   +/-   ##  coverage       ?   9823%             complexity     ?     6205             files          ?      667  ?    44889     ?     6216             hits           ?    44095             misses         ?      261             partials       ?      533```------[continue to review full report at codecov]( **legend** - [click here to learn more]( `  absolute <relative> (impact)` `  not affected` `?  missing data`> ( last update [f78bd954e778d6]( read the [comment docs]( ||;;;;1;1;2x: expand and fix completabledelaysubscription tests;
6254;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix flaky sample() backpressure test  improve coverage;use processors to trigger the  missingbackpressureexception  case instead of the timer  which could fire prematurely and stop the sequence before the first item was sent by the  behaviorprocessor .;;6253.0;2x: fix flaky sample() backpressure test improve coverage;use processors to trigger the `missingbackpressureexception` case instead of the timer which could fire prematurely and stop the sequence before the first item was sent by the `behaviorprocessor`also small improvements to the code coverage of `flowablesample`6253; merging 6254 ;flaky test/operator: flowablesampletest backpressureoverflowwithotherpublisher;```ioreactivexinternaloperatorsflowableflowablesampletest > backpressureoverflowwithotherpublisher failed    javalangassertionerror: no errors (latch  0 values  0 errors  0 completions  1)        at ioreactivexobserversbasetestconsumerfail(basetestconsumerjava:189)        at ioreactivexobserversbasetestconsumerasserterror(basetestconsumerjava:318)        at ioreactivexobserversbasetestconsumerasserterror(basetestconsumerjava:303)        at ioreactivexobserversbasetestconsumerassertfailure(basetestconsumerjava:811)        at ioreactivexinternaloperatorsflowableflowablesampletestbackpressureoverflowwithotherpublisher(flowablesampletestjava:313)```;;1;0;2x: fix flaky sample() backpressure test improve coverage;
6255;1;0;0;0;0;1;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: cleanup code style  commas  spaces  docs;- add missing spaces after commas and semicolons;;0;2x: cleanup code style commas spaces docs;- add missing spaces after commas and semicolons- add or fix first sentences without commas in javadocs; merging 6255 ;;;;1;1;2x: cleanup code style commas spaces docs;
6257;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: add completable.delaysubscription marble  fix some javadoc;- add marbles to the new  completable.delaysubscription  operator.;;0;2x: add completabledelaysubscription marble fix some javadoc;- add marbles to the new `completabledelaysubscription` operator- fix the method name referenced in the `conditionalsubscriber` javadoc(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completabledelaysubscriptiontpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completabledelaysubscriptiontspng); merging 6257 ;;;;1;1;2x: add cdelaysubscription marble fix some javadoc;
"6258;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix cancel/dispose upon upstream switch for some operators;this pr extends the  subscriptionarbiter  to optionally allow or disallow cancelling the current  subscription  if it is replaced by a new one. some operators do not need to cancel the current  subscription :  concat    concatmap    repeat    repeatwhen    retry  and  retrywhen .;;625.0;2x: fix cancel/dispose upon upstream switch for some operators;this pr extends the `subscriptionarbiter` to optionally allow or disallow cancelling the current `subscription` if it is replaced by a new one some operators do not need to cancel the current `subscription`: `concat` `concatmap` `repeat` `repeatwhen` `retry` and `retrywhen` in addition `repeatwhen` and `retrywhen` were cancelling when the handler sequence itself terminated the code has been updated to disconnect the upstream upon the completion/failure but before signaling the handlerthe reactive streams specification also disallows synchronous cancellation after the terminal event anywayothers may actually need to cancel such as `timeout` `observable`s dont have a specific arbiter they use the `disposablehelper` methods and the relevant ones were changed to `replace()` instead of the disposing `set` callsome tests actually checking if the dispose/cancel happens and had to be updatedthe `flowabledelaysubscription(publisher)` also used `subscriptionarbiter` but it was unnecessary the code has been replaced with a more apt deferred requesting scheme as the downstream requests need to be delayed until the main subscription happens the other publisher is always consumed unboundedresolves: #6259; merging 6258 ;observeon doesnt behave as expected (clojure); clojure(ns rxlangclojureexamplesrx-examples  (:require [rxlangclojureinterop :as rx])  (:import rxobservable           rxsubscriptionssubscriptions           rxschedulersschedulers           javautilconcurrenttimeunit))(println (thread/currentthread))  (*)(-> (observable/interval 100 timeunit/milliseconds #_(schedulers/currentthread))     (take 5)    (observeon (schedulers/currentthread))    (subscribe (rx/action [v]                              this file is created but the content do not match (*)                            (spit """"/tmp/tidtxt"""" (thread/currentthread))                            (println v)))  this output never reaches the repl    )```so `observable/interval` spawns a new thread and the subscribed callback is invoked in that thread by default i need to use `observeon` to ensure the cbis invoked in the current thread so that the `println` output makes it to the repl`/tmp/tidtxt` does get created so the cb _is_ called but the println outputnever makes it to the replif i schedule `observable/interval` in the current thread (commented out) theoutput is visible (though the repl hangs afterwards for some reason) butthe `observeon` itself doesnt seem to do the job its meant tothe contents of /tmp/tid/txt dont match the current thread reportedby the println eitheris this a bug or am i doing something wrong?"";""> (though the repl hangs afterwards for some reason)i believe this is related to a bug where `currentthreadscheduler` can not be unsubscribed from since it is all single-threaded and thus not async and never returns the `subscription` so `take(5)` is meaningless to itwe should be able to unsubscribe from a `currentthread` scheduled `observable` though and @headinthebox and i were looking at this last week to determine how to do so we looked at the rxnet implementation and its very non-elegant to make it work (thread-locals and other such fun) its on my plate to tackle in the meantime for anything that is infinite such as `interval` youll want to use something with real concurrency such as `newthread` or `schedulersthreadpoolforcomputation()`> the contents of /tmp/tid/txt dont match the current thread reportedthe file contains this: `thread[rxcomputationthreadpool-65main]` and that is correct since `interval` uses the thread-pool by defaultthe `(schedulers/currentthread)` `scheduler` tells it to run on the """"current"""" thread whatever it is using a trampoline it is the same as using `immediate` which uses the """"current"""" thread except it does trampoliningif you change to use `(schedulers/immediate)` for the interval youll get what youre expecting (and it will block on the current thread sleeping for each interval since there is no concurrency):``` clojure(-> (observable/interval 100 timeunit/milliseconds (schedulers/immediate))     (take 5)    (observeon (schedulers/currentthread))    (subscribe (rx/action [v]                              this file is created but the content do not match (*)                            (spit """"/tmp/tidtxt"""" (thread/currentthread))                            (println v)))  this output never reaches the repl    ) outputs to file: thread[nrepl-worker-25main]```it now stays on the main thread and `observeon` in effect does nothing since it is told to use `schedulers/currentthread` so it stays on the main threadgenerally `observeon` is meant for moving the work from one thread to another such as from a background worker thread to a ui thread for rendering using `observeon` with `immediatescheduler` or `currentthreadscheduler` doesnt really make sense as it ends up being a pass-thru || thanks for the detailed answerthe fact that interval runs in the current thread by default is a little surprising but i can live with that (and im guessing its dictated by compat with net if nothing else)the example you provided does get the output to the repl (it hangs but thats expected now)but i dont need the interval to run in the current thread just the callback and i still haventfound the secret handshake for thatas i understand it observeon determines where the cb is run since i wasnt gettingany output i guessed that the cb ended up running on the wrong thread and made it explicitwhere it should run iirc the default is that cbs are run in the same thread as the generated event?given your feedback  i expected this to work:```(-> (observable/interval 100 timeunit/milliseconds (schedulers/newthread)    (take 5)    (observeon (schedulers/immediate))  at least one of these should work depending on     #_(observeon (schedulers/currentthread))  the specific nature of    #_(no-op)  my misunderstanding    (subscribe (rx/action [v]                              this file is created but the content do not match (*)                            (spit """"/tmp/tidtxt"""" (thread/currentthread))                            (println v)))  this output never reaches the repl    )```which i read as: the interval runs in a new thread (forever for now) while the `observeon` callensures the cb is invoked in the current thread that should reward me with output to the replit doesnt block but no output is generated  || > the fact that interval runs in the current thread by default is a little surprisingthe `interval` operator by default runs on a separate thread you would you have to pass `schedulers/immediate` or `schedulers/currentthread` to make it run on the current thread> but i dont need the interval to run in the current thread just the callback and i still havent> found the secret handshake for thatobserveon has no way to automatically make something jump back to the """"main"""" thread the repl is on that would require the main thread offering an event-loop or something to hook into and a `scheduler` implementation that knows how to schedule work onto it similar to the android and swing modules which know how to schedule work into their ui event-loops> while the observeon call ensures the cb is invoked in the current threadthe `observeon` operator schedules work on whatever `scheduler` it is given think of it as moving the work from one thread to another (or one scheduler to another)thus it doesnt determine anything it just puts the work where you tell it thus in your code `observableinterval` and `take` are running on the new thread you tell it to use: `(schedulers/newthread)` then you tell it to `observeon` the `immediate` scheduler which is a no-op and it will continue using the `(schedulers/newthread)` you provided at the beginning so `subscribe` will still run on the new thread---here are two examples one blocking another non-blocking:``` clojure(-> (observable/interval 100 timeunit/milliseconds)    (take 5)    (subscribe (rx/action [v]               (println """"non-blocking"""" v (javalangthread/currentthread)))))(-> (observable/interval 100 timeunit/milliseconds)  (take 5)  (toblockingobservable)  (foreach (rx/action [v] (println """"blocking"""" v (javalangthread/currentthread)))))```the repl shows this:```(-> (observable/interval 100 timeunit/milliseconds)  (take 5)  (toblockingobservable)  (foreach (rx/action [v] (println """"blocking"""" v (javalangthread/currentthread)))))nil(-> (observable/interval 100 timeunit/milliseconds)    (take 5)    (subscribe (rx/action [v]               (println """"non-blocking"""" v (javalangthread/currentthread)))))#<safeobservablesubscription rxoperatorssafeobservablesubscription@5034037e>```the console shows this:```blocking 0 #<thread thread[rxcomputationthreadpool-45main]>blocking 1 #<thread thread[rxcomputationthreadpool-45main]>blocking 2 #<thread thread[rxcomputationthreadpool-45main]>blocking 3 #<thread thread[rxcomputationthreadpool-45main]>blocking 4 #<thread thread[rxcomputationthreadpool-45main]>non-blocking 0 #<thread thread[rxcomputationthreadpool-25main]>non-blocking 1 #<thread thread[rxcomputationthreadpool-25main]>non-blocking 2 #<thread thread[rxcomputationthreadpool-25main]>non-blocking 3 #<thread thread[rxcomputationthreadpool-25main]>non-blocking 4 #<thread thread[rxcomputationthreadpool-25main]>```if i want it to emit to the repl i would need to have it all run on the repl thread then i get this:```(-> (observable/interval 100 timeunit/milliseconds (schedulers/currentthread))    (take 5)    (subscribe (rx/action [v]               (println """"non-blocking"""" v (javalangthread/currentthread)))))non-blocking 0 #<thread thread[nrepl-worker-25main]>non-blocking 1 #<thread thread[nrepl-worker-25main]>non-blocking 2 #<thread thread[nrepl-worker-25main]>non-blocking 3 #<thread thread[nrepl-worker-25main]>non-blocking 4 #<thread thread[nrepl-worker-25main]>```this then causes the bug with `currentthreadscheduler` that it never unsubscribes and hangs the repli dont know enough about how the clojure repl works (im a beginner with clojure) to know if there is a way to hook a `scheduler` into it if so that would be a great contribution to the rxjava-clojure module now to see how `observeon` behaves ``` clojure(-> (observable/interval 100 timeunit/milliseconds)  run on default which is schedulersthreadpoolforcomputation()    (take 5)     print out the value and what thread it is on before doing `observeon`    (doonnext (rx/action [v] (println """"interval emitted"""" v """"on thread"""" (javalangthread/currentthread))))    (observeon (schedulers/newthread))  move it to a new thread from here onwords    (subscribe (rx/action [v]                receive the output and show what thread it is one               (println """"  -> output"""" v """"on thread"""" (javalangthread/currentthread)))))```the repl shows:```(-> (observable/interval 100 timeunit/milliseconds)  run on default which is schedulersthreadpoolforcomputation()    (take 5)     print out the value and what thread it is on before doing `observeon`    (doonnext (rx/action [v] (println """"interval emitted"""" v """"on thread"""" (javalangthread/currentthread))))    (observeon (schedulers/newthread))  move it to a new thread from here onwords    (subscribe (rx/action [v]                receive the output and show what thread it is one               (println """"  -> output"""" v """"on thread"""" (javalangthread/currentthread)))))#<safeobservablesubscription rxoperatorssafeobservablesubscription@6df85c2c>```the console shows:```interval emitted 0 on thread #<thread thread[rxcomputationthreadpool-65main]>  -> output 0 on thread #<thread thread[rxnewthreadscheduler-45main]>interval emitted 1 on thread #<thread thread[rxcomputationthreadpool-65main]>  -> output 1 on thread #<thread thread[rxnewthreadscheduler-45main]>interval emitted 2 on thread #<thread thread[rxcomputationthreadpool-65main]>  -> output 2 on thread #<thread thread[rxnewthreadscheduler-45main]>interval emitted 3 on thread #<thread thread[rxcomputationthreadpool-65main]>  -> output 3 on thread #<thread thread[rxnewthreadscheduler-45main]>interval emitted 4 on thread #<thread thread[rxcomputationthreadpool-65main]>  -> output 4 on thread #<thread thread[rxnewthreadscheduler-45main]>```if i want to emit something to the repl without using `println` i can return a `list` containing the output like this:``` clojure(-> (observable/interval 100 timeunit/milliseconds)  run on default which is schedulersthreadpoolforcomputation()    (take 5)    (observeon (schedulers/newthread))  move it to a new thread from here onwords    (map (rx/fn [v]                receive the output and show what thread it is one               (str """"  -> output """" v """" on thread """" (javalangthread/currentthread))))    (tolist)    (toblockingobservable)    (single))```this now returns the `arraylist` in the repl:```(-> (observable/interval 100 timeunit/milliseconds)  run on default which is schedulersthreadpoolforcomputation()    (take 5)    (observeon (schedulers/newthread))  move it to a new thread from here onwords    (map (rx/fn [v]                receive the output and show what thread it is one               (str """"  -> output """" v """" on thread """" (javalangthread/currentthread))))    (tolist)    (toblockingobservable)    (single))#<arraylist [  -> output 0 on thread thread[rxnewthreadscheduler-85main]   -> output 1 on thread thread[rxnewthreadscheduler-85main]   -> output 2 on thread thread[rxnewthreadscheduler-85main]   -> output 3 on thread thread[rxnewthreadscheduler-85main]   -> output 4 on thread thread[rxnewthreadscheduler-85main]]>```hope this is helpful || /cc @daveray in case you can provide better insight (particularly regarding repl/console output) || thats a fantastic answernoting that `doonnext` is a recent addition i needed to pull and recompilei realize now part of the issue is that i use emacs/cider so println output in another thread ends up in the nrepl buffer rather then the repl buffer where i expected ityes it doesnt make sense to ask for work to be schedueled in the currentthread without somethingthere to process schedueled work my badstill puzzled by how in your last example the result gets returned to the current threaddoes each call after `observeon` block the current thread in turn? is `single` magical?in any case that was very helpful and realizing the behavior i described is not a bugill close this nowthanks again || > still puzzled by how in your last example the result gets returned to the current thread> does each call after observeon block the current thread in turn? is single magical?its the call to `(toblockingobservable)` that makes it block anytime you want to go from non-blocking to blocking you can use `toblockingobservable` which then exposes a variety of blocking operators they are useful when doing unit tests playing around repls etc or when bridging from async to sync in a mixed codebase || see here for more info about `blockingobservable`:  || right but everything youve shown me so far suggests that the blocking observable will stilllive in another thread i can only hope that im not the only person who finds all this quite subtleill read up on it rather then taking up more of your time truly admire your dedication happy new year || yes it happens on the background thread where it is scheduled the `toblockingobservable` doesnt change that it just blocks and returns type `t` instead of `observable<t>` or `subscription` outside of a repl it might make more sense where the assignment is explicit``` groovy// this returns a non-blocking observable and is lazy so not running yetobservable<long> i  observableinterval(100 timeunitmilliseconds)take(5)// this executes the above and returns a subscription and does so asynchronously (non-blocking)subscription s  isubscribe({ v -> println(v)})// or i can block and fetch the last valuelong lastvalue  itoblockingobservable()last()```the `toblockingobservable` does not change where the work is done but it blocks the current thread to wait for the value which then is assigned and unblocks the current thread which then has itthis is what the repl is doing in my example where it gets the list of values returned to the repl thread itself and it blocks the repl thread until the value is returnedthe return type explains what is going on || "";1;0;restore star imports;"
"6262;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;use junit s assert format for assert messages to enable better suppor;this changes the message format of  assert  to match that of junit. this way ides like intellij idea are able to parse it and offer functionality like  compare values .;;0;use junits assert format for assert messages to enable better suppor;""this changes the message format of """"assert"""" to match that of junit this way ides like intellij idea are able to parse it and offer functionality like """"compare values"""""";i thought intellij already recognized rxjavas expected/actual after this: #5258 || i thought so too ||  merging 6262 ;;;;1;1;remove unnecessary < and > since its not matched by intellijs regex;"
6263;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;inline subscriptionhelper.iscancelled();addresses https://github.com/reactivex/rxjava/pull/6258#discussion_r228725602;;0;inline subscriptionhelperiscancelled();addresses https://githubcom/reactivex/rxjava/pull/6258#discussion_r228725602; merging 6263 ;;;;1;1;inline subscriptionhelperiscancelled();
"6269;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: call the doon{dispose|cancel} handler at most once;this pr makes sure the  doondispose    dooncancel  and  doonlifecycle  execute their cancellation handler once.;;6268.0;2x: call the doon{dispose|cancel} handler at most once;this pr makes sure the `doondispose` `dooncancel` and `doonlifecycle` execute their cancellation handler onceresolves: #6268; merging 6269 ;2x: firstorerror call on dispose twice;""in  rxjava (222) if i use the next code the `ondispose` callback is called twice i have already changed the code to not use this approach bc the `sonnext` inside the subscribe is pretty obscure but i report it just in case this can affect more cases looks like firstorerror (actually observableelementatsingle) can call upstream cancelation twicecode that produces the problem:```javabehaviorsubject<integer> s  behaviorsubjectcreate()sdoonlifecycle(d -> outprintln(""""subscribe"""") () -> { outprintln(""""dispose"""") sonnext(2) })        firstorerror()subscribe()dispose()```console output:```subscribedisposedispose```"";this is kind of an awkward reentrance problem ill have to investigate which components need to suppress dispose calls ||;1;0;2x: call the doon{dispose|cancel} handler at most once;"
"6275;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: improve the observable/flowable cache() operators;this pr rewrites the  observable.cache  and  flowable.cache  operators to allocate less and be more up-to-date algorithmically.;;627.0;2x: improve the observable/flowable cache() operators;this pr rewrites the `observablecache` and `flowablecache` operators to allocate less and be more up-to-date algorithmicallyive also added comments to help understand its inner workings in case someone is interestedresolves: #6270; merging 6275  < ;add a parallel execution function for processing a single emitted item over different parallel fucntions;we have the following use case  we create an observable which emits a single value  this value passes through a couple of standard rx map functions sequentially  after the sequential functions it then needs to have multiple validation functions to be executed concurrently  these are slow operations since they require i/o with external systems  if we can perform them in parallel we can significantly reduce our userss perceived execution timenote that this is different than the current parallel and parallelmap functions  these perform the same function over multiple emitted items  i need to perform multiple different functions in parallel over a single emitted value  it seems that the last step might need to be a zip or similar so that the user can provide an aggregation function and then emit a single value from the result of the parallel aggregationthoughts?;""are you looking for something like this?``` javastatic void sleep(long ms) {    systemoutprintln(""""sleeping for """" + ms + """" ms on thread """" + threadcurrentthread()getid())    try {        threadsleep(ms)    } catch (interruptedexception e) {        eprintstacktrace()    }}static observable<boolean> doexpensivetestsinparallel(observable<integer> obs) {    return obsflatmap(new func1<integer observable<boolean>>() {        public observable<boolean> call(final integer i) {            func0<boolean> expensivetest1  new func0<boolean>() {                public boolean call() { sleep(200) return i > 30 }            }            func0<boolean> expensivetest2  new func0<boolean>() {                public boolean call() { sleep(100) return i % 5  2 }            }            func0<boolean> expensivetest3  new func0<boolean>() {                public boolean call() { sleep(300) return i < 100 }            }            return observablemerge(                observablestart(expensivetest1 schedulersthreadpoolforio())                observablestart(expensivetest2 schedulersthreadpoolforio())                observablestart(expensivetest3 schedulersthreadpoolforio())            )all(functions<boolean>identity())        }    })}``` || thats very close  however in my case the functions themselves are quite complex and touch a lot of integration points  rather than have them as embedded functions i create classes that implements func1 or action1  therefore i need the ability to have both func1 or action1 to be invoked  this allows us to unit test each of our complex functions or actions and receive the input as an argument to the """"call"""" method || you can see an example of how we do this at netflix here:  a `flatmap` we kick off multiple async calls (you can do computation whereas we do io) and then merge or zip them together use merge if you dont care about their ordering or getting them back all at once || "";1;0;remove another unnecessary cast;"
"6278;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add materialize() and dematerialize();this pr adds the  materialize  operator to  maybe    single  and  completable  to turn their signals into the corresponding  notification  object. this operator has been available for  observable s (and  flowable s) from the beginning of the rx api. the methods return  single<notification<t>> .;;627.0;2x: add materialize() and dematerialize();this pr adds the `materialize` operator to `maybe` `single` and `completable` to turn their signals into the corresponding `notification` object this operator has been available for `observable`s (and `flowable`s) from the beginning of the rx api the methods return `single<notification<t>>`to complement the `dematerialize` operator is only defined for `single` and results in a `maybe`if accepted ill draw the correct marble diagrams for them in a separate prresolves: #6272; merging 6278 ;add a parallel execution function for processing a single emitted item over different parallel fucntions;we have the following use case  we create an observable which emits a single value  this value passes through a couple of standard rx map functions sequentially  after the sequential functions it then needs to have multiple validation functions to be executed concurrently  these are slow operations since they require i/o with external systems  if we can perform them in parallel we can significantly reduce our userss perceived execution timenote that this is different than the current parallel and parallelmap functions  these perform the same function over multiple emitted items  i need to perform multiple different functions in parallel over a single emitted value  it seems that the last step might need to be a zip or similar so that the user can provide an aggregation function and then emit a single value from the result of the parallel aggregationthoughts?;""are you looking for something like this?``` javastatic void sleep(long ms) {    systemoutprintln(""""sleeping for """" + ms + """" ms on thread """" + threadcurrentthread()getid())    try {        threadsleep(ms)    } catch (interruptedexception e) {        eprintstacktrace()    }}static observable<boolean> doexpensivetestsinparallel(observable<integer> obs) {    return obsflatmap(new func1<integer observable<boolean>>() {        public observable<boolean> call(final integer i) {            func0<boolean> expensivetest1  new func0<boolean>() {                public boolean call() { sleep(200) return i > 30 }            }            func0<boolean> expensivetest2  new func0<boolean>() {                public boolean call() { sleep(100) return i % 5  2 }            }            func0<boolean> expensivetest3  new func0<boolean>() {                public boolean call() { sleep(300) return i < 100 }            }            return observablemerge(                observablestart(expensivetest1 schedulersthreadpoolforio())                observablestart(expensivetest2 schedulersthreadpoolforio())                observablestart(expensivetest3 schedulersthreadpoolforio())            )all(functions<boolean>identity())        }    })}``` || thats very close  however in my case the functions themselves are quite complex and touch a lot of integration points  rather than have them as embedded functions i create classes that implements func1 or action1  therefore i need the ability to have both func1 or action1 to be invoked  this allows us to unit test each of our complex functions or actions and receive the input as an argument to the """"call"""" method || you can see an example of how we do this at netflix here:  a `flatmap` we kick off multiple async calls (you can do computation whereas we do io) and then merge or zip them together use merge if you dont care about their ordering or getting them back all at once || "";1;0;use dematerialize selector fix some docs;"
6281;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: add dematerialize(selector)  deprecate old;this pr adds the  dematerialize(function<t  notification<r>> selector)  overload to allow type-safe dematerialization of  notification  signals. the pre-existing  dematerialize()  forced the return type and assumed the items of the source are  notification  objects  which could not be enforced via the type system. this selector variant establishes the type link from  t  to  notification<r>  to  r  (where r == t is allowed).;;0;2x: add dematerialize(selector) deprecate old;this pr adds the `dematerialize(function<t notification<r>> selector)` overload to allow type-safe dematerialization of `notification` signals the pre-existing `dematerialize()` forced the return type and assumed the items of the source are `notification` objects which could not be enforced via the type system this selector variant establishes the type link from `t` to `notification<r>` to `r` (where r  t is allowed)the intended use is```javaobservable<notification<t>> source  observable<t> result  sourcedematerialize(notification -> notification)```aka identity mappingthe pre-existing `dematerialize()` methods are marked as deprecated now*(also the actual operator were missing from the examples in the respective javadocs)*; merging 6281 ;;;;1;1;fix parameter naming;
6283;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix observable.flatmap to sustain concurrency level;if the  observable.flatmap  operator run in limited concurrency mode and multiple sources completed at the same time while the operator was in its drain loop  the operator only started with one new inner source instead of trying to run replace all the completed inner sources with new ones.;;0;2x: fix observableflatmap to sustain concurrency level;if the `observableflatmap` operator run in limited concurrency mode and multiple sources completed at the same time while the operator was in its drain loop the operator only started with one new inner source instead of trying to run replace all the completed inner sources with new onesthe solution is to count the completed sources and replenish them in a loop*(the `flowable` variant works properly because it uses backpressure and inner source counting already to replenish those completed inner sources the `observable` doesnt have backpressure so it has to emulate it via the work-in-progress counting and the secondary queue for available inner sources)*fixes: #6282; merging 6283 ;;;;1;1;2x: fix observableflatmap to sustain concurrency level;
"6287;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: expose the keep-alive value of the io scheduler as system property. (#6279);configuring keep-alive through system property.;;627.0;2x: expose the keep-alive value of the io scheduler as system property (#6279);configuring keep-alive through system propertyresolves: #6279; merging 6287 ;add a parallel execution function for processing a single emitted item over different parallel fucntions;we have the following use case  we create an observable which emits a single value  this value passes through a couple of standard rx map functions sequentially  after the sequential functions it then needs to have multiple validation functions to be executed concurrently  these are slow operations since they require i/o with external systems  if we can perform them in parallel we can significantly reduce our userss perceived execution timenote that this is different than the current parallel and parallelmap functions  these perform the same function over multiple emitted items  i need to perform multiple different functions in parallel over a single emitted value  it seems that the last step might need to be a zip or similar so that the user can provide an aggregation function and then emit a single value from the result of the parallel aggregationthoughts?;""are you looking for something like this?``` javastatic void sleep(long ms) {    systemoutprintln(""""sleeping for """" + ms + """" ms on thread """" + threadcurrentthread()getid())    try {        threadsleep(ms)    } catch (interruptedexception e) {        eprintstacktrace()    }}static observable<boolean> doexpensivetestsinparallel(observable<integer> obs) {    return obsflatmap(new func1<integer observable<boolean>>() {        public observable<boolean> call(final integer i) {            func0<boolean> expensivetest1  new func0<boolean>() {                public boolean call() { sleep(200) return i > 30 }            }            func0<boolean> expensivetest2  new func0<boolean>() {                public boolean call() { sleep(100) return i % 5  2 }            }            func0<boolean> expensivetest3  new func0<boolean>() {                public boolean call() { sleep(300) return i < 100 }            }            return observablemerge(                observablestart(expensivetest1 schedulersthreadpoolforio())                observablestart(expensivetest2 schedulersthreadpoolforio())                observablestart(expensivetest3 schedulersthreadpoolforio())            )all(functions<boolean>identity())        }    })}``` || thats very close  however in my case the functions themselves are quite complex and touch a lot of integration points  rather than have them as embedded functions i create classes that implements func1 or action1  therefore i need the ability to have both func1 or action1 to be invoked  this allows us to unit test each of our complex functions or actions and receive the input as an argument to the """"call"""" method || you can see an example of how we do this at netflix here:  a `flatmap` we kick off multiple async calls (you can do computation whereas we do io) and then merge or zip them together use merge if you dont care about their ordering or getting them back all at once || "";1;0;2x: expose the keep-alive value of the io scheduler as system property (#6279);"
6287;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: expose the keep-alive value of the io scheduler as system property. (#6279);configuring keep-alive through system property.;;6279.0;2x: expose the keep-alive value of the io scheduler as system property (#6279);configuring keep-alive through system propertyresolves: #6279; merging 6287 ;expose the keep-alive value of the io scheduler as system property;currently the keep-alive is 60 seconds constant: [ioschedulerjava#l37]( the configuration could be done via `integergetinteger()` similar to how `priority` is configurable: [l52]( documentation of [schedulersjava#l32]( and [schedulersjava#l158]( should also describe this option;;1;0;2x: expose the keep-alive value of the io scheduler as system property (#6279);
6297;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix refcount eager disconnect not resetting the connection;this pr fixes the case when an observer/subscriber disposes/cancels immediately upon subscribing to a  refcount  operator before it establishes the connection and ends up with a disposed but non-reset connection  preventing further interactions with the connectable source.;;629.0;2x: fix refcount eager disconnect not resetting the connection;this pr fixes the case when an observer/subscriber disposes/cancels immediately upon subscribing to a `refcount` operator before it establishes the connection and ends up with a disposed but non-reset connection preventing further interactions with the connectable sourcethe fix is to detect this case and reset the connection when the `connect()` method signals the dispose handlerboth `connectableflowablerefcount` and `connectableflowablerefcount` is affectedfixes: #6296; merging 6297 ;toblockingobservable wraps exception so i cant handle it with try catch;```try {result result  apigetresult(params)                        toblockingobservable()                        last()   } catch (final throwable e) { // cannot catch myexception here because it wrapped with runtimeexception spawned by blockingobservable   if (e instanceof myexception) {   }}```;checked exceptions need to be wrapped as the iterable interface doesnt allow throwing implementations therefore anything that is not subclass of runtimeexception (or error) is wrapped into a runtimeexception use `getcause()` to extract the myexception || using onerrorreturn or other error handling methods of observable and only blocking at the very end would be better style since you can use your error handling logic for both non-blocking and blocking code || @akarnokd thanks i think that should be highlight in docs because its not obvious@samuelgruetter nice tip! || it doesnt wrap `runtimeexception` only if it is a checked `exception` so is the exception you were expecting a checked `exception`? if it was a `runtimeexception` then it should have thrown it and your catch would work otherwise we have a bug ||;1;0;remove unnecessary comment;
6301;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add missing onsubscribe null-checks to npe docs on flowable/observable subscribe;happened to notice these today;;0;add missing onsubscribe null-checks to npe docs on flowable/observable subscribe;happened to notice these today; merging 6301 ;;;;1;1;add missing onsubscribe null-checks to npe docs on flowable/observable subscribehappened to notice these today;
6303;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;javadoc: fix incorrect image placement;add  <p>  before image elements in javadoc.;;6302.0;javadoc: fix incorrect image placement;add `<p>` before image elements in javadocresolves: #6302; merging 6303 ;javadoc: flowable::zipwith image is displayed incorrectly;there is a small problem with the images in the current javadoc (223) of the following operators:- [`flowable::zipwith(publisher bifunction)`]( [`flowable::zipwith(publisher bifunction boolean)`]( [`flowable::zipwith(publisher bifunction boolean int)`]( the javadoc is viewed on a wide screen the images are displayed on the right side instead of the left i have a screenshot attached where the problem can be seenthe problem can be resolved by adding `<p>` before the image element![screenshot_2018-11-11 flowable rxjava javadoc 2 2 3](https://user-imagesentcom/12369767/48316512-ec073680-e5e4-11e8-8d20-566b63d32a3epng);pr welcome ||;1;0;fix(incorrect image placement);
6305;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;javadoc : explain explicitly about using emitter interface methods synchronously;add note in javadoc explicitly explaining about using emitter interface methods synchronously.;;6299.0;javadoc : explain explicitly about using emitter interface methods synchronously;add note in javadoc explicitly explaining about using emitter interface methods synchronously- add notes for `generate` methods in observable and flowable- plus add the similar note to emitter interfaceresolves: #6299; merging 6305  < ;javadoc: explain explicitly that the emitter methods should be called non-concurrently with generate;the javadocs of the `generate` methods as well the `emitter` interface should explicitly mention that the methods should be called non-concurrently generate can be found in both `flowable` and `observable`#### generate:```html<p>note that the {@link emitter#onnext} {@link emitter#onerror} and {@link emitter#oncomplete} methods provided to the function should be called synchronouslynever concurrently and only while the method is executing calling them from multiple threads or outside the function call is not supported and leads to an undefined behavior```#### emitter:```html<p>note that the {@link emitter#onnext} {@link emitter#onerror} and {@link emitter#oncomplete} methods provided to the function should be called synchronouslynever concurrently calling them from multiple threads is not supported and leads to an undefined behavior```;i believe calling from multiple threads is supported if there is a happens-before relationship between calls perhaps this:```<p>note that there must be a <i>happens-before</i> relationship between calls to the {@link emitter#onnext} {@link emitter#onerror} and {@link emitter#oncomplete} methods calling those methods from multiple threads without establishing that relationship is not supported and leads to undefined behavior``` || fundamentally the calls should not escape the callback method and one would have to block the callback if the `onnext` happens asynchronously to the method still you can only call it once and the blocking implicitly establishes this relationship || sounds good thanks @akarnokd  ||;1;0;javadoc : explain explicitly about non-concurrency for emitter interface methods;
6308;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;javadoc updates for rxjava issue 6289;updates to io.reactivex.flowable javadocs as per #6289.;;6289.0;javadoc updates for rxjava issue 6289;updates to ioreactivexflowable javadocs as per #6289 updated docs for all 6 flowablegroupby() methods; merging 6308  < ;javadoc: explain flowablegroupby should be consumed on all of its outputs;in order for `flowablegroupby` to remain bounded in memory it uses a prefetch and consumption-based replenishment strategy: when a group has consumed an item a new item is requested from the source of `groupby`since a new item may create a fresh group the only way to move forward is to have that group consumed as well for this the `groupedflowable` itself has to reach some operator and get subscribed tothe typical use is with `flatmap` that will subscribe to the groups and keeps consuming them however `flatmap` by default works in a limited concurrency mode it means as long as the groups themselves dont complete `flatmap` wont accept a newer group and thus that group will not get consumed resulting in a potential livelock the solution is to have a larger max-concurrency as there are number of groups expected potentially going unbounded with `flatmap` completelythis is not an issue with `observablegroupby` because there is no backpressure and non-consumed groups cant hinder active groupsi suggest extending the javadocs of all `flowablegroupby` about this property something along the lines of:```html<p>note that the {@link groupedflowable}s should be subscribed to as soon as possible otherwise the unconsumed groups may starve other groups due to the internal backpressurecoordination of the {@code groupby} operator such hangs can be usually avoided by using {@link #flatmap} or {@link #concatmapeager} and overriding the default maximum concurrency value to be greater or equal to the expected number of groups possibly using {@link integermax_value} if the number of expected groups is unknown```(please when writing the `{@link #}`s out pick the shortest overload of the respective method that also includes the `maxconcurrency` parameter your ides content assist should help you in this regard);ah this has been done in #6308 closing ||;1;0;with review comments on issue 6289;
6311;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;javadoc: explain that distinctuntilchanged requires non-mutating data to work as expected;- add note in javadoc for all  distinctuntilchanged()  methods in  flowable  and  observable  class explaining about unexpected results to expect when using mutable data sources like **mutable charsequence** or **lists**.;;6290.0;javadoc: explain that distinctuntilchanged requires non-mutating data to work as expected;- add note in javadoc for all `distinctuntilchanged()` methods in `flowable` and `observable` class explaining about unexpected results to expect when using mutable data sources like **mutable charsequence** or **lists**resolves: #6290; merging 6311 ;javadoc: explain that distinctuntilchanged requires non-mutating data to work as expected;`distinctuntilchanged` keeps the last value/key (depending on the overload) so it can compare it agains the newer value/key via `objectequals` however if the value/key is mutable and gets mutated in between elements the operator may not work as expected and filter out the seemingly same data:```javapublishsubject<list<integer>> subject  publishsubjectcreate()list<integer> list  new arraylist<integer>()listadd(1)subjectdistinctuntilchanged()subscribe(systemout::println)subjectonnext(list)// prints [1]listadd(2)subjectonnext(list)// does not print anything but [1 2] was expected```in the example the same reference is passed to `distinctuntilchanged` thus two subsequent items evaluate as same this mistake by the user is also very common on android and with text components using a mutable `charsequence`i suggest adding a section to every `distinctuntilchanged` variant explaining the situation in short something along the lines:```<p>note that if the element type of the flow is mutable the comparison of the previous and current item may yield unexpected results if the items are mutated externally common cases are mutable{@code charsequence}s or {@code list}s where subsequent objects are actually the same references modified before/after {@code distinctuntilchanged} it is recommended mutable data isconverted to an immutable one such as `map(charsequence::tostring)` or `map(collections::unmodifiablelist)` for example to avoid the situation```;nice never actually thought of this case very valid   few questions before the pr 1 this should reflect on withlatestform variants for `observable` & `flowable` types right?2 additionally will it be okay to link this issue to the doc for clarity? || hi1 its about the `distinctuntilchanged` where this mutation is most obviously affecting a flow all overloads in both `observable` and `flowable` should be updated2 we dont link to issues in the main javadoc ||;1;0;remove tests and fix typo in javadoc;
6313;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;adding nonnull annotations to observable & single;adding nonnull annotations in factory methods for improved code compilation;;630.0;adding nonnull annotations to observable & single;adding nonnull annotations in factory methods for improved code compilationresolves: #6309;#6309 @akarnokd can you pls take a look at this and review ? || thanks for contributing a few points:- you dont have to keep the welcome text of the pr thats for telling contributors what to do see the updated text for future reference- didnt you mean to add `@nonnull` to the arguments rather than to the return value? ||  merging 6313 ;exception in oncompleted() not propagate to onerror();when an exception occurred in oncompleted() the exception is not propagate to onerror()code of rxoperatorssafeobserver```    @override    public void oncompleted() {        if (isfinishedcompareandset(false true)) {            try {                actualoncompleted()            } catch (throwable e) {                // handle errors if the oncompleted implementation fails not just if the observable fails                onerror(e)            }            // auto-unsubscribe            subscriptionunsubscribe()        }    }```in our case isfinished is already true so onerror does nothing``` @override    public void onerror(throwable e) {        if (isfinishedcompareandset(false true)) {                   }    }```;thats intentional according to rx contract a observer should not receive both oncompleted and onerror you need to handle the exception in oncompleted by yourself![2013-12-17 7 38 00]( || ok the contract is clearso i dont understand why in **safeobserver** there is this code```catch (throwable e) {    // handle errors if the oncompleted implementation fails not just if the observable fails    onerror(e)}```its in contradiction with the grammar and because **isfinished** is set to **true** so this call is _useless_why not call a global errorhandler or something like that in the _catch_ ?i dont understandregardsronan || ha yep that code is pretty useless kind of funny  ill submit a fix shortly ||;1;0;adding nonnull annotation;
6314;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;change javadoc explanation for mutable list;as per [this]( discussion  change javadoc for  distinctuntilchanged()  method for mutable list.;;0;change javadoc explanation for mutable list;as per [this]( discussion change javadoc for `distinctuntilchanged()` method for mutable list; ;;;;1;1;change javadoc explanation for mutable list;
"6321;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix flowable#toobservable backpressure support;6320;;632.0;fix flowable#toobservable backpressure support;6320; merging 6321  < ;newthreadscheduler thread exhaustion;""the current implementation of `newthreadscheduler` creates a new threadpoolexecutor for each non-recursive schedule invocation the pool is never terminated (except when the application terminates) therefore pools no longer in use still keep one thread active (blocked on waiting for the next task which cant arrive) if too many pools are created the operating system might run out of fresh threads causing """"native thread creation failed"""" throughout the application to demonstrate the problem here is a small test case:``` javapublic class newthreadschedulertest {    @test    public void testexhaustion() throws interruptedexception {        scheduler s  schedulersnewthread()        blockingobservable<integer> source  observablefrom(1)                subscribeon(s)toblockingobservable()        for (int i  0 i < 10000 i++) {            assertassertequals((integer)1 sourcesingle())        }    }}```(this test fails on my windows 7 x86 after about 4000 iterations)its equivalent rxnet code however works fine:``` c#class program {        static void main(string args) {            ischeduler s  newthreadschedulerdefault            iobservable<int> source  observabletoobservable(new int { 1 } s)                    subscribeon(s)            int sum  0            for (int i  0 i < 10000 i++) {                sum + sourcesingle()                threadsleep(1)                if (i % 256  0) {                    consolewrite(i)                    consolewrite("""": """")                    consolewriteline(sum)                }            }        }    }```the programs thread count remains about 15 (it seems that rxnet uses vanilla threads in combination with some kind of currentthreadscheduler in it and has an explicit option to quit if no more tasks are queued or pending)ive tried to fix newthreadscheduler by setting a keepalive on the thread pool but unfortunately it breaks the `operationparallelmergetest` because a restarted thread in the thread pool will get a different identifier ive tried adding wip counter to capture when to terminate the pool but didnt work (probably due escaped scheduler reference is invoked outside the callback function/action)any ideas?"";""i think the issue is two-fold:1) newthreadscheduler does not shutdown the executor in the subscription it returns2) blockingobservable does not obey guideline 43 and unsubscribe when it completes generally we rely upon a user provided observer and the safeobserver doing this but blockingobservable never receives a user provided observer```43 assume resources are cleaned up after an onerror or oncompletedmessageparagraph 41 states that no more messages should arrive after an onerror or oncompleted message this makes it possible to cleanup any resource used by the subscription the moment an onerror or oncompleted arrives cleaning up resources immediately will make sure that any side-effect occurs in a predictable fashion it also makes sure that the runtime can reclaim these resourcessampleobservableusing(() > new filestream(@""""d:\temp\testtxt"""" filemodecreate) fs > observablerange(0 10000)select(v > encodingasciigetbytes(vtostring()))            writetostream(fs))        subscribe()in this sample the using operator creates a resource that will be disposed upon unsubscription the rx contract for cleanup ensures that unsubscription will be called automatically once an onerror or oncompleted message is sent``` || im working on this || ive confirmed its what i thought  the `blockingobservable` doesnt call `unsubscribe` when `oncomplete`/`onerror` happen and thus the resources are not freed the example code works fine if `blockingobservable` is not involved and a normal async `subscribe` is used || before fixing bo would it be possible to merge our prs changing the same files so we dont have to rebase everything again?unfortunately there is no good way to detect if an iteration has stopped in java we can have a foreach overload that takes a predicate || yeah i can merge it i intend on working more on this tonight just havent had time to finish it during my day hoursfor an iteration stopping isnt it sufficient to know that we have exited that block of code and just have the completion marker style thing invoked right after we exit the iteration? || when java 7 introduced the `directorystream` they faced a similar issue: one would need to call `close` on the iterator but then you cant use for-each loop for enumeration the solution was to have `directorystream` `closeable` and return only a single `iterator` therefore this pattern is established:``` javatry (directorystream ds  list(""""*"""")) {   for (path p : ds) {      if (ptostring()endswith(""""xml"""")) {         break      }   }}```we can have a `blockingobservableonetimeiterable()` returning an `iterableunsubscribable` instance and require a similar patternalternatively the following foreach overload could do the trick:``` javablockingobservableforeachuntil(func1<t boolean> breakoutconsumer)```where the function `breakoutconsumer` should return true if it wishes to continue the loop || that seems to solve a different problem breaking out of a `foreach` loop on an infinite stream as opposed to knowing when it completes the `takeuntil` operator already enables conditionally breaking an infinite stream `foreachuntil` is just merging those together what exactly is the use case you were referring to for this statement > """"there is no good way to detect if an iteration has stopped in java""""? || the `takeuntil` seems to be appropriate but we still need a boawait() to run to run through the results and blocka case:``` javapublic integer one() {return observablefrom(1)subscibeon(schedulersthreadpoolforcomputation())repeat()toblockingobservable()toiterable()iterator()next()}```we dont have the idisposable in java which seems to handle exactly these issues || what is the issue in that code example other than the one we already know that causes `blockingobservable` to not correctly unsubscribe? || up to the `toblockingobservable()` it is an infinite stream of 1s we take the first value of this stream and leave the whole thing there is no way the bo can detect that nothing is iterating it further and cant stop because the upstream wont complete one would need a way to tell the iterator to stop || id argue that next() on an infinite iterator is bad code same way that calling `tolist()` on an infinite stream is bad code || yes if you know that it is an infinite iterator the example could feature a ``` javarange(1 10000000)scheduleon(schedulersthreadpoolforcomputation())toblockingobservable()toiterable()iterator()next()```which it is finite yet wasteful we could return a subclass of `iterable` and `iterator` that allow unsubscribing when someone uses the `stoppableiterable` and `stoppableiterator` without calling stop that is definitely a bad code when you have just the `iterable` there is no contract or way to do the stopping similar problem appeared with streams in the lambda-dev recently || closing this as the original test case now passes as expected || "";1;0;fix flowable#toobservable backpressure support;"
"6335;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;replace indexed loop with for-each java5 syntax;thank you for contributing to rxjava. before pressing the  create pull request  button  please consider the following points:;;0;replace indexed loop with for-each java5 syntax;""thank you for contributing to rxjava before pressing the """"create pull request"""" button please consider the following points:  -  please give a description about what and why you are contributing even if its trivial  -  please include the issue list number(s) or other pr numbers in the description if you are contributing in response to those  -  please include a reasonable set of unit tests if you contribute new code or change an existing one if you contribute an operator (if applicable) please make sure you have tests for working with an `empty` `just` `range` of values as well as an `error` source with and/or without backpressure and see if unsubscription/cancellation propagates correctly""; merging 6335 ;;;;1;1;keep empty lines as per @akarnokd code review;"
6344;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;javadoc: incorrect  return types in javadoc comments;this pr fixes some mistakes in javadoc comments of some methods inside  flowable.java  and  observable.java  where the actual return type differs from what is described in the documentation.;;0;javadoc: incorrect  return types in javadoc comments;this pr fixes some mistakes in javadoc comments of some methods inside `flowablejava` and `observablejava` where the actual return type differs from what is described in the documentationrelates to: #4535; merging 6344 ;;;;1;1;fix: use correct return type in javadoc documentation;
6346;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;javadoc: fix examples using markdown instead of @code;in javadoc  backtick has no meaning and caused javadoc compilation errors:;;0;javadoc: fix examples using markdown instead of @code;in javadoc backtick has no meaning and caused javadoc compilation errors //travis-ciorg/akarnokd/rxjava2_9/jobs/469904725#l516; merging 6346 ;;;;1;1;javadoc: fix examples using markdown instead of @code;
"6359;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix the error/race in observable.repeatwhen due to flooding repeat signal;this pr fixes a race condition in the  observablerepeatwhen  operator for the case when the repeat signal is not 1-for-1 and a new subscription may race with the clearing of the previous disposable because  active  is set to  false  too early. the fix is to swap the two operations.;;6358.0;2x: fix the error/race in observablerepeatwhen due to flooding repeat signal;this pr fixes a race condition in the `observablerepeatwhen` operator for the case when the repeat signal is not 1-for-1 and a new subscription may race with the clearing of the previous disposable because `active` is set to `false` too early the fix is to swap the two operations `observableretrywhen` and the `flowable` versions do not have this bug unit tests were added to all 4 operators to verify the correct behavior regardlessfixes: #6358; merging 6359 ;2x: disposable already set! using delaysubscription with takeuntil/repeatwhen;""issue encountered in: ioreactivexrxjava2 224when using a combination of takeuntil/repeatwhen operators on an observable with delaysubscription operator applied it is possible to encounter a protocolviolationexception: disposable already set! thrown by repeatwhenobserver#onsubscribe it appears that if delaysubscription uses an observablesource which rapidly/concurrently emits multiple notifications a rare race condition leads to a double subscription issuei am not sure if this issue is a user error (take(1) on observablesource supplied to delaysubscription alleviates it) or a bug in rxjava however the following slow unit test demonstrates it:```java    @test    public void delaysubscriptionwithrepeatwhen() {        list<throwable> errors  testhelpertrackpluginerrors()        executorservice executor  executorsnewthreadpool(2)        try {            observable<object> subscriptionsignal  observablemerge(                    observablejust(new object())delay(0 timeunitmilliseconds)                    observablejust(new object())delay(0 timeunitmilliseconds)            )            final subject<boolean> boolstream  publishsubject<boolean>create()toserialized()            observable<boolean> brokenstream  boolstream                    delaysubscription(subscriptionsignal)                    takeuntil(new predicate<boolean>()  {                        @override                        public boolean test(boolean state) throws exception {                            return state                        }                    })                    repeatwhen(new function<observable<object> observablesource<?>>() {                        @override                        public observablesource<?> apply(observable<object> objectobservable) throws exception {                            return boolstreamfilter(new predicate<boolean>() {                                @override                                public boolean test(boolean state) throws exception {                                    return !state                                }                            })                        }                    })            final random random  new random()            for (int i  0 i < 1000000 i++) {                final testobserver<boolean> testobserver  brokenstreamtest()                executorexecute(new runnable() {                    @override                    public void run() {                        boolstreamonnext(randomnextboolean())                        testobserver                                assertnoerrors()                                dispose()                    }                })                if (!errorsisempty()) {                    fail(""""uncaught fatal errors: """" + errors)                }            }        } finally {            executorshutdown()            try {                executorawaittermination(30 timeunitseconds)            } catch (interruptedexception e) {            }        }    }```"";""ive tried the test provided but didnt get any protocol violations with 225 please provide a stacktrace of the actual error || @akarnokd here is the stacktrace:```javalangassertionerror: uncaught fatal errors: ioreactivexexceptionsprotocolviolationexception: disposable already set!	at ioreactivexinternaldisposablesdisposablehelperreportdisposableset(disposablehelperjava:156)	at ioreactivexinternaldisposablesdisposablehelpersetonce(disposablehelperjava:82)	at ioreactivexinternaloperatorsobservableobservablerepeatwhen$repeatwhenobserveronsubscribe(observablerepeatwhenjava:95)	at ioreactivexinternaloperatorsobservableobservabletakeuntilpredicate$takeuntilpredicateobserveronsubscribe(observabletakeuntilpredicatejava:49)	at ioreactivexinternaloperatorsobservableobservabledelaysubscriptionothersubscribeactual(observabledelaysubscriptionotherjava:39)	at ioreactivexobservablesubscribe(observablejava:12246)	at ioreactivexinternaloperatorsobservableobservabletakeuntilpredicatesubscribeactual(observabletakeuntilpredicatejava:32)	at ioreactivexobservablesubscribe(observablejava:12246)	at ioreactivexinternaloperatorsobservableobservablerepeatwhen$repeatwhenobserversubscribenext(observablerepeatwhenjava:151)	at ioreactivexinternaloperatorsobservableobservablerepeatwhensubscribeactual(observablerepeatwhenjava:60)	at ioreactivexobservablesubscribe(observablejava:12246)	at ioreactivexobservabletest(observablejava:15441)	at ioreactivexinternaloperatorsobservableobservabledelaytestdelaysubscriptionwithrepeatwhen(observabledelaytestjava:1020)	at sunreflectnativemethodaccessorimplinvoke0(native method)	at sunreflectnativemethodaccessorimplinvoke(nativemethodaccessorimpljava:62)	at sunreflectdelegatingmethodaccessorimplinvoke(delegatingmethodaccessorimpljava:43)	at javalangreflectmethodinvoke(methodjava:498)	at orgjunitrunnersmodelframeworkmethod$1runreflectivecall(frameworkmethodjava:50)	at orgjunitinternalrunnersmodelreflectivecallablerun(reflectivecallablejava:12)	at orgjunitrunnersmodelframeworkmethodinvokeexplosively(frameworkmethodjava:47)	at orgjunitinternalrunnersstatementsinvokemethodevaluate(invokemethodjava:17)	at orgjunitinternalrunnersstatementsrunbeforesevaluate(runbeforesjava:26)	at orgjunitrunnersparentrunnerrunleaf(parentrunnerjava:325)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:78)	at orgjunitrunnersblockjunit4classrunnerrunchild(blockjunit4classrunnerjava:57)	at orgjunitrunnersparentrunner$3run(parentrunnerjava:290)	at orgjunitrunnersparentrunner$1schedule(parentrunnerjava:71)	at orgjunitrunnersparentrunnerrunchildren(parentrunnerjava:288)	at orgjunitrunnersparentrunneraccess$000(parentrunnerjava:58)	at orgjunitrunnersparentrunner$2evaluate(parentrunnerjava:268)	at orgjunitrunnersparentrunnerrun(parentrunnerjava:363)	at orgjunitrunnerjunitcorerun(junitcorejava:137)	at comintellijjunit4junit4ideatestrunnerstartrunnerwithargs(junit4ideatestrunnerjava:68)	at comintellijrtexecutionjunitideatestrunner$repeaterstartrunnerwithargs(ideatestrunnerjava:47)	at comintellijrtexecutionjunitjunitstarterpreparestreamsandstart(junitstarterjava:242)	at comintellijrtexecutionjunitjunitstartermain(junitstarterjava:70)``` || thanks this is a race condition due to that flooding """"repeat"""" signal and `active` set to false before the previous `disposable` is cleared the `retrywhen` is implemented correctly in this regard ill post a fix shortly || "";1;0;2x: fix the error/race in obsrepeatwhen due to flooding repeat signal;"
6364;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix publish not requesting upon client change;due to a bug in the  flowable.publish  operator  it is not requesting more if there was a change in the subscriber array during an emission run in the non-fused operation mode.;;636.0;2x: fix publish not requesting upon client change;due to a bug in the `flowablepublish` operator it is not requesting more if there was a change in the subscriber array during an emission run in the non-fused operation modefixes: #6363; merging 6364  < ;operators bochunkify bocollect oforiterable;issue #634any suggestions for a name instead of `foriterable`?;#566  split into two ||;1;0;add fused test rename test method;
6365;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;indicate source disposal in timeout(fallback);some of the overloads of  timeout(  fallback)  operator didn t indicate that source gets disposed on timeout in the javadoc.;;0;indicate source disposal in timeout(fallback);some of the overloads of `timeout( fallback)` operator didnt indicate that source gets disposed on timeout in the javadoc; merging 6365 ;;;;1;1;indicate source disposal in timeout(fallback);
6370;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: add interruptible mode to schedulers.from;by default  the  schedulers.from  uses a trampoline to ensure worker tasks are executed fifo and non-overlappingly on any potentially multi-threaded  executor . this old setup didn t allow task interruption due to this disconnect between the trampoline task and the operator task. (in contrast  the standard schedulers use single threaded executors and their  future  is linked and interruptible when the operator task is cancelled).;;636.0;2x: add interruptible mode to schedulersfrom;by default the `schedulersfrom` uses a trampoline to ensure worker tasks are executed fifo and non-overlappingly on any potentially multi-threaded `executor` this old setup didnt allow task interruption due to this disconnect between the trampoline task and the operator task (in contrast the standard schedulers use single threaded executors and their `future` is linked and interruptible when the operator task is cancelled)this pr add an interruptible mode to the `schedulersfrom` via a paramerer in a new overload and some internal dispatching based on this mode selector existing `schedulersfrom(executor)` users should still behave the sameresolves: #6368; merging 6370 ;operators bochunkify bocollect oforiterable;issue #634any suggestions for a name instead of `foriterable`?;#566  split into two ||;1;0;2x: add interruptible mode to schedulersfrom;
6371;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix bounded replay() memory leak due to bad node retention;this pr fixes a memory leak caused by node retention in the bounded  replay()  implementations. when the consumer disposed/canceled the flow  the  index  field was not cleared. in certain situations  such out-of-comission consumers were still reachable via thread local stack and through it  the node they were last refencing. further items through it would then keep referencing an ever increasing number of linked nodes  causing oome eventually.;;0;2x: fix bounded replay() memory leak due to bad node retention;this pr fixes a memory leak caused by node retention in the bounded `replay()` implementations when the consumer disposed/canceled the flow the `index` field was not cleared in certain situations such out-of-comission consumers were still reachable via thread local stack and through it the node they were last refencing further items through it would then keep referencing an ever increasing number of linked nodes causing oome eventuallythe fix is to clear the `index` field upon dispose/cancellation the subject/processor variants were working properly tests were added to verify them though as wellissue discovered on stackoverflow: https://stackoverflowcom/q/54191190/61158; merging 6371 ;;;;1;1;2x: fix bounded replay() memory leak due to bad node retention;
"6375;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: don t dispose the winner of {single|maybe|completable}.amb();this pr fixes the  single.amb    maybe.amb  and  completable.amb  operators to not dispose the winner source  causing potential interruptions as a side-effect on the current thread.;;637.0;2x: dont dispose the winner of {single|maybe|completable}amb();this pr fixes the `singleamb` `maybeamb` and `completableamb` operators to not dispose the winner source causing potential interruptions as a side-effect on the current threadthe fix is to [delete]( the winner from the composite before disposing the rest to avoid the interruption raceunit tests were added to verify this behavior on all `amb` implementations `flowable` and `observable` were already working correctlyfixes: #6373; merging 6375 ;why subscribe with single action for onnext design to crush if error happened?;why subscribe with single action for onnext designed to crush if error happened? i thought that missing of onerror should just silently failobservable1subscribe(new action1<myresult>() {}) // will crush if onerror is calledwhat is preferred way to subscribe if i want silently fail onerror? using my own observer?;""i cant tell the reason but we have the following overload:`subscription subscribe(final action1<? super t> onnext final action1<throwable> onerror)`where you can specify your error handler alternatively you need to implement `observer<t>` to get all 3 kinds of events || i dont see this as being any different than writing regular code without a try/catch and then a runtimeexception being thrown if error handling is ignored and a runtimeexception occurs it will throwabsence of an error handler should not mean """"swallow errors silently and fail without any way of knowing something happened"""" that results in very non-obvious bugs and bad system operations if errors want to be swallowed that needs to be a conscious choicetwo simple approaches that come to mind for swallowing errors are:1) an empty handler can be passed in (such as to the overload @akarnokd mentioned) or a fully qualified implementation of `observer` with the `onerror` method doing nothing using the overloads though allows code such as:``` groovyobservablewitherrorsubscribe({ value -> println(value)} {throwable -> /* do nothing */})```2) use the `onerrorresumenext` operator in your sequence and make it return `observableempty()```` groovyobservablewitherroronerrorresumenext(observableempty())subscribe({ value -> println(value)})```hope this helps || is this answered sufficiently or do you still think something is done wrong? || @benjchristensen yeah i thinks its clear now thanks a lot! || "";1;0;add null-source test to maybeambtest;"
6377;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;expand  observable#debounce  and  flowable#debounce  javadoc;mention that if the processing of a task takes too long;;6288.0;expand `observable#debounce` and `flowable#debounce` javadoc;mention that if the processing of a task takes too longand a newer item arrives then the previous task willget disposed interrupting a long running workfixes: #6288; merging 6377 ;javadoc: expand debounce() docs to explain possible interruption;`debounce` schedules a timeout which then emits the last item if no newer item arrives in the meantime however if the processing takes too long a newer item may arrive and the previous task will get disposed possibly interrupting the long running workthe `flowabledebounce` and `observabledebounce` javadocs should mention this property for clarity something along the lines:```html<p>delivery of the item after the grace period happens on the (default|given) {@code scheduler}s {@code worker} which if takes too long a newer item may arrive from the upstream causing the {@code worker}s task to get disposed which may also interrupt any downstream blocking operation(yielding an {@code interruptedexception}) it is recommended processing itemsthat may take long time to be moved to another thread via {@link #observeon} applied after {@code debounce} itself```;;1;0;expand `observable#debounce` and `flowable#debounce` javadocmention that if the processing of a task takes too longand a newer item arrives then the previous task willget disposed interrupting a long running workfixes: #6288;
"6380;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;fix bug in compositeexception.getrootcause;i found what i believe is a bug in  compositeexception.getrootcause .;;0;fix bug in compositeexceptiongetrootcause;""i found what i believe is a bug in `compositeexceptiongetrootcause`the [original code]( use to be `if (root  null || root  e)` but apparently after some refactoring it ended up as `if (root  null || cause  root)`as a side note i think this method should be made `static` (that would have prevented the bug)<!--thank you for contributing to rxjava before pressing the """"create pull request"""" button please consider the following points:  -  please give a description about what and why you are contributing even if its trivial  -  please include the issue list number(s) or other pr numbers in the description if you are contributing in response to those  -  please include a reasonable set of unit tests if you contribute new code or change an existing one if you contribute an operator (if applicable) please make sure you have tests for working with an `empty` `just` `range` of values as well as an `error` source with and/or without backpressure and see if unsubscription/cancellation propagates correctly-->""; merging 6380 ;;;;1;1;update unit tests for compositeexceptiongetrootcause;"
6386;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;add doonterminate to single/maybe for consistency;this pr adds doonterminate operator to single and maybe.;;6379.0;add doonterminate to single/maybe for consistency;this pr adds doonterminate operator to single and mayberesolves: #6379; merging 6386 ;add doonterminate to single/maybe for consistency;as mentioned in #5814 there is no `doonterminate` operator on `single` or `maybe` but there is on `observable` `flowable` and `completable` there doesnt seem to be any reason for this inconsistency other than its just an omission yes you can workaround this using `dononevent` but can we instead get this operator added just for api consistency?;okay pr welcome || @akarnokd i would like to contribute to this feature is this issue free to work on? however even though it seems pretty straightforward im new to this project and it may take some time for me to submit a final pr is it acceptable? i dont want to block if its an urgent need and can be done by somebody else in a faster manner  nobody has started working on this to my knowledge i suggest you do it either way so you gain experience with doing prs as well as creating rxjava operators || thanks for the tip will do ||;1;0;add doonterminate to single/maybe for consistency (#6379);
6398;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix window() with start/end selector not disposing/cancelling properly;this pr fixes the start-end selector variant of  observable.window  and  flowable.window  to properly;;0;2x: fix window() with start/end selector not disposing/cancelling properly;this pr fixes the start-end selector variant of `observablewindow` and `flowablewindow` to properly - dispose the window-opening sequence upon disposing the main output flow and - disposing the main upstream upon disposing the main output flow provided there are no windows openfixes: #6397; merging 6398 ;;;;1;1;fix cancellation upon backpressure problem/handler crash;
6405;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix concateager to dispose sources & clean up properly.;this pr fixes the  concatmapeager  operator (which drives the static variants as well) to properly dispose and clean up the state of the operator upon cancelling/disposing the sequence.;;640.0;2x: fix concateager to dispose sources & clean up properly;this pr fixes the `concatmapeager` operator (which drives the static variants as well) to properly dispose and clean up the state of the operator upon cancelling/disposing the sequence- `flowableconcatmapeager` did not cancel the current active inner consumer only the ones coming after- `observableconcatmapeager` did not dispose the main source of the inner observablesboth variants have received the same two unit tests to verify their behaviorfixes: #6404; merging 6405 ;scala publish;the current scala bindings for publish are as follows:  def publish: (() > subscription observable[t])  {    val javaco  asjavaobservablepublish()    (() > javacoconnect() toscalaobservable[t](javaco))  }this has a couple of downsides- it forces every caller has to invent names for the two pieces whereas they already have  names given by the callee    val (foo bar)  bazpublish()vs  val bar  bazpublish()  barsubscribe()  barconnect- it hides the fact that publish returns a connectable observable so you cannot call refcount- why split up a nice object into a tuple of unrelated things maybe that makes sense if you want to pass the two pieces around separately but that is typically not the case of connectable observablesif i dont hear anyone screaming loudly i am going to change this to mimic the java signature;when i came up with this `(() > subscription observable)` pattern the scala observable extended `anyval` so it was final and i could not make a `connectableobservable` extending it but now this problem is gone so i think it makes sense to replace `(() > subscription observable)`  connectableobservable` (of course not only in `publish` but also in `multicast` and `replay`)theres a similar situation with `groupby`: in java we have a `groupedobservable<k t>` and in scala we have a `observable[(k observable[t])]` here however i wouldnt change anything because an observable emitting tuples which map keys to observables makes more sense than claiming that the key is part of the observable and also the tuples allow nice for comprehensions like `for ((key obs) <- ogroupby())` || @headinthebox @samuelgruetter has this been resolved? || should be resolved in #1160 ||;1;0;2x: fix concateager to dispose sources & clean up properly;
"6408;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;improving javadoc of flattenasflowable and flattenasobservable method;improving the javadoc of the  flattenasflowable  and  flattenasobservable  methods of  single  and  maybe  classes.;;6276.0;improving javadoc of flattenasflowable and flattenasobservable method;improving the javadoc of the `flattenasflowable` and `flattenasobservable` methods of `single` and `maybe` classesresolves: #6276; merging 6408 ;flattenasflowable wrong wording in javadocs;""the wording of `singleflattenasflowable` is a bit off:> """"returns a flowable that **merges each item emitted by the source single with the values in an iterable corresponding to that item that is generated by a selector**""""in contrast `flattenasobservable` is somewhat better:> """"returns an observable that maps a success value into an iterable and emits its items""""id say something along the lines of:""""maps the success value of the upstream `{@code single}` into an `{@link iterable}` and emits its items as an `{@link observable}` sequence""""the `maybe` variants have the same issues (they were copy-pasted back then)"";hi @akarnokd  i would like to start working on this could you please give me some heads up ?  || > could you please give me some heads up ?nobody has started working on this yet so go ahead || @dilantha111 have you finished working on this? || @freakomonk  nope just got some other things coming up if you are willing to do that please go ahead at the moment stuck with some other stuffs  || @dilantha111 since i have finished some other issue as my first bug i dont think its fair for me to take this up too so leaving it open for others to take it || @freakomonk unfortunately people are not lining up to work on issues right now so i suggest you do as much as you like and not worry about taking away opportunities || @akarnokd sure david will take it up tomorrow || @akarnokd i would like to work on this || @thiyagu-7 sure! ||;1;0;improving javadoc of flattenasflowable and flattenasobservable methods (#6276);"
"6432;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x composite disposable docs;on compositedisposable add and addall methods  if the param is null  currently the npe error message (produced by objecthelper) is  d is null  which is not very helpful.;;6430.0;2x composite disposable docs;""on compositedisposable add and addall methods if the param is null currently the npe error message (produced by objecthelper) is """"d is null"""" which is not very helpfulthis is a small refactor for making the message a bit more helpful6430 ""; merging 6432 ;""2x """"d is null"""" message for compositedisposable add and addall"";""affects version: 227 (and before)message """"d is null"""" for errors in compositedisposables add and addall methods is not very helpfull"";;1;0;2x: applied pr suggestions in javadoc and messages for compositedisposable;"
6433;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;make error messages of parameter checks consistent;this pr updates error messages of parameter checks. most of the changes are due to the renaming of a parameter without changing the error message used when the parameter check fails.;;0;make error messages of parameter checks consistent;this pr updates error messages of parameter checks most of the changes are due to the renaming of a parameter without changing the error message used when the parameter check fails; merging 6433 ;;;;1;1;make error messages of parameter checks consistent;
6442;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;undeliverable error handling logic for completable operators;completable.fromaction  and  completable.fromrunnable  operators were missing  rxjavaplugins  calls to handle undeliverable errors. this behaviour is fixed in this pr.;;0;undeliverable error handling logic for completable operators;`completablefromaction` and `completablefromrunnable` operators were missing `rxjavaplugins` calls to handle undeliverable errors this behaviour is  in this pr also added missing error handling java doc for completablefromrunnable; merging 6442 ;;;;1;1;added error handling java docs section to completablefromrunnable;
6452;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove dependency of schedulers from observablerefcount;6451.;;6451.0;remove dependency of schedulers from observablerefcount;6451in the constructor of `observablerefcount` that takes `connectableobservable<t> source` as the argument we set `timeout` to `0l` in that specific use case of `observablerefcount` `scheduler` is never needed its only referenced in `cancel()` method but if timeout is 0 it wont be triggered at all because there is early return this commit removes the need to depend on `schedulerstrampoline()` and instead passes null to be scheduler when the ref count is not time-based similarly applies the same change to `flowablerefcount`the reasons for this change are the following:1 in projects that dont depend on `schedulers` class if there is no reference to `schedulers` the whole `schedulers` can be stripped out of the library after optimizations (eg proguard) with constructor that references `schedulers` the optimizer cant properly strip it out in our quick test of our android app we were able to reduce the rxjava library size dependency from 51kb to 37kb (after optimization but before compression) by simply avoiding access to `schedulers` in `observablerefcount`2 in terms of modularity `observablerefcount` is just an operator so it by itself should probably not have dependency on what available pool of schedulers (`schedulers`) there are it should just know that there is some `scheduler` that could be passed to `observablerefcount` when `observablerefcount` needs it; merging 6452 ;unnecessary dependency on schedulerstrampoline() for non-time-based refcount operator;in the constructor of `observablerefcount` that takes `connectableobservable<t> source` as the argument we set `timeout` to `0l` in that specific use case of `observablerefcount` `scheduler` is never needed its only referenced in `cancel()` method but if `timeout` is 0 it wont be triggered at all because there is early return i am wondering if we could avoid referencing `schedulerstrampoline()` in that specific use case of `observablerefcount` to keep the dependency clear reasons are the following:1 in projects that dont depend on `schedulers` class if there is no reference to `schedulers` the whole `schedulers` can be stripped out of the library after optimizations (eg proguard) with constructor that references `schedulers` the optimizer cant properly strip it out in our quick test of our android app we were able to reduce the rxjava library size dependency from 51kb to 37kb (after optimization but before compression) by simply avoiding access to `schedulers` in `observablerefcount`2 in terms of modularity `observablerefcount` is just an operator so it by itself should probably not have dependency on what available pool of schedulers (`schedulers`) there are it should just know that there is some `scheduler` that could be passed to `observablerefcount` when `observablerefcount` needs it;yes it can be replaced  null` pr welcome ||;1;0;remove dependency of schedulers from observablerefcountin the constructor of `observablerefcount` that takes `connectableobservable<t> source` as the argument we set `timeout` to `0l` in that specific use case of `observablerefcount` `scheduler` is never needed its only referenced in `cancel()` method but if timeout is 0 it wont be triggered at all because there is early return this commit removes the need to depend on `schedulerstrampoline()` and instead passes null to be scheduler when the ref count is not time-basedthe reasons for this change are the following:1 in projects that dont depend on `schedulers` class if there is no reference to `schedulers` the whole `schedulers` can be stripped out of the library after optimizations (eg proguard) with constructor that references `schedulers` the optimizer cant properly strip it out in our quick test of our android app we were able to reduce the rxjava library size dependency from 51kb to 37kb (after optimization but before compression) by simply avoiding access to `schedulers` in `observablerefcount`2 in terms of modularity `observablerefcount` is just an operator so it by itself should probably not have dependency on what available pool of schedulers (`schedulers`) there are it should just know that there is some `scheduler` that could be passed to `observablerefcount` when `observablerefcount` needs it;
6453;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fixed typos for comments;i was looking at the docs and found that some details does not match the given code.;;0; typos for comments;i was looking at the docs and found that some details does not match the given codefor example:![screenshot from 2019-04-04 10-01-00]( says new completable instance when in fact it returns a maybe; merging 6453 ;;;;1;1;update singlejava;
"6458;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;update the javadoc of the  retry  operator;specify that the  times  function parameter describes  the number of times;;6402.0;update the javadoc of the `retry` operator;""specify that the `times` function parameter describes """"the number of timesto resubscribe if the current observable fails""""solves: #6402"";bellow is the marble with the number of retries decreased from 2 to 1 if the marble is correct can you upload it to the repository?![retry o n]( || sure could you also make sure all the other counted `retry()` operators in the other base classes have the correct wording? ||  merging 6458  < ;error in documentation of observable retry(n);""there appears to be an error in the 2x javadoc for the `retry( n )` operator of `observable` `n` is referred to as """"number of retry attempts before failing"""" but the accompanying marble diagram shows only a single retry when `retry(2)` is called does `n` indicate the total number of subscriptions including the first one? "";""hello you could write a small program to find it out and if there is a documentation mistake you are welcome to post a pr || my test program (below) shows that the `n` argument does not include the initial attempt to subscribe thus `retry( 10 )` gives a total of 11 subscriptions the easiest doc fix would be to change the large `retry(2)` in the marble diagram to `retry(1)` but i have no facility for doing that (the javadoc for `single` doesnt include a marble diagram but the text description is correct) ```disposable retrydisp  observableerror( new sockettimeoutexception() )                doonsubscribe( disp -> systemoutprintln( """"subscribe count is now """" + ++subcount ) )                doonerror( err -> systemoutprintln( """"error count is now """" + ++errcount ) )                retry( 10 )  // gives a total of 11 subscriptions & 11 errors                subscribe(                        item -> systemoutprintln( """"we never see this"""" )                        err -> systemoutprintln( """"without this we get a missing error handler crash"""" )                )``` || does anyone work on this issue?also the function parameter `times` is described as """"the number of times to repeat"""" and could be mixed with the `repeat` operator i think thats an opportunity to improve the javadoc of `public final observable<t> retry(long times predicate<? super throwable> predicate)` at the same time || @romanwuattier nobody seems to work on this so you are welcome if you want || closing via #5458 || "";1;0;""update the javadoc of the `retry` operatorspecify that the `times` function parameter describes """"the number of timesto resubscribe if the current *operator* fails""""also this commit updates some unit tests to illustrate the javadoc wordingsolves: #6402"";"
"6461;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;change error message in observablefromarray;changed the error message when an element at position i is null to what was suggested in #6460 .;;6460.0;change error message in observablefromarray;changed the error message when an element at position i is null to what was suggested in #6460;could you please update these locations as well?  ||  merging 6461 ;fromarray to report element at index $i is null;currently `observablefromarray` says `the $i th element is null` which is a bit misleading as `i` is the element index update the error message to `the element at index $i is null` the `flowable` version should be updated if necessary note that the null checks appear multiple places;closing via #6461 ||;1;0;""change error messages in flowablefromarraychanged error messages from """"array element is null"""" to """"the element at index $i is null""""solves #6460"";"
6469;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;remove redundant methods from sample(observable);resolves: #6468;;646.0;remove redundant methods from sample(observable);resolves: #6468; merging 6469 ;operator boforeachfuture;issue #634i tried to find a random place in bo but it is likely this or the other prs will not merge one after another;#578  in rxnet it had clean design with `task` and `async/await` in java we dont this (and other similar pull requests) dont make much sense and are greatly complicating the apiin java the `future`/`futuretask`/`callable`/`runnable`/`completablefuture` set of classes do not play well with the non-blocking/reactive style of rx nor is there good conformity across jvm languages (scala groovy clojure with different concurrency models and libraries) or even java libraries (such as guava and akka)i think that all of these additions you are proposing related to `javautilconcurrent` interop should be pushed into a separate contrib module and not part of core perhaps `rxjava-contrib/rxjava-java-future` or something along those lines?in short the goal is to keep rxjava-core focused on the basics of `observable` and non-blocking operators interop with the various different approaches to concurrency should be kept separate in retrospect even the `asyncjava` stuff should likely be moved out to this new contrib module  || yes a contrib module would be much cleaner || great im glad we agree ill setup the module for you || merge these into  instead ||;1;0;merge pull request #1 from reactivex/2xmerge from head;
6470;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove unused import in flowable.java;remove unused import in flowable.java;;0;remove unused import in flowablejava;remove unused import in flowablejava; merging 6470 ;;;;1;1;remove unused import in flowablejava;
"6483;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;correction for maybe.count doc typo;6481;;6481.0;correction for maybecount doc typo;6481; merging 6483 ;maybecount doc typo;""![screenshot from 2019-05-20 10-07-12]( here that it """"returns a maybe"""" when in fact it returns a single"";pr welcome ||;1;0;correction for maybecount doc typo6481;"
6485;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;remove unused else from the observable;remove unused else from the observable class.;;0;remove unused else from the observable;remove unused else from the observable class; merging 6485 ;;;;1;1; mr comments;
"6488;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix zip not stopping the subscription upon eager error;the  observable.zip  did not stop subscribing to the next sources if the previous one failed with an  onerror .  flowable.zip  works as intended.;;648.0;2x: fix zip not stopping the subscription upon eager error;the `observablezip` did not stop subscribing to the next sources if the previous one failed with an `onerror` `flowablezip` works as intended6487; merging 6488 ;reentrant scheduling2;revised version of pr #643- added `schedulerunnable()` overloads to `scheduler` directly to avoid constant wrapping between `runnable` and `action0`- removed the helper interface- reworked `reentrantscheduler` to work with a parent scheduler directly- replaced `forwardsubscription` with `incrementalsubscription` as the first one didnt correctly managed the orderly nature of swapping subscriptions: an unfortunate thread scheduling could have swapped in an older subscription before a new subscriptionin my opinion the `scheduler` and its implementations should use `runnable` as the internal unit of work instead of `action0` since the `executor`s require `runnable` anyway less wrapping means less memory and better performance the `scheduler` interface can retain the `action0` overloads but no other implementation should need to deal with them;""#582  this seems like its a bug inside current schedulers as recursion should work without memory leaks here is the histogram showing the leak:```jvm version is 2445-b08iterating over heap this may take a whileobject histogram:num       #instances    #bytes  class description--------------------------------------------------------------------------1:      1488649 83360752    javalangobject2:      2976652 47626432    javautilconcurrentatomicatomicreference3:      1488325 47626400    rxschedulersdiscardableaction4:      1488324 47626368    javautilconcurrentfuturetask5:      1488330 35719920    javautilarraylist6:      1488324 35719776    rxsubscriptionscompositesubscription$state7:      1488456 23815296    javalanginteger8:      1488326 23813216    javautilconcurrentatomicatomicboolean9:      1488326 23813216    rxoperatorssafeobservablesubscription10:     1488325 23813200    rxsubscriptionscompositesubscription11:     1488324 23813184    rxsubscriptionssubscriptions$312:     7036    905920  * methodklass13:     7036    813896  * constmethodklass14:     499 567648  * constantpoolklass15:     499 348832  * instanceklassklass16:     447 339168  * constantpoolcacheklass17:     2051    148592  char18:     702 106856  byte19:     569 68872   javalangclass20:     830 52568   * system objarray21:     2027    48648   javalangstring22:     769 44128   short23:     124 40800   * methoddataklass24:     785 31400   javautiltreemap$entry25:     53  28408   * objarrayklassklass26:     138 9936    javalangreflectfield27:     218 6976    javautilconcurrentconcurrenthashmap$hashentry28:     192 6568    javalangstring29:     138 4416    javautilhashmap$entry30:     8   4288    * typearrayklassklass31:     178 4272    javautillinkedlist$node32:     116 3712    javautilhashtable$entry33:     97  3104    javautillinkedlist34:     193 3088    javalangobject35:     46  2944    javaneturl36:     30  2848    javautilhashmap$entry37:     66  2704    javautilconcurrentconcurrenthashmap$hashentry38:     66  2640    javautilconcurrentconcurrenthashmap$segment39:     72  2304    javautilconcurrentlocksreentrantlock$nonfairsync40:     11  2288    * klassklass41:     38  1824    sunutillocalelocaleobjectcache$cacheentry42:     36  1728    javautilhashmap43:     5   1696    int44:     36  1440    javautillinkedhashmap$entry45:     18  1296    javalangreflectconstructor46:     16  1280    javautilweakhashmap$entry47:     1   1040    javalanginteger48:     26  1040    javalangrefsoftreference49:     6   992 javautilhashtable$entry[]50:     16  896 javautilweakhashmap51:     21  840 javalangreffinalizer```i will dig in to where this leak is occurring we should not need new subscription or scheduler types to solve this otherwise anything using schedulers is broken code in java 6 for proving the leak as modified from the original java 8 bug report:``` java/**     * generates an observable sequence by iterating a state from an initial     * state until the condition returns false     */    public static <tstate r> onsubscribefunc<r> generate(            final tstate initialstate            final func1<tstate boolean> condition            final func1<tstate tstate> iterate            final func1<tstate r> resultselector            final scheduler scheduler) {        return new onsubscribefunc<r>() {            @override            public subscription onsubscribe(final observer<? super r> observer) {                return schedulerschedule(initialstate new func2<scheduler tstate subscription>() {                    @override                    public subscription call(scheduler s tstate state) {                        boolean hasnext                        try {                            hasnext  conditioncall(state)                        } catch (throwable t) {                            observeronerror(t)                            return subscriptionsempty()                        }                        if (hasnext) {                            r result                            try {                                result  resultselectorcall(state)                            } catch (throwable t) {                                observeronerror(t)                                return subscriptionsempty()                            }                            observeronnext(result)                            tstate nextstate                            try {                                nextstate  iteratecall(state)                            } catch (throwable t) {                                observeronerror(t)                                return subscriptionsempty()                            }                            return sschedule(nextstate this)                        }                        observeroncompleted()                        return subscriptionsempty()                    }                })            }        }    }    public static void main(string[] args) throws exception {//        threadsleep(10000)        observable<integer> source  observablecreate(generate(                0 new func1<integer boolean>() {                    @override                    public boolean call(integer t1) {                        return true                    }                }                new func1<integer integer>() {                    @override                    public integer call(integer t) {                        return t + 1                    }                }                new func1<integer integer>() {                    @override                    public integer call(integer t) {                        return t                    }                } schedulersnewthread()))        final countdownlatch latch  new countdownlatch(1)        subscription s  sourcesubscribe(new observer<integer>() {            @override            public void oncompleted() {                latchcountdown()            }            @override            public void onerror(throwable e) {                eprintstacktrace()                latchcountdown()            }            @override            public void onnext(integer v) {                if (v % 100000  0) {                    systemoutprintln(v)                }                if (v > 10000000) {                    latchcountdown()                }            }        })        latchawait()        systemoutprintln(""""wait done"""")        sunsubscribe()        systemoutprintln(""""unsubscribe done"""")    }```@headinthebox will try in net || this memory leak is  in  || "";1;0;2x: fix zip not stopping the subscription upon eager error;"
6498;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: merge in changes from 2.x since the initial branching;### version 2.2.9;;0;3x: merge in changes from 2x since the initial branching;### version 229#es- #6488: fix zip not stopping the subscription upon eager error#### documentation changes- #6453:  wrong type referenced in maybe and single javadocs- #6458: update the javadoc of the retry operator#### other- #6452: remove dependency of schedulers from observablerefcount- #6461: change error message in observablefromarray- #6469: remove redundant methods from sample(observable)- #6470: remove unused import from flowablejava- #6485: remove unused else from the observable### version 228 - march 26 2019 (maven)#### bugfixes- #6442: add missing undeliverable error handling logic for completablefromrunnable & fromaction operators#### documentation changes- #6432: improve the docs of compositedisposable- #6434: improve subjects and processors package doc- #6436: improve creating-observables wiki doc#### other- #6433: make error messages of parameter checks consistent; merging 6498 ;;;;1;1;3x: merge in changes from 2x since the initial branching;
"6499;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;null check for bufferexactboundedobserver;- [*] please give a description about what and why you are contributing  even if it s trivial:;;0;null check for bufferexactboundedobserver;""- [*] please give a description about what and why you are contributing even if its trivial:**improve stability of the library**other variants of the oncomplete method include this null check already eg bufferexactunboundedobserver this check should fix the case when there is a race condition and buffer is already set to """"null"""" by the time oncomplete is calledit is causing 01% crashes in our production app this should improve stability of other apps too "";""i dont see how that scenario would be possible with just the exact buffer only the terminal events can set `buffer` to null and `run` is protected against a null bufferarent you using `publishsubject` as well from multiple threads competing for termination? || also an unit test demonstrating the presumed bug has been  is required ||  merging 6499  <  "";;;;1;1;better unit tests for flowablebuffertimed and bufferexactboundedsubscriber npe issuereverted;"
6504;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix javadocs & imports;- fix some errors in the javadoc links.;;0;2x: fix javadocs & imports;- fix some errors in the javadoc links- remove unused imports- add the parallelflowable page to the javadoc cleanup routine; merging 6504  < ;;;;1;1;2x: fix javadocs & imports;
6506;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: expand the javadoc of flowable;- add links to reactive streams;;0;2x: expand the javadoc of flowable;- add links to reactive streams- fix hyphenation- turn some `@code` into `@link`s- add a short protocol description- add basic example usage- add example to use `create` for custom sources- mention the synchronous/sequential nature and link in some operators; merging 6506 ;;;;1;1;2x: expand the javadoc of flowable;
6507;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: sync up with 2.2.10 snapshot;the changes.md always comes up conflicting. i ll leave it as it is for now.;;0;3x: sync up with 2210 snapshot;the changesmd always comes up conflicting ill leave it as it is for now;i decided it is time to move forward towards the next major release ||  merging 6507 ;;;;1;1;add the flowable javadoc changes too;
6510;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: correct reactive-streams to reactive streams in documentation;* changes  reactive-streams  to  reactive streams  in line with the rest of the documentation.;;0;2x: correct reactive-streams to reactive streams in documentation;* changes `reactive-streams` to `reactive streams` in line with the rest of the documentation;;;;;1;1;2x: correct reactive-streams to reactive streams in documentation;
6511;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: widen functional interface throws  replace callable with supplier;this pr widens the  throws exception  into  throws throwable  in the functional interfaces and adjusts  catch (exception  to  catch(throwable  where needed.;;0;3x: widen functional interface throws replace callable with supplier;this pr widens the `throws exception` into `throws throwable` in the functional interfaces and adjusts `catch (exception` to `catch(throwable` where neededthe major change is the replacement of `javautilconcurrentcallable` in almost all api with `ioreactivexfunctionssupplier` which is defined with `throws throwable` since subinterfaces cant widen the throws clause only narrow it `supplier` cant extend `callable``fromcallable` remained in all base classes and a separate pr will introduce `fromsupplier`the single-valued fusion now works with `supplier` and `scalarsupplier` types instead of `callable` and `scalarcallable` (removed); merging 6511 ;;;;1;1;some cleanup;
6514;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: merge as() into to();in 2.x  the  to()  operator used the generic  function  to allow assembly-time conversion of flows into arbitrary types. the drawback of this approach was that each base reactive type had the same  function  interface in their method signature  thus it was impossible to implement multiple converters for different reactive types within the same class. to work around this issue  the  as  operator and  xconverter  interfaces have been introduced in 2.x  which interfaces are distinct and can be implemented on the same class. changing the signature of  to  in 2.x was not possible due to the pledged binary compatibility of the library.;;0;3x: merge as() into to();in 2x the `to()` operator used the generic `function` to allow assembly-time conversion of flows into arbitrary types the drawback of this approach was that each base reactive type had the same `function` interface in their method signature thus it was impossible to implement multiple converters for different reactive types within the same class to work around this issue the `as` operator and `xconverter` interfaces have been introduced in 2x which interfaces are distinct and can be implemented on the same class changing the signature of `to` in 2x was not possible due to the pledged binary compatibility of the libraryfrom 3x the `as()` methods have been removed and the `to()` methods now each work with their respective `xconverer` interfaces:- `flowableto(function<flowable<t> r>)` is now `flowableto(flowableconverter<t r>)`- `observableto(function<observable<t> r>)` is now `observableto(observableconverter<t r>)`- `maybeto(function<flowable<t> r>)` is now `maybeto(maybeconverter<t r>)`- `singleto(function<flowable<t> r>)` is now `maybeto(singleconverter<t r>)`- `completableto(function<completable r>)` is now `completableto(completableconverter<r>)`- `parallelflowableto(function<parallelflowable<t> r)` is now `parallelflowableto(parallelflowableconverter<t r>)`if one was using these methods with a lambda expression only a recompilation is needed:```java// beforesourceto(flowable -> flowableblockingfirst())// aftersourceto(flowable -> flowableblockingfirst())```if one was implementing a function interface (typically anonymously) the interface type type arguments and the `throws` clause have to be adjusted```java// beforesourceto(new function<flowable<integer> integer>() {    @override    public integer apply(flowable<integer> t) throws exception {        return tblockingfirst()    }})// aftersourceto(new flowableconverter<integer integer>() {    @override    public integer apply(flowable<integer> t) {        return tblockingfirst()    }})```resolves: #5654;   no coverage uploaded for pull request base (`3x@cb03724`) [click here to learn what that means]( ` ;;;;1;1;fix as() mentioned in the javadocs;
6516;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: remove getvalues() from some subjects/processors;the  getvalue()  and  getvalues(t)  methods were a remnant from a time where  subject  and  flowableprocessor  was unifying all state peeking methods for every kind of subject/processor. these have been marked as  @deprecated  in 2.x and are now removed from 3.x. they can be trivially replaced with  getvalue()  if necessary  for example:;;0;3x: remove getvalues() from some subjects/processors;the `getvalue()` and `getvalues(t)` methods were a remnant from a time where `subject` and `flowableprocessor` was unifying all state peeking methods for every kind of subject/processor these have been marked as `@deprecated` in 2x and are now removed from 3x they can be trivially replaced with `getvalue()` if necessary for example:```javaobject value  subjectgetvalue()if (value  null) {   return new object[1]}return new object { value }```related: #5622;   no coverage uploaded for pull request base (`3x@cb03724`) [click here to learn what that means]( `n/a`(                                  3x    #6516   +/-   ##  coverage       ?   9819%             complexity     ?     6259             files          ?      675  ?    45107     ?     6226             hits           ?    44293             misses         ?      280             partials       ?      534```| [impacted files]( | coverage  | complexity  | ||---|---|---|---|| [/main/java/io/reactivex/subjects/asyncsubjectjava]( | `9893% <> ()` | `45 <0> (?)` | || [n/java/io/reactivex/processors/asyncprocessorjava]( | `9895% <> ()` | `45 <0> (?)` | || [ava/io/reactivex/processors/behaviorprocessorjava]( | `956% <> ()` | `50 <0> (?)` | || [in/java/io/reactivex/subjects/behaviorsubjectjava]( | `988% <> ()` | `45 <0> (?)` | |------[continue to review full report at codecov]( **legend** - [click here to learn more]( `  absolute <relative> (impact)` `  not affected` `?  missing data`> ( last update [cb0372458d4ac5]( read the [comment docs]( ||;;;;1;1;3x: remove getvalues() from some subjects/processors;
6517;1;0;0;0;0;1;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: various small api changes and removals;-  maybe.defaultifempty()  returns  single .;;0;3x: various small api changes and removals;- `maybedefaultifempty()` returns `single`- removal of `maybetosingle(t)`- removal of `flowablesubscribe(4 args)`- removal of `observablesubscribe(4 args)`- removal of `singletocompletable()`- removal of `completableblockingget()`- removal of `flowablesubscribe(/* 4 args */)`- removal of `observablesubscribe(/* 4 args */)`; merging 6517 ;;;;1;1;3x: various small api changes and removals;
6519;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: connectableflowable/connetableobservabe redesign;this pr changes the connectable api to have a specific  reset  method to reset a terminated connectable source as part of the official api.;;5628.0;3x: connectableflowable/connetableobservabe redesign;this pr changes the connectable api to have a specific `reset` method to reset a terminated connectable source as part of the official apiin 2x when `publish()` terminated it reset itself to a fresh state which could lead to late consumers not receiving events as there might be no one to call `connect()` again (see #6501) however `replay()` did not reset itself thus late consumers got the cached events however a reconnect started the sequence and new consumers may have missed itemsin 3x this two corner cases have been  by the introduction of `reset()` both `publish` and `replay` now remain in their terminated state until `reset` is called if the connection is disposed it will automatically reset their state just like before the state transitions are as follows:1 **fresh** -> `connect()` -> **running** -> `oncomplete()`/`onerror()` -> **terminated** -> `reset()` -> **fresh**2 **fresh** -> `connect()` -> **running** -> `dispose()` -> **fresh**3 **fresh** -> `connect()` -> **running** -> `oncomplete()`/`onerror()` -> **terminated** -> `dispose()` -> **fresh**4 **fresh** -> `connect()` -> **running** -> `oncomplete()`/`onerror()` -> **terminated** -> `connect()` -> **running**this does resolve the race condition with `publish()refcount()` described in #6501in addition there are some changes to `flowablepublish()`s behavior:it no longer keeps consuming the upstream if there are no subscribers this implies if the source terminates while there are unconsumed items in the internal buffer those will be available for observation*i have no strong preference on this property and in comparison `observablepublish` drops items because there is no backpressure buffer in its implementation*upstream errors are not reported to the `rxjavapluginsonerror` handler when if there are no subscribers but have to be observed via a subscriber*because terminal events are available until `reset` now we cant know really if there is going to be a subscriber or not however it might be possible to detect the no-consumer case upon an error and still report it when `reset` or `dispose` is called*5628resolves #5899; merging 6519 ;3x: connectableobservable redesign;the `completableobservable` (and `completableflowable`) implementors `publish` and `replay` in rxjava 1x and 2x are inconsistent in their terminal behaviorwhen `publish` terminates its `completableobservable` will appear as fresh to the new subscribers this has the drawback that such subscribers may hang as `connect` may be never called againin contrast `replay` will stay terminated along with any cached items and new subscribers can still get those events the drawback here is that a new `connect` will clear the internal storage and start the consumption of the main source while not giving any chance to subscribers to prepare and receive that stream of events from the start if the replay is boundeddealing with this inconsistency currently requires `refcount` to trigger a reset on an unofficial channel: casting the `completableobserver` into `disposable` if possible and disposing it when the count reaches zero again### suggested solutioni suggest changing the api to include an explicit `reset()` method and changing the logic to have 3 states:**fresh** --> `connect()` --> **running** --> `oncomplete()`/`onerror()` --> **terminated** --> `reset()` --> **fresh**and possibly:**terminated** --> `connect()` --> **running**in the **fresh** state consumers can pile up and be ready to receive events an atomic state change to **running** will begin streaming events until a terminal event is reached at which point the state atomically changes to **terminated** consumers subscribing in this state will always receive the terminal event and in case of `replay` the cached items as wella call to `reset()` will clear the internal storage of the `connectableobservable` and start out as **fresh** again allowing new consumers to gather around and get all fresh events from the beginningit is possible to support the call to `connect` in the **terminated** state to skip the **fresh** state preventing this transition however may be more involved as `connect()` should communicate this to be illegal transition someway as well as the need for a soft way for checking if `connect` is to succeed or not note that calling `connect` on a running `connectableobservable` is a no-op in 1x and 2x;hey @akarnokd when are you planning to start working on that? i believe we may collaborate on that so i will port the same design to reactor 3?cc/ @smaldini || closing via #6519 ||;1;0;3x: connectableflowable/connetableflowable redesign;
"6519;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: connectableflowable/connetableobservabe redesign;this pr changes the connectable api to have a specific  reset  method to reset a terminated connectable source as part of the official api.;;589.0;3x: connectableflowable/connetableobservabe redesign;this pr changes the connectable api to have a specific `reset` method to reset a terminated connectable source as part of the official apiin 2x when `publish()` terminated it reset itself to a fresh state which could lead to late consumers not receiving events as there might be no one to call `connect()` again (see #6501) however `replay()` did not reset itself thus late consumers got the cached events however a reconnect started the sequence and new consumers may have missed itemsin 3x this two corner cases have been  by the introduction of `reset()` both `publish` and `replay` now remain in their terminated state until `reset` is called if the connection is disposed it will automatically reset their state just like before the state transitions are as follows:1 **fresh** -> `connect()` -> **running** -> `oncomplete()`/`onerror()` -> **terminated** -> `reset()` -> **fresh**2 **fresh** -> `connect()` -> **running** -> `dispose()` -> **fresh**3 **fresh** -> `connect()` -> **running** -> `oncomplete()`/`onerror()` -> **terminated** -> `dispose()` -> **fresh**4 **fresh** -> `connect()` -> **running** -> `oncomplete()`/`onerror()` -> **terminated** -> `connect()` -> **running**this does resolve the race condition with `publish()refcount()` described in #6501in addition there are some changes to `flowablepublish()`s behavior:it no longer keeps consuming the upstream if there are no subscribers this implies if the source terminates while there are unconsumed items in the internal buffer those will be available for observation*i have no strong preference on this property and in comparison `observablepublish` drops items because there is no backpressure buffer in its implementation*upstream errors are not reported to the `rxjavapluginsonerror` handler when if there are no subscribers but have to be observed via a subscriber*because terminal events are available until `reset` now we cant know really if there is going to be a subscriber or not however it might be possible to detect the no-consumer case upon an error and still report it when `reset` or `dispose` is called*5628resolves #5899; merging 6519 ;migrate language adaptors to top level projects of rxlang;""as we approach 10 and based on the experience of working on the language adaptors it is going to make sense to let the adaptors move to a first-class level and be named rxscala rxclojure rxgroovy etc instead of rxjava-scala rxjava-clojure etcthis should also mean they become top level projects of their own with a single dependency on rxjavathis does not need to be done immediately but probably as we hit the 10 release candidate stagetwo reasons for this are:- dont tie the naming to the """"java"""" portion of the core function implementations- decouple release and versioning cycles (particularly important for scala where it is typical to maintain branches for the different scala versions such as 2_10 and 2_11)anyone else agree or disagree?"";agree but as you said it neednt be done immediately but would be good to do it for 10 release candidate || done || before people start working on the new repos id like to suggest that we keep the git history according to  this seems to be very simple and the advantages of keeping the history are considerable || cool command!  || see  || happy to have someone with strong git foo do this || i made all the changes to repos this morning to retain history ||;1;0;3x: connectableflowable/connetableflowable redesign;"
"6519;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: connectableflowable/connetableobservabe redesign;this pr changes the connectable api to have a specific  reset  method to reset a terminated connectable source as part of the official api.;;6501.0;3x: connectableflowable/connetableobservabe redesign;this pr changes the connectable api to have a specific `reset` method to reset a terminated connectable source as part of the official apiin 2x when `publish()` terminated it reset itself to a fresh state which could lead to late consumers not receiving events as there might be no one to call `connect()` again (see #6501) however `replay()` did not reset itself thus late consumers got the cached events however a reconnect started the sequence and new consumers may have missed itemsin 3x this two corner cases have been  by the introduction of `reset()` both `publish` and `replay` now remain in their terminated state until `reset` is called if the connection is disposed it will automatically reset their state just like before the state transitions are as follows:1 **fresh** -> `connect()` -> **running** -> `oncomplete()`/`onerror()` -> **terminated** -> `reset()` -> **fresh**2 **fresh** -> `connect()` -> **running** -> `dispose()` -> **fresh**3 **fresh** -> `connect()` -> **running** -> `oncomplete()`/`onerror()` -> **terminated** -> `dispose()` -> **fresh**4 **fresh** -> `connect()` -> **running** -> `oncomplete()`/`onerror()` -> **terminated** -> `connect()` -> **running**this does resolve the race condition with `publish()refcount()` described in #6501in addition there are some changes to `flowablepublish()`s behavior:it no longer keeps consuming the upstream if there are no subscribers this implies if the source terminates while there are unconsumed items in the internal buffer those will be available for observation*i have no strong preference on this property and in comparison `observablepublish` drops items because there is no backpressure buffer in its implementation*upstream errors are not reported to the `rxjavapluginsonerror` handler when if there are no subscribers but have to be observed via a subscriber*because terminal events are available until `reset` now we cant know really if there is going to be a subscriber or not however it might be possible to detect the no-consumer case upon an error and still report it when `reset` or `dispose` is called*5628resolves #5899; merging 6519 ;publish()refcount() race may leave observers hanging;""this test eventually times out because one of the sources will not complete or trigger a reconnection:```javafor (int i  0 i < 10_000 i++) {    observable<integer> observable  observablejust(1)publish()refcount()    testobserver<integer> observer1  observable        subscribeon(schedulerscomputation())        test()        testobserver<integer> observer2  observable        subscribeon(schedulerscomputation())        test()    observer1        withtag(""""observer1 """" + i)        awaitdone(5 timeunitseconds)        assertnoerrors()        assertcomplete()    observer2        withtag(""""observer2 """" + i)        awaitdone(5 timeunitseconds)        assertnoerrors()        assertcomplete()}```(originally reported as a [comment](https://githubcom/reactivex/rxjava/pull/6187#issuecomment-501879711))"";""in our anecdotal case its an observable that gets disposed and therefore cancels the  request while the next subscriber receives the immediately-canceled stream from the first subscribersomething like:    val apirequest: observable<foo>  retrofitapirequest()share()    // subscriber 1 main thread:    val disposable  apirequestsubscribeon(schedulersio())subscribe()        disposabledispose()        // subscriber 2 also main thread:    val disposable  apirequestsubsribeon(schedulersio())subscribe()subscriber 1 for one reason or another disposes before the api request responds  nearly the same time as the first one disposing subscriber 2 subscribes and only receives the interruptedioexception from the first request being canceledas i understood when the first subscriber disposes it should cancel the api request and also removes itself as a subscriber so the refcount() should cause the upstream observable to dispose  when the 2nd subscriber attaches it should be starting a brand new request to the upstream api source rather than receiving the first errorso its slightly different because its not actually a timeout (as if the stream had zero events) its actually receiving the error from the first subscribers canceled attempt || we were able to track down the part of our code that was triggering this issue but i still believe that it is a race condition in `share()` where your original suspicion was """"one of the observers connect right between onnext and oncomplete"""" in our case refcount is dispatching the dispose/cancel upstream to the original request but is not decrementing the refcount quickly enough so that the 2nd request is coming in as if it is refcount2 even though it has already terminated the upstream (and therefore should have already become refcount0 and the connectableobservable should already have been disconnected)in our case (android) we had 2 separate fragments being added approximately simultaneously fragment 1 makes a request for configuration (which is implemented with `share()` and intended to be shared across multiple requests for the same configs) and then shortly after also disposes that request (this was a mistake and thats what has been  on our end -- short version is we were using `compositedisposableclear()` but we should have only been disposing a _single_ unrelated observable)  fragment 2 also makes the same request for configurationsas a result of compositedisposableclear() fragment 1s config request got disposed and rather than allowing fragment 2s request to continue operating due to the refcount fragment 2 only receives the ok interruptedioexception from the canceled operation and never receives a completed successful response || share() is generally tricky even without this bug because people have a sense of it staying alive a bit longer and also receiving onnext events in time which is not guaranteed with it you could try using `replay(1)refcount()` or `publish()refcount(1 timeunitseconds)` to give it some wiggle room until i find a way to fix this bug (my attempts this far have broken other unit tests so it may take a few days) || this is a tough onewhat happens is that the termination happens when a new observer subscribes which makes `refcount2` but the new observer gets assigned to a fresh publishing instance ready to be connected however the refcounts termination management sees `refcount2` and wont reset nor will it reconnect if it reset though that would clear the new observer and still result in a hang toothis could be resolved if a late observer wasnt assigned to a fresh publishing instance but receive the terminal signal instead (thus making refcount get down to zero and reset/reconnect) unfortunately this is a behavior change that in addition requires api change to allow manual resetting for those who work with `connectableobservable` directly i already planned to resolve the underlying issue in 3x: #5628ill keep thinking about this problem until then you could use the workarounds above or use `timeout()retry()` to detect the hang and make it cancel/reconnect || i tried using `retry()` and the problem with that seemed to be that the `share()` caused it to keep the existing interruptedioexception error so it just kept re-emitting the same error on each retryi dont think i tried `replay(1)refcount()` but that is worth testing - thanks!  i thought i was avoiding replay for some some reason but now i cant think of any reason why i would need to avoid that || "";1;0;3x: connectableflowable/connetableflowable redesign;"
"6522;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix concatmapdelayerror not continuing on fused inner source crash;the  callable  fused path didn t consider the error-delay settings and cut the sequence short.;;6520.0;2x: fix concatmapdelayerror not continuing on fused inner source crash;the `callable` fused path didnt consider the error-delay settings and cut the sequence shortfixes: #6520; merging 6522  < ;issus about flowable concatmapdelayerror;""rxjava version 229i feel doubt about `flowable#concatmapdelayerror` when i use `flowable#fromcallable`the following code:```java   flowablejust(1 2 3 101 102 23 890 120 32)        concatmapdelayerror(new function<integer flowable<integer>>() {          @override public flowable<integer> apply(final integer integer) throws exception {            return flowablefromcallable(new callable<integer>() {              @override public integer call() throws exception {                if (integer > 100) {                  throw new nullpointerexception(""""test null exp"""")                }                return integer              }            })          }        })        subscribe(new consumer<integer>() {          @override public void accept(integer integer) throws exception {            loge(tag """"test-->complete-"""" + integer)          }        } new consumer<throwable>() {          @override public void accept(throwable throwable) throws exception {            loge(tag """"test-->error-"""" + throwable)          }        })```the following output:```  test-->complete-1  test-->complete-2  test-->complete-3  test-->error-javalangnullpointerexception: test null exp```it do not delay error but i use `observable` is success delayed the error and i use `flowable#create` is success delayed the errorthe following code:```java    observablejust(1 2 3 101 102 23 890 120 32)        concatmapdelayerror(new function<integer observable<integer>>() {          @override public observable<integer> apply(final integer integer) throws exception {            return observablefromcallable(new callable<integer>() {              @override public integer call() throws exception {                if (integer > 100) {                  throw new nullpointerexception(""""test null exp"""")                }                return integer              }            })          }        })        subscribe(new consumer<integer>() {          @override public void accept(integer integer) throws exception {            loge(tag """"test-->complete-"""" + integer)          }        } new consumer<throwable>() {          @override public void accept(throwable throwable) throws exception {            loge(tag """"test-->error-"""" + throwable)          }        })```the following output:```  test-->complete-1  test-->complete-2  test-->complete-3  test-->complete-23  test-->complete-32  test-->error-ioreactivexexceptionscompositeexception: 4 exceptions occurred ```the following code:```java    flowablejust(1 2 3 101 102 23 890 120 32)        concatmapdelayerror(new function<integer flowable<integer>>() {          @override public flowable<integer> apply(final integer integer) throws exception {            return flowablecreate(new flowableonsubscribe<integer>() {              @override public void subscribe(flowableemitter<integer> emitter) throws exception {                if (integer > 100) {                  throw new nullpointerexception(""""test null exp"""")                }                emitteronnext(integer)                emitteroncomplete()              }            } backpressurestrategybuffer)          }        })        subscribe(new consumer<integer>() {          @override public void accept(integer integer) throws exception {            loge(tag """"test-->complete-"""" + integer)          }        } new consumer<throwable>() {          @override public void accept(throwable throwable) throws exception {            loge(tag """"test-->error-"""" + throwable)          }        })```the following output:```  test-->complete-1  test-->complete-2  test-->complete-3  test-->complete-23  test-->complete-32  test-->error-ioreactivexexceptionscompositeexception: 4 exceptions occurred ```"";thanks for reporting this is a bug in the operator cutting short because of internal shortcuts not considering the error-delay property ill post a fix shortly || thanks appreciate it! ||;1;0;2x: fix concatmapdelayerror not continuing on fused inner source crash;"
"6523;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: fix concatmapdelayerror not continuing on fused inner source crash;the  supplier  fused path didn t consider the error-delay settings and cut the sequence short.;;6520.0;3x: fix concatmapdelayerror not continuing on fused inner source crash;the `supplier` fused path didnt consider the error-delay settings and cut the sequence shortfixes: #6520;;issus about flowable concatmapdelayerror;""rxjava version 229i feel doubt about `flowable#concatmapdelayerror` when i use `flowable#fromcallable`the following code:```java   flowablejust(1 2 3 101 102 23 890 120 32)        concatmapdelayerror(new function<integer flowable<integer>>() {          @override public flowable<integer> apply(final integer integer) throws exception {            return flowablefromcallable(new callable<integer>() {              @override public integer call() throws exception {                if (integer > 100) {                  throw new nullpointerexception(""""test null exp"""")                }                return integer              }            })          }        })        subscribe(new consumer<integer>() {          @override public void accept(integer integer) throws exception {            loge(tag """"test-->complete-"""" + integer)          }        } new consumer<throwable>() {          @override public void accept(throwable throwable) throws exception {            loge(tag """"test-->error-"""" + throwable)          }        })```the following output:```  test-->complete-1  test-->complete-2  test-->complete-3  test-->error-javalangnullpointerexception: test null exp```it do not delay error but i use `observable` is success delayed the error and i use `flowable#create` is success delayed the errorthe following code:```java    observablejust(1 2 3 101 102 23 890 120 32)        concatmapdelayerror(new function<integer observable<integer>>() {          @override public observable<integer> apply(final integer integer) throws exception {            return observablefromcallable(new callable<integer>() {              @override public integer call() throws exception {                if (integer > 100) {                  throw new nullpointerexception(""""test null exp"""")                }                return integer              }            })          }        })        subscribe(new consumer<integer>() {          @override public void accept(integer integer) throws exception {            loge(tag """"test-->complete-"""" + integer)          }        } new consumer<throwable>() {          @override public void accept(throwable throwable) throws exception {            loge(tag """"test-->error-"""" + throwable)          }        })```the following output:```  test-->complete-1  test-->complete-2  test-->complete-3  test-->complete-23  test-->complete-32  test-->error-ioreactivexexceptionscompositeexception: 4 exceptions occurred ```the following code:```java    flowablejust(1 2 3 101 102 23 890 120 32)        concatmapdelayerror(new function<integer flowable<integer>>() {          @override public flowable<integer> apply(final integer integer) throws exception {            return flowablecreate(new flowableonsubscribe<integer>() {              @override public void subscribe(flowableemitter<integer> emitter) throws exception {                if (integer > 100) {                  throw new nullpointerexception(""""test null exp"""")                }                emitteronnext(integer)                emitteroncomplete()              }            } backpressurestrategybuffer)          }        })        subscribe(new consumer<integer>() {          @override public void accept(integer integer) throws exception {            loge(tag """"test-->complete-"""" + integer)          }        } new consumer<throwable>() {          @override public void accept(throwable throwable) throws exception {            loge(tag """"test-->error-"""" + throwable)          }        })```the following output:```  test-->complete-1  test-->complete-2  test-->complete-3  test-->complete-23  test-->complete-32  test-->error-ioreactivexexceptionscompositeexception: 4 exceptions occurred ```"";thanks for reporting this is a bug in the operator cutting short because of internal shortcuts not considering the error-delay property ill post a fix shortly || thanks appreciate it! ||;1;0;3x: fix concatmapdelayerror not continuing on fused inner source crash;"
"6525;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: remove  test  from  testxxx  method names  create a validator;6518.;;6518.0;3x: remove `test` from `testxxx` method names create a validator;""6518-  create validator-  automatically rename methods """"testxxx"""" to """"xxx"""" (analog to [fixlicenseheaders]( check)-  rename methods""; merging 6525 ;3x: remove `test` from `testxxx` method names create a validator;a lot of test methods were named like `testxxx` in the 0x-1x era and we didnt want to change those for 2x now is the time to get rid of the redundant naming from all test methodsin addition a validator should be added that checks all test java files and reports if it finds the pattern `void\s+test[a-za-z0-9]` in any file see [this validator]( for an example of finding and checking source code files;closing via #6525 & #6528 ||;1;0;ignore test prefix check for now;"
6526;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: remove methods from test consumers  make internal versions;remove methods from the standard test consumers based on feedback in [6153 comment](https://github.com/reactivex/rxjava/issues/6153#issuecomment-463184785).;;0;3x: remove methods from test consumers make internal versions;remove methods from the standard test consumers based on feedback in [6153 comment]( test support has been moved into the `ioreactivextestsupport` package in the form of `testobserverex` and `testsubscriberex`resolves: #6153; merging 6526  < ;;;;1;1;3x: remove methods from test consumers make internal versions;
6528;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;rename test methods and enable the check;6518.;;6518.0;rename test methods and enable the check;6518;   no coverage uploaded for pull request base (`3x@edb1f71`) [click here to learn what that means]( `n/a`(                                  3x    #6528   +/-   ##  coverage       ?   9822%             complexity     ?     6157             files          ?      675  ?    44785     ?     6181             hits           ?    43989             misses         ?      274             partials       ?      522```------[continue to review full report at codecov]( **legend** - [click here to learn more]( `  absolute <relative> (impact)` `  not affected` `?  missing data`> ( last update [edb1f7135e510a]( read the [comment docs]( ||;3x: remove `test` from `testxxx` method names create a validator;a lot of test methods were named like `testxxx` in the 0x-1x era and we didnt want to change those for 2x now is the time to get rid of the redundant naming from all test methodsin addition a validator should be added that checks all test java files and reports if it finds the pattern `void\s+test[a-za-z0-9]` in any file see [this validator]( for an example of finding and checking source code files;closing via #6525 & #6528 ||;1;0;enable testprefixinmethodname check;
6529;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: add x.fromsupplier();this pr adds the  fromsupplier  operator to support the new  supplier  interface.;;0;3x: add xfromsupplier();this pr adds the `fromsupplier` operator to support the new `supplier` interfacethe marble diagrams will be updated in a separate pr;   no coverage uploaded for pull request base (`3x@edb1f71`) [click here to learn what that means]( ` ;;;;1;1;correct some missing callable-supplier name changes;
6530;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: disambiguate startwith+1 to startwithitem & startwithiterable;startwith(t)  and  startwith(iterable)  was causing some trouble with  startwith(publisher) . this pr will rename the former two.;;0;3x: disambiguate startwith+1 to startwithitem & startwithiterable;`startwith(t)` and `startwith(iterable)` was causing some trouble with `startwith(publisher)` this pr will rename the former twothe diagrams will be updated in a separate prresolves: #6122;this is one of the changes where library authors can run into troubles the only way to fix this is to use 3x publish a new version and drop 2x support ||  merging 6530 ;;;;1;1;3x: disambiguate startwith+1 to startwithitem & startwithiterable;
6531;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: add marbles to x.fromsupplier;this pr adds marbles to the new  fromsupplier  operators:;;0;3x: add marbles to xfromsupplier;this pr adds marbles to the new `fromsupplier` operators:#### flowable:( observable:![image]( maybe:![image]( single:![image]( completable:![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completablefromsupplierpng); merging 6531  < ;;;;1;1;3x: add marbles to xfromsupplier;
6532;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: add eager truncation to bounded replay() to avoid item retention;this pr adds the  eagertruncate  option to the  replay  operator so that the  head  node will lose the item reference it holds upon truncation.;;647.0;3x: add eager truncation to bounded replay() to avoid item retention;this pr adds the `eagertruncate` option to the `replay` operator so that the `head` node will lose the item reference it holds upon truncationthe bounded buffers in `replay` implement a linked list that when truncated moves the head reference forward along the links atomically this allows late consumers to pick up the head and follow the links between them to get items replayed however the truncation may happen concurrently with a consumer working on some prior nodes so if the truncation would `null` out the value the consumer reaching the same node would see `null` as well and fail( avoid this type of retention the head node has to be refreshed with a new node still pointing to the next node in the chain but without any value ![image]( reason this is not the default is that it requires an additional allocation for each new incoming value when the buffer is full which would reduce performance in cases where the excess retention is not a problemoverloads to both the direct and function-variants of both `flowablereplay()` and `observablereplay()` have been added to avoid too many overloads only one extra overload has been added extending the signature of the longest parameterized method per each bounds mode (size time time+size)their unit test files have been cloned so that both the non-eager (original) behavior and the eager behavior is tested separately6475; merging 6532  < ;operation generate + timed;issue #49i hope the `func1<tstate long> timeunit` will sufficei kept the absolute time variant in the `operationgenerate` and in tests but havent exposed them in `observable`;#581  as per @headinthebox this is really only used in demos and super complicated and thus should not be added to rxjava anything that can be done via `generate` should instead be done inside `observablecreate(onsubscribefunc f)` optionally with a `scheduler ||;1;0;those eager tests are in their separate files already;
"6534;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: make using() resource disposal order consistent with eager-mode;make the resource disposal order in all  using  implementations are consistent with the eagerness of the operator:;;634.0;3x: make using() resource disposal order consistent with eager-mode;make the resource disposal order in all `using` implementations are consistent with the eagerness of the operator:**eager**: dispose resource then dispose the upstream**non-eager**: dispose the upstream then dispose the resourcefixes: #6347; merging 6534 ;more operators in rxnet;i extracted the method names from rxjava and rxnet and compared them i find some operators in rxnet(version 20208230) do not appear in the msdn do we need to implement them before 10? here is the list:-   any (exist isempty)-   **asobservable** (#641)-   **case** (#635)-   ~~catch~~ (onerrorresumenext is what we use this was for f# computation expressions)-   **chunkify** (#636)-   **collect** (#636)-   ~~deferasync~~ (not applicable as we dont have `task` or async/await)-   **delaysubscription** (#638)-   do (dooneach)-   **dowhile** (#635)-   finally (finallydo)-   **firstasync** (#520)- [x]  **firstordefaultasync** (firstordefault)- [x]  **for** (#636)- [x]  foreach (blockingobservableforeach)-   ~~foreachasync~~ (blockingobservableforeach since we dont  have `task` or async/await)-   ~~fromasync~~ (from with schedulers does this)- [x]  ~~fromasyncpattern~~ (wont implement)- [x]  ~~fromevent~~ (wont implement)- [x]  ~~fromeventpattern~~ (wont implement)- [x]  **generate** (#519)- [x]  ~~getenumerator~~ (wont implement)- [x]  **if** (#635)- [x]  lastasync (last)- [x]  lastordefault (blockingobservablelastordefault)- [x]  **lastordefaultasync** (#520)- [x]  **latest** (#626)- [x]  mostrecent (blockingobservablemostrecent)- [x]  next (blockingobservablenext)- [x]  refcount (connectableobservablerefcount)- [x]  **repeat** (#518)- [x]  return (from just)- [x]  select (map)- [x]  selectmany (flatmap)- [x]  single (blockingobservablesingle)- [x]  **singleasync** (#520)- [x]  singleordefault (blockingobservablesingleordefault)- [x]  **singleordefaultasync** (#520)-   ~~startasync~~- [x]  switch (switchonnext)- [x]  **takelastbuffer** (#638)- [x]  throttle (debounce)- [x]  throw (error)- [x]  toarray (unnecessary)- [x]  toasync (asynctoasync)- [x]  todictionary (tomap)- [x]  toenumerable (blockingobservabletoiterable)- [x]  ~~toevent~~ (wont implement)- [x]  ~~toeventpattern~~ (wont implement)- [x]  tolookup (tomultimap)- [x]  toobservable (from)-   ~~wait~~ (blockingobservablelast())- [x]  **while** (#635)**strong** means someone is working on it~~strikethrough~~ means it wont be implememted;""nice listcatch -> onerrorresumenext (?)fromasyncpattern: wont implement (#46)generate -> pr available (#519) still debating on return typelastordefault -> bolastordefault (?)mostrecent -> bomostrecentrepeat -> pr available (#518)startasync -> start  (?)switch -> switchonnext (?)throttle -> debouncei dont recognize the rest || updatedstartasync is not the `start` operator:```    //    // summary:    //     invokes the asynchronous function surfacing the result through an observable    //     sequence  the cancellationtoken is shared by all subscriptions on the resulting    //     observable sequence see the remarks section for more information    //    // parameters:    //   functionasync:    //     asynchronous function to run    //    // type parameters:    //   tresult:    //     the type of the result returned by the asynchronous function    //    // returns:    //     an observable sequence exposing the functions result value or an exception    //    // exceptions:    //   systemargumentnullexception:    //     functionasync is null    //    // remarks:    //      the function is started immediately not during the subscription of the    //     resulting sequence  multiple subscriptions to the resulting sequence can    //     observe the functions result  if any subscription to the resulting sequence    //     is disposed the cancellationtoken is set the observer associated to the    //     disposed subscription wont see the taskcanceledexception but other observers    //     will you can protect against this using the catch operator  be careful    //     when handing out the resulting sequence because of this behavior the most    //     common use is to have a single subscription to the resulting sequence which    //     controls the cancellationtoken state alternatively you can control subscription    //     behavior using multicast operators    public static iobservable<tresult> startasync<tresult>(func<cancellationtoken task<tresult>> functionasync)``` || here is whats missing and what they generally do:-  **asobservable**: """"hides the identity of an observable sequence""""-  **case**: """"uses a selector to determine which source to return"""" ie in onsubscribe a func0 selector is called and an observable looked up in a map then subscribed to it-  **chunkify**: """"produces an enumerable sequence of consecutive (possibly empty) chunks of the source sequence"""" ie implemented as `sourcecollect(() -> new arraylist (lst x) -> {lstadd(x) return lst} u -> new arraylist)`-  **collect**: """"produces an enumerable sequence that returns elements collected/aggregated from the source sequence between consecutive iterations"""" for example you start out with an empty list and each onnext adds to the list once the `iteratornext()` takes the current list it is replaced by a fresh list depending on the frequency of `next()` you might get lists with various sizes-  **deferasync**: """"returns an observable sequence that starts the specified asynchronous factory function whenever a new observer subscribes"""" implemented as defer(() -> startasync(factory)merge()) where factory is a `func0<task<iobservable<tvalue>>>`-  **delaysubscription**: """"time shifts the observable sequence by delaying the subscription with the specified relative time duration"""" does not timeshift the unsubscribe-  **dowhile**: """"repeats the given source as long as the specified condition holds where the condition is evaluated after each repeated source completed"""" ie repeat only if condition holds: `do { subscribe & run } while (condition)`-  **for**: """"concatenates the observable sequences obtained by running the resultselector for each element in the given enumerable source"""" the difference from a plain concat is that the source iterable is consumed on demand rather than all at once-  **foreachasync**: """"invokes an action for each element in the observable sequence and returns a task object that will get signaled when the sequence terminates"""" like making a whole sequence of observations into a big future dual of fromfuture & toasync in some sense-  **fromasync**: """"converts to asynchronous function into an observable sequence each subscription to the resulting sequence causes the function to be started the cancellationtoken passed to the asynchronous function is tied to the observable sequences subscription that triggered the functions invocation and can be used for best-effort cancellation"""" implemented as `defer(() -> startasync(functionasync))` where functionasync is `func<task<tresult>>` or `func<cancellationtoken task<tresult>>`- [x] **if**: """"if the specified condition evaluates true select the thensource sequence otherwise select the elsesource sequence"""" condition is evaluated on subscription- [x] **groupby** with capacity overloads (v22)- [x] **groupbyuntil** with capacity overloads (v22)- [x] **singleasync**: """"returns the only element of an observable sequence and reports an exception if there is not exactly one element in the observable sequence"""" returns an observable with a single element or exception- [x] **singleordefaultasync**: """"returns the only element of an observable sequence or a default value if the observable sequence is empty this method reports an exception if there is more than one element in the observable sequence""""- [x] **startasync**: see [comment]( above- [x] **takelast** overload with time window (ie return the last 2 seconds worth of source values once it finishes)- [x] **takelastbuffer**: """"returns a list with the specified number of contiguous elements from the end of an observable sequence"""" has time based overloads almost like takelast but emits a single list of elements - [x] **wait**: """"waits for the observable sequence to complete and returns the last element of the sequence if the sequence terminates with an onerror notification the exception is throw"""" returns t looks like a `sourcetakelast(1)toblockingobservable()single()`- [x] **while**: """"repeats the given source as long as the specified condition holds where the condition is evaluated before each repeated source is subscribed to"""" ie `while(condition) { subscribe }` || @zsxwing or anyone else do you want to do some of these? ill do them in batches do i dont have to rebase and restart from master all the time ill start with `dowhile` `while` `if` `case` || continuing with `chunkify` `collect` `wait` and `for`update: wait is practically bolast() since we dont usually do aliases ill skip wait || next: `defersubscription` `takelast` `takelastbuffer` || i can add singleasync and singleordefaultasync in pr #520 directly || do we really need deferasync foreachasync fromasync startasync? we have no cancellationtoken in java || it appears to me that cancellationtoken is used for cancelling tasks basically a similar way you would use futuretask and check its iscancelled() but since these tokens come from the outside you can signal cancellations to multiple tasks at once since we have the `subscription` infrastructure for that id vote for not implementing those variants || doing `asobservable` `groupby` and `groupbyuntil` variants || anyone want to implement all the testschedulers?(cancellationtoken is really only useful when you have async await) || a can take those as well unless someone else beats me to it while i do the ops mentioned above || doing lastasync and lastordefaultasync || @headinthebox what features do you miss from the current `testscheduler`? im looking at rxnet sources of virtualscheduler testscheduler and historicalscheduler but it is not apparent to me what the functional requirements arenever mind ill start doing it btw im starting to require the enhancements of my prs to avoid feature duplication || these :switch -> switchonnext (?)throttle -> debouncethe """"async"""" ones dont use the async suffix in rxjava since the non-async ones are on `blockingobservable` instead thus some of those in the list are already implemented just without the async suffix || @zsxwing how is the `lastasync` operator you say youre doing different than `last` ( that is already implemented? it is non-blockingwe have `last` and `takelast````last()           returns an observable that emits the last item emitted by the source or an illegalargumentexception if the source observable is emptytakelast(int count)           returns an observable that emits only the last count items emitted by the source observable```difference between `takelast(1)` and `last()` just being the `illegalargumentexception` on `take` you were involved in both of these i though so im confused why were pursuing `lastasync` || what is a use case for `asobservable` to """"hide identity""""? || rxnet uses it all around the place to hide subjects @headinthebox might explain it better || interesting though what value is there in """"hiding"""" it? if it is returned as an `observable` not a `subject` people will use it as an `observable` is it to prevent people reflecting or inspecting a type and then interacting with the `subject`? || yup as @benjchristensen says it is to prevent downcasting etc in net people are pretty paranoid about this say you have a method that returns an iterable<t> but really it is an array<t> now that opens a potential (security) hole since the caller can use the iterable as a an array  || > @zsxwing how is the lastasync operator you say youre doing different than last ( that is already implemented? it is non-blockingsorry forget it we just need to add `lastordefaultasync` hope this comment ( can make these operators clear if no problem i can add this table to the wiki || looking into `deferasync` `startasync` and `singleasync` || > looking into deferasync startasync and singleasyncsingleasync has already done in #520 || doing foreachasync and fromasync and probably will amend pr #645 || the `fromasync` behavior seems to be covered in `from` overloads that take a `scheduler` such as this:  || no this fromasync is a completely different operation: it uses a factory to get a future of a value which is then observed per subscriber || already added the table to the wiki: thu dec 19 2013 at 5:57 pm shixiong zhu notifications@githubcomwrote:> @zsxwing  how is the lastasync operator you> say youre doing different than last (>  that is already implemented? it is non-blocking> > sorry forgot it we just need to add lastordefaultasync hope this> comment (#520 (comment) can make these operators clear if no problem i can add this table to the> wiki> > > reply to this email directly or view it on github ## david m grossplp consulting || @headinthebox and i reviewed the list all remaining items have been struck out as they should not be implementedgreat work getting all the others done! || "";1;0;3x: make using() resource disposal order consistent with eager-mode;"
6535;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: javadocs: clarify create emitters are per consumer;this pr adds this documentation part to the various  create  javadocs (adapted):;;0;3x: javadocs: clarify create emitters are per consumer;this pr adds this documentation part to the various `create` javadocs (adapted):whenever an `observer` subscribes to the returned `observable` the provided`observableonsubscribe` callback is invoked with a fresh instance of an `observableemitter`that will interact only with that specific `observer` if this `observer`disposes the flow (making `observableemitter#isdisposed` return true)other observers subscribed to the same returned `observable` are not affected6390; merging 6535  < ;;;;1;1;3x: javadocs: clarify create emitters are per consumer;
6537;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: promote beta/experimental to standard;promote the following experimental operators to standard:;;0;3x: promote beta/experimental to standard;promote the following experimental operators to standard:- `completabledelaysubscription(long timeunit [ scheduler])`- `completablematerialize()`- `flowabledematerialize(function)`- `maybedoonterminate()`- `maybematerialize()`- `observabledematerialize(function)`- `singledematerialize(function)`- `singlematerialize()`there were no `beta` operators in 22x; merging 6537 ;;;;1;1;3x: promote beta/experimental to standard;
"6538;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: add concatmap with scheduler guaranteeing where the mapper runs;this pr adds an overload to  concatmap  and  concatmapdelayerror  in both  flowable  and  observable  which makes sure the  mapper  function is always executed on a dedicated scheduler.;;644.0;3x: add concatmap with scheduler guaranteeing where the mapper runs;this pr adds an overload to `concatmap` and `concatmapdelayerror` in both `flowable` and `observable` which makes sure the `mapper` function is always executed on a dedicated schedulerby default `concatmap` may execute the `mapper` function on various threads: the subscribing thread the upstream thread generating the items to be mapped or the thread where the generated inner source terminates these overloads remove this kind of uncertaintythe implementation is a copy of the original concatmap instead of an extension so that optimizations for the non-scheduled variants still work without extra overheadoverloads to the `concatmap{single|maybe|completable}` and `concatmap{single|maybe|completable}delayerror` *may be added* in a separate pr later6447; merging 6538 ;throw the checked exception without declaring it;it uses the deprecated method threadstop(throwable) to throw an exception without declaring it;""the non-deprecated way of doing this if i understand your goal is the so-called """"sneakythrow"""" approach:  || #574 i saw that one but this way seems so much simpler || this looks like a [very dangerous thing]( in addition are basically killing the current thread which could be a thread of a thread pool and incur a thread-recreation fee as well  || thats what throwing any exception does  the real danger is that a user incorrectly assumes that because a checked exception isnt declared that only subclasses runtimeexception can be thrown || im not convinced we should be attempting sneaky throw at all in java people do not expect checked exceptions to be thrown without declaration i dont like checked exceptions but i like confusing and non-obvious behavior less is the problem of runtimeexception wrapping for blockingobservable serious enough to fight against the language?are there other major libraries that do this? || i didnt even consider the idea of a sneaky throw until i ran into it with java calling a groovy closure not that groovy is anything to aspire to || > not that groovy is anything to aspire toha! || i feel that this comment is the key to this discussion:> the real danger is that a user incorrectly assumes that because a checked exception isnt declared that only subclasses runtimeexception can be thrownmy opinion is that we should not try and do a sneaky throw as the least surprising thing we can do it wrap an `exception`/`throwable` in a `runtimeexception` and everyone will catch it instead of them getting `exception`/`throwable` thrown past their `try/catch` block and blowing up their appdoes anyone have a strong reason to pursue this """"sneaky throw"""" approach in light of this perspective?i will close this out in the next couple days if i hear nothing to convince otherwise || "";1;0;3x: add concatmap with scheduler guaranteeing where the mapper runs;"
6539;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: remove no-arg dematerialize()  remove replay(scheduler) variants;this pr removes some obsolete api.;;0;3x: remove no-arg dematerialize() remove replay(scheduler) variants;this pr removes some obsolete apithe `flowabledematerialize()` and `observabledematerialize()` were inherently type-unsafe and have been removed in rxnet the extension methods allowed `dematerialize()` to be applied to `observable<notification<t>>` only but there is no way for doing it in java as it has no extension methods and one cant restrict a method to appear only with a certain type argument schemethe`replay(scheduler)` and other overloads were carried over from the original rxnet api set but i cant rememeber if they had any use in the field most use cases capture the connectable anyway so there is no much benefit from inlining an `observeon` into a connectable:```javaconnectableflowable<integer> connectable  sourcereplay()flowable<integr> flowable  connectableobserveon(schedulersio())// hand flowable to consumersflowablesubscribe()connectableconnect()```; merging 6539 ;;;;1;1;3x: remove no-arg dematerialize() remove replay(scheduler) variants;
6544;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fixing version tag on schedulers.from(executor  boolean);6543;;6543.0;fixing version tag on schedulersfrom(executor boolean);6543 updating the version tag on `schedulersfrom(executor boolean)` since it was promoted; merging 6544 ;3x: fix schedulersfrom(executor boolean) version tag;it should say `@since 300` as it has been promotedhttps://githubcom/reactivex/rxjava/blob/3x/src/main/java/io/reactivex/schedulers/schedulersjava#l403;closing via #6544 ||;1;0;#6543 fixing version tag since `schedulersfrom(executor boolean)` has been promoted;
6545;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: remove unnecessary static imports from unit tests;2.x: remove unnecessary static imports from unit tests.;;0;2x: remove unnecessary static imports from unit tests;2x: remove unnecessary static imports from unit tests; merging 6545 ;;;;1;1;remove unnecessary import;
6546;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: simplify junit tests with more appropriate assert methods;simplify unit tests by using the more appropriate junit assert methods.;;0;2x: simplify junit tests with more appropriate assert methods;simplify unit tests by using the more appropriate junit assert methods; merging 6546 ;;;;1;1;simplify junit;
6549;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: simplify junit tests with more appropriate assert methods;simplify junit tests with more appropriate assert methods.;;0;3x: simplify junit tests with more appropriate assert methods;simplify junit tests with more appropriate assert methods;thanks!please in the future fill in the issue text and dont leave the default welcome text there the better the issue text describes the change the easier search engines will find them ||;;;;1;1;3x: simplify junit tests with more appropriate assert methods;
6550;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: remove unnecessary static imports from unit tests;remove unnecessary static imports from unit tests.;;0;3x: remove unnecessary static imports from unit tests;remove unnecessary static imports from unit tests; merging 6550 ;;;;1;1;3x: remove unnecessary static imports from unit tests;
"6556;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x rename on error resume next methods to disambiguate when calling from kotlin (#6551);6551;;6551.0;3x rename on error resume next methods to disambiguate when calling from kotlin (#6551);6551 - renamed `onerrorresumenext(source)` to `onerrorresumewith(source)` for `observable` `maybe` `single` and `flowable`- renamed some unit tests and their classes to reflect the method name change- changed parameter type of `singleonerrorresumewith` from `single` to `singlesource`  - updated javadocs for all renamed methods- removed redundant casts for unit tests- deleted duplicate unit test that arose from no longer needing to cast arguments;;disambiguous some method call sites when calling from kotlin;""i vaguely remember that we already had a discussion about this but i dont know which conclusion was drawn observableonerrorresumenext is ambiguous when calling from kotlin<img width""""1370"""" alt""""screenshot 2019-06-30 at 12 09 33"""" src"""" 3x is a thing do we want to rename these methods similar to what we did with `startwith` (even though there was no type inference problem)"";yes 3x is a good place fix such ambiguities my ideas are `onerrorresume(observablesource)` or `onerrorresumewith(observablesource)` pr welcome || those names sound good to me i believe the onerrorreturn should also be renamd then || a few questions:- do you want to change `maybeonerrorresumenext(maybesource)` as well? - to what should `observableonerrorreturn(function valuesupplier)` be renamed? - do you want to rename `maybeonerrorreturn(function valuesupplier)` as well?- what about `singleonerrorreturn(function resumefunction)?`- is it ok to do all of this in the same pr? || > do you want to change maybeonerrorresumenext(maybesource) as well?yes every class where `onerrorresumenext` has a source type and a function> to what should observableonerrorreturn(function valuesupplier) be renamed?there is no ambiguity there as the other is called `onerrorreturnitem`> do you want to rename maybeonerrorreturn(function valuesupplier) as well?there is no ambiguity there either> what about singleonerrorreturn(function resumefunction)?there is no ambiguity there either> is it ok to do all of this in the same pr?you can rename multiple things within the same pr || @akarnokd thanks for the clarification out of curiosity @vanniktech was there a reason besides ambiguity that made you suggest renaming the `onerrorreturn`s? || @akarnokd is there a reason `singleonerrorresumenext(final single<? extends t> resumesingleincaseoferror)` takes a `single` and not a `singlesource` like the other methods? ive made the change and run all the tests for this method and all of them pass if theres no reason and its ok with you id be happy to make the change since im in the area anyway  || looks like an api mistake you can change that too (and see if other places need fixing as well) ||;1;0;#6551 renaming flowableonerrorresumenext(publisher) to flowableonerrorresumewith(publisher) renaming some affected tests deleted duplicated unit test that arose from being able to remove redundant casts updated javadocs;"
"6559;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x fix npe when debouncing empty source;**background** related issue #6558;;6558.0;3x fix npe when debouncing empty source;""**background** related issue #6558 debounce with selector on the empty `observable` leads to npeit happens because of `debounceobserver#debouncer` field is set up only when `onnext` is called when `onnext` isnt called at all like when debouncing `observableempty()` we get a null reference from `debouncer` and call `emit` on `null` which actually leads to npe**change**wrap `emit` call with null check both in `observabledebounce` and `flowabledebounce`**test plan**to check `observable`:```/gradlew test --tests """"ioreactivexinternaloperatorsobservableobservabledebouncetestdebounceonempty""`to check `flowable`:```/gradlew test --tests """"ioreactivexinternaloperatorsflowableflowabledebouncetestdebounceonempty""""````""; merging 6559 ;2x/3x - npe when debouncing empty source;hey there!ive faced with an issue when debouncing empty source it leads npe here is simple test which demonstrates a problem:```@testpublic void debounceonempty() {    observableempty()debounce(new function<object observablesource<object>>() {        @override        public observablesource<object> apply(object o) {            return observablejust(new object())        }    })subscribe()}```issue also touches `flowable` in the same way rxjava version is 227 however it is also reproducible for latest 3xi am going to create pr with a fix soon for both of versions lets keep this ticket to track a state of the issue;closing via #6559 & #6560 ||;1;0;fix npe when debouncing empty source;"
"6560;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x fix npe when debouncing empty source;**background** related issue #6558;;6558.0;2x fix npe when debouncing empty source;""**background** related issue #6558 cherry pick of #6559 for 2x versiondebounce with selector on the empty `observable` leads to npeit happens because of `debounceobserver#debouncer` field is set up only when `onnext` is called when `onnext` isnt called at all like when debouncing `observableempty()` we get a null reference from `debouncer` and call `emit` on `null` which actually leads to npe**change**wrap `emit` call with null check both in `observabledebounce` and `flowabledebounce`**test plan**to check `observable`:```/gradlew test --tests """"ioreactivexinternaloperatorsobservableobservabledebouncetestdebounceonempty""`to check `flowable`:```/gradlew test --tests """"ioreactivexinternaloperatorsflowableflowabledebouncetestdebounceonempty""""````""; merging 6560 ;2x/3x - npe when debouncing empty source;hey there!ive faced with an issue when debouncing empty source it leads npe here is simple test which demonstrates a problem:```@testpublic void debounceonempty() {    observableempty()debounce(new function<object observablesource<object>>() {        @override        public observablesource<object> apply(object o) {            return observablejust(new object())        }    })subscribe()}```issue also touches `flowable` in the same way rxjava version is 227 however it is also reproducible for latest 3xi am going to create pr with a fix soon for both of versions lets keep this ticket to track a state of the issue;closing via #6559 & #6560 ||;1;0;fix npe when debouncing empty source;"
6564;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: remove buffer/window with supplier & onexceptionresumenext;this pr removes 3 kinds of operators that had no noticeable use bases or use cases on their own in the past years.;;655.0;3x: remove buffer/window with supplier & onexceptionresumenext;this pr removes 3 kinds of operators that had no noticeable use bases or use cases on their own in the past years- `buffer(supplier [ supplier])`- `window(supplier [ int])`- `onexceptionresumenext(<source>)`6554 resolves #6555; merging 6564  < ;skip skiplast take takelast with time;issue #653;#588  #589 #592 looks good || what is the reason for the `drain` concept? i know it exists in net but i dont believe we need this in javai can imagine concern with not wanting a timer thread to do long-running work but we dont have that issue with our `scheduler` implementations we always have the time aspects of our schedulers running on separate threads (such as `genericscheduledexecutorservice` in the case of `newthreadscheduler` so we dont block time events || i think it was added to avoid scheduling onnext calls individually but rather emit everything in one go i havent found any other places where this kind of overload was present in rxnet should i remove that overload? are the other variants okay to stay? || ill resubmit this since it conflicts with master anyway ||;1;0;3x: remove buffer/window with supplier & onexceptionresumenext;
6564;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: remove buffer/window with supplier & onexceptionresumenext;this pr removes 3 kinds of operators that had no noticeable use bases or use cases on their own in the past years.;;6554.0;3x: remove buffer/window with supplier & onexceptionresumenext;this pr removes 3 kinds of operators that had no noticeable use bases or use cases on their own in the past years- `buffer(supplier [ supplier])`- `window(supplier [ int])`- `onexceptionresumenext(<source>)`6554 resolves #6555; merging 6564  < ;remove onexceptionresumenext?;[javadocs]( dont remember ever needing asked for or recommended this operator? the difference from `onerrorresumenext` is that anything thats not extending `exception` can pass through i believe it was added to support some internal netflix operation it can be emulated via `onerrorresumenext`: ```javasourceonerrorresumenext(    error -> error instanceof exception         ? fallback : obserableerror(error))```;never used onexceptionresumenext || it was rather more confusing ||;1;0;3x: remove buffer/window with supplier & onexceptionresumenext;
"6565;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix javadocs of single.doonterminate refer to oncomplete notification;as mentioned in javadocs of this class that single does not have  oncomplete  notification.;;0;fix javadocs of singledoonterminate refer to oncomplete notification;""as mentioned in javadocs of this class that single does not have """"oncomplete"""" notificationthis newly introduced method refer to that notification which looks to me it should be onsuccess instead"";   no coverage uploaded for pull request base (`2x@5c83b50`) [click here to learn what that means]( `n/a`(                                  2x    #6565   +/-   ##  coverage       ?   9824%             complexity     ?     6333             files          ?      677  ?    45488     ?     6321             hits           ?    44691             misses         ?      244             partials       ?      553```| [impacted files]( | coverage  | complexity  | ||---|---|---|---|| [src/main/java/io/reactivex/singlejava]( | `100% <> ()` | `149 <0> (?)` | |------[continue to review full report at codecov]( **legend** - [click here to learn more]( `  absolute <relative> (impact)` `  not affected` `?  missing data`> ( last update [5c83b509d9ef71]( read the [comment docs]( ||;;;;1;1;fix javadocs of singledoonterminate refer to oncomplete notification;"
6566;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: fix wording in single javadocs;some wording fixes in  single   includes #6565.;;0;3x: fix wording in single javadocs;some wording fixes in `single` includes #6565; merging 6566 ;;;;1;1;3x: fix wording in single javadocs;
"6570;1;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: code verification fixes for javac s generated switchmap classes;java 13+ compilers generate a synthetic class for switch statements over enumerables now  so  observable.class  (and a few others) now receive an  observable$1.class  companion  which trips the no anonymous inner classes heuristic verification. this pr changes the respective unit test to filter out such classes in a heuristic manner too.;;0;3x: code verification fixes for javacs generated switchmap classes;""java 13+ compilers generate a synthetic class for switch statements over enumerables now so `observableclass` (and a few others) now receive an `observable$1class` companion which trips the no anonymous inner classes heuristic verification this pr changes the respective unit test to filter out such classes in a heuristic manner tooin addition the `findsource` method has been moved into `testhelper` for clarity and changed so that any capitalization of the """"rxjava"""" host directory is accepted"";"" merging 6570  "";;;;1;1;gradle/intellij output dir corrections;"
6572;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix switchmaps inconsistency swallowing errors when cancelled;the various  switchmap  operators did not report any accumulated exceptions to the global error handler when the sequence was cancelled (and thus the errors would never be delivered through the regular channels).;;0;3x: fix switchmaps inconsistency swallowing errors when cancelled;the various `switchmap` operators did not report any accumulated exceptions to the global error handler when the sequence was cancelled (and thus the errors would never be delivered through the regular channels); merging 6572  < ;;;;1;1;3x: fix switchmaps inconsistency swallowing errors when cancelled;
6577;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0; #6576 - observableblockingsubscribe compares blockingobserver.terminated with wrong object;6576   compare with  v  instead of  o .;;6576.0; #6576 - observableblockingsubscribe compares blockingobserverterminated with wrong object;6576  compare with `v` instead of `o`; merging 6577  < ;observableblockingsubscribe compares blockingobserverterminated with wrong object;the `observableblockingsubscribeobserve` function appears to compare the `o` variable ie the `observablesource` which shouldnt ever change with `blockingobserverterminated` this will probably never be true the intention was likely to use `v` instead of `o` in: since this appears to be somewhat redundant with `bsisdisposed()` this probably does not cause any issues;yes it should be `v  blockingobserverterminated` pr welcome ||;1;0; #6576 - observableblockingsubscribe compares blockingobserverterminated with wrong object;
6579;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: widen throws on the xonsubscribe interfaces;this pr widens the  throws exception  to  throws throwable  on the callback interfaces of the  create  methods:  {flowable|observable|maybe|single|completable}onsubscribe .;;0;3x: widen throws on the xonsubscribe interfaces;this pr widens the `throws exception` to `throws throwable` on the callback interfaces of the `create` methods: `{flowable|observable|maybe|single|completable}onsubscribe`; merging 6579 ;;;;1;1;3x: widen throws on the xonsubscribe interfaces;
6581;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: add more time for gc in refcounttest.publishnoleak;few of the recent merges failed the  publishnoleak  test because the gc apparently didn t finish in time. this pr increases the gc time to 250 milliseconds in those tests.;;0;3x: add more time for gc in refcounttestpublishnoleak;few of the recent merges failed the `publishnoleak` test because the gc apparently didnt finish in time this pr increases the gc time to 250 milliseconds in those tests; ;;;;1;1;some test restructuring and dynamic gc wait;
6582;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: fix truncation bugs in replay() and replaysubject/processor;this pr fixes several truncation bugs with the time and size-bound replay() operators and their hot class versions:;;0;3x: fix truncation bugs in replay() and replaysubject/processor;this pr fixes several truncation bugs with the time and size-bound replay() operators and their hot class versions:- unexpected removal of the last item just added due to becoming out-of-date at the lowest time resolution creating a hole in the linked chain and hanging the consumer [related failure]( incorrect size accounting upon removing old entries leading to more items dropped than expected*sidenote: the operators and classes would benefit from a rewrite to improve on allocation and indirection i wanted first to get the bugfixes and related tests done to have a known good baseline*; merging 6582 ;;;;1;1;undo the last commit as it somehow hangs the ci offline is okay;
6589;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;create a base test class and have all unit tests extend it;this commit creates the  rxjavatest  class defining a default;;658.0;create a base test class and have all unit tests extend it;this commit creates the `rxjavatest` class defining a defaulttimeout to 5 minutes an ignored test announce itself for eachrunning class extending it preventing travis ci from killing thebuildhave `completable` tests extend from `rxjavatest`have `disposable` tests extend from `rxjavatest`have `exception` tests extend from `rxjavatest`related: #6583; merging 6589 ;behaviorsubject race condition;need to investigate the `behaviorsubject` as it likely has the same problem as rxnet as reported here:  that `subjects` were just re-implemented but kept the same behavior and for the `behaviorsubject` the race between returning the current value and subscribing for subsequent values appears to be wronguse case:```onnext: 1 2 3 4 5 6 7 8 9observer: subscribe between 3 & 4  should receive 3 4 5 6 7 8 9```the likely bug is that in a race it could receive `3 6 7 8 9`;there are a few missing suggestions that i didnt have in my pr which also involves behaviorsubject ill take a look at this as welledit: yes this can happen if an observer subscribes it immediately gets the current value then it is eventually added to the state object via `addobserver` which add could be delayed and values lostedit 2: how to avoid it:- one would need to block onnext while a subscription is happening which would negate the improvements - include the lastnotification in the state so a new observed value triggers a state replace similar to when an observer subscribes however one would need 2 states: active and modifying: this avoids using a lock similar to how `abstractatomicsubscription` allows complex operations in the mutating statei thought about the queue/drain suggestion in the article but i cant see it solving the value skip problem (it surely acts against reordering if there happen to be concurrent onnext calls - but we dont allow / ignore those by contract) || the queue/drain approach can be adapted to also ensure you dont miss notifications all you have to do is _queue the subscription as well_ (queue/drain is a fully general synchronization mechanism akin to using an actor)note that if you do this the initial value may not arrive immediately if the behavior subject is being touched on another thread but it can be  by introducing a second queue specific to the subscription that was initialized with the latest value while atomically subscribingso a no-deadlock no-reorder no-thread-hopping-for-initial-value subscription would look like:```initialvaluesent  falsemisseddraincount  0create drain queue q for subscriptionsync(this) {    add observer to {        enqueue new value onto q        sync(q) {            // other threads must not push initial value            if (!initialvaluesent) {                misseddraincount++            }        }        trydrain q    }    enqueue current value onto q}// forward value to caller before returning (and perhaps some later values too)trydrain q// --- allow other threads to forward future values ---sync(q) {    initialvaluesent  true}// in case observers were enqueueing while we set the flag// (pretty sure reading misseddraincount is safe to touch without locking now)// (this can be done without the loop but requires modifying the q to drain n)while (misseddraincount-- > 0) {    trydrain q}```i think thats right just off the top of my head though || if youre willing to allow the initial value to thread-hop its a lot simpler of course:```subscribe:    enqueue {        add observer    }    trydrainsend:    enqueue {        send to all observers    }    trydrain```(assuming youre using the queue as your only synchronization mechanism if youre also using locks you probably need to lock around the enqueues)_edit_ fixed enqueueing inside add observer instead of inside send || i think this is still an unsolved problem do we still want to put effort into this? || i was thinking about trying to solve it similar to the `groupby` solution but havent spent the time to determine if it can be made to work || ive implemented a potential fix [here]( but cant create a pr right now due to a github 500 error  a simple publish benchmark for publishsubject is 83 mops/s behaviorsubject (new) ~47mops/s behaviorsubject (master) is ~48 mops/sec || fix just ;1;0;create a base test class and have all unit tests extend itthis commit creates the `rxjavatest` class defining a defaulttimeout to 5 minutes an ignored test announce itself for eachrunning class extending it preventing travis ci from killing thebuildhave `completable` tests extend from `rxjavatest`have `disposable` tests extend from `rxjavatest`have `exception` tests extend from `rxjavatest`related: #6583;
6594;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;have unit tests extends  rxjavatest  - 2;this commit updates the unit tests of the following operators:;;658.0;have unit tests extends `rxjavatest` - 2;this commit updates the unit tests of the following operators:* flowable* maybe* observable* disposable* observer* parallel* processors* schedulersand rxjava pluginrelated: #6583; merging 6594  < ;behaviorsubject race condition;need to investigate the `behaviorsubject` as it likely has the same problem as rxnet as reported here:  that `subjects` were just re-implemented but kept the same behavior and for the `behaviorsubject` the race between returning the current value and subscribing for subsequent values appears to be wronguse case:```onnext: 1 2 3 4 5 6 7 8 9observer: subscribe between 3 & 4  should receive 3 4 5 6 7 8 9```the likely bug is that in a race it could receive `3 6 7 8 9`;there are a few missing suggestions that i didnt have in my pr which also involves behaviorsubject ill take a look at this as welledit: yes this can happen if an observer subscribes it immediately gets the current value then it is eventually added to the state object via `addobserver` which add could be delayed and values lostedit 2: how to avoid it:- one would need to block onnext while a subscription is happening which would negate the improvements - include the lastnotification in the state so a new observed value triggers a state replace similar to when an observer subscribes however one would need 2 states: active and modifying: this avoids using a lock similar to how `abstractatomicsubscription` allows complex operations in the mutating statei thought about the queue/drain suggestion in the article but i cant see it solving the value skip problem (it surely acts against reordering if there happen to be concurrent onnext calls - but we dont allow / ignore those by contract) || the queue/drain approach can be adapted to also ensure you dont miss notifications all you have to do is _queue the subscription as well_ (queue/drain is a fully general synchronization mechanism akin to using an actor)note that if you do this the initial value may not arrive immediately if the behavior subject is being touched on another thread but it can be  by introducing a second queue specific to the subscription that was initialized with the latest value while atomically subscribingso a no-deadlock no-reorder no-thread-hopping-for-initial-value subscription would look like:```initialvaluesent  falsemisseddraincount  0create drain queue q for subscriptionsync(this) {    add observer to {        enqueue new value onto q        sync(q) {            // other threads must not push initial value            if (!initialvaluesent) {                misseddraincount++            }        }        trydrain q    }    enqueue current value onto q}// forward value to caller before returning (and perhaps some later values too)trydrain q// --- allow other threads to forward future values ---sync(q) {    initialvaluesent  true}// in case observers were enqueueing while we set the flag// (pretty sure reading misseddraincount is safe to touch without locking now)// (this can be done without the loop but requires modifying the q to drain n)while (misseddraincount-- > 0) {    trydrain q}```i think thats right just off the top of my head though || if youre willing to allow the initial value to thread-hop its a lot simpler of course:```subscribe:    enqueue {        add observer    }    trydrainsend:    enqueue {        send to all observers    }    trydrain```(assuming youre using the queue as your only synchronization mechanism if youre also using locks you probably need to lock around the enqueues)_edit_ fixed enqueueing inside add observer instead of inside send || i think this is still an unsolved problem do we still want to put effort into this? || i was thinking about trying to solve it similar to the `groupby` solution but havent spent the time to determine if it can be made to work || ive implemented a potential fix [here]( but cant create a pr right now due to a github 500 error  a simple publish benchmark for publishsubject is 83 mops/s behaviorsubject (new) ~47mops/s behaviorsubject (master) is ~48 mops/sec || fix just ;1;0;have unit tests extends `rxjavatest` - 2this commit updates the unit tests of the following operators:* flowable* maybe* observable* disposable* observer* parallel* processors* schedulersand rxjava pluginrelated: #6583;
6595;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;have unit tests extends  rxjavatest  - 3;this commit updates the unit tests of the following operators:;;658.0;have unit tests extends `rxjavatest` - 3;this commit updates the unit tests of the following operators:* single* subjects* subscribersand for internal operators:* internaldisposable* internalfuctions* internalobservers* internalqueue* interanlschedulers* internalsubscribers* internalsubscriptions* internaloperatorcompletablerelated: #6583; merging 6595 ;behaviorsubject race condition;need to investigate the `behaviorsubject` as it likely has the same problem as rxnet as reported here:  that `subjects` were just re-implemented but kept the same behavior and for the `behaviorsubject` the race between returning the current value and subscribing for subsequent values appears to be wronguse case:```onnext: 1 2 3 4 5 6 7 8 9observer: subscribe between 3 & 4  should receive 3 4 5 6 7 8 9```the likely bug is that in a race it could receive `3 6 7 8 9`;there are a few missing suggestions that i didnt have in my pr which also involves behaviorsubject ill take a look at this as welledit: yes this can happen if an observer subscribes it immediately gets the current value then it is eventually added to the state object via `addobserver` which add could be delayed and values lostedit 2: how to avoid it:- one would need to block onnext while a subscription is happening which would negate the improvements - include the lastnotification in the state so a new observed value triggers a state replace similar to when an observer subscribes however one would need 2 states: active and modifying: this avoids using a lock similar to how `abstractatomicsubscription` allows complex operations in the mutating statei thought about the queue/drain suggestion in the article but i cant see it solving the value skip problem (it surely acts against reordering if there happen to be concurrent onnext calls - but we dont allow / ignore those by contract) || the queue/drain approach can be adapted to also ensure you dont miss notifications all you have to do is _queue the subscription as well_ (queue/drain is a fully general synchronization mechanism akin to using an actor)note that if you do this the initial value may not arrive immediately if the behavior subject is being touched on another thread but it can be  by introducing a second queue specific to the subscription that was initialized with the latest value while atomically subscribingso a no-deadlock no-reorder no-thread-hopping-for-initial-value subscription would look like:```initialvaluesent  falsemisseddraincount  0create drain queue q for subscriptionsync(this) {    add observer to {        enqueue new value onto q        sync(q) {            // other threads must not push initial value            if (!initialvaluesent) {                misseddraincount++            }        }        trydrain q    }    enqueue current value onto q}// forward value to caller before returning (and perhaps some later values too)trydrain q// --- allow other threads to forward future values ---sync(q) {    initialvaluesent  true}// in case observers were enqueueing while we set the flag// (pretty sure reading misseddraincount is safe to touch without locking now)// (this can be done without the loop but requires modifying the q to drain n)while (misseddraincount-- > 0) {    trydrain q}```i think thats right just off the top of my head though || if youre willing to allow the initial value to thread-hop its a lot simpler of course:```subscribe:    enqueue {        add observer    }    trydrainsend:    enqueue {        send to all observers    }    trydrain```(assuming youre using the queue as your only synchronization mechanism if youre also using locks you probably need to lock around the enqueues)_edit_ fixed enqueueing inside add observer instead of inside send || i think this is still an unsolved problem do we still want to put effort into this? || i was thinking about trying to solve it similar to the `groupby` solution but havent spent the time to determine if it can be made to work || ive implemented a potential fix [here]( but cant create a pr right now due to a github 500 error  a simple publish benchmark for publishsubject is 83 mops/s behaviorsubject (new) ~47mops/s behaviorsubject (master) is ~48 mops/sec || fix just ;1;0;have unit tests extends `rxjavatest` - 3this commit updates the unit tests of the following operators:* single* subjects* subscribersand for internal operators:* internaldisposable* internalfuctions* internalobservers* internalqueue* interanlschedulers* internalsubscribers* internalsubscriptions* internaloperatorcompletablerelated: #6583;
6598;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: fix mergewith not cancelling the other source if the main errors;the  mergewith  implementations   onerror  (called by the main source) cancelled the main source instead of cancelling the other source. this mistake affects all 2 x 3 overloads of the operator.;;0;3x: fix mergewith not cancelling the other source if the main errors;the `mergewith` implementations `onerror` (called by the main source) cancelled the main source instead of cancelling the other source this mistake affects all 2 x 3 overloads of the operator6597; merging 6598 ;;;;1;1;fix typo in the test name;
"6600;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: have  internal.operator.flowable  unit tests extends  rxjavatest  - 4;this commit updates the unit tests for  internal.operator.flowable;;6583.0;3x: have `internaloperatorflowable` unit tests extends `rxjavatest` - 4;this commit updates the unit tests for `internaloperatorflowable`related: #6583; merging 6600  < ;3x: have all unit tests extend a base test class;""by adding a common base class we can enable a """"global"""" timeout and a per-class log output that prevents travis ci to stop the build and also not flood the log with all methods:```javapackage ioreactivextestsupportpublic abstract class rxjavatest {  @rule  protected timeout globaltimeout  new timeout(5 timeunitminutes)  @test  @ignore  public final void announce() {  }}```this way we no longer have to rely on the random ignores scattered along the codebase this baseclass-ignore may seem unnecessarily complicated but unfortunately i was unable to create a working settinggradles test runner](https://docsgradleorg/current/dsl/orggradleapitaskstestingloggingtestlogginghtml)"";hey i see the interest having a global timeout in a base class please note that in junit4 the timeout parameter on `@test` annotation does not override the timeout rule this can be an issue when a test requires a custom timeoutalso i dont understand the `announce` test do you expect every ignored test to be transferred in the class `rxjavatest`? || no problem default 2-5 minutes should work travis kills the build if no standard output is happening for 10 minutes announce should create a log print often ignore should be reevaluated in place and deleted if no longer needed || thanks ill submit a pr || heythere are a few remaining things to close the issuefirst i did not delete ignored tests for the fusion operatorsecond i dont know what should be done to fix those non-deterministic and thread starvation tests:*     i did not update technology compatibility kit (tck) tests || dont worry about them thanks for your diligent work! ||;1;0;have `internaloperatorflowable` unit tests extends `rxjavatest` - 4this commit updates the unit tests for `internaloperatorflowable`related: #6583;"
6601;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: observableblockingsubscribe compares with wrong object;it should compare the terminated instance with the value received from the blocking queue.;;6576.0;2x: observableblockingsubscribe compares with wrong object;it should compare the terminated instance with the value received from the blocking queuefixes: #6576 related: #6577;;observableblockingsubscribe compares blockingobserverterminated with wrong object;the `observableblockingsubscribeobserve` function appears to compare the `o` variable ie the `observablesource` which shouldnt ever change with `blockingobserverterminated` this will probably never be true the intention was likely to use `v` instead of `o` in: since this appears to be somewhat redundant with `bsisdisposed()` this probably does not cause any issues;yes it should be `v  blockingobserverterminated` pr welcome ||;1;0;2x: observableblockingsubscribe compares with wrong object;
6602;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix truncation bugs in replay() and replaysubject/processor;this pr fixes several truncation bugs with the time and size-bound replay() operators and their hot class versions:;;658.0;2x: fix truncation bugs in replay() and replaysubject/processor;this pr fixes several truncation bugs with the time and size-bound replay() operators and their hot class versions:- unexpected removal of the last item just added due to becoming out-of-date at the lowest time resolution creating a hole in the linked chain and hanging the consumer [related failure]( incorrect size accounting upon removing old entries leading to more items dropped than expectedrelated: #6582;;behaviorsubject race condition;need to investigate the `behaviorsubject` as it likely has the same problem as rxnet as reported here:  that `subjects` were just re-implemented but kept the same behavior and for the `behaviorsubject` the race between returning the current value and subscribing for subsequent values appears to be wronguse case:```onnext: 1 2 3 4 5 6 7 8 9observer: subscribe between 3 & 4  should receive 3 4 5 6 7 8 9```the likely bug is that in a race it could receive `3 6 7 8 9`;there are a few missing suggestions that i didnt have in my pr which also involves behaviorsubject ill take a look at this as welledit: yes this can happen if an observer subscribes it immediately gets the current value then it is eventually added to the state object via `addobserver` which add could be delayed and values lostedit 2: how to avoid it:- one would need to block onnext while a subscription is happening which would negate the improvements - include the lastnotification in the state so a new observed value triggers a state replace similar to when an observer subscribes however one would need 2 states: active and modifying: this avoids using a lock similar to how `abstractatomicsubscription` allows complex operations in the mutating statei thought about the queue/drain suggestion in the article but i cant see it solving the value skip problem (it surely acts against reordering if there happen to be concurrent onnext calls - but we dont allow / ignore those by contract) || the queue/drain approach can be adapted to also ensure you dont miss notifications all you have to do is _queue the subscription as well_ (queue/drain is a fully general synchronization mechanism akin to using an actor)note that if you do this the initial value may not arrive immediately if the behavior subject is being touched on another thread but it can be  by introducing a second queue specific to the subscription that was initialized with the latest value while atomically subscribingso a no-deadlock no-reorder no-thread-hopping-for-initial-value subscription would look like:```initialvaluesent  falsemisseddraincount  0create drain queue q for subscriptionsync(this) {    add observer to {        enqueue new value onto q        sync(q) {            // other threads must not push initial value            if (!initialvaluesent) {                misseddraincount++            }        }        trydrain q    }    enqueue current value onto q}// forward value to caller before returning (and perhaps some later values too)trydrain q// --- allow other threads to forward future values ---sync(q) {    initialvaluesent  true}// in case observers were enqueueing while we set the flag// (pretty sure reading misseddraincount is safe to touch without locking now)// (this can be done without the loop but requires modifying the q to drain n)while (misseddraincount-- > 0) {    trydrain q}```i think thats right just off the top of my head though || if youre willing to allow the initial value to thread-hop its a lot simpler of course:```subscribe:    enqueue {        add observer    }    trydrainsend:    enqueue {        send to all observers    }    trydrain```(assuming youre using the queue as your only synchronization mechanism if youre also using locks you probably need to lock around the enqueues)_edit_ fixed enqueueing inside add observer instead of inside send || i think this is still an unsolved problem do we still want to put effort into this? || i was thinking about trying to solve it similar to the `groupby` solution but havent spent the time to determine if it can be made to work || ive implemented a potential fix [here]( but cant create a pr right now due to a github 500 error  a simple publish benchmark for publishsubject is 83 mops/s behaviorsubject (new) ~47mops/s behaviorsubject (master) is ~48 mops/sec || fix just ;1;0;2x: fix truncation bugs in replay() and replaysubject/processor;
6604;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: have unit tests extends  rxjavatest  - 5;this commit updates the unit tests of the following operators:;;658.0;3x: have unit tests extends `rxjavatest` - 5;this commit updates the unit tests of the following operators:* internaloperatorsmaybe* internaloperatormixed* internaloperatorsinglerelated: #6583;;behaviorsubject race condition;need to investigate the `behaviorsubject` as it likely has the same problem as rxnet as reported here:  that `subjects` were just re-implemented but kept the same behavior and for the `behaviorsubject` the race between returning the current value and subscribing for subsequent values appears to be wronguse case:```onnext: 1 2 3 4 5 6 7 8 9observer: subscribe between 3 & 4  should receive 3 4 5 6 7 8 9```the likely bug is that in a race it could receive `3 6 7 8 9`;there are a few missing suggestions that i didnt have in my pr which also involves behaviorsubject ill take a look at this as welledit: yes this can happen if an observer subscribes it immediately gets the current value then it is eventually added to the state object via `addobserver` which add could be delayed and values lostedit 2: how to avoid it:- one would need to block onnext while a subscription is happening which would negate the improvements - include the lastnotification in the state so a new observed value triggers a state replace similar to when an observer subscribes however one would need 2 states: active and modifying: this avoids using a lock similar to how `abstractatomicsubscription` allows complex operations in the mutating statei thought about the queue/drain suggestion in the article but i cant see it solving the value skip problem (it surely acts against reordering if there happen to be concurrent onnext calls - but we dont allow / ignore those by contract) || the queue/drain approach can be adapted to also ensure you dont miss notifications all you have to do is _queue the subscription as well_ (queue/drain is a fully general synchronization mechanism akin to using an actor)note that if you do this the initial value may not arrive immediately if the behavior subject is being touched on another thread but it can be  by introducing a second queue specific to the subscription that was initialized with the latest value while atomically subscribingso a no-deadlock no-reorder no-thread-hopping-for-initial-value subscription would look like:```initialvaluesent  falsemisseddraincount  0create drain queue q for subscriptionsync(this) {    add observer to {        enqueue new value onto q        sync(q) {            // other threads must not push initial value            if (!initialvaluesent) {                misseddraincount++            }        }        trydrain q    }    enqueue current value onto q}// forward value to caller before returning (and perhaps some later values too)trydrain q// --- allow other threads to forward future values ---sync(q) {    initialvaluesent  true}// in case observers were enqueueing while we set the flag// (pretty sure reading misseddraincount is safe to touch without locking now)// (this can be done without the loop but requires modifying the q to drain n)while (misseddraincount-- > 0) {    trydrain q}```i think thats right just off the top of my head though || if youre willing to allow the initial value to thread-hop its a lot simpler of course:```subscribe:    enqueue {        add observer    }    trydrainsend:    enqueue {        send to all observers    }    trydrain```(assuming youre using the queue as your only synchronization mechanism if youre also using locks you probably need to lock around the enqueues)_edit_ fixed enqueueing inside add observer instead of inside send || i think this is still an unsolved problem do we still want to put effort into this? || i was thinking about trying to solve it similar to the `groupby` solution but havent spent the time to determine if it can be made to work || ive implemented a potential fix [here]( but cant create a pr right now due to a github 500 error  a simple publish benchmark for publishsubject is 83 mops/s behaviorsubject (new) ~47mops/s behaviorsubject (master) is ~48 mops/sec || fix just ;1;0;3x: have unit tests extends `rxjavatest` - 5this commit updates the unit tests of the following operators:* internaloperatorsmaybe* internaloperatormixed* internaloperatorsinglerelated: #6583;
6607;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: have  internal.operator.observable  unit tests extends  rxjavatest  - 6;this commit updates the unit tests for  internal.operator.observable;;658.0;3x: have `internaloperatorobservable` unit tests extends `rxjavatest` - 6;this commit updates the unit tests for `internaloperatorobservable`related: #6583; merging 6607 ;behaviorsubject race condition;need to investigate the `behaviorsubject` as it likely has the same problem as rxnet as reported here:  that `subjects` were just re-implemented but kept the same behavior and for the `behaviorsubject` the race between returning the current value and subscribing for subsequent values appears to be wronguse case:```onnext: 1 2 3 4 5 6 7 8 9observer: subscribe between 3 & 4  should receive 3 4 5 6 7 8 9```the likely bug is that in a race it could receive `3 6 7 8 9`;there are a few missing suggestions that i didnt have in my pr which also involves behaviorsubject ill take a look at this as welledit: yes this can happen if an observer subscribes it immediately gets the current value then it is eventually added to the state object via `addobserver` which add could be delayed and values lostedit 2: how to avoid it:- one would need to block onnext while a subscription is happening which would negate the improvements - include the lastnotification in the state so a new observed value triggers a state replace similar to when an observer subscribes however one would need 2 states: active and modifying: this avoids using a lock similar to how `abstractatomicsubscription` allows complex operations in the mutating statei thought about the queue/drain suggestion in the article but i cant see it solving the value skip problem (it surely acts against reordering if there happen to be concurrent onnext calls - but we dont allow / ignore those by contract) || the queue/drain approach can be adapted to also ensure you dont miss notifications all you have to do is _queue the subscription as well_ (queue/drain is a fully general synchronization mechanism akin to using an actor)note that if you do this the initial value may not arrive immediately if the behavior subject is being touched on another thread but it can be  by introducing a second queue specific to the subscription that was initialized with the latest value while atomically subscribingso a no-deadlock no-reorder no-thread-hopping-for-initial-value subscription would look like:```initialvaluesent  falsemisseddraincount  0create drain queue q for subscriptionsync(this) {    add observer to {        enqueue new value onto q        sync(q) {            // other threads must not push initial value            if (!initialvaluesent) {                misseddraincount++            }        }        trydrain q    }    enqueue current value onto q}// forward value to caller before returning (and perhaps some later values too)trydrain q// --- allow other threads to forward future values ---sync(q) {    initialvaluesent  true}// in case observers were enqueueing while we set the flag// (pretty sure reading misseddraincount is safe to touch without locking now)// (this can be done without the loop but requires modifying the q to drain n)while (misseddraincount-- > 0) {    trydrain q}```i think thats right just off the top of my head though || if youre willing to allow the initial value to thread-hop its a lot simpler of course:```subscribe:    enqueue {        add observer    }    trydrainsend:    enqueue {        send to all observers    }    trydrain```(assuming youre using the queue as your only synchronization mechanism if youre also using locks you probably need to lock around the enqueues)_edit_ fixed enqueueing inside add observer instead of inside send || i think this is still an unsolved problem do we still want to put effort into this? || i was thinking about trying to solve it similar to the `groupby` solution but havent spent the time to determine if it can be made to work || ive implemented a potential fix [here]( but cant create a pr right now due to a github 500 error  a simple publish benchmark for publishsubject is 83 mops/s behaviorsubject (new) ~47mops/s behaviorsubject (master) is ~48 mops/sec || fix just ;1;0;3x: have `internaloperatorobservable` unit tests extends `rxjavatest` - 6this commit updates the unit tests for `internaloperatorobservable`related: #6583;
"6609;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix refcount not resetting when termination triggers cross-cancel;this pr fixes both  refcount  implementation to properly reset the source when the source terminates multiple consumers.;;660.0;3x: fix refcount not resetting when termination triggers cross-cancel;this pr fixes both `refcount` implementation to properly reset the source when the source terminates multiple consumersin the original when the source terminated multiple sources the first termination handler cleared the connection but since the `--subscribercount` wasnt zero the source was not reset if this termination triggered a cancel on the second consumer that path would not get the source reset either due to losing the connection object unfortunately one cant just take the first termination handler and reset there immediately either because that could disrupt the termination of the rest of the consumers it has to wait for the source to terminate all consumers or have the consumers cancel allthis affects 2x and will be backported in a separate pr6608; merging 6609 ;hopefully  missing notifications if part of the subscription is del;""ayedfix suggestion to issue #658basically it is a """"spin-lock"""" between onnext and the subscription it has the additional effect of locking out concurrent subscriptions but these would most likely clash on the state-swap anyway"";#594  added test case to illustrate the underlying issue if i comment out the new mutating part it will fail typically with values (3 7 8 9) ! (3 4 5 6 7 8 9) || #595 ill have to spend more time on this one later to think through || okay ||;1;0;3x: fix refcount not resetting when termination triggers cross-cancel;"
6612;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: fix many operators swallowing undeliverable exceptions;fix many operators to emit the collected exception in case of a cancel/dispose call to the plugin error handler (i.e.  becoming undeliverable excptions).;;658.0;3x: fix many operators swallowing undeliverable exceptions;fix many operators to emit the collected exception in case of a cancel/dispose call to the plugin error handler (ie becoming undeliverable excptions)in addition the terminal event/error delivery has been unified in many other operators so that the terminal-indicator exception is never leakedthere will be a separate pr about cleaning up the `addthrowable` usage cases (#6611)fixes: #6587; merging 6612 ;behaviorsubject race condition;need to investigate the `behaviorsubject` as it likely has the same problem as rxnet as reported here:  that `subjects` were just re-implemented but kept the same behavior and for the `behaviorsubject` the race between returning the current value and subscribing for subsequent values appears to be wronguse case:```onnext: 1 2 3 4 5 6 7 8 9observer: subscribe between 3 & 4  should receive 3 4 5 6 7 8 9```the likely bug is that in a race it could receive `3 6 7 8 9`;there are a few missing suggestions that i didnt have in my pr which also involves behaviorsubject ill take a look at this as welledit: yes this can happen if an observer subscribes it immediately gets the current value then it is eventually added to the state object via `addobserver` which add could be delayed and values lostedit 2: how to avoid it:- one would need to block onnext while a subscription is happening which would negate the improvements - include the lastnotification in the state so a new observed value triggers a state replace similar to when an observer subscribes however one would need 2 states: active and modifying: this avoids using a lock similar to how `abstractatomicsubscription` allows complex operations in the mutating statei thought about the queue/drain suggestion in the article but i cant see it solving the value skip problem (it surely acts against reordering if there happen to be concurrent onnext calls - but we dont allow / ignore those by contract) || the queue/drain approach can be adapted to also ensure you dont miss notifications all you have to do is _queue the subscription as well_ (queue/drain is a fully general synchronization mechanism akin to using an actor)note that if you do this the initial value may not arrive immediately if the behavior subject is being touched on another thread but it can be  by introducing a second queue specific to the subscription that was initialized with the latest value while atomically subscribingso a no-deadlock no-reorder no-thread-hopping-for-initial-value subscription would look like:```initialvaluesent  falsemisseddraincount  0create drain queue q for subscriptionsync(this) {    add observer to {        enqueue new value onto q        sync(q) {            // other threads must not push initial value            if (!initialvaluesent) {                misseddraincount++            }        }        trydrain q    }    enqueue current value onto q}// forward value to caller before returning (and perhaps some later values too)trydrain q// --- allow other threads to forward future values ---sync(q) {    initialvaluesent  true}// in case observers were enqueueing while we set the flag// (pretty sure reading misseddraincount is safe to touch without locking now)// (this can be done without the loop but requires modifying the q to drain n)while (misseddraincount-- > 0) {    trydrain q}```i think thats right just off the top of my head though || if youre willing to allow the initial value to thread-hop its a lot simpler of course:```subscribe:    enqueue {        add observer    }    trydrainsend:    enqueue {        send to all observers    }    trydrain```(assuming youre using the queue as your only synchronization mechanism if youre also using locks you probably need to lock around the enqueues)_edit_ fixed enqueueing inside add observer instead of inside send || i think this is still an unsolved problem do we still want to put effort into this? || i was thinking about trying to solve it similar to the `groupby` solution but havent spent the time to determine if it can be made to work || ive implemented a potential fix [here]( but cant create a pr right now due to a github 500 error  a simple publish benchmark for publishsubject is 83 mops/s behaviorsubject (new) ~47mops/s behaviorsubject (master) is ~48 mops/sec || fix just ;1;0;add completablemerge variants too;
6612;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: fix many operators swallowing undeliverable exceptions;fix many operators to emit the collected exception in case of a cancel/dispose call to the plugin error handler (i.e.  becoming undeliverable excptions).;;6611.0;3x: fix many operators swallowing undeliverable exceptions;fix many operators to emit the collected exception in case of a cancel/dispose call to the plugin error handler (ie becoming undeliverable excptions)in addition the terminal event/error delivery has been unified in many other operators so that the terminal-indicator exception is never leakedthere will be a separate pr about cleaning up the `addthrowable` usage cases (#6611)fixes: #6587; merging 6612 ;3x: revise atomicthrowableaddthrowable usage;currently many (if not all?) usage of `addthrowable` is as follows:```javaif (errorsaddthrowable(ex)) {   // do something with the error case} else {    rxjavapluginsonerror(ex)}```the plugin error call could be inlined into the method call and renamed to `tryaddthrowable` to ensure all usage places are updated correctly;hey do you need help doing this?  || each usage location has to be reevaluated and there are thousands of those it would be easier if i do them ||;1;0;add completablemerge variants too;
6616;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix switchmap incorrect sync-fusion & error management;this pr fixes the incorrect request call inside  switchmap  when working with sync-fused sources.;;0;3x: fix switchmap incorrect sync-fusion & error management;this pr fixes the incorrect request call inside `switchmap` when working with sync-fused sourcesfixes: #6615; merging 6616 ;;;;1;1;3x: fix switchmap incorrect sync-fusion & error management;
6618;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix switchmap incorrect sync-fusion & error management;this pr fixes the incorrect request call inside  switchmap  when working with sync-fused sources.;;0;2x: fix switchmap incorrect sync-fusion & error management;this pr fixes the incorrect request call inside `switchmap` when working with sync-fused sourcesfixes: #6615; merging 6618 ;;;;1;1;2x: fix switchmap incorrect sync-fusion & error management;
6620;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: elementat  first - constrain upstream requests;as discussed in #6569 this pr constrains upstream requests for the  elementat  and  first  overloads. other operators will be covered in other prs.;;6569.0;3x: elementat first - constrain upstream requests;as discussed in #6569 this pr constrains upstream requests for the `elementat` and `first` overloads other operators will be covered in other prs; merging 6620 ;3x: unbounded requests from first take and others;in 2x we talked about some surprising request patterns from operators like `first` `take` and others where despite only one or a limited number of items being needed longmax_value was requested of upstream and then cancelled after the desired number arrived (#5077) i believe this was a micro-optimization performance boost that improved the scrabble benchmarks any change to the pattern was rejected based on it being a breaking api changein essence id like us not to be opinionated about the effect on the upstream of over-requesting (particularly over a network boundary) by over-requesting we are fundamentally *losing information that can be useful to optimizing upstream processing* an example that springs to mind is that requesting a large number may be translated to an api call to a remote upstream that does a full sort (o(nlogn)) whereas requesting only one can be implemented upstream with a max scan (o(n)) this of course assumes one and only request to create the stream so is not a run-of-the-mill streaming case id also suggest we are not opinionated about the ability of upstream to respond to cancellation (upstream may be performing cpu intensive actions in third-party libraries that arent cancellable)i think the effect on the benchmarks of reverting to naturally bounded requests where obvious (`first` `take` etc) will be very small can we revisit this one for 3x?;okay lets make limit the default and change first/single what about the lambda subscribe? || thanks @akarnokd so im suggesting we constrain upstream requests for:* `elementat`* `elementatorerror`* `first` (calls `elementat`)* `firstorerror` (calls `elementat`)* `take`* `single(default)`* `singleorerror`* `blockingsingle(default)` calls `single(default)`* `blockingsingle` (calls `singleorerror`)`limit` can then be an alias for `take`>what about the lambda subscribe?youve lost me what are you referring to? || there is no reason to have `limit` separately then[lambda subscribe]( requests max value || >lambda subscribe requests max valueyes that seems reasonable to me why would it be otherwise?  || > there is no reason to have limit separately thenok by me || you were worrying about overrequesting over the network boundary a straight `subscribe` would do that too for your case im fine with it as is || >you were worrying about overrequesting over the network boundary a straight subscribe would do that too for your case im fine with it as isim fine with it also || would you like a pr for these changes? you are welcome to do it yourself if you want to but i can help if useful || im still waiting for #6589 but you can go ahead and create a pr || im happy to wait for #6589 before starting the pr ||;1;0;update javadoc on backpressure for elementat and first;
6621;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: refactor to io.reactivex.rxjava3.**;this pr refactors the package structure to match the group id:  io.reactivex.rxjava3 . in addition  the base classes and interfaces now live in  io.reactivex.rxjava3.core .;;0;3x: refactor to ioreactivexrxjava3**;this pr refactors the package structure to match the group id: `ioreactivexrxjava3` in addition the base classes and interfaces now live in `ioreactivexrxjava3core`in addition the reactive streams dependency was bumped to 103-rc1 to verify the tck changes;   no coverage uploaded for pull request base (`3x@f8841c7`) [click here to learn what that means]( `n/a`(                                  3x    #6621   +/-   ##  coverage       ?   9819%             complexity     ?     6191             files          ?      678  ?    44792     ?     6173             hits           ?    43982             misses         ?      278             partials       ?      532```------[continue to review full report at codecov]( **legend** - [click here to learn more]( `  absolute <relative> (impact)` `  not affected` `?  missing data`> ( last update [f8841c75adb308]( read the [comment docs]( || you can compare lines and branch counts:              coverage diff              @@##                3x    #6620      +/-   ##+ coverage     9813%   9817%   +003%     - complexity     6187     6188       +1       files           678      678                lines         44792    44792                branches       6173     6173              + hits          43956    43973      +17     + misses          290      281       -9     + partials        546      538       -8``` || go ahead and merge! ||;;;;1;1;fix package location in text;
"6626;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: fix blockingiterable not unblocking when force-disposed;when the iterator was cast to  disposable  and disposed  the subsequent  hasnext  would block indefinitely. that interface is not intended to be part of the public api and  iterator  in general does not support any form of official cancellation (unlike stream). this pr makes sure that if that dispose is called  it unblocks the iterator.;;6625.0;3x: fix blockingiterable not unblocking when force-disposed;when the iterator was cast to `disposable` and disposed the subsequent `hasnext` would block indefinitely that interface is not intended to be part of the public api and `iterator` in general does not support any form of official cancellation (unlike stream) this pr makes sure that if that dispose is called it unblocks the iteratora separate pr will be posted for 2xrelated #6625;;2x calling hasnext() on a disposed blocking iterator hangs forever;""calling `hasnext()` on a a blocking iterator never returns if the iterator has been disposed tested on 2211to reproduce:```iterator<integer> iterator  flowablefromarray(1 2 3)delay(1 timeunitseconds)blockingiterable()iterator()systemoutprintln(""""start"""")((disposable)iterator)dispose()iteratorhasnext() //hangs forever```"";""indeed if you """"hack"""" into that iterator it wont work properly as it implementing disposable is not part of the public intended api ill see what i can do about it in 2x for 3x it probably needs some redesign to work with try-with-resources for example || closing via #6626 & #6627 || "";1;0;missed a volatile;"
"6627;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix blockingiterable hang when force-disposed;when the iterator was cast to  disposable  and disposed  the subsequent  hasnext  would block indefinitely. that interface is not intended to be part of the public api and  iterator  in general does not support any form of official cancellation (unlike stream). this pr makes sure that if that dispose is called  it unblocks the iterator.;;6625.0;2x: fix blockingiterable hang when force-disposed;when the iterator was cast to `disposable` and disposed the subsequent `hasnext` would block indefinitely that interface is not intended to be part of the public api and `iterator` in general does not support any form of official cancellation (unlike stream) this pr makes sure that if that dispose is called it unblocks the iterator6625;;2x calling hasnext() on a disposed blocking iterator hangs forever;""calling `hasnext()` on a a blocking iterator never returns if the iterator has been disposed tested on 2211to reproduce:```iterator<integer> iterator  flowablefromarray(1 2 3)delay(1 timeunitseconds)blockingiterable()iterator()systemoutprintln(""""start"""")((disposable)iterator)dispose()iteratorhasnext() //hangs forever```"";""indeed if you """"hack"""" into that iterator it wont work properly as it implementing disposable is not part of the public intended api ill see what i can do about it in 2x for 3x it probably needs some redesign to work with try-with-resources for example || closing via #6626 & #6627 || "";1;0;2x: fix blockingiterable hang when force-disposed;"
6628;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: better leak detection via gc/sleep loop;the  publishnoleak  and  replaynoleak  tests tend to fail because the gc/sleep time is not enough sometimes to cleanup memory. this pr adds a main test helper that loops at most a number of times and quits when the gc has apparently done its job.;;0;3x: better leak detection via gc/sleep loop;the `publishnoleak` and `replaynoleak` tests tend to fail because the gc/sleep time is not enough sometimes to cleanup memory this pr adds a main test helper that loops at most a number of times and quits when the gc has apparently done its job;;;;;1;1;remove the unnecessary sleeps;
6629;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix refcount() not resetting when cross-canceled;this pr fixes the issue with  refcount  not resetting the connection when the termination triggers cross-cancellation over it.;;6608.0;2x: fix refcount() not resetting when cross-canceled;this pr fixes the issue with `refcount` not resetting the connection when the termination triggers cross-cancellation over it6608the fix is more involved than #6609 because how 2x uses two `publish()` implementation internally due to bug6505 the old/classic implementation does not fail #6608 but the newer implementation fails #6608 if the fix is applied unconditionally the old/classic implementation fails an older unit test verifying an error allows reconnection therefore the pr checks and applies the new code path only if `refcount` isnt talking to the classic publish implementationas a reminder #6609 for 3x has a redesigned `connectable` with a much more clearer reset semantics and thus the restructuring of the termination handling had no trouble passing the aforementioned error-allows-reconnect unit test; merging 6629 ;replaysubject and buffer with debounce not emitting values after first subscription;the issue described below started with version 2210 and continues with 2211 it works with 227 through 229i have a test where a set a `replaysubject` like so:```locationpublisher  replaysubjectcreate()locationpublisheronnext(mocklocation)locationpublisheroncomplete()locationobservable  locationpublishershare()```then i subscribe twice to the observable (im simplifying the test case just to demonstrate the bug):```        locationobservable            buffer(locationobservabledebounce(5 timeunitseconds))            test()            assertvaluecount(2)        locationobservable            buffer(locationobservabledebounce(5 timeunitseconds))            test()            assertvaluecount(2)```when i run the above test it fails on the second test subscription on rxjava 2210 or 2211:> javalangassertionerror: value counts differ expected: 2 but was: 1 (latch  0 values  1 errors  0 completions  1)expected :2 actual   :1 (latch  0 values  1 errors  0 completions  1);hi and thanks for reporting this is a bug in `refcount` affecting both 2x and 3xwhat happens is that when the source subject completes it completes `buffer` which then cancels the boundary source which makes the `refcount` think it still has 1 subscriber active and doesnt reset the sourcethe operator is a bit delicate so i have to work out the correct state transitions and not break tests || hi i cant seem to reproduce this with 2211 could you check if the following test passes for you on 2211?```java@testpublic void upstreamterminationtriggersanothercancel() throws exception {    replaysubject<integer> rs  replaysubjectcreate()    rsonnext(1)    rsoncomplete()    observable<integer> shared  rsshare()    shared    buffer(shareddebounce(5 timeunitseconds))    test()    assertvaluecount(2)    shared    buffer(shareddebounce(5 timeunitseconds))    test()    assertvaluecount(2)}``` || yes i just created a new project with android studio and added only rxjava as a new dependency and your test aboveit fails on versions 2210 and 2211 put passes on 229 ||;1;0;undo test timeout comment;
"6632;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: upgrade gradle & dependency versions;this pr upgrades to:;;0;3x: upgrade gradle & dependency versions;""this pr upgrades to:- gradle 56- testng 700- mockito 300- jmh 121- jmh plugin 050-rc-2 (required by gradle 55+)- license 0150- jacoco 084- guava 28in addition the `osgi` plugin has been deprecated in gradle 5 and has been removed in gradle 6 therefore a separate plugin called `bnd` is required to produce the necessary jar properties(also the mockitojunitrunner has been moved to a new location hence the package change)this gradle version should support working on a java 11 runtime when executing `gradlew build`note that this may require further """"live"""" testing as the auto-release of snapshots as well as auto-release cant be properly tested offline ""; merging 6632  < ;;;;1;1;add checkstyle version string to the top fix jmh class;"
6635;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: remove vararg overloads for combinelatest in observable + flowable;started removing the vararg function from #6634;;663.0;3x: remove vararg overloads for combinelatest in observable + flowable;started removing the vararg function from #6634;hmm after looking at the tests the varag variant for `combinelatestdelayerror` might be useful since there are no 2-x overloads available what do you think? || let me guess intellij refactor? || the varargs is a convenience over the array variant so `combinelatestdelayerror`s can go ||  merging 6635  < ;bocollect and bochunkify;refactored bocollect and bochunkify out of pr #636mentioned in issue #634;#597 there is a compilation issue with master in file operationtakelast due to the removal of singleassignmentsubscription || #598 this looks good  though we have discovered that java 8 stream has a collect interface and were considering whether we should change to match it on both the `observable` and `blockingobservable` versions instead of exactly matching rxnet in this case || /cc @headinthebox for api review || take a look at the `collect` operator here:  || closing this out as it will need to be recreated and discussed again@akarnokd  and @headinthebox please coordinate ||;1;0;3x: remove vararg overloads for combinelatest in observable + flowablefix tests;
6637;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: avoid using system.getproperties() due to security restrictions;change the code in the  schedulerpoolfactory  to use  system.getproperty  directly. also fix property names to  rx3.  as now both v2 and v3 could run together.;;663.0;3x: avoid using systemgetproperties() due to security restrictions;change the code in the `schedulerpoolfactory` to use `systemgetproperty` directly also fix property names to `rx3` as now both v2 and v3 could run together6636; merging 6637 ;bocollect and bochunkify;refactored bocollect and bochunkify out of pr #636mentioned in issue #634;#597 there is a compilation issue with master in file operationtakelast due to the removal of singleassignmentsubscription || #598 this looks good  though we have discovered that java 8 stream has a collect interface and were considering whether we should change to match it on both the `observable` and `blockingobservable` versions instead of exactly matching rxnet in this case || /cc @headinthebox for api review || take a look at the `collect` operator here:  || closing this out as it will need to be recreated and discussed again@akarnokd  and @headinthebox please coordinate ||;1;0;3x: avoid using systemgetproperties() due to security restrictions;
6638;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: rename zipiterable  remove zip(o(o))  adjust concatmapx arg order;- rename  zipiterable  to  zip;;0;3x: rename zipiterable remove zip(o(o)) adjust concatmapx arg order;- rename `zipiterable` to `zip`- remove `zip(observablesource<observablesource<t>>)` and `zip(publisher<publisher<t>>)`- change the order of the `tilltheend` argument in `concatmapdelayerror` and `concatmapeagerdelayerror` to be consistent with other operators taking a `boolean` parameter before `prefetch`/`maxconcurrency`related: #6610; merging 6638 ;;;;1;1;3x: rename zipiterable remove zip(o(o)) adjust concatmapx arg order;
"6639;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: cleanup addthrowable   2.x  and null-value error messages;this pr renames the internal  addthrowable  to  tryaddthrowable  and introduces the  tryaddthrowableorreport  to perform the common reporting to the global error handler. usage places have been re-evaluated and fixed if necessary.;;0;""3x: cleanup addthrowable """"2x"""" and null-value error messages"";this pr renames the internal `addthrowable` to `tryaddthrowable` and introduces the `tryaddthrowableorreport` to perform the common reporting to the global error handler usage places have been re-evaluated and  if necessaryin addition `null` exceptions have been made more uniform6611; merging 6639 ;;;;1;1;""3x: cleanup addthrowable """"2x"""" and null-value error messages"";"
6640;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: rename combinelatest methods that take an array to combinelatestarray;renames the methods as suggested;;0;3x: rename combinelatest methods that take an array to combinelatestarray;renames the methods as suggested; merging 6640 ;;;;1;1;3x: rename combinelatest methods that take an array to combinelatestarray;
6648;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix takelast(time) last events time window calculation.;the logic inside the  observable.takelast(time)  was not using a fixed timestamp to compare against but one that could change between calls  resulting in items wrongly skipped from the accumulated buffer. the pr makes this timestamp limit fixed outside the drain loop.;;0;3x: fix takelast(time) last events time window calculation;the logic inside the `observabletakelast(time)` was not using a  timestamp to compare against but one that could change between calls resulting in items wrongly skipped from the accumulated buffer the pr makes this timestamp limit fixed outside the drain loopthe `flowable` variant did not have the issue but both received the unit test verifying the correct behaviorthe same fix for 2x will be posted separatelyfixes: #6647;   no coverage uploaded for pull request base (`3x@9a36930`) [click here to learn what that means]( ` ;;;;1;1;3x: fix takelast(time) last events time window calculation;
6650;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: constrain upstream requests from take  remove limit operator;as per discussion in #6569  this pr constrains upstream requests from the  take  operator and removes the  limit  operator.;;6569.0;3x: constrain upstream requests from take remove limit operator;as per discussion in #6569 this pr constrains upstream requests from the `take` operator and removes the `limit` operatorive also added a couple of unit tests for coverage of `elementat` that i didnt include in #6620; merging 6650 ;3x: unbounded requests from first take and others;in 2x we talked about some surprising request patterns from operators like `first` `take` and others where despite only one or a limited number of items being needed longmax_value was requested of upstream and then cancelled after the desired number arrived (#5077) i believe this was a micro-optimization performance boost that improved the scrabble benchmarks any change to the pattern was rejected based on it being a breaking api changein essence id like us not to be opinionated about the effect on the upstream of over-requesting (particularly over a network boundary) by over-requesting we are fundamentally *losing information that can be useful to optimizing upstream processing* an example that springs to mind is that requesting a large number may be translated to an api call to a remote upstream that does a full sort (o(nlogn)) whereas requesting only one can be implemented upstream with a max scan (o(n)) this of course assumes one and only request to create the stream so is not a run-of-the-mill streaming case id also suggest we are not opinionated about the ability of upstream to respond to cancellation (upstream may be performing cpu intensive actions in third-party libraries that arent cancellable)i think the effect on the benchmarks of reverting to naturally bounded requests where obvious (`first` `take` etc) will be very small can we revisit this one for 3x?;okay lets make limit the default and change first/single what about the lambda subscribe? || thanks @akarnokd so im suggesting we constrain upstream requests for:* `elementat`* `elementatorerror`* `first` (calls `elementat`)* `firstorerror` (calls `elementat`)* `take`* `single(default)`* `singleorerror`* `blockingsingle(default)` calls `single(default)`* `blockingsingle` (calls `singleorerror`)`limit` can then be an alias for `take`>what about the lambda subscribe?youve lost me what are you referring to? || there is no reason to have `limit` separately then[lambda subscribe]( requests max value || >lambda subscribe requests max valueyes that seems reasonable to me why would it be otherwise?  || > there is no reason to have limit separately thenok by me || you were worrying about overrequesting over the network boundary a straight `subscribe` would do that too for your case im fine with it as is || >you were worrying about overrequesting over the network boundary a straight subscribe would do that too for your case im fine with it as isim fine with it also || would you like a pr for these changes? you are welcome to do it yourself if you want to but i can help if useful || im still waiting for #6589 but you can go ahead and create a pr || im happy to wait for #6589 before starting the pr ||;1;0;3x: constrain upstream requests from take (#6569);
"6652;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: fix size+time bound window not creating windows properly;there was a logic error in the size+time bound  window  operator for when to close a window if timers are not restarted when the size-bound is hit.;;665.0;3x: fix size+time bound window not creating windows properly;there was a logic error in the size+time bound `window` operator for when to close a window if timers are not restarted when the size-bound is hitdue to this bug two tests were not receiving and thus accounting for empty windows that are happening when the size-bound is hit followed by the periodic time-bound hit2x will be  in a separate pr6651;   no coverage uploaded for pull request base (`3x@9a36930`) [click here to learn what that means]( ` ;groupbyuntil with maxgroups;split from #641purpose: limit the active groups to a certain number if new group is opened the oldest group is closed;""#600 why not remove the one that got a notification last? not sure if this specific behavior particularly useful || i dont know i think it matches rxnets signature but i cant really look into `concurrentdictionary` it is possible the capacity is just for the initial capacity of the map and has nothing to do with limiting the groups || @akarnokd since we already have `groupbyuntil` in `observable` what is the reason for adding more overloads with `maxgroups`? where is this use case and signature coming from?the stated reason is:> purpose: limit the active groups to a certain number if new group is opened the oldest group is closedhowever that is an arbitrary decision on how to """"clear out the cache"""" and one that would need different eviction policies if this is going to be pursued it needs something more thorough than just a `maxgroups` as for `concurrentdictionary` limiting groups there is no evidence to that from looking at the api it seems it will keep growing at least to the max integer size for number of keys also `concurrentdictionary` is a implementation detail not part of the `groupbyuntil` contractis it correct that youre trying to create a `groupbyuntil` variant that provides a cache eviction policy? if so why and how should it behave if the `key` shows up again?  || closing based on discussion above > i guess this pr can be ignored || "";1;0;3x: fix size+time bound window not creating windows properly;"
6653;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix takelast(time) last events time window calculation.;the logic inside the  observable.takelast(time)  was not using a fixed timestamp to compare against but one that could change between calls  resulting in items wrongly skipped from the accumulated buffer. the pr makes this timestamp limit fixed outside the drain loop.;;0;2x: fix takelast(time) last events time window calculation;the logic inside the `observabletakelast(time)` was not using a  timestamp to compare against but one that could change between calls resulting in items wrongly skipped from the accumulated buffer the pr makes this timestamp limit fixed outside the drain loopthe `flowable` variant did not have the issue but both received the unit test verifying the correct behaviorfixes: #6647; merging 6653 ;;;;1;1;3x: fix takelast(time) last events time window calculation;
"6657;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix size+time bound window not creating windows properly;there was a logic error in the size+time bound  window  operator for when to close a window if timers are not restarted when the size-bound is hit.;;665.0;2x: fix size+time bound window not creating windows properly;there was a logic error in the size+time bound `window` operator for when to close a window if timers are not restarted when the size-bound is hitdue to this bug two tests were not receiving and thus accounting for empty windows that are happening when the size-bound is hit followed by the periodic time-bound hit6651; merging 6657  < ;groupbyuntil with maxgroups;split from #641purpose: limit the active groups to a certain number if new group is opened the oldest group is closed;""#600 why not remove the one that got a notification last? not sure if this specific behavior particularly useful || i dont know i think it matches rxnets signature but i cant really look into `concurrentdictionary` it is possible the capacity is just for the initial capacity of the map and has nothing to do with limiting the groups || @akarnokd since we already have `groupbyuntil` in `observable` what is the reason for adding more overloads with `maxgroups`? where is this use case and signature coming from?the stated reason is:> purpose: limit the active groups to a certain number if new group is opened the oldest group is closedhowever that is an arbitrary decision on how to """"clear out the cache"""" and one that would need different eviction policies if this is going to be pursued it needs something more thorough than just a `maxgroups` as for `concurrentdictionary` limiting groups there is no evidence to that from looking at the api it seems it will keep growing at least to the max integer size for number of keys also `concurrentdictionary` is a implementation detail not part of the `groupbyuntil` contractis it correct that youre trying to create a `groupbyuntil` variant that provides a cache eviction policy? if so why and how should it behave if the `key` shows up again?  || closing based on discussion above > i guess this pr can be ignored || "";1;0;2x: fix size+time bound window not creating windows properly;"
6662;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: multiple empty line detection to ignore whitespace;update the empty newline detection to ignore whitespace in otherwise empty subsequent lines.;;0;3x: multiple empty line detection to ignore whitespace;update the empty newline detection to ignore whitespace in otherwise empty subsequent lines; merging 6662 ;;;;1;1;remove the separate file;
"6664;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix groupby group emission in some cases;this pr fixes two issues:;;6663.0;3x: fix groupby group emission in some cases;this pr fixes two issues:- when the `observablegroupby` operator would abandon a newly created group before the groups only item was emitted causing dataloss- when the `groupby`s value selector failed for a new group thus the new group would never be emitted and report the failureit should fix the first test failure of #6663 but may not be the cause for the second; merging 6664  < ;3x: observablegroupby test failures;""two tests fail randomly on ci:this is probably failing because some non-atomicity bug in determining a group has been abandoned?```ioreactivexrxjava3internaloperatorsobservableobservablegroupbytest > firstgroupscompleteandparentslowtothenemitfinalgroupswhichthensubscribesonanddelaysandthencompletes failed    javalangassertionerror: expected:<6> but was:<5>        at orgjunitassertfail(assertjava:88)        at orgjunitassertfailnotequals(assertjava:834)        at orgjunitassertassertequals(assertjava:645)        at orgjunitassertassertequals(assertjava:631)        at ioreactivexrxjava3internaloperatorsobservableobservablegroupbytestfirstgroupscompleteandparentslowtothenemitfinalgroupswhichthensubscribesonanddelaysandthencompletes(observablegroupbytestjava:765)```and this fails because dispose still doesnt get propagated to upstream```ioreactivexrxjava3internaloperatorsobservableobservablegroupbytest > canceloverflatmaprace()      at assertfalse(""""round """" + i pshasobservers())```i cant make these tests fail on my machine at all so the groupby logic has to be rechecked the `flowable` variants have not failed (yet)"";ive run the changes with the build matrix and no failures popped up closing for now ||;1;0;test non-fresh group with value selector failure;"
6668;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: add missing marble diagams to single;add (hopefully) all remaining missing marble diagrams to  single .;;5788.0;3x: add missing marble diagams to single;add (hopefully) all remaining missing marble diagrams to `single`5788(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleconcatarrayeagerpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlemergedelayerroripng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlemergedelayerrorppng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlemergedelayerror2png)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlemergedelayerror3png)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlemergedelayerror4png)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleunsafecreatepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleusingpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleusingbpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlewrappng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlecachepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlecastpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singledelaysubscriptiontpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singledelaysubscriptiontspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singledooneventpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleblockinggetpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleliftpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlecontainsfpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlecontainspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleonerrorresumewithpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleonterminatedetachpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleretrypng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleretryf2png)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleretrynpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleretryfpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleretrynfpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleretrywhenpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlesubscribepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlesubscribecpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlesubscribeccpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlesubscribec2png)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlesubscribewithpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singletakeuntilcpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singletakeuntilspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singletakeuntilppng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singletimeoutpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singletimeoutspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singletimeoutbpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singletimeoutsbpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleunsubscribeonpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singletestpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singletestbpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singledelaysubscriptionppng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singledelaysubscriptionopng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singledelaysubscriptionspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singledelaysubscriptioncpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singledematerializepng); merging 6668 ;3x: single incorrect or missing images (tracking issue);-  `amb`: missing diagram-  `ambarray`: missing diagram-  `concat(arg)`: missing diagram-  `concat(s1s4)`: add 3rd and 4th source indicate backpressure-  `concatarray`: missing diagram-  `concatarrayeager`: missing diagram-  `concateager`: missing diagram-  `create`: missing diagram-  `defer`: missing diagram-  `error(callable)`: missing diagram- [x] `error(throwable)`: indicate error in the box- [x] `fromcallable`: missing diagram- [x] `frompublisher`: missing diagram- [x] `fromobservable`: missing diagram- [x] `merge`: missing diagram- [x] `merge(singlesource<singlesource<t>>)`: indicate main element is a `singlesource`- [x] `merge(s1s4)`: add 3rd and 4th source indicate backpressure- [x] `mergedelayerror`: iterable/publisher missing diagrams s2s3s4 wrong diagrams- [x] `never`: missing diagram- [x] `timer`: missing diagram- [x] `equals`: missing diagram- [x] `unsafecreate`: missing diagram- [x] `using`: missing diagram- [x] `wrap`: missing diagram- [x] `ambwith`: missing diagram- [x] `as`: missing diagram- [x] `hide`: missing diagram- [x] `compose`: missing diagram- [x] `cache`: missing diagram- [x] `cast`: missing diagram- [x] `delay`: missing diagram- [x] `delaysubscription`: missing diagram- [x] `dematerialize`: missing diagram- [x] `doaftersuccess`: missing diagram- [x] `doafterterminate`: indicate error case- [x] `dofinally`: missing diagram- [x] `doonsubscibe`: missing diagram- [x] `doonsuccess`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonerror`: missing diagram- [x] `doondispose`: missing diagram- [x] `filter`: one source item indicate both true and false outcomes- [x] `flatmappublisher`: operator name- [x] `blockingget`: missing diagram- [x] `lift`: missing diagram- [x] `contains`: missing diagram- [x] `mergewith`: indicate backpressure- [x] `onerrorreturn`: indicate item is the result of a function call with the original error- [x] `onerrorreturnitem`: use the previous `onerrorreturn` diagram change name in box- [x] `onerrorresumenext`: diagram should have one item and no complete marker- [x] `onerrorresumewith`: operator name- [x] `onterminatedetach`: missing diagram- [x] `repeat`: missing diagram- [x] `repeatwhen`: missing diagram- [x] `repeatuntil`: missing diagram- [x] `retry`: missing diagram- [x] `retrywhen`: missing diagram- [x] `subscribe`: missing diagram- [x] `subscribewith`: missing diagram?- [x] `takeuntil`: fix item count in main and other sources indicate all other signal types- [x] `timeout`: missing diagram- [x] `to`: missing diagram- [x] `tocompletable`: diagram is stretched- [x] `toflowable`: operator name in box indicate backpressure- [x] `tofuture`: indicate future remove the blocking text- [x] `tomaybe`: operator name in box indicate both outcomes with proper signal types- [x] `unsubscribeon`: missing diagram- [x] `test`: missing diagram?;i see most marbles in the javadoc live under this folder:  ` are other locations accepted - eg can i upload it in google drive for example and open a pr with the updated path in the javadoc directly? heres a few i created:![single_dofinally]( || images have to be hosted by the project besides google drive tends to change the service terms and images may become inaccessible (ive lost resource location this way in another project) about your images:- `dofinally`:   - error should be a red x  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here- `doondispose`  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here  - `unsubscribe` should be `dispose`- `doonsubscribe`  - the star should be in between the operator box and the bottom timeline- `doonsuccess`: ok || updated images from #5987 now in the repository:![dofinally]( || how are these made? are there any written guidelines? i can try making some when i have time || there is a mac only omnigraffle im on windows and i use excel shapes and arrows || @aarjavp  i used [this template]( as a staring point its for **inkscape** software which worked nicely on my mac || hi all can you please tell me is this marble acceptable for the `filter` operator?as i havent contributed to this project so far i would like to take it easy and slow :) let me know what should i change so that i have a reference for future marbles![filter]( || not really there is no | in single please have a look at diagrams above:  || @akarnokd can we update this issue please? its getting a bit messy and hard to follow what has been completed || @umfsimke it has been only you lately that worked on this ||;1;0;3x: add missing marble diagams to single;
6674;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: fix window(time) possible interrupts while terminating;fix the case in  window(time)  variants where the timer thread is busy with window emission and the upstream terminates on some other thread  the window emission is interrupted.;;0;3x: fix window(time) possible interrupts while terminating;fix the case in `window(time)` variants where the timer thread is busy with window emission and the upstream terminates on some other thread the window emission is interrupted~~so instead of disposing the timer/worker right after the upstream termination a `dispose` message is queued up thus any ongoing drain loop from the timer thread can cleanup gracefully~~after some additional considerations there is no need for `dispose` the drain loop will take care of disposing the timer and the main downstream can simply be terminatedthe 2x fix will be in a separate pr shortly6672; merging 6674 ;;;;1;1;i dont think the dispose token is necessary after all;
6676;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix concurrent clear() calls when fused chains are canceled;when a fuseable source backed by an spsclinkedarrayqueue is cancelled and cleared concurrently (i.e.  one thread clears while the other cancels the chain)  the  clear()  method could run concurrently and either crash with npe or end up in an infinite loop due to corrupted queue state.;;0;3x: fix concurrent clear() calls when fused chains are canceled;when a fuseable source backed by an spsclinkedarrayqueue is cancelled and cleared concurrently (ie one thread clears while the other cancels the chain) the `clear()` method could run concurrently and either crash with npe or end up in an infinite loop due to corrupted queue statethis pr fixes two kinds of mistakes leading to this scenario:- calling `clear()` from `cancel`/`dispose` when the output is fused- calling `clear()` from a fused drain loop when cancellation is detectedwhen fused similar to `poll()` calling `clear()` is the responsibility of the consumer and the producer side is not allowed to call themthe bug affected the following operators:- `flowableonbackpressurebuffer`- `flowablegroupby`- `unicastprocessor`- `unicastsubject`6673; merging 6676 ;;;;1;1;3x: fix concurrent clear() calls when fused chains are canceled;
6677;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix concurrent clear() calls when fused chains are canceled;## backport of #6676;;0;2x: fix concurrent clear() calls when fused chains are canceled;## backport of #6676when a fuseable source backed by an spsclinkedarrayqueue is cancelled and cleared concurrently (ie one thread clears while the other cancels the chain) the `clear()` method could run concurrently and either crash with npe or end up in an infinite loop due to corrupted queue statethis pr fixes two kinds of mistakes leading to this scenario:- calling `clear()` from `cancel`/`dispose` when the output is fused- calling `clear()` from a fused drain loop when cancellation is detectedwhen fused similar to `poll()` calling `clear()` is the responsibility of the consumer and the producer side is not allowed to call themthe bug affected the following operators:- `flowableonbackpressurebuffer`- `flowablegroupby`- `unicastprocessor`- `unicastsubject`6673; merging 6677 ;;;;1;1;2x: fix concurrent clear() calls when fused chains are canceled;
6681;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;backport marble diagrams for single from 3.x;this pr is to backport the marble images of single class from 3.x. the method  onerrorresumewith  does not exist in 2.x and hence i have left that out.;;0;backport marble diagrams for single from 3x;this pr is to backport the marble images of single class from 3x the method `onerrorresumewith` does not exist in 2x and hence i have left that outcloses #6679; merging 6681 ;;;;1;1;backport marble diagrams for single from 3x;
6682;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix type inference problem when compiling with newer jdks;code in the  flowablegroupbytest  [didn t compile on newer jdks]( because of type inference changes between java 6 and them. in java 6  this;;0;3x: fix type inference problem when compiling with newer jdks;code in the `flowablegroupbytest` [didnt compile on newer jdks]( because of type inference changes between java 6 and them in java 6 this     flowable<integer> source      flowable<x> result  sourcegroupby(functionsidentity())comes out as `x  groupedflowable<object integer>` however newer jdks will propagate type arguments thus:    flowable<integer> source      flowable<y> result  sourcegroupby(functionsidentity())`y  groupedflowable<integer integer>` and mismatching with the rest of the typesi chose an explicit `integer` argument for clarity; merging 6682 ;;;;1;1;3x: fix type inference problem when compiling with newer jdks;
6684;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix window(time) possible interrupts while terminating;fix the case in  window(time)  variants where the timer thread is busy with window emission and the upstream terminates on some other thread  the window emission is interrupted.;;0;2x: fix window(time) possible interrupts while terminating;fix the case in `window(time)` variants where the timer thread is busy with window emission and the upstream terminates on some other thread the window emission is interruptedthe drain loop will take care of disposing the timer and the main downstream can simply be terminatedrelated #6674 6672; merging 6684 ;;;;1;1;2x: fix window(time) possible interrupts while terminating;
"6700;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: update javadoc for observeon to mention its eagerness;update javadoc to reflect the eagerness property of  observeon  in  flowable  and  observable  classes.;;6697.0;3x: update javadoc for observeon to mention its eagerness;update javadoc to reflect the eagerness property of `observeon` in `flowable` and `observable` classes6697; merging 6700 ;3x: update javadoc for observeon to mention its eagerness;""`flowableobserveon` and `observableobserveon` try to do as much event delivery as they canadd a section explaining this property to all these multi-valued `observeon` overloads:""""this operator keeps emitting as many signals as it can on the given schedulers worker thread which may result in a longer than expected occupation of this thread in other terms it does not allow per-signal fairness in case the worker runs on a shared underlying thread if such fairness and signal/work interleaving is preferred use the `delay` operator with zero time instead""""also link to the `@see #delay(longtimeunitscheduler)`"";hi! do we only need to add the quoted message in both classes? i can do it if it is ok || > i can do it if it is oksure> do we only need to add the quoted message in both classes?`single` `maybe` and `completable` can signal only one event and thus cant exhibit the property described || hi @akarnokd! just one silly question: when you say > add a section explaining this property to all these multi-valued observeon overloadsyou mean all but `observeon(scheduler scheduler)` right?in any case i just created a pr with what i understood was required please if there is something wrong let me know to fix itthanks  || @akarnokd could you take a look at this? can just test my last example your suggestion to use `delay()` did not help me solve the problem ||;1;0;update javadoc order;"
6708;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix concurrent clear in observeon while output-fused;there was another cancel-clear race leading to npe or infinite loop inside both  observeon  implementations.;;0;3x: fix concurrent clear in observeon while output-fused;there was another cancel-clear race leading to npe or infinite loop inside both `observeon` implementationsrelated: #6676; merging 6708 ;;;;1;1;3x: fix concurrent clear in observeon while output-fused;
6709;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: cleanup of some javadoc parts;enabled some javadoc validation and found a few mistakes. as far as i can tell  there is no  testunhandlederrorisdeliveredtothreadhandler  method or similar to reference there.;;0;3x: cleanup of some javadoc parts;enabled some javadoc validation and found a few mistakes as far as i can tell there is no `testunhandlederrorisdeliveredtothreadhandler` method or similar to reference there; merging 6709 ;;;;1;1;3x: cleanup of some javadoc parts;
6710;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix concurrent clear in observeon while output-fused;backport of #6708;;0;2x: fix concurrent clear in observeon while output-fused;backport of #6708------there was another cancel-clear race leading to npe or infinite loop inside both observeon implementationsrelated: #6676; merging 6710 ;;;;1;1;2x: fix concurrent clear in observeon while output-fused;
6714;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: fix multicastprocessor not requesting more after limit is reached;after reaching the prefetch limit  the updated  consumed  counter was not written back so the processor stopped requesting more (consumed > limit).;;671.0;3x: fix multicastprocessor not requesting more after limit is reached;after reaching the prefetch limit the updated `consumed` counter was not written back so the processor stopped requesting more (consumed > limit)affects 2x to a separate pr will be posted for it6713; merging 6714 ;api design review: aggregate and math functions;several operators on `rxobservable` are intended for aggregation and potentially dangerous on long-running or infinite observables similar to how blocking operators were moved to `blockingobservable` it has been suggested that aggregation operators be collected into an `aggregateobservable` or something similarly named this could be further broken into `aggregateobservable` and `numberobservable` for ones specifically operating on numbers as the type would be `<? extends number>` rather than `<t>`some of these operators include:- average*- max (add maxby (keyselector))- min (add minby)- sum*- contains- count- longcount- tolist- reduce/cc @headinthebox and @jhusain;average min max and sum went into rxjava-math do we want to move the rest too? from the rest i would rarely want to count the elements in a stream || agreed we should not lead people towards reducing streams to single values || we still have:- contains- count- longcount- tolist- reduce@headinthebox @akarnokd  should we leave these?it seems that `tolist` and `reduce` would be pretty jarring to remove people get what they ask for on those the `contains` and `count` are trivial and dont bother me being in the apii suggest we leave these 4 || except for tolist which i do often use im happy to remove the others but happy to keep them as well || i think we just leave them they dont bother me closing this out ||;1;0;test for more prefetch values and patterns;
6715;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix multicastprocessor not requesting more after limit is reached;after reaching the prefetch limit  the updated  consumed  counter was not written back so the processor stopped requesting more (consumed > limit).;;671.0;2x: fix multicastprocessor not requesting more after limit is reached;after reaching the prefetch limit the updated `consumed` counter was not written back so the processor stopped requesting more (consumed > limit)6713; merging 6715  < ;api design review: aggregate and math functions;several operators on `rxobservable` are intended for aggregation and potentially dangerous on long-running or infinite observables similar to how blocking operators were moved to `blockingobservable` it has been suggested that aggregation operators be collected into an `aggregateobservable` or something similarly named this could be further broken into `aggregateobservable` and `numberobservable` for ones specifically operating on numbers as the type would be `<? extends number>` rather than `<t>`some of these operators include:- average*- max (add maxby (keyselector))- min (add minby)- sum*- contains- count- longcount- tolist- reduce/cc @headinthebox and @jhusain;average min max and sum went into rxjava-math do we want to move the rest too? from the rest i would rarely want to count the elements in a stream || agreed we should not lead people towards reducing streams to single values || we still have:- contains- count- longcount- tolist- reduce@headinthebox @akarnokd  should we leave these?it seems that `tolist` and `reduce` would be pretty jarring to remove people get what they ask for on those the `contains` and `count` are trivial and dont bother me being in the apii suggest we leave these 4 || except for tolist which i do often use im happy to remove the others but happy to keep them as well || i think we just leave them they dont bother me closing this out ||;1;0;2x: fix multicastprocessor not requesting more after limit is reached;
6719;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: fix parallel() on grouped flowable not replenishing properly;fix a case when the  groupedflowable  is consumed by a  parallel()  in fusion mode causing the source to stop replenishing items from the upstream  hanging the whole sequence.;;0;3x: fix parallel() on grouped flowable not replenishing properly;fix a case when the `groupedflowable` is consumed by a `parallel()` in fusion mode causing the source to stop replenishing items from the upstream hanging the whole sequence`parallel()` was slightly different from the usual queue consumers because it checks for `isempty` before trying to `pull` for an item this was necessary because the rails may not be ready for more and an eager `pull` to check for emptyness would lose that item the replenishing was done in `groupedflowablepull` but a call to `groupedflowableisempty` would not replenishthe fix is to have `isempty` replenish similar to when `poll` detects emptyness and replenishesreported in https://githubcom/reactor/reactor-core/issues/1959; merging 6719 ;;;;1;1;again undo;
"6720;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix parallel() on grouped flowable not replenishing properly;## backport of #6719;;195.0;2x: fix parallel() on grouped flowable not replenishing properly;## backport of #6719 fix a case when the groupedflowable is consumed by a parallel() in fusion mode causing the source to stop replenishing items from the upstream hanging the whole sequenceparallel() was slightly different from the usual queue consumers because it checks for isempty before trying to pull for an item this was necessary because the rails may not be ready for more and an eager pull to check for emptyness would lose that item the replenishing was done in groupedflowablepull but a call to groupedflowableisempty would not replenishthe fix is to have isempty replenish similar to when poll detects emptyness and replenishesreported in reactor/reactor-core#1959; merging 6720 ;unwrap atomicobservablesubscription?;as far as i can tell any custom subscription that is passed to `subscribe` gets `wrap`ped in an atomicobservablesubscription unless `trusted` is true a flag which cant be controlled from outsidesince aos doesnt have an `unwrap` method how can i pass custom subscriptions in a type safe manner?rationale is being able to maintain extra state about a subscription _in_ the subscription;""an observable by design doesnt expose state so that it can be composed (wrapped) exactly as this is doing for example observablesynchronize() could be used to wrap an observable before vending it out for use if the observable was thought to not be thread-safe this is part of the principles of being functional and monadicall state within the func1 implementation that gets converted into an observable should be self-containedso what is your use case that is causing you to want to reach back into the observable implementation itself and how are you trying to do that? || not sure if it makes a difference but small correction: we dont want to track state in the observable we want to track state in the subscription which is what the client holds on tothe reason we want to do this is that on android we need to deal with component life cycles and need to attach/detach observers to prevent resource leaks or terminate observable sequence midway throughi see there is a `booleansubscription` which helps terminating loops by checking the subscription for `isunsubscribed` which is similar to what we want to do how would you even use this? anything i get in return from `subscribe` is wrapped away in an atomicobservablesubscription || the state is always hidden behind the observable or subscription interfaces - not leaked out thus your func1 implementation (that becomes and observable) would return an implementation of subscription that works with your function correctly to signal an unsubscribe this is important because the sequences of observables can be composed n-levels and an unsubscribe will be propagated up the sequence and each observable then does with it what its implementation dictates - but nothing external ever knows the implementation or tries to reach inside itheres an example of how booleansubscription is used:  groovyobservable<videolist> getlistoflists(userid) {    return observablecreate({ observer ->         booleansubscription subscription  new booleansubscription()        try {            // this will happen on a separate thread as it requires a network call            executorexecute({                    // simulate network latency                    threadsleep(180)                    for(i in 015) {                        if(subscriptionisunsubscribed()) {                            break                        }                        try {                            //println(""""****** emitting list: """" + i)                            observeronnext(new videolist(i))                        }catch(exception e) {                            observeronerror(e)                        }                    }                    observeroncompleted()            })        }catch(exception e) {            observeronerror(e)        }        return subscription    })}```as for multiple observers subscribing/unsubscribing that is definitely what multicast/publish is all about ( and  as discussed on twitter:  near the top of the todo list but if you need this functionality sooner than i or someone else is getting to it perhaps you can try tackling them as they are the right way to handle these issues of state || thanks for clarifying! have to admit that im still getting into the whole mindset of functional programming in java (the lack of supportive language constructs doesnt help) and its hard to do it in a clean way when introducing something like rx into a grown code base but were getting there no rush on the implementation of multicast but sure ill give it a shot when you guys are too busy! || yes it took myself and my teammates a month or two to adapt our thinking to it and several times we tried breaking the model before we starting thinking functionally also the lack of lambdas/closures in java (until java8 which i eagerly await) is why we predominantly use rxjava in other languages that support them || "";1;0;2x: fix parallel() on grouped flowable not replenishing properly;"
6722;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;2.x: update javadoc for observeon to mention its eagerness;## backport of #6700;;0;2x: update javadoc for observeon to mention its eagerness;## backport of #6700update javadoc to reflect the eagerness property of observeon in flowable and observable classesrelated #6697; merging 6722 ;;;;1;1;2x: update javadoc for observeon to mention its eagerness;
6723;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: observeon and schedulers.from eagerness javadoc updates;- add missing explanation to  observeon(scheduler);;0;3x: observeon and schedulersfrom eagerness javadoc updates;- add missing explanation to `observeon(scheduler)`- remove `<p>`s that create javadoc empty-tag warnings- update `@see` to point to `delay`s with `delayerror` parameter- explain that `schedulersfrom` is eager toorelated #6700; merging 6723 ;;;;1;1;3x: observeon and schedulersfrom eagerness javadoc updates;
6729;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: fix self-see references  some comments;- some  @see  should point to the other party (plain <->  delayerror ).;;672.0;3x: fix self-see references some comments;- some `@see` should point to the other party (plain <-> `delayerror`)- add a few `@see` to the nearby operators- comments no longer apply in `blockingxmostrecent` source code- add a comment from #6728 to `actiondisposable`replaces #6728;;api design review: delaysubscription;what is the `delaysubscription` operator for and should we delete it?/cc @headinthebox and @jhusain;@headinthebox should we keep this? || this one comes from net i never use it myself i think it is mostly useful for testing where you can delay the subscription to fuzz || skipping it then   ||;1;0;3x: fix self-see references some comments;
6729;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: fix self-see references  some comments;- some  @see  should point to the other party (plain <->  delayerror ).;;6728.0;3x: fix self-see references some comments;- some `@see` should point to the other party (plain <-> `delayerror`)- add a few `@see` to the nearby operators- comments no longer apply in `blockingxmostrecent` source code- add a comment from #6728 to `actiondisposable`replaces #6728;;add javadoc on actiondisposable correction of dangling javadoc comme;javadoc corrections :- add javadoc on actiondisposable- correction of dangling javadoc comments- remove of unnecessary @see (on same method)issue #4535; merging 6728 ;1;0;3x: fix self-see references some comments;
6730;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: add maybe marble diagrams (14 cases);related #5806;;5806.0;3x: add maybe marble diagrams (14 cases);related #5806----(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybezipipng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybezipnpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeziparraypng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybezipwithpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybecontainsopng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeunsubscribeonpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeonterminatedetachpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybecastpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeliftpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedooneventpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedelaysubscriptiontpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedelaysubscriptiontspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedelaysubscriptionppng); merging 6730 ;3x: maybe incorrect or missing marbles (tracking issue);-  `amb`: missing diagram-  `ambarray`: missing diagram-  `concat(iterable)`: missing diagram-  `concat(publisher)`: missing diagram-  `concat(publisher int)`: missing diagram-  `concatarray`: missing diagram-  `concatarraydelayerror`: indicate error delayed 1 marble per source-  `concatarrayeager`: missing diagram-  `concatdelayerror(iterable)`: missing diagram-  `concatdelayerror(publisher)`: missing diagram- [x] `concatdelayerror(publisher int)`: fix overlap/misalignment inside the operator box- [x] `concateager(iterable)`: missing diagram- [x] `concateager(publisher)`: missing diagram- [x] `create`: missing diagram- [x] `defer`: missing diagram- [x] `error(callable)`: indicate callable returns the error- [x] `fromaction`: missing diagram- [x] `fromcompletable`: missing diagram- [x] `fromsingle`: missing diagram- [x] `fromcallable`: missing diagram- [x] `fromfuture(future)`: operator name in the box indicate future is the parameter- [x] `fromfuture(future long timeunit)`: operator name in the box indicate future is the parameter indicate timeout- [x] `fromrunnable`: missing diagram- [x] `merge(iterable)`: missing diagram- [x] `merge(publisher)`: missing diagram- [x] `merge(publisher int)`: missing diagram- [x] `mergearray`: missing diagram- [x] `mergearraydelayerror`: one marble per maybe source- [x] `mergedelayerror(iterable)`: one marble per maybe source- [x] `mergedelayerror(publisher)`: one marble per maybe source- [x] `mergedelayerror(maybe maybe )`: one marble per maybe source- [x] `sequenceequal` + 1: result should be `single`- [x] `timer` + 1: result should be maybe- [x] `using` + 1: rework to indicate the created maybe- [x] `wrap`: missing marble- [x] `zip(iterable)`: one marble per maybe source result should be maybe- [x] `zip(maybe maybe )` + 8: one marble per maybe source result should be maybe- [x] `ziparray`: one marble per maybe source result should be maybe- [x] `ambwith`: one marble per maybe source result should be maybe- [x] ~~`as`: missing diagram~~ operator removed- [x] `blockingget` + 1: missing diagram- [x] `cache`: one marble per maybe source result should be maybe- [x] `cast`: missing diagram- [x] `compose`: missing diagram- [x] `concatmap`: indicate maybe target indicate empty source- [x] `concatwith`: one marble per maybe source result should be maybe operator name indicate other is a parameter- [x] `contains`: one marble per maybe source result should be single empty case- [x] `count`: one marble per maybe operator name result should be single empty case- [x] `defaultifempty`: non-empty case result should be maybe- [x] `delay(time)` + 3: one marble per maybe source result should be maybe- [x] `delay(publisher)`: one marble per maybe one signal by the publisher empty publisher case- [x] `delaysubscription(publisher)`: missing diagram- [x] `delaysubscription(time)` + 1: one marble per maybe source result should be maybe- [x] `doaftersuccess`: missing diagram- [x] `doafterterminate`: operator name one marble per maybe result should be maybe- [x] `dofinally`: missing diagram- [x] `doondispose`: missing diagram- [x] `dooncomplete`: one marble per maybe result should be maybe- [x] `doonerror`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonsubscribe`: missing diagram- [x] `doonsuccess`: missing diagram- [x] `doonterminate`: one marble per maybe result should be maybe- [x] `filter`: one marble per maybe result should be maybe- [x] `flatmap(function function callable)`: one marble per maybe result should be maybe- [x] `flatmap(function bifunction)`: one marble per maybe result should be maybe- [x] `flatmapobservable`: should be mapped into an observable- [x] `flatmappublisher`: indicate backpressure- [x] `flatmapsingle`: indicate empty maybe results in error- [x] `flatmapsingleelement`: operator name indicate empty maybe- [x] `flatmapcompletable`: indicate empty maybe- [x] `hide`: missing diagram- [x] `ignoreelement`: operator name one marble per maybe result should be maybe- [x] `isempty`: result should be single- [x] `mergewith`: operator name one marble per maybe indicate backpressure- [x] `oftype`: one marble per maybe- [x] `onerrorcomplete` + 1: missing diagram- [x] `onerrorresumenext`: one marble per maybe result should be maybe- [x] `onerrorresumewith`: one marble per maybe result should be maybe- [x] `onerrorreturn`: one marble per maybe result should be maybe indicate callback- [x] `onerrorreturnitem`: operator name one marble per maybe result should be maybe indicate normal outcome- [x] ~~`onexceptionresumenext`: operator takes a maybe source directly~~ operator removed- [x] `onterminatedetach`: missing diagram- [x] `repeat` + 1: one marble per source indicate backpressure indicate repeat conditions- [x] `repeatuntil`: operator name repeat condition indicate backpressure- [x] `repeatwhen`: one marble per maybe indicate backpressure- [x] `retry` + 2: one marble per maybe result should be maybe indicate repeat conditions- [x] `retry(int predicate)`: missing diagram- [x] `retry(predicate)`: missing diagram- [x] `retryuntil`: missing diagram- [x] `retrywhen`: one marble per maybe output should be maybe- [x] `switchifempty` + 1: improve diagrams indicate argument type- [x] `takeuntil` + 1: one marble per maybe output should be maybe- [x] `timeout` + 3: one marble per maybe output should be maybe- [x] `timeout(maybesource)`: missing diagram- [x] `timeout(maybesource maybesource)`: missing diagram- [x] `timeout(publisher)`: missing diagram- [x] `timeout(publisher maybesource)`: missing diagram- [x] `to`: missing diagram- [x] `toflowable`: missing diagram- [x] `toobservable`: missing diagram- [x] `tosingle` + 1: missing diagram- [x] `unsubscribeon`: missing diagram- [x] `zipwith`: one marble per maybe output should be maybe;here is the excel file i draw the diagrams in:  ||;1;0;3x: add maybe marble diagrams (14 cases);
6732;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: update single.zip marble diagrams (4 cases);related #5788;;5788.0;3x: update singlezip marble diagrams (4 cases);related #5788-----(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlezipipng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlezipnpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleziparraypng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlezipwithpng);;3x: single incorrect or missing images (tracking issue);-  `amb`: missing diagram-  `ambarray`: missing diagram-  `concat(arg)`: missing diagram-  `concat(s1s4)`: add 3rd and 4th source indicate backpressure-  `concatarray`: missing diagram-  `concatarrayeager`: missing diagram-  `concateager`: missing diagram-  `create`: missing diagram-  `defer`: missing diagram-  `error(callable)`: missing diagram- [x] `error(throwable)`: indicate error in the box- [x] `fromcallable`: missing diagram- [x] `frompublisher`: missing diagram- [x] `fromobservable`: missing diagram- [x] `merge`: missing diagram- [x] `merge(singlesource<singlesource<t>>)`: indicate main element is a `singlesource`- [x] `merge(s1s4)`: add 3rd and 4th source indicate backpressure- [x] `mergedelayerror`: iterable/publisher missing diagrams s2s3s4 wrong diagrams- [x] `never`: missing diagram- [x] `timer`: missing diagram- [x] `equals`: missing diagram- [x] `unsafecreate`: missing diagram- [x] `using`: missing diagram- [x] `wrap`: missing diagram- [x] `ambwith`: missing diagram- [x] `as`: missing diagram- [x] `hide`: missing diagram- [x] `compose`: missing diagram- [x] `cache`: missing diagram- [x] `cast`: missing diagram- [x] `delay`: missing diagram- [x] `delaysubscription`: missing diagram- [x] `dematerialize`: missing diagram- [x] `doaftersuccess`: missing diagram- [x] `doafterterminate`: indicate error case- [x] `dofinally`: missing diagram- [x] `doonsubscibe`: missing diagram- [x] `doonsuccess`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonerror`: missing diagram- [x] `doondispose`: missing diagram- [x] `filter`: one source item indicate both true and false outcomes- [x] `flatmappublisher`: operator name- [x] `blockingget`: missing diagram- [x] `lift`: missing diagram- [x] `contains`: missing diagram- [x] `mergewith`: indicate backpressure- [x] `onerrorreturn`: indicate item is the result of a function call with the original error- [x] `onerrorreturnitem`: use the previous `onerrorreturn` diagram change name in box- [x] `onerrorresumenext`: diagram should have one item and no complete marker- [x] `onerrorresumewith`: operator name- [x] `onterminatedetach`: missing diagram- [x] `repeat`: missing diagram- [x] `repeatwhen`: missing diagram- [x] `repeatuntil`: missing diagram- [x] `retry`: missing diagram- [x] `retrywhen`: missing diagram- [x] `subscribe`: missing diagram- [x] `subscribewith`: missing diagram?- [x] `takeuntil`: fix item count in main and other sources indicate all other signal types- [x] `timeout`: missing diagram- [x] `to`: missing diagram- [x] `tocompletable`: diagram is stretched- [x] `toflowable`: operator name in box indicate backpressure- [x] `tofuture`: indicate future remove the blocking text- [x] `tomaybe`: operator name in box indicate both outcomes with proper signal types- [x] `unsubscribeon`: missing diagram- [x] `test`: missing diagram?;i see most marbles in the javadoc live under this folder:  ` are other locations accepted - eg can i upload it in google drive for example and open a pr with the updated path in the javadoc directly? heres a few i created:![single_dofinally]( || images have to be hosted by the project besides google drive tends to change the service terms and images may become inaccessible (ive lost resource location this way in another project) about your images:- `dofinally`:   - error should be a red x  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here- `doondispose`  - the dispose case puts the star too close to the time arrow as if it was an output instead of a side-effect  - i draw disposed flows with dashed lines ([example]( it would be great here  - `unsubscribe` should be `dispose`- `doonsubscribe`  - the star should be in between the operator box and the bottom timeline- `doonsuccess`: ok || updated images from #5987 now in the repository:![dofinally]( || how are these made? are there any written guidelines? i can try making some when i have time || there is a mac only omnigraffle im on windows and i use excel shapes and arrows || @aarjavp  i used [this template]( as a staring point its for **inkscape** software which worked nicely on my mac || hi all can you please tell me is this marble acceptable for the `filter` operator?as i havent contributed to this project so far i would like to take it easy and slow :) let me know what should i change so that i have a reference for future marbles![filter]( || not really there is no | in single please have a look at diagrams above:  || @akarnokd can we update this issue please? its getting a bit messy and hard to follow what has been completed || @umfsimke it has been only you lately that worked on this ||;1;0;3x: update singlezip marble diagrams (4 cases);
6739;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: mockito fix deprecated api use after bump to 3.2.0;use the suggested  verifynointeractions  instead of  verifyzerointeractions .;;0;3x: mockito fix deprecated api use after bump to 320;use the suggested `verifynointeractions` instead of `verifyzerointeractions`; merging 6739 ;;;;1;1;3x: mockito fix deprecated api use after bump to 320;
6740;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: change flowable.groupby to signal mbe instead of possibly hanging;this pr changes the backpressure behavior of  flowable.groupby  to signal  missingbackpressureexception  instead of silently hanging if the produced groups are not ready to be accepted by the downstream.;;0;3x: change flowablegroupby to signal mbe instead of possibly hanging;this pr changes the backpressure behavior of `flowablegroupby` to signal `missingbackpressureexception` instead of silently hanging if the produced groups are not ready to be accepted by the downstream this can happen if one `flatmap`s a `groupby` but there are more groups produced than the concurrency level of `flatmap` since replenishment is tied to item consumption from the groups not consuming them can result in none of the groups receiving any further items and the whole operator hangsthe following changes have been applied:- removed the queue from the main operator since it will now try to emit directly and not buffer groups- the main `flowable` lacking a queue no longer supports operator fusion tests checking this property have been removed as well- when a group is drained consumed items are replenished in batch if possible detecting a cancellation will also trigger a replenishment- when a group is pulled (fusion mode) now all `pull` `isempty` and `clear` will trigger replenishment so that other groups can make progress too- unit tests have been modified to have large enough buffersize/prefetch amounts to allow them to pass6641; merging 6740 ;;;;1;1;improve coverage of changes;
"6744;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: add fair mode overload to schedulers.from(executor);the default  schedulers.from  implementation uses an eager approach to execute tasks on the underlying  executor  which can lead to excessive thread occupation on its own  even if operators use buffering/prefetch of 1.;;6696.0;3x: add fair mode overload to schedulersfrom(executor);the default `schedulersfrom` implementation uses an eager approach to execute tasks on the underlying `executor` which can lead to excessive thread occupation on its own even if operators use buffering/prefetch of 1this pr introduces a new overload with a fairness option so that tasks are submitted to the `executor` in a non-overlapping and fifo manner one by onein addition the scheduler retention tests have been cleaned up and reworked to not wait unnecessarily long for the gc to finishrelated: #6696 #6697; merging 6744  < ;2x: surprising scheduler behaviour;""# brief descriptiongiven a shared upstream and two flows using `observeon()` before `filter()` may change the original emission order# rxjava version`2213`# code sample```private val subject  publishsubjectcreate<int>()toserialized()private val singlescheduler  schedulerssingle()fun filtersubjectforidonscheduler(id: int): observable<int> {    return subject        observeon(singlescheduler)        filter {            loge(""""filter"""" """"id  $id value  $it"""")            it  id        }}fun main() {    observablemerge(        filtersubjectforidonscheduler(1)        filtersubjectforidonscheduler(2)    )        subscribe { loge(""""subscribe"""" """"value  $it"""") }    subjectonnext(2)    subjectonnext(1)}```# actual (surprising) result```14491-14855 e/filter: id  1 value  214491-14855 e/filter: id  1 value  114491-14855 e/subscribe: value  114491-14855 e/filter: id  2 value  214491-14855 e/subscribe: value  214491-14855 e/filter: id  2 value  1```# expected result```14491-14855 e/filter: id  1 value  214491-14855 e/filter: id  2 value  214491-14855 e/subscribe: value  214491-14855 e/filter: id  1 value  114491-14855 e/subscribe: value  114491-14855 e/filter: id  2 value  1```# notes1 the code originally used a `schedulersfrom(executorsnewsinglethreadexecutor())`  i thought that somehow the executors may be optimised in a way that batches individual runnables and cycles them before cycling the queue of observers i found `schedulerssingle()` which states (emphasis mine):>      * returns a default shared single-thread-backed {@link scheduler} instance for work>      * requiring >>>strongly-sequential<<< execution on the same background thread2 instead of using `observeon()` calling via `scheduledirect` yields expected results:```singleschedulerscheduledirect { subjectonnext(2) }singleschedulerscheduledirect { subjectonnext(1) }// orsingleschedulerscheduledirect {    subjectonnext(2)    subjectonnext(1)}```3 it seems that the scheduler has two queues one for emissions and one for observers the emissions queue seems to be cycled before the queue of observers where sequential processing seemingly would need different priority of cycling (notify all observers about the first emission before proceeding to a next one)# questionis the actual result an expected one?if so  could you explain why? is it possible to alter the flow without reordering operators and achieve expected results?"";`observeon` keeps the single thread occupied as long as it sees work in this case the values 2 and 1 in quick succession try `delay(0)` which schedules events individually || > try `delay(0)` which schedules events individuallydo you mean `delay(0 timeunitseconds)`? i have tried adding it before and after `observeon()` but it seems to work the same || replace `observeon` with `delay(0 timeunitseconds)` || using `delay(0 timeunitseconds singlescheduler)` instead of `observeon(singlescheduler)` changed the behaviour to one that matches the expected resultfor me this looks awkward  as a user i would like to observe on a specified scheduler in sequential order currently it seems to violate [law of least surprise]( how do you think? or maybe current implementation has some obvious performance advantage that i am unaware of? || `observeon` is designed to do as much work in a drain run as possible reactive concurrency is complicated and scheduling is an orthogonal concept (when vs where) hence a perfectly sequential scheduler used with an operator can result in non-intuitive event signaling pattern downstream also your type of lockstepping and coordination is rare || is this well described somewhere so i could study the topic a bit more?> reactive concurrency is complicated and scheduling is an orthogonal concept (when vs where) hence a perfectly sequential scheduler used with an operator can result in non-intuitive event signaling pattern downstreamshould this be mentioned somewhere? it looks like an important gotcha> also your type of lockstepping and coordination is rarei use this approach to relief the calling thread as quickly as possible since it is bound to native code and prone to break the underlying system that i do not control (here modelled as the `subject`) || see [my blog]( and the [operator writing guide]( should this be mentioned somewhere?the `observeon` javadoc can be updated to mention its eagerness || a helper question  do you know why schedulers are designed this way by default (instead of being basically equivalent to `delay(0 timeunit scheduler)`? || scheduler is an abstraction over crossing an asynchronous boundary by providing methods to run work somewhere it doesnt know what or how much work it means `observeon` is designed to be low overhead (both time and allocation) when moving data between threads `delay` has to schedule each item individually which adds a lot of allocation || i think this topic is cleared and appropriate [javadoc change has landed]( so i am closing thank you very much for the helpi do have some other questions about surfaceing reactive and non-reactive world 1 difference in how `observable`s are subscribed and disposed when using `subscribeon()` and without it  in the first situation the `observable` may or may not be subscribed depending on a race condition and in the second it will always be subscribed funny thing is that `testscheduler` seems to work as no `subscribeon()` is present rather than other schedulers2 `undeliverableexception`  this is something that is seemingly impossible to mitigate in a multi-threaded environment as there always may be a race condition under which the `observer` will already be unsubscribedi would like to discuss those matters or find a way to learn on how to deal with them should i create separate issues or? || 1 `subscribeon` always signals `onsubscribe` but the subscription towards the upstream should be properly depend on when `testscheduler::triggeractions()` is invoked2 i dont think there is anything to discuss about this errors must not get lost upon disposing and rx cant decide which to ignore  || 1 apparently there are some optimisations which make `observablesubscribeon()subscribe()dispose()` subscribing/not subscribing to the `observable` depending on a race condition i see some weird behaviour in my tests but i assume i got something wrong will dig deeper and keep you posted if i find something funny2 i know this i was hoping that it may be somehow handled by the code that uses rxjava 2 current design does not allow for using rxjava 2 as an implementation detail it cannot really be encapsulated due to static handlers ||;1;0;3x: add fair mode overload to schedulersfrom(executor);"
6745;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: make disposablecontainer public api;make the internal interface  disposablecontainer  public as it can be one safely.;;674.0;3x: make disposablecontainer public api;make the internal interface `disposablecontainer` public as it can be one safely(ive seen some 3rd party usage in custom containers this will make them now legit on 3x)**edit**also [should resolve]( the osgi private reference warning6742; merging 6745 ;api design review: rxjoinobserverbase;the `rxjoinobserverbase` class should not be public as part of the rxjava-core apiit needs to be deleted or made private it replicates behavior of `safeobserver` which is also kept private /cc @headinthebox and @jhusain;;1;0;3x: make disposablecontainer public api;
6746;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;javadoc cleanup 1203;this pr is simply a backport of #6729 to the rxjava 2.x branch.;;0;javadoc cleanup 1203;this pr is simply a backport of #6729 to the rxjava 2x branch;whoa thats definitively incorrect looks like you started with a very old commit you should checkout 2x from this repo not yourolder fork || okay so it only needed retargeting you have to select the target branch next time you create a pr for 2x as the default is 3x ||  merging 6746 ;;;;1;1;backporting #6729 to 2x branch;
6748;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: change how the cause of compositeexception is generated;this pr changes how  compositeexception.getcause  creates a cause exception on demand. in 1.x and 2.x  the code tried to link up the various inner exceptions via their  initcause   which was in on itself fishy as well as could lead to excessive memory usage.;;674.0;3x: change how the cause of compositeexception is generated;this pr changes how `compositeexceptiongetcause` creates a cause exception on demand in 1x and 2x the code tried to link up the various inner exceptions via their `initcause` which was in on itself fishy as well as could lead to excessive memory usageinstead the new code will present the inner exceptions as part of a formatted message which in theory should be still picked up by ide exception listings and allow navigation:```multiple exceptions (2)|-- ioreactivexrxjava3exceptionstestexception: ex3    at ioreactivexrxjava3exceptionscompositeexceptiontestnestedmultilinemessage(compositeexceptiontestjava:341)|-- ioreactivexrxjava3exceptionstestexception: ex4    at ioreactivexrxjava3exceptionscompositeexceptiontestnestedmultilinemessage(compositeexceptiontestjava:342)  |-- ioreactivexrxjava3exceptionscompositeexception: 2 exceptions occurred       at ioreactivexrxjava3exceptionscompositeexceptiontestnestedmultilinemessage(compositeexceptiontestjava:337)    |-- ioreactivexrxjava3exceptionscompositeexceptionexceptionoverview:         multiple exceptions (2)        |-- ioreactivexrxjava3exceptionstestexception: ex1            at ioreactivexrxjava3exceptionscompositeexceptiontestnestedmultilinemessage(compositeexceptiontestjava:335)        |-- ioreactivexrxjava3exceptionstestexception: ex2            at ioreactivexrxjava3exceptionscompositeexceptiontestnestedmultilinemessage(compositeexceptiontestjava:336)```( are a few formatting conveniences:- if there is only one inner exception the `compositeexception`s cause will be simply that exception this can happen when the very same exception is aggregated into the composite and get deduplicated- if an inner exceptions message is multi-lined the message and cause traces should be indented properly- reoccurring causes are not expanded over and over:```multiple exceptions (2)|-- ioreactivexrxjava3exceptionstestexception: ex1    at ioreactivexrxjava3exceptionscompositeexceptiontestreoccurringexception(compositeexceptiontestjava:316)  |-- ioreactivexrxjava3exceptionstestexception: ex0      at ioreactivexrxjava3exceptionscompositeexceptiontestreoccurringexception(compositeexceptiontestjava:315)|-- ioreactivexrxjava3exceptionstestexception: ex2    at ioreactivexrxjava3exceptionscompositeexceptiontestreoccurringexception(compositeexceptiontestjava:319)  |-- ioreactivexrxjava3exceptionstestexception: ex1      at ioreactivexrxjava3exceptionscompositeexceptiontestreoccurringexception(compositeexceptiontestjava:316)      |-- (cause not expanded again) ioreactivexrxjava3exceptionstestexception: ex0```currently only the first line of the stacktraces are shown because it can get quite long (and thus memory consuming) to list them all maybe a system parameter can be introduced to control the verbosity6747; merging 6748 ;api design review: rxjoinobserverbase;the `rxjoinobserverbase` class should not be public as part of the rxjava-core apiit needs to be deleted or made private it replicates behavior of `safeobserver` which is also kept private /cc @headinthebox and @jhusain;;1;0;fix a mistake in the unit test;
6750;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: update observeon docs with links and +backpressure explanation;fixed a style mistake and wrong classes mentioned in the  flowable.observeon  docs.;;0;3x: update observeon docs with links and +backpressure explanation; a style mistake and wrong classes mentioned in the `flowableobserveon` docsin addition ive added explanation about it not preserving the request pattern across; merging 6750 ;;;;1;1;3x: update observeon docs with links and +backpressure explanation;
6754;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: zip  combinelatest  and amb operators throw when supplied with observablesource implementation that doesn t subclass observable;6753;;675.0;2x: zip combinelatest and amb operators throw when supplied with observablesource implementation that doesnt subclass observable;6753;please add unit tests so this doesnt happen again in case of any future change ||  merging 6754  < ;api design review: zip overload without function;while reviewing the `zip` operators it was suggested we add an overload that returns `observable<list<r>>` and doesnt take a function it would allow zipping without explicitly defining a function if we had tuples we would return those since we dont well return `list<r>`/cc @headinthebox and @jhusain;more precisely this transposes iterable<observable<t>> to observable<list<t>>  || do we still want this overload? || not for me || closing  not important and additive so it can always be done later ||;1;0;2x: add tests for allowing arbitrary observablesource implementations;
6756;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix observable amb  combinelatest & zip arraystoreexception;when using iterable of sources  the initial array is the wrong type and causes  arraystoreexception .;;675.0;3x: fix observable amb combinelatest & zip arraystoreexception;when using iterable of sources the initial array is the wrong type and causes `arraystoreexception`unit tests were added to verify the other implementations6753; merging 6756 ;api design review: zip overload without function;while reviewing the `zip` operators it was suggested we add an overload that returns `observable<list<r>>` and doesnt take a function it would allow zipping without explicitly defining a function if we had tuples we would return those since we dont well return `list<r>`/cc @headinthebox and @jhusain;more precisely this transposes iterable<observable<t>> to observable<list<t>>  || do we still want this overload? || not for me || closing  not important and additive so it can always be done later ||;1;0;3x: fix observable amb combinelatest & zip arraystoreexception;
6758;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix flowable.window (size  time) cancellation and abandonment;this pr fixes the  flowable.window  operator (with size and time boundaries) so that;;0;3x: fix flowablewindow (size time) cancellation and abandonment;this pr fixes the `flowablewindow` operator (with size and time boundaries) so that- cancelling the inner windows allows cancelling the upstream once neither the main output nor other windows are being consumed further- ignoring a window still allows cancelling the upstreamthese fixes are necessary similar to how `groupby` had to be updated in #6740the publisher-boundary and start-stop publisher boundary as well as the `observable` variants will be updated in subsequent prs due to the sheer number of changes; merging 6758 ;;;;1;1;3x: fix flowablewindow (size time) cancellation and abandonment;
6760;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix typo in flowable javadoc;fix compilation error in example code in javadoc;;0;fix typo in flowable javadoc;fix compilation error in example code in javadoc; merging 6760  < ;;;;1;1;fix typo in flowable javadocfix compilation error in example code in javadoc;
6761;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: fix observable.window (size & time) cancellation and abandonment;this pr fixes the  observable.window  operator (with size and time boundaries) so that;;0;3x: fix observablewindow (size & time) cancellation and abandonment;this pr fixes the `observablewindow` operator (with size and time boundaries) so that- cancelling the inner windows allows cancelling the upstream once neither the main output nor other windows are being consumed further- ignoring a window still allows cancelling the upstreamfollow-up to #6758 the boundary and start-stop publisher boundarywill be updated in subsequent prsin addition the previous `windowsubscribeintercept` has been renamed to match the reactive type naming as well as removed the unnecessary serialization of the emission of window processors; merging 6761  < ;;;;1;1;3x: fix observablewindow (size & time) cancellation and abandonment;
"6762;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix window (boundary  start/end) cancel and abandonment;this pr fixes the  window  operator (with boundary and start-end sources) so that;;676.0;3x: fix window (boundary start/end) cancel and abandonment;this pr fixes the `window` operator (with boundary and start-end sources) so that- cancelling the inner windows allows cancelling the upstream once neither the main output nor other windows are being consumed further- ignoring a window still allows cancelling the upstreamfollow-up to #6758 and #6761; merging 6762 ;api design review: safeobserver via reflection or marker interface;the `safeobserver` wrapper is applied to all `observer` implementations passed into `observablesubscribe` by users but it is not applied to any `observer` implementations that originate from within the `rxoperators` packagethis is so we achieve the desired safety and error handling while not paying the cost of wrapping trusted `observer` implementations from internal operatorstoday it uses reflection to look at the package the `observer` originates from it then caches this information for performance  see here:  and here:   is not pretty but it worksthe other way is we could put marker interfaces such as `trustedobserver` on all `observer` implementations we use in `rxoperators` or elsewhere that should not be wrappedpros:- doesnt involve reflection- obvious- can be used by non-internal operatorscons:- marker interfaces require remembering to put them where they should be- they can be put where theyre not supposed to be- can be used by non-internal operators and misused- they are an extra type to maintain in the public api serving little valueneither approach is pretty is there another approach? if not which of these two is preferable and why?/cc @headinthebox and @jhusain;""since `observable` code changes often enough those links will become wrong so here is the valid code:``` java/**     * whether a given {@link function} is an internal implementation inside     * rx* packages or not     * <p>     * for why this is being used see     *  for discussion on     * """"guideline 64: protect calls to user code from within an operator""""     *      * note: if strong reasons for not depending on package names comes up then     * the implementation of this method can change to looking for a marker     * interface     *      * @param o     * @return {@code true} if the given function is an internal implementation     *         and {@code false} otherwise     */    private boolean isinternalimplementation(object o) {        if (o  null) {            return true        }        // prevent double-wrapping (yeah it happens)        if (o instanceof safeobserver) {            return true        }        class<?> clazz  ogetclass()        if (internalclassmapcontainskey(clazz)) {            //dont need to do reflection            return internalclassmapget(clazz)        } else {            // we treat the following package as """"internal"""" and dont wrap it            package p  ogetclass()getpackage() // it can be null            boolean isinternal  (p ! null && pgetname()startswith(""""rxoperators""""))            internalclassmapput(clazz isinternal)            return isinternal        }    }`````` javaif (isinternalimplementation(observer)) {                subscription s  onsubscribefunctiononsubscribe(observer)                if (s  null) {                    // this generally shouldnt be the case on a trusted onsubscribe but in case it happens                    // we want to gracefully handle it the same as safeobservablesubscription does                    return hookonsubscribereturn(this subscriptionsempty())                } else {                    return hookonsubscribereturn(this s)                }            } else {                safeobservablesubscription subscription  new safeobservablesubscription()                subscriptionwrap(onsubscribefunctiononsubscribe(new safeobserver<t>(subscription observer)))                return hookonsubscribereturn(this subscription)            }``` || fwiw id lean toward option 2 (wouldnt this still result in using reflection though since youd have to check for the annotation at runtime?)> marker interfaces require remembering to put them where they should betrue is this something that could be caught using static analysis?> they can be put where theyre not supposed to bebut so can any class level annotation and it can be made only applicable to classes via the target property i dont see this being an issue really> can be used by non-internal operators and misusedsure then again whoever misuses this to mark a misbehaving observer as trusted is only shooting themselves in the foot? you get what you ask for :-) > they are an extra type to maintain in the public api serving little valueare you referring to the marker interface? whats the maintenance overhead though apart from having to remember applying it to internal observers?would be interested in hearing what others have to say || another option ive become more comfortable with (and that @headinthebox prefers) is that we add `observableunsafesubscribe` that `operator` implementations can use and it does what it says  subscribe without any """"safety"""" wrapping it would directly invoke the inner `onsubscribe` function || yes thats what i would prefer ^f for """"unsafe"""" during code reviews to spot where people may shoot themselves in the foot that dont know what they are doing but allow full power in case you need to implement a new operator || i see i would find it a bit odd though to find unsafesubscribe invocationsthroughout my client code even when i know its safe it would raise eyebrows for people not as familiar with the peculiarities of the library || do you create operators that act on nested observables? examples are `repeat` `retry` `merge`those are the only scenario where an `unsafesubscribe` is needed otherwise normal `operator` implementations like `map` `take` `filter` etc do not need to || here is an example location where it is doing an """"unsafe subscribe"""":  in `map` youll see it never subscribes because it is a `subscriber` -> `subscriber` transformation that gets lifted into the `observable`:  || i intend on doing this in 018 along with `scheduler` changes do my last explanations make sense or is there still concern about this change?the only time when this will need to be used is when implementing operators that do nested subscriptions  || +1on mon mar 31 2014 at 7:34 pm ben christensennotifications@githubcomwrote:> i intend on doing this in 018 along with scheduler changes do my last> explanations make sense or is there still concern about this change?> > the only time when this will need to be used is when implementing> operators that do nested subscriptions> > > reply to this email directly or view it on github  || thanks for the positive confirmation @mttkay  ill proceed with this || completed in  || "";1;0;3x: fix window (boundary start/end) cancel and abandonment;"
"6765;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: [java 8] upgrade to java 8  add flowable.fromx operators;this pr upgrades rxjava to use and compile with java 8.;;6695.0;3x: [java 8] upgrade to java 8 add flowablefromx operators;this pr upgrades rxjava to use and compile with java 8- build target set to 8- animalsniffer set to 8- javadocs link to the official jdk set to 8- implemented operators:  - `flowablefromoptional`  - `flowablefromcompletionstage`  - `flowablefromstream`- applied `@safevarargs` to many methods- created marblesrelated #6695(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/fromoptionalfpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/fromcompletionstagefpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/fromstreamfpng); merging 6765 ;3x release vs java 8 support on android;""recently the news came that [android studio 4 will support]( a so-called """"desugaring"""" of java 8 apis (ie some kind of auto-backport for target devices not supporting newer api levels as i understand) this would allow rxjava 3 to increase the baseline support to java 8 on its surface api:- `stream` support- stream `collector`s support- `optional` support- `completablefuture` support- use site non-null annotationssome features wont be supported:- `javatimeduration`: allocates well stick to time+unit- `javautilfunction`: these cant throw `throwable`s overloads would create bloat and/or ambiguitythe main issue with androids java 8 support is timing related to the pledged release schedule of rxjava 3x **end of december 2019** agp 4 may not release for months inclining us to:- wait for agps release effectively parking rxjava 3 for months as release candidate drawback: agp may slip a lot- release on schedule with java 6 baseline drawback: agp may release shortly after and thus  - wed be stuck on 3x for years  - wed have to start working on 4x undermining 3x in a sense also adding more maintenance burden  - we release 31 with baseline 8 abandoning 30 and possibly violating some pledge- release on schedule with java 8 baseline drawback: 3x improvements wont be available to many at release- release on schedule with java 8 bytecode output but no 8 api use add those in 31 drawback: despite best efforts this could cause problems with existing desugaring/toolingthe same issue is likely to arise with the next step java 9 support on android from our perspective support for the flow* interfaces would be just enough as none of the other 9 features would work (varhandles - field reflection anomalies? cleaner - portable? modules?) beyond 9 the next major change to rxjava would have to come due to value types (no version eta yet) loom/fibers is likely simply an api expansion not a fundamental changesuggestions ideas welcome "";""just some of my thoughtsim not a fan of the 1st option because literally nobody wins people can still use rxjava 2 before agp 4 comes out i think the 3rd option makes a lot more sense than the 1stfor java 9 support only supporting flow* interfaces to me doesnt justify requiring java 9 as interoperating between the interfaces is pretty easyif i had to pick an option id stick with java 6 ive been using rxjava 2 with java 8 on the server side and not supporting java 8 out-of-the-box does not feel like much of a hindrance since the interop library is pretty nice and easy to use also not requiring java 8 is imo one of the distinguishing features of rxjava vs reactor coreim also okay with supporting java 8 from the start and releasing on schedule if rxjava 3 is set to support java 8 it makes no sense to me to delay the initial release or to release it without java 8 features || in my opinion if java 6 is a must then go with rxjava2 the best option to me seems to be the third although it means postponing some improvements that may come up gradually in the form of patchesand maybe java 11 would be a better choice than java 9 in the future? just thinking out loud || > and maybe java 11 would be a better choice than java 9 in the future? just thinking out loudi think requiring a newer java version only makes sense if that version has features that are beneficial to rxjava for java 8 its `stream`s `completablefuture`s etc for java 9 its `flow*` and potentially `cleaner`? i dont think java 11 has anything worthwhile || +1 for option 3 || from androids perspective you do not need to wait for desguaring to ship to use the types mentioned * `stream`: presumably this would only exist as a static factory for creating an `observable`/`flowable` from a `stream` in which case this would only be callable on api 24+ * `collector`: this would exist as a blocking consumer member method on `observable`/`flowable` which would only be callable on api 24+ * `completablefuture`: factory methods and conversion method for `completable` and `single` which would only be callable on api 24+ * `optional`: not sure what this would be used for factory method for `maybe`? if so would only be callable on api 24+ * `type_use` annotations: have been removed by the build tooling for at least a year or twoas long as none of the critical path uses these types and theyre only used as leaf sources created by factories or leaf converters implemented as operators the rest of the api will work fine and these types will only be usable on api 24+when desugaring does ship these apis will magically work on older apis without any change necessary there is no need to wait for it to launchas to `duration` while you shouldnt use it internally because it allocates its still _very_ useful for apis that accept timeouts or intervals so that you can carry the scalar and unit as a single value and store it as a type-safe constant internally rxjava can immediately convert it to millis or its preferred unit this also could still be used today provided its done as overloads which immediately convert into long those apis would only work on api 26+ until desugaring launches when theyd become magically available on older versionsso basically i vote 3 as well || > as to `duration` while you shouldnt use it internally because it allocates its still very useful for apis that accept timeouts or intervals so that you can carry the scalar and unit as a single value and store it as a type-safe constant internally rxjava can immediately convert it to millis or its preferred unit this also could still be used today provided its done as overloads which immediately convert into long those apis would only work on api 26+ until desugaring launches when theyd become magically available on older versionsas an example ok does this: || +1 to everything jake mentioned its quite standard to compile against java 8 in android projects these days since the original introduction of desugar androids linter protects against usage of any java 8 apis that wouldnt be covered under desugar so theres no danger for consumers either as long as theyre just top-level conversion apis like jake described above || what do you mean by """"leaf""""? the following api integrations would be possible with java 8:```javapublic static <t> flowable<t> fromstream(stream<t> stream)public static <t> flowable<t> fromcompletionstage(completionstage<t> cs)public static <t> flowable<t> fromoptional(optional<t> option)// -----public stream<t> blockingtostream()public completionstage<t> firstelementstage()public completionstage<t> firstorerrorstage()public completionstage<t> singleelementstage()public completionstage<t> singleorerrorstage()public completionstage<t> lastelementstage()public completionstage<t> lastorerrorstage()public <t a c r> single<r> collect(collector<t a c r> collector)public <r> flowable<r> mapoptional(function<t optional<r>> mapper)public <r> flowable<r> flatmapstream(function<t stream<r>> mapper)```so 3 static methods 10 instance methods with otherwise isolated implementations (existing operators wouldnt use java 8 features such as `objects` or java 8 types nor the backing implementations of these)one risk is java 8s `objects` by the way as a java 8 compiler sometimes inserts it into the compiled output even though the source didnt mention it (example: #5966) || im pretty sure `objects` is available on java 7 also wasnt  caused by [error-prone]( || `objectsrequirenonnull` has also been desugared automatically since agp 30 || i have cobbled together a [small library]( that uses java 8 api and features ive created a basic android studio 352 project using it from maven local and kept modifying the `compilesdkversion` `minsdkversion` and `targetsdkversion` to 14 24 and 29- 14: methods with `stream` `completionstage` `duration` and `optional` wont compile- 24: methods with `duration` wont compile- 29: okayalso tried as 4 canary 5- 14: `completablefuture` gives ide error (minsdk > 24 required) the project deploys successfully but fails at runtime with missing class `completionstage` interface gives no error but its methods do- 24: okay- 29: okay || > what do you mean by """"leaf""""?having no internal callers all of your listed examples above seem like they fit the bill as long as these operators and factories are not used internally (unless by overloads/similar functionality) theyll simply be unused for people who cannot use those types due to the newapi lint check || if i try the library with a `javaversionversion_1_7` android project not calling any of the jdk 8 apis i get the error> the dependency contains java 8 bytecode please enable desugaring by adding the following to build requiring the compile options set to 18 is such version leap on a project otherwise not using java 8 dependencies or features going to be fine? || it is becoming common for libraries to do this nowadays yes java 8 is ancient at this point and the fact that the android tooling has not made it the default is ridiculous ok did it 9 months ago and its one of the most popular libraries on the platform:  || okay lets upgrade to rxjava 8 baseline and release without delaying too much || progress tracked in #6776 || "";1;0;annotate return type argument to flowable<@nonnull t>;"
6769;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;[3.x] remove deprecated method from 2.x;;;0;[3x] remove deprecated method from 2x;; merging 6769 ;;;;1;1;remove deprecated method from 2x;
6770;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;[3.x] replace some objecshelpers methods with java 8 apis;;;0;[3x] replace some objecshelpers methods with java 8 apis;;these are all desugared as of agp 35 ||  merging 6770 ;;;;1;1;replace some objecshelpers methods with java 8 apis;
6771;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;[3.x] replace objecthelper.requirenonnull with objects.requirenonnull;it big.;;0;[3x] replace objecthelperrequirenonnull with objectsrequirenonnull;it big; merging 6771 ;;;;1;1;replace objecthelperrequirenonnull with objectsrequirenonnull;
"6773;1;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add functionalinterface annotations.;6768;;676.0;add functionalinterface annotations;6768; merging 6773  < ;api design review: safeobserver via reflection or marker interface;the `safeobserver` wrapper is applied to all `observer` implementations passed into `observablesubscribe` by users but it is not applied to any `observer` implementations that originate from within the `rxoperators` packagethis is so we achieve the desired safety and error handling while not paying the cost of wrapping trusted `observer` implementations from internal operatorstoday it uses reflection to look at the package the `observer` originates from it then caches this information for performance  see here:  and here:   is not pretty but it worksthe other way is we could put marker interfaces such as `trustedobserver` on all `observer` implementations we use in `rxoperators` or elsewhere that should not be wrappedpros:- doesnt involve reflection- obvious- can be used by non-internal operatorscons:- marker interfaces require remembering to put them where they should be- they can be put where theyre not supposed to be- can be used by non-internal operators and misused- they are an extra type to maintain in the public api serving little valueneither approach is pretty is there another approach? if not which of these two is preferable and why?/cc @headinthebox and @jhusain;""since `observable` code changes often enough those links will become wrong so here is the valid code:``` java/**     * whether a given {@link function} is an internal implementation inside     * rx* packages or not     * <p>     * for why this is being used see     *  for discussion on     * """"guideline 64: protect calls to user code from within an operator""""     *      * note: if strong reasons for not depending on package names comes up then     * the implementation of this method can change to looking for a marker     * interface     *      * @param o     * @return {@code true} if the given function is an internal implementation     *         and {@code false} otherwise     */    private boolean isinternalimplementation(object o) {        if (o  null) {            return true        }        // prevent double-wrapping (yeah it happens)        if (o instanceof safeobserver) {            return true        }        class<?> clazz  ogetclass()        if (internalclassmapcontainskey(clazz)) {            //dont need to do reflection            return internalclassmapget(clazz)        } else {            // we treat the following package as """"internal"""" and dont wrap it            package p  ogetclass()getpackage() // it can be null            boolean isinternal  (p ! null && pgetname()startswith(""""rxoperators""""))            internalclassmapput(clazz isinternal)            return isinternal        }    }`````` javaif (isinternalimplementation(observer)) {                subscription s  onsubscribefunctiononsubscribe(observer)                if (s  null) {                    // this generally shouldnt be the case on a trusted onsubscribe but in case it happens                    // we want to gracefully handle it the same as safeobservablesubscription does                    return hookonsubscribereturn(this subscriptionsempty())                } else {                    return hookonsubscribereturn(this s)                }            } else {                safeobservablesubscription subscription  new safeobservablesubscription()                subscriptionwrap(onsubscribefunctiononsubscribe(new safeobserver<t>(subscription observer)))                return hookonsubscribereturn(this subscription)            }``` || fwiw id lean toward option 2 (wouldnt this still result in using reflection though since youd have to check for the annotation at runtime?)> marker interfaces require remembering to put them where they should betrue is this something that could be caught using static analysis?> they can be put where theyre not supposed to bebut so can any class level annotation and it can be made only applicable to classes via the target property i dont see this being an issue really> can be used by non-internal operators and misusedsure then again whoever misuses this to mark a misbehaving observer as trusted is only shooting themselves in the foot? you get what you ask for :-) > they are an extra type to maintain in the public api serving little valueare you referring to the marker interface? whats the maintenance overhead though apart from having to remember applying it to internal observers?would be interested in hearing what others have to say || another option ive become more comfortable with (and that @headinthebox prefers) is that we add `observableunsafesubscribe` that `operator` implementations can use and it does what it says  subscribe without any """"safety"""" wrapping it would directly invoke the inner `onsubscribe` function || yes thats what i would prefer ^f for """"unsafe"""" during code reviews to spot where people may shoot themselves in the foot that dont know what they are doing but allow full power in case you need to implement a new operator || i see i would find it a bit odd though to find unsafesubscribe invocationsthroughout my client code even when i know its safe it would raise eyebrows for people not as familiar with the peculiarities of the library || do you create operators that act on nested observables? examples are `repeat` `retry` `merge`those are the only scenario where an `unsafesubscribe` is needed otherwise normal `operator` implementations like `map` `take` `filter` etc do not need to || here is an example location where it is doing an """"unsafe subscribe"""":  in `map` youll see it never subscribes because it is a `subscriber` -> `subscriber` transformation that gets lifted into the `observable`:  || i intend on doing this in 018 along with `scheduler` changes do my last explanations make sense or is there still concern about this change?the only time when this will need to be used is when implementing operators that do nested subscriptions  || +1on mon mar 31 2014 at 7:34 pm ben christensennotifications@githubcomwrote:> i intend on doing this in 018 along with scheduler changes do my last> explanations make sense or is there still concern about this change?> > the only time when this will need to be used is when implementing> operators that do nested subscriptions> > > reply to this email directly or view it on github  || thanks for the positive confirmation @mttkay  ill proceed with this || completed in  || "";1;0;add functionalinterface annotations;"
6778;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;3.x: javadocs package-info made nicer  update readme regarding java 8;- update  readme.md  and indicate java 8 requirement.;;0;3x: javadocs package-info made nicer update readme regarding java 8;- update `readmemd` and indicate java 8 requirement- enable `@nullable` to be put on type parameters and type uses- add links to components in various `package-infojava` documentations  for easier navigation in the javadocs summary; merging 6778 ;;;;1;1;3x: javadocs package-info made nicer update readme regarding java 8;
6779;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: [java 8] add blockingstream & flatmapstream to flowable;add java 8 interoperation methods to  flowable :;;6776.0;3x: [java 8] add blockingstream & flatmapstream to flowable;add java 8 interoperation methods to `flowable`:- `blockingstream` - essentially `blockingiterable` with close support- `concatmapstream` - map and concatenate streams- `flatmapstream` - map and concatenate streams inherently same as `concatmapstream`related #6776 marbles:(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/blockingstreamfpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/blockingstreamfipng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/concatmapstreamfpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/concatmapstreamfipng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flatmapstreamfpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flatmapstreamfipng); merging 6779  < ;3x: [java 8] add operators supporting the newer platform [tracking issue];this issue tracks the new java 8-related operators to be implemented-  `flowablefromoptional`-  `flowablefromstream`-  `flowablefromcompletionstage`-  `flowablemapoptional`-  `flowablecollect(collector)`-  `flowablefirststage`-  `flowablesinglestage`-  `flowablelaststage`-  `flowablefirstorerrorstage`-  `flowablesingleorerrorstage`- [x] `flowablelastorerrorstage`- [x] `flowableblockingstream` + 1- [x] `flowableflatmapstream` + 1- [x] `flowableconcatmapstream` + 1------ [x] `observablefromoptional`- [x] `observablefromstream`- [x] `observablefromcompletionstage`- [x] `observablemapoptional`- [x] `observablecollect(collector)`- [x] `observablefirststage`- [x] `observablesinglestage`- [x] `observablelaststage`- [x] `observablefirstorerrorstage`- [x] `observablesingleorerrorstage`- [x] `observablelastorerrorstage`- [x] `observableblockingstream` + 1- [x] `observableflatmapstream`- [x] `observableconcatmapstream`------ [x] `maybefromoptional`- [x] `maybefromcompletionstage`- [x] `maybemapoptional`- [x] `maybetocompletionstage()` + 1- [x] `maybeflattenstreamasflowable`- [x] `maybeflattenstreamasobservable`------ [x] `singlefromcompletionstage`- [x] `singlemapoptional` returns `maybe<t>`- [x] `singletocompletionstage()`- [x] `singleflattenstreamasflowable`- [x] `singleflattenstreamasobservable`------ [x] `completablefromcompletionstage`- [x] `completabletocompletionstage`------ [x] `parallelflowablemapoptional`- [x] `parallelflowableflatmapstream`- [x] `parallelflowablecollect(collector)` returns `flowable`;~how about eliminating the plural sibling classes and moving their static factories onto the main class? for example the factories on `disposables` can be moved to `disposable`~nevermind this isnt operator-related ill just send a pr! || will android desugaring be able to work with that? || yep supported since agp 32 well over a year now || the previously `???` marked entries will be better implemented externally for now (rxjavaextensions) ||;1;0;3x: [java 8] add blockingstream & flatmapstream to flowable;
"6780;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: [java 8] add autocloseable <-> disposable conversions  nicen docs;add  disposables.fromautocloseable  and  disposables.toautocloseable  methods. improve javadocs styling.;;677.0;3x: [java 8] add autocloseable <-> disposable conversions nicen docs;add `disposablesfromautocloseable` and `disposablestoautocloseable` methods improve javadocs styling6772resolves #6777;you could also do```javainterface disposable extends autocloseable {  boolean isdisposed()  void dispose()  default void close() {    dispose()  }}``` ||  merging 6780 ;api design review: replay selector t -> r without connectableobservable;why are there `replay` overloads that:- convert from t to r like a `map` operator?- return `observable` instead of `connectableobservable`?``` javapublic <r> observable<r> replay(func1<? super observable<t> ? extends observable<r>> selector)```it seems that someone should just use `observablemap(t -> r)replay()` and that it should always return `connectableobservable`/cc @headinthebox and @jhusain;""i never understood this operator and the current implementation works different than rxnet``` javapublic class replaymulticast {    public static void main(string args) {        observable<integer> source  observablefrom(1 2 3 4)                doonnext(v -> {                     systemoutprintln(""""sideeffect"""")                 })        observable<integer> result  sourcereplay(o -> otake(2))        for (int i  1 i < 3 i++) {            systemoutprintf(""""- %d -%n"""" i)            resultsubscribe(systemout::println throwable::printstacktrace                     () -> systemoutprintln(""""done"""")            )        }    }}```that prints```- 1 -sideeffect1sideeffect2donesideeffectsideeffect- 2 -sideeffect1sideeffect2donesideeffectsideeffect```an infinite stream would never stoprxnet prints```- 1 -sideeffect1sideeffect2done- 2 -sideeffect1sideeffect2done```regardless i dont get the operator || replay has way to many overloads  (personally i never use replay so i am not the right person to ask which ones to keep :-) || @headinthebox now is the time for a review of these and deleting any if we want to  || can you specify which ones so we dont confuse each other on subjective non-obvious decisions? || here are all the overloadsthe ones that create a `connectableobservable`:```connectableobservable<t> replay()connectableobservable<t> replay(int buffersize) connectableobservable<t> replay(int buffersize long time timeunit unit)connectableobservable<t> replay(int buffersize long time timeunit unit scheduler scheduler)connectableobservable<t> replay(int buffersize scheduler scheduler)connectableobservable<t> replay(long time timeunit unit)connectableobservable<t> replay(long time timeunit unit scheduler scheduler)connectableobservable<t> replay(scheduler scheduler)```and the corresponding ones that take a function and create a  regular observable:```observable<r> replay(func1<? super observable<t> ? extends observable<r>> selector)observable<r> replay(func1<? super observable<t> ? extends observable<r>> selector final int buffersize) observable<r> replay(func1<? super observable<t> ? extends observable<r>> selector int buffersize long time timeunit unit)observable<r> replay(func1<? super observable<t> ? extends observable<r>> selector final int buffersize final long time final timeunit unit final scheduler scheduler)observable<r> replay(func1<? super observable<t> ? extends observable<r>> selector final int buffersize final scheduler scheduler) observable<r> replay(func1<? super observable<t> ? extends observable<r>> selector long time timeunit unit) observable<r> replay(func1<? super observable<t> ? extends observable<r>> selector final long time final timeunit unit final scheduler scheduler)observable<r> replay(func1<? super observable<t> ? extends observable<r>> selector final scheduler scheduler)```these latter ones are similar to the `publish` overload that takes a function `observable<r> publish(func1<? super observable<t> ? extends observable<r>> selector)` where the source observable is published _inside_ the functionif you like `replay` (which i personally dont in fact i have not used it in the last 2 years) all the overloads make sense so unfortunately i guess that if we keep replay we need all of them || @akarnokd the net behavior is the correct one when you call `sourcereplay(replayedsource -> replayedsourcetake(2))` the function gets a private copy sourcereplay() that it can use since `source` is finite it should replay the side effects and take the first two elements || @headinthebox thanks i suspected so luckily the issue i mentioned above was  and rxjava should behave as rxnet now || @akarnokd great! and @benjchristensen sorry for not being able to prune this bunch but it makes rx extra `super` :-) || closing out  review has decided that what we have is what we wantthanks @akarnokd and @headinthebox  || "";1;0;3x: [java 8] add autocloseable <-> disposable conversions nicen docs;"
6780;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: [java 8] add autocloseable <-> disposable conversions  nicen docs;add  disposables.fromautocloseable  and  disposables.toautocloseable  methods. improve javadocs styling.;;6772.0;3x: [java 8] add autocloseable <-> disposable conversions nicen docs;add `disposablesfromautocloseable` and `disposablestoautocloseable` methods improve javadocs styling6772resolves #6777;you could also do```javainterface disposable extends autocloseable {  boolean isdisposed()  void dispose()  default void close() {    dispose()  }}``` ||  merging 6780 ;3x: [java 8] add disposablesfromautocloseable;similar to the other `disposablesfromx` add a variant that wraps an `autocloseable`;;1;0;3x: [java 8] add autocloseable <-> disposable conversions nicen docs;
6781;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: migrate disposables static factories to disposable interface;;;0;3x: migrate disposables static factories to disposable interface;; merging 6781 ;;;;1;1;migrate disposables static factories to disposable interface;
6783;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: [java 8] add fromopt/stage  mapoptional  tocompletionstage to m/s/c;add the following java 8 operators to various reactive base classes:;;6776.0;3x: [java 8] add fromopt/stage mapoptional tocompletionstage to m/s/c;add the following java 8 operators to various reactive base classes:| operator | `maybe` | `single` | `completable` ||---|:---:|:---:|:---:|| `fromoptional` | ( | (1) | (2) || `fromcompletionstage` | ![image]( | ![image]( | ![image]( || `mapoptional` | ![image]( | ![image]( | (3) || `tocompletionstage` | ![image]( | ![image]( | (4) || `tocompletionstage(t)` | ![image]( | (5) | ![image]( |1 should it be implemented as `optionalempty() -> singleerror(new nosuchelementexception())`?2 no reason to implement always `completablecomplete()`3 no value to map4 no value to emit thus it is better to ask the user for a completion value5 never empty no reason to implementrelated #6776 marbles:![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/fromoptionalmpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/fromcompletionstagespng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/fromcompletionstagecpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mapoptionalmpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mapoptionalspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/tocompletionstagempng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/tocompletionstagemvpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/tocompletionstagespng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/tocompletionstagecpng); merging 6783  < ;3x: [java 8] add operators supporting the newer platform [tracking issue];this issue tracks the new java 8-related operators to be implemented-  `flowablefromoptional`-  `flowablefromstream`-  `flowablefromcompletionstage`-  `flowablemapoptional`-  `flowablecollect(collector)`-  `flowablefirststage`-  `flowablesinglestage`-  `flowablelaststage`-  `flowablefirstorerrorstage`-  `flowablesingleorerrorstage`- [x] `flowablelastorerrorstage`- [x] `flowableblockingstream` + 1- [x] `flowableflatmapstream` + 1- [x] `flowableconcatmapstream` + 1------ [x] `observablefromoptional`- [x] `observablefromstream`- [x] `observablefromcompletionstage`- [x] `observablemapoptional`- [x] `observablecollect(collector)`- [x] `observablefirststage`- [x] `observablesinglestage`- [x] `observablelaststage`- [x] `observablefirstorerrorstage`- [x] `observablesingleorerrorstage`- [x] `observablelastorerrorstage`- [x] `observableblockingstream` + 1- [x] `observableflatmapstream`- [x] `observableconcatmapstream`------ [x] `maybefromoptional`- [x] `maybefromcompletionstage`- [x] `maybemapoptional`- [x] `maybetocompletionstage()` + 1- [x] `maybeflattenstreamasflowable`- [x] `maybeflattenstreamasobservable`------ [x] `singlefromcompletionstage`- [x] `singlemapoptional` returns `maybe<t>`- [x] `singletocompletionstage()`- [x] `singleflattenstreamasflowable`- [x] `singleflattenstreamasobservable`------ [x] `completablefromcompletionstage`- [x] `completabletocompletionstage`------ [x] `parallelflowablemapoptional`- [x] `parallelflowableflatmapstream`- [x] `parallelflowablecollect(collector)` returns `flowable`;~how about eliminating the plural sibling classes and moving their static factories onto the main class? for example the factories on `disposables` can be moved to `disposable`~nevermind this isnt operator-related ill just send a pr! || will android desugaring be able to work with that? || yep supported since agp 32 well over a year now || the previously `???` marked entries will be better implemented externally for now (rxjavaextensions) ||;1;0;3x: [java 8] add fromopt/stage mapoptional tocompletionstage to m/s/c;
6785;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: cleanup and prettify javadocs  widen xoperator throws;this pr clears up some javadocs and widens the  throws  on the various  operator  interfaces:;;0;3x: cleanup and prettify javadocs widen xoperator throws;this pr clears up some javadocs and widens the `throws` on the various `operator` interfaces:- link to `integermax_value` and `longmax_value`s- add links to types and `{@code thetype}` for other appearances- wrap event type indicators into `{@code }` tags- wrap boolean outcomes into `{@code }` tags- wrap null mentions into `{@code }` tags- apply nullability annotations- fix wording and copy-paste errors; merging 6785 ;;;;1;1;fix a wrong tag name;
6786;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;diamond operators in unit tests  observable package;hello  in this pull request i ve changed all ide marked explicit types with diamond operator. affected package is internal/operators/observable. there is one test fail in completabletest.repeatnormal   but diamond is not the cause  there is last stack entry:;;6767.0;diamond operators in unit tests observable package;hello in this pull request ive changed all ide marked explicit types with diamond operator affected package is internal/operators/observable there is one test fail in completabletestrepeatnormal  but diamond is not the cause there is last stack entry: javalangassertionerror: expected:<6> but was:<5>	at orgjunitassertfail(assertjava:88)this pr is part of  #6767 issue resolving; merging 6786 ;3x: [java 8] use diamond <> where possible in unit tests;the upgrade to java 8 caused more than 4000 locations to report as diamond capable including regular classes and testsin the first round fix the unit test files but beware:- do not change the non-test files yet (avoid conflict with other cleanups and java 8 additions)- do not change the existing tests functional interface usages to lambdas (undoing lambdaification is extremely painful because tools guess the inner class types wrong almost always)- on a rare occasion the warning is wrong in the ide and breaks the gradle compilation with javacid appreciate this to be split between several prs or ~100 file changes per pr tops to still be able to review them on github;hello! ive made several prs with ~100 file changes in each more detailed information is in prs || done ||;1;0;diamond operators in unit tests observable package;
6787;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;diamond operators in unit tests  flowable package;hello  in this pull request i ve changed all ide marked explicit types with diamond operator. affected package is internal/operators/flowable.;;6767.0;diamond operators in unit tests flowable package;hello in this pull request ive changed all ide marked explicit types with diamond operator affected package is internal/operators/flowable there is one test fail in completabletestrepeatnormal  but diamond is not the cause there is last stack entry: javalangassertionerror: expected:<6> but was:<5>	at orgjunitassertfail(assertjava:88)this pr is part of  #6767 issue resolving;;3x: [java 8] use diamond <> where possible in unit tests;the upgrade to java 8 caused more than 4000 locations to report as diamond capable including regular classes and testsin the first round fix the unit test files but beware:- do not change the non-test files yet (avoid conflict with other cleanups and java 8 additions)- do not change the existing tests functional interface usages to lambdas (undoing lambdaification is extremely painful because tools guess the inner class types wrong almost always)- on a rare occasion the warning is wrong in the ide and breaks the gradle compilation with javacid appreciate this to be split between several prs or ~100 file changes per pr tops to still be able to review them on github;hello! ive made several prs with ~100 file changes in each more detailed information is in prs || done ||;1;0;diamond operators in unit tests flowable package;
6788;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;diamond operators in tests;hello  in this pull request i ve changed all ide marked explicit types with diamond operator. affected packages is internal/   internal/operators/.;;6767.0;diamond operators in tests;hello in this pull request ive changed all ide marked explicit types with diamond operator affected packages is internal/  internal/operators/there is one test fail in completabletestrepeatnormal  but diamond is not the cause there is last stack entry: javalangassertionerror: expected:<6> but was:<5>	at orgjunitassertfail(assertjava:88)this pr is part of  #6767 issue resolving; merging 6788  < ;3x: [java 8] use diamond <> where possible in unit tests;the upgrade to java 8 caused more than 4000 locations to report as diamond capable including regular classes and testsin the first round fix the unit test files but beware:- do not change the non-test files yet (avoid conflict with other cleanups and java 8 additions)- do not change the existing tests functional interface usages to lambdas (undoing lambdaification is extremely painful because tools guess the inner class types wrong almost always)- on a rare occasion the warning is wrong in the ide and breaks the gradle compilation with javacid appreciate this to be split between several prs or ~100 file changes per pr tops to still be able to review them on github;hello! ive made several prs with ~100 file changes in each more detailed information is in prs || done ||;1;0;diamond operators in unit tests small packages in internal/operators;
6789;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;diamond operators in tests  small packages;hello  in this pull request i ve changed all ide marked explicit types with diamond operator. affected packages is in tests root.;;6767.0;diamond operators in tests small packages;hello in this pull request ive changed all ide marked explicit types with diamond operator affected packages is in tests rootthere is one test fail in completabletestrepeatnormal  but diamond is not the cause there is last stack entry: javalangassertionerror: expected:<6> but was:<5>	at orgjunitassertfail(assertjava:88)this pr is part of  #6767 issue resolving; merging 6789 ;3x: [java 8] use diamond <> where possible in unit tests;the upgrade to java 8 caused more than 4000 locations to report as diamond capable including regular classes and testsin the first round fix the unit test files but beware:- do not change the non-test files yet (avoid conflict with other cleanups and java 8 additions)- do not change the existing tests functional interface usages to lambdas (undoing lambdaification is extremely painful because tools guess the inner class types wrong almost always)- on a rare occasion the warning is wrong in the ide and breaks the gradle compilation with javacid appreciate this to be split between several prs or ~100 file changes per pr tops to still be able to review them on github;hello! ive made several prs with ~100 file changes in each more detailed information is in prs || done ||;1;0;diamond operators in unit tests small packages;
"6790;1;0;0;0;0;1;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: remove now unnecessary unchecked warning suppressions;most varargs places now have  @safevarargs  so there is no need for  @suppresswarnings( unchecked ) . some non-test classes need still updating though.;;0;3x: remove now unnecessary unchecked warning suppressions;""most varargs places now have `@safevarargs` so there is no need for `@suppresswarnings(""""unchecked"""")` some non-test classes need still updating though""; merging 6790 ;;;;1;1;3x: remove now unnecessary unchecked warning suppressions;"
"6791;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: add nonnull & safevarargs annotations + validator;this pr cleans up the main classes:;;676.0;3x: add nonnull & safevarargs annotations + validator;this pr cleans up the main classes:- add missing `@nonnull` annotations- add missing `@safevarargs` annotations- add validator code that scans the sources to verify the annotations are present- remove unnecessary `@suppresswarnings` annotations- fix a few type argumentsrelated #6766; merging 6791 ;api design review: safeobserver via reflection or marker interface;the `safeobserver` wrapper is applied to all `observer` implementations passed into `observablesubscribe` by users but it is not applied to any `observer` implementations that originate from within the `rxoperators` packagethis is so we achieve the desired safety and error handling while not paying the cost of wrapping trusted `observer` implementations from internal operatorstoday it uses reflection to look at the package the `observer` originates from it then caches this information for performance  see here:  and here:   is not pretty but it worksthe other way is we could put marker interfaces such as `trustedobserver` on all `observer` implementations we use in `rxoperators` or elsewhere that should not be wrappedpros:- doesnt involve reflection- obvious- can be used by non-internal operatorscons:- marker interfaces require remembering to put them where they should be- they can be put where theyre not supposed to be- can be used by non-internal operators and misused- they are an extra type to maintain in the public api serving little valueneither approach is pretty is there another approach? if not which of these two is preferable and why?/cc @headinthebox and @jhusain;""since `observable` code changes often enough those links will become wrong so here is the valid code:``` java/**     * whether a given {@link function} is an internal implementation inside     * rx* packages or not     * <p>     * for why this is being used see     *  for discussion on     * """"guideline 64: protect calls to user code from within an operator""""     *      * note: if strong reasons for not depending on package names comes up then     * the implementation of this method can change to looking for a marker     * interface     *      * @param o     * @return {@code true} if the given function is an internal implementation     *         and {@code false} otherwise     */    private boolean isinternalimplementation(object o) {        if (o  null) {            return true        }        // prevent double-wrapping (yeah it happens)        if (o instanceof safeobserver) {            return true        }        class<?> clazz  ogetclass()        if (internalclassmapcontainskey(clazz)) {            //dont need to do reflection            return internalclassmapget(clazz)        } else {            // we treat the following package as """"internal"""" and dont wrap it            package p  ogetclass()getpackage() // it can be null            boolean isinternal  (p ! null && pgetname()startswith(""""rxoperators""""))            internalclassmapput(clazz isinternal)            return isinternal        }    }`````` javaif (isinternalimplementation(observer)) {                subscription s  onsubscribefunctiononsubscribe(observer)                if (s  null) {                    // this generally shouldnt be the case on a trusted onsubscribe but in case it happens                    // we want to gracefully handle it the same as safeobservablesubscription does                    return hookonsubscribereturn(this subscriptionsempty())                } else {                    return hookonsubscribereturn(this s)                }            } else {                safeobservablesubscription subscription  new safeobservablesubscription()                subscriptionwrap(onsubscribefunctiononsubscribe(new safeobserver<t>(subscription observer)))                return hookonsubscribereturn(this subscription)            }``` || fwiw id lean toward option 2 (wouldnt this still result in using reflection though since youd have to check for the annotation at runtime?)> marker interfaces require remembering to put them where they should betrue is this something that could be caught using static analysis?> they can be put where theyre not supposed to bebut so can any class level annotation and it can be made only applicable to classes via the target property i dont see this being an issue really> can be used by non-internal operators and misusedsure then again whoever misuses this to mark a misbehaving observer as trusted is only shooting themselves in the foot? you get what you ask for :-) > they are an extra type to maintain in the public api serving little valueare you referring to the marker interface? whats the maintenance overhead though apart from having to remember applying it to internal observers?would be interested in hearing what others have to say || another option ive become more comfortable with (and that @headinthebox prefers) is that we add `observableunsafesubscribe` that `operator` implementations can use and it does what it says  subscribe without any """"safety"""" wrapping it would directly invoke the inner `onsubscribe` function || yes thats what i would prefer ^f for """"unsafe"""" during code reviews to spot where people may shoot themselves in the foot that dont know what they are doing but allow full power in case you need to implement a new operator || i see i would find it a bit odd though to find unsafesubscribe invocationsthroughout my client code even when i know its safe it would raise eyebrows for people not as familiar with the peculiarities of the library || do you create operators that act on nested observables? examples are `repeat` `retry` `merge`those are the only scenario where an `unsafesubscribe` is needed otherwise normal `operator` implementations like `map` `take` `filter` etc do not need to || here is an example location where it is doing an """"unsafe subscribe"""":  in `map` youll see it never subscribes because it is a `subscriber` -> `subscriber` transformation that gets lifted into the `observable`:  || i intend on doing this in 018 along with `scheduler` changes do my last explanations make sense or is there still concern about this change?the only time when this will need to be used is when implementing operators that do nested subscriptions  || +1on mon mar 31 2014 at 7:34 pm ben christensennotifications@githubcomwrote:> i intend on doing this in 018 along with scheduler changes do my last> explanations make sense or is there still concern about this change?> > the only time when this will need to be used is when implementing> operators that do nested subscriptions> > > reply to this email directly or view it on github  || thanks for the positive confirmation @mttkay  ill proceed with this || completed in  || "";1;0;3x: add nonnull & safevarargs annotations + validator;"
"6795;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: add missing annotations  fix many diamonds;- improve validation code and extend them to other classes/sources.;;0;3x: add missing annotations fix many diamonds;""- improve validation code and extend them to other classes/sources- add `@nonnull` annotations- add `@safevarargs` annotations- add `@checkreturnvalue` annotations- add more `@backpressuresupport` & `@schedulersupport` annotations- add backpressure and scheduler descriptions in `parallelflowable`- remove now unnecessary `@suppresswarnings(""""unchecked"""")`- fix wording in some javadocs- move `tofunction` nullcheck into the caller method so the validation refers to the proper parameter name- use diamond arguments where possible- remove unused type arguments""; merging 6795 ;;;;1;1;fix npe in unicast due to null-cleanup;"
"6797;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: [java 8] add observable operators + cleanup;add the following java 8 operators to  observable :;;677.0;3x: [java 8] add observable operators + cleanup;add the following java 8 operators to `observable`:- `fromoptional`- `fromcompletionstage`- `fromstream`- `firststage`- `firstorerrorstage`- `singestage`- `singleorerrorstage`- `laststage`- `lastorerrorstage`- `blockingstream`- `mapoptional`- `collect`- `concatmapstream` / `flatmapstream`in addition some validators received reporting improvements (such as using ` at ` so the ide can jump to the exact line of the issue) consequently all local variable misnaming of `unicastsubject up` and `unicastprocessor us` have been  as wellrelated #6776;marbles:( ||  merging 6797 ;api design review: replay selector t -> r without connectableobservable;why are there `replay` overloads that:- convert from t to r like a `map` operator?- return `observable` instead of `connectableobservable`?``` javapublic <r> observable<r> replay(func1<? super observable<t> ? extends observable<r>> selector)```it seems that someone should just use `observablemap(t -> r)replay()` and that it should always return `connectableobservable`/cc @headinthebox and @jhusain;""i never understood this operator and the current implementation works different than rxnet``` javapublic class replaymulticast {    public static void main(string args) {        observable<integer> source  observablefrom(1 2 3 4)                doonnext(v -> {                     systemoutprintln(""""sideeffect"""")                 })        observable<integer> result  sourcereplay(o -> otake(2))        for (int i  1 i < 3 i++) {            systemoutprintf(""""- %d -%n"""" i)            resultsubscribe(systemout::println throwable::printstacktrace                     () -> systemoutprintln(""""done"""")            )        }    }}```that prints```- 1 -sideeffect1sideeffect2donesideeffectsideeffect- 2 -sideeffect1sideeffect2donesideeffectsideeffect```an infinite stream would never stoprxnet prints```- 1 -sideeffect1sideeffect2done- 2 -sideeffect1sideeffect2done```regardless i dont get the operator || replay has way to many overloads  (personally i never use replay so i am not the right person to ask which ones to keep :-) || @headinthebox now is the time for a review of these and deleting any if we want to  || can you specify which ones so we dont confuse each other on subjective non-obvious decisions? || here are all the overloadsthe ones that create a `connectableobservable`:```connectableobservable<t> replay()connectableobservable<t> replay(int buffersize) connectableobservable<t> replay(int buffersize long time timeunit unit)connectableobservable<t> replay(int buffersize long time timeunit unit scheduler scheduler)connectableobservable<t> replay(int buffersize scheduler scheduler)connectableobservable<t> replay(long time timeunit unit)connectableobservable<t> replay(long time timeunit unit scheduler scheduler)connectableobservable<t> replay(scheduler scheduler)```and the corresponding ones that take a function and create a  regular observable:```observable<r> replay(func1<? super observable<t> ? extends observable<r>> selector)observable<r> replay(func1<? super observable<t> ? extends observable<r>> selector final int buffersize) observable<r> replay(func1<? super observable<t> ? extends observable<r>> selector int buffersize long time timeunit unit)observable<r> replay(func1<? super observable<t> ? extends observable<r>> selector final int buffersize final long time final timeunit unit final scheduler scheduler)observable<r> replay(func1<? super observable<t> ? extends observable<r>> selector final int buffersize final scheduler scheduler) observable<r> replay(func1<? super observable<t> ? extends observable<r>> selector long time timeunit unit) observable<r> replay(func1<? super observable<t> ? extends observable<r>> selector final long time final timeunit unit final scheduler scheduler)observable<r> replay(func1<? super observable<t> ? extends observable<r>> selector final scheduler scheduler)```these latter ones are similar to the `publish` overload that takes a function `observable<r> publish(func1<? super observable<t> ? extends observable<r>> selector)` where the source observable is published _inside_ the functionif you like `replay` (which i personally dont in fact i have not used it in the last 2 years) all the overloads make sense so unfortunately i guess that if we keep replay we need all of them || @akarnokd the net behavior is the correct one when you call `sourcereplay(replayedsource -> replayedsourcetake(2))` the function gets a private copy sourcereplay() that it can use since `source` is finite it should replay the side effects and take the first two elements || @headinthebox thanks i suspected so luckily the issue i mentioned above was  and rxjava should behave as rxnet now || @akarnokd great! and @benjchristensen sorry for not being able to prune this bunch but it makes rx extra `super` :-) || closing out  review has decided that what we have is what we wantthanks @akarnokd and @headinthebox  || "";1;0;3x: [java 8] add observable operators + cleanup;"
6798;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: [java 8] add parallelflowable operators + cleanup;add java 8 operators to the  parallelflowable  class:;;0;3x: [java 8] add parallelflowable operators + cleanup;add java 8 operators to the `parallelflowable` class:- `mapoptional` + 2- `flatmapstream` + 1- `collect`also for symmetry the `flatmapiterable` operator has also been addedcleanups:- add missing `@since` tags unify tag location- use diamond in parallel classes- fix error messages in the parallel-try operators- improve validation messages with ` at ` entries so the ide can navigate to the problematic line- add some unit tests to improve coverage of some existing parallel operators; merging 6798 ;;;;1;1;3x: [java 8] add parallelflowable operators + cleanup;
6799;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: xprocessor.offer to throw npe immediately;make  offer  throw a  nullpointerexception  immediately instead of turning it into an error signal. in addition  have  multicastprocessor.offer  throw an  illegalstateexception  if called when the processor is in fusion mode.;;6794.0;3x: xprocessoroffer to throw npe immediately;make `offer` throw a `nullpointerexception` immediately instead of turning it into an error signal in addition have `multicastprocessoroffer` throw an `illegalstateexception` if called when the processor is in fusion mode6794; merging 6799 ;3x: xprocessoroffer to throw npe instead of signaling it;change the behavior to align with the standard `onxxx` methods;;1;0;3x: xprocessoroffer to throw npe immediately;
"6800;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: add blockingforeach(consumer  int) overload;the underlying  blockingiterable  already supported the custom prefetch overload and this pr exposes it as a new  blockingforeach  overload.;;678.0;3x: add blockingforeach(consumer int) overload;the underlying `blockingiterable` already supported the custom prefetch overload and this pr exposes it as a new `blockingforeach` overloadin addition the javadocs incorrectly stated `blockingforeach` operated in an unbounded-in fashion it uses the usual stable-prefetch with 75% re-request amount6784; merging 6800 ;api design review: java 8 stream naming conventions;""lets compare against the java 8 streams api and try to match as closely to it as possible we can add aliases where it makes sense and possibly deprecate and migrate to their names if they are betterthe idea is to support java developers as they use the stream api and then want to move to async and be as similar as possibleit should try and achieve the """"[principle of least surprise]( for developersideally someone could have code written for the stream api and just swap out the `stream` for an `observable` and it """"just work""""/cc @headinthebox and @jhusain/cc @bondolo (from oracle) if you have any thoughts on this"";""unless one uses call-site lambdas """"just swapping"""" wont work due base functional type mismatch:``` javastreamfilter(v -> v % 2  0)observablefilter(v -> v % 2  0)// butpredicate<integer> p  v -> v % 2  0streamfilter(p)observablefilter(p) // type mismatchobservablefilter(p::test)```some renames/matches of functionality| stream api | observable api || --- | --- || `filter` | `where` || `maptoint` | primitive observable ??? || `sorted` | n/a || `peek` | ??? || `limit` | `take(n)` || `foreach` | `dooneach` || `toarray` | `toblockingobservable()tolist()toarray()` || `anymatch` | `exists()toblockingobservable()single()` || `count` | `count()toblockingobservable()single()` || `allmatch` | `all()toblockingobservable()single()` || `nonematch` | `all(not())toblockingobservable()single()` || `findfirst` | `materialize()toblockingobservable()first()` || `findany` | n/a would be identical to `findfirst` |some `stream` methods exit the stream this is why there are that many `toblockingobservable` calls in the table || keep the net naming and usage intact much as possible any language specific idioms can core exit with thisthis would help towards less confusion and easy portability in case you maintain a net api also this can be extended to the other language bindings also eg idiomatic scala api should ideally not hide the net of f# usage (as in this case f# being closer to scala / clojure than c#) but co exist with the idiomatic language version || i sympathize with the plight of the cross-platform rx user - i am one  however i strongly disagree with the idea of using non-idiomatic names just to make porting code between platforms easier we tried that with rxjs and it caused no end of confusion there are many rx users who use rx across platforms however there is a much larger potential audience that does not yet use rx will very likely be exposed to streams and will approach reactive programming for the first time in the next two years jdictated using voice recognition please forgive the typos> on dec 27 2013 at 6:29 am suminda dharmasena notifications@githubcom wrote:> > keep the net naming and usage intact much as possible any language specific idioms can core exit with this> > this would help towards less confusion and easy portability in case you maintain a net api also> > this can be extended to the other language bindings also eg idiomatic scala api should ideally not hide the net of f# usage (as in this case f# being closer to scala / clojure than c#)> > > reply to this email directly or view it on github || what i say is use idiomatic names wherever possible but leave the more familiar naming and usage also the idiomatic changes would be a few so there will be little overhead || best is that if there is a possibility / feasibility coordinate across the rx implementations and the net project is also open source so there is coherence and api convergence || these are the only ones that seem worth considering:| stream api | observable api || --- | --- || `filter` | `where` || `limit` | `take(n)` || `foreach` | `dooneach` |we have already done `filter` i am okay with aliasing `take` and `limit` the `foreach` name may also be good the question then is whether its a synonym with `dooneach` or `subscribe(action1<t>)` i think its the later as someone shouldnt need to `foreach(f)subscribe()`should we alias `subscribe` with `foreach`?``` javavoid foreach(action1<? super t>)void foreach(action1<? super t> action1<throwable>)void foreach(action1<? super t> action1<throwable> action0)``` || @benjchristensen i agree with the latter especially people coming from java 8 streams its not obvious that in rx you then have to subscribe in addition || ok with foreach i think rxjs has that as well || lets move ahead with this || completed in  || ``` java    public static void main(string args) {        observablefrom(1 2 3)foreach(systemout::println)        observablefrom(1 2 3)toblocking()foreach(systemout::println)        observablefrom(1 2 3)limit(2)foreach(systemout::println)    }``` || note that in javascript this method removes the data from the monadthat said we should definitely match the stream apis closely as possible for java 8dictated using voice recognition please forgive the typos> on may 20 2014 at 9:14 am headinthebox notifications@githubcom wrote:> > ok with foreach i think rxjs has that as well> > > reply to this email directly or view it on github || we have both the non-blocking and blocking forms of `foreach` now the blocking one removes it from the monad``` javaobservablefrom(1 2 3)foreach(systemout::println)observablefrom(1 2 3)toblocking()foreach(systemout::println)``` || makes sense || "";1;0;3x: add blockingforeach(consumer int) overload;"
"6801;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: add missing throwiffatal calls;- add missing  exceptions.throwiffatal  calls in  catch (throwable   blocks.;;679.0;3x: add missing throwiffatal calls;- add missing `exceptionsthrowiffatal` calls in `catch (throwable ` blocks- add validator that checks for the existence of these `throwiffatal` `wraporthrow` or `fail` calls- fix `autocloseabledisposable` to use `wraporthrow` like the other `disposable` wrapper implementations6796; merging 6801  < ;api design review: timer/interval;it seems `timer` is almost replicating `interval` but doing so with a non-obvious name an operator named `timer` suggests its related to scheduling work in the future but its actually about a stream of numberslets consider removing `timer` and improving `interval` to achieve what it doesperhaps we can also have a better name for simply getting an infinite stream of numbers (with or without time involved) perhaps an obvious name like `observablenumbers` or something equally apparent?/cc @headinthebox and @jhusain;""we also should consider the example of`observablerange(start count)` it seems like it should also be capable of doing `observablerange(start)` and just start at a value and keep counting but then its not really a `range` but thats what we want to do and dont have the ability to do || timer has the ability to determine when it first fires set an interval (just like interval) so perhaps we should remove interval sent from my ipad> on dec 23 2013 at 9:47 pm ben christensen notifications@githubcom wrote:> > it seems timer is almost replicating interval but doing so with a non-obvious name an operator named timer suggests its related to scheduling work in the future but its actually about a stream of numbers> > lets consider removing timer and improving interval to achieve what it does> > perhaps we can also have a better name for simply getting an infinite stream of numbers (with or without time involved) perhaps an obvious name like observablenumbers or something equally apparent?> > /cc @headinthebox and @jhusain> > > reply to this email directly or view it on github || interval was removed by one of my prs so i guess this is settled || they are still there right now:``` java/**     * returns an observable that emits a sequential number every specified interval of time     * <p>     * <img width""""640"""" src""""     *      * @param interval     *            interval size in time units (see below)     * @param unit     *            time units to use for the interval size     * @return an observable that emits a sequential number each time interval     * @see <a href"""" wiki: interval()</a>     * @see <a href"""" observableinterval</a>     */    public final static observable<long> interval(long interval timeunit unit) {        return create(new operatortimerperiodically(interval interval unit schedulerscomputation()))    }    /**     * returns an observable that emits a sequential number every specified interval of time on a     * specified scheduler     * <p>     * <img width""""640"""" src""""     *      * @param interval     *            interval size in time units (see below)     * @param unit     *            time units to use for the interval size     * @param scheduler     *            the scheduler to use for scheduling the items     * @return an observable that emits a sequential number each time interval     * @see <a href"""" wiki: interval()</a>     * @see <a href"""" observableinterval</a>     */    public final static observable<long> interval(long interval timeunit unit scheduler scheduler) {        return create(new operatortimerperiodically(interval interval unit scheduler))    }``` || i meant they use the same implementation as the `timer` methods and now serve as aliases || oh :-) || should we keep `interval` and `timer` in the api? || programmers coming from other flavors of rx may expect to discover `interval` || dont see why not || leaving as is  || "";1;0;3x: add missing throwiffatal calls;"
6804;1;0;0;0;0;1;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: fix diamonds  spelling  unnecessary code;- use diamond where possible;;0;3x: fix diamonds spelling unnecessary code;- use diamond where possible- remove type arguments where they can be now inferred under java 8- fix spelling errors- remove unnecessary `throws` declarations; merging 6804 ;;;;1;1;3x: fix diamonds spelling unnecessary code;
6805;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: [java 8] add flattenstreamasx to maybe/single;add;;6776.0;3x: [java 8] add flattenstreamasx to maybe/single;add- `maybeflattenstreamasflowable`- `maybeflattenstreamasobservable`- `singleflattenstreamasflowable`- `singleflattenstreamasobservable`related #6776(in addition adjust the validators to appreciate the new patterns)marbles:(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flattenstreamasflowablempng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flattenstreamasobservablempng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flattenstreamasflowablespng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flattenstreamasobservablespng); merging 6805 ;3x: [java 8] add operators supporting the newer platform [tracking issue];this issue tracks the new java 8-related operators to be implemented-  `flowablefromoptional`-  `flowablefromstream`-  `flowablefromcompletionstage`-  `flowablemapoptional`-  `flowablecollect(collector)`-  `flowablefirststage`-  `flowablesinglestage`-  `flowablelaststage`-  `flowablefirstorerrorstage`-  `flowablesingleorerrorstage`- [x] `flowablelastorerrorstage`- [x] `flowableblockingstream` + 1- [x] `flowableflatmapstream` + 1- [x] `flowableconcatmapstream` + 1------ [x] `observablefromoptional`- [x] `observablefromstream`- [x] `observablefromcompletionstage`- [x] `observablemapoptional`- [x] `observablecollect(collector)`- [x] `observablefirststage`- [x] `observablesinglestage`- [x] `observablelaststage`- [x] `observablefirstorerrorstage`- [x] `observablesingleorerrorstage`- [x] `observablelastorerrorstage`- [x] `observableblockingstream` + 1- [x] `observableflatmapstream`- [x] `observableconcatmapstream`------ [x] `maybefromoptional`- [x] `maybefromcompletionstage`- [x] `maybemapoptional`- [x] `maybetocompletionstage()` + 1- [x] `maybeflattenstreamasflowable`- [x] `maybeflattenstreamasobservable`------ [x] `singlefromcompletionstage`- [x] `singlemapoptional` returns `maybe<t>`- [x] `singletocompletionstage()`- [x] `singleflattenstreamasflowable`- [x] `singleflattenstreamasobservable`------ [x] `completablefromcompletionstage`- [x] `completabletocompletionstage`------ [x] `parallelflowablemapoptional`- [x] `parallelflowableflatmapstream`- [x] `parallelflowablecollect(collector)` returns `flowable`;~how about eliminating the plural sibling classes and moving their static factories onto the main class? for example the factories on `disposables` can be moved to `disposable`~nevermind this isnt operator-related ill just send a pr! || will android desugaring be able to work with that? || yep supported since agp 32 well over a year now || the previously `???` marked entries will be better implemented externally for now (rxjavaextensions) ||;1;0;add rs tck tests for flattenstreamasflowable;
6806;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: prettify flowable javadoc + validator;this pr unifies the javadoc style of the  flowable  type:;;0;3x: prettify flowable javadoc + validator;this pr unifies the javadoc style of the `flowable` type:- mention of `flowable` has to be `{@code flowable}`- first mention of a set of types has to be `{@link thetype}`- subsequent mention of a set of types has to be `{@code thetype}`- some keywords and method names have to be `{@code methodname}`in addition `javadocwording` has been modified to detect an additional set of wrong typename use;diff view due to a lot of changes:  ||  merging 6806 ;;;;1;1;3x: prettify flowable javadoc + validator;
6809;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: improve javadocs of completable and some others;improve the javadocs of  completable  by;;0;3x: improve javadocs of completable and some others;improve the javadocs of `completable` by- using `{@link}` and `{@code}` tags- adding `@throws` regarding parameter validation- fix wording of some operators; merging 6809 ;;;;1;1;3x: improve javadocs of completable and some others;
6812;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: improve javadocs of single;- use  {@link} s and  {@code}  tags;;0;3x: improve javadocs of single;- use `{@link}`s and `{@code}` tags- fix some wording and copy-paste mistakes- add `@throws` about argument validation throwing `nullpointerexception`s and `illegalargumentexception`s; merging 6812 ;;;;1;1;3x: improve javadocs of single;
6813;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix junit 4.13 deprecated api use;junit 4.13 deprecated the use of  expectedexception  in favor of  assertthrows .;;0;3x: fix junit 413 deprecated api use;junit 413 deprecated the use of `expectedexception` in favor of `assertthrows`; merging 6813 ;;;;1;1;3x: fix junit 413 deprecated api use;
6814;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: remove fromfuture(  scheduler) overloads;those overloads were only applying  subscribeon  with no other benefits.;;681.0;3x: remove fromfuture( scheduler) overloads;those overloads were only applying `subscribeon` with no other benefitsresolves: #6811; merging 6814 ;api design review: defaultifempty(observable);there is a `defaultifempty` that returns value `t` should we have one that accepts an `observable<t>` as a default to subscribe to? it would be like `onemptyresumenext(observable<t>)` similar to `onerrorresumenext(observable<t>)`/cc @headinthebox and @jhusain;there are several operators have a default value eg `singleordefault` `firstordefault` `lastordefault` `elementatordefault` can we add an overload that accepts a function to generate the default value? like``` javapublic final observable<t> singleordefault(func0<t> defaultvalue)```iss helpful for rxjava-scala to implement the call-by-name version of these operatorshere is `firstorelse` in rxjava-scala``` scala  def firstorelse[u >: t](default: > u): observable[u]  {    thistake(1)foldleft[option[u]](none)((v: option[u] e: u) > some(e))map({      case some(element) > element      case none > default    })  }```if we have the function overload of `firstordefault` we can implement it like``` scala  def firstorelse[u >: t](default: > u): observable[u]  {    asjavaobservablefirstordefault( () > default )  }```/cc @samuelgruetter || seems like `onemptyreturn(t t)` and `onemptyresumenext(observable<t> o)` would be better naming conventions but since we already have `defaultifempty` do we want:- `defaultifempty(t t)`- `defaultifempty(observable<t> t)` || closing as not important we can always revisit this in the future if it comes interesting again ||;1;0;3x: remove fromfuture( scheduler) overloads;
6815;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: improve javadocs of maybe;improve the javadocs by:;;0;3x: improve javadocs of maybe;improve the javadocs by:- adding `{@code}` and `{@link}` tags-  wording and copy-paste mistakes- added `@throws` for the parameter validation exceptions; merging 6815 ;;;;1;1;fix a mistake in single;
6817;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;deleted functions.naturalorder;removes a duplication of the natural order comparator.;;681.0;deleted functionsnaturalorder;removes a duplication of the natural order comparator6816; merging 6817  < ;api design review: defaultifempty(observable);there is a `defaultifempty` that returns value `t` should we have one that accepts an `observable<t>` as a default to subscribe to? it would be like `onemptyresumenext(observable<t>)` similar to `onerrorresumenext(observable<t>)`/cc @headinthebox and @jhusain;there are several operators have a default value eg `singleordefault` `firstordefault` `lastordefault` `elementatordefault` can we add an overload that accepts a function to generate the default value? like``` javapublic final observable<t> singleordefault(func0<t> defaultvalue)```iss helpful for rxjava-scala to implement the call-by-name version of these operatorshere is `firstorelse` in rxjava-scala``` scala  def firstorelse[u >: t](default: > u): observable[u]  {    thistake(1)foldleft[option[u]](none)((v: option[u] e: u) > some(e))map({      case some(element) > element      case none > default    })  }```if we have the function overload of `firstordefault` we can implement it like``` scala  def firstorelse[u >: t](default: > u): observable[u]  {    asjavaobservablefirstordefault( () > default )  }```/cc @samuelgruetter || seems like `onemptyreturn(t t)` and `onemptyresumenext(observable<t> o)` would be better naming conventions but since we already have `defaultifempty` do we want:- `defaultifempty(t t)`- `defaultifempty(observable<t> t)` || closing as not important we can always revisit this in the future if it comes interesting again ||;1;0;deleted functionsnaturalorder;
"6826;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix flowable.flatmap not canceling the inner sources on outer error;the outer  onerror  did not cancel the inner sources. the  observable  variant works correctly but both received an unit test to verify the behavior.;;6825.0;3x: fix flowableflatmap not canceling the inner sources on outer error;the outer `onerror` did not cancel the inner sources the `observable` variant works correctly but both received an unit test to verify the behavior2x will be  in a separate prrelated #6825; merging 6826  < ;2x: unexpected flowableflatmap() behavior while handling an upstream error;""hi ive discovered an unexpected behavior of the flowableflatmap() operator leading to a possible subscription leak localized my problem in the following scenario:1 rxjava version 22162 given a simple rx chain of flowable1flatmap(value -> flowable2)3 flowable1 emits a value (so that flatmap subscribes to flowable2)4 flowable1 emits an errorexpected result: flatmap disposes flowable2 upon handling the upstream erroractual result: flowable2 remains subscribed after the entire rx chain terminates because of the errorreplacing the flatmap operator with concatmap fixes the problem (such a replacement is valid in my case) however i decided to raise this issue because such behavior of flatmap looks quite odd to me could somebody from rxjava team confirm whether my expectation is valid and the observed behavior is a defect?ive reproduced this issue in a code snippet:  expecting this code to produce """"flowable2 cancelled"""" output but got """"flowable2 error"""" instead plus error2 gets thrown as undeliverableexception because it occurs after the entire chain is terminated"";""sources emitting an error are considered cancelled so it is completely legal to not call cancel on them use `dofinally` to cleanup upon all sorts of termination or cancellation || thank you for looking into this but im afraid i wasnt specific enough in my question above in the following code snippet i expected error2 to never get emitted because error1 terminates the entire flow sooner that flowable2 emits error2 however error2 actually fired (triggered an undeliverableexception) ```    final exception error1  new exception(""""1"""")    final flowable<integer> flowable1  flowablejust(1)delay(1 timeunitseconds)        concatwith(flowable<integer>error(error1)delaysubscription(1 timeunitseconds))    final exception error2  new exception(""""2"""")    final flowable<object> flowable2         flowableerror(error2)delaysubscription(2 timeunitseconds)            dooncancel(() -> systemoutprintln(""""flowable2 cancelled""""))            doonerror(error -> systemoutprintln(""""flowable2 error""""))    flowable1flatmap(i -> flowable2)test()        awaitdone(4 timeunitseconds)        asserterror(error1)```so my questions are: 1 is this an expected behavior? 2 is there a way to avoid throwing error2 as an undeliverableexception  (except for intercepting it with rxjavapluginsseterrorhandler)? 3 whats the reason of the difference in behavior between flatmap and concatmap is such conditions? || 1 no the inner sequence should get cancelled ill investigate this further2 suppressing the error via `onerrorx` or not let rxjava know about the error in the first place3 should work the same || closing via #6826 & #6827 || thank you very much for your support || "";1;0;3x: fix flowableflatmap not canceling the inner sources on outer error;"
"6827;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix flowable.flatmap not canceling the inner sources on outer error;the outer  onerror  did not cancel the inner sources. the  observable  variant works correctly but both received an unit test to verify the behavior.;;6825.0;2x: fix flowableflatmap not canceling the inner sources on outer error;the outer `onerror` did not cancel the inner sources the `observable` variant works correctly but both received an unit test to verify the behaviorfixes: #6825; merging 6827 ;2x: unexpected flowableflatmap() behavior while handling an upstream error;""hi ive discovered an unexpected behavior of the flowableflatmap() operator leading to a possible subscription leak localized my problem in the following scenario:1 rxjava version 22162 given a simple rx chain of flowable1flatmap(value -> flowable2)3 flowable1 emits a value (so that flatmap subscribes to flowable2)4 flowable1 emits an errorexpected result: flatmap disposes flowable2 upon handling the upstream erroractual result: flowable2 remains subscribed after the entire rx chain terminates because of the errorreplacing the flatmap operator with concatmap fixes the problem (such a replacement is valid in my case) however i decided to raise this issue because such behavior of flatmap looks quite odd to me could somebody from rxjava team confirm whether my expectation is valid and the observed behavior is a defect?ive reproduced this issue in a code snippet:  expecting this code to produce """"flowable2 cancelled"""" output but got """"flowable2 error"""" instead plus error2 gets thrown as undeliverableexception because it occurs after the entire chain is terminated"";""sources emitting an error are considered cancelled so it is completely legal to not call cancel on them use `dofinally` to cleanup upon all sorts of termination or cancellation || thank you for looking into this but im afraid i wasnt specific enough in my question above in the following code snippet i expected error2 to never get emitted because error1 terminates the entire flow sooner that flowable2 emits error2 however error2 actually fired (triggered an undeliverableexception) ```    final exception error1  new exception(""""1"""")    final flowable<integer> flowable1  flowablejust(1)delay(1 timeunitseconds)        concatwith(flowable<integer>error(error1)delaysubscription(1 timeunitseconds))    final exception error2  new exception(""""2"""")    final flowable<object> flowable2         flowableerror(error2)delaysubscription(2 timeunitseconds)            dooncancel(() -> systemoutprintln(""""flowable2 cancelled""""))            doonerror(error -> systemoutprintln(""""flowable2 error""""))    flowable1flatmap(i -> flowable2)test()        awaitdone(4 timeunitseconds)        asserterror(error1)```so my questions are: 1 is this an expected behavior? 2 is there a way to avoid throwing error2 as an undeliverableexception  (except for intercepting it with rxjavapluginsseterrorhandler)? 3 whats the reason of the difference in behavior between flatmap and concatmap is such conditions? || 1 no the inner sequence should get cancelled ill investigate this further2 suppressing the error via `onerrorx` or not let rxjava know about the error in the first place3 should work the same || closing via #6826 & #6827 || thank you very much for your support || "";1;0;2x: fix flowableflatmap not canceling the inner sources on outer error;"
6831;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: improve javadocs of observable and fix similar issues elsewhere;improve the javadoc of  observable :;;0;3x: improve javadocs of observable and fix similar issues elsewhere;improve the javadoc of `observable`:- use `{@code` and `{@link}` tags uniformly- improve wording of many operators- add `@throws` declaration for validation exceptions- add missing or incorrect `requirenonnull` usages- have `skiplast` and `takelast` throw `illegalargumentexception` instead of `indexoutofboundsexception`- improve the various validator tests to detect more cases- change argument names from `prefetch` to the more appropriate `buffersize`;   no coverage uploaded for pull request base (`3x@6030d83`) [click here to learn what that means]( ` ;;;;1;1;3x: improve javadocs of observable and fix similar issues elsewhere;
6835;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: cleanup javadoc for parameter validation all around;- add missing  @throws  documentation;;0;3x: cleanup javadoc for parameter validation all around;- add missing `@throws` documentation- fix wording and style of `flowable` javadocs- fix documentation style of many files- improve the validator test to detect more patterns- `skip` now rejects negative amounts with `illegalargumentexception`; merging 6835 ;;;;1;1;last set of intended changes;
6837;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: remove a pointless observable.concatmapiterable overload;remove the  concatmapiterable(function  int)  overload as there is no buffering involved with the operator.;;6828.0;3x: remove a pointless observableconcatmapiterable overload;remove the `concatmapiterable(function int)` overload as there is no buffering involved with the operator6828;;3x: inline observableconcatmapiterable and flatmapiterable;they can be implemented more efficiently than relying on `concatmap` or `flatmap` similarly to how `flowable` implements themin addition the `buffersize` overloads make no sense as the operation is completely synchronous and nothing is to be buffered (in comparison `flowableconcatmapiterable` has to buffer the upstream items because the downstream may not be ready to consume the iterable);;1;0;3x: remove a pointless concatmapiterable overload;
"6838;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: rename to combinelatestarraydelayerror;the operator missed a rename with 2.x to match the  combinelatestarray  variant.;;682.0;3x: rename to combinelatestarraydelayerror;the operator missed a rename with 2x to match the `combinelatestarray` variant6820; merging 6838 ;api design review: share;similar to how we have the `observablecache` operator as an easy to understand helper over `multicast`/`replay` it is suggested to use `observableshare` for the `multicast`/`publish` as a shortcut to `observablepublish()refcount()` which is typically rather non-obvious and non-discoverable for people new to the library the suggestion is that `observableshare` would meet the majority of `multicast` use cases for sharing an `observable` not needing the complexity of handling the `connectableobservable` directly or knowing to use `refcount()`it would also match with rxjs:  @headinthebox @jhusain and @mattpodwysocki;""@headinthebox and @akarnokd do you like the idea of `share()` being a cover for `publish()refcount()`?note that rxjs already does this || adding it isnt a big deal but i cant comment on whether the name `share` is discoverable enough id like to hear from users who had trouble with publishrefcount being inconvenient  || my only insight into this is that i often see the question/struggle of how to use `publish()` and `connect()` and `refcount()` is always a surprise || im fine as you mention rxjs has this they also have pluck which sounds cool :-)personally i like to be explicit but  i can see the value of share  || (oops github ui fooled me into accidentally closing) || @headinthebox @benjchristensen yeah we gave it some thought before we committed to it but in the long run it was worth it || thanks for the insight @mattpodwysocki lets proceed with this it leaves us with `cache()` and `share()` as the most common multicasting use cases and the rest for the more complicated scenarios || what is `cache()` in this respect?  `replay()refcount()` or something else? || its just `replaysubject` without `refcount` once it is subscribed to once it receives all values from the origin and caches them all and replays them all back to whoever subscribes thus it is a big massive memory leak if used incorrectly (but thats how `tolist` and default `replaysubject` are anyways)this is most commonly used in request/response style network calls where it is a single or finite response expectedcode:  || done in  || i do a lot of rx training and every time i have to teach connectable observable i lose a third of the room thats frustrating because cache and share meet more than 90% of all use casesi think we should follow the principle that only complete subscriptions are cached  a cached observable has two states:1 uncached2 cachedin the uncached state the observable is similar to a share() observable concurrent subscribers should share a single ref counted subscription the only difference is that late concurrent subscribers are """"caught up"""" by immediately getting the contents of the bufferonce in an oncompleted or onerror message is received the cached observable goes into the cached state at this point the observable behaves exactly like a replay subject never issuing another call to the underlying data source the data itself is cashed within the replaysubject should not go away ever until all references to the cached observable are freed this is what users expect rather than the cached data being tied to a particular subscription as in replay()refcount()if all concurrent subscribers unsubscribe before the subscription has completed the data in the cash should be purged and the observable should return to the uncached statejdictated using voice recognition please forgive the typos> on may 20 2014 at 9:24 am ben christensen notifications@githubcom wrote:> > its just replaysubject without refcount once it is subscribed to once it receives all values from the origin and caches them all and replays them all back to whoever subscribes> > thus it is a big massive memory leak if used incorrectly (but thats how tolist and default replaysubject are anyways)> > this is most commonly used in request/response style network calls where it is a single or finite response expected> > code:  > > reply to this email directly or view it on github || > the data itself is cashed within the replaysubject should not go away ever until all references to the cached observable are freedyes this is how we implemented `cache()` it lets garbage collection free it we dont proactively do anything the way `refcount` does as its not what people expect here> if all concurrent subscribers unsubscribe before the subscription has completed the data in the cash should be purged and the observable should return to the uncached statethis isnt as obvious that would mean it could be resubscribed to and re-execute the work which would be surprising to people this could happen all the time if they are using `take(n)` as it would never `oncomplete` and always be unsubscribedthe `cache()` operator caches the entire origin if its an infinite stream it wont work well and something like `take` will need to be done before the `cache()` operator is applied || "";1;0;3x: rename to combinelatestarraydelayerror;"
6839;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;0;0;3.x: enable javac parameter saving in class files;related #6832;;683.0;3x: enable javac parameter saving in class files;related #6832; merging 6839 ;api design review: conditionals;discussion with @headinthebox suggests that the conditional operators really dont belong in rxjava (at least not the core) as they were added to rxnet for very specific use cases in f# these include `ifthen` `switchcase` `dowhile` `whiledo`are there reasons to keep these? if so do we move them out of `observable` or should we delete them?/cc @headinthebox and @jhusain; i dont know of anyone using this for real in rxnet || these could be moved into a `rxjava-contrib/rxjava-dotnet-legacy` package along with those ops that have been added just to match rxnet || these can be used for cep scenarios to reason over multiple streams it is best that they stay in some form or other as java does not have anonymous classes like c# where they could be easily avoided by joining fields into a anonymous class they are more needed in the jvm implementation than in netideally the senarios should be expanded in rxjava || @sirinath can you give a concrete example? i dont see the connection between these operators which are intended to overload imperative control structures in f# computation expressions and anonymous types || if this is extended to accept an observable sequence as the condition / selector then it would be more usefulsay i want to buy using signal a if vol is greater than a certain threshold plus some other computationally expensive conditions and signal b otherwise only if i am trading that instrument for the day and i only trade 05% of instrumentsthe current form is somewhat useful if we want to certain set of signals at start of the day but this is something you can do otherwise eagerly at a cost also it would be useful if the conditional is also an observable sequence as you can select between streams than at subscription using linq you can aggregate multiple items into anonymous class and select what is needed at the end from this in a further query this is more difficult though possible in java than c# hence it will be good to have the conditional functionality extended for other use casesmore powerful it would be if you have linq expressions this is also possible through commons jci or directly using janino perhaps at a later stage || also the conditions or index can be extended to a function to take 1 item from each stream and return the appropriate values (boolean / index) for item selection if not subscribers the condition is not evaluated and if possible each item can be discarded from the streamsthis would be a more convinient way to use this functionality || @sirinath could you provide a concrete example? i am not sure that i understand what you are after precisely || migrating conditionals to a contrib module:  || here is a link to documentation on their usage:  || @headinthebox add an extra overload with func<bool tresult tresult> condition for if and func<tvalue tresult> selector  etcif((a b) -> !aequals(obj1) && bequals(obj2)strm1strm2)this case condition is evaluated as needed but for each element coming in || @headinthebox in a nutshell the extension will help combination and generation something you can consider for the main implementation also ||;1;0;3x: enable javac parameter saving in class files;
"6840;1;0;0;0;0;1;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: add nullability annotations to type arguments;annotate type argument use with  @nonnull .;;676.0;3x: add nullability annotations to type arguments;annotate type argument use with `@nonnull`6766; merging 6840 ;api design review: safeobserver via reflection or marker interface;the `safeobserver` wrapper is applied to all `observer` implementations passed into `observablesubscribe` by users but it is not applied to any `observer` implementations that originate from within the `rxoperators` packagethis is so we achieve the desired safety and error handling while not paying the cost of wrapping trusted `observer` implementations from internal operatorstoday it uses reflection to look at the package the `observer` originates from it then caches this information for performance  see here:  and here:   is not pretty but it worksthe other way is we could put marker interfaces such as `trustedobserver` on all `observer` implementations we use in `rxoperators` or elsewhere that should not be wrappedpros:- doesnt involve reflection- obvious- can be used by non-internal operatorscons:- marker interfaces require remembering to put them where they should be- they can be put where theyre not supposed to be- can be used by non-internal operators and misused- they are an extra type to maintain in the public api serving little valueneither approach is pretty is there another approach? if not which of these two is preferable and why?/cc @headinthebox and @jhusain;""since `observable` code changes often enough those links will become wrong so here is the valid code:``` java/**     * whether a given {@link function} is an internal implementation inside     * rx* packages or not     * <p>     * for why this is being used see     *  for discussion on     * """"guideline 64: protect calls to user code from within an operator""""     *      * note: if strong reasons for not depending on package names comes up then     * the implementation of this method can change to looking for a marker     * interface     *      * @param o     * @return {@code true} if the given function is an internal implementation     *         and {@code false} otherwise     */    private boolean isinternalimplementation(object o) {        if (o  null) {            return true        }        // prevent double-wrapping (yeah it happens)        if (o instanceof safeobserver) {            return true        }        class<?> clazz  ogetclass()        if (internalclassmapcontainskey(clazz)) {            //dont need to do reflection            return internalclassmapget(clazz)        } else {            // we treat the following package as """"internal"""" and dont wrap it            package p  ogetclass()getpackage() // it can be null            boolean isinternal  (p ! null && pgetname()startswith(""""rxoperators""""))            internalclassmapput(clazz isinternal)            return isinternal        }    }`````` javaif (isinternalimplementation(observer)) {                subscription s  onsubscribefunctiononsubscribe(observer)                if (s  null) {                    // this generally shouldnt be the case on a trusted onsubscribe but in case it happens                    // we want to gracefully handle it the same as safeobservablesubscription does                    return hookonsubscribereturn(this subscriptionsempty())                } else {                    return hookonsubscribereturn(this s)                }            } else {                safeobservablesubscription subscription  new safeobservablesubscription()                subscriptionwrap(onsubscribefunctiononsubscribe(new safeobserver<t>(subscription observer)))                return hookonsubscribereturn(this subscription)            }``` || fwiw id lean toward option 2 (wouldnt this still result in using reflection though since youd have to check for the annotation at runtime?)> marker interfaces require remembering to put them where they should betrue is this something that could be caught using static analysis?> they can be put where theyre not supposed to bebut so can any class level annotation and it can be made only applicable to classes via the target property i dont see this being an issue really> can be used by non-internal operators and misusedsure then again whoever misuses this to mark a misbehaving observer as trusted is only shooting themselves in the foot? you get what you ask for :-) > they are an extra type to maintain in the public api serving little valueare you referring to the marker interface? whats the maintenance overhead though apart from having to remember applying it to internal observers?would be interested in hearing what others have to say || another option ive become more comfortable with (and that @headinthebox prefers) is that we add `observableunsafesubscribe` that `operator` implementations can use and it does what it says  subscribe without any """"safety"""" wrapping it would directly invoke the inner `onsubscribe` function || yes thats what i would prefer ^f for """"unsafe"""" during code reviews to spot where people may shoot themselves in the foot that dont know what they are doing but allow full power in case you need to implement a new operator || i see i would find it a bit odd though to find unsafesubscribe invocationsthroughout my client code even when i know its safe it would raise eyebrows for people not as familiar with the peculiarities of the library || do you create operators that act on nested observables? examples are `repeat` `retry` `merge`those are the only scenario where an `unsafesubscribe` is needed otherwise normal `operator` implementations like `map` `take` `filter` etc do not need to || here is an example location where it is doing an """"unsafe subscribe"""":  in `map` youll see it never subscribes because it is a `subscriber` -> `subscriber` transformation that gets lifted into the `observable`:  || i intend on doing this in 018 along with `scheduler` changes do my last explanations make sense or is there still concern about this change?the only time when this will need to be used is when implementing operators that do nested subscriptions  || +1on mon mar 31 2014 at 7:34 pm ben christensennotifications@githubcomwrote:> i intend on doing this in 018 along with scheduler changes do my last> explanations make sense or is there still concern about this change?> > the only time when this will need to be used is when implementing> operators that do nested subscriptions> > > reply to this email directly or view it on github  || thanks for the positive confirmation @mttkay  ill proceed with this || completed in  || "";1;0;3x: add nullability annotations to type arguments;"
"6843;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: improve wording of operators;- reword sentences with  modifies  and  instructs .;;6819.0;3x: improve wording of operators;""- reword sentences with """"modifies"""" and """"instructs""""- reword """"the source x"""" to """"the current x""""- reword a couple of other operator sentencesrelated #6819 6821""; merging 6843 ;""3x: change """"the source publisher"""" in flowable javadocs to """"the current flowable"""""";in instance methods of `flowable` the source should be referred to as `the current {@code flowable}` currently it is `the source {@link publisher}` due to previous copy-paste and search/replace mistakessimilarly `the resulting {@code publisher}` should be `the resulting {@code flowable}`(watch out for line breaks in the javadocs when searching for these as patterns)----`(?s)(the|a)\s*\*?\s*(source|upstream|resulting)\s*\*?\s*(\{\@code|\{\@link)? publisher``(?s)this\s*\*?\s*(\{\@code|\{\@link)? publisher``(?s)new\s*\*?\s*(\{\@code)?\s*publisher`; in #6835 ||;1;0;3x: improve wording of operators;"
"6843;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: improve wording of operators;- reword sentences with  modifies  and  instructs .;;682.0;3x: improve wording of operators;""- reword sentences with """"modifies"""" and """"instructs""""- reword """"the source x"""" to """"the current x""""- reword a couple of other operator sentencesrelated #6819 6821""; merging 6843 ;api design review: share;similar to how we have the `observablecache` operator as an easy to understand helper over `multicast`/`replay` it is suggested to use `observableshare` for the `multicast`/`publish` as a shortcut to `observablepublish()refcount()` which is typically rather non-obvious and non-discoverable for people new to the library the suggestion is that `observableshare` would meet the majority of `multicast` use cases for sharing an `observable` not needing the complexity of handling the `connectableobservable` directly or knowing to use `refcount()`it would also match with rxjs:  @headinthebox @jhusain and @mattpodwysocki;""@headinthebox and @akarnokd do you like the idea of `share()` being a cover for `publish()refcount()`?note that rxjs already does this || adding it isnt a big deal but i cant comment on whether the name `share` is discoverable enough id like to hear from users who had trouble with publishrefcount being inconvenient  || my only insight into this is that i often see the question/struggle of how to use `publish()` and `connect()` and `refcount()` is always a surprise || im fine as you mention rxjs has this they also have pluck which sounds cool :-)personally i like to be explicit but  i can see the value of share  || (oops github ui fooled me into accidentally closing) || @headinthebox @benjchristensen yeah we gave it some thought before we committed to it but in the long run it was worth it || thanks for the insight @mattpodwysocki lets proceed with this it leaves us with `cache()` and `share()` as the most common multicasting use cases and the rest for the more complicated scenarios || what is `cache()` in this respect?  `replay()refcount()` or something else? || its just `replaysubject` without `refcount` once it is subscribed to once it receives all values from the origin and caches them all and replays them all back to whoever subscribes thus it is a big massive memory leak if used incorrectly (but thats how `tolist` and default `replaysubject` are anyways)this is most commonly used in request/response style network calls where it is a single or finite response expectedcode:  || done in  || i do a lot of rx training and every time i have to teach connectable observable i lose a third of the room thats frustrating because cache and share meet more than 90% of all use casesi think we should follow the principle that only complete subscriptions are cached  a cached observable has two states:1 uncached2 cachedin the uncached state the observable is similar to a share() observable concurrent subscribers should share a single ref counted subscription the only difference is that late concurrent subscribers are """"caught up"""" by immediately getting the contents of the bufferonce in an oncompleted or onerror message is received the cached observable goes into the cached state at this point the observable behaves exactly like a replay subject never issuing another call to the underlying data source the data itself is cashed within the replaysubject should not go away ever until all references to the cached observable are freed this is what users expect rather than the cached data being tied to a particular subscription as in replay()refcount()if all concurrent subscribers unsubscribe before the subscription has completed the data in the cash should be purged and the observable should return to the uncached statejdictated using voice recognition please forgive the typos> on may 20 2014 at 9:24 am ben christensen notifications@githubcom wrote:> > its just replaysubject without refcount once it is subscribed to once it receives all values from the origin and caches them all and replays them all back to whoever subscribes> > thus it is a big massive memory leak if used incorrectly (but thats how tolist and default replaysubject are anyways)> > this is most commonly used in request/response style network calls where it is a single or finite response expected> > code:  > > reply to this email directly or view it on github || > the data itself is cashed within the replaysubject should not go away ever until all references to the cached observable are freedyes this is how we implemented `cache()` it lets garbage collection free it we dont proactively do anything the way `refcount` does as its not what people expect here> if all concurrent subscribers unsubscribe before the subscription has completed the data in the cash should be purged and the observable should return to the uncached statethis isnt as obvious that would mean it could be resubscribed to and re-execute the work which would be surprising to people this could happen all the time if they are using `take(n)` as it would never `oncomplete` and always be unsubscribedthe `cache()` operator caches the entire origin if its an infinite stream it wont work well and something like `take` will need to be done before the `cache()` operator is applied || "";1;0;3x: improve wording of operators;"
6844;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: remove maybe.onexceptionresumenext;it was always very peculiar to let only checked exceptions resumed.;;684.0;3x: remove maybeonexceptionresumenext;it was always very peculiar to let only checked exceptions resumed6842; merging 6844 ;api design review: delayerror;the `mergedelayerror` operator has been in rxjava from very early and evolved out of experience with the netflix api use cases it is not from rxnetit has proved very valuable and it has been suggested that this pattern be expanded to other combinatorial operators where lazily handling errors is sometimes appropriatethese include:- `concatdelayerror`- `combinelatestdelayerror`- `switchlatestdelayerror`are there others? any reason not to do this?/cc @headinthebox and @jhusain;talking about these operators in the net version there is an overload that limits the amount of concurrency  while merging which does not seem to be present in rxjava || i can take this overload of merge this weekend || still open to do related to this is `flatmapdelayerror`:  || @zsxwing would be great we should also make sure that the same consistency is applied for `mergemap` ie i want the same overloads on `concatmap` (maybe i should open a new issue for that?) || do we still want these versions? || i do || okay - `combinelatestdelayerror` is implemented operator-vise just needs exposure- for `concatdelayerror` concat needs full rewrite anyway- `switchlatestdelayerror` is `switchonnext` with error delay i presume || see #3759 for `concatdelayerror` || see #3763 for `combinelatestdelayerror` || see #3765 for `switchonnextdelayerror` || operators have been added let us know if there are some more required ||;1;0;3x: remove maybeonexceptionresumenext;
6847;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: simplify @return sentences in flowable javadocs;simplify the wording of  @return  in javadocs.;;683.0;3x: simplify @return sentences in flowable javadocs;simplify the wording of `@return` in javadocs6834; merging 6847 ;api design review: conditionals;discussion with @headinthebox suggests that the conditional operators really dont belong in rxjava (at least not the core) as they were added to rxnet for very specific use cases in f# these include `ifthen` `switchcase` `dowhile` `whiledo`are there reasons to keep these? if so do we move them out of `observable` or should we delete them?/cc @headinthebox and @jhusain; i dont know of anyone using this for real in rxnet || these could be moved into a `rxjava-contrib/rxjava-dotnet-legacy` package along with those ops that have been added just to match rxnet || these can be used for cep scenarios to reason over multiple streams it is best that they stay in some form or other as java does not have anonymous classes like c# where they could be easily avoided by joining fields into a anonymous class they are more needed in the jvm implementation than in netideally the senarios should be expanded in rxjava || @sirinath can you give a concrete example? i dont see the connection between these operators which are intended to overload imperative control structures in f# computation expressions and anonymous types || if this is extended to accept an observable sequence as the condition / selector then it would be more usefulsay i want to buy using signal a if vol is greater than a certain threshold plus some other computationally expensive conditions and signal b otherwise only if i am trading that instrument for the day and i only trade 05% of instrumentsthe current form is somewhat useful if we want to certain set of signals at start of the day but this is something you can do otherwise eagerly at a cost also it would be useful if the conditional is also an observable sequence as you can select between streams than at subscription using linq you can aggregate multiple items into anonymous class and select what is needed at the end from this in a further query this is more difficult though possible in java than c# hence it will be good to have the conditional functionality extended for other use casesmore powerful it would be if you have linq expressions this is also possible through commons jci or directly using janino perhaps at a later stage || also the conditions or index can be extended to a function to take 1 item from each stream and return the appropriate values (boolean / index) for item selection if not subscribers the condition is not evaluated and if possible each item can be discarded from the streamsthis would be a more convinient way to use this functionality || @sirinath could you provide a concrete example? i am not sure that i understand what you are after precisely || migrating conditionals to a contrib module:  || here is a link to documentation on their usage:  || @headinthebox add an extra overload with func<bool tresult tresult> condition for if and func<tvalue tresult> selector  etcif((a b) -> !aequals(obj1) && bequals(obj2)strm1strm2)this case condition is evaluated as needed but for each element coming in || @headinthebox in a nutshell the extension will help combination and generation something you can consider for the main implementation also ||;1;0;clean observable;
"6853;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: fix method argument naming across types;make method argument naming consistent between the base reactive classes  adjust some of the naming for all.;;6832.0;3x: fix method argument naming across types;make method argument naming consistent between the base reactive classes adjust some of the naming for allin addition the null-check was missing from `blockingmostrecent`6832 the utility program has to be run manually to list the inconsistencies the remaining inconsistency is due to `merge` because its argument is `sources` for `flowable`/`observable` but `source` for `single`/`maybe` nested; merging 6853 ;3x: validate argument naming consistency between base class methods;""operator argument naming should match between base classes on the same operatorsfor example `observable::buffer(boundary)` vs `flowable::buffer(boundaryindicator)`source-level comparison would be too complicated so reflection can be used for this provided the class saves the argument names javac 8 has this option that must be enabled in the ide and in `buildgradle`:```groovy[compilejava compiletestjava]*options*compilerargs << """"-parameters""""taskswithtype(javacompile) {    optionscompilerargs << """"-parameters""""}```an extra test is preferrable to remind users enabling this option:```java    void method(int paramname) {        // deliberately empty    }    @test    public void javacparametersenabled() throws exception {        assertequals(""""please enable saving parameter names via the -parameters javac argument""""                """"paramname""""                getclass()                getdeclaredmethod(""""method"""" integertype)                getparameters()[0]getname())    }```there are some common operator names across all base classes these should match as well"";;1;0;remove outdated null-test of blockingmostrecent;"
"6856;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;rename single.equals to single.sequenceequal;renamed single.equals to single.sequenceequal and renamed argument names for consistent naming.;;685.0;rename singleequals to singlesequenceequal;renamed singleequals to singlesequenceequal and renamed argument names for consistent naming6854; merging 6856 ;""api design review: better name for """"just""""?"";the `just` operator seems misplaced and non-discoverable the `from` operator is preferable but we cant have `from(t scheduler)` because if `t` is `object` then `from(object scheduler)` cant be disambiguated from `from(object object)`ideas on a new name or different approach?/cc @headinthebox and @jhusain;""we can always do observablerepeat(x)take(1) or observablerepeat(x1) that was the argument for not including """"return"""" in c# enumerable || i think its too late to remove `just`  and it worksthe two primary entry points are `observablefrom()` and `observablejust()` || "";1;0;update mentions of renamed parameters;"
6857;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: [wiki] improve operator-matrix with links and notes;update the  operatormatrixgenerator  to add anchors and links to notes about why operators are not present in one or another class.;;6852.0;3x: [wiki] improve operator-matrix with links and notes;update the `operatormatrixgenerator` to add anchors and links to notes about why operators are not present in one or another class operators are missing and will be added as part of #68526855; merging 6857 ;3x: missing operators (tracking issue); present in some but not other classes (when they make sense there too):-  `completableconcatarraydelayerror`-  `completableblockingsubscribe`-  `completabledoonlifecycle`-  `completableonerrorresumewith`-  `completableonerrorreturn`-  `completableonerrorreturnitem`-  `completableretryuntil`-  `completablesafesubscribe`-  `completablesequenceequal`-  `completablestartwith` (`maybesource` `singlesource`)- [x] `completableswitchonnext`- [x] `completableswitchonnextdelayerror`- [x] `completabletofuture`- [x] `maybeblockingsubscribe`- [x] `maybeconcatarrayeagerdelayerror`- [x] `maybeconcatmapcompletable`- [x] `maybeconcatmapsingle`- [x] `maybedematerialize`- [x] `maybefromobservable`- [x] `maybedoonlifecycle`- [x] `maybefrompublisher`- [x] `maybesafesubscribe`- [x] `maybestartwith` - [x] `maybetimeinterval`- [x] `maybetimestamp`- [x] `maybetofuture`- [x] `maybeswitchonnext`- [x] `maybeswitchonnextdelayerror`- [x] `singleblockingsubscribe`- [x] `singleconcatarraydelayerror`- [x] `singleconcatarrayeagerdelayerror`- [x] `singleconcatdelayerror`- [x] `singleconcatmap`- [x] `singleconcatmapcompletable`- [x] `singleconcatmapmaybe`- [x] `singledoonlifecycle`- [x] `singlefrommaybe`- [x] `singlemergearray`- [x] `singlemergearraydelayerror`- [x] `singleoftype`- [x] `singleonerrorcomplete`- [x] `singleretryuntil`- [x] `singlesafesubscribe`- [x] `singlesequenceequal` (rename `equals`)- [x] `singlestartwith` - [x] `singletimeinterval`- [x] `singletimestamp`- [x] `singleswitchonnext`- [x] `singleswitchonnextdelayerror`- [x] `flowablefromaction`- [x] `flowablefromcompletable`- [x] `flowablefrommaybe`- [x] `flowablefromobservable`- [x] `flowablefromrunnable`- [x] `flowablefromsingle`- [x] `flowableonerrorcomplete`- [x] `flowablestartwith` (`maybesource` `singlesource` `completablesource`)- [x] `observablefromaction`- [x] `observablefromcompletable`- [x] `observablefrommaybe`- [x] `observablefromrunnable`- [x] `observablefromsingle`- [x] `observableonerrorcomplete`- [x] `observablestartwith` (`maybesource` `singlesource` `completablesource`);can i work on it? || @souraexx sure pick one im currently working on all `onerrorcomplete`s ||;1;0;3x: [wiki] improve operator-matrix with links and notes;
6857;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: [wiki] improve operator-matrix with links and notes;update the  operatormatrixgenerator  to add anchors and links to notes about why operators are not present in one or another class.;;6855.0;3x: [wiki] improve operator-matrix with links and notes;update the `operatormatrixgenerator` to add anchors and links to notes about why operators are not present in one or another class operators are missing and will be added as part of #68526855; merging 6857 ;3x: [wiki] enhance operator-matrix generation with anchors and explanations; turned the column headers to images rotated 90 degrees so the table doesnt overflow the wiki layoutthe `src/test/java/io/reactivex/rxjava3/internal/util/operatormatrixgeneratorjava` should be updated accordingly plus:- add html anchors to the rows so they can be navigated to via `#methodname`- add `<sup>[n](#note-n)</sup>` to absent entries and a list of notes below the table explaining why for this the reason mapping has to be added to the generator;closing via #6857 ||;1;0;3x: [wiki] improve operator-matrix with links and notes;
6858;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: verify the use of base interfaces in operator inputs & lambdas;this pr adds a test that verifies standard operator methods use base interfaces as their input and lambdas capable of returning base types do as well. consequently  it fixes two declarations of  flowable.buffer  having the wrong input type.;;0;3x: verify the use of base interfaces in operator inputs & lambdas;this pr adds a test that verifies standard operator methods use base interfaces as their input and lambdas capable of returning base types do as well consequently it fixes two declarations of `flowablebuffer` having the wrong input typebasically detect the following declarations:```java// direct use of the class should be publisher    public void method1(flowable<?> f)// lambda returns the class should return a publisher    public void method2(callable<flowable<?>> c)// the inner publisher emits the class should emit publisher    public void method3(supplier<publisher<flowable<?>>> c)// direct use of the class as array type should be publisher    public void method4(flowable<?> array)// lambda returns an array of the class should return publisher    public void method5(callable<flowable<?>> c)// the inner publisher emits an array of the class should emit publisher    public void method6(callable<publisher<flowable<?>>> c)```; merging 6858 ;;;;1;1;add @nonnull annotations too;
"6860;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: add last missing throws tag to javadocs;added the last missing  @throws  tag to methods and one missing  @nonnull  annotation.;;682.0;3x: add last missing throws tag to javadocs;added the last missing `@throws` tag to methods and one missing `@nonnull` annotationi included a small program that will list javadocs without `@throws` for future use6829; merging 6860 ;api design review: share;similar to how we have the `observablecache` operator as an easy to understand helper over `multicast`/`replay` it is suggested to use `observableshare` for the `multicast`/`publish` as a shortcut to `observablepublish()refcount()` which is typically rather non-obvious and non-discoverable for people new to the library the suggestion is that `observableshare` would meet the majority of `multicast` use cases for sharing an `observable` not needing the complexity of handling the `connectableobservable` directly or knowing to use `refcount()`it would also match with rxjs:  @headinthebox @jhusain and @mattpodwysocki;""@headinthebox and @akarnokd do you like the idea of `share()` being a cover for `publish()refcount()`?note that rxjs already does this || adding it isnt a big deal but i cant comment on whether the name `share` is discoverable enough id like to hear from users who had trouble with publishrefcount being inconvenient  || my only insight into this is that i often see the question/struggle of how to use `publish()` and `connect()` and `refcount()` is always a surprise || im fine as you mention rxjs has this they also have pluck which sounds cool :-)personally i like to be explicit but  i can see the value of share  || (oops github ui fooled me into accidentally closing) || @headinthebox @benjchristensen yeah we gave it some thought before we committed to it but in the long run it was worth it || thanks for the insight @mattpodwysocki lets proceed with this it leaves us with `cache()` and `share()` as the most common multicasting use cases and the rest for the more complicated scenarios || what is `cache()` in this respect?  `replay()refcount()` or something else? || its just `replaysubject` without `refcount` once it is subscribed to once it receives all values from the origin and caches them all and replays them all back to whoever subscribes thus it is a big massive memory leak if used incorrectly (but thats how `tolist` and default `replaysubject` are anyways)this is most commonly used in request/response style network calls where it is a single or finite response expectedcode:  || done in  || i do a lot of rx training and every time i have to teach connectable observable i lose a third of the room thats frustrating because cache and share meet more than 90% of all use casesi think we should follow the principle that only complete subscriptions are cached  a cached observable has two states:1 uncached2 cachedin the uncached state the observable is similar to a share() observable concurrent subscribers should share a single ref counted subscription the only difference is that late concurrent subscribers are """"caught up"""" by immediately getting the contents of the bufferonce in an oncompleted or onerror message is received the cached observable goes into the cached state at this point the observable behaves exactly like a replay subject never issuing another call to the underlying data source the data itself is cashed within the replaysubject should not go away ever until all references to the cached observable are freed this is what users expect rather than the cached data being tied to a particular subscription as in replay()refcount()if all concurrent subscribers unsubscribe before the subscription has completed the data in the cash should be purged and the observable should return to the uncached statejdictated using voice recognition please forgive the typos> on may 20 2014 at 9:24 am ben christensen notifications@githubcom wrote:> > its just replaysubject without refcount once it is subscribed to once it receives all values from the origin and caches them all and replays them all back to whoever subscribes> > thus it is a big massive memory leak if used incorrectly (but thats how tolist and default replaysubject are anyways)> > this is most commonly used in request/response style network calls where it is a single or finite response expected> > code:  > > reply to this email directly or view it on github || > the data itself is cashed within the replaysubject should not go away ever until all references to the cached observable are freedyes this is how we implemented `cache()` it lets garbage collection free it we dont proactively do anything the way `refcount` does as its not what people expect here> if all concurrent subscribers unsubscribe before the subscription has completed the data in the cash should be purged and the observable should return to the uncached statethis isnt as obvious that would mean it could be resubscribed to and re-execute the work which would be surprising to people this could happen all the time if they are using `take(n)` as it would never `oncomplete` and always be unsubscribedthe `cache()` operator caches the entire origin if its an infinite stream it wont work well and something like `take` will need to be done before the `cache()` operator is applied || "";1;0;3x: add last missing throws tag to javadocs;"
6862;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: add maybe/single/completable blockingsubscribe;add the missing  blockingsubscribe  methods to  maybe    single  and  completable  for symmetry with  flowable  and  observable .;;6852.0;3x: add maybe/single/completable blockingsubscribe;add the missing `blockingsubscribe` methods to `maybe` `single` and `completable` for symmetry with `flowable` and `observable`usually wed like to avoid blocking but now that project loom (preview) transparently turns latch-based awaiting into suspension inside virtual threads they will act as free interop operators for exiting the reactive world into the continuation worldrelated: #6852marbles:#### maybe( single![image]( completable![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableblockingsubscribepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableblockingsubscribeapng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableblockingsubscribeacpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableblockingsubscribeopng); merging 6862 ;3x: missing operators (tracking issue); present in some but not other classes (when they make sense there too):-  `completableconcatarraydelayerror`-  `completableblockingsubscribe`-  `completabledoonlifecycle`-  `completableonerrorresumewith`-  `completableonerrorreturn`-  `completableonerrorreturnitem`-  `completableretryuntil`-  `completablesafesubscribe`-  `completablesequenceequal`-  `completablestartwith` (`maybesource` `singlesource`)- [x] `completableswitchonnext`- [x] `completableswitchonnextdelayerror`- [x] `completabletofuture`- [x] `maybeblockingsubscribe`- [x] `maybeconcatarrayeagerdelayerror`- [x] `maybeconcatmapcompletable`- [x] `maybeconcatmapsingle`- [x] `maybedematerialize`- [x] `maybefromobservable`- [x] `maybedoonlifecycle`- [x] `maybefrompublisher`- [x] `maybesafesubscribe`- [x] `maybestartwith` - [x] `maybetimeinterval`- [x] `maybetimestamp`- [x] `maybetofuture`- [x] `maybeswitchonnext`- [x] `maybeswitchonnextdelayerror`- [x] `singleblockingsubscribe`- [x] `singleconcatarraydelayerror`- [x] `singleconcatarrayeagerdelayerror`- [x] `singleconcatdelayerror`- [x] `singleconcatmap`- [x] `singleconcatmapcompletable`- [x] `singleconcatmapmaybe`- [x] `singledoonlifecycle`- [x] `singlefrommaybe`- [x] `singlemergearray`- [x] `singlemergearraydelayerror`- [x] `singleoftype`- [x] `singleonerrorcomplete`- [x] `singleretryuntil`- [x] `singlesafesubscribe`- [x] `singlesequenceequal` (rename `equals`)- [x] `singlestartwith` - [x] `singletimeinterval`- [x] `singletimestamp`- [x] `singleswitchonnext`- [x] `singleswitchonnextdelayerror`- [x] `flowablefromaction`- [x] `flowablefromcompletable`- [x] `flowablefrommaybe`- [x] `flowablefromobservable`- [x] `flowablefromrunnable`- [x] `flowablefromsingle`- [x] `flowableonerrorcomplete`- [x] `flowablestartwith` (`maybesource` `singlesource` `completablesource`)- [x] `observablefromaction`- [x] `observablefromcompletable`- [x] `observablefrommaybe`- [x] `observablefromrunnable`- [x] `observablefromsingle`- [x] `observableonerrorcomplete`- [x] `observablestartwith` (`maybesource` `singlesource` `completablesource`);can i work on it? || @souraexx sure pick one im currently working on all `onerrorcomplete`s ||;1;0;update marble dimensions;
6864;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;adding delayerror to maybe.delay;6863;;6863.0;adding delayerror to maybedelay;6863; merging 6864  < ;3x: maybedelay has no `delayerror` option unlike `single`;it defaults to always delay an error;;1;0;add delayerror to maybedelay;
6866;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: fix many marbles in maybe;add many missing and replace incorrect marble diagrams in  maybe .;;0;3x: fix many marbles in maybe;add many missing and replace incorrect marble diagrams in `maybe`(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybecreatepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedeferpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeerrorfpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybefromactionpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybefromrunnablepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybefromcallablepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybefromfuturepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybefromfuturetpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybefromsinglepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybefromcompletablepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybemergeipng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybemergeppng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybemergepnpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybemergearraypng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybemergearraydelayerrorpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybemergedelayerroripng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybemergedelayerrorppng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybemergedelayerrorpnpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybemerge2png)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybemerge3png)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybemerge4png)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybemergedelayerror2png)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybemergedelayerror3png)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybemergedelayerror4png)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetimerpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetimerspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybesequenceequalpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybesequenceequalfpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeunsafecreatepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeusingpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeusingbpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybewrappng); merging 6866 ;;;;1;1;3x: fix many marbles in maybe;
6867;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: add onerrorcomplete to flowable  observable and single;add the  onerrorcomplete()  and  onerrorcomplete(predicate)  operators to the remaining base classes.;;5806.0;3x: add onerrorcomplete to flowable observable and single;add the `onerrorcomplete()` and `onerrorcomplete(predicate)` operators to the remaining base classesalso created the missing marble for `maybeonerrorcomplete` + 1related #6852 #5806 (https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowableonerrorcompletepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowableonerrorcompletefpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observableonerrorcompletepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observableonerrorcompletefpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleonerrorcompletepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleonerrorcompletefpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeonerrorcompletepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeonerrorcompletefpng); merging 6867 ;3x: maybe incorrect or missing marbles (tracking issue);-  `amb`: missing diagram-  `ambarray`: missing diagram-  `concat(iterable)`: missing diagram-  `concat(publisher)`: missing diagram-  `concat(publisher int)`: missing diagram-  `concatarray`: missing diagram-  `concatarraydelayerror`: indicate error delayed 1 marble per source-  `concatarrayeager`: missing diagram-  `concatdelayerror(iterable)`: missing diagram-  `concatdelayerror(publisher)`: missing diagram- [x] `concatdelayerror(publisher int)`: fix overlap/misalignment inside the operator box- [x] `concateager(iterable)`: missing diagram- [x] `concateager(publisher)`: missing diagram- [x] `create`: missing diagram- [x] `defer`: missing diagram- [x] `error(callable)`: indicate callable returns the error- [x] `fromaction`: missing diagram- [x] `fromcompletable`: missing diagram- [x] `fromsingle`: missing diagram- [x] `fromcallable`: missing diagram- [x] `fromfuture(future)`: operator name in the box indicate future is the parameter- [x] `fromfuture(future long timeunit)`: operator name in the box indicate future is the parameter indicate timeout- [x] `fromrunnable`: missing diagram- [x] `merge(iterable)`: missing diagram- [x] `merge(publisher)`: missing diagram- [x] `merge(publisher int)`: missing diagram- [x] `mergearray`: missing diagram- [x] `mergearraydelayerror`: one marble per maybe source- [x] `mergedelayerror(iterable)`: one marble per maybe source- [x] `mergedelayerror(publisher)`: one marble per maybe source- [x] `mergedelayerror(maybe maybe )`: one marble per maybe source- [x] `sequenceequal` + 1: result should be `single`- [x] `timer` + 1: result should be maybe- [x] `using` + 1: rework to indicate the created maybe- [x] `wrap`: missing marble- [x] `zip(iterable)`: one marble per maybe source result should be maybe- [x] `zip(maybe maybe )` + 8: one marble per maybe source result should be maybe- [x] `ziparray`: one marble per maybe source result should be maybe- [x] `ambwith`: one marble per maybe source result should be maybe- [x] ~~`as`: missing diagram~~ operator removed- [x] `blockingget` + 1: missing diagram- [x] `cache`: one marble per maybe source result should be maybe- [x] `cast`: missing diagram- [x] `compose`: missing diagram- [x] `concatmap`: indicate maybe target indicate empty source- [x] `concatwith`: one marble per maybe source result should be maybe operator name indicate other is a parameter- [x] `contains`: one marble per maybe source result should be single empty case- [x] `count`: one marble per maybe operator name result should be single empty case- [x] `defaultifempty`: non-empty case result should be maybe- [x] `delay(time)` + 3: one marble per maybe source result should be maybe- [x] `delay(publisher)`: one marble per maybe one signal by the publisher empty publisher case- [x] `delaysubscription(publisher)`: missing diagram- [x] `delaysubscription(time)` + 1: one marble per maybe source result should be maybe- [x] `doaftersuccess`: missing diagram- [x] `doafterterminate`: operator name one marble per maybe result should be maybe- [x] `dofinally`: missing diagram- [x] `doondispose`: missing diagram- [x] `dooncomplete`: one marble per maybe result should be maybe- [x] `doonerror`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonsubscribe`: missing diagram- [x] `doonsuccess`: missing diagram- [x] `doonterminate`: one marble per maybe result should be maybe- [x] `filter`: one marble per maybe result should be maybe- [x] `flatmap(function function callable)`: one marble per maybe result should be maybe- [x] `flatmap(function bifunction)`: one marble per maybe result should be maybe- [x] `flatmapobservable`: should be mapped into an observable- [x] `flatmappublisher`: indicate backpressure- [x] `flatmapsingle`: indicate empty maybe results in error- [x] `flatmapsingleelement`: operator name indicate empty maybe- [x] `flatmapcompletable`: indicate empty maybe- [x] `hide`: missing diagram- [x] `ignoreelement`: operator name one marble per maybe result should be maybe- [x] `isempty`: result should be single- [x] `mergewith`: operator name one marble per maybe indicate backpressure- [x] `oftype`: one marble per maybe- [x] `onerrorcomplete` + 1: missing diagram- [x] `onerrorresumenext`: one marble per maybe result should be maybe- [x] `onerrorresumewith`: one marble per maybe result should be maybe- [x] `onerrorreturn`: one marble per maybe result should be maybe indicate callback- [x] `onerrorreturnitem`: operator name one marble per maybe result should be maybe indicate normal outcome- [x] ~~`onexceptionresumenext`: operator takes a maybe source directly~~ operator removed- [x] `onterminatedetach`: missing diagram- [x] `repeat` + 1: one marble per source indicate backpressure indicate repeat conditions- [x] `repeatuntil`: operator name repeat condition indicate backpressure- [x] `repeatwhen`: one marble per maybe indicate backpressure- [x] `retry` + 2: one marble per maybe result should be maybe indicate repeat conditions- [x] `retry(int predicate)`: missing diagram- [x] `retry(predicate)`: missing diagram- [x] `retryuntil`: missing diagram- [x] `retrywhen`: one marble per maybe output should be maybe- [x] `switchifempty` + 1: improve diagrams indicate argument type- [x] `takeuntil` + 1: one marble per maybe output should be maybe- [x] `timeout` + 3: one marble per maybe output should be maybe- [x] `timeout(maybesource)`: missing diagram- [x] `timeout(maybesource maybesource)`: missing diagram- [x] `timeout(publisher)`: missing diagram- [x] `timeout(publisher maybesource)`: missing diagram- [x] `to`: missing diagram- [x] `toflowable`: missing diagram- [x] `toobservable`: missing diagram- [x] `tosingle` + 1: missing diagram- [x] `unsubscribeon`: missing diagram- [x] `zipwith`: one marble per maybe output should be maybe;here is the excel file i draw the diagrams in:  ||;1;0;add version tags;
6867;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: add onerrorcomplete to flowable  observable and single;add the  onerrorcomplete()  and  onerrorcomplete(predicate)  operators to the remaining base classes.;;6852.0;3x: add onerrorcomplete to flowable observable and single;add the `onerrorcomplete()` and `onerrorcomplete(predicate)` operators to the remaining base classesalso created the missing marble for `maybeonerrorcomplete` + 1related #6852 #5806 (https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowableonerrorcompletepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowableonerrorcompletefpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observableonerrorcompletepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observableonerrorcompletefpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleonerrorcompletepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleonerrorcompletefpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeonerrorcompletepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeonerrorcompletefpng); merging 6867 ;3x: missing operators (tracking issue); present in some but not other classes (when they make sense there too):-  `completableconcatarraydelayerror`-  `completableblockingsubscribe`-  `completabledoonlifecycle`-  `completableonerrorresumewith`-  `completableonerrorreturn`-  `completableonerrorreturnitem`-  `completableretryuntil`-  `completablesafesubscribe`-  `completablesequenceequal`-  `completablestartwith` (`maybesource` `singlesource`)- [x] `completableswitchonnext`- [x] `completableswitchonnextdelayerror`- [x] `completabletofuture`- [x] `maybeblockingsubscribe`- [x] `maybeconcatarrayeagerdelayerror`- [x] `maybeconcatmapcompletable`- [x] `maybeconcatmapsingle`- [x] `maybedematerialize`- [x] `maybefromobservable`- [x] `maybedoonlifecycle`- [x] `maybefrompublisher`- [x] `maybesafesubscribe`- [x] `maybestartwith` - [x] `maybetimeinterval`- [x] `maybetimestamp`- [x] `maybetofuture`- [x] `maybeswitchonnext`- [x] `maybeswitchonnextdelayerror`- [x] `singleblockingsubscribe`- [x] `singleconcatarraydelayerror`- [x] `singleconcatarrayeagerdelayerror`- [x] `singleconcatdelayerror`- [x] `singleconcatmap`- [x] `singleconcatmapcompletable`- [x] `singleconcatmapmaybe`- [x] `singledoonlifecycle`- [x] `singlefrommaybe`- [x] `singlemergearray`- [x] `singlemergearraydelayerror`- [x] `singleoftype`- [x] `singleonerrorcomplete`- [x] `singleretryuntil`- [x] `singlesafesubscribe`- [x] `singlesequenceequal` (rename `equals`)- [x] `singlestartwith` - [x] `singletimeinterval`- [x] `singletimestamp`- [x] `singleswitchonnext`- [x] `singleswitchonnextdelayerror`- [x] `flowablefromaction`- [x] `flowablefromcompletable`- [x] `flowablefrommaybe`- [x] `flowablefromobservable`- [x] `flowablefromrunnable`- [x] `flowablefromsingle`- [x] `flowableonerrorcomplete`- [x] `flowablestartwith` (`maybesource` `singlesource` `completablesource`)- [x] `observablefromaction`- [x] `observablefromcompletable`- [x] `observablefrommaybe`- [x] `observablefromrunnable`- [x] `observablefromsingle`- [x] `observableonerrorcomplete`- [x] `observablestartwith` (`maybesource` `singlesource` `completablesource`);can i work on it? || @souraexx sure pick one im currently working on all `onerrorcomplete`s ||;1;0;add version tags;
6868;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: add completable.onerrorresumewith;this pr adds the missing  completable.onerrorresumewith  present in the rest of the base classes.;;5806.0;3x: add completableonerrorresumewith;this pr adds the missing `completableonerrorresumewith` present in the rest of the base classesalso marbles for `maybeonerrorresumenext` and `maybeonerrorresumewith` have been updatedrelated #6852 #5806(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableonerrorresumewithpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeonerrorresumenextpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeonerrorresumewithpng); merging 6868 ;3x: maybe incorrect or missing marbles (tracking issue);-  `amb`: missing diagram-  `ambarray`: missing diagram-  `concat(iterable)`: missing diagram-  `concat(publisher)`: missing diagram-  `concat(publisher int)`: missing diagram-  `concatarray`: missing diagram-  `concatarraydelayerror`: indicate error delayed 1 marble per source-  `concatarrayeager`: missing diagram-  `concatdelayerror(iterable)`: missing diagram-  `concatdelayerror(publisher)`: missing diagram- [x] `concatdelayerror(publisher int)`: fix overlap/misalignment inside the operator box- [x] `concateager(iterable)`: missing diagram- [x] `concateager(publisher)`: missing diagram- [x] `create`: missing diagram- [x] `defer`: missing diagram- [x] `error(callable)`: indicate callable returns the error- [x] `fromaction`: missing diagram- [x] `fromcompletable`: missing diagram- [x] `fromsingle`: missing diagram- [x] `fromcallable`: missing diagram- [x] `fromfuture(future)`: operator name in the box indicate future is the parameter- [x] `fromfuture(future long timeunit)`: operator name in the box indicate future is the parameter indicate timeout- [x] `fromrunnable`: missing diagram- [x] `merge(iterable)`: missing diagram- [x] `merge(publisher)`: missing diagram- [x] `merge(publisher int)`: missing diagram- [x] `mergearray`: missing diagram- [x] `mergearraydelayerror`: one marble per maybe source- [x] `mergedelayerror(iterable)`: one marble per maybe source- [x] `mergedelayerror(publisher)`: one marble per maybe source- [x] `mergedelayerror(maybe maybe )`: one marble per maybe source- [x] `sequenceequal` + 1: result should be `single`- [x] `timer` + 1: result should be maybe- [x] `using` + 1: rework to indicate the created maybe- [x] `wrap`: missing marble- [x] `zip(iterable)`: one marble per maybe source result should be maybe- [x] `zip(maybe maybe )` + 8: one marble per maybe source result should be maybe- [x] `ziparray`: one marble per maybe source result should be maybe- [x] `ambwith`: one marble per maybe source result should be maybe- [x] ~~`as`: missing diagram~~ operator removed- [x] `blockingget` + 1: missing diagram- [x] `cache`: one marble per maybe source result should be maybe- [x] `cast`: missing diagram- [x] `compose`: missing diagram- [x] `concatmap`: indicate maybe target indicate empty source- [x] `concatwith`: one marble per maybe source result should be maybe operator name indicate other is a parameter- [x] `contains`: one marble per maybe source result should be single empty case- [x] `count`: one marble per maybe operator name result should be single empty case- [x] `defaultifempty`: non-empty case result should be maybe- [x] `delay(time)` + 3: one marble per maybe source result should be maybe- [x] `delay(publisher)`: one marble per maybe one signal by the publisher empty publisher case- [x] `delaysubscription(publisher)`: missing diagram- [x] `delaysubscription(time)` + 1: one marble per maybe source result should be maybe- [x] `doaftersuccess`: missing diagram- [x] `doafterterminate`: operator name one marble per maybe result should be maybe- [x] `dofinally`: missing diagram- [x] `doondispose`: missing diagram- [x] `dooncomplete`: one marble per maybe result should be maybe- [x] `doonerror`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonsubscribe`: missing diagram- [x] `doonsuccess`: missing diagram- [x] `doonterminate`: one marble per maybe result should be maybe- [x] `filter`: one marble per maybe result should be maybe- [x] `flatmap(function function callable)`: one marble per maybe result should be maybe- [x] `flatmap(function bifunction)`: one marble per maybe result should be maybe- [x] `flatmapobservable`: should be mapped into an observable- [x] `flatmappublisher`: indicate backpressure- [x] `flatmapsingle`: indicate empty maybe results in error- [x] `flatmapsingleelement`: operator name indicate empty maybe- [x] `flatmapcompletable`: indicate empty maybe- [x] `hide`: missing diagram- [x] `ignoreelement`: operator name one marble per maybe result should be maybe- [x] `isempty`: result should be single- [x] `mergewith`: operator name one marble per maybe indicate backpressure- [x] `oftype`: one marble per maybe- [x] `onerrorcomplete` + 1: missing diagram- [x] `onerrorresumenext`: one marble per maybe result should be maybe- [x] `onerrorresumewith`: one marble per maybe result should be maybe- [x] `onerrorreturn`: one marble per maybe result should be maybe indicate callback- [x] `onerrorreturnitem`: operator name one marble per maybe result should be maybe indicate normal outcome- [x] ~~`onexceptionresumenext`: operator takes a maybe source directly~~ operator removed- [x] `onterminatedetach`: missing diagram- [x] `repeat` + 1: one marble per source indicate backpressure indicate repeat conditions- [x] `repeatuntil`: operator name repeat condition indicate backpressure- [x] `repeatwhen`: one marble per maybe indicate backpressure- [x] `retry` + 2: one marble per maybe result should be maybe indicate repeat conditions- [x] `retry(int predicate)`: missing diagram- [x] `retry(predicate)`: missing diagram- [x] `retryuntil`: missing diagram- [x] `retrywhen`: one marble per maybe output should be maybe- [x] `switchifempty` + 1: improve diagrams indicate argument type- [x] `takeuntil` + 1: one marble per maybe output should be maybe- [x] `timeout` + 3: one marble per maybe output should be maybe- [x] `timeout(maybesource)`: missing diagram- [x] `timeout(maybesource maybesource)`: missing diagram- [x] `timeout(publisher)`: missing diagram- [x] `timeout(publisher maybesource)`: missing diagram- [x] `to`: missing diagram- [x] `toflowable`: missing diagram- [x] `toobservable`: missing diagram- [x] `tosingle` + 1: missing diagram- [x] `unsubscribeon`: missing diagram- [x] `zipwith`: one marble per maybe output should be maybe;here is the excel file i draw the diagrams in:  ||;1;0;3x: add completableonerrorresumewith;
6868;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: add completable.onerrorresumewith;this pr adds the missing  completable.onerrorresumewith  present in the rest of the base classes.;;6852.0;3x: add completableonerrorresumewith;this pr adds the missing `completableonerrorresumewith` present in the rest of the base classesalso marbles for `maybeonerrorresumenext` and `maybeonerrorresumewith` have been updatedrelated #6852 #5806(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableonerrorresumewithpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeonerrorresumenextpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeonerrorresumewithpng); merging 6868 ;3x: missing operators (tracking issue); present in some but not other classes (when they make sense there too):-  `completableconcatarraydelayerror`-  `completableblockingsubscribe`-  `completabledoonlifecycle`-  `completableonerrorresumewith`-  `completableonerrorreturn`-  `completableonerrorreturnitem`-  `completableretryuntil`-  `completablesafesubscribe`-  `completablesequenceequal`-  `completablestartwith` (`maybesource` `singlesource`)- [x] `completableswitchonnext`- [x] `completableswitchonnextdelayerror`- [x] `completabletofuture`- [x] `maybeblockingsubscribe`- [x] `maybeconcatarrayeagerdelayerror`- [x] `maybeconcatmapcompletable`- [x] `maybeconcatmapsingle`- [x] `maybedematerialize`- [x] `maybefromobservable`- [x] `maybedoonlifecycle`- [x] `maybefrompublisher`- [x] `maybesafesubscribe`- [x] `maybestartwith` - [x] `maybetimeinterval`- [x] `maybetimestamp`- [x] `maybetofuture`- [x] `maybeswitchonnext`- [x] `maybeswitchonnextdelayerror`- [x] `singleblockingsubscribe`- [x] `singleconcatarraydelayerror`- [x] `singleconcatarrayeagerdelayerror`- [x] `singleconcatdelayerror`- [x] `singleconcatmap`- [x] `singleconcatmapcompletable`- [x] `singleconcatmapmaybe`- [x] `singledoonlifecycle`- [x] `singlefrommaybe`- [x] `singlemergearray`- [x] `singlemergearraydelayerror`- [x] `singleoftype`- [x] `singleonerrorcomplete`- [x] `singleretryuntil`- [x] `singlesafesubscribe`- [x] `singlesequenceequal` (rename `equals`)- [x] `singlestartwith` - [x] `singletimeinterval`- [x] `singletimestamp`- [x] `singleswitchonnext`- [x] `singleswitchonnextdelayerror`- [x] `flowablefromaction`- [x] `flowablefromcompletable`- [x] `flowablefrommaybe`- [x] `flowablefromobservable`- [x] `flowablefromrunnable`- [x] `flowablefromsingle`- [x] `flowableonerrorcomplete`- [x] `flowablestartwith` (`maybesource` `singlesource` `completablesource`)- [x] `observablefromaction`- [x] `observablefromcompletable`- [x] `observablefrommaybe`- [x] `observablefromrunnable`- [x] `observablefromsingle`- [x] `observableonerrorcomplete`- [x] `observablestartwith` (`maybesource` `singlesource` `completablesource`);can i work on it? || @souraexx sure pick one im currently working on all `onerrorcomplete`s ||;1;0;3x: add completableonerrorresumewith;
6869;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: add single/completable retryuntil + marbles;retryuntil  was missing from  single  and  completable .;;5806.0;3x: add single/completable retryuntil + marbles;`retryuntil` was missing from `single` and `completable`added marble for `maybe` as wellrelated #6852 #5806(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableretryuntilpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleretryuntilpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mayberetryuntilpng); merging 6869 ;3x: maybe incorrect or missing marbles (tracking issue);-  `amb`: missing diagram-  `ambarray`: missing diagram-  `concat(iterable)`: missing diagram-  `concat(publisher)`: missing diagram-  `concat(publisher int)`: missing diagram-  `concatarray`: missing diagram-  `concatarraydelayerror`: indicate error delayed 1 marble per source-  `concatarrayeager`: missing diagram-  `concatdelayerror(iterable)`: missing diagram-  `concatdelayerror(publisher)`: missing diagram- [x] `concatdelayerror(publisher int)`: fix overlap/misalignment inside the operator box- [x] `concateager(iterable)`: missing diagram- [x] `concateager(publisher)`: missing diagram- [x] `create`: missing diagram- [x] `defer`: missing diagram- [x] `error(callable)`: indicate callable returns the error- [x] `fromaction`: missing diagram- [x] `fromcompletable`: missing diagram- [x] `fromsingle`: missing diagram- [x] `fromcallable`: missing diagram- [x] `fromfuture(future)`: operator name in the box indicate future is the parameter- [x] `fromfuture(future long timeunit)`: operator name in the box indicate future is the parameter indicate timeout- [x] `fromrunnable`: missing diagram- [x] `merge(iterable)`: missing diagram- [x] `merge(publisher)`: missing diagram- [x] `merge(publisher int)`: missing diagram- [x] `mergearray`: missing diagram- [x] `mergearraydelayerror`: one marble per maybe source- [x] `mergedelayerror(iterable)`: one marble per maybe source- [x] `mergedelayerror(publisher)`: one marble per maybe source- [x] `mergedelayerror(maybe maybe )`: one marble per maybe source- [x] `sequenceequal` + 1: result should be `single`- [x] `timer` + 1: result should be maybe- [x] `using` + 1: rework to indicate the created maybe- [x] `wrap`: missing marble- [x] `zip(iterable)`: one marble per maybe source result should be maybe- [x] `zip(maybe maybe )` + 8: one marble per maybe source result should be maybe- [x] `ziparray`: one marble per maybe source result should be maybe- [x] `ambwith`: one marble per maybe source result should be maybe- [x] ~~`as`: missing diagram~~ operator removed- [x] `blockingget` + 1: missing diagram- [x] `cache`: one marble per maybe source result should be maybe- [x] `cast`: missing diagram- [x] `compose`: missing diagram- [x] `concatmap`: indicate maybe target indicate empty source- [x] `concatwith`: one marble per maybe source result should be maybe operator name indicate other is a parameter- [x] `contains`: one marble per maybe source result should be single empty case- [x] `count`: one marble per maybe operator name result should be single empty case- [x] `defaultifempty`: non-empty case result should be maybe- [x] `delay(time)` + 3: one marble per maybe source result should be maybe- [x] `delay(publisher)`: one marble per maybe one signal by the publisher empty publisher case- [x] `delaysubscription(publisher)`: missing diagram- [x] `delaysubscription(time)` + 1: one marble per maybe source result should be maybe- [x] `doaftersuccess`: missing diagram- [x] `doafterterminate`: operator name one marble per maybe result should be maybe- [x] `dofinally`: missing diagram- [x] `doondispose`: missing diagram- [x] `dooncomplete`: one marble per maybe result should be maybe- [x] `doonerror`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonsubscribe`: missing diagram- [x] `doonsuccess`: missing diagram- [x] `doonterminate`: one marble per maybe result should be maybe- [x] `filter`: one marble per maybe result should be maybe- [x] `flatmap(function function callable)`: one marble per maybe result should be maybe- [x] `flatmap(function bifunction)`: one marble per maybe result should be maybe- [x] `flatmapobservable`: should be mapped into an observable- [x] `flatmappublisher`: indicate backpressure- [x] `flatmapsingle`: indicate empty maybe results in error- [x] `flatmapsingleelement`: operator name indicate empty maybe- [x] `flatmapcompletable`: indicate empty maybe- [x] `hide`: missing diagram- [x] `ignoreelement`: operator name one marble per maybe result should be maybe- [x] `isempty`: result should be single- [x] `mergewith`: operator name one marble per maybe indicate backpressure- [x] `oftype`: one marble per maybe- [x] `onerrorcomplete` + 1: missing diagram- [x] `onerrorresumenext`: one marble per maybe result should be maybe- [x] `onerrorresumewith`: one marble per maybe result should be maybe- [x] `onerrorreturn`: one marble per maybe result should be maybe indicate callback- [x] `onerrorreturnitem`: operator name one marble per maybe result should be maybe indicate normal outcome- [x] ~~`onexceptionresumenext`: operator takes a maybe source directly~~ operator removed- [x] `onterminatedetach`: missing diagram- [x] `repeat` + 1: one marble per source indicate backpressure indicate repeat conditions- [x] `repeatuntil`: operator name repeat condition indicate backpressure- [x] `repeatwhen`: one marble per maybe indicate backpressure- [x] `retry` + 2: one marble per maybe result should be maybe indicate repeat conditions- [x] `retry(int predicate)`: missing diagram- [x] `retry(predicate)`: missing diagram- [x] `retryuntil`: missing diagram- [x] `retrywhen`: one marble per maybe output should be maybe- [x] `switchifempty` + 1: improve diagrams indicate argument type- [x] `takeuntil` + 1: one marble per maybe output should be maybe- [x] `timeout` + 3: one marble per maybe output should be maybe- [x] `timeout(maybesource)`: missing diagram- [x] `timeout(maybesource maybesource)`: missing diagram- [x] `timeout(publisher)`: missing diagram- [x] `timeout(publisher maybesource)`: missing diagram- [x] `to`: missing diagram- [x] `toflowable`: missing diagram- [x] `toobservable`: missing diagram- [x] `tosingle` + 1: missing diagram- [x] `unsubscribeon`: missing diagram- [x] `zipwith`: one marble per maybe output should be maybe;here is the excel file i draw the diagrams in:  ||;1;0;3x: add s/c retryuntil + marbles;
6869;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: add single/completable retryuntil + marbles;retryuntil  was missing from  single  and  completable .;;6852.0;3x: add single/completable retryuntil + marbles;`retryuntil` was missing from `single` and `completable`added marble for `maybe` as wellrelated #6852 #5806(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableretryuntilpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleretryuntilpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mayberetryuntilpng); merging 6869 ;3x: missing operators (tracking issue); present in some but not other classes (when they make sense there too):-  `completableconcatarraydelayerror`-  `completableblockingsubscribe`-  `completabledoonlifecycle`-  `completableonerrorresumewith`-  `completableonerrorreturn`-  `completableonerrorreturnitem`-  `completableretryuntil`-  `completablesafesubscribe`-  `completablesequenceequal`-  `completablestartwith` (`maybesource` `singlesource`)- [x] `completableswitchonnext`- [x] `completableswitchonnextdelayerror`- [x] `completabletofuture`- [x] `maybeblockingsubscribe`- [x] `maybeconcatarrayeagerdelayerror`- [x] `maybeconcatmapcompletable`- [x] `maybeconcatmapsingle`- [x] `maybedematerialize`- [x] `maybefromobservable`- [x] `maybedoonlifecycle`- [x] `maybefrompublisher`- [x] `maybesafesubscribe`- [x] `maybestartwith` - [x] `maybetimeinterval`- [x] `maybetimestamp`- [x] `maybetofuture`- [x] `maybeswitchonnext`- [x] `maybeswitchonnextdelayerror`- [x] `singleblockingsubscribe`- [x] `singleconcatarraydelayerror`- [x] `singleconcatarrayeagerdelayerror`- [x] `singleconcatdelayerror`- [x] `singleconcatmap`- [x] `singleconcatmapcompletable`- [x] `singleconcatmapmaybe`- [x] `singledoonlifecycle`- [x] `singlefrommaybe`- [x] `singlemergearray`- [x] `singlemergearraydelayerror`- [x] `singleoftype`- [x] `singleonerrorcomplete`- [x] `singleretryuntil`- [x] `singlesafesubscribe`- [x] `singlesequenceequal` (rename `equals`)- [x] `singlestartwith` - [x] `singletimeinterval`- [x] `singletimestamp`- [x] `singleswitchonnext`- [x] `singleswitchonnextdelayerror`- [x] `flowablefromaction`- [x] `flowablefromcompletable`- [x] `flowablefrommaybe`- [x] `flowablefromobservable`- [x] `flowablefromrunnable`- [x] `flowablefromsingle`- [x] `flowableonerrorcomplete`- [x] `flowablestartwith` (`maybesource` `singlesource` `completablesource`)- [x] `observablefromaction`- [x] `observablefromcompletable`- [x] `observablefrommaybe`- [x] `observablefromrunnable`- [x] `observablefromsingle`- [x] `observableonerrorcomplete`- [x] `observablestartwith` (`maybesource` `singlesource` `completablesource`);can i work on it? || @souraexx sure pick one im currently working on all `onerrorcomplete`s ||;1;0;3x: add s/c retryuntil + marbles;
6870;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: add maybe/single/completable switchonnext & switchonnextdelayerror;add the missing  switchonnext  and  switchonnextdelayerror  operators  which are essentially delegated to the respective  flowable::switchmapx  operators with identity mapping.;;6852.0;3x: add maybe/single/completable switchonnext & switchonnextdelayerror;add the missing `switchonnext` and `switchonnextdelayerror` operators which are essentially delegated to the respective `flowable::switchmapx` operators with identity mappingrelated #6852(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableswitchonnextpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableswitchonnextdelayerrorpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleswitchonnextpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleswitchonnextdelayerrorpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeswitchonnextpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeswitchonnextdelayerrorpng);;3x: missing operators (tracking issue); present in some but not other classes (when they make sense there too):-  `completableconcatarraydelayerror`-  `completableblockingsubscribe`-  `completabledoonlifecycle`-  `completableonerrorresumewith`-  `completableonerrorreturn`-  `completableonerrorreturnitem`-  `completableretryuntil`-  `completablesafesubscribe`-  `completablesequenceequal`-  `completablestartwith` (`maybesource` `singlesource`)- [x] `completableswitchonnext`- [x] `completableswitchonnextdelayerror`- [x] `completabletofuture`- [x] `maybeblockingsubscribe`- [x] `maybeconcatarrayeagerdelayerror`- [x] `maybeconcatmapcompletable`- [x] `maybeconcatmapsingle`- [x] `maybedematerialize`- [x] `maybefromobservable`- [x] `maybedoonlifecycle`- [x] `maybefrompublisher`- [x] `maybesafesubscribe`- [x] `maybestartwith` - [x] `maybetimeinterval`- [x] `maybetimestamp`- [x] `maybetofuture`- [x] `maybeswitchonnext`- [x] `maybeswitchonnextdelayerror`- [x] `singleblockingsubscribe`- [x] `singleconcatarraydelayerror`- [x] `singleconcatarrayeagerdelayerror`- [x] `singleconcatdelayerror`- [x] `singleconcatmap`- [x] `singleconcatmapcompletable`- [x] `singleconcatmapmaybe`- [x] `singledoonlifecycle`- [x] `singlefrommaybe`- [x] `singlemergearray`- [x] `singlemergearraydelayerror`- [x] `singleoftype`- [x] `singleonerrorcomplete`- [x] `singleretryuntil`- [x] `singlesafesubscribe`- [x] `singlesequenceequal` (rename `equals`)- [x] `singlestartwith` - [x] `singletimeinterval`- [x] `singletimestamp`- [x] `singleswitchonnext`- [x] `singleswitchonnextdelayerror`- [x] `flowablefromaction`- [x] `flowablefromcompletable`- [x] `flowablefrommaybe`- [x] `flowablefromobservable`- [x] `flowablefromrunnable`- [x] `flowablefromsingle`- [x] `flowableonerrorcomplete`- [x] `flowablestartwith` (`maybesource` `singlesource` `completablesource`)- [x] `observablefromaction`- [x] `observablefromcompletable`- [x] `observablefrommaybe`- [x] `observablefromrunnable`- [x] `observablefromsingle`- [x] `observableonerrorcomplete`- [x] `observablestartwith` (`maybesource` `singlesource` `completablesource`);can i work on it? || @souraexx sure pick one im currently working on all `onerrorcomplete`s ||;1;0;fix wording of the completable variant;
6871;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: add maybe.dematerialize;add the  dematerialize  operator to  maybe  to be in sync with the other classes.;;6852.0;3x: add maybedematerialize;add the `dematerialize` operator to `maybe` to be in sync with the other classesrelated #6852 (https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedematerializepng); merging 6871 ;3x: missing operators (tracking issue); present in some but not other classes (when they make sense there too):-  `completableconcatarraydelayerror`-  `completableblockingsubscribe`-  `completabledoonlifecycle`-  `completableonerrorresumewith`-  `completableonerrorreturn`-  `completableonerrorreturnitem`-  `completableretryuntil`-  `completablesafesubscribe`-  `completablesequenceequal`-  `completablestartwith` (`maybesource` `singlesource`)- [x] `completableswitchonnext`- [x] `completableswitchonnextdelayerror`- [x] `completabletofuture`- [x] `maybeblockingsubscribe`- [x] `maybeconcatarrayeagerdelayerror`- [x] `maybeconcatmapcompletable`- [x] `maybeconcatmapsingle`- [x] `maybedematerialize`- [x] `maybefromobservable`- [x] `maybedoonlifecycle`- [x] `maybefrompublisher`- [x] `maybesafesubscribe`- [x] `maybestartwith` - [x] `maybetimeinterval`- [x] `maybetimestamp`- [x] `maybetofuture`- [x] `maybeswitchonnext`- [x] `maybeswitchonnextdelayerror`- [x] `singleblockingsubscribe`- [x] `singleconcatarraydelayerror`- [x] `singleconcatarrayeagerdelayerror`- [x] `singleconcatdelayerror`- [x] `singleconcatmap`- [x] `singleconcatmapcompletable`- [x] `singleconcatmapmaybe`- [x] `singledoonlifecycle`- [x] `singlefrommaybe`- [x] `singlemergearray`- [x] `singlemergearraydelayerror`- [x] `singleoftype`- [x] `singleonerrorcomplete`- [x] `singleretryuntil`- [x] `singlesafesubscribe`- [x] `singlesequenceequal` (rename `equals`)- [x] `singlestartwith` - [x] `singletimeinterval`- [x] `singletimestamp`- [x] `singleswitchonnext`- [x] `singleswitchonnextdelayerror`- [x] `flowablefromaction`- [x] `flowablefromcompletable`- [x] `flowablefrommaybe`- [x] `flowablefromobservable`- [x] `flowablefromrunnable`- [x] `flowablefromsingle`- [x] `flowableonerrorcomplete`- [x] `flowablestartwith` (`maybesource` `singlesource` `completablesource`)- [x] `observablefromaction`- [x] `observablefromcompletable`- [x] `observablefrommaybe`- [x] `observablefromrunnable`- [x] `observablefromsingle`- [x] `observableonerrorcomplete`- [x] `observablestartwith` (`maybesource` `singlesource` `completablesource`);can i work on it? || @souraexx sure pick one im currently working on all `onerrorcomplete`s ||;1;0;3x: add maybedematerialize;
6873;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: add many fromx operators + marbles;add a cross section of  from  operators (![present]( [ fromaction ]( ..  fromsingle ) :;;6852.0;3x: add many fromx operators + marbles;add a cross section of `from` operators (![present]( [`fromaction`](  `fromsingle`) :operator | f | o | m | s | c |-|-|-|-|-|-|<a namefromaction></a>`fromaction`|![present]( <sup titlenever empty>([23](#notes-23))</sup>|![present]( namefromcompletable></a>`fromcompletable`|![present]( <sup titlealways error>([72](#notes-72))</sup>|![absent]( <sup titleuse wrap()>([73](#notes-73))</sup>|<a namefrommaybe></a>`frommaybe`|![present]( <sup titleuse wrap()>([73](#notes-73))</sup>|![present]( namefromobservable></a>`fromobservable`|![present]( <sup titleuse wrap()>([73](#notes-73))</sup>|![present]( namefrompublisher></a>`frompublisher`|![present]( namefromrunnable></a>`fromrunnable`|![present]( <sup titlenever empty>([23](#notes-23))</sup>|![present]( namefromsingle></a>`fromsingle`|![present]( <sup titleuse wrap()>([73](#notes-73))</sup>|![present]( #6852 (https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowablefromactionpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowablefromcompletablepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowablefrommaybepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowablefromobservablebufferpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowablefromobservablelatestpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowablefromobservabledroppng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowablefromobservableerrorpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowablefromobservablemissingpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowablefromrunnablepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowablefromsinglepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observablefromactionpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observablefromcompletablepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observablefrommaybepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observablefromrunnablepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observablefromsinglepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybefrompublisherpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybefromobservablepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlefrommaybepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlefrommaybevpng); merging 6873 ;3x: missing operators (tracking issue); present in some but not other classes (when they make sense there too):-  `completableconcatarraydelayerror`-  `completableblockingsubscribe`-  `completabledoonlifecycle`-  `completableonerrorresumewith`-  `completableonerrorreturn`-  `completableonerrorreturnitem`-  `completableretryuntil`-  `completablesafesubscribe`-  `completablesequenceequal`-  `completablestartwith` (`maybesource` `singlesource`)- [x] `completableswitchonnext`- [x] `completableswitchonnextdelayerror`- [x] `completabletofuture`- [x] `maybeblockingsubscribe`- [x] `maybeconcatarrayeagerdelayerror`- [x] `maybeconcatmapcompletable`- [x] `maybeconcatmapsingle`- [x] `maybedematerialize`- [x] `maybefromobservable`- [x] `maybedoonlifecycle`- [x] `maybefrompublisher`- [x] `maybesafesubscribe`- [x] `maybestartwith` - [x] `maybetimeinterval`- [x] `maybetimestamp`- [x] `maybetofuture`- [x] `maybeswitchonnext`- [x] `maybeswitchonnextdelayerror`- [x] `singleblockingsubscribe`- [x] `singleconcatarraydelayerror`- [x] `singleconcatarrayeagerdelayerror`- [x] `singleconcatdelayerror`- [x] `singleconcatmap`- [x] `singleconcatmapcompletable`- [x] `singleconcatmapmaybe`- [x] `singledoonlifecycle`- [x] `singlefrommaybe`- [x] `singlemergearray`- [x] `singlemergearraydelayerror`- [x] `singleoftype`- [x] `singleonerrorcomplete`- [x] `singleretryuntil`- [x] `singlesafesubscribe`- [x] `singlesequenceequal` (rename `equals`)- [x] `singlestartwith` - [x] `singletimeinterval`- [x] `singletimestamp`- [x] `singleswitchonnext`- [x] `singleswitchonnextdelayerror`- [x] `flowablefromaction`- [x] `flowablefromcompletable`- [x] `flowablefrommaybe`- [x] `flowablefromobservable`- [x] `flowablefromrunnable`- [x] `flowablefromsingle`- [x] `flowableonerrorcomplete`- [x] `flowablestartwith` (`maybesource` `singlesource` `completablesource`)- [x] `observablefromaction`- [x] `observablefromcompletable`- [x] `observablefrommaybe`- [x] `observablefromrunnable`- [x] `observablefromsingle`- [x] `observableonerrorcomplete`- [x] `observablestartwith` (`maybesource` `singlesource` `completablesource`);can i work on it? || @souraexx sure pick one im currently working on all `onerrorcomplete`s ||;1;0;3x: add many fromx operators + marbles;
6874;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: add timeinterval & timestamp to m/s;add  timeinterval  and  timestamp  operators  (4 overloads each). to  maybe  and  single .;;6852.0;3x: add timeinterval & timestamp to m/s;add `timeinterval` and `timestamp` operators  (4 overloads each) to `maybe` and `single`related #6852 (https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetimeintervalpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetimeintervalspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetimestamppng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetimestampspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singletimeintervalpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singletimeintervalspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singletimestamppng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singletimestampspng); merging 6874 ;3x: missing operators (tracking issue); present in some but not other classes (when they make sense there too):-  `completableconcatarraydelayerror`-  `completableblockingsubscribe`-  `completabledoonlifecycle`-  `completableonerrorresumewith`-  `completableonerrorreturn`-  `completableonerrorreturnitem`-  `completableretryuntil`-  `completablesafesubscribe`-  `completablesequenceequal`-  `completablestartwith` (`maybesource` `singlesource`)- [x] `completableswitchonnext`- [x] `completableswitchonnextdelayerror`- [x] `completabletofuture`- [x] `maybeblockingsubscribe`- [x] `maybeconcatarrayeagerdelayerror`- [x] `maybeconcatmapcompletable`- [x] `maybeconcatmapsingle`- [x] `maybedematerialize`- [x] `maybefromobservable`- [x] `maybedoonlifecycle`- [x] `maybefrompublisher`- [x] `maybesafesubscribe`- [x] `maybestartwith` - [x] `maybetimeinterval`- [x] `maybetimestamp`- [x] `maybetofuture`- [x] `maybeswitchonnext`- [x] `maybeswitchonnextdelayerror`- [x] `singleblockingsubscribe`- [x] `singleconcatarraydelayerror`- [x] `singleconcatarrayeagerdelayerror`- [x] `singleconcatdelayerror`- [x] `singleconcatmap`- [x] `singleconcatmapcompletable`- [x] `singleconcatmapmaybe`- [x] `singledoonlifecycle`- [x] `singlefrommaybe`- [x] `singlemergearray`- [x] `singlemergearraydelayerror`- [x] `singleoftype`- [x] `singleonerrorcomplete`- [x] `singleretryuntil`- [x] `singlesafesubscribe`- [x] `singlesequenceequal` (rename `equals`)- [x] `singlestartwith` - [x] `singletimeinterval`- [x] `singletimestamp`- [x] `singleswitchonnext`- [x] `singleswitchonnextdelayerror`- [x] `flowablefromaction`- [x] `flowablefromcompletable`- [x] `flowablefrommaybe`- [x] `flowablefromobservable`- [x] `flowablefromrunnable`- [x] `flowablefromsingle`- [x] `flowableonerrorcomplete`- [x] `flowablestartwith` (`maybesource` `singlesource` `completablesource`)- [x] `observablefromaction`- [x] `observablefromcompletable`- [x] `observablefrommaybe`- [x] `observablefromrunnable`- [x] `observablefromsingle`- [x] `observableonerrorcomplete`- [x] `observablestartwith` (`maybesource` `singlesource` `completablesource`);can i work on it? || @souraexx sure pick one im currently working on all `onerrorcomplete`s ||;1;0;fix timed coverage;
6875;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: add maybe/completable tofuture;add  tofuture  to  maybe  and  completable .;;6852.0;3x: add maybe/completable tofuture;add `tofuture` to `maybe` and `completable`related #6852 (https://githubcom/reactivex/rxjava/wiki/images/rx-operators/maybetofuturepng)![image](https://githubcom/reactivex/rxjava/wiki/images/rx-operators/completabletofuturepng); merging 6875 ;3x: missing operators (tracking issue); present in some but not other classes (when they make sense there too):-  `completableconcatarraydelayerror`-  `completableblockingsubscribe`-  `completabledoonlifecycle`-  `completableonerrorresumewith`-  `completableonerrorreturn`-  `completableonerrorreturnitem`-  `completableretryuntil`-  `completablesafesubscribe`-  `completablesequenceequal`-  `completablestartwith` (`maybesource` `singlesource`)- [x] `completableswitchonnext`- [x] `completableswitchonnextdelayerror`- [x] `completabletofuture`- [x] `maybeblockingsubscribe`- [x] `maybeconcatarrayeagerdelayerror`- [x] `maybeconcatmapcompletable`- [x] `maybeconcatmapsingle`- [x] `maybedematerialize`- [x] `maybefromobservable`- [x] `maybedoonlifecycle`- [x] `maybefrompublisher`- [x] `maybesafesubscribe`- [x] `maybestartwith` - [x] `maybetimeinterval`- [x] `maybetimestamp`- [x] `maybetofuture`- [x] `maybeswitchonnext`- [x] `maybeswitchonnextdelayerror`- [x] `singleblockingsubscribe`- [x] `singleconcatarraydelayerror`- [x] `singleconcatarrayeagerdelayerror`- [x] `singleconcatdelayerror`- [x] `singleconcatmap`- [x] `singleconcatmapcompletable`- [x] `singleconcatmapmaybe`- [x] `singledoonlifecycle`- [x] `singlefrommaybe`- [x] `singlemergearray`- [x] `singlemergearraydelayerror`- [x] `singleoftype`- [x] `singleonerrorcomplete`- [x] `singleretryuntil`- [x] `singlesafesubscribe`- [x] `singlesequenceequal` (rename `equals`)- [x] `singlestartwith` - [x] `singletimeinterval`- [x] `singletimestamp`- [x] `singleswitchonnext`- [x] `singleswitchonnextdelayerror`- [x] `flowablefromaction`- [x] `flowablefromcompletable`- [x] `flowablefrommaybe`- [x] `flowablefromobservable`- [x] `flowablefromrunnable`- [x] `flowablefromsingle`- [x] `flowableonerrorcomplete`- [x] `flowablestartwith` (`maybesource` `singlesource` `completablesource`)- [x] `observablefromaction`- [x] `observablefromcompletable`- [x] `observablefrommaybe`- [x] `observablefromrunnable`- [x] `observablefromsingle`- [x] `observableonerrorcomplete`- [x] `observablestartwith` (`maybesource` `singlesource` `completablesource`);can i work on it? || @souraexx sure pick one im currently working on all `onerrorcomplete`s ||;1;0;fix copy-paste mistakes;
6876;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: add single.oftype;add  oftype  to  single  already available to the other non-empty base types.;;580.0;3x: add singleoftype;add `oftype` to `single` already available to the other non-empty base typesrelated #6852 ( addition diagrams for `maybefilter` and `maybeoftype` have been updated:![image]( #5806; merging 6876 ;crlf fixes;issue #579in case the manual mode is chosen;#519  i added the gitattributes file in this commit:  and then let git renormalize itself as per  ||;1;0;3x: add singleoftype;
6876;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: add single.oftype;add  oftype  to  single  already available to the other non-empty base types.;;6852.0;3x: add singleoftype;add `oftype` to `single` already available to the other non-empty base typesrelated #6852 ( addition diagrams for `maybefilter` and `maybeoftype` have been updated:![image]( #5806; merging 6876 ;3x: missing operators (tracking issue); present in some but not other classes (when they make sense there too):-  `completableconcatarraydelayerror`-  `completableblockingsubscribe`-  `completabledoonlifecycle`-  `completableonerrorresumewith`-  `completableonerrorreturn`-  `completableonerrorreturnitem`-  `completableretryuntil`-  `completablesafesubscribe`-  `completablesequenceequal`-  `completablestartwith` (`maybesource` `singlesource`)- [x] `completableswitchonnext`- [x] `completableswitchonnextdelayerror`- [x] `completabletofuture`- [x] `maybeblockingsubscribe`- [x] `maybeconcatarrayeagerdelayerror`- [x] `maybeconcatmapcompletable`- [x] `maybeconcatmapsingle`- [x] `maybedematerialize`- [x] `maybefromobservable`- [x] `maybedoonlifecycle`- [x] `maybefrompublisher`- [x] `maybesafesubscribe`- [x] `maybestartwith` - [x] `maybetimeinterval`- [x] `maybetimestamp`- [x] `maybetofuture`- [x] `maybeswitchonnext`- [x] `maybeswitchonnextdelayerror`- [x] `singleblockingsubscribe`- [x] `singleconcatarraydelayerror`- [x] `singleconcatarrayeagerdelayerror`- [x] `singleconcatdelayerror`- [x] `singleconcatmap`- [x] `singleconcatmapcompletable`- [x] `singleconcatmapmaybe`- [x] `singledoonlifecycle`- [x] `singlefrommaybe`- [x] `singlemergearray`- [x] `singlemergearraydelayerror`- [x] `singleoftype`- [x] `singleonerrorcomplete`- [x] `singleretryuntil`- [x] `singlesafesubscribe`- [x] `singlesequenceequal` (rename `equals`)- [x] `singlestartwith` - [x] `singletimeinterval`- [x] `singletimestamp`- [x] `singleswitchonnext`- [x] `singleswitchonnextdelayerror`- [x] `flowablefromaction`- [x] `flowablefromcompletable`- [x] `flowablefrommaybe`- [x] `flowablefromobservable`- [x] `flowablefromrunnable`- [x] `flowablefromsingle`- [x] `flowableonerrorcomplete`- [x] `flowablestartwith` (`maybesource` `singlesource` `completablesource`)- [x] `observablefromaction`- [x] `observablefromcompletable`- [x] `observablefrommaybe`- [x] `observablefromrunnable`- [x] `observablefromsingle`- [x] `observableonerrorcomplete`- [x] `observablestartwith` (`maybesource` `singlesource` `completablesource`);can i work on it? || @souraexx sure pick one im currently working on all `onerrorcomplete`s ||;1;0;3x: add singleoftype;
6877;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: add doonlifecycle to maybe  single & completable;add the  doonlifecycle  operator to the remaining classes.;;6852.0;3x: add doonlifecycle to maybe single & completable;add the `doonlifecycle` operator to the remaining classesrelated #6852 (https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedoonlifecyclepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singledoonlifecyclepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completabledoonlifecyclepng); merging 6877 ;3x: missing operators (tracking issue); present in some but not other classes (when they make sense there too):-  `completableconcatarraydelayerror`-  `completableblockingsubscribe`-  `completabledoonlifecycle`-  `completableonerrorresumewith`-  `completableonerrorreturn`-  `completableonerrorreturnitem`-  `completableretryuntil`-  `completablesafesubscribe`-  `completablesequenceequal`-  `completablestartwith` (`maybesource` `singlesource`)- [x] `completableswitchonnext`- [x] `completableswitchonnextdelayerror`- [x] `completabletofuture`- [x] `maybeblockingsubscribe`- [x] `maybeconcatarrayeagerdelayerror`- [x] `maybeconcatmapcompletable`- [x] `maybeconcatmapsingle`- [x] `maybedematerialize`- [x] `maybefromobservable`- [x] `maybedoonlifecycle`- [x] `maybefrompublisher`- [x] `maybesafesubscribe`- [x] `maybestartwith` - [x] `maybetimeinterval`- [x] `maybetimestamp`- [x] `maybetofuture`- [x] `maybeswitchonnext`- [x] `maybeswitchonnextdelayerror`- [x] `singleblockingsubscribe`- [x] `singleconcatarraydelayerror`- [x] `singleconcatarrayeagerdelayerror`- [x] `singleconcatdelayerror`- [x] `singleconcatmap`- [x] `singleconcatmapcompletable`- [x] `singleconcatmapmaybe`- [x] `singledoonlifecycle`- [x] `singlefrommaybe`- [x] `singlemergearray`- [x] `singlemergearraydelayerror`- [x] `singleoftype`- [x] `singleonerrorcomplete`- [x] `singleretryuntil`- [x] `singlesafesubscribe`- [x] `singlesequenceequal` (rename `equals`)- [x] `singlestartwith` - [x] `singletimeinterval`- [x] `singletimestamp`- [x] `singleswitchonnext`- [x] `singleswitchonnextdelayerror`- [x] `flowablefromaction`- [x] `flowablefromcompletable`- [x] `flowablefrommaybe`- [x] `flowablefromobservable`- [x] `flowablefromrunnable`- [x] `flowablefromsingle`- [x] `flowableonerrorcomplete`- [x] `flowablestartwith` (`maybesource` `singlesource` `completablesource`)- [x] `observablefromaction`- [x] `observablefromcompletable`- [x] `observablefrommaybe`- [x] `observablefromrunnable`- [x] `observablefromsingle`- [x] `observableonerrorcomplete`- [x] `observablestartwith` (`maybesource` `singlesource` `completablesource`);can i work on it? || @souraexx sure pick one im currently working on all `onerrorcomplete`s ||;1;0;3x: add doonlifecycle to m/s/c;
6879;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: add concatmapx operators (aliases);add the following operator aliases:;;6852.0;3x: add concatmapx operators (aliases);add the following operator aliases:- `maybeconcatmapcompletable`- `maybeconcatmapsingle`- `singleconcatmapcompletable`- `singleconcatmap`- `singleconcatmapmaybe`related #6852 ( addition some missing or wrong `maybe` marbles have been :![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeconcatmappng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeflatmapcompletable3png)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeflatmapsingle3png)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeflatmapsingleelementpng); merging 6879 ;3x: missing operators (tracking issue); present in some but not other classes (when they make sense there too):-  `completableconcatarraydelayerror`-  `completableblockingsubscribe`-  `completabledoonlifecycle`-  `completableonerrorresumewith`-  `completableonerrorreturn`-  `completableonerrorreturnitem`-  `completableretryuntil`-  `completablesafesubscribe`-  `completablesequenceequal`-  `completablestartwith` (`maybesource` `singlesource`)- [x] `completableswitchonnext`- [x] `completableswitchonnextdelayerror`- [x] `completabletofuture`- [x] `maybeblockingsubscribe`- [x] `maybeconcatarrayeagerdelayerror`- [x] `maybeconcatmapcompletable`- [x] `maybeconcatmapsingle`- [x] `maybedematerialize`- [x] `maybefromobservable`- [x] `maybedoonlifecycle`- [x] `maybefrompublisher`- [x] `maybesafesubscribe`- [x] `maybestartwith` - [x] `maybetimeinterval`- [x] `maybetimestamp`- [x] `maybetofuture`- [x] `maybeswitchonnext`- [x] `maybeswitchonnextdelayerror`- [x] `singleblockingsubscribe`- [x] `singleconcatarraydelayerror`- [x] `singleconcatarrayeagerdelayerror`- [x] `singleconcatdelayerror`- [x] `singleconcatmap`- [x] `singleconcatmapcompletable`- [x] `singleconcatmapmaybe`- [x] `singledoonlifecycle`- [x] `singlefrommaybe`- [x] `singlemergearray`- [x] `singlemergearraydelayerror`- [x] `singleoftype`- [x] `singleonerrorcomplete`- [x] `singleretryuntil`- [x] `singlesafesubscribe`- [x] `singlesequenceequal` (rename `equals`)- [x] `singlestartwith` - [x] `singletimeinterval`- [x] `singletimestamp`- [x] `singleswitchonnext`- [x] `singleswitchonnextdelayerror`- [x] `flowablefromaction`- [x] `flowablefromcompletable`- [x] `flowablefrommaybe`- [x] `flowablefromobservable`- [x] `flowablefromrunnable`- [x] `flowablefromsingle`- [x] `flowableonerrorcomplete`- [x] `flowablestartwith` (`maybesource` `singlesource` `completablesource`)- [x] `observablefromaction`- [x] `observablefromcompletable`- [x] `observablefrommaybe`- [x] `observablefromrunnable`- [x] `observablefromsingle`- [x] `observableonerrorcomplete`- [x] `observablestartwith` (`maybesource` `singlesource` `completablesource`);can i work on it? || @souraexx sure pick one im currently working on all `onerrorcomplete`s ||;1;0;3x: add concatmapx operators (aliases);
6881;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: add various concatxdelayerror operators;add the following concat kind of operators:;;6852.0;3x: add various concatxdelayerror operators;add the following concat kind of operators:- `maybeconcatarrayeagerdelayerror`- `maybeconcatdelayerror(publisher int)`- `singleconcatarraydelayerror`- `singleconcatarrayeagerdelayerror`- `singleconcatdelayerror` + 2- `completableconcatarraydelayerror`- `completableconcatdelayerror` + 2related #6852 ( addition the `maybeconcatdelayerror(publisher)` marble has been :![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeconcatdelayerror3ipng); merging 6881 ;3x: missing operators (tracking issue); present in some but not other classes (when they make sense there too):-  `completableconcatarraydelayerror`-  `completableblockingsubscribe`-  `completabledoonlifecycle`-  `completableonerrorresumewith`-  `completableonerrorreturn`-  `completableonerrorreturnitem`-  `completableretryuntil`-  `completablesafesubscribe`-  `completablesequenceequal`-  `completablestartwith` (`maybesource` `singlesource`)- [x] `completableswitchonnext`- [x] `completableswitchonnextdelayerror`- [x] `completabletofuture`- [x] `maybeblockingsubscribe`- [x] `maybeconcatarrayeagerdelayerror`- [x] `maybeconcatmapcompletable`- [x] `maybeconcatmapsingle`- [x] `maybedematerialize`- [x] `maybefromobservable`- [x] `maybedoonlifecycle`- [x] `maybefrompublisher`- [x] `maybesafesubscribe`- [x] `maybestartwith` - [x] `maybetimeinterval`- [x] `maybetimestamp`- [x] `maybetofuture`- [x] `maybeswitchonnext`- [x] `maybeswitchonnextdelayerror`- [x] `singleblockingsubscribe`- [x] `singleconcatarraydelayerror`- [x] `singleconcatarrayeagerdelayerror`- [x] `singleconcatdelayerror`- [x] `singleconcatmap`- [x] `singleconcatmapcompletable`- [x] `singleconcatmapmaybe`- [x] `singledoonlifecycle`- [x] `singlefrommaybe`- [x] `singlemergearray`- [x] `singlemergearraydelayerror`- [x] `singleoftype`- [x] `singleonerrorcomplete`- [x] `singleretryuntil`- [x] `singlesafesubscribe`- [x] `singlesequenceequal` (rename `equals`)- [x] `singlestartwith` - [x] `singletimeinterval`- [x] `singletimestamp`- [x] `singleswitchonnext`- [x] `singleswitchonnextdelayerror`- [x] `flowablefromaction`- [x] `flowablefromcompletable`- [x] `flowablefrommaybe`- [x] `flowablefromobservable`- [x] `flowablefromrunnable`- [x] `flowablefromsingle`- [x] `flowableonerrorcomplete`- [x] `flowablestartwith` (`maybesource` `singlesource` `completablesource`)- [x] `observablefromaction`- [x] `observablefromcompletable`- [x] `observablefrommaybe`- [x] `observablefromrunnable`- [x] `observablefromsingle`- [x] `observableonerrorcomplete`- [x] `observablestartwith` (`maybesource` `singlesource` `completablesource`);can i work on it? || @souraexx sure pick one im currently working on all `onerrorcomplete`s ||;1;0;3x: add various concatxdelayerror operators;
6882;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: add single.mergearray & mergearraydelayerror;single  was missing the  mergearray  and  mergearraydelayerror  operators already present in the other classes.;;6852.0;3x: add singlemergearray & mergearraydelayerror;`single` was missing the `mergearray` and `mergearraydelayerror` operators already present in the other classesrelated #6852(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlemergearraypng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlemergearraydelayerrorpng); merging 6882 ;3x: missing operators (tracking issue); present in some but not other classes (when they make sense there too):-  `completableconcatarraydelayerror`-  `completableblockingsubscribe`-  `completabledoonlifecycle`-  `completableonerrorresumewith`-  `completableonerrorreturn`-  `completableonerrorreturnitem`-  `completableretryuntil`-  `completablesafesubscribe`-  `completablesequenceequal`-  `completablestartwith` (`maybesource` `singlesource`)- [x] `completableswitchonnext`- [x] `completableswitchonnextdelayerror`- [x] `completabletofuture`- [x] `maybeblockingsubscribe`- [x] `maybeconcatarrayeagerdelayerror`- [x] `maybeconcatmapcompletable`- [x] `maybeconcatmapsingle`- [x] `maybedematerialize`- [x] `maybefromobservable`- [x] `maybedoonlifecycle`- [x] `maybefrompublisher`- [x] `maybesafesubscribe`- [x] `maybestartwith` - [x] `maybetimeinterval`- [x] `maybetimestamp`- [x] `maybetofuture`- [x] `maybeswitchonnext`- [x] `maybeswitchonnextdelayerror`- [x] `singleblockingsubscribe`- [x] `singleconcatarraydelayerror`- [x] `singleconcatarrayeagerdelayerror`- [x] `singleconcatdelayerror`- [x] `singleconcatmap`- [x] `singleconcatmapcompletable`- [x] `singleconcatmapmaybe`- [x] `singledoonlifecycle`- [x] `singlefrommaybe`- [x] `singlemergearray`- [x] `singlemergearraydelayerror`- [x] `singleoftype`- [x] `singleonerrorcomplete`- [x] `singleretryuntil`- [x] `singlesafesubscribe`- [x] `singlesequenceequal` (rename `equals`)- [x] `singlestartwith` - [x] `singletimeinterval`- [x] `singletimestamp`- [x] `singleswitchonnext`- [x] `singleswitchonnextdelayerror`- [x] `flowablefromaction`- [x] `flowablefromcompletable`- [x] `flowablefrommaybe`- [x] `flowablefromobservable`- [x] `flowablefromrunnable`- [x] `flowablefromsingle`- [x] `flowableonerrorcomplete`- [x] `flowablestartwith` (`maybesource` `singlesource` `completablesource`)- [x] `observablefromaction`- [x] `observablefromcompletable`- [x] `observablefrommaybe`- [x] `observablefromrunnable`- [x] `observablefromsingle`- [x] `observableonerrorcomplete`- [x] `observablestartwith` (`maybesource` `singlesource` `completablesource`);can i work on it? || @souraexx sure pick one im currently working on all `onerrorcomplete`s ||;1;0;remove unnecessary shortcut;
6884;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: add completable.sequenceequal;the operator was available in all other classes.;;6852.0;3x: add completablesequenceequal;the operator was available in all other classesrelated #6852 (https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completablesequenceequalpng); merging 6884 ;3x: missing operators (tracking issue); present in some but not other classes (when they make sense there too):-  `completableconcatarraydelayerror`-  `completableblockingsubscribe`-  `completabledoonlifecycle`-  `completableonerrorresumewith`-  `completableonerrorreturn`-  `completableonerrorreturnitem`-  `completableretryuntil`-  `completablesafesubscribe`-  `completablesequenceequal`-  `completablestartwith` (`maybesource` `singlesource`)- [x] `completableswitchonnext`- [x] `completableswitchonnextdelayerror`- [x] `completabletofuture`- [x] `maybeblockingsubscribe`- [x] `maybeconcatarrayeagerdelayerror`- [x] `maybeconcatmapcompletable`- [x] `maybeconcatmapsingle`- [x] `maybedematerialize`- [x] `maybefromobservable`- [x] `maybedoonlifecycle`- [x] `maybefrompublisher`- [x] `maybesafesubscribe`- [x] `maybestartwith` - [x] `maybetimeinterval`- [x] `maybetimestamp`- [x] `maybetofuture`- [x] `maybeswitchonnext`- [x] `maybeswitchonnextdelayerror`- [x] `singleblockingsubscribe`- [x] `singleconcatarraydelayerror`- [x] `singleconcatarrayeagerdelayerror`- [x] `singleconcatdelayerror`- [x] `singleconcatmap`- [x] `singleconcatmapcompletable`- [x] `singleconcatmapmaybe`- [x] `singledoonlifecycle`- [x] `singlefrommaybe`- [x] `singlemergearray`- [x] `singlemergearraydelayerror`- [x] `singleoftype`- [x] `singleonerrorcomplete`- [x] `singleretryuntil`- [x] `singlesafesubscribe`- [x] `singlesequenceequal` (rename `equals`)- [x] `singlestartwith` - [x] `singletimeinterval`- [x] `singletimestamp`- [x] `singleswitchonnext`- [x] `singleswitchonnextdelayerror`- [x] `flowablefromaction`- [x] `flowablefromcompletable`- [x] `flowablefrommaybe`- [x] `flowablefromobservable`- [x] `flowablefromrunnable`- [x] `flowablefromsingle`- [x] `flowableonerrorcomplete`- [x] `flowablestartwith` (`maybesource` `singlesource` `completablesource`)- [x] `observablefromaction`- [x] `observablefromcompletable`- [x] `observablefrommaybe`- [x] `observablefromrunnable`- [x] `observablefromsingle`- [x] `observableonerrorcomplete`- [x] `observablestartwith` (`maybesource` `singlesource` `completablesource`);can i work on it? || @souraexx sure pick one im currently working on all `onerrorcomplete`s ||;1;0;3x: add completablesequenceequal;
6885;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: add missing startwith overloads;add missing ( ![add]( )  startwith  overloads;;6852.0;3x: add missing startwith overloads;add missing ( ![add]( ) `startwith` overloads source \ other | f | o | m | s | c |--|--|--|--|--|--|flowable | ![present]( | ![absent]( | ![add]( | ![add]( | ![add]( | ![absent]( | ![present]( ![add]( | ![add]( | ![add]( | ![add]( | ![add]( | ![add]( | ![add]( | ![add]( | ![add]( | ![add]( | ![add]( | ![add]( | ![add]( | ![present]( | ![present]( | ![add]( | ![add]( | ![present]( #6852(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowablestartwithmpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowablestartwithspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowablestartwithcpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observablestartwithmpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observablestartwithspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observablestartwithcpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybestartwithppng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybestartwithopng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybestartwithmpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybestartwithspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybestartwithcpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlestartwithppng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlestartwithopng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlestartwithmpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlestartwithspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singlestartwithcpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completablestartwithmpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completablestartwithspng); merging 6885 ;3x: missing operators (tracking issue); present in some but not other classes (when they make sense there too):-  `completableconcatarraydelayerror`-  `completableblockingsubscribe`-  `completabledoonlifecycle`-  `completableonerrorresumewith`-  `completableonerrorreturn`-  `completableonerrorreturnitem`-  `completableretryuntil`-  `completablesafesubscribe`-  `completablesequenceequal`-  `completablestartwith` (`maybesource` `singlesource`)- [x] `completableswitchonnext`- [x] `completableswitchonnextdelayerror`- [x] `completabletofuture`- [x] `maybeblockingsubscribe`- [x] `maybeconcatarrayeagerdelayerror`- [x] `maybeconcatmapcompletable`- [x] `maybeconcatmapsingle`- [x] `maybedematerialize`- [x] `maybefromobservable`- [x] `maybedoonlifecycle`- [x] `maybefrompublisher`- [x] `maybesafesubscribe`- [x] `maybestartwith` - [x] `maybetimeinterval`- [x] `maybetimestamp`- [x] `maybetofuture`- [x] `maybeswitchonnext`- [x] `maybeswitchonnextdelayerror`- [x] `singleblockingsubscribe`- [x] `singleconcatarraydelayerror`- [x] `singleconcatarrayeagerdelayerror`- [x] `singleconcatdelayerror`- [x] `singleconcatmap`- [x] `singleconcatmapcompletable`- [x] `singleconcatmapmaybe`- [x] `singledoonlifecycle`- [x] `singlefrommaybe`- [x] `singlemergearray`- [x] `singlemergearraydelayerror`- [x] `singleoftype`- [x] `singleonerrorcomplete`- [x] `singleretryuntil`- [x] `singlesafesubscribe`- [x] `singlesequenceequal` (rename `equals`)- [x] `singlestartwith` - [x] `singletimeinterval`- [x] `singletimestamp`- [x] `singleswitchonnext`- [x] `singleswitchonnextdelayerror`- [x] `flowablefromaction`- [x] `flowablefromcompletable`- [x] `flowablefrommaybe`- [x] `flowablefromobservable`- [x] `flowablefromrunnable`- [x] `flowablefromsingle`- [x] `flowableonerrorcomplete`- [x] `flowablestartwith` (`maybesource` `singlesource` `completablesource`)- [x] `observablefromaction`- [x] `observablefromcompletable`- [x] `observablefrommaybe`- [x] `observablefromrunnable`- [x] `observablefromsingle`- [x] `observableonerrorcomplete`- [x] `observablestartwith` (`maybesource` `singlesource` `completablesource`);can i work on it? || @souraexx sure pick one im currently working on all `onerrorcomplete`s ||;1;0;fix javadocs copy-paste mistakes;
6886;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: add completable.onerrorreturn[item];the operators were already available elsewhere.;;5806.0;3x: add completableonerrorreturn[item];the operators were already available elsewhererelated #6852( addition the `maybe` variants have received updated marbles as well:![image]( #5806; merging 6886 ;3x: maybe incorrect or missing marbles (tracking issue);-  `amb`: missing diagram-  `ambarray`: missing diagram-  `concat(iterable)`: missing diagram-  `concat(publisher)`: missing diagram-  `concat(publisher int)`: missing diagram-  `concatarray`: missing diagram-  `concatarraydelayerror`: indicate error delayed 1 marble per source-  `concatarrayeager`: missing diagram-  `concatdelayerror(iterable)`: missing diagram-  `concatdelayerror(publisher)`: missing diagram- [x] `concatdelayerror(publisher int)`: fix overlap/misalignment inside the operator box- [x] `concateager(iterable)`: missing diagram- [x] `concateager(publisher)`: missing diagram- [x] `create`: missing diagram- [x] `defer`: missing diagram- [x] `error(callable)`: indicate callable returns the error- [x] `fromaction`: missing diagram- [x] `fromcompletable`: missing diagram- [x] `fromsingle`: missing diagram- [x] `fromcallable`: missing diagram- [x] `fromfuture(future)`: operator name in the box indicate future is the parameter- [x] `fromfuture(future long timeunit)`: operator name in the box indicate future is the parameter indicate timeout- [x] `fromrunnable`: missing diagram- [x] `merge(iterable)`: missing diagram- [x] `merge(publisher)`: missing diagram- [x] `merge(publisher int)`: missing diagram- [x] `mergearray`: missing diagram- [x] `mergearraydelayerror`: one marble per maybe source- [x] `mergedelayerror(iterable)`: one marble per maybe source- [x] `mergedelayerror(publisher)`: one marble per maybe source- [x] `mergedelayerror(maybe maybe )`: one marble per maybe source- [x] `sequenceequal` + 1: result should be `single`- [x] `timer` + 1: result should be maybe- [x] `using` + 1: rework to indicate the created maybe- [x] `wrap`: missing marble- [x] `zip(iterable)`: one marble per maybe source result should be maybe- [x] `zip(maybe maybe )` + 8: one marble per maybe source result should be maybe- [x] `ziparray`: one marble per maybe source result should be maybe- [x] `ambwith`: one marble per maybe source result should be maybe- [x] ~~`as`: missing diagram~~ operator removed- [x] `blockingget` + 1: missing diagram- [x] `cache`: one marble per maybe source result should be maybe- [x] `cast`: missing diagram- [x] `compose`: missing diagram- [x] `concatmap`: indicate maybe target indicate empty source- [x] `concatwith`: one marble per maybe source result should be maybe operator name indicate other is a parameter- [x] `contains`: one marble per maybe source result should be single empty case- [x] `count`: one marble per maybe operator name result should be single empty case- [x] `defaultifempty`: non-empty case result should be maybe- [x] `delay(time)` + 3: one marble per maybe source result should be maybe- [x] `delay(publisher)`: one marble per maybe one signal by the publisher empty publisher case- [x] `delaysubscription(publisher)`: missing diagram- [x] `delaysubscription(time)` + 1: one marble per maybe source result should be maybe- [x] `doaftersuccess`: missing diagram- [x] `doafterterminate`: operator name one marble per maybe result should be maybe- [x] `dofinally`: missing diagram- [x] `doondispose`: missing diagram- [x] `dooncomplete`: one marble per maybe result should be maybe- [x] `doonerror`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonsubscribe`: missing diagram- [x] `doonsuccess`: missing diagram- [x] `doonterminate`: one marble per maybe result should be maybe- [x] `filter`: one marble per maybe result should be maybe- [x] `flatmap(function function callable)`: one marble per maybe result should be maybe- [x] `flatmap(function bifunction)`: one marble per maybe result should be maybe- [x] `flatmapobservable`: should be mapped into an observable- [x] `flatmappublisher`: indicate backpressure- [x] `flatmapsingle`: indicate empty maybe results in error- [x] `flatmapsingleelement`: operator name indicate empty maybe- [x] `flatmapcompletable`: indicate empty maybe- [x] `hide`: missing diagram- [x] `ignoreelement`: operator name one marble per maybe result should be maybe- [x] `isempty`: result should be single- [x] `mergewith`: operator name one marble per maybe indicate backpressure- [x] `oftype`: one marble per maybe- [x] `onerrorcomplete` + 1: missing diagram- [x] `onerrorresumenext`: one marble per maybe result should be maybe- [x] `onerrorresumewith`: one marble per maybe result should be maybe- [x] `onerrorreturn`: one marble per maybe result should be maybe indicate callback- [x] `onerrorreturnitem`: operator name one marble per maybe result should be maybe indicate normal outcome- [x] ~~`onexceptionresumenext`: operator takes a maybe source directly~~ operator removed- [x] `onterminatedetach`: missing diagram- [x] `repeat` + 1: one marble per source indicate backpressure indicate repeat conditions- [x] `repeatuntil`: operator name repeat condition indicate backpressure- [x] `repeatwhen`: one marble per maybe indicate backpressure- [x] `retry` + 2: one marble per maybe result should be maybe indicate repeat conditions- [x] `retry(int predicate)`: missing diagram- [x] `retry(predicate)`: missing diagram- [x] `retryuntil`: missing diagram- [x] `retrywhen`: one marble per maybe output should be maybe- [x] `switchifempty` + 1: improve diagrams indicate argument type- [x] `takeuntil` + 1: one marble per maybe output should be maybe- [x] `timeout` + 3: one marble per maybe output should be maybe- [x] `timeout(maybesource)`: missing diagram- [x] `timeout(maybesource maybesource)`: missing diagram- [x] `timeout(publisher)`: missing diagram- [x] `timeout(publisher maybesource)`: missing diagram- [x] `to`: missing diagram- [x] `toflowable`: missing diagram- [x] `toobservable`: missing diagram- [x] `tosingle` + 1: missing diagram- [x] `unsubscribeon`: missing diagram- [x] `zipwith`: one marble per maybe output should be maybe;here is the excel file i draw the diagrams in:  ||;1;0;3x: add completableonerrorreturn[item];
6886;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: add completable.onerrorreturn[item];the operators were already available elsewhere.;;6852.0;3x: add completableonerrorreturn[item];the operators were already available elsewhererelated #6852( addition the `maybe` variants have received updated marbles as well:![image]( #5806; merging 6886 ;3x: missing operators (tracking issue); present in some but not other classes (when they make sense there too):-  `completableconcatarraydelayerror`-  `completableblockingsubscribe`-  `completabledoonlifecycle`-  `completableonerrorresumewith`-  `completableonerrorreturn`-  `completableonerrorreturnitem`-  `completableretryuntil`-  `completablesafesubscribe`-  `completablesequenceequal`-  `completablestartwith` (`maybesource` `singlesource`)- [x] `completableswitchonnext`- [x] `completableswitchonnextdelayerror`- [x] `completabletofuture`- [x] `maybeblockingsubscribe`- [x] `maybeconcatarrayeagerdelayerror`- [x] `maybeconcatmapcompletable`- [x] `maybeconcatmapsingle`- [x] `maybedematerialize`- [x] `maybefromobservable`- [x] `maybedoonlifecycle`- [x] `maybefrompublisher`- [x] `maybesafesubscribe`- [x] `maybestartwith` - [x] `maybetimeinterval`- [x] `maybetimestamp`- [x] `maybetofuture`- [x] `maybeswitchonnext`- [x] `maybeswitchonnextdelayerror`- [x] `singleblockingsubscribe`- [x] `singleconcatarraydelayerror`- [x] `singleconcatarrayeagerdelayerror`- [x] `singleconcatdelayerror`- [x] `singleconcatmap`- [x] `singleconcatmapcompletable`- [x] `singleconcatmapmaybe`- [x] `singledoonlifecycle`- [x] `singlefrommaybe`- [x] `singlemergearray`- [x] `singlemergearraydelayerror`- [x] `singleoftype`- [x] `singleonerrorcomplete`- [x] `singleretryuntil`- [x] `singlesafesubscribe`- [x] `singlesequenceequal` (rename `equals`)- [x] `singlestartwith` - [x] `singletimeinterval`- [x] `singletimestamp`- [x] `singleswitchonnext`- [x] `singleswitchonnextdelayerror`- [x] `flowablefromaction`- [x] `flowablefromcompletable`- [x] `flowablefrommaybe`- [x] `flowablefromobservable`- [x] `flowablefromrunnable`- [x] `flowablefromsingle`- [x] `flowableonerrorcomplete`- [x] `flowablestartwith` (`maybesource` `singlesource` `completablesource`)- [x] `observablefromaction`- [x] `observablefromcompletable`- [x] `observablefrommaybe`- [x] `observablefromrunnable`- [x] `observablefromsingle`- [x] `observableonerrorcomplete`- [x] `observablestartwith` (`maybesource` `singlesource` `completablesource`);can i work on it? || @souraexx sure pick one im currently working on all `onerrorcomplete`s ||;1;0;3x: add completableonerrorreturn[item];
"6887;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: add safesubscribe to maybe  single & completable;add the final missing method   safesubscribe  to  maybe    single  &  completable .;;685.0;3x: add safesubscribe to maybe single & completable;add the final missing method `safesubscribe` to `maybe` `single` & `completable`6852; merging 6887 ;""api design review: better name for """"just""""?"";the `just` operator seems misplaced and non-discoverable the `from` operator is preferable but we cant have `from(t scheduler)` because if `t` is `object` then `from(object scheduler)` cant be disambiguated from `from(object object)`ideas on a new name or different approach?/cc @headinthebox and @jhusain;""we can always do observablerepeat(x)take(1) or observablerepeat(x1) that was the argument for not including """"return"""" in c# enumerable || i think its too late to remove `just`  and it worksthe two primary entry points are `observablefrom()` and `observablejust()` || "";1;0;3x: add safesubscribe to maybe single & completable;"
"6888;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: use more appropriate operators when delegating to flowable ops;many  single  and  maybe  operators delegate to  flowable  operators. this pr makes sure they use the most appropriate ones since there are  single - and  maybe -specific operators on  flowable  for some time now.;;6865.0;3x: use more appropriate operators when delegating to flowable ops;many `single` and `maybe` operators delegate to `flowable` operators this pr makes sure they use the most appropriate ones since there are `single`- and `maybe`-specific operators on `flowable` for some time nowsome concatenating non-delayed single operators now use the `flowableconcatmapsingledelayerror(functionsidentity() false)` because an array or `iterable` of `single`s cant just throw anytime like a `publisher<single<t>>`s `publisher` could hence a delay-error until boundary mode works the same but without the extra coordination of the more general `publisher` variant6865`completable` didnt have any delegation required changing; merging 6888 ;3x: check maybe/single/completable operators delegating to flowable ops;""some operators in `maybe` `single` and `completable` are delegating to `flowable` operators that may not be the best fit for example:```java    public static <t> flowable<t> merge(@nonnull publisher<@nonnull ? extends maybesource<? extends t>> sources int maxconcurrency) {        objectsrequirenonnull(sources """"sources is null"""")        objecthelperverifypositive(maxconcurrency """"maxconcurrency"""")        return rxjavapluginsonassembly(new flowableflatmappublisher(sources maybetopublisherinstance() false maxconcurrency 1))    }```can now be:```java       return rxjavapluginsonassembly(new flowableflatmapmaybe<>(sources functionsidentity() false maxconcurrency)```but since `flowableflatmapmaybe` takes a `flowable<t>` not a `publisher<t>` a new simple class should be created (`flowableflatmapmaybepublisher`) that takes a `publisher<t>` but reuses the internals of `flowableflatmapmaybe`"";;1;0;remove now-unused classes;"
"6890;1;0;0;1;0;1;0;0;0;0;0;0;0;0;0;0;0;0;1;1;0;0;0;0;0;0;0;3.x: fix marble dimensions  add program that checks them;6872;;6872.0;3x: fix marble dimensions add program that checks them;6872also added 2 diagrams missing(  1 diagram wrongly exported![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/completableconcatarraydelayerrorpng); merging 6890 ;3x: create a tool that scans the java sources and checks marble dimensions;""create a manually runnable tool (in `internalutil`) that walks through the java sources of the base classes parses out the `<img width"""""""" height"""""""" src""""""""/>` downloads the referenced image and verifies that `height` is set properly more specifically `round(6400/imagewidth * imageheight)` and prints a fake stacktrace element to the particular line and the right amount it is recommended the download is somewhat rate-limited (1 per 100ms) because the sheer number of images the same reason applies why this isnt an unit test to be use `testhelperfindsource()` to locate the source java"";;1;0;remove an empty line;"
6891;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: swap maybe.flatmapsingle and maybe.flatmapsingleelement;6878;;6878.0;3x: swap maybeflatmapsingle and maybeflatmapsingleelement;6878dropped the old `maybeflatmapsingle` and replaced it with `maybeflatmapsingleelement`;hmm for xflatmaptestmaybesingle if i replace `flatmapsingle()tosingle()` with `tosingle()flatmap()` then the test will pass || the test checks if disposing while in the function the returned `single` never gets subscribed to and thus no error is signaled to the downstream or the global error handler put an `@ignore` on it for now and ill look into the operator tomorrow ||  merging 6891  < ;3x: swap maybeflatmapsingle and maybeflatmapsingleelement ?;currently `flatmapsingle` returns `single` and signals `nosuchelementexception` if the source `maybe` is empty `flatmapsingleelement` remains `maybe`id consider renaming `flatmapsingle` to `flatmapsingleorerror` and `flatmapsingleelement` to `flatmapsingle` as i think a default `maybe` -> `maybe` transformer should better match the other such transformersalternatively drop `flatmapsingle` and rename `flatmapsingleelement` to `flatmapsingle` so that the original behavior could be achieved via `flatmapsingletosingle())`;personally im in favor of dropping the old `flatmapsingle` and renaming `flatmapsingleelement` because i found the behavior of the old `flatmapsingle` surprising at first and using `tosingle()flatmap()` is more readable || lets drop `flatmapsingle` and rename `flatmapsingleelement` @slisaasquatch would you like to post a pr? if so please keep the unit tests and use `flatmapsingle()tosingle()` ||;1;0;add ignore to xflatmaptestmaybesingle;
6893;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: reenable xflatmaptest.maybesingle  add missing single operators;reenable the  xflatmaptest.maybesingle  and make sure all flatmap variants behave the same when the flow is cancelled/disposed while the mapper function is executing  thus the returned inner source doesn t get subscribed to at all.;;5806.0;3x: reenable xflatmaptestmaybesingle add missing single operators;reenable the `xflatmaptestmaybesingle` and make sure all flatmap variants behave the same when the flow is cancelled/disposed while the mapper function is executing thus the returned inner source doesnt get subscribed to at all6892while adding the extra tests i noticed two `flatmap` variant is missing from `single`:- a combiner of the original and inner success item: `flatmap(function<t single<u>> bifunction<t u r>)`- a notification-type mapper: `flatmap(function<t single<r>> function<throwable single<r>>)`( the same combiner variant for `maybe` received a marble diagram too:![image]( #5806; merging 6893 ;3x: maybe incorrect or missing marbles (tracking issue);-  `amb`: missing diagram-  `ambarray`: missing diagram-  `concat(iterable)`: missing diagram-  `concat(publisher)`: missing diagram-  `concat(publisher int)`: missing diagram-  `concatarray`: missing diagram-  `concatarraydelayerror`: indicate error delayed 1 marble per source-  `concatarrayeager`: missing diagram-  `concatdelayerror(iterable)`: missing diagram-  `concatdelayerror(publisher)`: missing diagram- [x] `concatdelayerror(publisher int)`: fix overlap/misalignment inside the operator box- [x] `concateager(iterable)`: missing diagram- [x] `concateager(publisher)`: missing diagram- [x] `create`: missing diagram- [x] `defer`: missing diagram- [x] `error(callable)`: indicate callable returns the error- [x] `fromaction`: missing diagram- [x] `fromcompletable`: missing diagram- [x] `fromsingle`: missing diagram- [x] `fromcallable`: missing diagram- [x] `fromfuture(future)`: operator name in the box indicate future is the parameter- [x] `fromfuture(future long timeunit)`: operator name in the box indicate future is the parameter indicate timeout- [x] `fromrunnable`: missing diagram- [x] `merge(iterable)`: missing diagram- [x] `merge(publisher)`: missing diagram- [x] `merge(publisher int)`: missing diagram- [x] `mergearray`: missing diagram- [x] `mergearraydelayerror`: one marble per maybe source- [x] `mergedelayerror(iterable)`: one marble per maybe source- [x] `mergedelayerror(publisher)`: one marble per maybe source- [x] `mergedelayerror(maybe maybe )`: one marble per maybe source- [x] `sequenceequal` + 1: result should be `single`- [x] `timer` + 1: result should be maybe- [x] `using` + 1: rework to indicate the created maybe- [x] `wrap`: missing marble- [x] `zip(iterable)`: one marble per maybe source result should be maybe- [x] `zip(maybe maybe )` + 8: one marble per maybe source result should be maybe- [x] `ziparray`: one marble per maybe source result should be maybe- [x] `ambwith`: one marble per maybe source result should be maybe- [x] ~~`as`: missing diagram~~ operator removed- [x] `blockingget` + 1: missing diagram- [x] `cache`: one marble per maybe source result should be maybe- [x] `cast`: missing diagram- [x] `compose`: missing diagram- [x] `concatmap`: indicate maybe target indicate empty source- [x] `concatwith`: one marble per maybe source result should be maybe operator name indicate other is a parameter- [x] `contains`: one marble per maybe source result should be single empty case- [x] `count`: one marble per maybe operator name result should be single empty case- [x] `defaultifempty`: non-empty case result should be maybe- [x] `delay(time)` + 3: one marble per maybe source result should be maybe- [x] `delay(publisher)`: one marble per maybe one signal by the publisher empty publisher case- [x] `delaysubscription(publisher)`: missing diagram- [x] `delaysubscription(time)` + 1: one marble per maybe source result should be maybe- [x] `doaftersuccess`: missing diagram- [x] `doafterterminate`: operator name one marble per maybe result should be maybe- [x] `dofinally`: missing diagram- [x] `doondispose`: missing diagram- [x] `dooncomplete`: one marble per maybe result should be maybe- [x] `doonerror`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonsubscribe`: missing diagram- [x] `doonsuccess`: missing diagram- [x] `doonterminate`: one marble per maybe result should be maybe- [x] `filter`: one marble per maybe result should be maybe- [x] `flatmap(function function callable)`: one marble per maybe result should be maybe- [x] `flatmap(function bifunction)`: one marble per maybe result should be maybe- [x] `flatmapobservable`: should be mapped into an observable- [x] `flatmappublisher`: indicate backpressure- [x] `flatmapsingle`: indicate empty maybe results in error- [x] `flatmapsingleelement`: operator name indicate empty maybe- [x] `flatmapcompletable`: indicate empty maybe- [x] `hide`: missing diagram- [x] `ignoreelement`: operator name one marble per maybe result should be maybe- [x] `isempty`: result should be single- [x] `mergewith`: operator name one marble per maybe indicate backpressure- [x] `oftype`: one marble per maybe- [x] `onerrorcomplete` + 1: missing diagram- [x] `onerrorresumenext`: one marble per maybe result should be maybe- [x] `onerrorresumewith`: one marble per maybe result should be maybe- [x] `onerrorreturn`: one marble per maybe result should be maybe indicate callback- [x] `onerrorreturnitem`: operator name one marble per maybe result should be maybe indicate normal outcome- [x] ~~`onexceptionresumenext`: operator takes a maybe source directly~~ operator removed- [x] `onterminatedetach`: missing diagram- [x] `repeat` + 1: one marble per source indicate backpressure indicate repeat conditions- [x] `repeatuntil`: operator name repeat condition indicate backpressure- [x] `repeatwhen`: one marble per maybe indicate backpressure- [x] `retry` + 2: one marble per maybe result should be maybe indicate repeat conditions- [x] `retry(int predicate)`: missing diagram- [x] `retry(predicate)`: missing diagram- [x] `retryuntil`: missing diagram- [x] `retrywhen`: one marble per maybe output should be maybe- [x] `switchifempty` + 1: improve diagrams indicate argument type- [x] `takeuntil` + 1: one marble per maybe output should be maybe- [x] `timeout` + 3: one marble per maybe output should be maybe- [x] `timeout(maybesource)`: missing diagram- [x] `timeout(maybesource maybesource)`: missing diagram- [x] `timeout(publisher)`: missing diagram- [x] `timeout(publisher maybesource)`: missing diagram- [x] `to`: missing diagram- [x] `toflowable`: missing diagram- [x] `toobservable`: missing diagram- [x] `tosingle` + 1: missing diagram- [x] `unsubscribeon`: missing diagram- [x] `zipwith`: one marble per maybe output should be maybe;here is the excel file i draw the diagrams in:  ||;1;0;3x: reenable xflatmaptestmaybesingle add missing single operators;
6893;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: reenable xflatmaptest.maybesingle  add missing single operators;reenable the  xflatmaptest.maybesingle  and make sure all flatmap variants behave the same when the flow is cancelled/disposed while the mapper function is executing  thus the returned inner source doesn t get subscribed to at all.;;6892.0;3x: reenable xflatmaptestmaybesingle add missing single operators;reenable the `xflatmaptestmaybesingle` and make sure all flatmap variants behave the same when the flow is cancelled/disposed while the mapper function is executing thus the returned inner source doesnt get subscribed to at all6892while adding the extra tests i noticed two `flatmap` variant is missing from `single`:- a combiner of the original and inner success item: `flatmap(function<t single<u>> bifunction<t u r>)`- a notification-type mapper: `flatmap(function<t single<r>> function<throwable single<r>>)`( the same combiner variant for `maybe` received a marble diagram too:![image]( #5806; merging 6893 ;3x: reenable xflatmaptestmaybesingle;there is a small behavior difference between `flowableflatmap` and `maybeflatmapsingle` that made the test fail namely the effect of disposing before the function returns the inner source;;1;0;3x: reenable xflatmaptestmaybesingle add missing single operators;
6894;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix groupby not requesting more if a group is cancelled with buffered items;if a group is cancelled with unconsumed item in its buffer  the operator stopped requesting more thus hanging other groups.;;0;2x: fix groupby not requesting more if a group is cancelled with buffered items;if a group is cancelled with unconsumed item in its buffer the operator stopped requesting more thus hanging other groupsthe fix is to count how many items are still in the buffer upon cancellation and issue a request for them for the parent6889; merging 6894 ;;;;1;1;2x: fig groupby not requesting more if a group is cancelled with buffered items;
6895;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix groupby not requesting more if a group is cancelled w/ items;if a group is cancelled with unconsumed item in its buffer  the operator stopped requesting more thus hanging other groups. in 3.x the operator was somewhat strenghtened for this case except one case when the cancellation happens outside the drain loop.;;0;3x: fix groupby not requesting more if a group is cancelled w/ items;if a group is cancelled with unconsumed item in its buffer the operator stopped requesting more thus hanging other groups in 3x the operator was somewhat strenghtened for this case except one case when the cancellation happens outside the drain loopthe fix is to invoke `drain()` from cancel for it to have the cleanup and replenishment happen6889; merging 6895 ;;;;1;1;3x: fix groupby not requesting more if a group is cancelled w/ items;
6897;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: add remaining maybe marbles (+50);5806;;5806.0;3x: add remaining maybe marbles (+50);5806 (https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeambwithpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeblockinggetpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeblockinggetvpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybecachepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybecomposepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeconcatwithpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybecountpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedefaultifemptypng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedelayppng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedelaytpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedelaytbpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedelaytspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedelaytsbpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedoaftersuccesspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedoafterterminatepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedofinallypng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedoondisposepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedoonsubscribepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybedoonterminatepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeflatmapobservablepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeflatmappublisherpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeisemptypng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybemergewithpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mayberepeatnpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mayberepeatpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mayberepeatuntilpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mayberepeatwhenpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mayberetryfpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mayberetrygpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mayberetrynpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mayberetrynfpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mayberetrypng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/mayberetrywhenpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeswitchifemptympng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybeswitchifemptyspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetakeuntilmpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetakeuntilppng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetimeoutmpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetimeoutmmpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetimeoutppng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetimeoutpmpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetimeouttpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetimeouttmpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetimeouttspng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetimeouttsmpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetopng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetoflowablepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetoobservablepng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/maybetosinglepng); merging 6897  < ;3x: maybe incorrect or missing marbles (tracking issue);-  `amb`: missing diagram-  `ambarray`: missing diagram-  `concat(iterable)`: missing diagram-  `concat(publisher)`: missing diagram-  `concat(publisher int)`: missing diagram-  `concatarray`: missing diagram-  `concatarraydelayerror`: indicate error delayed 1 marble per source-  `concatarrayeager`: missing diagram-  `concatdelayerror(iterable)`: missing diagram-  `concatdelayerror(publisher)`: missing diagram- [x] `concatdelayerror(publisher int)`: fix overlap/misalignment inside the operator box- [x] `concateager(iterable)`: missing diagram- [x] `concateager(publisher)`: missing diagram- [x] `create`: missing diagram- [x] `defer`: missing diagram- [x] `error(callable)`: indicate callable returns the error- [x] `fromaction`: missing diagram- [x] `fromcompletable`: missing diagram- [x] `fromsingle`: missing diagram- [x] `fromcallable`: missing diagram- [x] `fromfuture(future)`: operator name in the box indicate future is the parameter- [x] `fromfuture(future long timeunit)`: operator name in the box indicate future is the parameter indicate timeout- [x] `fromrunnable`: missing diagram- [x] `merge(iterable)`: missing diagram- [x] `merge(publisher)`: missing diagram- [x] `merge(publisher int)`: missing diagram- [x] `mergearray`: missing diagram- [x] `mergearraydelayerror`: one marble per maybe source- [x] `mergedelayerror(iterable)`: one marble per maybe source- [x] `mergedelayerror(publisher)`: one marble per maybe source- [x] `mergedelayerror(maybe maybe )`: one marble per maybe source- [x] `sequenceequal` + 1: result should be `single`- [x] `timer` + 1: result should be maybe- [x] `using` + 1: rework to indicate the created maybe- [x] `wrap`: missing marble- [x] `zip(iterable)`: one marble per maybe source result should be maybe- [x] `zip(maybe maybe )` + 8: one marble per maybe source result should be maybe- [x] `ziparray`: one marble per maybe source result should be maybe- [x] `ambwith`: one marble per maybe source result should be maybe- [x] ~~`as`: missing diagram~~ operator removed- [x] `blockingget` + 1: missing diagram- [x] `cache`: one marble per maybe source result should be maybe- [x] `cast`: missing diagram- [x] `compose`: missing diagram- [x] `concatmap`: indicate maybe target indicate empty source- [x] `concatwith`: one marble per maybe source result should be maybe operator name indicate other is a parameter- [x] `contains`: one marble per maybe source result should be single empty case- [x] `count`: one marble per maybe operator name result should be single empty case- [x] `defaultifempty`: non-empty case result should be maybe- [x] `delay(time)` + 3: one marble per maybe source result should be maybe- [x] `delay(publisher)`: one marble per maybe one signal by the publisher empty publisher case- [x] `delaysubscription(publisher)`: missing diagram- [x] `delaysubscription(time)` + 1: one marble per maybe source result should be maybe- [x] `doaftersuccess`: missing diagram- [x] `doafterterminate`: operator name one marble per maybe result should be maybe- [x] `dofinally`: missing diagram- [x] `doondispose`: missing diagram- [x] `dooncomplete`: one marble per maybe result should be maybe- [x] `doonerror`: missing diagram- [x] `doonevent`: missing diagram- [x] `doonsubscribe`: missing diagram- [x] `doonsuccess`: missing diagram- [x] `doonterminate`: one marble per maybe result should be maybe- [x] `filter`: one marble per maybe result should be maybe- [x] `flatmap(function function callable)`: one marble per maybe result should be maybe- [x] `flatmap(function bifunction)`: one marble per maybe result should be maybe- [x] `flatmapobservable`: should be mapped into an observable- [x] `flatmappublisher`: indicate backpressure- [x] `flatmapsingle`: indicate empty maybe results in error- [x] `flatmapsingleelement`: operator name indicate empty maybe- [x] `flatmapcompletable`: indicate empty maybe- [x] `hide`: missing diagram- [x] `ignoreelement`: operator name one marble per maybe result should be maybe- [x] `isempty`: result should be single- [x] `mergewith`: operator name one marble per maybe indicate backpressure- [x] `oftype`: one marble per maybe- [x] `onerrorcomplete` + 1: missing diagram- [x] `onerrorresumenext`: one marble per maybe result should be maybe- [x] `onerrorresumewith`: one marble per maybe result should be maybe- [x] `onerrorreturn`: one marble per maybe result should be maybe indicate callback- [x] `onerrorreturnitem`: operator name one marble per maybe result should be maybe indicate normal outcome- [x] ~~`onexceptionresumenext`: operator takes a maybe source directly~~ operator removed- [x] `onterminatedetach`: missing diagram- [x] `repeat` + 1: one marble per source indicate backpressure indicate repeat conditions- [x] `repeatuntil`: operator name repeat condition indicate backpressure- [x] `repeatwhen`: one marble per maybe indicate backpressure- [x] `retry` + 2: one marble per maybe result should be maybe indicate repeat conditions- [x] `retry(int predicate)`: missing diagram- [x] `retry(predicate)`: missing diagram- [x] `retryuntil`: missing diagram- [x] `retrywhen`: one marble per maybe output should be maybe- [x] `switchifempty` + 1: improve diagrams indicate argument type- [x] `takeuntil` + 1: one marble per maybe output should be maybe- [x] `timeout` + 3: one marble per maybe output should be maybe- [x] `timeout(maybesource)`: missing diagram- [x] `timeout(maybesource maybesource)`: missing diagram- [x] `timeout(publisher)`: missing diagram- [x] `timeout(publisher maybesource)`: missing diagram- [x] `to`: missing diagram- [x] `toflowable`: missing diagram- [x] `toobservable`: missing diagram- [x] `tosingle` + 1: missing diagram- [x] `unsubscribeon`: missing diagram- [x] `zipwith`: one marble per maybe output should be maybe;here is the excel file i draw the diagrams in:  ||;1;0;3x: add remaining maybe marbles (+50);
6899;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: add concateagerdelayerror across;flowable    observable    maybe  and  single  now have a  concateagerdelayerror   delegating to the appropriate  concatmapeagerdelayerror  operator.;;6880.0;3x: add concateagerdelayerror across;`flowable` `observable` `maybe` and `single` now have a `concateagerdelayerror` delegating to the appropriate `concatmapeagerdelayerror` operatorin addition `maybe` and `single` received an overload `concateager(iterable int)` to expose the `maxconcurrency` option already present in the rest of the typesnote that `completableconcateagerdelayerror` is essentially the same as `mergedelayerror` because there are no items to keep emitting in order6880the `flowable` and `observable` variant of `concateager` also received fresh marble diagrams (related #5813)#### flowable( observable![image]( maybe![image]( single![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleconcateagerinpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleconcateagerpnpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleconcateagerdelayerroripng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleconcateagerdelayerrorinpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleconcateagerdelayerrorppng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/singleconcateagerdelayerrorpnpng); merging 6899  < ;3x: add concateagerdelayerror across;`concateager` [is available]( but its delay-error variant is missing;;1;0;add more since 300 tags;
6901;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: add missing coverage  fix unused/inconsistent ops;cleanup and coverage improvements.;;0;3x: add missing coverage fix unused/inconsistent ops;cleanup and coverage improvements~~(still many operators to review in `flowables` and `observables`)~~; merging 6901 ;;;;1;1;fix wrong use of juobservable;
6903;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: add  error handling  section to observable.blockingfirst javadocs;add missing javadocs section.;;0;3x: add error handling section to observableblockingfirst javadocs;add missing javadocs section6900; merging 6903 ;;;;1;1;3x: add error handling section to observableblockingfirst documentation (#6900);
6917;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix flowable.switchmap not canceling properly during onnext-cancel races;there was an unnecessary  active.lazyset(null)  which prevented cancellation of the inner source under some circumstances.;;0;3x: fix flowableswitchmap not canceling properly during onnext-cancel races;there was an unnecessary `activelazyset(null)` which prevented cancellation of the inner source under some circumstancesmore specifically when one thread issued a `cancel` the cancelled flag was set then another thread in `drain` would loop around see the `cancelled` flag and clear the reference back in the cancelling thread the `disposeinner` would only see `null` and do nothingobservableswitchmap did not have this mistake both received unit tests to verify the correct behavior2x will be  in a separate pr6914; merging 6917 ;;;;1;1;3x: fix switchmap not canceling properly during onnext-cancel races;
"6921;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix replay() not resetting when the connection is disposed;disposing a  replay() -based connectable should reset the operator to its fresh state. this was supposed to happen but the relevant code changes were not enabled. the pr fixes this for both  flowable  and  observable -based implementations.;;692.0;3x: fix replay() not resetting when the connection is disposed;disposing a `replay()`-based connectable should reset the operator to its fresh state this was supposed to happen but the relevant code changes were not enabled the pr fixes this for both `flowable` and `observable`-based implementationsthe `publish`-based connectables work as intended6920; merging 6921 ;how to map exceptions?;i have observable<myresult> that could produce onerror with exception1 i want to remap it so i can handle exception1 and rethrow my own exception2what is the proper way to do it?;""you need to implement your own observer and perform the remapping there:``` javafinal observer<object> actual  observableerror(new exception())subscribe(new observer<object>() {   public void onnext(object a) { actualonnext(a) }   public void oncompleted() { actualoncompleted() }   public void onerror(throwable e) {      if (e instanceof exception) {         actualonerror(new runtimeexception(e)      }   }})```if you need to do this regularly you can have your own operator for it:``` javapublic class mapexception {    public static <t e extends exception> observable<t> mapexception(        final observable<t> source final func1<? super throwable e> errorselector) {        return observablecreate(new onsubscribefunc<t>() {            @override            public subscription onsubscribe(final observer<? super t> t1) {                observer<t> o  new observer<t>() {                    @override public void onnext(t args) { t1onnext(args) }                    @override public void onerror(throwable e) {                       e f                        try {                         f  errorselectorcall(e)                        } catch (throwable t) {                            t1onerror(t)                            return                        }                        t1onerror(f)                    }                    @override public void oncompleted() { t1oncompleted() }                }                return sourcesubscribe(o)            }        })    }    public static void main(string args) throws interruptedexception {        func1<throwable ioexception> ioe  new func1<throwable ioexception>() {            @override            public ioexception call(throwable t1) {                return new ioexception(t1getmessage() t1getcause())            }        }        observable<integer> source  mapexception(concat(from(1 2 3) error(            new runtimeexception(""""forced failure!""""))) ioe)        final countdownlatch latch  new countdownlatch(1)        sourcesubscribe(new action1<object>() {            @override            public void call(object t1) {                systemoutprintln(t1)            }        } new action1<throwable>() {            @override            public void call(throwable t1) {                t1printstacktrace()                latchcountdown()            }        } new action0() {            @override            public void call() {                latchcountdown()            }        })        latchawait(10 timeunitseconds)    }}``` || you can use onerrorresumenext:  the function perform your conditional logic and return observables as appropriate such as using observableerror with your new exception  || @benjchristensen when i return converted exception it seems some sort of recursion calls are made and i receive my exceptions many times || this works for me as expected:``` javapublic class mapexception2 {    public static void main(string args) throws interruptedexception {        observable<integer> source  concat(from(1 2 3)             error(new runtimeexception(""""forced failure"""")))        observable<integer> result  sourceonerrorresumenext(e ->             concat(from(4 5 6) error(new ioexception(egetmessage() egetcause())))        )        resultsubscribe(systemout::println throwable::printstacktrace)        threadsleep(1000)    }}```prints the numbers 1 - 6 and an ioexception stacktrace || @akarnokd i ran into that problem on rxjava 2could you take a look a this implementation and tell me if this is implemented properly?```kotlinclass observablemaperror<t : any>(private val source: observable<t> private val errormapper: (throwable) -> throwable) : observable<t>() {  override fun subscribeactual(observer: observer<in t>) {    sourcesubscribe(maperrorobserver(observer errormapper))  }  class maperrorobserver<t : any>(val actual: observer<in t> val errormapper: (throwable) -> throwable) : observer<t> disposable {    private var source: disposable?  null    override fun onsubscribe(s: disposable) {      if (disposablehelpervalidate(source s)) {        thissource  s        actualonsubscribe(this)      }    }    override fun dispose() {      source!!dispose()    }    override fun isdisposed(): boolean  source!!isdisposed    override fun onnext(t: t) {      actualonnext(t)    }    override fun onerror(t: throwable) {      val mapped  errormapper(t)      actualonerror(mapped)    }    override fun oncomplete() {      actualoncomplete()    }  }}``` || almost i wouldnt trust `errormapper(t)` to not throw thus id wrap it into try-catch and call the `actualonerror` with a composite of the original and this latter exception || @akarnokd i ran into same problem on rxjava2 maybe it is worth to add those operators to single observable flowable completable as official ones? || i still dont think so || i did the following:```                onerrorresumenext { singleerror(exception()) }```is this something wrong? || "";1;0;3x: fix replay() not resetting when the connection is disposed;"
6934;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;add see annotation for range operators;- added @see annotation for range operators  reorder annotation to common code style.;;0;add see annotation for range operators;- added @see annotation for range operators reorder annotation to common code style  - #4535; merging 6934 ;;;;1;1;add see annotation for range operators;
6943;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;docs: quick javadoc fixes.;added @code tag wherever < or > were used  also removed a few;;0;docs: quick javadoc fixes;added @code tag wherever < or > were used also removed a fewself-closing <p> tags both of these issues cause errors with the latestversion of javadocsigned-off-by: zachary trant <zach@graalonlinecom>; merging 6943 ;;;;1;1;update serializedobservertestjava;
"6944;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;update image urls to non-transparent version.;updated image urls to use non-transparent ones as per #6883;;6883.0;update image urls to non-transparent version;updated image urls to use non-transparent ones as per #68836883; merging 6944 ;3x: marbles should have a proper background;the transparent ones look terrible with dark-themed ides or non-light background:( looks fine in eclipse:![image]( a program that goes through the images in ` `images/rx-operators` checks if the image has transparency draw it onto a white background then save it as `originalnamev3png` (because some of those are linked all around) find the filename in the source code and replace them;""id like to do this if its fine || @tomislavhofman sure! || while were waiting for my internet to do the heavy liftinghere are some fun facts:- there were 749 images with transparent background ( which now have corresponding v3png with white background )- rxjava project contains 45 md files and 1855 java files- a total of 842 occurrences of transparent pngs has been found across 18 files in total ( 5 located in /docs/ and 13 in /src/ )    1 first place flowablejava and 373 changes    2 trailing second observablejava with 351 changes    3 third place has been taken by singlejava which was updated in 72 placesheres a very bare and unsorted log of changes made to rxjava source code   images with white background-  found and replaced in source codeon a side note if my 2nd attempt to push the wiki changes onto my fork fails would you be okay with me uploading just the updated images somewhere and you can update the wiki yourself? its a difference between 100ish mb and 1gb<img width""""688"""" alt""""screenshot 2020-04-02 at 11 32 53"""" src"""" if that doesnt work for you ill just try againonce the wiki files are updated ill submit the pull request for links updates || you wont be able to push to the wiki or create a pr for the wiki part can you upload the files into this issue via attachment(s)? || oh and i thought i was being clever by researching and discovering how to make a pr to github wikiill attach the files below || okay ive uploaded all 749 images to a comment in this thread which i havent posted yethow should i approach posting them im a bit confused here it is a lot of images ;1;0;update image urls to non-transparent version;"
6946;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix observable.flatmap with maxconcurrency hangs;queued up scalar values were not counted as completed  thus the subsequent sources where not subscribed to to fill up the allowed concurrency level.;;0;3x: fix observableflatmap with maxconcurrency hangs;queued up scalar values were not counted as completed thus the subsequent sources where not subscribed to to fill up the allowed concurrency level6945;yes added the test for it too anyway ||  merging 6946 ;;;;1;1;verify flowable;
6953;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: workaround flakyness of multithreadedwithnpe* tests;these tests tend to fail more often with jdk 9 target 9 builds (but all the others are fine).;;0;3x: workaround flakyness of multithreadedwithnpe* tests;these tests tend to fail more often with jdk 9 target 9 builds (but all the others are fine)note that an overarching flakyness plugin could hide many of the legitimately incorrect behavior tested via races; merging 6953 ;;;;1;1;do not run the original test;
"6956;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix scheduled tasks  fatal exception behavior;fatal exceptions may be lost with scheduled direct & scheduled periodic direct tasks because  futuretask  simply treats them as exceptional outcomes. for regular tasks  [scheduledrunnable]( already avoids rethrowing fatal errors as it would go nowhere.;;695.0;3x: fix scheduled tasks fatal exception behavior;fatal exceptions may be lost with scheduled direct & scheduled periodic direct tasks because `futuretask` simply treats them as exceptional outcomes for regular tasks [scheduledrunnable]( already avoids rethrowing fatal errors as it would go nowherethis pr adds this behavior to the direct runnable tasks6954;""> this will halt the application when stack overflow:i dont understand as far as i know calling the uncaught exception handler on android kills your app on desktop such calls do nothing but the repetition of the `scheduleperiodicallydirect` should end || > > this will halt the application when stack overflow:> > i dont understand as far as i know calling the uncaught exception handler on android kills your app on desktop such calls do nothing but the repetition of the `scheduleperiodicallydirect` should endi am sorry i think i made a mistake when simplifies #748 case the key point is when stackoverflowerror ocurrs calling error hander without throw may cause stack full again that is also why i selected a complex approach ill check it  || > > this will halt the application when stack overflow:> > i dont understand as far as i know calling the uncaught exception handler on android kills your app on desktop such calls do nothing but the repetition of the `scheduleperiodicallydirect` should endhi akarnokd sorry to the above mistakepersonally  i think this approach has some flaws1 - this approach means well catch fatal exceptions instead of throwing it through the call stack but the functions on the call stack may need this exception to clean/stop itself for example this change will make periodic tasks unable to stop (at least on desktop or server):    @test // fail    public void periodictaskshouldstoponerror() throws exception {        atomicinteger repeatcount  new atomicinteger()        new computationscheduler()scheduleperiodicallydirect(new runnable() {            @override            public void run() {                repeatcountincrementandget()                if (true) {                    throw new outofmemoryerror()                }            }        } 0 500 timeunitmilliseconds)        threadsleep(1000 * 3)        assertequals(1 repeatcountget())    }2 - to solve the above problem we need to rethrow the exception after rxjavapluginsonerror() or make rxjavapluginsonerror() to throw after calling the uncaughtexceptionhandler of the thread this actullay makes some exceptions to be handled more than once and i think it will make things more and more complex as we solve those cases one by one3 - if we are able to check exceptions in the future as #6954 mentioned (and jdk has given us all we need) exception handing in rxjava will be simpler and easier as we do elsewhere: make rxjavapluginsonerror() handle/propagate the exception and continue the work or make rxjavapluginsonerror() throws and exceptions go through the stack to do whatever clean/stop needed and finally to the uncaughtexceptionhandler of the thread  ||  merging 6956  "";api design review;my thoughts on the api design review try to be faithful to the ms implementation much as possible where feasible any enhancements can also live along side the core implementation with other language bindings also coming from ms it is good that there are consistency among the implementationsso idiomatic rx comes before any other implementations idiomatic \* can core exist along side the standard rx usage;/cc @headinthebox @jhusain @mattpodwysocki || > try to be faithful to the ms implementation much as possible where feasibleof course ||;1;0;adjust some test expectation with disposetask;"
6960;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: fix observable.flatmap with maxconcurrency hangs (#6947);just a backport to 2.x of the fix for the scalar-queue max-concurrency issue already fixed for 3.x in #6946;;6947.0;2x: fix observableflatmap with maxconcurrency hangs (#6947);just a backport to 2x of the fix for the scalar-queue max-concurrency issue already  for 3x in #6946the code for the fix has been added and also the test for itin addition as was also done for #6946 the corresponding test for `flowableflatmap` has been added6947; merging 6960 ;2x: open for grabs: backport #6946;fix for the scalar-queue max-concurrency issue already  for 3x in #6946;;1;0;2x: fix observableflatmap with maxconcurrency hangs (#6947);
6969;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: allow setting the drift tolerance timeunit via system property;adds the new system property  rx3.scheduler.drift-tolerance-unit  to allow specifying a more fine-grained tolerance amount.;;696.0;3x: allow setting the drift tolerance timeunit via system property;adds the new system property `rx3schedulerdrift-tolerance-unit` to allow specifying a more fine-grained tolerance amount6968; merging 6969 ;new contrib module: rxjava-async-util;home for async utility functions with jucfuture actions functions etc that dont need to be in rxjava-coreas per discussions at:-    @akarnokd;@akarnokd do you want to extend this branch and merge the various prs in to it that belong here?if you dont like the name go ahead and propose something i couldnt think of anything better but only spent a couple minutes on thisi want something generic enough to cover the various utilities at the same time i feel this name may be too broad as these utilities may not apply at all to other jvm languages but thats probably fine as thats why its a contrib module || #613 thanks @benjchristensen the name is okay ill update and resubmit the relevant prs should `observablefrom(future)` and its overloads from before be moved into this module? || leave `observablefrom(future)` in `observable` for now well need to do a deprecation process on those if we remove them || im closing this pr as you will take my branch and re-submit a new one || im sorry i dont quite understand i check out your branch then once all ops are added i submit a pr against rxjava/master? || yes ||;1;0;3x: allow setting the drift tolerance timeunit via system property;
6975;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix flowable.groupby eviction logic double decrement and hang;when a group is evicted  the group is synchronously  oncomplete d during an  onnext . if a cancellation happened during this time (for example  when a  publish  cancels its upstream because its output completes)  the cancellation would unconditionally decrement the group counter even though the  groups  map had no longer the group (because it was evicted before). then once the eviction logic finishes  it decremented the group counter again  leading to invalid internal state and hangs.;;0;3x: fix flowablegroupby eviction logic double decrement and hang;when a group is evicted the group is synchronously `oncomplete`d during an `onnext` if a cancellation happened during this time (for example when a `publish` cancels its upstream because its output completes) the cancellation would unconditionally decrement the group counter even though the `groups` map had no longer the group (because it was evicted before) then once the eviction logic finishes it decremented the group counter again leading to invalid internal state and hangsthe fix is to only decrement if there was a group actually removed from the map6974; merging 6975 ;;;;1;1;3x: fix flowablegroupby eviction logic double decrement and hang;
6979;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix flowable.groupby cancellation/cleanup/eviction race hangs;this pr fixes three additional race conditions from https://github.com/reactivex/rxjava/issues/6974#issuecomment-626319431;;0;3x: fix flowablegroupby cancellation/cleanup/eviction race hangs;this pr fixes three additional race conditions from  when a cancellation arrived asynchronously to a group the drain loop quit and left unconsumed items in the queue and thus prevented the replenishment from the main upstream **fix:** change the drain loop to always clean & replenish upon seeing a canceled state2 when a cancellation was detected just after the drain loop has polled from the queue that polled item was ignored and not replenished **fix:** include the non-empty polled item in the replenishment count upon cancellation3 when a cancellation happened concurrently with an eviction both could end up decrementing the group counter into an invalid (negative) number preventing the operator to function properly **fix:** make sure group removal accounting happens at most oncefixes: #6974; merging 6979 ;;;;1;1;3x: fix flowablegroupby cancellation/cleanup/eviction race hangs;
6983;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: disable fusion on the groups of flowable.groupby;this pr disables the async fusion capability of the groups emitted by  flowable.groupby  as it appears to lead to hangs due to cancellation and/or lack of requests in certain async scenarios.;;0;3x: disable fusion on the groups of flowablegroupby;this pr disables the async fusion capability of the groups emitted  flowablegroupby` as it appears to lead to hangs due to cancellation and/or lack of requests in certain async scenariosby disabling fusion the groups will manage the items they queue and cancellation will (hopefully) properly trigger replenishment requests for the unclaimed itemsthis is more of a workaround than a comprehensible fix for the underlying issues the main problem is that with `groupby` and backpressure each group itself and the items passing through them now count as **resources** and reactive streams cant cope well with items requiring their own lifecyclerelated: #6982; merging 6983 ;;;;1;1;3x: disable fusion on the groups of flowablegroupby;
6988;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix flowable.groupby eviction-completion-replenishment problems;this pr fixes the two cases from https://github.com/reactivex/rxjava/issues/6982#issuecomment-630290658;;0;3x: fix flowablegroupby eviction-completion-replenishment problems;this pr fixes the two cases from  case 1: completions missedwhen the upstream completed and some groups were waiting in the eviction queue the eviction queue was cleared without completing those groups since they were no longer in the main map those groups never completed and downstream operators relying on all groups completing (ie flatmap) would never completethe fix is to call `completeevictions` upon upstream termination### case 2: no replenisment on evicted groupswhen an eviction happens the groups get completed however unlike with the non-evicting case a group completion no longer implies the upstream has completed consequently the evicted groups emitted their items but never issued a replenishment for them hanging the still-alive main operatorthe fix is to replenish emitted (and polled) counts whenever the group detects a completion (errors still imply the main operator has terminated so no need to replenish then) 6982;/cc @davidmoten @dbakr ||  merging 6988 ;;;;1;1;3x: fix flowablegroupby eviction-completion-replenishment problems;
6990;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;add missing  @test  annotation;there was a missing  @test  annotation in  replaysubjecttest . this pr fix that.;;0;add missing `@test` annotation;there was a missing `@test` annotation in `replaysubjecttest` this pr fix that; merging 6990 ;;;;1;1;add missing `@test` annotation;
6992;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;removed unnecessary upstream.cancel() call for casually finished upstream sequences.;- no upstream.cancel() in flowablepublishmulticast when the sequence is finished normally via oncomplete/onerror from upstream;;0;removed unnecessary upstreamcancel() call for casually finished upstream sequences;- no upstreamcancel() in flowablepublishmulticast when the sequence is finished normally via oncomplete/onerror from upstream- minor code cleanup - unnecessary disposable implementation to avoid method name clash- fixes  flowablepublishfunctiontestjava  refactored to use lambdas; merging 6992 ;;;;1;1;reduced visibility for dispose() and isdisposed() in the inner multicastprocessor;
6994;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix recent groupby tests sometimes failing with mbe;these tests can fail with  missingbackpressureexception  because groups may not complete fast enough so  flatmap  can request more groups in time. this doesn t happen consistently but could fail the test on ci. the workaround is to allow any termination  not just normal completion. the reasoning is that the aim of the tests were to verify the operator doesn t hang.;;0;3x: fix recent groupby tests sometimes failing with mbe;these tests can fail with `missingbackpressureexception` because groups may not complete fast enough so `flatmap` can request more groups in time this doesnt happen consistently but could fail the test on ci the workaround is to allow any termination not just normal completion the reasoning is that the aim of the tests were to verify the operator doesnt hangthe underlying complication is that whenever there is an item replenishment any subsequent item can result in a fresh group being created if the concurrency level of `flatmap` is not high enough this will result in a mbe and the sequence terminates; merging 6994 ;;;;1;1;3x: fix recent groupby tests sometimes failing with mbe;
6996;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;suppress undeliverableexception handling in tests (#6987);i used a junit testrule to suppress handling of undeliverableexception for test methods annotated with @suppressundeliverable. this approach is coarser than the suggested approach (it suppresses the handling of all undeliverableexceptions for the entire annotated test method).;;6987.0;suppress undeliverableexception handling in tests (#6987);i used a junit testrule to suppress handling of undeliverableexception for test methods annotated with @suppressundeliverable this approach is coarser than the suggested approach (it suppresses the handling of all undeliverableexceptions for the entire annotated test method)i thought this approach was clean but i can switch to the suggested approach if preferredi added @suppressundeliverable to most tests that were logging undeliverableexceptions with the test method in the stack trace this may be more suppression than was required so just let me know6987; merging 6996 ;3x: suppress undeliverables in some tests;some tests trigger a lot of undeliverable exceptions flooding the console output example:```at ioreactivexrxjava3internalsubscribersfuturesubscribertest    onerrorcancelrace(futuresubscribertestjava:178)at ioreactivexrxjava3internaloperatorsobservableobservablewindowwithobservabletest    disposemainboundaryerrorrace(observablewindowwithobservabletestjava:590)```these are generally irrelevant from those particular tests and should be safely ignored the difficulty is locating these tests if the console doesnt retain too many linesto resolve the issue perhaps the easiest way is to write a `testhelperwithundeliverablesuppressed(action)` method and keep wrapping the problematic test bodies;;1;0;write requested changes (#6996)* remove changes to rxjavaplugins* move @rule field into rxjavatest* use lambda suppressundeliverablerule;
7006;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;updating suppressundeliverablerule to have a named inner class instead of an anonymous inner class;based on the discussion in https://github.com/reactivex/rxjava/issues/7005;;0;updating suppressundeliverablerule to have a named inner class instead of an anonymous inner class;based on the discussion in  #7005;@akarnokd please take a look at this when you can? let me know if there is anything that could be improved || thanks! if it works for you locally and passes the ci then everything is okay ||  merging 7006 ;;;;1;1;updating suppressundeliverablerule to have a named inner class instead of an anonymous inner class;
7028;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: allow mbe in flowablegroupbytest.issue6974runpart2noevict;issue #7001;;7001.0;3x: allow mbe in flowablegroupbytestissue6974runpart2noevict;issue #7001 above test can probabilistically throw an exception thus: above assertion would be invalid i have removed the invalid assertion7001; merging 7028 ;3x: flaky groupby test; > issue6974part2case1noevict failed    javalangassertionerror: error(s) present: [ioreactivexrxjava3exceptionscompositeexception: 1 exceptions occurred ] (latch  0 values  15551 errors  1 completions  0)        at ioreactivexrxjava3observersbasetestconsumerfail(basetestconsumerjava:125)        at ioreactivexrxjava3observersbasetestconsumerassertnoerrors(basetestconsumerjava:212)        at ioreactivexrxjava3internaloperatorsflowableflowablegroupbytestissue6974runpart2noevict(flowablegroupbytestjava:2681)        at ioreactivexrxjava3internaloperatorsflowableflowablegroupbytestissue6974part2case1noevict(flowablegroupbytestjava:2693)        caused by:        ioreactivexrxjava3exceptionscompositeexception: 1 exceptions occurred             caused by:            ioreactivexrxjava3exceptionsmissingbackpressureexception: unable to emit a new group (#71) due to lack of requests please make sure the downstream can always accept a new group as well as each group is consumed in order for the whole operator to be able to proceed```error is an allowed outcome here;i would like to pick up this issue if no one is working on it yet || i would like to pick up this issue @ddunig2  are you still working on it? || i had not realized i got the okay to work on this @tmankita give me three days to work on it then its all yours || @akarnokd that test seems to be passing on my local machine im not sure what the issue is || it can probabilistically result in a `missingbackpressureexception` which is an allowed outcome but the test expects no errors:  the only thing needed is a different assert such as in this test:  || @akarnokd okay i got it would simply removing the assertnoerrors be valid? i would have to change the testsubsriber to testsubscriberex to include the assertterminate() and in this case would we still need assertcomplete()? ||;1;0; for issue #7001;
"7033;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;{flowable observable}.collect(collector) contravariant on t;added  ? super  twice. would 7032.;;7032.0;{flowableobservable}collect(collector) contravariant on t;added `? super` twice would 7032;compilation errors:```> task :compilejava/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/rxjava3/core/flowablejava  error: cannot infer type arguments for flowablecollectwithcollectorsingle<>        return rxjavapluginsonassembly(new flowablecollectwithcollectorsingle<>(this collector))                                        ^  reason: inferred type does not conform to equality constraint(s)    inferred: cap#1    equality constraints(s): cap#1t  where t is a type-variable:    t extends object declared in class flowable  where cap#1 is a fresh type-variable:    cap#1 extends object super: t from capture of ? super t/home/travis/build/reactivex/rxjava/src/main/java/io/reactivex/rxjava3/core/observablejava  error: cannot infer type arguments for observablecollectwithcollectorsingle<>        return rxjavapluginsonassembly(new observablecollectwithcollectorsingle<>(this collector))                                        ^  reason: inferred type does not conform to equality constraint(s)    inferred: cap#1    equality constraints(s): cap#1t  where t is a type-variable:    t extends object declared in class observable  where cap#1 is a fresh type-variable:    cap#1 extends object super: t from capture of ? super t2 errors``` || hehe i thought i would get away with not even compiling the sources ||  merging 7033 ;3x consider making collect contravariant on t;""hicurrently `collect` in flowable observable accepts a `collector<t a r> collector` if that were to be `collector<? super t a r> collector` less casting would be needed in some instances for example when using `javautilstreamcollectorsjoining()`:```javaobservable        just(""""foo"""" """"bar"""" """"baz"""")        cast(charsequenceclass)        collect(joining("""" """"))```the `cast(charsequenceclass)` would then no longer be neededshould also be binary compatible?"";probably wont break anything pr welcome ||;1;0;made the parameter of {flowableobservable}collect(collector) contravariant on t;"
"7040;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix map() conditional chain causing npe;fix the case when an (async) fused  filter - map - filter  chain does not handle the null indicator in its conditional path inside  map .;;7039.0;3x: fix map() conditional chain causing npe;fix the case when an (async) fused `filter`-`map`-`filter` chain does not handle the null indicator in its conditional path inside `map`7039; wow so happy with the turnaround on this! ||  merging 7040 ;flowablefilter potentially corrupts the source after observeon;""ive tried version 302 and 304 and both versions have this issueso heres the code thats causing the issue:```java	private publisher<shortcode> findall() {		// yes this is not just for this code example im actually using flowableempty()		return flowable<boolean>empty()				observeon(schedulersio())				filter(_b -> {					systemoutprintln(""""111111111111111111111111111 """" + (_b  null))					return _b				})				map(_b -> {					systemoutprintln(""""2222222222222222222222222222 """" + (_b  null))					return _b				})				// the flowable is always empty so casting to anything is safe				map(shortcodeclass::cast)	}```the code causes the following npe:```javalangnullpointerexception: the mapper function returned a null value        at javautilobjectsrequirenonnull(objectsjava:228)        at ioreactivexrxjava3internaloperatorsflowableflowablemap$mapconditionalsubscribertryonnext(flowablemapjava:124)```the console output is:```2222222222222222222222222222 true```so the function inside `filter` never gets called which is expected but then the function inside `map` gets called with a `null` element which is not expected it seems like the `filter` has corrupted the source and has made it emit a `null` elementand the weird thing is that if you run that piece of code in a standalone main method it will not cause the npealso doing any of the following will stop the npe from happening:* remove the `observeon`* move the `observeon` after the `filter`* add `to(flux::from)` after the `observeon`* replace `flowable<boolean>empty()observeon(schedulersio())` with `flux<boolean>empty()publishon(reactorcoreschedulerschedulerselastic())`the examples involving `flux` are simply to demonstrate that it is not an issue with reactor corei know that not being able to reproduce the npe with just that code sample is not terribly helpful but are there any circumstances where doing an `observeon` followed by a `filter` can corrupt the source?thanks!"";how are you consuming the problematic flow?could you place an objectrequirenonnull inside the map to see what is the code path that triggers the npe? || found the issue and posted a fix in #7040  || thanks a lot!!!  ||;1;0;3x: fix map() conditional chain causing npe;"
"7049;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix observable.window (size  skip  overlap) dispose behavior;disposing the main output of the  observable.window  operator did not properly propagate the dispose call under certain circumstances  such as no current active window or the window(s) were abandoned immediately.;;704.0;3x: fix observablewindow (size skip overlap) dispose behavior;disposing the main output of the `observablewindow` operator did not properly propagate the dispose call under certain circumstances such as no current active window or the window(s) were abandoned immediately7048; merging 7049 ;new contrib module: rxjava-async-util;- added startfuture deferfuture foreachfuture operators- left out the cancellationtoken resembling overloads as i was in doubt they can be meaningfully used if a task is cancelled it is enough to check the threadcurrentthread()isinterrupted() flag;""#620  why is this changing 7700+ lines of `observable` and most of `observabletests`? || i dont know maybe a line ending anomaly from your branch? somehow these two classes got transformed into crlf on checkout since i havent touched them ive changed them to lf || #622 this pull request merged the master branch instead of rebasing so has lots of unnecessary and unrelated changes i have created a new pull request after cherry picking just the relevant changes and avoiding the """"merge with master"""" artifacts:  || "";1;0;3x: fix observablewindow (size skip overlap) dispose behavior;"
7051;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: update marbles of onerrorresume(next|with) + cleanup;-  onerrorresumenext  marble now indicates the error and function-callback nature:;;0;3x: update marbles of onerrorresume(next|with) + cleanup;- `onerrorresumenext` marble now indicates the error and function-callback nature:( `onerrorresumewith` marble now has the correct name (and retains the original onerrorresumenext style):![image]( address now deprecated api usage of mockito- few other style corrections7050; merging 7051 ;;;;1;1;3x: update marbles of onerrorresume(next|with) + cleanup;
7071;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: fromrunnable/fromaction javadoc improvements;- fix the wording across the base types.;;0;3x: fromrunnable/fromaction javadoc improvements;- fix the wording across the base types- add missing error handling section- point to `fromaction` in `fromrunnable` docs; merging 7071 ;;;;1;1;3x: fromrunnable/fromaction javadoc improvements;
"7080;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;change a method name to make consistent with pr#6801;thank you for contributing to rxjava. before pressing the  create pull request  button  please consider the following points:;;680.0;change a method name to make consistent with pr#6801;""thank you for contributing to rxjava before pressing the """"create pull request"""" button please consider the following points:  -  please give a description about what and why you are contributing even if its trivialin #6801 a method name `flowablezipiterable#error` is changed to `fail` but its similar class `observablezipiterable` was not changedi changed it for consistency  -  please include the issue list number(s) or other pr numbers in the description if you are contributing in response to thosethis pr is related to #6801  -  please include a reasonable set of unit tests if you contribute new code or change an existing one if you contribute an operator (if applicable) please make sure you have tests for working with an `empty` `just` `range` of values as well as an `error` source with and/or without backpressure and see if unsubscription/cancellation propagates correctlythis change will not affect external behavior""; merging 7080 ;api design review: async & future;we have started collecting functionality related to `asyncjava` `observablestart` and similar such as in  and  these do not directly apply to the goals of rxjava-core in enabling async `observable` behavior but are valuable utilities for converting to and from `observable` and executing work asynchronouslyhaving them in the core however has the following drawbacks:- they increase api surface area code and byte size- they complicate the mental model by mixing multiple different concepts- they are tied to the `javautilconcurrent` model- different java libraries such as guava and akka have different models- each jvm language has different concurrency models and libraries- work can be executed asynchronous in many ways such as actors event-loops or thread pools and rxjava-core is purposefully non-opinionated about the source of concurrency or asynchronocityfor these reasons it is felt that this functionality should be removed and/or not accepted into rxjava-core but instead placed in a contrib module this is similar to how `rxjava-android` and `rxjava-swing` add additional functionality  @headinthebox and @jhusain;the `async` class and related operators has been moved into `rxjava-async-util`:  ||;1;0;s/error/fail/;"
7083;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: fix toflowable(error) not cancelling on mbe;there was a missing  upstream.cancel()  for when the overflow happens.;;0;3x: fix toflowable(error) not cancelling on mbe;there was a missing `upstreamcancel()` for when the overflow happens7081; merging 7083 ;;;;1;1;3x: fix toflowable(error) not cancelling on mbe;
7084;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix toflowable(error) not cancelling upon mbe;there was a missing upstream.cancel() for when the overflow happens.;;0;2x: fix toflowable(error) not cancelling upon mbe;there was a missing upstreamcancel() for when the overflow happens7081; merging 7084 ;;;;1;1;2x: fix toflowable(error) not cancelling upon mbe;
7089;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: fix flowable.concatmap backpressure w/ scalars;in  concatmap   there is a shortcut for when the mapped  flowable  turns out to be a scalar value and thus the full subscription process can be skipped. this used a so-called weak subscription that expected non-concurrent requesting to emits its single value.;;0;3x: fix flowableconcatmap backpressure w/ scalars;in `concatmap` there is a shortcut for when the mapped `flowable` turns out to be a scalar value and thus the full subscription process can be skipped this used a so-called weak subscription that expected non-concurrent requesting to emits its single valueunfortunately there is a race condition for when the downstream requests exactly when this weak subscription is activated resulting in either double emission or no emission at all the fix is to do the proper `compareandset` to ensure the emission happens exactly oncediscovered while running the build matrix and a test failed with:```ioreactivexrxjava3internaloperatorsflowableflowableconcatmapschedulertest > boundaryfusiondelayerror failed    javalangassertionerror: error(s) present: [ioreactivexrxjava3exceptionsmissingbackpressureexception: queue is full?!] (latch  0 values  1 errors  1 completions  0)        at ioreactivexrxjava3observersbasetestconsumerfail(basetestconsumerjava:125)        at ioreactivexrxjava3observersbasetestconsumerassertnoerrors(basetestconsumerjava:212)        at ioreactivexrxjava3observersbasetestconsumerassertresult(basetestconsumerjava:525)        at ioreactivexrxjava3internaloperatorsflowableflowableconcatmapschedulertestboundaryfusiondelayerror(flowableconcatmapschedulertestjava:94)        caused by:        ioreactivexrxjava3exceptionsmissingbackpressureexception: queue is full?!            at ioreactivexrxjava3internaloperatorsflowableflowableobserveon$baseobserveonsubscriberonnext(flowableobserveonjava:114)            at ioreactivexrxjava3internaloperatorsflowableflowableconcatmapscheduler$concatmapdelayedinnernext(flowableconcatmapschedulerjava:396)            at ioreactivexrxjava3internaloperatorsflowableflowableconcatmap$concatmapinneronnext(flowableconcatmapjava:559)            at ioreactivexrxjava3internaloperatorsflowableflowableconcatmap$weakscalarsubscriptionrequest(flowableconcatmapjava:343)            at ioreactivexrxjava3internalsubscriptionssubscriptionarbitersetsubscription(subscriptionarbiterjava:99)            at ioreactivexrxjava3internaloperatorsflowableflowableconcatmapscheduler$concatmapdelayedrun(flowableconcatmapschedulerjava:531)            at ioreactivexrxjava3internalschedulersimmediatethinscheduler$immediatethinworkerschedule(immediatethinschedulerjava:89)            at ioreactivexrxjava3internaloperatorsflowableflowableconcatmapscheduler$concatmapdelayedschedule(flowableconcatmapschedulerjava:431)            at ioreactivexrxjava3internaloperatorsflowableflowableconcatmapscheduler$baseconcatmapsubscriberonnext(flowableconcatmapschedulerjava:156)            at ioreactivexrxjava3internaloperatorsflowableflowablemap$mapsubscriberonnext(flowablemapjava:69)            at ioreactivexrxjava3internaloperatorsflowableflowableobserveon$observeonsubscriberrunsync(flowableobserveonjava:337)            at ioreactivexrxjava3internaloperatorsflowableflowableobserveon$baseobserveonsubscriberrun(flowableobserveonjava:174)            at ioreactivexrxjava3internalschedulersscheduledrunnablerun(scheduledrunnablejava:65)            at ioreactivexrxjava3internalschedulersscheduledrunnablecall(scheduledrunnablejava:56)            at javabase/javautilconcurrentfuturetaskrun(futuretaskjava:264)            at javabase/javautilconcurrentscheduledthreadpoolexecutor$scheduledfuturetaskrun(scheduledthreadpoolexecutorjava:304)            at javabase/javautilconcurrentthreadpoolexecutorrunworker(threadpoolexecutorjava:1130)            at javabase/javautilconcurrentthreadpoolexecutor$workerrun(threadpoolexecutorjava:630)            at javabase/javalangthreadrun(threadjava:832)```; merging 7089 ;;;;1;1;3x: fix flowableconcatmap backpressure w/ scalars;
7091;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;2.x: fix flowable.concatmap backpressure w/ scalars;in  concatmap   there is a shortcut for when the mapped  flowable  turns out to be a scalar value and thus the full subscription process can be skipped. this used a so-called weak subscription that expected non-concurrent requesting to emits its single value.;;0;2x: fix flowableconcatmap backpressure w/ scalars;in `concatmap` there is a shortcut for when the mapped `flowable` turns out to be a scalar value and thus the full subscription process can be skipped this used a so-called weak subscription that expected non-concurrent requesting to emits its single valueunfortunately there is a race condition for when the downstream requests exactly when this weak subscription is activated resulting in either double emission or no emission at all the fix is to do the proper `compareandset` to ensure the emission happens exactly oncebackport of #7089;;;;;1;1;replace java 8 constructs;
7093;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;clarify the documentation for scan operators;improves the wording the  scan  operators.;;0;clarify the documentation for scan operators;improves the wording the `scan` operators;/cc @daviddta  ||    no coverage uploaded for pull request base (`3x@35702ec`) [click here to learn what that means]( `n/a`(                                  3x    #7093   +/-   ##  coverage       ?   9954%             complexity     ?     6671             files          ?      742  ?    47275     ?     6374             hits           ?    47061             misses         ?       96             partials       ?      118           ```| [impacted files]( | coverage  | complexity  | ||---|---|---|---|| [/main/java/io/reactivex/rxjava3/core/flowablejava]( | `10000% <> ()` | `59500 <000> (?)` | || [ain/java/io/reactivex/rxjava3/core/observablejava]( | `10000% <> ()` | `56500 <000> (?)` | |------[continue to review full report at codecov]( **legend** - [click here to learn more]( `  absolute <relative> (impact)` `  not affected` `?  missing data`> ( last update [35702ecb063053]( read the [comment docs]( ||;;;;1;1;fix typo;
7110;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: flowable scan/scanwith backpressure documentation update;documented flowable initial value scan variants upstream consumption pattern as it is different from the variant with no initial value.;;0;3x: flowable scan/scanwith backpressure documentation update;documented flowable initial value scan variants upstream consumption pattern as it is different from the variant with no initial value7109; merging 7110 ;;;;1;1;3x: flowable scan/scanwith backpressure documentation merge <dd> sections;
7113;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix source locator code to support github actions folder layout;github action  actions/checkout@v2  downloads the files to a directory that doesn t appear to include the   rxjava  name anymore and makes the source code tests unable to read the files.;;0;3x: fix source locator code to support github actions folder layout;github action `actions/checkout@v2` downloads the files to a directory that doesnt appear to include the  `rxjava` name anymore and makes the source code tests unable to read the filesthis changes the locator to try for `src/main/java` in each parent directory relative to where the class files are located via `getresource`this is a preparation in case we have to bail from travis ci they now have a pricing model that in theory would be free for open source projects still but who knows in practice as there are hops apparently to get projects recognized as such; merging 7113 ;;;;1;1;3x: fix source locator code to support github actions folder layout;
7121;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: remove unnecessary cancel/dispose calls from terminating using;following up on a [gitter.im report](  the  oncomplete / onerror  methods of the  using  operators were calling cancel/dispose on the upstream even though there is no reason to do such a thing and is also not allowed by reactive streams rule [2.3](https://github.com/reactive-streams/reactive-streams-jvm#2.3).;;0;3x: remove unnecessary cancel/dispose calls from terminating using;following up on a [gitterim report]( the `oncomplete`/`onerror` methods of the `using` operators were calling cancel/dispose on the upstream even though there is no reason to do such a thing and is also not allowed by reactive streams rule [23]( original codes side-effect was that given a nested `using` pair an `oncomplete`/`onerror` of the inner sequence would trigger a cancellation and resource release in the outer before/while the `oncomplete`/`onerror` signals propagate downstream and return back on a non-eager setting; merging 7121 ;;;;1;1;3x: remove unnecessary cancel/dispose calls from terminating using;
7124;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: add onbackpressurereduce operator;added one more backpressure strategy. it works like backpressure latest but instead of just dropping values it merge/reduce excessive items;;0;3x: add onbackpressurereduce operator;added one more backpressure strategy it works like backpressure latest but instead of just dropping values it merge/reduce excessive items; merging 7124 ;;;;1;1;3x: onbackpressurereduce operator;
"7126;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: improve error messages in the test consumers;this pr improves the error messages reported in the  testobserver  and  testsubscriber :;;7125.0;3x: improve error messages in the test consumers;this pr improves the error messages reported in the `testobserver` and `testsubscriber`:- `assertvalue(predicate)` now shows the value that didnt pass the predicate- `assertvalueat(index t)`:  - if the index is out of range the message includes the valid range  - the message now includes the index argument where the failure happened- `assertvalueat(index predicate)`:  - if the index is out of range the message includes the valid range  - shows the value at index that didnt pass the predicate  - the message now includes the index argument where the failure happened- `asserterror(predicate)` is now worded to indicate the exception did not pass the predicatein addition the verification tests for the error messages were not actually testing the error message with `assertthrows` and have been updated7125; merging 7126 ;testobserver error messages should include more information about values where possible;""this applies to both 2x and 3x and while id like this to be  in 2x its more of a frustration than a bugsuppose im trying to assert that a value from a `testobserver` is equal to a particular value i write this test:```kotlinsinglejust(""""foo"""")test()assertvalue(""""bar"""")```and get this helpful error message:```javalangassertionerror: expected: bar (class: string) but was: foo (class: string) (latch  0 values  1 errors  0 completions  1)expected :bar (class: string) actual   :foo (class: string) (latch  0 values  1 errors  0 completions  1)```(never mind that the """"actual"""" in this case includes extra information it conveys what it needs to)suppose that i instead use a predicate:```kotlinsinglejust(""""foo"""")test()assertvalue { itequals(""""goodbye"""" ignorecase  true) }```now i get this error message instead:```javalangassertionerror: value not present (latch  0 values  1 errors  0 completions  1)```im told that the value isnt present which is slightly misleading as """"not present"""" is different than """"does not match predicate"""" but more importantly i dont see what the """"not present"""" value is which is immensely helpful when debugging the test my usual solution here is to use something like this instead:```kotlinsinglejust(""""foo"""")test()assertvalue {    assert(it)isequalto(""""bar"""" ignorecase  true)    true}```this code is more clunky but gives me the actual value in the error message:```javalangassertionerror: expected :""""[bar]""""actual   :""""[foo]""the cost is that i lose useful `(latch  0 values  1 errors  0 completions  1)` informationinstead of having to make a choice between these two it would be most helpful if the simplest solution was also just as informative:```javalangassertionerror: value bar (class: string) did not match predicate (latch  0 values  1 errors  0 completions  1)```this extends to many other assertions as well for example if i called `assertnovalues()` but there was a value? id like to know what that value was"";""> the cost is that i lose useful (latch  0 values  1 errors  0 completions  1) informationwith `single` you have 3 states: not finished success failure you can rule out the first two via `assertcomplete` and `assertnoerrors` then use your predicate that captures the value for you since you are on kotlin you can even make an extension method for it || if i change the order by checking `assertcomplete` first:```behaviorsubjectcreatedefault(""""foo"""")test()assertcomplete()assertvalue { itequals(""""bar"""" ignorecase  true)}```then if the chain is not completed i will learn that first without learning the value even if knowing the value would be more useful for debugging:```javalangassertionerror: not completed (latch  1 values  1 errors  0 completions  0)```even then with a more complicated workaround available why shouldnt the librarys provided assertion method provide information (the exact value that failedthe predicate) that any programmer would like to know when their test fails? the only drawback i can think of is if the value has an overly long and unhelpful `tostring` but thats a minor drawback compared to the usefulness of seeing the value in all cases || the library provides a limited set of assertions based on community feedback and usage for anything more complicated the `testobserver` can be extended and youll have direct access to the [received events]( as well as add on-class methods this will also let you call [fail()]( to produce that particular formatted error message || im not asking for a new assertion to be added but for the existing assertion to have a better error message is there a reason for the """"value not present"""" error message to not contain the value that failed the predicate? || it didnt fit the pattern expected vs actual because with a predicate there is no way to tell the expected hence the actual was not considered to be printed eitherafter further considerations and looking at other methods the error message across the tester class can be improved ill prepare a pr with the changes ||  "";1;0;verify assertvalueat with negative index;"
7127;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: improve javadocs of connectable sources;improve the styling and wording of  connectableobservable  and  connectableflowable .;;0;3x: improve javadocs of connectable sources;improve the styling and wording of `connectableobservable` and `connectableflowable`; merging 7127 ;;;;1;1;3x: improve javadocs of connectable sources;
7129;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: add onbackpressurereduce operator;added one more overloaded version of onbackpressurereduce operator;;0;3x: add onbackpressurereduce operator;added one more overloaded version of onbackpressurereduce operator```@experimental    @checkreturnvalue    @backpressuresupport(backpressurekindunbounded_in)    @schedulersupport(schedulersupportnone)    @nonnull    public final <r> flowable<r> onbackpressurereduce(@nonnull supplier<r> supplier @nonnull bifunction<r ? super t r> reducer) {        return rxjavapluginsonassembly(new flowableonbackpressurereducewith<>(this supplier reducer))    }```changes:- added `flowableonbackpressurereducewith`- `abstractbackpressurethrottlingsubscriber` has two types now t - upstream r- downstream and inherited by 3 classes: `backpressurelatestsubscriber` `backpressurereducesubscriber` and `backpressurereducewithsubscriber`suggest to review and merge after [this ]( merged;could you please rebase this onto a fresh `3x`? ||  merging 7129 ;;;;1;1;3x: add onbackpressurereduce operator;
"7144;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: update marbles of amb()  ambarray() and ambwith();update the marble diagrams in  flowable  and  observable   indicating cancellation of the non-winners.;;6995.0;3x: update marbles of amb() ambarray() and ambwith();update the marble diagrams in `flowable` and `observable` indicating cancellation of the non-winners6995(https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowableambpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowableambarraypng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/flowableambwithpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observableambpng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observableambarraypng)![image](https://rawgithubcom/wiki/reactivex/rxjava/images/rx-operators/observableambwithpng); merging 7144 ;3x: observableamb marble diagram is a bit incorrect (or maybe its a bug?);""version: 304the marble diagram for the `observableamb` operator is as follows:![amb]( means that the second (looser) `observable` stays active (subscribed) while the whole `amb` executes but in fact all `observables` except the first (winner) are being cancelled (disposed)please consider the following code snippet:```kotlin        observable            amb(                listof(                    observable                        create<int> {                            threadsleep(500l)                            itonnext(1)                            threadsleep(500l)                            itoncomplete()                        }                        subscribeon(schedulerscomputation())                        doonnext { logv(""""mytest"""" """"1: next $it"""") }                        dooncomplete { logv(""""mytest"""" """"1: complete"""") }                        dofinally { logv(""""mytest"""" """"1: finally"""") }                    observable                        create<int> {                            threadsleep(250l)                            itonnext(1)                            threadsleep(500l)                            itoncomplete()                        }                        subscribeon(schedulerscomputation())                        doonnext { logv(""""mytest"""" """"2: next $it"""") }                        dooncomplete { logv(""""mytest"""" """"2: complete"""") }                        dofinally { logv(""""mytest"""" """"2: finally"""") }                )            )            doonnext { logv(""""mytest"""" """"amb: next $it"""") }            dooncomplete { logv(""""mytest"""" """"amb: complete"""") }            dofinally { logv(""""mytest"""" """"amb: finally"""") }            subscribe()```this code produces the following output:```2020-05-22 16 01724 5954-5979/? v/mytest: 2: next 12020-05-22 16 01724 5954-5979/? v/mytest: 1: finally2020-05-22 16 01724 5954-5979/? v/mytest: amb: next 12020-05-22 16 02224 5954-5979/? v/mytest: 2: complete2020-05-22 16 02224 5954-5979/? v/mytest: amb: complete2020-05-22 16 02224 5954-5979/? v/mytest: amb: finally2020-05-22 16 02224 5954-5979/? v/mytest: 2: finally```also it would be nice to describe this behavior explicitly in java docs"";some of the older diagrams havent been updated to include dispose/cancel information the [newer ones are]( > also it would be nice to describe this behavior explicitly in java docspr welcome ||;1;0;fix image size;"
7145;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: fix take() mentioning the old limit() operator;the javadocs of  take  still referenced the original  limit  operator.;;0;3x: fix take() mentioning the old limit() operator;the javadocs of `take` still referenced the original `limit` operator; merging 7145 ;;;;1;1;3x: fix take() mentioning the old limit() operator;
7150;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: document schedulers.from s rejectedexecutionexception handling;updates the 3 overloads of  schedulers.from  to describe (in a concise manner) the cases when the  executor  would throw a  rejectedexecutionexception . such exceptions can t be reasonably handled from within rxjava.;;0;3x: document schedulersfroms rejectedexecutionexception handling;updates the 3 overloads of `schedulersfrom` to describe (in a concise manner) the cases when the `executor` would throw a `rejectedexecutionexception` such exceptions cant be reasonably handled from within rxjavathere are typically two cases when such exception would occur:1) **the underlying executor is shut down** operators such as `observeon` guarantee worker-confinement when calling `onnext` `onerror` and `oncomplete` a failure to schedule would at best bypass this confinement notifying the downstream on the current thread at worst cause overlapping execution downstreamthe recommended workaround is to cancel all flows using the particular `scheduler` after which the executor can be shut down safely2) **the underlying executor temporarily rejects more work**such temporary rejections are often used in traditional `executor` usages to drop work or pause the submission of work in rxjava though there is often no 1:1 correspondence to signals (`onnext` `onerror` or `oncomplete`) some work may be correlated to several `onnext`s other work may be due to downstream requests dropping any such work may lead to inconsistent flow state or livelocksthe recommended workaround is to express limits on the execution via backpressure (eg `flowable`s)    7149; merging 7150 ;;;;1;1;3x: schedulersfrom vs rejectedexecutionexception;
7151;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: onreducebackpressure internals cleanup;- simplify empty/non-empty cases.;;0;3x: onreducebackpressure internals cleanup;- simplify empty/non-empty cases- fix cancellation order and wrong fall-through- add deterministic test to cover the reduction cases; merging 7151 ;;;;1;1;update flowableonbackpressurereducewithtestjava;
"7160;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;io scheduler  scheduled worker release.;ioscheduler  releases the workers back to the pool to be reused optimistically to reduce the number of threads being created. this could lead to deadlocks in some situations like this one:;;0;io scheduler scheduled worker release;""`ioscheduler` releases the workers back to the pool to be reused optimistically to reduce the number of threads being created this could lead to deadlocks in some situations like this one:```flowablejust(""""item"""")        observeon(schedulersio())        firstorerror()        subscribe(__ -> {            for (int i  0 i < 200 i++) {                completablecomplete()                        observeon(schedulersio())                        blockingawait()            }            systemoutprintln(""""will never reach this"""")        })```as discussed on  this pr allow to configure this behaviourenabling `rx3io-scheduled-release` will guarantee that workers are not reused until all the processing has finished once we merge this we i can create a similar pr for the `2x` branch""; merging 7160 ;;;;1;1;fix tests addressed javadoc feedback;"
7162;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;io scheduler  scheduled worker release (v2.x);this is the same change as  but targeting the 2.x branch;;0;io scheduler scheduled worker release (v2x);this is the same change as  but targeting the 2x branchrelated to issue https://githubcom/reactivex/rxjava/issues/7153; merging 7162 ;;;;1;1;support for scheduled release of threads in io scheduler;
7163;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: testscheduler option to use onschedule hook;the  testscheduler  is a bit inconsistent regarding the use of  rxjavaplugins.onschedule . it extends  scheduler  so the  scheduledirect  methods do invoke the hook whereas the worker s  schedule  methods don t.;;711.0;3x: testscheduler option to use onschedule hook;the `testscheduler` is a bit inconsistent regarding the use of `rxjavapluginsonschedule` it extends `scheduler` so the `scheduledirect` methods do invoke the hook whereas the workers `schedule` methods dontthis pr adds a constructor flag to enable the use of the hook in the workers `schedule` methods as well this addition should avoid issues with existing tests not expecting the hook to be invoked all of a sudden7119; merging 7163 ;recursion on executorservice with >1 thread is slow;recursion on newthreadscheduler or executorscheduler with 1 thread is fast as number of threads increase in the pool it increasingly slows down my guess is its adding overhead jumping between threads and/or cpus and thus having cache misses or something along those linesi found this while testing `testrecursionmemoryusage` and trying `schedulersthreadpoolforcomputation()` versus `schedulersnewthread()`i confirmed that this changes the performance: `executorsnewscheduledthreadpool(2)` vs `executorsnewscheduledthreadpool(1)`the real code uses numcores for that value which is worsewe need to look at a way of using a thread-pool sized to the number of threads on the machine so were not launching new threads every time a scheduler is used but that recursion efficiently uses the same thread;removed `executorscheduler` and replaced with `computationscheduler` that has a pool of event loops:  ||;1;0;3x: testscheduler option to use onschedule hook;
7164;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;updating documentation for scheduleactual method;remove unnecessary sentence from  newthreadworker.scheduleactual .;;716.0;updating documentation for scheduleactual method;remove unnecessary sentence from `newthreadworkerscheduleactual`7161; merging 7164 ;[scala adapter] observable trait has only the seed version of scan;in the documentation ( it says that there are two forms of scan: `my_observablescan(accumulator_closure)` which seeds with the next value of `my_observable` and `my_observablescan(initial_seed accumulator_closure)` which seeds with `initial_seed`however the scala adapter only provides the latter of these two see  this missing for a reason?;i imagine that such a method would look something like``` scaladef scan[t](accumulator: (t t) > t): observable[t]   toscalaobservable[t](asjavaobservablescan(new func2[t t t] {    def call(t1: t t2: t): t  accumulator(t1 t2)  }))``` ||  check the code to appreciate the beauty of covariance || hmm im not exactly sure what youre referring to the last commit affecting  was from 10 days agoin general how would i go about writing a scan without an initial seed? || @samuela hes referring to this pr:  (which is not yet merged) || awesome ;1;0;updating documentation for scheduleactual method;
7165;1;0;0;1;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: add fusion support to concatmap{maybe|single|completable};this pr adds front fusion support to;;706.0;3x: add fusion support to concatmap{maybe|single|completable};this pr adds front fusion support to- `flowableconcatmapcompletable`- `flowableconcatmapmaybe`- `flowableconcatmapsingle`- `observableconcatmapcompletable`- `observableconcatmapmaybe`- `observableconcatmapsingle`the operators have been tidied up by factoring out common code pathsin addition the `deferredscalarsubscription`s fusion-emission had to be  in async fusion mode `onnext(null)` is generally expected from the upstream but `deferredscalarsubscription` sent the value itself now it correctly sends `null` (`deferredscalardisposable` already did this correctly)7061; merging 7165 ;clean merge of rxjava-async-util;manual merge of  by cherry picking relevant changes;#623  ugh  broke this pull request || #624 looks like i got a properly cleaned merge in  ||;1;0;3x: add fusion support to concatmap{maybe|single|completable};
7168;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: improve javadocs style of schedulers;add the proper links and code blocks to improve style to  io.reactivex.rxjava3.schedulers.schedulers .;;0;3x: improve javadocs style of schedulers;add the proper links and code blocks to improve style to `ioreactivexrxjava3schedulersschedulers`; merging 7168 ;;;;1;1;3x: improve javadocs style of schedulers;
"7169;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: introduce property rx3.scheduler.use-nanotime;7154;;0;3x: introduce property rx3scheduleruse-nanotime;7154;""@akarnokd i got a problem when i try to test the code because when the class is loaded one can not change set variable:`private static final string drift_use_nanotime  """"rx3schedulerdrift-use-nanotime"""" resolution:* no tests* define a own test set which tests the nanotime use-case and configure this test-src-set to run each class in a new jvm* find a junit-runner which loads the test-classes via a own classloader* remove """"final"""" for `drift_use_nanotime` and set it for testing which might not be desirable because it can be changed laterwhat are your thoughts on this issue regarding testing? ||  merging 7169  "";;;;1;1;3x: introduce property rx3scheduleruse-nanotimeissue-id: #7154;"
"7170;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;2.x: introduce property rx2.scheduler.use-nanotime (#7154);7169;;7154.0;2x: introduce property rx2scheduleruse-nanotime (#7154);7169;@akarnokd  i had to create a new `schedulertest` class because on the 2x branch the package did not match the package of `scheduler` therefore i could not access the field (package-private) ||  merging 7170 ;3x feature: introduce abstract time source for scheduler impl;version 309related: task with delay scheduled in a `scheduler`problem:when the linux kernel wakes up from suspension `systemcurrenttimemillis` will be adjusted on linux x86 openjdk in my case this is bad because watchdogs/ timer will fire which they shouldnt i would like to use a different time-source but cant because `systemcurrenttimemillis` is hard-coded```java    public long now(@nonnull timeunit unit) {        return unitconvert(systemcurrenttimemillis() timeunitmilliseconds)    }```solution:i would like to introduce a `timesource` interface which can be set via `rxjavaplugins````kotlininterface timesource {    fun now(unit : timeunit) : long}```impl```kotlinclass nanosource : timesource {    override fun now(unit: timeunit): long {        return unitconvert(systemnanotime() timeunitnanoseconds)    }}```in order to not break the current behavior the default timesource would still be `systemcurrenttimemillis()` this idea was pitched by: @artem-zinnatullin in  this is fine request is fine with the community i would try to implement it quickly and create a pr for it;""you can override `now` when implementing `scheduler` and `worker` and delegate the other methods to an existing `scheduler` and `worker` || @akarnokd  thank you for your responsei actually do not want to implement/ delegate because this will probably only work new scheduler what about `schedulerssingle` or `schedulersfrom` (`executorscheduler`)for example when i use `schedulerssingleworker()` the implementation for `public disposable scheduleperiodically(@nonnull runnable run final long initialdelay final long period @nonnull final timeunit unit)` will be used from `super` which uses `systemcurrenttimemillis` that said i am unable to re-use already existing `scheduler` because it uses a clock which is not desired in my case `deep sleep` is a feature which will occur quite often and other developers in different departments probably do not know that `systemcurrenttimemillis` is used and just use `schedulerssingle` for everything which could cause very subtle bugs regarding delegation and overriding: yes i could just wrap another scheduler and overwrite now for `worker` and `scheduler` and use `rxjavaplugins` in order to overwrite eg `schedulerssingle` but i think this is actually more difficult then just overwriting `systemcurrenttimemillis` with an interface which return a `long` as time-source performance wise i would reckon that c2/ art would just inline the call to the time-source if `hot` enough but i would bench it firstdo you have a better idea how to easily switch the time without requiring to re-implement schedulers (eg reuse `schedulerssingle`)?  || another idea would be to use the java standard `scheduledexecutorservice` (provided it doesnt have the same timing problem) to drive your sensitive flows through `subject`s and/or `observablecreate` emitting the ticksotherwise yes we would need to add indirection to the `now` calculation the problem then is should it be affecting any and all default `scheduler` implementations or should it be more coarse grained? || > another idea would be to use the java standard `scheduledexecutorservice` (provided it doesnt have the same timing problem) to drive your sensitive flows through `subject`s and/or `observablecreate` emitting the ticks> > otherwise yes we would need to add indirection to the `now` calculation the problem then is should it be affecting any and all default `scheduler` implementations or should it be more coarse grained?is this a bad idea to add a method to rxjavaplugins to override the default time source?something like this:``` /**     * sets the specific hook function     * @param handler the hook function to set null allowed     */    public static void settimesourcehandler(@nullable function<? super timesource ? extends timesource> handler) {        if (lockdown) {            throw new illegalstateexception(""""plugins cant be changed anymore"""")        }        ontimesourcehandler  handler    }```@sergejisbrecht rxjavaplugins can also be used to override single io and computational schedulers this doesnt cover schedulersfrom() but at least it covers computation() || > is this a bad idea to add a method to rxjavaplugins to override the default time source?i generally prefer to modify rxjavaplugins as a last resort || dear @akarnokdi have been looking into `rxjava`s `scheduler` implementation i will sum up my findings as follows:scheduler```scheduler {    default:        disposable scheduledirect(@nonnull runnable run)        disposable scheduledirect(@nonnull runnable run long delay @nonnull timeunit unit) // depends on worker default-impl        disposable scheduleperiodicallydirect(@nonnull runnable run long initialdelay long period @nonnull timeunit unit) // uses now(timeunit) transitively from worker default-impl        long now(@nonnull timeunit unit)    abstract:        abstract worker createworker()}```worker```schedulerworker {    default:        disposable schedule(@nonnull runnable run)        disposable scheduleperiodically(@nonnull runnable run final long initialdelay final long period @nonnull final timeunit unit) // uses now(timeunitnanoseconds)        long now(@nonnull timeunit unit)    abstract:        abstract disposable schedule(@nonnull runnable run long delay @nonnull timeunit unit)}```example implementation of `singlescheduler````singlescheduler {    override:        disposable scheduledirect(@nonnull runnable run long delay timeunit unit)        disposable scheduleperiodicallydirect(@nonnull runnable run long initialdelay long period timeunit unit)        worker createworker()}``````singleschedulerworker {    override:        disposable schedule(@nonnull runnable run long delay @nonnull timeunit unit)}```condition* `singlescheduler` uses a `scheduledexecutorservice` internally * `scheduledexecutorservice` uses `systemnanotime` and `singleschedulerworker#scheduleperiodically` uses `systemcurrenttimemillis`problem:`singlescheduler` uses default impl `scheduleperiodically` from `singleschedulerworker` but overwrites `scheduler#scheduledirect` (with delay) & `scheduler#scheduleperiodicallydirect`conclusion:even one scheduler in this case `singlescheduler` might use two different times which might cause subtile issues when returning from suspension (s2r) any idea why `singleschedulerworker` does not overwrite `singleschedulerworker#scheduleperiodically` just like it is done with `singlescheduler#scheduleperiodicallydirect`? i did not find a way to create a scheduler which uses only one time-source at every case (eg executorscheduler)regarding you suggestion:> you can override now when implementing scheduler and worker and delegate the other methods to an existing scheduler and workeri do see a problem with this approach:* in order to wrap a `singlescheduler` i would implement a new scheduler and delegate all the work to given `singlescheduler` and overload `now` with my time-source of choice when looking into the implementation of `scheduler` and `worker` it becomes apparent that `now` is actually only used in one place: `schedulerworker#scheduleperiodically` this means that this method should not be delegated in the new implementation when `singlescheduler` uses the default implementation it can not be delegated because the delegate would call now this its `this` and not the overloaded `now` this brings me to my point i do need internal knowledge when and where `now` is used which can change at any time if this happens my wrapper will probably not do what i wantconclusion: it might be possible to use a different time source but in the light of how rxjava implements/ delegates to executors the only option is actually to use `systemnanotime` in order to garantuee that all methods use the same time-source resolution:maybe we do not need a global time-source interface which is set via `rxjavaplugins` but extend some factory methods to take a time-source as a parameter when creating by default a singleton of `systemcurrenttimemillis` will be used what do you think about it?> otherwise yes we would need to add indirection to the now calculation the problem then is should it be affecting any and all default scheduler implementations or should it be more coarse grained?i would probably not do it there might be a use-case there you want to configure how each `scheduler` should behave (eg fire directly after suspension when times will be adjusted and time > timer_fires_time or not fire because time was not adjusted and time < timer_fires_time) but this could be done with a simple overload when creating a `new` scheduler witth the factory provided  schedulers` but in my opinion there is actually only one value which should be allowed and this is `systemnanotime` because all work is already delegate to executorservice which internally uses this time-source this would make sure that all methods use the same time-source as i see it no one ever had such a problem or did not bother therefore the time and resources are probably not well spend to extend rxjava to support fine grained editing of the time-sourceschedulerwrapper-impl: || [observableinterval]( uses `scheduleperiodicallydirect` would it work for your periodic needs?> any idea why singleschedulerworker does not overwrite singleschedulerworker#scheduleperiodically just like it is done with singlescheduler#scheduleperiodicallydirecti have to think about this || > observableinterval uses scheduleperiodicallydirect would it work for your periodic needs?this is probably more of a isosteric problen than a real one our developers probably use every method in the `scheduler` and `worker` class this is why i can not say in advance which operators will be used `schedulerworker#scheduleperiodically`* flowableinterval* flowablebuffertimed* flowablewindowtimed`scheduler#scheduleperiodicallydirect`* flowableinterval* flowablesampletimed* flowablewindowtimedfor example when i use a `singlescheduler` and compose a stream which uses `schedulerworker#scheduleperiodically` and `scheduler#scheduleperiodicallydirect` a developer might run into trouble because a timer fires after suspension and another one does notexample```        // scheduler#scheduleperiodicallydirect        flowableinterval(10 timeunitseconds schedulerssingle())            // schedulerworker#scheduleperiodically            buffer(5 timeunitseconds schedulerssingle())``` || i seefor a start would the introduction of a system property `rx3schedulerdrift-use-nanotime` and behavior help you? || > for a start would the introduction of a system property rx3schedulerdrift-use-nanotime and behavior help you?yes of course this would be enough for me i would probably call it `rx3schedulernow-use-nanotime` but either way is fineedit: if this is the way i would like to suggest that i backport this change back to rxjava2 because we are currently using it and we would not need to change before rxjava2 reaches eol on `february 28 2021`if you would like i would create an pr for rxjava3 and rxjava3 adding said property || > pr for rxjava3 and rxjava3 adding said propertysure go ahead lets use `rx3schedulerdrift-use-nanotime` because there could be an implicit assumption that `now(timeunitmilliseconds)` is the current time || "";1;0;2x: introduce property rx2scheduleruse-nanotime (#7154);"
7173;1;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: workaround for futuretask.tostring + jdk 11 build;starting from jdk 10  the  futuretask.tostring  can now print the inner callable routine  which if somehow references the parent  futuretask  again  it leads to  stackoverflowerror . this can happen in rxjava because  abstractdirecttask  and  scheduledrunnable  store the  future  object returned by the executor in a reference field that gets accessed by their default  tostring  implementation.;;0;3x: workaround for futuretasktostring + jdk 11 build;starting from jdk 10 the `futuretasktostring` can now print the inner callable routine which if somehow references the parent `futuretask` again it leads to `stackoverflowerror` this can happen in rxjava because `abstractdirecttask` and `scheduledrunnable` store the `future` object returned by the executor in a reference field that gets accessed by their default `tostring` implementationthe fix is to define custom `tostring`s that break this cycle note that we cant print the underlying `runnable` either because that could also reference something in a circular manner in addition the release of the `runner` `thread` marker has been moved closer to the exit of the wrappers which helps with the state determination and self-cancellationto verify the fix works a new github action has been added targeting jdk 11 as the issue does not manifest itself under the main target jdk 87172; merging 7173 ;;;;1;1;3x: workaround for futuretasktostring + jdk 11 build;
7178;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;fix the typos;fix the javadoc typos of #7150.;;0;fix the typos;fix the javadoc typos of #7150;;;;;1;1;fix the typos;
"7191;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;3.x: add onsubscribe hook to parallelflowable operators;parallel operators were missing an  rxjavaplugins.onsubscribe  hook.;;719.0;3x: add onsubscribe hook to parallelflowable operators;parallel operators were missing an `rxjavapluginsonsubscribe` hook7190; merging 7191 ;map doesnt work with random numbers;""this may be specific to the scala adapter or a general issue im not sure it may also be simply disallowed somewhere in the documentation but i couldnt find anything mentioning it``` scalaval o  observableinterval(250 millis)        map(x > mathrandom)        take(10)var id  o map(x > x)osubscribe(n > println(""""n  """" + n))idsubscribe(n > println(""""id  """" + n))```produces```n  016257918600676124id  0015701253635574397n  065811522451999id  06745847570884935n  008592558068181289id  06761688548540207n  01511738754239501id  037751043543314455n  03335425497156287id  02433811198187099```of course we expect the values of the two observables to be equal but they arent related whatsoever"";""this behavior is the expected behavior remove the line `var id  ` and replace the line `idsubscribe()` by a second `osubscribe()` and you will see that the two outputs are still different the reason is that everywhere in rx each subscriber gets its own version of the observable it subscribes to so here each subscriber gets its own """"observableinterval"""" so `x > mathrandom` is executed seperately for each subscriber if you want several observers to share the same observable you should use the `publish` operator || you have discovered the distinction between """"hot"""" and """"cold"""" observables and the evil that is side-effects || following up on a previous comment your code should read something like this: ```val (start o)  observableinterval(250 millis) map {x > mathrandom} take 10 publishval id  o map {x > x}start()o subscribe {x > println(s""""n  $x"""")}id subscribe {x > println(s""""id  $x"""")}``` || note that we will be changing the scala bindings to use connectableobservable so while this code work now in the future you would write something like so:val observable  observableinterval(250 millis)map(x > mathrandom)take(10)publishval id  observablemap(x > x)observablesubscribe(x > println(s""""n  $x""""))idsubscribe(x > println(s""""id  $x""""))observableconnect || ah gotcha thanks for the clarification! || "";1;0;3x: add onsubscribe hook to parallelflowable operators;"
"7196;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: allow single.zip and maybe.zip result to be garbage collected;7195;;719.0;3x: allow singlezip and maybezip result to be garbage collected;7195;@akarnokd sorry hit re-review accidentally    ||  merging 7196 ;map doesnt work with random numbers;""this may be specific to the scala adapter or a general issue im not sure it may also be simply disallowed somewhere in the documentation but i couldnt find anything mentioning it``` scalaval o  observableinterval(250 millis)        map(x > mathrandom)        take(10)var id  o map(x > x)osubscribe(n > println(""""n  """" + n))idsubscribe(n > println(""""id  """" + n))```produces```n  016257918600676124id  0015701253635574397n  065811522451999id  06745847570884935n  008592558068181289id  06761688548540207n  01511738754239501id  037751043543314455n  03335425497156287id  02433811198187099```of course we expect the values of the two observables to be equal but they arent related whatsoever"";""this behavior is the expected behavior remove the line `var id  ` and replace the line `idsubscribe()` by a second `osubscribe()` and you will see that the two outputs are still different the reason is that everywhere in rx each subscriber gets its own version of the observable it subscribes to so here each subscriber gets its own """"observableinterval"""" so `x > mathrandom` is executed seperately for each subscriber if you want several observers to share the same observable you should use the `publish` operator || you have discovered the distinction between """"hot"""" and """"cold"""" observables and the evil that is side-effects || following up on a previous comment your code should read something like this: ```val (start o)  observableinterval(250 millis) map {x > mathrandom} take 10 publishval id  o map {x > x}start()o subscribe {x > println(s""""n  $x"""")}id subscribe {x > println(s""""id  $x"""")}``` || note that we will be changing the scala bindings to use connectableobservable so while this code work now in the future you would write something like so:val observable  observableinterval(250 millis)map(x > mathrandom)take(10)publishval id  observablemap(x > x)observablesubscribe(x > println(s""""n  $x""""))idsubscribe(x > println(s""""id  $x""""))observableconnect || ah gotcha thanks for the clarification! || "";1;0;update maybeziparrayjava;"
"7203;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix schedulers.from to honor interruptibleworker across methods;the direct scheduling methods of the  executorscheduler  created via  schedulers.from(executor  boolean)  did not fully honor the  interruptibleworker  settings.;;7201.0;3x: fix schedulersfrom to honor interruptibleworker across methods;the direct scheduling methods of the `executorscheduler` created via `schedulersfrom(executor boolean)` did not fully honor the `interruptibleworker` settings7201; merging 7203 ;3x flowable#sample may complete on an interrupted thread;""hi !using version 3010 and the following code:```javaint i  0while (true) {        systemoutprintln(""""i  """" + i++)        publishsubject<long> subj  publishsubjectcreate()        subjtoflowable(backpressurestrategyerror)	        sample(10 timeunitmilliseconds)	        dofinally(() -> {		        systemoutprintln(stringformat(""""current thread %s is interrupted: %b""""                                         threadcurrentthread()getname()				        threadcurrentthread()isinterrupted())                        )		        if (threadcurrentthread()isinterrupted()) {			        systemexit(1)		        }	        })	        subscribe()        subjonnext(1l)                observabletimer(10 timeunitmilliseconds)	        blockingsubscribe(any -> subjoncomplete())}```the loop ends after a few iterations (usually between 250 and 300 on my device)the first iterations give: `current thread main is interrupted: false`and the last: `current thread rxcomputationthreadpool-7 is interrupted: true`i quite understand why i get this result but im still surprised by it is it an known/accepted/intended behavior ?nb 1: using `buffer` unstead of `sample` gives the same resultnb 2: changing `sample` scheduler to `schedulersfrom(executorsnewsinglethreadexecutor())` causes the loop to never endnb 3: first observed with rxjava2 with no change in behavior"";this is possible behavior because your completion races with the sampling when the upstream completes the timer for the sampler thread is cancelled which interrupts it if it happens to runif you want to avoid interruption run the `sample` on a non-interruptible schedulerschedulersfrom(executor boolean)]( || thanks for the explanation and the work-aroundi have been doing a few tests with `schedulersfrom(executor boolean)`using `executorsnewsinglethreadexecutor()` has given the expected result (ie an interrupted thread with a value `true` for the boolean no interruption otherwise)using `executorsnewsinglethreadscheduledexecutor()` has not in both case my code ended with an interruptionis there something i have been missing ? || i dont understand what you are saying are you saying you tried my suggestion with those executors and still got the interruption in dofinally? || thats iti ran the code provided in my first post with only one modification: i specified a scheduler for the `sample` operatori tried the following schedulers:`schedulersfrom(executorsnewsinglethreadexecutor())``schedulersfrom(executorsnewsinglethreadexecutor() true)`both had the expected result`schedulersfrom(executorsnewsinglethreadscheduledexecutor() false)``schedulersfrom(executorsnewsinglethreadscheduledexecutor() true)`both ended with an interruption || i seelooks like the case with `scheduledexecutorservice` was missed when the non-interruptible feature was added ill fix it tomorrow ||;1;0;3x: fix schedulersfrom to honor interruptibleworker across methods;"
7205;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;standardize java source headers;convert license headers to block comments instead of dangling javadoc comments. use checkstyle to validate java source files have licenses attached. updated checkstyle to most recent version. updated checkstyle configuration to remove mostly commented out code and update to correct dtd.;;0;standardize java source headers;convert license headers to block comments instead of dangling javadoc comments use checkstyle to validate java source files have licenses attached updated checkstyle to most recent version updated checkstyle configuration to remove mostly commented out code and update to correct dtdremoved unit test fixlicenseheaders as the functionality is handled by the checkstyle header validationone commit is checkstyle and gradle updates second commit is for all the java source license updates7204;please dont remove the fixlicenseheaders || also please do not change the license start date it should be 2016 ||  merging 7205 ;;;;1;1;fix bad logic for header check in fixlicenseheaders test;
7206;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: fix wrong reference in single.flattenstreamasobservable javadoc;fix the copy-paste error of pointing to  flattenasflowable  instead of  flattenasobservable .;;0;3x: fix wrong reference in singleflattenstreamasobservable javadoc;fix the copy-paste error of pointing to `flattenasflowable` instead of `flattenasobservable`; merging 7206 ;;;;1;1;3x: fix wrong reference in singleflattenstreamasobservable javadoc;
7210;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;0;0;added javadoc checks to checkstyle. fix violating javadoc.;add javadocmethod and missingjavadocmethod checks to checkstyle.;;0;added javadoc checks to checkstyle fix violating javadoc;add javadocmethod and missingjavadocmethod checks to checkstylechecks ensure there are no missing javadoc comments for public methods and that each of the javadoc comments describe all method parametersadd suppressionsxml checkstyle configuration file to exclude jmh testand internal from missingjavadocmethod checkmove checkstyle configuration files and license headers into config directory to reduce pollution of root directoryfix javadoc comments that violate the added checks which should take care of the first bullet from issue #4535 (parameter names change in the code but the javadocs still refer to the old names); merging 7210 ;;;;1;1;added javadoc checks to checkstyle fix violating javadocadd javadocmethod and missingjavadocmethod checks to checkstylechecks ensure there are no missing javadoc comments for public methods and that each of the javadoc comments describe all method parametersadd suppressionsxml checkstyle configuration file to exclude jmh testand internal from missingjavadocmethod checkmove checkstyle configuration files and license headers into config directoryfix javadoc comments that violate the added checks;
"7212;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: compositeexception.printstacktrace to write directly into printstream/printwriter;i don t remember why the stacktrace it wasn t printed directly via the printstream/printwriter  no reason to aggregate the entire string output.;;721.0;3x: compositeexceptionprintstacktrace to write directly into printstream/printwriter;i dont remember why the stacktrace it wasnt printed directly via the printstream/printwriter no reason to aggregate the entire string outputfixes: #7211; merging 7212 ;add groupbyuntil operator to scala adapter;""i have the following use case i create an observable that streams in timestamped data i would like to aggregate this data into distinct sequences based upon time ranges in which the data arrives (first 5 seconds next 5 seconds etc) and have it emitted as completed sequences from an observable to be more explicit lets call the type of my timestamped data observable observable[t] using groupby gives me: observable[(timerange observable[t])] next i can perform a map to remove the timerange component from grouping tuple:observable[observable[t]] then i can use toseq to make the inner-most observable return a single sequence for each groupthis is where i run into trouble since the groupby operator doesnt have a mechanism for """"closing"""" a group the inner most observables will not emit their sequences until all of my timestamped data has been streamed in unless i am mistaken there isnt an easy way to do this with the current set of operators the api provides thoughts? edit: upon reviewing the documentation there is a function called groupbyuntil which appears in rxjava but not in the scala adapter "";""cant you just use observables``` scaladef buffer(timespan: duration): observable[seq[t]]``` || no because i do not necessarily want my data to be streamed in real-time the distinction is that ```def buffer(timespan: duration): observable[seq[t]] ```will only work if my timestamps correspond exactly to the current time my data is streamed in with timestamps attached to it the function above separates the data into groups based upon durations that pass at runtime however i would like to separate my data based upon the time stamps that are part of its signature as i mentioned in my above edit there is a function groupbyuntil which i am fairly certain would solve my problem but it is not yet available in the scala-adapter  || your problem might also be solved using this overload of `buffer`:``` javapublic <topening tclosing> observable<list<t>> buffer(observable<? extends topening> bufferopenings func1<? super topening ? extends observable<? extends tclosing>> bufferclosingselector)```the type parameters `topening` and `tclosing` were recently added and have not yet found their way into the scala adapter and as you said `groupbyuntil` is also missing pull requests are welcome -) || not quite a pull request but here is a solution that works for our purposes:``` scaladef bufferbykey[t k](o: observable[t] keyfunc: t > k): observable[list[t]]   oscan((noneasinstanceof[option[k]]          list()asinstanceof[list[t]]          noneasinstanceof[option[list[t]]])) {  (laststate: (option[k] list[t] option[list[t]]) newval: t) >    val (lastkey acc emit)  laststate    val nk  keyfunc(newval)    lastkey match {      case none > (some(nk) newval :: acc none)      case some(k) >        if (k  nk)          (some(k) newval :: acc none)        else          (some(nk) list(newval) some(acc))    }  } flatmap {    case (_ _ none) > observable()    case (_ _ some(acc)) > observable(accreverse)  }```i think it would be much nicer to build this into the java core with the chunking stuff but oh well this solution also wont emit elements from the last change in keys to the closing of the observable for example``` scalaval o: observable[int]  observable(1 to 11)val x  bufferbykey(o { x: int > x % 3  0 })x subscribe { x > println(""""x  """" + x) }```will output```x  list(1 2)x  list(3)x  list(4 5)x  list(6)x  list(7 8)x  list(9)```(note the absence of 10 and 11) || @samuela nice solution the more im looking into it it looks like almost every function that is being ported from the rxjava code is just a subset of scan and flatmap for instance:```def buffer[t](o: observable[t])(openings: (t)>boolean closings: (tt)>boolean)  {  type s  (boolean option[t] seq[t] boolean)  oscan[s]((false none seq() false)) {case ((open first buffered closing) elem) >    if (open) {      val some(unwrapped_first)  first      val is_closed  closings(unwrapped_first elem)      (!is_closed first elem +: buffered is_closed)    } else {      val is_opened  openings(elem)      if (is_opened) (is_opened some(elem) seq(elem) false)      else (is_opened none seq() false)    }flatmap {case (_ _ buffered closing) > closing match {      case true > observable(buffered reverse)      case false > observable()    }}}```@samuelgruetter have you guys ever thought about replacing some of the other functions in the library with solutions like these it seems like it would be easier for you guys to maintain || > it looks like almost every function that is being ported from the rxjava code is just a subset of scan and flatmaptheoretically yes and as a general rule we want to use existing operators to build other ones whenever it makes sense in fact thats part of the rx design guidelines from rxnetsometimes however its not very efficient to do this as it involves extra levels of abstraction so we dont do it another way of viewing this is that on the outside we want to be functional and immutable in nature but on the inside we often use imperative mutable approaches for performance an example is we have started to make some code less elegant and remove abstractions such as the use of `notification<t>` to improve performance (by quite a lot)all that said ill be the first to state that all operators in rxjava are not yet implemented to the same degree of quality nor are they all as battle-tested as wed like theres a reason were not yet to a 10 releaseim not convinced `buffer` and `window` are completely correct and certainly not convinced that their performance and implementation is as good as it can be i know `groupby` has problems and basically needs a re-write some use a non-locking approach others use locks its the nature of an open-source project with a 20+ contributors and a team improving its understanding of the various operators over time we have chosen to optimize for speed of getting functionality (coverage of operators) into the project and then iterating on improving rather than only allowing 2 or 3 people to slowly try and get through iti was working with @headinthebox (erik meijer) today on an approach for starting to clean up our operator implementations and establish a pattern for all future refactorings and implementations to follow as we are maturing and approaching towards 10 now that weve almost gotten all operators in and have the public api solidifying this will likely involve common patterns for concurrency error handling performance testing etc as right now its been ad-hoc based on who contributed and the intensity of the review done another example is that operators heavily used by the netflix api are far more trusted than ones not used at netflix i hope this provides some backgroundas for this operator missing on the scala side that should be a very easy contribution and now that 0160 is out (which was a big chunk of work) we can quickly iterate on new releases i can push 0161 tomorrow if someone wants to submit the pr for adding `groupbyuntil` to scala || @benjchristensen thank you for the explanation! its reassuring to hear a candid report on the state of the project for those of us interested in contributing to the rxjava project is there any documentation on the implementation that we could use to get started? in terms of this issue specifically is this a method which you would like to be included and if so would solutions like the one i gave previously be acceptable? i suppose that adding such a method to only the scala adapter might be frowned upon is this so? || > i suppose that adding such a method to only the scala adapter might be frowned upon is this so?our goal is for base functionality to be done in rxjava-core so it becomes available to all languages thus we would rather not implement an operator only in one of the language bindings the language bindings should be specific to exposing functionality in an idiomatic manner to that language and/or bridging with libraries and techniques of that language (scala futures for example) thus wed prefer that operators (or other common functionality like schedulers subscriptions etc) be implemented in rxjava-core and then exposed in the scala bindings>  is there any documentation on the implementation that we could use to get startedthis wiki page is a very basic introduction:  is from the beginning of the project though and i think i need to provide a much more detailed document now that lays out the roadmap to 10 plans for graduating language bindings to their own top-level projects patterns for operator implementation etc || certainly that makes sense ok if i get a chance ill try to put a pull request together for this later || thanks @samuela for your involvement we made good progress in 2013 but still have maturation to do and your help is appreciated || @zsxwing is this done yet? if not can you do so in the scala module? || i think this can be closed || "";1;0;3x: compositeexceptionprintstacktrace to write directly into ps/pw;"
7213;1;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;fix intermittently failing unit tests;fix several unit tests that are intermittently failing on slower clients due to timeouts. all fixes;;0;fix intermittently failing unit tests;fix several unit tests that are intermittently failing on slower clients due to timeouts all fixesinvolve increasing timeoutsall other changes are adjustments to formatting within the updated tests; merging 7213 ;;;;1;1;remove formatting/refactoring from previous commitsuperfluous formatting and refactoring was making review impossible;
"7223;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix typo in flowableretrytest.java;;;0;3x: fix typo in flowableretrytestjava;""thank you for contributing to rxjava before pressing the """"create pull request"""" button please consider the following points:  -  please give a description about what and why you are contributing even if its trivial typo below```seperate -> separate```  -  please include the issue list number(s) or other pr numbers in the description if you are contributing in response to those  -  please include a reasonable set of unit tests if you contribute new code or change an existing one if you contribute an operator (if applicable) please make sure you have tests for working with an `empty` `just` `range` of values as well as an `error` source with and/or without backpressure and see if unsubscription/cancellation propagates correctly""; merging 7223 ;;;;1;1;3x: fix typo in flowableretrytestjavaseperate -> separate;"
7272;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: fix copy-paste error in completable javadoc;it was incorrectly referencing  singleobserver  in one of the sentences.;;0;3x: fix copy-paste error in completable javadoc;it was incorrectly referencing `singleobserver` in one of the sentencesresolves: #7271; merging 7272 ;;;;1;1;3x: fix copy-paste error in completable javadoc;
"7274;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;0;0;0;0;0;0;0;3.x: javadoc: fix wording of *onsubscribe interfaces;bad wording:  an instance of a(n) x instance .;;0;3x: javadoc: fix wording of *onsubscribe interfaces;""bad wording: """"an instance of a(n) x instance""""""; merging 7274 ;;;;1;1;3x: javadoc: fix wording of *onsubscribe interfaces;"
"7277;1;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0;0;0;0;0;0;1;0;3.x: fix typo in observableretrytest.java;;;0;3x: fix typo in observableretrytestjava;""thank you for contributing to rxjava before pressing the """"create pull request"""" button please consider the following points:  -  please give a description about what and why you are contributing even if its trivial typo below```seperate -> separate```  -  please include the issue list number(s) or other pr numbers in the description if you are contributing in response to those  -  please include a reasonable set of unit tests if you contribute new code or change an existing one if you contribute an operator (if applicable) please make sure you have tests for working with an `empty` `just` `range` of values as well as an `error` source with and/or without backpressure and see if unsubscription/cancellation propagates correctly""; merging 7277 ;;;;1;1;3x: fix typo in observableretrytestjavaseperate -> separate;"